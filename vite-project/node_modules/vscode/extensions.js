import { IExtensionService } from './vscode/src/vs/workbench/services/extensions/common/extensions.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { getExtensionId } from './vscode/src/vs/platform/extensionManagement/common/extensionManagementUtil.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { localizeManifest } from './vscode/src/vs/platform/extensionManagement/common/extensionNls.js';
import { joinPath } from 'monaco-editor/esm/vs/base/common/resources.js';
import { Schemas, FileAccess } from 'monaco-editor/esm/vs/base/common/network.js';
import { Barrier } from 'monaco-editor/esm/vs/base/common/async.js';
export { ExtensionHostKind } from './vscode/src/vs/workbench/services/extensions/common/extensionHostKind.js';
import { IWorkbenchEnvironmentService } from './vscode/src/vs/workbench/services/environment/common/environmentService.js';
import { getLocalExtHostExtensionService } from './service-override/extensions.js';
import { registerExtensionFile } from './service-override/files.js';
import { setDefaultApi } from './api.js';
import { getService } from './services.js';
const defaultApiInitializeBarrier = new Barrier();
async function initialize() {
    await getLocalExtHostExtensionService().then(async (extHostExtensionService) => {
        setDefaultApi(await extHostExtensionService.getApi());
        defaultApiInitializeBarrier.open();
    });
}
function registerExtensionFileUrl(extensionLocation, filePath, url, mimeType) {
    const fileDisposable = new DisposableStore();
    fileDisposable.add(FileAccess.registerStaticBrowserUri(joinPath(extensionLocation, filePath), ( URI.parse(url))));
    fileDisposable.add(registerExtensionFile(extensionLocation, filePath, async () => {
        const response = await fetch(url, {
            headers: mimeType != null
                ? {
                    Accept: mimeType
                }
                : {}
        });
        if (response.status !== 200) {
            throw new Error(response.statusText);
        }
        return new Uint8Array(await response.arrayBuffer());
    }));
    return fileDisposable;
}
let _toAdd = [];
let _toRemove = [];
let lastPromise;
async function deltaExtensions(toAdd, toRemove) {
    _toAdd.push(...toAdd);
    _toRemove.push(...toRemove);
    if (lastPromise == null) {
        lastPromise = new Promise(resolve => setTimeout(resolve)).then(async () => {
            const extensionService = await getService(IExtensionService);
            await extensionService.deltaExtensions(_toAdd, _toRemove);
            _toAdd = [];
            _toRemove = [];
            lastPromise = undefined;
        });
    }
    await lastPromise;
}
function registerExtension(manifest, extHostKind, { defaultNLS, builtin = manifest.publisher === 'vscode', path = '/' } = {}) {
    const disposableStore = new DisposableStore();
    const localizedManifest = defaultNLS != null ? localizeManifest(manifest, defaultNLS) : manifest;
    const id = getExtensionId(localizedManifest.publisher, localizedManifest.name);
    let extension = {
        manifest: localizedManifest,
        type: builtin ? 0  : 1 ,
        isBuiltin: builtin,
        identifier: { id },
        location: ( URI.from({ scheme: 'extension', authority: id, path })),
        targetPlatform: "web" ,
        isValid: true,
        validations: [],
        extHostKind
    };
    const addExtensionPromise = (async () => {
        if (extHostKind === 3 ) {
            const remoteAuthority = (await getService(IWorkbenchEnvironmentService)).remoteAuthority;
            extension = {
                ...extension,
                location: ( URI.from({ scheme: Schemas.vscodeRemote, authority: remoteAuthority, path }))
            };
        }
        await deltaExtensions([extension], []);
        return extension;
    })();
    let api = {
        id,
        async whenReady() {
            await addExtensionPromise;
        },
        async dispose() {
            const extension = await addExtensionPromise;
            await deltaExtensions([], [extension]);
            disposableStore.dispose();
        }
    };
    if (extHostKind !== 3 ) {
        function registerFileUrl(path, url, mimeType) {
            return registerExtensionFileUrl(extension.location, path, url, mimeType);
        }
        api = {
            ...api,
            registerFileUrl
        };
    }
    if (extHostKind === 1 ) {
        async function getApi() {
            await addExtensionPromise;
            return (await getLocalExtHostExtensionService()).getApi(id);
        }
        api = {
            ...api,
            getApi,
            async setAsDefaultApi() {
                setDefaultApi(await getApi());
            }
        };
    }
    return api;
}
function onExtHostInitialized(fct) {
    void defaultApiInitializeBarrier.wait().then(fct);
}
export { initialize, onExtHostInitialized, registerExtension };
