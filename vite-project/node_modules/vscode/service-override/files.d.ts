import { Emitter, Event } from '../vscode/src/vs/base/common/event.js';
import { URI } from '../vscode/src/vs/base/common/uri.js';
import { Disposable, IDisposable } from '../vscode/src/vs/base/common/lifecycle.js';
import { FileType, IStat, IFileSystemProviderWithFileReadWriteCapability, IFileChange, IFileSystemProvider, FileSystemProviderCapabilities, FileChangeType, IFileWriteOptions, IWatchOptions, IFileDeleteOptions, IFileOverwriteOptions } from '../vscode/src/vs/platform/files/common/files.js';
export { FilePermission, FileSystemProviderError, FileSystemProviderErrorCode } from '../vscode/src/vs/platform/files/common/files.js';
import { IEditorOverrideServices } from '../vscode/src/vs/editor/standalone/browser/standaloneServices.js';
export { InMemoryFileSystemProvider } from '../vscode/src/vs/platform/files/common/inMemoryFilesystemProvider.js';
export { HTMLFileSystemProvider } from '../vscode/src/vs/platform/files/browser/htmlFileSystemProvider.js';

declare abstract class RegisteredFile {
    uri: URI;
    private readonly;
    private ctime;
    private mtime;
    readonly type: FileType;
    protected _onDidChange: Emitter<void>;
    onDidChange: Event<void>;
    protected _onDidDelete: Emitter<void>;
    onDidDelete: Event<void>;
    protected _onDidRename: Emitter<{
        from: URI;
        to: URI;
    }>;
    onDidRename: Event<{
        from: URI;
        to: URI;
    }>;
    constructor(uri: URI, readonly: boolean);
    stats(): Promise<IStat>;
    getSize(): Promise<number>;
    abstract read(): Promise<string | Uint8Array>;
    abstract write(content: string): Promise<void>;
    delete(): Promise<void>;
    rename(to: URI): Promise<void>;
}
declare class RegisteredReadOnlyFile extends RegisteredFile {
    read: () => Promise<string | Uint8Array>;
    constructor(uri: URI, read: () => Promise<string | Uint8Array>);
    write(): Promise<void>;
    delete(): Promise<void>;
    rename(): Promise<void>;
}
declare class RegisteredMemoryFile extends RegisteredFile {
    private content;
    constructor(uri: URI, content: string);
    read(): Promise<string | Uint8Array>;
    write(content: string): Promise<void>;
}
declare class RegisteredFileSystemProvider extends Disposable implements IFileSystemProviderWithFileReadWriteCapability {
    private files;
    capabilities: number;
    constructor(readonly: boolean);
    onDidChangeCapabilities: Event<any>;
    _onDidChangeFile: Emitter<readonly IFileChange[]>;
    onDidChangeFile: Event<readonly IFileChange[]>;
    registerFile(file: RegisteredFile): IDisposable;
    stat(resource: URI): Promise<IStat>;
    readdir(resource: URI): Promise<[string, FileType][]>;
    readFile(resource: URI): Promise<Uint8Array>;
    watch(): IDisposable;
    writeFile(resource: URI, content: Uint8Array): Promise<void>;
    delete(resource: URI): Promise<void>;
    rename(from: URI, to: URI): Promise<void>;
    mkdir(): Promise<never>;
}
declare class DelegateFileSystemProvider implements IFileSystemProvider {
    private options;
    constructor(options: {
        delegate: IFileSystemProvider;
        toDelegate: (uri: URI) => URI;
        fromDeletate: (uri: URI) => URI;
    });
    get capabilities(): FileSystemProviderCapabilities;
    onDidChangeCapabilities: Event<void>;
    onDidChangeFile: Event<{
        type: FileChangeType;
        resource: URI;
    }[]>;
    readFile: ((resource: URI) => Promise<Uint8Array>) | undefined;
    writeFile: ((resource: URI, content: Uint8Array, opts: IFileWriteOptions) => Promise<void>) | undefined;
    watch(resource: URI, opts: IWatchOptions): IDisposable;
    stat(resource: URI): Promise<IStat>;
    mkdir(resource: URI): Promise<void>;
    readdir(resource: URI): Promise<[string, FileType][]>;
    delete(resource: URI, opts: IFileDeleteOptions): Promise<void>;
    rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;
}
declare function getServiceOverride(): IEditorOverrideServices;
declare function registerExtensionFile(extensionLocation: URI, filePath: string, getContent: () => Promise<string | Uint8Array>): IDisposable;
/**
 * Register a file system overlay
 *
 * By default, a memory filesystem is used to read and write file
 *
 * This method allows to register another fileSystemProvider in front OR behind the default memory one.
 *
 * The default one is registered as priority: 0, so:
 * - any provider registered with a positive priority will be in front of the default one
 * - any provider registered with a negative priority will be behind the default one
 */
declare function registerFileSystemOverlay(priority: number, provider: IFileSystemProviderWithFileReadWriteCapability): IDisposable;

export { DelegateFileSystemProvider, FileChangeType, FileSystemProviderCapabilities, FileType, IFileChange, IFileDeleteOptions, IFileOverwriteOptions, IFileSystemProviderWithFileReadWriteCapability, IFileWriteOptions, IStat, IWatchOptions, RegisteredFile, RegisteredFileSystemProvider, RegisteredMemoryFile, RegisteredReadOnlyFile, getServiceOverride as default, registerExtensionFile, registerFileSystemOverlay };
