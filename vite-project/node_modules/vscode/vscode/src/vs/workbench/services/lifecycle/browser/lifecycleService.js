import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { AbstractLifecycleService } from '../common/lifecycleService.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { addDisposableListener, EventType } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { WillSaveStateReason, IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
let BrowserLifecycleService = class BrowserLifecycleService extends AbstractLifecycleService {
    constructor(logService, storageService) {
        super(logService, storageService);
        this.beforeUnloadListener = undefined;
        this.unloadListener = undefined;
        this.ignoreBeforeUnload = false;
        this.didUnload = false;
        this.registerListeners();
    }
    registerListeners() {
        this.beforeUnloadListener = addDisposableListener(window, EventType.BEFORE_UNLOAD, (e) => this.onBeforeUnload(e));
        this.unloadListener = addDisposableListener(window, EventType.PAGE_HIDE, () => this.onUnload());
    }
    onBeforeUnload(event) {
        if (this.ignoreBeforeUnload) {
            this.logService.info('[lifecycle] onBeforeUnload triggered but ignored once');
            this.ignoreBeforeUnload = false;
        }
        else {
            this.logService.info('[lifecycle] onBeforeUnload triggered and handled with veto support');
            this.doShutdown(() => this.vetoBeforeUnload(event));
        }
    }
    vetoBeforeUnload(event) {
        event.preventDefault();
        event.returnValue = ( localize(
            'lifecycleVeto',
            "Changes that you made may not be saved. Please check press 'Cancel' and try again."
        ));
    }
    withExpectedShutdown(reason, callback) {
        if (typeof reason === 'number') {
            this.shutdownReason = reason;
            return this.storageService.flush(WillSaveStateReason.SHUTDOWN);
        }
        else {
            this.ignoreBeforeUnload = true;
            try {
                callback?.();
            }
            finally {
                this.ignoreBeforeUnload = false;
            }
        }
    }
    async shutdown() {
        this.logService.info('[lifecycle] shutdown triggered');
        this.beforeUnloadListener?.dispose();
        this.unloadListener?.dispose();
        await this.storageService.flush(WillSaveStateReason.SHUTDOWN);
        this.doShutdown();
    }
    doShutdown(vetoShutdown) {
        const logService = this.logService;
        this.storageService.flush(WillSaveStateReason.SHUTDOWN);
        let veto = false;
        function handleVeto(vetoResult, id) {
            if (typeof vetoShutdown !== 'function') {
                return;
            }
            if (vetoResult instanceof Promise) {
                logService.error(`[lifecycle] Long running operations before shutdown are unsupported in the web (id: ${id})`);
                veto = true;
            }
            if (vetoResult === true) {
                logService.info(`[lifecycle]: Unload was prevented (id: ${id})`);
                veto = true;
            }
        }
        this._onBeforeShutdown.fire({
            reason: 2 ,
            veto(value, id) {
                handleVeto(value, id);
            },
            finalVeto(valueFn, id) {
                handleVeto(valueFn(), id);
            }
        });
        if (veto && typeof vetoShutdown === 'function') {
            return vetoShutdown();
        }
        return this.onUnload();
    }
    onUnload() {
        if (this.didUnload) {
            return;
        }
        this.didUnload = true;
        this._register(addDisposableListener(window, EventType.PAGE_SHOW, (e) => this.onLoadAfterUnload(e)));
        const logService = this.logService;
        this._onWillShutdown.fire({
            reason: 2 ,
            joiners: () => [],
            token: CancellationToken.None,
            join(promise, joiner) {
                logService.error(`[lifecycle] Long running operations during shutdown are unsupported in the web (id: ${joiner.id})`);
            },
            force: () => { },
        });
        this._onDidShutdown.fire();
    }
    onLoadAfterUnload(event) {
        const wasRestoredFromCache = event.persisted;
        if (!wasRestoredFromCache) {
            return;
        }
        this.withExpectedShutdown({ disableShutdownHandling: true }, () => window.location.reload());
    }
};
BrowserLifecycleService = ( __decorate([
    ( __param(0, ILogService)),
    ( __param(1, IStorageService))
], BrowserLifecycleService));
export { BrowserLifecycleService };
