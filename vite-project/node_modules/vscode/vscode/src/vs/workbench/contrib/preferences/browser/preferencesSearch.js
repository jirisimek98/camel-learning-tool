import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { SettingMatchType } from '../../../services/preferences/common/preferences.js';
import { distinct } from 'monaco-editor/esm/vs/base/common/arrays.js';
import * as strings from 'monaco-editor/esm/vs/base/common/strings.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { matchesWords, or, matchesCamelCase, matchesContiguousSubString, matchesPrefix } from 'monaco-editor/esm/vs/base/common/filters.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IExtensionManagementService } from '../../../../platform/extensionManagement/common/extensionManagement.js';
import { IWorkbenchExtensionEnablementService } from '../../../services/extensionManagement/common/extensionManagement.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { RelatedInformationType, IAiRelatedInformationService } from '../../../services/aiRelatedInformation/common/aiRelatedInformation.js';
var LocalSearchProvider_1, SettingMatches_1, RemoteSearchProvider_1;
let PreferencesSearchService = class PreferencesSearchService extends Disposable {
    constructor(instantiationService, configurationService, extensionManagementService, extensionEnablementService) {
        super();
        this.instantiationService = instantiationService;
        this.configurationService = configurationService;
        this.extensionManagementService = extensionManagementService;
        this.extensionEnablementService = extensionEnablementService;
        this._installedExtensions = this.extensionManagementService.getInstalled(1 ).then(exts => {
            return exts
                .filter(ext => this.extensionEnablementService.isEnabled(ext))
                .filter(ext => ext.manifest && ext.manifest.contributes && ext.manifest.contributes.configuration)
                .filter(ext => !!ext.identifier.uuid);
        });
    }
    get remoteSearchAllowed() {
        const workbenchSettings = this.configurationService.getValue().workbench.settings;
        return workbenchSettings.enableNaturalLanguageSearch;
    }
    getRemoteSearchProvider(filter, newExtensionsOnly = false) {
        if (!this.remoteSearchAllowed) {
            return undefined;
        }
        if (!this._remoteSearchProvider) {
            this._remoteSearchProvider = this.instantiationService.createInstance(RemoteSearchProvider);
        }
        this._remoteSearchProvider.setFilter(filter);
        return this._remoteSearchProvider;
    }
    getLocalSearchProvider(filter) {
        return this.instantiationService.createInstance(LocalSearchProvider, filter);
    }
};
PreferencesSearchService = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IConfigurationService)),
    ( __param(2, IExtensionManagementService)),
    ( __param(3, IWorkbenchExtensionEnablementService))
], PreferencesSearchService));
function cleanFilter(filter) {
    return filter
        .replace(/[":]/g, ' ')
        .replace(/  /g, ' ')
        .trim();
}
let LocalSearchProvider = class LocalSearchProvider {
    static { LocalSearchProvider_1 = this; }
    static { this.EXACT_MATCH_SCORE = 10000; }
    static { this.START_SCORE = 1000; }
    constructor(_filter, configurationService) {
        this._filter = _filter;
        this.configurationService = configurationService;
        this._filter = cleanFilter(this._filter);
    }
    searchModel(preferencesModel, token) {
        if (!this._filter) {
            return Promise.resolve(null);
        }
        let orderedScore = LocalSearchProvider_1.START_SCORE;
        const settingMatcher = (setting) => {
            const { matches, matchType } = ( new SettingMatches(
                this._filter,
                setting,
                true,
                true,
                (filter, setting) => preferencesModel.findValueMatches(filter, setting),
                this.configurationService
            ));
            const score = this._filter === setting.key ?
                LocalSearchProvider_1.EXACT_MATCH_SCORE :
                orderedScore--;
            return matches && matches.length ?
                {
                    matches,
                    matchType,
                    score
                } :
                null;
        };
        const filterMatches = preferencesModel.filterSettings(this._filter, this.getGroupFilter(this._filter), settingMatcher);
        if (filterMatches[0] && filterMatches[0].score === LocalSearchProvider_1.EXACT_MATCH_SCORE) {
            return Promise.resolve({
                filterMatches: filterMatches.slice(0, 1),
                exactMatch: true
            });
        }
        else {
            return Promise.resolve({
                filterMatches
            });
        }
    }
    getGroupFilter(filter) {
        const regex = strings.createRegExp(filter, false, { global: true });
        return (group) => {
            return regex.test(group.title);
        };
    }
};
LocalSearchProvider = LocalSearchProvider_1 = ( __decorate([
    ( __param(1, IConfigurationService))
], LocalSearchProvider));
let SettingMatches = SettingMatches_1 = class SettingMatches {
    constructor(searchString, setting, requireFullQueryMatch, searchDescription, valuesMatcher, configurationService) {
        this.requireFullQueryMatch = requireFullQueryMatch;
        this.searchDescription = searchDescription;
        this.valuesMatcher = valuesMatcher;
        this.configurationService = configurationService;
        this.descriptionMatchingWords = ( new Map());
        this.keyMatchingWords = ( new Map());
        this.valueMatchingWords = ( new Map());
        this.matchType = SettingMatchType.None;
        this.matches = distinct(this._findMatchesInSetting(searchString, setting), (match) => `${match.startLineNumber}_${match.startColumn}_${match.endLineNumber}_${match.endColumn}_`);
    }
    _findMatchesInSetting(searchString, setting) {
        const result = this._doFindMatchesInSetting(searchString, setting);
        if (setting.overrides && setting.overrides.length) {
            for (const subSetting of setting.overrides) {
                const subSettingMatches = ( new SettingMatches_1(
                    searchString,
                    subSetting,
                    this.requireFullQueryMatch,
                    this.searchDescription,
                    this.valuesMatcher,
                    this.configurationService
                ));
                const words = searchString.split(' ');
                const descriptionRanges = this.getRangesForWords(words, this.descriptionMatchingWords, [subSettingMatches.descriptionMatchingWords, subSettingMatches.keyMatchingWords, subSettingMatches.valueMatchingWords]);
                const keyRanges = this.getRangesForWords(words, this.keyMatchingWords, [subSettingMatches.descriptionMatchingWords, subSettingMatches.keyMatchingWords, subSettingMatches.valueMatchingWords]);
                const subSettingKeyRanges = this.getRangesForWords(words, subSettingMatches.keyMatchingWords, [this.descriptionMatchingWords, this.keyMatchingWords, subSettingMatches.valueMatchingWords]);
                const subSettingValueRanges = this.getRangesForWords(words, subSettingMatches.valueMatchingWords, [this.descriptionMatchingWords, this.keyMatchingWords, subSettingMatches.keyMatchingWords]);
                result.push(...descriptionRanges, ...keyRanges, ...subSettingKeyRanges, ...subSettingValueRanges);
                result.push(...subSettingMatches.matches);
                this.refreshMatchType(keyRanges.length + subSettingKeyRanges.length);
                this.matchType |= subSettingMatches.matchType;
            }
        }
        return result;
    }
    _doFindMatchesInSetting(searchString, setting) {
        const registry = ( Registry.as(Extensions.Configuration)).getConfigurationProperties();
        const schema = registry[setting.key];
        const words = searchString.split(' ');
        const settingKeyAsWords = setting.key.split('.').join(' ');
        const settingValue = this.configurationService.getValue(setting.key);
        for (const word of words) {
            if (this.searchDescription) {
                for (let lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {
                    const descriptionMatches = matchesWords(word, setting.description[lineIndex], true);
                    if (descriptionMatches) {
                        this.descriptionMatchingWords.set(word, ( descriptionMatches.map(match => this.toDescriptionRange(setting, match, lineIndex))));
                    }
                    this.checkForWholeWordMatchType(word, setting.description[lineIndex]);
                }
            }
            const keyMatches = or(matchesWords, matchesCamelCase)(word, settingKeyAsWords);
            if (keyMatches) {
                this.keyMatchingWords.set(word, ( keyMatches.map(match => this.toKeyRange(setting, match))));
            }
            this.checkForWholeWordMatchType(word, settingKeyAsWords);
            const valueMatches = typeof settingValue === 'string' ? matchesContiguousSubString(word, settingValue) : null;
            if (valueMatches) {
                this.valueMatchingWords.set(word, ( valueMatches.map(match => this.toValueRange(setting, match))));
            }
            else if (schema && schema.enum && ( schema.enum.some(
                enumValue => typeof enumValue === 'string' && !!matchesContiguousSubString(word, enumValue)
            ))) {
                this.valueMatchingWords.set(word, []);
            }
            if (typeof settingValue === 'string') {
                this.checkForWholeWordMatchType(word, settingValue);
            }
        }
        const descriptionRanges = [];
        if (this.searchDescription) {
            for (let lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {
                const matches = or(matchesContiguousSubString)(searchString, setting.description[lineIndex] || '') || [];
                descriptionRanges.push(...( matches.map(match => this.toDescriptionRange(setting, match, lineIndex))));
            }
            if (descriptionRanges.length === 0) {
                descriptionRanges.push(...this.getRangesForWords(words, this.descriptionMatchingWords, [this.keyMatchingWords, this.valueMatchingWords]));
            }
        }
        const keyMatches = or(matchesPrefix, matchesContiguousSubString)(searchString, setting.key);
        const keyRanges = keyMatches ? ( keyMatches.map(match => this.toKeyRange(setting, match))) : this.getRangesForWords(words, this.keyMatchingWords, [this.descriptionMatchingWords, this.valueMatchingWords]);
        let valueRanges = [];
        if (typeof settingValue === 'string' && settingValue) {
            const valueMatches = or(matchesPrefix, matchesContiguousSubString)(searchString, settingValue);
            valueRanges = valueMatches ? ( valueMatches.map(match => this.toValueRange(setting, match))) : this.getRangesForWords(words, this.valueMatchingWords, [this.keyMatchingWords, this.descriptionMatchingWords]);
        }
        else {
            valueRanges = this.valuesMatcher(searchString, setting);
        }
        this.refreshMatchType(keyRanges.length);
        return [...descriptionRanges, ...keyRanges, ...valueRanges];
    }
    checkForWholeWordMatchType(singleWordQuery, lineToSearch) {
        singleWordQuery = singleWordQuery.toLowerCase().replace(/[\s-\._]+$/, '');
        lineToSearch = lineToSearch.toLowerCase();
        const singleWordRegex = ( new RegExp(`\\b${strings.escapeRegExpCharacters(singleWordQuery)}\\b`));
        if (singleWordRegex.test(lineToSearch)) {
            this.matchType |= SettingMatchType.WholeWordMatch;
        }
    }
    refreshMatchType(keyRangesLength) {
        if (keyRangesLength) {
            this.matchType |= SettingMatchType.KeyMatch;
        }
    }
    getRangesForWords(words, from, others) {
        const result = [];
        for (const word of words) {
            const ranges = from.get(word);
            if (ranges) {
                result.push(...ranges);
            }
            else if (this.requireFullQueryMatch && others.every(o => !( o.has(word)))) {
                return [];
            }
        }
        return result;
    }
    toKeyRange(setting, match) {
        return {
            startLineNumber: setting.keyRange.startLineNumber,
            startColumn: setting.keyRange.startColumn + match.start,
            endLineNumber: setting.keyRange.startLineNumber,
            endColumn: setting.keyRange.startColumn + match.end
        };
    }
    toDescriptionRange(setting, match, lineIndex) {
        return {
            startLineNumber: setting.descriptionRanges[lineIndex].startLineNumber,
            startColumn: setting.descriptionRanges[lineIndex].startColumn + match.start,
            endLineNumber: setting.descriptionRanges[lineIndex].endLineNumber,
            endColumn: setting.descriptionRanges[lineIndex].startColumn + match.end
        };
    }
    toValueRange(setting, match) {
        return {
            startLineNumber: setting.valueRange.startLineNumber,
            startColumn: setting.valueRange.startColumn + match.start + 1,
            endLineNumber: setting.valueRange.startLineNumber,
            endColumn: setting.valueRange.startColumn + match.end + 1
        };
    }
};
SettingMatches = SettingMatches_1 = ( __decorate([
    ( __param(5, IConfigurationService))
], SettingMatches));
class RemoteSearchKeysProvider {
    constructor(aiRelatedInformationService) {
        this.aiRelatedInformationService = aiRelatedInformationService;
        this.settingKeys = [];
        this.settingsRecord = {};
    }
    updateModel(preferencesModel) {
        if (preferencesModel === this.currentPreferencesModel) {
            return;
        }
        this.currentPreferencesModel = preferencesModel;
        this.refresh();
    }
    refresh() {
        this.settingKeys = [];
        this.settingsRecord = {};
        if (!this.currentPreferencesModel ||
            !this.aiRelatedInformationService.isEnabled()) {
            return;
        }
        for (const group of this.currentPreferencesModel.settingsGroups) {
            if (group.id === 'mostCommonlyUsed') {
                continue;
            }
            for (const section of group.sections) {
                for (const setting of section.settings) {
                    this.settingKeys.push(setting.key);
                    this.settingsRecord[setting.key] = setting;
                }
            }
        }
    }
    getSettingKeys() {
        return this.settingKeys;
    }
    getSettingsRecord() {
        return this.settingsRecord;
    }
}
let RemoteSearchProvider = class RemoteSearchProvider {
    static { RemoteSearchProvider_1 = this; }
    static { this.AI_RELATED_INFORMATION_THRESHOLD = 0.73; }
    static { this.AI_RELATED_INFORMATION_MAX_PICKS = 15; }
    constructor(aiRelatedInformationService) {
        this.aiRelatedInformationService = aiRelatedInformationService;
        this._filter = '';
        this._keysProvider = ( new RemoteSearchKeysProvider(aiRelatedInformationService));
    }
    setFilter(filter) {
        this._filter = cleanFilter(filter);
    }
    async searchModel(preferencesModel, token) {
        if (!this._filter ||
            !this.aiRelatedInformationService.isEnabled()) {
            return null;
        }
        this._keysProvider.updateModel(preferencesModel);
        return {
            filterMatches: await this.getAiRelatedInformationItems(token)
        };
    }
    async getAiRelatedInformationItems(token) {
        const settingsRecord = this._keysProvider.getSettingsRecord();
        const filterMatches = [];
        const relatedInformation = await this.aiRelatedInformationService.getRelatedInformation(this._filter, [RelatedInformationType.SettingInformation], token ?? CancellationToken.None);
        relatedInformation.sort((a, b) => b.weight - a.weight);
        for (const info of relatedInformation) {
            if (info.weight < RemoteSearchProvider_1.AI_RELATED_INFORMATION_THRESHOLD || filterMatches.length === RemoteSearchProvider_1.AI_RELATED_INFORMATION_MAX_PICKS) {
                break;
            }
            const pick = info.setting;
            filterMatches.push({
                setting: settingsRecord[pick],
                matches: [settingsRecord[pick].range],
                matchType: SettingMatchType.RemoteMatch,
                score: info.weight
            });
        }
        return filterMatches;
    }
};
RemoteSearchProvider = RemoteSearchProvider_1 = ( __decorate([
    ( __param(0, IAiRelatedInformationService))
], RemoteSearchProvider));
export { LocalSearchProvider, PreferencesSearchService, RemoteSearchProvider, SettingMatches };
