import { __decorate, __param } from '../../../../../../../../external/tslib/tslib.es6.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { EditorExtensionsRegistry } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { CodeEditorWidget } from 'monaco-editor/esm/vs/editor/browser/widget/codeEditorWidget.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { getSimpleEditorOptions } from '../../../codeEditor/browser/simpleEditorOptions.js';
import { ITerminalService } from '../../../terminal/browser/terminal.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { CodeActionController } from 'monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionController.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
let TerminalAccessibleWidget = class TerminalAccessibleWidget extends DisposableStore {
    get element() { return this._element; }
    get editorWidget() { return this._editorWidget; }
    constructor(_className, _instance, _xterm, rawFocusContextKey, rawFocusLastLineContextKey, _instantiationService, _modelService, _configurationService, _contextKeyService, _terminalService) {
        super();
        this._className = _className;
        this._instance = _instance;
        this._xterm = _xterm;
        this._instantiationService = _instantiationService;
        this._modelService = _modelService;
        this._configurationService = _configurationService;
        this._contextKeyService = _contextKeyService;
        this._terminalService = _terminalService;
        this._listeners = [];
        this._xtermElement = _xterm.raw.element;
        this._element = document.createElement('div');
        this._element.setAttribute('role', 'document');
        this._element.classList.add(_className);
        this._element.classList.add("terminal-accessible-widget" );
        this._editorContainer = document.createElement('div');
        const codeEditorWidgetOptions = {
            contributions: EditorExtensionsRegistry.getEditorContributions().filter(c => c.id !== CodeActionController.ID)
        };
        const font = _xterm.getFont();
        const editorOptions = {
            ...getSimpleEditorOptions(this._configurationService),
            lineDecorationsWidth: 6,
            dragAndDrop: true,
            cursorWidth: 1,
            fontSize: font.fontSize,
            lineHeight: font.charHeight ? font.charHeight * font.lineHeight : 1,
            letterSpacing: font.letterSpacing,
            fontFamily: font.fontFamily,
            wrappingStrategy: 'advanced',
            wrappingIndent: 'none',
            padding: { top: 2, bottom: 2 },
            quickSuggestions: false,
            renderWhitespace: 'none',
            dropIntoEditor: { enabled: true },
            readOnly: true,
            ariaLabel: ( localize('terminalAccessibleBuffer', "Terminal Buffer"))
        };
        this._editorWidget = this.add(this._instantiationService.createInstance(CodeEditorWidget, this._editorContainer, editorOptions, codeEditorWidgetOptions));
        this._element.replaceChildren(this._editorContainer);
        this._xtermElement.insertAdjacentElement('beforebegin', this._element);
        this._focusTracker = this.add(dom.trackFocus(this._editorContainer));
        this._focusedContextKey = rawFocusContextKey.bindTo(this._contextKeyService);
        this._focusedLastLineContextKey = rawFocusLastLineContextKey.bindTo(this._contextKeyService);
        this.add(this._focusTracker.onDidFocus(() => {
            this._focusedContextKey?.set(true);
            this._focusedLastLineContextKey?.set(this._editorWidget.getSelection()?.positionLineNumber === this._editorWidget.getModel()?.getLineCount());
        }));
        this.add(this._focusTracker.onDidBlur(() => {
            this._focusedContextKey?.reset();
            this._focusedLastLineContextKey?.reset();
        }));
        this._editorWidget.onDidChangeCursorPosition(() => {
            console.log(this._editorWidget.getSelection()?.positionLineNumber === this._editorWidget.getModel()?.getLineCount());
            this._focusedLastLineContextKey?.set(this._editorWidget.getSelection()?.positionLineNumber === this._editorWidget.getModel()?.getLineCount());
        });
        this.add(Event.runAndSubscribe(this._xterm.raw.onResize, () => this.layout()));
        this.add(this._configurationService.onDidChangeConfiguration(e => {
            if (( e.affectedKeys.has("terminal.integrated.fontFamily" )) || ( e.affectedKeys.has("terminal.integrated.fontSize" )) || ( e.affectedKeys.has("terminal.integrated.lineHeight" )) || ( e.affectedKeys.has("terminal.integrated.letterSpacing" ))) {
                const font = this._xterm.getFont();
                this._editorWidget.updateOptions({ fontFamily: font.fontFamily, fontSize: font.fontSize, lineHeight: font.charHeight ? font.charHeight * font.lineHeight : 1, letterSpacing: font.letterSpacing });
            }
        }));
        this.add(this._editorWidget.onKeyDown((e) => {
            switch (e.keyCode) {
                case 9 :
                    this.hide(true);
                    break;
            }
        }));
        this.add(this._editorWidget.onDidFocusEditorText(async () => {
            this._terminalService.setActiveInstance(this._instance);
            this._xtermElement.classList.add("hide" );
        }));
        this.add(this._editorWidget.onDidBlurEditorText(async () => this.hide()));
    }
    registerListeners() {
        this._listeners.push(this._instance.onDidRequestFocus(() => this.editorWidget.focus()));
    }
    layout() {
        this._editorWidget.layout({ width: this._xtermElement.clientWidth, height: this._xtermElement.clientHeight });
    }
    async show() {
        this.registerListeners();
        await this.updateEditor();
        this.element.tabIndex = -1;
        this.layout();
        this.element.classList.add("active" );
        this._xtermElement.classList.add("hide" );
        this.editorWidget.focus();
    }
    dispose() {
        this._disposeListeners();
        super.dispose();
    }
    _disposeListeners() {
        for (const listener of this._listeners) {
            listener.dispose();
        }
    }
    hide(focusXterm) {
        this._disposeListeners();
        this.element.classList.remove("active" );
        this._xtermElement.classList.remove("hide" );
        if (focusXterm) {
            this._xterm.raw.focus();
        }
    }
    async getTextModel(resource) {
        const existing = this._modelService.getModel(resource);
        if (existing && !existing.isDisposed()) {
            return existing;
        }
        return this._modelService.createModel(`${this._className}-${resource.fragment}`, null, resource, false);
    }
};
TerminalAccessibleWidget = ( __decorate([
    ( __param(5, IInstantiationService)),
    ( __param(6, IModelService)),
    ( __param(7, IConfigurationService)),
    ( __param(8, IContextKeyService)),
    ( __param(9, ITerminalService))
], TerminalAccessibleWidget));
export { TerminalAccessibleWidget };
