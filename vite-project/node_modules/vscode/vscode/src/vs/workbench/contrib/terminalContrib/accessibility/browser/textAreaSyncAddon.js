import { __decorate, __param } from '../../../../../../../../external/tslib/tslib.es6.js';
import { Disposable, MutableDisposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IAccessibilityService } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
import { ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';
import { debounce } from 'monaco-editor/esm/vs/base/common/decorators.js';
import { addDisposableListener } from 'monaco-editor/esm/vs/base/browser/dom.js';
let TextAreaSyncAddon = class TextAreaSyncAddon extends Disposable {
    activate(terminal) {
        this._terminal = terminal;
        if (this._accessibilityService.isScreenReaderOptimized()) {
            this._registerSyncListeners();
        }
    }
    constructor(_capabilities, _accessibilityService, _logService) {
        super();
        this._capabilities = _capabilities;
        this._accessibilityService = _accessibilityService;
        this._logService = _logService;
        this._listeners = this._register(( new MutableDisposable()));
        this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => {
            if (this._accessibilityService.isScreenReaderOptimized()) {
                this._syncTextArea();
                this._registerSyncListeners();
            }
            else {
                this._listeners.clear();
            }
        }));
    }
    _registerSyncListeners() {
        if (this._accessibilityService.isScreenReaderOptimized() && this._terminal?.textarea) {
            this._listeners.value = ( new DisposableStore());
            this._listeners.value.add(this._terminal.onCursorMove(() => this._syncTextArea()));
            this._listeners.value.add(this._terminal.onData(() => this._syncTextArea()));
            this._listeners.value.add(addDisposableListener(this._terminal.textarea, 'focus', () => this._syncTextArea()));
        }
    }
    _syncTextArea() {
        this._logService.debug('TextAreaSyncAddon#syncTextArea');
        const textArea = this._terminal?.textarea;
        if (!textArea) {
            this._logService.debug(`TextAreaSyncAddon#syncTextArea: no textarea`);
            return;
        }
        this._updateCommandAndCursor();
        if (this._currentCommand !== textArea.value) {
            textArea.value = this._currentCommand || '';
            this._logService.debug(`TextAreaSyncAddon#syncTextArea: text changed to "${this._currentCommand}"`);
        }
        else if (!this._currentCommand) {
            textArea.value = '';
            this._logService.debug(`TextAreaSyncAddon#syncTextArea: text cleared`);
        }
        if (this._cursorX !== textArea.selectionStart) {
            textArea.selectionStart = this._cursorX ?? 0;
            textArea.selectionEnd = this._cursorX ?? 0;
            this._logService.debug(`TextAreaSyncAddon#syncTextArea: selection start/end changed to ${this._cursorX}`);
        }
    }
    _updateCommandAndCursor() {
        if (!this._terminal) {
            return;
        }
        const commandCapability = this._capabilities.get(2 );
        const currentCommand = commandCapability?.currentCommand;
        if (!currentCommand) {
            this._logService.debug(`TextAreaSyncAddon#updateCommandAndCursor: no current command`);
            return;
        }
        const buffer = this._terminal.buffer.active;
        const lineNumber = currentCommand.commandStartMarker?.line;
        if (!lineNumber) {
            return;
        }
        const commandLine = buffer.getLine(lineNumber)?.translateToString(true);
        if (!commandLine) {
            this._logService.debug(`TextAreaSyncAddon#updateCommandAndCursor: no line`);
            return;
        }
        if (currentCommand.commandStartX !== undefined) {
            this._currentCommand = commandLine.substring(currentCommand.commandStartX);
            this._cursorX = buffer.cursorX - currentCommand.commandStartX;
        }
        else {
            this._currentCommand = undefined;
            this._cursorX = undefined;
            this._logService.debug(`TextAreaSyncAddon#updateCommandAndCursor: no commandStartX`);
        }
    }
};
TextAreaSyncAddon.__decorator = ( __decorate([
    debounce(50)
], TextAreaSyncAddon.prototype, "_syncTextArea", null));
TextAreaSyncAddon = ( __decorate([
    ( __param(1, IAccessibilityService)),
    ( __param(2, ITerminalLogService))
], TextAreaSyncAddon));
export { TextAreaSyncAddon };
