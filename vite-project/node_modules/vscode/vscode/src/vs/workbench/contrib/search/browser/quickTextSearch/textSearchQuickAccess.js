import { __decorate, __param } from '../../../../../../../../external/tslib/tslib.es6.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { basenameOrAuthority, dirname } from 'monaco-editor/esm/vs/base/common/resources.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { getSelectionKeyboardEvent } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { PickerQuickAccessProvider } from 'monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js';
import { DefaultQuickAccessFilterValue } from 'monaco-editor/esm/vs/platform/quickinput/common/quickAccess.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { IViewsService } from '../../../../common/views.js';
import { searchDetailsIcon, searchOpenInFileIcon } from '../searchIcons.js';
import { SearchModel, searchComparer, MatchInNotebook } from '../searchModel.js';
import { getEditorSelectionFromMatch } from '../searchView.js';
import { getOutOfWorkspaceEditorResources } from '../../common/search.js';
import { SIDE_GROUP, ACTIVE_GROUP, IEditorService } from '../../../../services/editor/common/editorService.js';
import { QueryBuilder } from '../../../../services/search/common/queryBuilder.js';
import { VIEW_ID } from '../../../../services/search/common/search.js';
const TEXT_SEARCH_QUICK_ACCESS_PREFIX = '% ';
const DEFAULT_TEXT_QUERY_BUILDER_OPTIONS = {
    _reason: 'quickAccessSearch',
    disregardIgnoreFiles: false,
    disregardExcludeSettings: false,
    onlyOpenEditors: false,
    expandPatterns: true
};
const MAX_FILES_SHOWN = 30;
const MAX_RESULTS_PER_FILE = 10;
let TextSearchQuickAccess = class TextSearchQuickAccess extends PickerQuickAccessProvider {
    _getTextQueryBuilderOptions(charsPerLine) {
        return {
            ...DEFAULT_TEXT_QUERY_BUILDER_OPTIONS,
            ...{
                extraFileResources: this._instantiationService.invokeFunction(getOutOfWorkspaceEditorResources),
                maxResults: this.configuration.maxResults ?? undefined,
                isSmartCase: this.configuration.smartCase,
            },
            previewOptions: {
                matchLines: 1,
                charsPerLine
            }
        };
    }
    constructor(_instantiationService, _contextService, _editorService, _labelService, _viewsService, _configurationService) {
        super(TEXT_SEARCH_QUICK_ACCESS_PREFIX, { canAcceptInBackground: true });
        this._instantiationService = _instantiationService;
        this._contextService = _contextService;
        this._editorService = _editorService;
        this._labelService = _labelService;
        this._viewsService = _viewsService;
        this._configurationService = _configurationService;
        this.queryBuilder = this._instantiationService.createInstance(QueryBuilder);
        this.searchModel = this._instantiationService.createInstance(SearchModel);
    }
    dispose() {
        this.searchModel.dispose();
        super.dispose();
    }
    provide(picker, token, runOptions) {
        const disposables = ( new DisposableStore());
        disposables.add(super.provide(picker, token, runOptions));
        disposables.add(picker.onDidHide(() => this.searchModel.searchResult.toggleHighlights(false)));
        disposables.add(picker.onDidAccept(() => this.searchModel.searchResult.toggleHighlights(false)));
        return disposables;
    }
    get configuration() {
        const editorConfig = this._configurationService.getValue().workbench?.editor;
        const searchConfig = this._configurationService.getValue().search;
        return {
            openEditorPinned: !editorConfig?.enablePreviewFromQuickOpen || !editorConfig?.enablePreview,
            preserveInput: searchConfig.experimental.quickAccess.preserveInput,
            maxResults: searchConfig.maxResults,
            smartCase: searchConfig.smartCase,
        };
    }
    get defaultFilterValue() {
        if (this.configuration.preserveInput) {
            return DefaultQuickAccessFilterValue.LAST;
        }
        return undefined;
    }
    doSearch(contentPattern, token) {
        if (contentPattern === '') {
            return undefined;
        }
        const folderResources = this._contextService.getWorkspace().folders;
        const content = {
            pattern: contentPattern,
        };
        const charsPerLine = content.isRegExp ? 10000 : 1000;
        const query = this.queryBuilder.text(content, ( folderResources.map(folder => folder.uri)), this._getTextQueryBuilderOptions(charsPerLine));
        const result = this.searchModel.search(query, undefined, token);
        const getAsyncResults = async () => {
            await result.asyncResults;
            return this.searchModel.searchResult.matches().filter(e => result.syncResults.indexOf(e) === -1);
        };
        return {
            syncResults: this.searchModel.searchResult.matches(),
            asyncResults: getAsyncResults()
        };
    }
    moveToSearchViewlet(model, currentElem) {
        this._viewsService.openView(VIEW_ID, false);
        const viewlet = this._viewsService.getActiveViewWithId(VIEW_ID);
        viewlet.importSearchResult(model);
        const viewer = viewlet?.getControl();
        viewer.setFocus([currentElem], getSelectionKeyboardEvent());
        viewer.setSelection([currentElem], getSelectionKeyboardEvent());
        viewer.reveal(currentElem);
    }
    _getPicksFromMatches(matches, limit) {
        matches = matches.sort(searchComparer);
        const files = matches.length > limit ? matches.slice(0, limit) : matches;
        const picks = [];
        for (let fileIndex = 0; fileIndex < matches.length; fileIndex++) {
            if (fileIndex === limit) {
                picks.push({
                    type: 'separator',
                });
                picks.push({
                    label: ( localize('QuickSearchSeeMoreFiles', "See More Files")),
                    iconClass: ThemeIcon.asClassName(searchDetailsIcon),
                    accept: async () => {
                        this.moveToSearchViewlet(this.searchModel, matches[limit]);
                    }
                });
                break;
            }
            const fileMatch = files[fileIndex];
            const label = basenameOrAuthority(fileMatch.resource);
            const description = this._labelService.getUriLabel(dirname(fileMatch.resource), { relative: true });
            picks.push({
                label,
                type: 'separator',
                tooltip: description,
                buttons: [{
                        iconClass: ThemeIcon.asClassName(searchOpenInFileIcon),
                        tooltip: ( localize('QuickSearchOpenInFile', "Open File"))
                    }],
            });
            const results = fileMatch.matches() ?? [];
            for (let matchIndex = 0; matchIndex < results.length; matchIndex++) {
                const element = results[matchIndex];
                if (matchIndex === MAX_RESULTS_PER_FILE) {
                    picks.push({
                        label: ( localize('QuickSearchMore', "More")),
                        iconClass: ThemeIcon.asClassName(searchDetailsIcon),
                        accept: async () => {
                            this.moveToSearchViewlet(this.searchModel, element);
                        }
                    });
                    break;
                }
                const preview = element.preview();
                const previewText = (preview.before + preview.inside + preview.after).trim().substring(0, 999);
                const match = [{
                        start: preview.before.length,
                        end: preview.before.length + preview.inside.length
                    }];
                picks.push({
                    label: `${previewText}`,
                    highlights: {
                        label: match
                    },
                    ariaLabel: `Match at location ${element.range().startLineNumber}:${element.range().startColumn} - ${previewText}`,
                    accept: async (keyMods, event) => {
                        await this.handleAccept(fileMatch, {
                            keyMods,
                            selection: getEditorSelectionFromMatch(element, this.searchModel),
                            preserveFocus: event.inBackground,
                            forcePinned: event.inBackground,
                            indexedCellOptions: element instanceof MatchInNotebook ? { index: element.cellIndex, selection: element.range() } : undefined
                        });
                    }
                });
            }
        }
        return picks;
    }
    async handleAccept(fileMatch, options) {
        const editorOptions = {
            preserveFocus: options.preserveFocus,
            pinned: options.keyMods?.ctrlCmd || options.forcePinned || this.configuration.openEditorPinned,
            selection: options.selection
        };
        const targetGroup = options.keyMods?.alt || (this.configuration.openEditorPinned && options.keyMods?.ctrlCmd) || options.forceOpenSideBySide ? SIDE_GROUP : ACTIVE_GROUP;
        await this._editorService.openEditor({
            resource: fileMatch.resource,
            options: editorOptions
        }, targetGroup);
    }
    _getPicks(contentPattern, disposables, token) {
        if (contentPattern === '') {
            this.searchModel.searchResult.clear();
            return [];
        }
        const allMatches = this.doSearch(contentPattern, token);
        if (!allMatches) {
            return null;
        }
        const matches = allMatches.syncResults;
        const syncResult = this._getPicksFromMatches(matches, MAX_FILES_SHOWN);
        if (syncResult.length > 0) {
            this.searchModel.searchResult.toggleHighlights(true);
        }
        if (matches.length >= MAX_FILES_SHOWN) {
            return syncResult;
        }
        return {
            picks: syncResult,
            additionalPicks: allMatches.asyncResults
                .then(asyncResults => this._getPicksFromMatches(asyncResults, MAX_FILES_SHOWN - matches.length))
                .then(picks => {
                if (picks.length > 0) {
                    this.searchModel.searchResult.toggleHighlights(true);
                }
                return picks;
            })
        };
    }
};
TextSearchQuickAccess = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IWorkspaceContextService)),
    ( __param(2, IEditorService)),
    ( __param(3, ILabelService)),
    ( __param(4, IViewsService)),
    ( __param(5, IConfigurationService))
], TextSearchQuickAccess));
export { TEXT_SEARCH_QUICK_ACCESS_PREFIX, TextSearchQuickAccess };
