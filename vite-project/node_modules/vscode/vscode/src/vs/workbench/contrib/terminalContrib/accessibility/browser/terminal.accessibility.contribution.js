import { __decorate, __param } from '../../../../../../../../external/tslib/tslib.es6.js';
import { DisposableStore, Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { CONTEXT_ACCESSIBILITY_MODE_ENABLED } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { terminalTabFocusModeContextKey } from '../../../../../platform/terminal/common/terminal.js';
import { IAccessibleViewService } from '../../../accessibility/browser/accessibleView.js';
import { AccessibilityHelpAction } from '../../../accessibility/browser/accessibleViewActions.js';
import { ITerminalService } from '../../../terminal/browser/terminal.js';
import { registerTerminalAction } from '../../../terminal/browser/terminalActions.js';
import { registerTerminalContribution } from '../../../terminal/browser/terminalExtensions.js';
import { TerminalContextKeys } from '../../../terminal/common/terminalContextKey.js';
import { TerminalAccessibleContentProvider } from './terminalAccessibilityHelp.js';
import { AccessibleBufferWidget } from './terminalAccessibleBuffer.js';
import { TextAreaSyncAddon } from './textAreaSyncAddon.js';
var TextAreaSyncContribution_1, AccessibleBufferContribution_1;
let TextAreaSyncContribution = class TextAreaSyncContribution extends DisposableStore {
    static { TextAreaSyncContribution_1 = this; }
    static { this.ID = 'terminal.textAreaSync'; }
    static get(instance) {
        return instance.getContribution(TextAreaSyncContribution_1.ID);
    }
    constructor(_instance, processManager, widgetManager, _instantiationService) {
        super();
        this._instance = _instance;
        this._instantiationService = _instantiationService;
    }
    xtermReady(xterm) {
        const addon = this._instantiationService.createInstance(TextAreaSyncAddon, this._instance.capabilities);
        xterm.raw.loadAddon(addon);
        addon.activate(xterm.raw);
    }
};
TextAreaSyncContribution = TextAreaSyncContribution_1 = ( __decorate([
    ( __param(3, IInstantiationService))
], TextAreaSyncContribution));
registerTerminalContribution(TextAreaSyncContribution.ID, TextAreaSyncContribution);
let AccessibleBufferContribution = class AccessibleBufferContribution extends DisposableStore {
    static { AccessibleBufferContribution_1 = this; }
    static { this.ID = 'terminal.accessible-buffer'; }
    static get(instance) {
        return instance.getContribution(AccessibleBufferContribution_1.ID);
    }
    constructor(_instance, processManager, widgetManager, _instantiationService, configurationService) {
        super();
        this._instance = _instance;
        this._instantiationService = _instantiationService;
        this.add(_instance.onDidRunText(() => {
            const focusAfterRun = configurationService.getValue("terminal.integrated.focusAfterRun" );
            if (focusAfterRun === 'terminal') {
                _instance.focus(true);
            }
            else if (focusAfterRun === 'accessible-buffer') {
                this.show();
            }
        }));
    }
    layout(xterm) {
        this._xterm = xterm;
    }
    async show() {
        if (!this._xterm) {
            return;
        }
        if (!this._accessibleBufferWidget) {
            this._accessibleBufferWidget = this.add(this._instantiationService.createInstance(AccessibleBufferWidget, this._instance, this._xterm));
        }
        await this._accessibleBufferWidget.show();
    }
    async createCommandQuickPick() {
        return this._accessibleBufferWidget?.createQuickPick();
    }
    navigateToCommand(type) {
        return this._accessibleBufferWidget?.navigateToCommand(type);
    }
    hide() {
        this._accessibleBufferWidget?.hide();
    }
};
AccessibleBufferContribution = AccessibleBufferContribution_1 = ( __decorate([
    ( __param(3, IInstantiationService)),
    ( __param(4, IConfigurationService))
], AccessibleBufferContribution));
registerTerminalContribution(AccessibleBufferContribution.ID, AccessibleBufferContribution);
class TerminalAccessibilityHelpContribution extends Disposable {
    constructor() {
        super();
        this._register(AccessibilityHelpAction.addImplementation(105, 'terminal', async (accessor) => {
            const instantiationService = accessor.get(IInstantiationService);
            const terminalService = accessor.get(ITerminalService);
            const accessibleViewService = accessor.get(IAccessibleViewService);
            const instance = await terminalService.getActiveOrCreateInstance();
            await terminalService.revealActiveTerminal();
            const terminal = instance?.xterm;
            if (!terminal) {
                return;
            }
            accessibleViewService.show(instantiationService.createInstance(TerminalAccessibleContentProvider, instance, terminal));
        }, ( ContextKeyExpr.or(TerminalContextKeys.focus, TerminalContextKeys.accessibleBufferFocus))));
    }
}
registerTerminalContribution(TerminalAccessibilityHelpContribution.ID, TerminalAccessibilityHelpContribution);
registerTerminalAction({
    id: "workbench.action.terminal.focusAccessibleBuffer" ,
    title: { value: ( localize(
        'workbench.action.terminal.focusAccessibleBuffer',
        'Focus Accessible Buffer'
    )), original: 'Focus Accessible Buffer' },
    precondition: ( ContextKeyExpr.or(
        TerminalContextKeys.processSupported,
        TerminalContextKeys.terminalHasBeenCreated
    )),
    keybinding: [
        {
            primary: 512  | 60 ,
            secondary: [2048  | 16 ],
            weight: 200 ,
            when: ( ContextKeyExpr.and(
                CONTEXT_ACCESSIBILITY_MODE_ENABLED,
                TerminalContextKeys.focus,
                ( ContextKeyExpr.or(terminalTabFocusModeContextKey, ( TerminalContextKeys.accessibleBufferFocus.negate())))
            ))
        }
    ],
    run: async (c) => {
        const instance = await c.service.getActiveOrCreateInstance();
        await c.service.revealActiveTerminal();
        if (!instance) {
            return;
        }
        await AccessibleBufferContribution.get(instance)?.show();
    }
});
registerTerminalAction({
    id: "workbench.action.terminal.navigateAccessibleBuffer" ,
    title: { value: ( localize(
        'workbench.action.terminal.navigateAccessibleBuffer',
        'Navigate Accessible Buffer'
    )), original: 'Navigate Accessible Buffer' },
    precondition: ( ContextKeyExpr.or(
        TerminalContextKeys.processSupported,
        TerminalContextKeys.terminalHasBeenCreated
    )),
    keybinding: [
        {
            primary: 2048  | 1024  | 37 ,
            weight: 200  + 2,
            when: TerminalContextKeys.accessibleBufferFocus
        }
    ],
    run: async (c) => {
        const instance = await c.service.getActiveOrCreateInstance();
        await c.service.revealActiveTerminal();
        if (!instance) {
            return;
        }
        const quickPick = await AccessibleBufferContribution.get(instance)?.createCommandQuickPick();
        quickPick?.show();
    }
});
registerTerminalAction({
    id: "workbench.action.terminal.accessibleBufferGoToNextCommand" ,
    title: { value: ( localize(
        'workbench.action.terminal.accessibleBufferGoToNextCommand',
        'Accessible Buffer Go to Next Command'
    )), original: 'Accessible Buffer Go to Next Command' },
    precondition: ( ContextKeyExpr.or(
        TerminalContextKeys.processSupported,
        TerminalContextKeys.terminalHasBeenCreated,
        TerminalContextKeys.accessibleBufferFocus
    )),
    keybinding: [
        {
            primary: 2048  | 18 ,
            when: ( ContextKeyExpr.and(TerminalContextKeys.accessibleBufferFocus, ( CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()))),
            weight: 200  + 2
        },
        {
            primary: 512  | 18 ,
            when: ( ContextKeyExpr.and(
                TerminalContextKeys.accessibleBufferFocus,
                CONTEXT_ACCESSIBILITY_MODE_ENABLED
            )),
            weight: 200  + 2
        }
    ],
    run: async (c) => {
        const instance = await c.service.getActiveOrCreateInstance();
        await c.service.revealActiveTerminal();
        if (!instance) {
            return;
        }
        await AccessibleBufferContribution.get(instance)?.navigateToCommand("next" );
    }
});
registerTerminalAction({
    id: "workbench.action.terminal.accessibleBufferGoToPreviousCommand" ,
    title: { value: ( localize(
        'workbench.action.terminal.accessibleBufferGoToPreviousCommand',
        'Accessible Buffer Go to Previous Command'
    )), original: 'Accessible Buffer Go to Previous Command' },
    precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
        TerminalContextKeys.processSupported,
        TerminalContextKeys.terminalHasBeenCreated
    )), TerminalContextKeys.accessibleBufferFocus)),
    keybinding: [
        {
            primary: 2048  | 16 ,
            when: ( ContextKeyExpr.and(TerminalContextKeys.accessibleBufferFocus, ( CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()))),
            weight: 200  + 2
        },
        {
            primary: 512  | 16 ,
            when: ( ContextKeyExpr.and(
                TerminalContextKeys.accessibleBufferFocus,
                CONTEXT_ACCESSIBILITY_MODE_ENABLED
            )),
            weight: 200  + 2
        }
    ],
    run: async (c) => {
        const instance = await c.service.getActiveOrCreateInstance();
        await c.service.revealActiveTerminal();
        if (!instance) {
            return;
        }
        await AccessibleBufferContribution.get(instance)?.navigateToCommand("previous" );
    }
});
export { TerminalAccessibilityHelpContribution };
