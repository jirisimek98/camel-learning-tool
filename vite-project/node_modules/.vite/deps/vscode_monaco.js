import {
  IWorkbenchThemeService
} from "./chunk-VLRIVIHE.js";
import {
  FoldingController,
  FoldingModel,
  InlayHintsController,
  InlineCompletionsController,
  ReferencesController,
  SEMANTIC_HIGHLIGHTING_SETTING_ID,
  asCommandLink,
  formatDocumentRangesWithSelectedProvider,
  formatDocumentWithSelectedProvider,
  init_format,
  setCollapseStateForMatchingLines,
  trimTrailingWhitespace
} from "./chunk-B6SX2JWG.js";
import {
  ColorExtensionPoint
} from "./chunk-KDNL575K.js";
import {
  SemanticTokenRule
} from "./chunk-DE7JK3KC.js";
import {
  Extensions as Extensions2,
  Extensions2 as Extensions4,
  ExtensionsRegistry,
  IAccessibleViewService,
  IEditorService,
  IExtensionService,
  IQuickDiffService,
  ITextFileService,
  ITextMateTokenizationService,
  TextCompareEditorActiveContext,
  accessibilityHelpIsShown,
  accessibleViewCurrentProviderId,
  accessibleViewGoToSymbolSupported,
  accessibleViewIsShown,
  accessibleViewSupportsNavigation,
  accessibleViewVerbosityEnabled,
  languagesExtPoint,
  n
} from "./chunk-ETI4KOTI.js";
import {
  __decorate,
  __param,
  init_tslib_es6
} from "./chunk-GJDIUAXO.js";
import {
  PeekViewWidget,
  StandaloneDiffEditor,
  StandaloneEditor,
  getOuterEditor,
  peekViewBorder,
  peekViewTitleBackground,
  peekViewTitleForeground,
  peekViewTitleInfoForeground
} from "./chunk-XHQJEB2N.js";
import {
  $,
  AccessibleDiffViewerNext,
  AccessibleDiffViewerPrev,
  Action,
  Action2,
  ActionRunner,
  ApplyCodeActionReason,
  AudioCue,
  Categories,
  CodeActionKind,
  CodeActionTriggerSource,
  Color,
  CommandsRegistry,
  DiffEditorWidget2,
  EditOperation,
  EditorAction,
  EditorAction2,
  EditorContextKeys,
  EmbeddedCodeEditorWidget,
  EmbeddedDiffEditorWidget,
  EmbeddedDiffEditorWidget2,
  Extensions,
  Extensions2 as Extensions3,
  IAccessibilityService,
  IAudioCueService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextMenuService,
  IContextViewService,
  IEditorWorkerService,
  IKeybindingService,
  ILanguageFeaturesService,
  ILanguageService,
  IMenuService,
  INotificationService,
  IQuickInputService,
  IStorageService,
  ITextModelService,
  ITextResourceConfigurationService,
  IThemeService,
  KeybindingsRegistry,
  Link,
  MenuId,
  MenuItemAction,
  MenuRegistry,
  ModelDecorationOptions,
  MultiCommand,
  Position,
  Progress,
  Range,
  Registry,
  SelectActionViewItem,
  Separator,
  ServiceCollection,
  Severity,
  SnippetController2,
  StandaloneKeybindingService,
  StandaloneQuickInputService,
  StandaloneServices,
  SyncDescriptor,
  TokenMetadata,
  Widget,
  addDisposableListener,
  alert,
  append,
  applyCodeAction,
  asCssVariable,
  asCssVariableWithDefault,
  autorunWithStore,
  buttonBackground,
  buttonForeground,
  clearNode,
  codeActionCommandId,
  contrastBorder,
  createAndFillInActionBarActions,
  createStyleSheet,
  defaultSelectBoxStyles,
  editorBackground,
  editorConfigurationBaseNode,
  editorErrorForeground,
  editorForeground,
  getCodeActions,
  gotoNextLocation,
  gotoPreviousLocation,
  init_actions,
  init_actions2,
  init_aria,
  init_codeEditorService,
  init_color,
  init_colorRegistry,
  init_commands,
  init_configuration,
  init_configurationRegistry,
  init_descriptors,
  init_dom,
  init_editOperation,
  init_editorBrowser,
  init_editorContextKeys,
  init_editorExtensions,
  init_editorWorker,
  init_encodedTokenAttributes,
  init_jsonContributionRegistry,
  init_keybindingsRegistry,
  init_language,
  init_languageFeatures,
  init_numbers,
  init_platform as init_platform2,
  init_position,
  init_progress,
  init_range,
  init_resolverService,
  init_textModel,
  init_themeService,
  isCodeEditor,
  isCompositeEditor,
  observableFromEvent,
  prepend,
  refactorCommandId,
  registerAction2,
  registerColor,
  registerDiffEditorContribution,
  registerEditorAction,
  registerEditorContribution,
  reset,
  rot,
  sourceActionCommandId,
  transparent
} from "./chunk-O3SOEW3V.js";
import {
  CancellationToken,
  CancellationTokenSource,
  Codicon,
  ConfigurationChangedEvent,
  ContextKeyEqualsExpr,
  ContextKeyExpr,
  Disposable,
  DisposableStore,
  Emitter,
  Event,
  IContextKeyService,
  IFileService,
  IInstantiationService,
  ILogService,
  ITelemetryService,
  RawContextKey,
  Schemas,
  ThemeIcon,
  VSBuffer,
  _util,
  basename,
  basename2,
  deepClone,
  distinct2 as distinct,
  editorOptionsRegistry,
  equals,
  errorHandler,
  init_arrays,
  init_buffer,
  init_cancellation,
  init_codicons,
  init_contextkey,
  init_editorOptions,
  init_errors,
  init_event,
  init_files,
  init_instantiation,
  init_lifecycle,
  init_log,
  init_model,
  init_network,
  init_nls,
  init_objects,
  init_path,
  init_platform,
  init_resources,
  init_strings,
  init_telemetry,
  init_themables,
  init_types,
  isEqual2 as isEqual,
  isEqualOrParent2 as isEqualOrParent,
  isMacintosh,
  isNonEmptyArray,
  isObject,
  isString,
  joinPath,
  lastNonWhitespaceIndex,
  localize,
  shouldSynchronizeModel,
  toDisposable
} from "./chunk-N5MAMNNV.js";
import "./chunk-PGWBAY6J.js";

// node_modules/vscode/monaco.js
init_tslib_es6();
init_instantiation();
init_types();
init_objects();
init_errors();
init_lifecycle();
init_platform2();
init_platform2();
init_jsonContributionRegistry();
init_commands();
init_commands();
init_actions2();
init_keybindingsRegistry();
init_configurationRegistry();

// node_modules/vscode/vscode/src/vs/editor/browser/config/editorConfiguration.js
init_arrays();
init_editorOptions();
var ValidatedEditorOptions = class {
  constructor() {
    this._values = [];
  }
  _read(option) {
    return this._values[option];
  }
  get(id) {
    return this._values[id];
  }
  _write(option, value) {
    this._values[option] = value;
  }
};
var ComputedEditorOptions = class {
  constructor() {
    this._values = [];
  }
  _read(id) {
    if (id >= this._values.length) {
      throw new Error("Cannot read uninitialized value");
    }
    return this._values[id];
  }
  get(id) {
    return this._read(id);
  }
  _write(id, value) {
    this._values[id] = value;
  }
};
var EditorOptionsUtil = class _EditorOptionsUtil {
  static validateOptions(options) {
    const result = new ValidatedEditorOptions();
    for (const editorOption of editorOptionsRegistry) {
      const value = editorOption.name === "_never_" ? void 0 : options[editorOption.name];
      result._write(editorOption.id, editorOption.validate(value));
    }
    return result;
  }
  static computeOptions(options, env) {
    const result = new ComputedEditorOptions();
    for (const editorOption of editorOptionsRegistry) {
      result._write(editorOption.id, editorOption.compute(env, result, options._read(editorOption.id)));
    }
    return result;
  }
  static _deepEquals(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || !a || !b) {
      return a === b;
    }
    if (Array.isArray(a) || Array.isArray(b)) {
      return Array.isArray(a) && Array.isArray(b) ? equals(a, b) : false;
    }
    if (Object.keys(a).length !== Object.keys(b).length) {
      return false;
    }
    for (const key in a) {
      if (!_EditorOptionsUtil._deepEquals(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  static checkEquals(a, b) {
    const result = [];
    let somethingChanged = false;
    for (const editorOption of editorOptionsRegistry) {
      const changed = !_EditorOptionsUtil._deepEquals(a._read(editorOption.id), b._read(editorOption.id));
      result[editorOption.id] = changed;
      if (changed) {
        somethingChanged = true;
      }
    }
    return somethingChanged ? new ConfigurationChangedEvent(result) : null;
  }
  static applyUpdate(options, update) {
    let changed = false;
    for (const editorOption of editorOptionsRegistry) {
      if (update.hasOwnProperty(editorOption.name)) {
        const result = editorOption.applyUpdate(options[editorOption.name], update[editorOption.name]);
        options[editorOption.name] = result.newValue;
        changed = changed || result.didChange;
      }
    }
    return changed;
  }
};

// node_modules/vscode/monaco.js
init_colorRegistry();
init_resolverService();
init_files();
init_buffer();

// node_modules/vscode/vscode/src/vs/workbench/api/common/jsonValidationExtensionPoint.js
init_nls();
init_resources();
init_types();
var configurationExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "jsonValidation",
  defaultExtensionKind: ["workspace", "web"],
  jsonSchema: {
    description: localize("contributes.jsonValidation", "Contributes json schema configuration."),
    type: "array",
    defaultSnippets: [{ body: [{ fileMatch: "${1:file.json}", url: "${2:url}" }] }],
    items: {
      type: "object",
      defaultSnippets: [{ body: { fileMatch: "${1:file.json}", url: "${2:url}" } }],
      properties: {
        fileMatch: {
          type: ["string", "array"],
          description: localize(
            "contributes.jsonValidation.fileMatch",
            `The file pattern (or an array of patterns) to match, for example "package.json" or "*.launch". Exclusion patterns start with '!'`
          ),
          items: {
            type: ["string"]
          }
        },
        url: {
          description: localize(
            "contributes.jsonValidation.url",
            "A schema URL ('http:', 'https:') or relative path to the extension folder ('./')."
          ),
          type: "string"
        }
      }
    }
  }
});
var JSONValidationExtensionPoint = class {
  constructor() {
    configurationExtPoint.setHandler((extensions) => {
      for (const extension of extensions) {
        const extensionValue = extension.value;
        const collector = extension.collector;
        const extensionLocation = extension.description.extensionLocation;
        if (!extensionValue || !Array.isArray(extensionValue)) {
          collector.error(localize("invalid.jsonValidation", "'configuration.jsonValidation' must be a array"));
          return;
        }
        extensionValue.forEach((extension2) => {
          if (!isString(extension2.fileMatch) && !(Array.isArray(extension2.fileMatch) && extension2.fileMatch.every(isString))) {
            collector.error(localize(
              "invalid.fileMatch",
              "'configuration.jsonValidation.fileMatch' must be defined as a string or an array of strings."
            ));
            return;
          }
          const uri = extension2.url;
          if (!isString(uri)) {
            collector.error(localize(
              "invalid.url",
              "'configuration.jsonValidation.url' must be a URL or relative path"
            ));
            return;
          }
          if (uri.startsWith("./")) {
            try {
              const colorThemeLocation = joinPath(extensionLocation, uri);
              if (!isEqualOrParent(colorThemeLocation, extensionLocation)) {
                collector.warn(localize(
                  "invalid.path.1",
                  "Expected `contributes.{0}.url` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.",
                  configurationExtPoint.name,
                  colorThemeLocation.toString(),
                  extensionLocation.path
                ));
              }
            } catch (e) {
              collector.error(localize(
                "invalid.url.fileschema",
                "'configuration.jsonValidation.url' is an invalid relative URL: {0}",
                e.message
              ));
            }
          } else if (!/^[^:/?#]+:\/\//.test(uri)) {
            collector.error(localize(
              "invalid.url.schema",
              "'configuration.jsonValidation.url' must be an absolute URL or start with './'  to reference schemas located in the extension."
            ));
            return;
          }
        });
      }
    });
  }
};

// node_modules/vscode/monaco.js
init_descriptors();
init_contextkey();
init_contextkey();
init_telemetry();
init_log();
init_codeEditorService();

// node_modules/vscode/tools/injection.js
init_instantiation();
function getInjectedParameters(instantiationService, ctor) {
  return instantiationService.invokeFunction((accessor) => {
    return _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index).map((d) => accessor.get(d.id));
  });
}
function createInjectedClass(ctor) {
  const _ctor = ctor;
  return class extends _ctor {
    constructor(...args) {
      super(...args.slice(1), ...getInjectedParameters(args[0], ctor));
    }
  };
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/workbenchReferenceSearch.js
init_tslib_es6();
init_editorExtensions();
init_codeEditorService();
init_configuration();
init_contextkey();
init_instantiation();
var WorkbenchReferencesController = class WorkbenchReferencesController2 extends ReferencesController {
  constructor(editor, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) {
    super(false, editor, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService);
  }
};
WorkbenchReferencesController = __decorate([
  __param(1, IContextKeyService),
  __param(2, ICodeEditorService),
  __param(3, INotificationService),
  __param(4, IInstantiationService),
  __param(5, IStorageService),
  __param(6, IConfigurationService)
], WorkbenchReferencesController);
registerEditorContribution(ReferencesController.ID, WorkbenchReferencesController, 4);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/diffEditorHelper.js
init_tslib_es6();
init_lifecycle();
init_editorExtensions();
init_codeEditorService();
init_nls();
init_configuration();
init_contextkey();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/browser/codeeditor.js
init_tslib_es6();
init_event();
init_lifecycle();
init_resources();
init_editorBrowser();
init_textModel();

// node_modules/vscode/vscode/src/vs/platform/actions/browser/floatingMenu.js
init_tslib_es6();
init_dom();
init_event();
init_lifecycle();
init_actions2();
init_contextkey();
init_colorRegistry();
var FloatingClickWidget = class extends Widget {
  constructor(label) {
    super();
    this.label = label;
    this._onClick = this._register(new Emitter());
    this.onClick = this._onClick.event;
    this._domNode = $(".floating-click-widget");
    this._domNode.style.padding = "6px 11px";
    this._domNode.style.borderRadius = "2px";
    this._domNode.style.cursor = "pointer";
    this._domNode.style.zIndex = "1";
  }
  getDomNode() {
    return this._domNode;
  }
  render() {
    clearNode(this._domNode);
    this._domNode.style.backgroundColor = asCssVariableWithDefault(buttonBackground, asCssVariable(editorBackground));
    this._domNode.style.color = asCssVariableWithDefault(buttonForeground, asCssVariable(editorForeground));
    this._domNode.style.border = `1px solid ${asCssVariable(contrastBorder)}`;
    append(this._domNode, $("")).textContent = this.label;
    this.onclick(this._domNode, () => this._onClick.fire());
  }
};
var AbstractFloatingClickMenu = class AbstractFloatingClickMenu2 extends Disposable {
  constructor(menuId, menuService, contextKeyService) {
    super();
    this.renderEmitter = new Emitter();
    this.onDidRender = this.renderEmitter.event;
    this.menu = this._register(menuService.createMenu(menuId, contextKeyService));
  }
  render() {
    const menuDisposables = this._register(new DisposableStore());
    const renderMenuAsFloatingClickBtn = () => {
      menuDisposables.clear();
      if (!this.isVisible()) {
        return;
      }
      const actions = [];
      createAndFillInActionBarActions(this.menu, { renderShortTitle: true, shouldForwardArgs: true }, actions);
      if (actions.length === 0) {
        return;
      }
      const [first] = actions;
      const widget = this.createWidget(first, menuDisposables);
      menuDisposables.add(widget);
      menuDisposables.add(widget.onClick(() => first.run(this.getActionArg())));
      widget.render();
    };
    this._register(this.menu.onDidChange(renderMenuAsFloatingClickBtn));
    renderMenuAsFloatingClickBtn();
  }
  getActionArg() {
    return void 0;
  }
  isVisible() {
    return true;
  }
};
AbstractFloatingClickMenu = __decorate([
  __param(1, IMenuService),
  __param(2, IContextKeyService)
], AbstractFloatingClickMenu);

// node_modules/vscode/vscode/src/vs/workbench/browser/codeeditor.js
init_actions2();
init_contextkey();
init_instantiation();
var RangeHighlightDecorations_1;
var _a;
var RangeHighlightDecorations = (_a = class extends Disposable {
  constructor(editorService) {
    super();
    this.editorService = editorService;
    this._onHighlightRemoved = this._register(new Emitter());
    this.onHighlightRemoved = this._onHighlightRemoved.event;
    this.rangeHighlightDecorationId = null;
    this.editor = null;
    this.editorDisposables = this._register(new DisposableStore());
  }
  removeHighlightRange() {
    if (this.editor && this.rangeHighlightDecorationId) {
      const decorationId = this.rangeHighlightDecorationId;
      this.editor.changeDecorations((accessor) => {
        accessor.removeDecoration(decorationId);
      });
      this._onHighlightRemoved.fire();
    }
    this.rangeHighlightDecorationId = null;
  }
  highlightRange(range, editor) {
    editor = editor ?? this.getEditor(range);
    if (isCodeEditor(editor)) {
      this.doHighlightRange(editor, range);
    } else if (isCompositeEditor(editor) && isCodeEditor(editor.activeCodeEditor)) {
      this.doHighlightRange(editor.activeCodeEditor, range);
    }
  }
  doHighlightRange(editor, selectionRange) {
    this.removeHighlightRange();
    editor.changeDecorations((changeAccessor) => {
      this.rangeHighlightDecorationId = changeAccessor.addDecoration(selectionRange.range, this.createRangeHighlightDecoration(selectionRange.isWholeLine));
    });
    this.setEditor(editor);
  }
  getEditor(resourceRange) {
    var _a12;
    const resource = (_a12 = this.editorService.activeEditor) == null ? void 0 : _a12.resource;
    if (resource && isEqual(resource, resourceRange.resource) && isCodeEditor(this.editorService.activeTextEditorControl)) {
      return this.editorService.activeTextEditorControl;
    }
    return void 0;
  }
  setEditor(editor) {
    if (this.editor !== editor) {
      this.editorDisposables.clear();
      this.editor = editor;
      this.editorDisposables.add(this.editor.onDidChangeCursorPosition((e) => {
        if (e.reason === 0 || e.reason === 3 || e.reason === 5 || e.reason === 6) {
          this.removeHighlightRange();
        }
      }));
      this.editorDisposables.add(this.editor.onDidChangeModel(() => {
        this.removeHighlightRange();
      }));
      this.editorDisposables.add(this.editor.onDidDispose(() => {
        this.removeHighlightRange();
        this.editor = null;
      }));
    }
  }
  createRangeHighlightDecoration(isWholeLine = true) {
    return isWholeLine ? RangeHighlightDecorations_1._WHOLE_LINE_RANGE_HIGHLIGHT : RangeHighlightDecorations_1._RANGE_HIGHLIGHT;
  }
  dispose() {
    var _a12;
    super.dispose();
    if ((_a12 = this.editor) == null ? void 0 : _a12.getModel()) {
      this.removeHighlightRange();
      this.editor = null;
    }
  }
}, RangeHighlightDecorations_1 = _a, _a._WHOLE_LINE_RANGE_HIGHLIGHT = ModelDecorationOptions.register({
  description: "codeeditor-range-highlight-whole",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: true
}), _a._RANGE_HIGHLIGHT = ModelDecorationOptions.register({
  description: "codeeditor-range-highlight",
  stickiness: 1,
  className: "rangeHighlight"
}), _a);
RangeHighlightDecorations = RangeHighlightDecorations_1 = __decorate([
  __param(0, IEditorService)
], RangeHighlightDecorations);
var FloatingEditorClickWidget = class FloatingEditorClickWidget2 extends FloatingClickWidget {
  constructor(editor, label, keyBindingAction, keybindingService) {
    super(keyBindingAction && keybindingService.lookupKeybinding(keyBindingAction) ? `${label} (${keybindingService.lookupKeybinding(keyBindingAction).getLabel()})` : label);
    this.editor = editor;
  }
  getId() {
    return "editor.overlayWidget.floatingClickWidget";
  }
  getPosition() {
    return {
      preference: 1
    };
  }
  render() {
    super.render();
    this.editor.addOverlayWidget(this);
  }
  dispose() {
    this.editor.removeOverlayWidget(this);
    super.dispose();
  }
};
FloatingEditorClickWidget = __decorate([
  __param(3, IKeybindingService)
], FloatingEditorClickWidget);
var _a2;
var FloatingEditorClickMenu = (_a2 = class extends AbstractFloatingClickMenu {
  constructor(editor, instantiationService, menuService, contextKeyService) {
    super(MenuId.EditorContent, menuService, contextKeyService);
    this.editor = editor;
    this.instantiationService = instantiationService;
    this.render();
  }
  createWidget(action) {
    return this.instantiationService.createInstance(FloatingEditorClickWidget, this.editor, action.label, action.id);
  }
  isVisible() {
    var _a12;
    return !(this.editor instanceof EmbeddedCodeEditorWidget) && ((_a12 = this.editor) == null ? void 0 : _a12.hasModel()) && !this.editor.getOption(60);
  }
  getActionArg() {
    var _a12;
    return (_a12 = this.editor.getModel()) == null ? void 0 : _a12.uri;
  }
}, _a2.ID = "editor.contrib.floatingClickMenu", _a2);
FloatingEditorClickMenu = __decorate([
  __param(1, IInstantiationService),
  __param(2, IMenuService),
  __param(3, IContextKeyService)
], FloatingEditorClickMenu);

// node_modules/vscode/vscode/src/vs/workbench/contrib/accessibility/browser/accessibleViewActions.js
init_codicons();
init_editorExtensions();
init_nls();
init_actions2();
init_contextkey();
init_codeEditorService();
init_aria();
var accessibleViewMenu = {
  id: MenuId.AccessibleView,
  group: "navigation",
  when: accessibleViewIsShown
};
var commandPalette = {
  id: MenuId.CommandPalette,
  group: "",
  order: 1
};
var AccessibleViewNextAction = class extends Action2 {
  constructor() {
    super({
      id: "editor.action.accessibleViewNext",
      precondition: ContextKeyExpr.and(accessibleViewIsShown, accessibleViewSupportsNavigation),
      keybinding: {
        primary: 512 | 94,
        weight: 200
      },
      menu: [
        commandPalette,
        {
          ...accessibleViewMenu,
          when: ContextKeyExpr.and(accessibleViewIsShown, accessibleViewSupportsNavigation)
        }
      ],
      icon: Codicon.arrowDown,
      title: localize("editor.action.accessibleViewNext", "Show Next in Accessible View")
    });
  }
  run(accessor) {
    accessor.get(IAccessibleViewService).next();
  }
};
registerAction2(AccessibleViewNextAction);
var AccessibleViewPreviousAction = class extends Action2 {
  constructor() {
    super({
      id: "editor.action.accessibleViewPrevious",
      precondition: ContextKeyExpr.and(accessibleViewIsShown, accessibleViewSupportsNavigation),
      keybinding: {
        primary: 512 | 92,
        weight: 200
      },
      icon: Codicon.arrowUp,
      menu: [
        commandPalette,
        {
          ...accessibleViewMenu,
          when: ContextKeyExpr.and(accessibleViewIsShown, accessibleViewSupportsNavigation)
        }
      ],
      title: localize("editor.action.accessibleViewPrevious", "Show Previous in Accessible View")
    });
  }
  run(accessor) {
    accessor.get(IAccessibleViewService).previous();
  }
};
registerAction2(AccessibleViewPreviousAction);
var AccessibleViewGoToSymbolAction = class extends Action2 {
  constructor() {
    super({
      id: "editor.action.accessibleViewGoToSymbol",
      precondition: ContextKeyExpr.and(ContextKeyExpr.or(accessibleViewIsShown, accessibilityHelpIsShown), accessibleViewGoToSymbolSupported),
      keybinding: {
        primary: 2048 | 1024 | 45,
        secondary: [2048 | 1024 | 89],
        weight: 200 + 10
      },
      icon: Codicon.symbolField,
      menu: [
        commandPalette,
        {
          ...accessibleViewMenu,
          when: ContextKeyExpr.and(ContextKeyExpr.or(accessibleViewIsShown, accessibilityHelpIsShown), accessibleViewGoToSymbolSupported)
        }
      ],
      title: localize(
        "editor.action.accessibleViewGoToSymbol",
        "Go To Symbol in Accessible View"
      )
    });
  }
  run(accessor) {
    accessor.get(IAccessibleViewService).goToSymbol();
  }
};
registerAction2(AccessibleViewGoToSymbolAction);
function registerCommand(command) {
  command.register();
  return command;
}
var AccessibilityHelpAction = registerCommand(new MultiCommand({
  id: "editor.action.accessibilityHelp",
  precondition: void 0,
  kbOpts: {
    primary: 512 | 59,
    weight: 200,
    linux: {
      primary: 512 | 1024 | 59,
      secondary: [512 | 59]
    }
  },
  menuOpts: [{
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("editor.action.accessibilityHelp", "Open Accessibility Help"),
    order: 1
  }]
}));
var AccessibleViewAction = registerCommand(new MultiCommand({
  id: "editor.action.accessibleView",
  precondition: void 0,
  kbOpts: {
    primary: 512 | 60,
    weight: 200,
    linux: {
      primary: 512 | 1024 | 60,
      secondary: [512 | 60]
    }
  },
  menuOpts: [{
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("editor.action.accessibleView", "Open Accessible View"),
    order: 1
  }]
}));
var AccessibleViewDisableHintAction = class extends Action2 {
  constructor() {
    super({
      id: "editor.action.accessibleViewDisableHint",
      precondition: ContextKeyExpr.and(ContextKeyExpr.or(accessibleViewIsShown, accessibilityHelpIsShown), accessibleViewVerbosityEnabled),
      keybinding: {
        primary: 512 | 64,
        weight: 200
      },
      icon: Codicon.bellSlash,
      menu: [
        commandPalette,
        {
          id: MenuId.AccessibleView,
          group: "navigation",
          when: ContextKeyExpr.and(ContextKeyExpr.or(accessibleViewIsShown, accessibilityHelpIsShown), accessibleViewVerbosityEnabled)
        }
      ],
      title: localize("editor.action.accessibleViewDisableHint", "Disable Accessible View Hint")
    });
  }
  run(accessor) {
    accessor.get(IAccessibleViewService).disableHint();
  }
};
registerAction2(AccessibleViewDisableHintAction);
var AccessibleViewAcceptInlineCompletionAction = class extends Action2 {
  constructor() {
    super({
      id: "editor.action.accessibleViewAcceptInlineCompletion",
      precondition: ContextKeyExpr.and(accessibleViewIsShown, ContextKeyExpr.equals(
        accessibleViewCurrentProviderId.key,
        "inlineCompletions"
      )),
      keybinding: {
        primary: 2048 | 90,
        mac: { primary: 256 | 90 },
        weight: 200
      },
      icon: Codicon.check,
      menu: [
        commandPalette,
        {
          id: MenuId.AccessibleView,
          group: "navigation",
          order: 0,
          when: ContextKeyExpr.and(accessibleViewIsShown, ContextKeyExpr.equals(
            accessibleViewCurrentProviderId.key,
            "inlineCompletions"
          ))
        }
      ],
      title: localize(
        "editor.action.accessibleViewAcceptInlineCompletionAction",
        "Accept Inline Completion"
      )
    });
  }
  async run(accessor) {
    var _a12;
    const codeEditorService = accessor.get(ICodeEditorService);
    const editor = codeEditorService.getActiveCodeEditor() || codeEditorService.getFocusedCodeEditor();
    if (!editor) {
      return;
    }
    const model = (_a12 = InlineCompletionsController.get(editor)) == null ? void 0 : _a12.model.get();
    const state = model == null ? void 0 : model.state.get();
    if (!model || !state) {
      return;
    }
    await model.accept(editor);
    alert("Accepted");
    model.stop();
    editor.focus();
  }
};
registerAction2(AccessibleViewAcceptInlineCompletionAction);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/diffEditorHelper.js
init_platform2();
var _a3;
var DiffEditorHelperContribution = (_a3 = class extends Disposable {
  constructor(_diffEditor, _instantiationService, _configurationService, _notificationService) {
    super();
    this._diffEditor = _diffEditor;
    this._instantiationService = _instantiationService;
    this._configurationService = _configurationService;
    this._notificationService = _notificationService;
    this._register(createScreenReaderHelp());
    const isEmbeddedDiffEditor = this._diffEditor instanceof EmbeddedDiffEditorWidget || this._diffEditor instanceof EmbeddedDiffEditorWidget2;
    if (!isEmbeddedDiffEditor) {
      const computationResult = observableFromEvent((e) => this._diffEditor.onDidUpdateDiff(e), () => this._diffEditor.getDiffComputationResult());
      const onlyWhiteSpaceChange = computationResult.map((r) => r && !r.identical && r.changes2.length === 0);
      this._register(autorunWithStore((reader, store) => {
        if (onlyWhiteSpaceChange.read(reader)) {
          const helperWidget = store.add(this._instantiationService.createInstance(FloatingEditorClickWidget, this._diffEditor.getModifiedEditor(), localize("hintWhitespace", "Show Whitespace Differences"), null));
          store.add(helperWidget.onClick(() => {
            this._configurationService.updateValue("diffEditor.ignoreTrimWhitespace", false);
          }));
          helperWidget.render();
        }
      }));
      this._register(this._diffEditor.onDidUpdateDiff(() => {
        const diffComputationResult = this._diffEditor.getDiffComputationResult();
        if (diffComputationResult && diffComputationResult.quitEarly) {
          this._notificationService.prompt(Severity.Warning, localize(
            "hintTimeout",
            "The diff algorithm was stopped early (after {0} ms.)",
            this._diffEditor.maxComputationTime
          ), [{
            label: localize("removeTimeout", "Remove Limit"),
            run: () => {
              this._configurationService.updateValue("diffEditor.maxComputationTime", 0);
            }
          }], {});
        }
      }));
    }
  }
}, _a3.ID = "editor.contrib.diffEditorHelper", _a3);
DiffEditorHelperContribution = __decorate([
  __param(1, IInstantiationService),
  __param(2, IConfigurationService),
  __param(3, INotificationService)
], DiffEditorHelperContribution);
function createScreenReaderHelp() {
  return AccessibilityHelpAction.addImplementation(105, "diff-editor", async (accessor) => {
    var _a12, _b;
    const accessibleViewService = accessor.get(IAccessibleViewService);
    const editorService = accessor.get(IEditorService);
    const codeEditorService = accessor.get(ICodeEditorService);
    const keybindingService = accessor.get(IKeybindingService);
    const next = (_a12 = keybindingService.lookupKeybinding(AccessibleDiffViewerNext.id)) == null ? void 0 : _a12.getAriaLabel();
    const previous = (_b = keybindingService.lookupKeybinding(AccessibleDiffViewerPrev.id)) == null ? void 0 : _b.getAriaLabel();
    if (!(editorService.activeTextEditorControl instanceof DiffEditorWidget2)) {
      return;
    }
    const codeEditor = codeEditorService.getActiveCodeEditor() || codeEditorService.getFocusedCodeEditor();
    if (!codeEditor) {
      return;
    }
    const keys = ["audioCues.diffLineDeleted", "audioCues.diffLineInserted", "audioCues.diffLineModified"];
    accessibleViewService.show({
      verbositySettingKey: "accessibility.verbosity.diffEditor",
      provideContent: () => [
        localize("msg1", "You are in a diff editor."),
        localize(
          "msg2",
          "Press {0} or {1} to view the next or previous diff in the diff review mode that is optimized for screen readers.",
          next,
          previous
        ),
        localize(
          "msg3",
          "To control which audio cues should be played, the following settings can be configured: {0}.",
          keys.join(", ")
        )
      ].join("\n\n"),
      onClose: () => {
        codeEditor.focus();
      },
      options: { type: "help" }
    });
  }, ContextKeyExpr.and(
    ContextKeyEqualsExpr.create("diffEditorVersion", 2),
    ContextKeyEqualsExpr.create("isInDiffEditor", true)
  ));
}
registerDiffEditorContribution(DiffEditorHelperContribution.ID, DiffEditorHelperContribution);
Registry.as(Extensions4.ConfigurationMigration).registerConfigurationMigrations([{
  key: "diffEditor.experimental.collapseUnchangedRegions",
  migrateFn: (value, accessor) => {
    return [
      ["diffEditor.hideUnchangedRegions.enabled", { value }],
      ["diffEditor.experimental.collapseUnchangedRegions", { value: void 0 }]
    ];
  }
}]);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/largeFileOptimizations.js
init_tslib_es6();
init_nls();
init_path();
init_lifecycle();
init_editorExtensions();
init_configuration();
var _a4;
var LargeFileOptimizationsWarner = (_a4 = class extends Disposable {
  constructor(_editor, _notificationService, _configurationService) {
    super();
    this._editor = _editor;
    this._notificationService = _notificationService;
    this._configurationService = _configurationService;
    this._register(this._editor.onDidChangeModel((e) => this._update()));
    this._update();
  }
  _update() {
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (model.isTooLargeForTokenization()) {
      const message = localize({
        key: "largeFile",
        comment: [
          "Variable 0 will be a file name."
        ]
      }, "{0}: tokenization, wrapping, folding and sticky scroll have been turned off for this large file in order to reduce memory usage and avoid freezing or crashing.", basename(model.uri.path));
      this._notificationService.prompt(Severity.Info, message, [
        {
          label: localize("removeOptimizations", "Forcefully Enable Features"),
          run: () => {
            this._configurationService.updateValue(`editor.largeFileOptimizations`, false).then(() => {
              this._notificationService.info(localize(
                "reopenFilePrompt",
                "Please reopen file in order for this setting to take effect."
              ));
            }, (err) => {
              this._notificationService.error(err);
            });
          }
        }
      ], { neverShowAgain: { id: "editor.contrib.largeFileOptimizationsWarner" } });
    }
  }
}, _a4.ID = "editor.contrib.largeFileOptimizationsWarner", _a4);
LargeFileOptimizationsWarner = __decorate([
  __param(1, INotificationService),
  __param(2, IConfigurationService)
], LargeFileOptimizationsWarner);
registerEditorContribution(LargeFileOptimizationsWarner.ID, LargeFileOptimizationsWarner, 1);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/inspectEditorTokens/inspectEditorTokens.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/inspectEditorTokens/inspectEditorTokens.css.js
var css = ".token-inspect-widget{border:1px solid var(--vscode-editorHoverWidget-border);padding:10px;user-select:text;-webkit-user-select:text;z-index:50}.hc-black .tokens-inspect-widget,.hc-light .tokens-inspect-widget{border-width:2px}.monaco-editor .token-inspect-widget{background-color:var(--vscode-editorHoverWidget-background)}.monaco-editor .token-inspect-widget .tiw-metadata-separator{background-color:var(--vscode-editorHoverWidget-border)}.tiw-token{font-family:var(--monaco-monospace-font)}.tiw-metadata-separator{border:0;height:1px}.tiw-token-length{float:right;font-size:60%;font-weight:400}.tiw-metadata-table{width:100%}.tiw-metadata-value{font-family:var(--monaco-monospace-font);word-break:break-word}.tiw-metadata-values{list-style:none;margin-right:-10px;max-height:300px;overflow-y:auto;padding-left:0}.tiw-metadata-values>.tiw-metadata-value{margin-right:10px}.tiw-metadata-key{min-width:150px;padding-right:10px;vertical-align:top;white-space:nowrap;width:1px}.tiw-metadata-semantic{font-style:italic}.tiw-metadata-scopes{line-height:normal}.tiw-theme-selector{font-family:var(--monaco-monospace-font)}";
n(css, {});

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/inspectEditorTokens/inspectEditorTokens.js
init_nls();
init_dom();
init_color();
init_lifecycle();
init_editorExtensions();
init_range();
init_encodedTokenAttributes();
init_language();

// node_modules/vscode/vscode/src/vs/workbench/services/textMate/common/TMHelper.js
function findMatchingThemeRule(theme, scopes, onlyColorRules = true) {
  for (let i = scopes.length - 1; i >= 0; i--) {
    const parentScopes = scopes.slice(0, i);
    const scope = scopes[i];
    const r = findMatchingThemeRule2(theme, scope, parentScopes, onlyColorRules);
    if (r) {
      return r;
    }
  }
  return null;
}
function findMatchingThemeRule2(theme, scope, parentScopes, onlyColorRules) {
  let result = null;
  for (let i = theme.tokenColors.length - 1; i >= 0; i--) {
    const rule = theme.tokenColors[i];
    if (onlyColorRules && !rule.settings.foreground) {
      continue;
    }
    let selectors;
    if (typeof rule.scope === "string") {
      selectors = rule.scope.split(/,/).map((scope2) => scope2.trim());
    } else if (Array.isArray(rule.scope)) {
      selectors = rule.scope;
    } else {
      continue;
    }
    for (let j = 0, lenJ = selectors.length; j < lenJ; j++) {
      const rawSelector = selectors[j];
      const themeRule = new ThemeRule(rawSelector, rule.settings);
      if (themeRule.matches(scope, parentScopes)) {
        if (themeRule.isMoreSpecific(result)) {
          result = themeRule;
        }
      }
    }
  }
  return result;
}
var ThemeRule = class _ThemeRule {
  constructor(rawSelector, settings) {
    this.rawSelector = rawSelector;
    this.settings = settings;
    const rawSelectorPieces = this.rawSelector.split(/ /);
    this.scope = rawSelectorPieces[rawSelectorPieces.length - 1];
    this.parentScopes = rawSelectorPieces.slice(0, rawSelectorPieces.length - 1);
  }
  matches(scope, parentScopes) {
    return _ThemeRule._matches(this.scope, this.parentScopes, scope, parentScopes);
  }
  static _cmp(a, b) {
    if (a === null && b === null) {
      return 0;
    }
    if (a === null) {
      return -1;
    }
    if (b === null) {
      return 1;
    }
    if (a.scope.length !== b.scope.length) {
      return a.scope.length - b.scope.length;
    }
    const aParentScopesLen = a.parentScopes.length;
    const bParentScopesLen = b.parentScopes.length;
    if (aParentScopesLen !== bParentScopesLen) {
      return aParentScopesLen - bParentScopesLen;
    }
    for (let i = 0; i < aParentScopesLen; i++) {
      const aLen = a.parentScopes[i].length;
      const bLen = b.parentScopes[i].length;
      if (aLen !== bLen) {
        return aLen - bLen;
      }
    }
    return 0;
  }
  isMoreSpecific(other) {
    return _ThemeRule._cmp(this, other) > 0;
  }
  static _matchesOne(selectorScope, scope) {
    const selectorPrefix = selectorScope + ".";
    if (selectorScope === scope || scope.substring(0, selectorPrefix.length) === selectorPrefix) {
      return true;
    }
    return false;
  }
  static _matches(selectorScope, selectorParentScopes, scope, parentScopes) {
    if (!this._matchesOne(selectorScope, scope)) {
      return false;
    }
    let selectorParentIndex = selectorParentScopes.length - 1;
    let parentIndex = parentScopes.length - 1;
    while (selectorParentIndex >= 0 && parentIndex >= 0) {
      if (this._matchesOne(selectorParentScopes[selectorParentIndex], parentScopes[parentIndex])) {
        selectorParentIndex--;
      }
      parentIndex--;
    }
    if (selectorParentIndex === -1) {
      return true;
    }
    return false;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/inspectEditorTokens/inspectEditorTokens.js
init_cancellation();
init_configuration();
init_network();
init_languageFeatures();
var InspectEditorTokensController_1;
var $2 = $;
var _a5;
var InspectEditorTokensController = (_a5 = class extends Disposable {
  static get(editor) {
    return editor.getContribution(InspectEditorTokensController_1.ID);
  }
  constructor(editor, textMateService, languageService, themeService, notificationService, configurationService, languageFeaturesService) {
    super();
    this._editor = editor;
    this._textMateService = textMateService;
    this._themeService = themeService;
    this._languageService = languageService;
    this._notificationService = notificationService;
    this._configurationService = configurationService;
    this._languageFeaturesService = languageFeaturesService;
    this._widget = null;
    this._register(this._editor.onDidChangeModel((e) => this.stop()));
    this._register(this._editor.onDidChangeModelLanguage((e) => this.stop()));
    this._register(this._editor.onKeyUp((e) => e.keyCode === 9 && this.stop()));
  }
  dispose() {
    this.stop();
    super.dispose();
  }
  launch() {
    if (this._widget) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (this._editor.getModel().uri.scheme === Schemas.vscodeNotebookCell) {
      return;
    }
    this._widget = new InspectEditorTokensWidget(
      this._editor,
      this._textMateService,
      this._languageService,
      this._themeService,
      this._notificationService,
      this._configurationService,
      this._languageFeaturesService
    );
  }
  stop() {
    if (this._widget) {
      this._widget.dispose();
      this._widget = null;
    }
  }
  toggle() {
    if (!this._widget) {
      this.launch();
    } else {
      this.stop();
    }
  }
}, InspectEditorTokensController_1 = _a5, _a5.ID = "editor.contrib.inspectEditorTokens", _a5);
InspectEditorTokensController = InspectEditorTokensController_1 = __decorate([
  __param(1, ITextMateTokenizationService),
  __param(2, ILanguageService),
  __param(3, IWorkbenchThemeService),
  __param(4, INotificationService),
  __param(5, IConfigurationService),
  __param(6, ILanguageFeaturesService)
], InspectEditorTokensController);
var InspectEditorTokens = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inspectTMScopes",
      label: localize("inspectEditorTokens", "Developer: Inspect Editor Tokens and Scopes"),
      alias: "Developer: Inspect Editor Tokens and Scopes",
      precondition: void 0
    });
  }
  run(accessor, editor) {
    const controller = InspectEditorTokensController.get(editor);
    controller == null ? void 0 : controller.toggle();
  }
};
function renderTokenText(tokenText) {
  if (tokenText.length > 40) {
    tokenText = tokenText.substr(0, 20) + "…" + tokenText.substr(tokenText.length - 20);
  }
  let result = "";
  for (let charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
    const charCode = tokenText.charCodeAt(charIndex);
    switch (charCode) {
      case 9:
        result += "→";
        break;
      case 32:
        result += "·";
        break;
      default:
        result += String.fromCharCode(charCode);
    }
  }
  return result;
}
var _InspectEditorTokensWidget = class _InspectEditorTokensWidget extends Disposable {
  constructor(editor, textMateService, languageService, themeService, notificationService, configurationService, languageFeaturesService) {
    super();
    this.allowEditorOverflow = true;
    this._isDisposed = false;
    this._editor = editor;
    this._languageService = languageService;
    this._themeService = themeService;
    this._textMateService = textMateService;
    this._notificationService = notificationService;
    this._configurationService = configurationService;
    this._languageFeaturesService = languageFeaturesService;
    this._model = this._editor.getModel();
    this._domNode = document.createElement("div");
    this._domNode.className = "token-inspect-widget";
    this._currentRequestCancellationTokenSource = new CancellationTokenSource();
    this._beginCompute(this._editor.getPosition());
    this._register(this._editor.onDidChangeCursorPosition((e) => this._beginCompute(this._editor.getPosition())));
    this._register(themeService.onDidColorThemeChange((_) => this._beginCompute(this._editor.getPosition())));
    this._register(configurationService.onDidChangeConfiguration((e) => e.affectsConfiguration("editor.semanticHighlighting.enabled") && this._beginCompute(this._editor.getPosition())));
    this._editor.addContentWidget(this);
  }
  dispose() {
    this._isDisposed = true;
    this._editor.removeContentWidget(this);
    this._currentRequestCancellationTokenSource.cancel();
    super.dispose();
  }
  getId() {
    return _InspectEditorTokensWidget._ID;
  }
  _beginCompute(position) {
    const grammar = this._textMateService.createTokenizer(this._model.getLanguageId());
    const semanticTokens = this._computeSemanticTokens(position);
    clearNode(this._domNode);
    this._domNode.appendChild(document.createTextNode(localize("inspectTMScopesWidget.loading", "Loading...")));
    Promise.all([grammar, semanticTokens]).then(([grammar2, semanticTokens2]) => {
      if (this._isDisposed) {
        return;
      }
      this._compute(grammar2, semanticTokens2, position);
      this._domNode.style.maxWidth = `${Math.max(this._editor.getLayoutInfo().width * 0.66, 500)}px`;
      this._editor.layoutContentWidget(this);
    }, (err) => {
      this._notificationService.warn(err);
      setTimeout(() => {
        var _a12;
        (_a12 = InspectEditorTokensController.get(this._editor)) == null ? void 0 : _a12.stop();
      });
    });
  }
  _isSemanticColoringEnabled() {
    var _a12;
    const setting = (_a12 = this._configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: this._model.getLanguageId(), resource: this._model.uri })) == null ? void 0 : _a12.enabled;
    if (typeof setting === "boolean") {
      return setting;
    }
    return this._themeService.getColorTheme().semanticHighlighting;
  }
  _compute(grammar, semanticTokens, position) {
    var _a12;
    const textMateTokenInfo = grammar && this._getTokensAtPosition(grammar, position);
    const semanticTokenInfo = semanticTokens && this._getSemanticTokenAtPosition(semanticTokens, position);
    if (!textMateTokenInfo && !semanticTokenInfo) {
      reset(this._domNode, "No grammar or semantic tokens available.");
      return;
    }
    const tmMetadata = textMateTokenInfo == null ? void 0 : textMateTokenInfo.metadata;
    const semMetadata = semanticTokenInfo == null ? void 0 : semanticTokenInfo.metadata;
    const semTokenText = semanticTokenInfo && renderTokenText(this._model.getValueInRange(semanticTokenInfo.range));
    const tmTokenText = textMateTokenInfo && renderTokenText(this._model.getLineContent(position.lineNumber).substring(textMateTokenInfo.token.startIndex, textMateTokenInfo.token.endIndex));
    const tokenText = semTokenText || tmTokenText || "";
    reset(this._domNode, $2("h2.tiw-token", void 0, tokenText, $2("span.tiw-token-length", void 0, `${tokenText.length} ${tokenText.length === 1 ? "char" : "chars"}`)));
    append(this._domNode, $2("hr.tiw-metadata-separator", { "style": "clear:both" }));
    append(this._domNode, $2("table.tiw-metadata-table", void 0, $2("tbody", void 0, $2("tr", void 0, $2("td.tiw-metadata-key", void 0, "language"), $2("td.tiw-metadata-value", void 0, (tmMetadata == null ? void 0 : tmMetadata.languageId) || "")), $2("tr", void 0, $2("td.tiw-metadata-key", void 0, "standard token type"), $2("td.tiw-metadata-value", void 0, this._tokenTypeToString((tmMetadata == null ? void 0 : tmMetadata.tokenType) || 0))), ...this._formatMetadata(semMetadata, tmMetadata))));
    if (semanticTokenInfo) {
      append(this._domNode, $2("hr.tiw-metadata-separator"));
      const table = append(this._domNode, $2("table.tiw-metadata-table", void 0));
      const tbody = append(table, $2("tbody", void 0, $2("tr", void 0, $2("td.tiw-metadata-key", void 0, "semantic token type"), $2("td.tiw-metadata-value", void 0, semanticTokenInfo.type))));
      if (semanticTokenInfo.modifiers.length) {
        append(tbody, $2("tr", void 0, $2("td.tiw-metadata-key", void 0, "modifiers"), $2("td.tiw-metadata-value", void 0, semanticTokenInfo.modifiers.join(" "))));
      }
      if (semanticTokenInfo.metadata) {
        const properties = ["foreground", "bold", "italic", "underline", "strikethrough"];
        const propertiesByDefValue = {};
        const allDefValues = new Array();
        for (const property of properties) {
          if (semanticTokenInfo.metadata[property] !== void 0) {
            const definition = semanticTokenInfo.definitions[property];
            const defValue = this._renderTokenStyleDefinition(definition, property);
            const defValueStr = defValue.map((el) => el instanceof HTMLElement ? el.outerHTML : el).join();
            let properties2 = propertiesByDefValue[defValueStr];
            if (!properties2) {
              propertiesByDefValue[defValueStr] = properties2 = [];
              allDefValues.push([defValue, defValueStr]);
            }
            properties2.push(property);
          }
        }
        for (const [defValue, defValueStr] of allDefValues) {
          append(tbody, $2("tr", void 0, $2("td.tiw-metadata-key", void 0, propertiesByDefValue[defValueStr].join(", ")), $2("td.tiw-metadata-value", void 0, ...defValue)));
        }
      }
    }
    if (textMateTokenInfo) {
      const theme = this._themeService.getColorTheme();
      append(this._domNode, $2("hr.tiw-metadata-separator"));
      const table = append(this._domNode, $2("table.tiw-metadata-table"));
      const tbody = append(table, $2("tbody"));
      if (tmTokenText && tmTokenText !== tokenText) {
        append(tbody, $2("tr", void 0, $2("td.tiw-metadata-key", void 0, "textmate token"), $2("td.tiw-metadata-value", void 0, `${tmTokenText} (${tmTokenText.length})`)));
      }
      const scopes = new Array();
      for (let i = textMateTokenInfo.token.scopes.length - 1; i >= 0; i--) {
        scopes.push(textMateTokenInfo.token.scopes[i]);
        if (i > 0) {
          scopes.push($2("br"));
        }
      }
      append(tbody, $2("tr", void 0, $2("td.tiw-metadata-key", void 0, "textmate scopes"), $2("td.tiw-metadata-value.tiw-metadata-scopes", void 0, ...scopes)));
      const matchingRule = findMatchingThemeRule(theme, textMateTokenInfo.token.scopes, false);
      const semForeground = (_a12 = semanticTokenInfo == null ? void 0 : semanticTokenInfo.metadata) == null ? void 0 : _a12.foreground;
      if (matchingRule) {
        if (semForeground !== textMateTokenInfo.metadata.foreground) {
          let defValue = $2("code.tiw-theme-selector", void 0, matchingRule.rawSelector, $2("br"), JSON.stringify(matchingRule.settings, null, "	"));
          if (semForeground) {
            defValue = $2("s", void 0, defValue);
          }
          append(tbody, $2("tr", void 0, $2("td.tiw-metadata-key", void 0, "foreground"), $2("td.tiw-metadata-value", void 0, defValue)));
        }
      } else if (!semForeground) {
        append(tbody, $2("tr", void 0, $2("td.tiw-metadata-key", void 0, "foreground"), $2("td.tiw-metadata-value", void 0, "No theme selector")));
      }
    }
  }
  _formatMetadata(semantic, tm) {
    const elements = new Array();
    function render(property) {
      const value = (semantic == null ? void 0 : semantic[property]) || (tm == null ? void 0 : tm[property]);
      if (value !== void 0) {
        const semanticStyle = (semantic == null ? void 0 : semantic[property]) ? "tiw-metadata-semantic" : "";
        elements.push($2("tr", void 0, $2("td.tiw-metadata-key", void 0, property), $2(`td.tiw-metadata-value.${semanticStyle}`, void 0, value)));
      }
      return value;
    }
    const foreground = render("foreground");
    const background = render("background");
    if (foreground && background) {
      const backgroundColor = Color.fromHex(background), foregroundColor = Color.fromHex(foreground);
      if (backgroundColor.isOpaque()) {
        elements.push($2("tr", void 0, $2("td.tiw-metadata-key", void 0, "contrast ratio"), $2("td.tiw-metadata-value", void 0, backgroundColor.getContrastRatio(foregroundColor.makeOpaque(backgroundColor)).toFixed(2))));
      } else {
        elements.push($2("tr", void 0, $2("td.tiw-metadata-key", void 0, "Contrast ratio cannot be precise for background colors that use transparency"), $2("td.tiw-metadata-value")));
      }
    }
    const fontStyleLabels = new Array();
    function addStyle(key) {
      let label;
      if (semantic && semantic[key]) {
        label = $2("span.tiw-metadata-semantic", void 0, key);
      } else if (tm && tm[key]) {
        label = key;
      }
      if (label) {
        if (fontStyleLabels.length) {
          fontStyleLabels.push(" ");
        }
        fontStyleLabels.push(label);
      }
    }
    addStyle("bold");
    addStyle("italic");
    addStyle("underline");
    addStyle("strikethrough");
    if (fontStyleLabels.length) {
      elements.push($2("tr", void 0, $2("td.tiw-metadata-key", void 0, "font style"), $2("td.tiw-metadata-value", void 0, ...fontStyleLabels)));
    }
    return elements;
  }
  _decodeMetadata(metadata) {
    const colorMap = this._themeService.getColorTheme().tokenColorMap;
    const languageId = TokenMetadata.getLanguageId(metadata);
    const tokenType = TokenMetadata.getTokenType(metadata);
    const fontStyle = TokenMetadata.getFontStyle(metadata);
    const foreground = TokenMetadata.getForeground(metadata);
    const background = TokenMetadata.getBackground(metadata);
    return {
      languageId: this._languageService.languageIdCodec.decodeLanguageId(languageId),
      tokenType,
      bold: fontStyle & 2 ? true : void 0,
      italic: fontStyle & 1 ? true : void 0,
      underline: fontStyle & 4 ? true : void 0,
      strikethrough: fontStyle & 8 ? true : void 0,
      foreground: colorMap[foreground],
      background: colorMap[background]
    };
  }
  _tokenTypeToString(tokenType) {
    switch (tokenType) {
      case 0:
        return "Other";
      case 1:
        return "Comment";
      case 2:
        return "String";
      case 3:
        return "RegEx";
      default:
        return "??";
    }
  }
  _getTokensAtPosition(grammar, position) {
    const lineNumber = position.lineNumber;
    const stateBeforeLine = this._getStateBeforeLine(grammar, lineNumber);
    const tokenizationResult1 = grammar.tokenizeLine(this._model.getLineContent(lineNumber), stateBeforeLine);
    const tokenizationResult2 = grammar.tokenizeLine2(this._model.getLineContent(lineNumber), stateBeforeLine);
    let token1Index = 0;
    for (let i = tokenizationResult1.tokens.length - 1; i >= 0; i--) {
      const t = tokenizationResult1.tokens[i];
      if (position.column - 1 >= t.startIndex) {
        token1Index = i;
        break;
      }
    }
    let token2Index = 0;
    for (let i = tokenizationResult2.tokens.length >>> 1; i >= 0; i--) {
      if (position.column - 1 >= tokenizationResult2.tokens[i << 1]) {
        token2Index = i;
        break;
      }
    }
    return {
      token: tokenizationResult1.tokens[token1Index],
      metadata: this._decodeMetadata(tokenizationResult2.tokens[(token2Index << 1) + 1])
    };
  }
  _getStateBeforeLine(grammar, lineNumber) {
    let state = null;
    for (let i = 1; i < lineNumber; i++) {
      const tokenizationResult = grammar.tokenizeLine(this._model.getLineContent(i), state);
      state = tokenizationResult.ruleStack;
    }
    return state;
  }
  isSemanticTokens(token) {
    return token && token.data;
  }
  async _computeSemanticTokens(position) {
    if (!this._isSemanticColoringEnabled()) {
      return null;
    }
    const tokenProviders = this._languageFeaturesService.documentSemanticTokensProvider.ordered(this._model);
    if (tokenProviders.length) {
      const provider = tokenProviders[0];
      const tokens = await Promise.resolve(provider.provideDocumentSemanticTokens(this._model, null, this._currentRequestCancellationTokenSource.token));
      if (this.isSemanticTokens(tokens)) {
        return { tokens, legend: provider.getLegend() };
      }
    }
    const rangeTokenProviders = this._languageFeaturesService.documentRangeSemanticTokensProvider.ordered(this._model);
    if (rangeTokenProviders.length) {
      const provider = rangeTokenProviders[0];
      const lineNumber = position.lineNumber;
      const range = new Range(lineNumber, 1, lineNumber, this._model.getLineMaxColumn(lineNumber));
      const tokens = await Promise.resolve(provider.provideDocumentRangeSemanticTokens(this._model, range, this._currentRequestCancellationTokenSource.token));
      if (this.isSemanticTokens(tokens)) {
        return { tokens, legend: provider.getLegend() };
      }
    }
    return null;
  }
  _getSemanticTokenAtPosition(semanticTokens, pos) {
    const tokenData = semanticTokens.tokens.data;
    const defaultLanguage = this._model.getLanguageId();
    let lastLine = 0;
    let lastCharacter = 0;
    const posLine = pos.lineNumber - 1, posCharacter = pos.column - 1;
    for (let i = 0; i < tokenData.length; i += 5) {
      const lineDelta = tokenData[i], charDelta = tokenData[i + 1], len = tokenData[i + 2], typeIdx = tokenData[i + 3], modSet = tokenData[i + 4];
      const line = lastLine + lineDelta;
      const character = lineDelta === 0 ? lastCharacter + charDelta : charDelta;
      if (posLine === line && character <= posCharacter && posCharacter < character + len) {
        const type = semanticTokens.legend.tokenTypes[typeIdx] || "not in legend (ignored)";
        const modifiers = [];
        let modifierSet = modSet;
        for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < semanticTokens.legend.tokenModifiers.length; modifierIndex++) {
          if (modifierSet & 1) {
            modifiers.push(semanticTokens.legend.tokenModifiers[modifierIndex]);
          }
          modifierSet = modifierSet >> 1;
        }
        if (modifierSet > 0) {
          modifiers.push("not in legend (ignored)");
        }
        const range = new Range(line + 1, character + 1, line + 1, character + 1 + len);
        const definitions = {};
        const colorMap = this._themeService.getColorTheme().tokenColorMap;
        const theme = this._themeService.getColorTheme();
        const tokenStyle = theme.getTokenStyleMetadata(type, modifiers, defaultLanguage, true, definitions);
        let metadata = void 0;
        if (tokenStyle) {
          metadata = {
            languageId: void 0,
            tokenType: 0,
            bold: tokenStyle == null ? void 0 : tokenStyle.bold,
            italic: tokenStyle == null ? void 0 : tokenStyle.italic,
            underline: tokenStyle == null ? void 0 : tokenStyle.underline,
            strikethrough: tokenStyle == null ? void 0 : tokenStyle.strikethrough,
            foreground: colorMap[(tokenStyle == null ? void 0 : tokenStyle.foreground) || 0],
            background: void 0
          };
        }
        return { type, modifiers, range, metadata, definitions };
      }
      lastLine = line;
      lastCharacter = character;
    }
    return null;
  }
  _renderTokenStyleDefinition(definition, property) {
    const elements = new Array();
    if (definition === void 0) {
      return elements;
    }
    const theme = this._themeService.getColorTheme();
    if (Array.isArray(definition)) {
      const scopesDefinition = {};
      theme.resolveScopes(definition, scopesDefinition);
      const matchingRule = scopesDefinition[property];
      if (matchingRule && scopesDefinition.scope) {
        const scopes = $2("ul.tiw-metadata-values");
        const strScopes = Array.isArray(matchingRule.scope) ? matchingRule.scope : [String(matchingRule.scope)];
        for (const strScope of strScopes) {
          scopes.appendChild($2("li.tiw-metadata-value.tiw-metadata-scopes", void 0, strScope));
        }
        elements.push(scopesDefinition.scope.join(" "), scopes, $2("code.tiw-theme-selector", void 0, JSON.stringify(matchingRule.settings, null, "	")));
        return elements;
      }
      return elements;
    } else if (SemanticTokenRule.is(definition)) {
      const scope = theme.getTokenStylingRuleScope(definition);
      if (scope === "setting") {
        elements.push(`User settings: ${definition.selector.id} - ${this._renderStyleProperty(definition.style, property)}`);
        return elements;
      } else if (scope === "theme") {
        elements.push(`Color theme: ${definition.selector.id} - ${this._renderStyleProperty(definition.style, property)}`);
        return elements;
      }
      return elements;
    } else {
      const style = theme.resolveTokenStyleValue(definition);
      elements.push(`Default: ${style ? this._renderStyleProperty(style, property) : ""}`);
      return elements;
    }
  }
  _renderStyleProperty(style, property) {
    switch (property) {
      case "foreground":
        return style.foreground ? Color.Format.CSS.formatHexA(style.foreground, true) : "";
      default:
        return style[property] !== void 0 ? String(style[property]) : "";
    }
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._editor.getPosition(),
      preference: [2, 1]
    };
  }
};
_InspectEditorTokensWidget._ID = "editor.contrib.inspectEditorTokensWidget";
var InspectEditorTokensWidget = _InspectEditorTokensWidget;
registerEditorContribution(InspectEditorTokensController.ID, InspectEditorTokensController, 4);
registerEditorAction(InspectEditorTokens);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/saveParticipants.js
init_tslib_es6();
init_strings();
init_editorBrowser();
init_codeEditorService();
init_editOperation();
init_position();
init_range();
init_format();
init_nls();
init_configuration();
init_instantiation();
init_progress();
init_lifecycle();
init_platform2();

// node_modules/vscode/vscode/src/vs/workbench/contrib/format/browser/formatModified.js
init_arrays();
init_cancellation();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_model();
init_editorWorker();
init_resolverService();
init_format();
init_nls();
init_contextkey();
init_instantiation();
init_progress();

// node_modules/vscode/vscode/src/vs/workbench/contrib/scm/browser/dirtydiffDecorator.js
init_tslib_es6();
init_nls();

// node_modules/vscode/vscode/src/vs/workbench/contrib/scm/browser/media/dirtydiffDecorator.css.js
var css2 = '.monaco-editor .dirty-diff-glyph{margin-left:5px;z-index:5}.monaco-editor .dirty-diff-glyph:before{content:"";height:100%;left:-2px;position:absolute;width:0}.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-glyph:before{transition:width 80ms linear,left 80ms linear,transform 80ms linear}.monaco-editor.modified-in-monaco-diff-editor .margin-view-overlays>div>.dirty-diff-glyph{display:none}.monaco-editor .dirty-diff-added{border-left-color:var(--vscode-editorGutter-addedBackground);border-left-style:solid}.monaco-editor .dirty-diff-added:before{background:var(--vscode-editorGutter-addedBackground)}.monaco-editor .dirty-diff-added-pattern{background-repeat:repeat-y}.monaco-editor .dirty-diff-added-pattern,.monaco-editor .dirty-diff-added-pattern:before{background-image:linear-gradient(-45deg,var(--vscode-editorGutter-addedBackground) 25%,var(--vscode-editorGutter-background) 25%,var(--vscode-editorGutter-background) 50%,var(--vscode-editorGutter-addedBackground) 50%,var(--vscode-editorGutter-addedBackground) 75%,var(--vscode-editorGutter-background) 75%,var(--vscode-editorGutter-background))}.monaco-editor .dirty-diff-added-pattern:before{transform:translateX(3px)}.monaco-editor .dirty-diff-modified{border-left-color:var(--vscode-editorGutter-modifiedBackground);border-left-style:solid}.monaco-editor .dirty-diff-modified:before{background:var(--vscode-editorGutter-modifiedBackground)}.monaco-editor .dirty-diff-modified-pattern{background-image:linear-gradient(-45deg,var(--vscode-editorGutter-modifiedBackground) 25%,var(--vscode-editorGutter-background) 25%,var(--vscode-editorGutter-background) 50%,var(--vscode-editorGutter-modifiedBackground) 50%,var(--vscode-editorGutter-modifiedBackground) 75%,var(--vscode-editorGutter-background) 75%,var(--vscode-editorGutter-background));background-repeat:repeat-y}.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-added,.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-added-pattern,.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-modified,.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-modified-pattern{transition:opacity .5s}.monaco-editor .dirty-diff-modified-pattern:before{background-image:linear-gradient(-45deg,var(--vscode-editorGutter-modifiedBackground) 25%,var(--vscode-editorGutter-background) 25%,var(--vscode-editorGutter-background) 50%,var(--vscode-editorGutter-modifiedBackground) 50%,var(--vscode-editorGutter-modifiedBackground) 75%,var(--vscode-editorGutter-background) 75%,var(--vscode-editorGutter-background));transform:translateX(3px)}.monaco-editor .margin:hover .dirty-diff-added,.monaco-editor .margin:hover .dirty-diff-added-pattern,.monaco-editor .margin:hover .dirty-diff-modified,.monaco-editor .margin:hover .dirty-diff-modified-pattern{opacity:1}.monaco-editor .dirty-diff-deleted:after{border-bottom:4px solid transparent;border-left:4px solid var(--vscode-editorGutter-deletedBackground);border-top:4px solid transparent;bottom:-4px;box-sizing:border-box;content:"";height:0;pointer-events:none;position:absolute;width:4px;z-index:9}.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-deleted:after{transition:border-top-width 80ms linear,border-bottom-width 80ms linear,bottom 80ms linear,opacity .5s}.monaco-editor .dirty-diff-deleted:before{background:var(--vscode-editorGutter-deletedBackground);bottom:0;height:0;margin-left:3px}.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-deleted:before{transition:height 80ms linear}.dirty-diff .peekview-title .dropdown{margin-right:10px}.dirty-diff .peekview-title .dropdown.select-container{cursor:default}.dirty-diff .peekview-title .dropdown .monaco-select-box{cursor:pointer;min-height:18px;min-width:100px;padding:0 23px 0 8px}';
n(css2, {});

// node_modules/vscode/vscode/src/vs/workbench/contrib/scm/browser/dirtydiffDecorator.js
init_lifecycle();
init_event();
init_instantiation();
init_configuration();
init_themeService();
init_colorRegistry();
init_editorExtensions();
init_contextkey();
init_editorContextKeys();
init_position();
init_numbers();
init_keybindingsRegistry();
init_actions();
init_resources();
init_actions2();
init_codeEditorService();
init_dom();
init_codicons();
init_themables();
init_color();

// node_modules/vscode/vscode/src/vs/workbench/contrib/scm/browser/dirtyDiffSwitcher.js
init_tslib_es6();
init_nls();
init_actions();
init_themeService();
init_colorRegistry();
var SwitchQuickDiffViewItem = class SwitchQuickDiffViewItem2 extends SelectActionViewItem {
  constructor(action, providers, selected, contextViewService, themeService) {
    const items = providers.map((provider) => ({ provider, text: provider }));
    let startingSelection = providers.indexOf(selected);
    if (startingSelection === -1) {
      startingSelection = 0;
    }
    const styles = { ...defaultSelectBoxStyles };
    const theme = themeService.getColorTheme();
    const editorBackgroundColor = theme.getColor(editorBackground);
    const peekTitleColor = theme.getColor(peekViewTitleBackground);
    const opaqueTitleColor = (peekTitleColor == null ? void 0 : peekTitleColor.makeOpaque(editorBackgroundColor)) ?? editorBackgroundColor;
    styles.selectBackground = opaqueTitleColor.lighten(0.6).toString();
    super(null, action, items, startingSelection, contextViewService, styles, { ariaLabel: localize("remotes", "Switch quick diff base") });
    this.optionsItems = items;
  }
  setSelection(provider) {
    const index = this.optionsItems.findIndex((item) => item.provider === provider);
    this.select(index);
  }
  getActionContext(_, index) {
    return this.optionsItems[index];
  }
  render(container) {
    super.render(container);
    this.setFocusable(true);
  }
};
SwitchQuickDiffViewItem = __decorate([
  __param(3, IContextViewService),
  __param(4, IThemeService)
], SwitchQuickDiffViewItem);
var _SwitchQuickDiffBaseAction = class _SwitchQuickDiffBaseAction extends Action {
  constructor(callback) {
    super(_SwitchQuickDiffBaseAction.ID, _SwitchQuickDiffBaseAction.LABEL, void 0, void 0);
    this.callback = callback;
  }
  async run(event) {
    return this.callback(event);
  }
};
_SwitchQuickDiffBaseAction.ID = "quickDiff.base.switch";
_SwitchQuickDiffBaseAction.LABEL = localize("quickDiff.base.switch", "Switch Quick Diff Base");
var SwitchQuickDiffBaseAction = _SwitchQuickDiffBaseAction;

// node_modules/vscode/vscode/src/vs/workbench/contrib/scm/browser/dirtydiffDecorator.js
var DirtyDiffController_1;
var DiffActionRunner = class extends ActionRunner {
  runAction(action, context) {
    if (action instanceof MenuItemAction) {
      return action.run(...context);
    }
    return super.runAction(action, context);
  }
};
var isDirtyDiffVisible = new RawContextKey("dirtyDiffVisible", false);
function getChangeHeight(change) {
  const modified = change.modifiedEndLineNumber - change.modifiedStartLineNumber + 1;
  const original = change.originalEndLineNumber - change.originalStartLineNumber + 1;
  if (change.originalEndLineNumber === 0) {
    return modified;
  } else if (change.modifiedEndLineNumber === 0) {
    return original;
  } else {
    return modified + original;
  }
}
function getModifiedEndLineNumber(change) {
  if (change.modifiedEndLineNumber === 0) {
    return change.modifiedStartLineNumber === 0 ? 1 : change.modifiedStartLineNumber;
  } else {
    return change.modifiedEndLineNumber;
  }
}
function lineIntersectsChange(lineNumber, change) {
  if (lineNumber === 1 && change.modifiedStartLineNumber === 0 && change.modifiedEndLineNumber === 0) {
    return true;
  }
  return lineNumber >= change.modifiedStartLineNumber && lineNumber <= (change.modifiedEndLineNumber || change.modifiedStartLineNumber);
}
var UIEditorAction = class UIEditorAction2 extends Action {
  constructor(editor, action, cssClass, keybindingService, instantiationService) {
    const keybinding = keybindingService.lookupKeybinding(action.id);
    const label = action.label + (keybinding ? ` (${keybinding.getLabel()})` : "");
    super(action.id, label, cssClass);
    this.instantiationService = instantiationService;
    this.action = action;
    this.editor = editor;
  }
  run() {
    return Promise.resolve(this.instantiationService.invokeFunction((accessor) => this.action.run(accessor, this.editor, null)));
  }
};
UIEditorAction = __decorate([
  __param(3, IKeybindingService),
  __param(4, IInstantiationService)
], UIEditorAction);
var ChangeType;
(function(ChangeType2) {
  ChangeType2[ChangeType2["Modify"] = 0] = "Modify";
  ChangeType2[ChangeType2["Add"] = 1] = "Add";
  ChangeType2[ChangeType2["Delete"] = 2] = "Delete";
})(ChangeType || (ChangeType = {}));
function getChangeType(change) {
  if (change.originalEndLineNumber === 0) {
    return ChangeType.Add;
  } else if (change.modifiedEndLineNumber === 0) {
    return ChangeType.Delete;
  } else {
    return ChangeType.Modify;
  }
}
function getChangeTypeColor(theme, changeType) {
  switch (changeType) {
    case ChangeType.Modify:
      return theme.getColor(editorGutterModifiedBackground);
    case ChangeType.Add:
      return theme.getColor(editorGutterAddedBackground);
    case ChangeType.Delete:
      return theme.getColor(editorGutterDeletedBackground);
  }
}
function getOuterEditorFromDiffEditor(accessor) {
  const diffEditors = accessor.get(ICodeEditorService).listDiffEditors();
  for (const diffEditor of diffEditors) {
    if (diffEditor.hasTextFocus() && diffEditor instanceof EmbeddedDiffEditorWidget) {
      return diffEditor.getParentEditor();
    }
  }
  return getOuterEditor(accessor);
}
var DirtyDiffWidget = class DirtyDiffWidget2 extends PeekViewWidget {
  constructor(editor, model, themeService, instantiationService, menuService, contextKeyService) {
    super(editor, { isResizeable: true, frameWidth: 1, keepEditorSelection: true, className: "dirty-diff" }, instantiationService);
    this.model = model;
    this.themeService = themeService;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this._index = 0;
    this._provider = "";
    this.height = void 0;
    this._disposables.add(themeService.onDidColorThemeChange(this._applyTheme, this));
    this._applyTheme(themeService.getColorTheme());
    if (this.model.original.length > 0) {
      contextKeyService = contextKeyService.createOverlay([["originalResourceScheme", this.model.original[0].uri.scheme], ["originalResourceSchemes", this.model.original.map((original) => original.uri.scheme)]]);
    }
    this.create();
    if (editor.hasModel()) {
      this.title = basename2(editor.getModel().uri);
    } else {
      this.title = "";
    }
    this.setTitle(this.title);
  }
  get provider() {
    return this._provider;
  }
  get index() {
    return this._index;
  }
  get visibleRange() {
    const visibleRanges = this.diffEditor.getModifiedEditor().getVisibleRanges();
    return visibleRanges.length >= 0 ? visibleRanges[0] : void 0;
  }
  showChange(index, usePosition = true) {
    var _a12;
    const labeledChange = this.model.changes[index];
    const change = labeledChange.change;
    this._index = index;
    this.contextKeyService.createKey("originalResourceScheme", this.model.changes[index].uri.scheme);
    this.updateActions();
    this._provider = labeledChange.label;
    this.change = change;
    const originalModel = this.model.original;
    if (!originalModel) {
      return;
    }
    const onFirstDiffUpdate = Event.once(this.diffEditor.onDidUpdateDiff);
    onFirstDiffUpdate(() => setTimeout(() => this.revealChange(change), 0));
    const diffEditorModel = this.model.getDiffEditorModel(labeledChange.uri.toString());
    if (!diffEditorModel) {
      return;
    }
    this.diffEditor.setModel(diffEditorModel);
    (_a12 = this.dropdown) == null ? void 0 : _a12.setSelection(labeledChange.label);
    const position = new Position(getModifiedEndLineNumber(change), 1);
    const lineHeight = this.editor.getOption(65);
    const editorHeight = this.editor.getLayoutInfo().height;
    const editorHeightInLines = Math.floor(editorHeight / lineHeight);
    const height = Math.min(getChangeHeight(change) + 8, Math.floor(editorHeightInLines / 3));
    this.renderTitle(labeledChange.label);
    const changeType = getChangeType(change);
    const changeTypeColor = getChangeTypeColor(this.themeService.getColorTheme(), changeType);
    this.style({ frameColor: changeTypeColor, arrowColor: changeTypeColor });
    const providerSpecificChanges = [];
    let contextIndex = index;
    for (const change2 of this.model.changes) {
      if (change2.label === this.model.changes[this._index].label) {
        providerSpecificChanges.push(change2.change);
        if (labeledChange === change2) {
          contextIndex = providerSpecificChanges.length - 1;
        }
      }
    }
    this._actionbarWidget.context = [diffEditorModel.modified.uri, providerSpecificChanges, contextIndex];
    if (usePosition) {
      this.show(position, height);
    }
    this.editor.focus();
  }
  renderTitle(label) {
    const providerChanges = this.model.mapChanges.get(label);
    const providerIndex = providerChanges.indexOf(this._index);
    let detail;
    if (!this.shouldUseDropdown()) {
      detail = this.model.changes.length > 1 ? localize(
        "changes",
        "{0} - {1} of {2} changes",
        label,
        providerIndex + 1,
        providerChanges.length
      ) : localize(
        "change",
        "{0} - {1} of {2} change",
        label,
        providerIndex + 1,
        providerChanges.length
      );
      this.dropdownContainer.style.display = "none";
    } else {
      detail = this.model.changes.length > 1 ? localize(
        "multiChanges",
        "{0} of {1} changes",
        providerIndex + 1,
        providerChanges.length
      ) : localize(
        "multiChange",
        "{0} of {1} change",
        providerIndex + 1,
        providerChanges.length
      );
      this.dropdownContainer.style.display = "inherit";
    }
    this.setTitle(this.title, detail);
  }
  switchQuickDiff(event) {
    const newProvider = event == null ? void 0 : event.provider;
    if (newProvider === this.model.changes[this._index].label) {
      return;
    }
    let closestGreaterIndex = this._index < this.model.changes.length - 1 ? this._index + 1 : 0;
    for (let i = closestGreaterIndex; i !== this._index; i < this.model.changes.length - 1 ? i++ : i = 0) {
      if (this.model.changes[i].label === newProvider) {
        closestGreaterIndex = i;
        break;
      }
    }
    let closestLesserIndex = this._index > 0 ? this._index - 1 : this.model.changes.length - 1;
    for (let i = closestLesserIndex; i !== this._index; i >= 0 ? i-- : i = this.model.changes.length - 1) {
      if (this.model.changes[i].label === newProvider) {
        closestLesserIndex = i;
        break;
      }
    }
    const closestIndex = Math.abs(this.model.changes[closestGreaterIndex].change.modifiedEndLineNumber - this.model.changes[this._index].change.modifiedEndLineNumber) < Math.abs(this.model.changes[closestLesserIndex].change.modifiedEndLineNumber - this.model.changes[this._index].change.modifiedEndLineNumber) ? closestGreaterIndex : closestLesserIndex;
    this.showChange(closestIndex, false);
  }
  shouldUseDropdown() {
    let providersWithChangesCount = 0;
    if (this.model.mapChanges.size > 1) {
      const keys = Array.from(this.model.mapChanges.keys());
      for (let i = 0; i < keys.length && providersWithChangesCount <= 1; i++) {
        if (this.model.mapChanges.get(keys[i]).length > 0) {
          providersWithChangesCount++;
        }
      }
    }
    return providersWithChangesCount >= 2;
  }
  updateActions() {
    if (!this._actionbarWidget) {
      return;
    }
    const previous = this.instantiationService.createInstance(UIEditorAction, this.editor, new ShowPreviousChangeAction(this.editor), ThemeIcon.asClassName(gotoPreviousLocation));
    const next = this.instantiationService.createInstance(UIEditorAction, this.editor, new ShowNextChangeAction(this.editor), ThemeIcon.asClassName(gotoNextLocation));
    this._disposables.add(previous);
    this._disposables.add(next);
    const actions = [];
    if (this.menu) {
      this.menu.dispose();
    }
    this.menu = this.menuService.createMenu(MenuId.SCMChangeContext, this.contextKeyService);
    createAndFillInActionBarActions(this.menu, { shouldForwardArgs: true }, actions);
    this._actionbarWidget.clear();
    this._actionbarWidget.push(actions.reverse(), { label: false, icon: true });
    this._actionbarWidget.push([next, previous], { label: false, icon: true });
    this._actionbarWidget.push(new Action("peekview.close", localize("label.close", "Close"), ThemeIcon.asClassName(Codicon.close), true, () => this.dispose()), { label: false, icon: true });
  }
  _fillHead(container) {
    super._fillHead(container, true);
    this.dropdownContainer = prepend(this._titleElement, $(".dropdown"));
    this.dropdown = this.instantiationService.createInstance(SwitchQuickDiffViewItem, new SwitchQuickDiffBaseAction((event) => this.switchQuickDiff(event)), this.model.quickDiffs.map((quickDiffer) => quickDiffer.label), this.model.changes[this._index].label);
    this.dropdown.render(this.dropdownContainer);
    this.updateActions();
  }
  _getActionBarOptions() {
    const actionRunner = new DiffActionRunner();
    actionRunner.onDidRun((e) => {
      if (!(e.action instanceof UIEditorAction) && !e.error) {
        this.dispose();
      }
    });
    return {
      ...super._getActionBarOptions(),
      actionRunner
    };
  }
  _fillBody(container) {
    const options = {
      scrollBeyondLastLine: true,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: true,
      minimap: { enabled: false },
      renderSideBySide: false,
      readOnly: false,
      renderIndicators: false,
      diffAlgorithm: "advanced",
      stickyScroll: { enabled: false }
    };
    this.diffEditor = this.instantiationService.createInstance(EmbeddedDiffEditorWidget, container, options, {}, this.editor);
    this._disposables.add(this.diffEditor);
  }
  _onWidth(width) {
    if (typeof this.height === "undefined") {
      return;
    }
    this.diffEditor.layout({ height: this.height, width });
  }
  _doLayoutBody(height, width) {
    super._doLayoutBody(height, width);
    this.diffEditor.layout({ height, width });
    if (typeof this.height === "undefined" && this.change) {
      this.revealChange(this.change);
    }
    this.height = height;
  }
  revealChange(change) {
    let start, end;
    if (change.modifiedEndLineNumber === 0) {
      start = change.modifiedStartLineNumber;
      end = change.modifiedStartLineNumber + 1;
    } else if (change.originalEndLineNumber > 0) {
      start = change.modifiedStartLineNumber - 1;
      end = change.modifiedEndLineNumber + 1;
    } else {
      start = change.modifiedStartLineNumber;
      end = change.modifiedEndLineNumber;
    }
    this.diffEditor.revealLinesInCenter(start, end, 1);
  }
  _applyTheme(theme) {
    const borderColor = theme.getColor(peekViewBorder) || Color.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor,
      headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color.transparent,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  revealRange(range) {
    this.editor.revealLineInCenterIfOutsideViewport(range.endLineNumber, 0);
  }
  hasFocus() {
    return this.diffEditor.hasTextFocus();
  }
  dispose() {
    var _a12;
    super.dispose();
    (_a12 = this.menu) == null ? void 0 : _a12.dispose();
  }
};
DirtyDiffWidget = __decorate([
  __param(2, IThemeService),
  __param(3, IInstantiationService),
  __param(4, IMenuService),
  __param(5, IContextKeyService)
], DirtyDiffWidget);
var ShowPreviousChangeAction = class extends EditorAction {
  constructor(outerEditor) {
    super({
      id: "editor.action.dirtydiff.previous",
      label: localize("show previous change", "Show Previous Change"),
      alias: "Show Previous Change",
      precondition: TextCompareEditorActiveContext.toNegated(),
      kbOpts: { kbExpr: EditorContextKeys.editorTextFocus, primary: 1024 | 512 | 61, weight: 100 }
    });
    this.outerEditor = outerEditor;
  }
  run(accessor) {
    const outerEditor = this.outerEditor ?? getOuterEditorFromDiffEditor(accessor);
    if (!outerEditor) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller) {
      return;
    }
    if (!controller.canNavigate()) {
      return;
    }
    controller.previous();
  }
};
registerEditorAction(ShowPreviousChangeAction);
var ShowNextChangeAction = class extends EditorAction {
  constructor(outerEditor) {
    super({
      id: "editor.action.dirtydiff.next",
      label: localize("show next change", "Show Next Change"),
      alias: "Show Next Change",
      precondition: TextCompareEditorActiveContext.toNegated(),
      kbOpts: { kbExpr: EditorContextKeys.editorTextFocus, primary: 512 | 61, weight: 100 }
    });
    this.outerEditor = outerEditor;
  }
  run(accessor) {
    const outerEditor = this.outerEditor ?? getOuterEditorFromDiffEditor(accessor);
    if (!outerEditor) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller) {
      return;
    }
    if (!controller.canNavigate()) {
      return;
    }
    controller.next();
  }
};
registerEditorAction(ShowNextChangeAction);
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "7_change_nav",
  command: {
    id: "editor.action.dirtydiff.next",
    title: localize(
      { key: "miGotoNextChange", comment: ["&& denotes a mnemonic"] },
      "Next &&Change"
    )
  },
  order: 1
});
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "7_change_nav",
  command: {
    id: "editor.action.dirtydiff.previous",
    title: localize(
      { key: "miGotoPreviousChange", comment: ["&& denotes a mnemonic"] },
      "Previous &&Change"
    )
  },
  order: 2
});
var GotoPreviousChangeAction = class extends EditorAction {
  constructor() {
    super({
      id: "workbench.action.editor.previousChange",
      label: localize("move to previous change", "Go to Previous Change"),
      alias: "Go to Previous Change",
      precondition: TextCompareEditorActiveContext.toNegated(),
      kbOpts: { kbExpr: EditorContextKeys.editorTextFocus, primary: 1024 | 512 | 63, weight: 100 }
    });
  }
  async run(accessor) {
    const outerEditor = getOuterEditorFromDiffEditor(accessor);
    const audioCueService = accessor.get(IAudioCueService);
    const accessibilityService = accessor.get(IAccessibilityService);
    const codeEditorService = accessor.get(ICodeEditorService);
    if (!outerEditor || !outerEditor.hasModel()) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller || !controller.modelRegistry) {
      return;
    }
    const lineNumber = outerEditor.getPosition().lineNumber;
    const model = controller.modelRegistry.getModel(outerEditor.getModel());
    if (!model || model.changes.length === 0) {
      return;
    }
    const index = model.findPreviousClosestChange(lineNumber, false);
    const change = model.changes[index];
    await playAudioCueForChange(change.change, audioCueService);
    setPositionAndSelection(change.change, outerEditor, accessibilityService, codeEditorService);
  }
};
registerEditorAction(GotoPreviousChangeAction);
var GotoNextChangeAction = class extends EditorAction {
  constructor() {
    super({
      id: "workbench.action.editor.nextChange",
      label: localize("move to next change", "Go to Next Change"),
      alias: "Go to Next Change",
      precondition: TextCompareEditorActiveContext.toNegated(),
      kbOpts: { kbExpr: EditorContextKeys.editorTextFocus, primary: 512 | 63, weight: 100 }
    });
  }
  async run(accessor) {
    const audioCueService = accessor.get(IAudioCueService);
    const outerEditor = getOuterEditorFromDiffEditor(accessor);
    const accessibilityService = accessor.get(IAccessibilityService);
    const codeEditorService = accessor.get(ICodeEditorService);
    if (!outerEditor || !outerEditor.hasModel()) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller || !controller.modelRegistry) {
      return;
    }
    const lineNumber = outerEditor.getPosition().lineNumber;
    const model = controller.modelRegistry.getModel(outerEditor.getModel());
    if (!model || model.changes.length === 0) {
      return;
    }
    const index = model.findNextClosestChange(lineNumber, false);
    const change = model.changes[index].change;
    await playAudioCueForChange(change, audioCueService);
    setPositionAndSelection(change, outerEditor, accessibilityService, codeEditorService);
  }
};
function setPositionAndSelection(change, editor, accessibilityService, codeEditorService) {
  var _a12;
  const position = new Position(change.modifiedStartLineNumber, 1);
  editor.setPosition(position);
  editor.revealPositionInCenter(position);
  if (accessibilityService.isScreenReaderOptimized()) {
    editor.setSelection({ startLineNumber: change.modifiedStartLineNumber, startColumn: 0, endLineNumber: change.modifiedStartLineNumber, endColumn: Number.MAX_VALUE });
    (_a12 = codeEditorService.getActiveCodeEditor()) == null ? void 0 : _a12.writeScreenReaderContent("diff-navigation");
  }
}
async function playAudioCueForChange(change, audioCueService) {
  const changeType = getChangeType(change);
  switch (changeType) {
    case ChangeType.Add:
      audioCueService.playAudioCue(AudioCue.diffLineInserted, { allowManyInParallel: true, source: "dirtyDiffDecoration" });
      break;
    case ChangeType.Delete:
      audioCueService.playAudioCue(AudioCue.diffLineDeleted, { allowManyInParallel: true, source: "dirtyDiffDecoration" });
      break;
    case ChangeType.Modify:
      audioCueService.playAudioCue(AudioCue.diffLineModified, { allowManyInParallel: true, source: "dirtyDiffDecoration" });
      break;
  }
}
registerEditorAction(GotoNextChangeAction);
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "closeDirtyDiff",
  weight: 100 + 50,
  primary: 9,
  secondary: [1024 | 9],
  when: ContextKeyExpr.and(isDirtyDiffVisible),
  handler: (accessor) => {
    const outerEditor = getOuterEditorFromDiffEditor(accessor);
    if (!outerEditor) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller) {
      return;
    }
    controller.close();
  }
});
var _a6;
var DirtyDiffController = (_a6 = class extends Disposable {
  static get(editor) {
    return editor.getContribution(DirtyDiffController_1.ID);
  }
  constructor(editor, contextKeyService, configurationService, instantiationService) {
    super();
    this.editor = editor;
    this.configurationService = configurationService;
    this.instantiationService = instantiationService;
    this.modelRegistry = null;
    this.model = null;
    this.widget = null;
    this.session = Disposable.None;
    this.mouseDownInfo = null;
    this.enabled = false;
    this.gutterActionDisposables = new DisposableStore();
    this.enabled = !contextKeyService.getContextKeyValue("isInDiffEditor");
    this.stylesheet = createStyleSheet();
    this._register(toDisposable(() => this.stylesheet.remove()));
    if (this.enabled) {
      this.isDirtyDiffVisible = isDirtyDiffVisible.bindTo(contextKeyService);
      this._register(editor.onDidChangeModel(() => this.close()));
      const onDidChangeGutterAction = Event.filter(configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration("scm.diffDecorationsGutterAction"));
      this._register(onDidChangeGutterAction(this.onDidChangeGutterAction, this));
      this.onDidChangeGutterAction();
    }
  }
  onDidChangeGutterAction() {
    const gutterAction = this.configurationService.getValue("scm.diffDecorationsGutterAction");
    this.gutterActionDisposables.dispose();
    this.gutterActionDisposables = new DisposableStore();
    if (gutterAction === "diff") {
      this.gutterActionDisposables.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
      this.gutterActionDisposables.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
      this.stylesheet.textContent = `
				.monaco-editor .dirty-diff-glyph {
					cursor: pointer;
				}

				.monaco-editor .margin-view-overlays .dirty-diff-glyph:hover::before {
					height: 100%;
					width: 6px;
					left: -6px;
				}

				.monaco-editor .margin-view-overlays .dirty-diff-deleted:hover::after {
					bottom: 0;
					border-top-width: 0;
					border-bottom-width: 0;
				}
			`;
    } else {
      this.stylesheet.textContent = ``;
    }
  }
  canNavigate() {
    var _a12;
    return !this.widget || ((_a12 = this.widget) == null ? void 0 : _a12.index) === -1 || !!this.model && this.model.changes.length > 1;
  }
  refresh() {
    var _a12;
    (_a12 = this.widget) == null ? void 0 : _a12.showChange(this.widget.index, false);
  }
  next(lineNumber) {
    if (!this.assertWidget()) {
      return;
    }
    if (!this.widget || !this.model) {
      return;
    }
    let index;
    if (this.editor.hasModel() && (typeof lineNumber === "number" || !this.widget.provider)) {
      index = this.model.findNextClosestChange(typeof lineNumber === "number" ? lineNumber : this.editor.getPosition().lineNumber, true, this.widget.provider);
    } else {
      const providerChanges = this.model.mapChanges.get(this.widget.provider) ?? this.model.mapChanges.values().next().value;
      const mapIndex = providerChanges.findIndex((value) => value === this.widget.index);
      index = providerChanges[rot(mapIndex + 1, providerChanges.length)];
    }
    this.widget.showChange(index);
  }
  previous(lineNumber) {
    if (!this.assertWidget()) {
      return;
    }
    if (!this.widget || !this.model) {
      return;
    }
    let index;
    if (this.editor.hasModel() && typeof lineNumber === "number") {
      index = this.model.findPreviousClosestChange(typeof lineNumber === "number" ? lineNumber : this.editor.getPosition().lineNumber, true, this.widget.provider);
    } else {
      const providerChanges = this.model.mapChanges.get(this.widget.provider) ?? this.model.mapChanges.values().next().value;
      const mapIndex = providerChanges.findIndex((value) => value === this.widget.index);
      index = providerChanges[rot(mapIndex - 1, providerChanges.length)];
    }
    this.widget.showChange(index);
  }
  close() {
    this.session.dispose();
    this.session = Disposable.None;
  }
  assertWidget() {
    if (!this.enabled) {
      return false;
    }
    if (this.widget) {
      if (!this.model || this.model.changes.length === 0) {
        this.close();
        return false;
      }
      return true;
    }
    if (!this.modelRegistry) {
      return false;
    }
    const editorModel = this.editor.getModel();
    if (!editorModel) {
      return false;
    }
    const model = this.modelRegistry.getModel(editorModel);
    if (!model) {
      return false;
    }
    if (model.changes.length === 0) {
      return false;
    }
    this.model = model;
    this.widget = this.instantiationService.createInstance(DirtyDiffWidget, this.editor, model);
    this.isDirtyDiffVisible.set(true);
    const disposables = new DisposableStore();
    disposables.add(Event.once(this.widget.onDidClose)(this.close, this));
    Event.chain(model.onDidChange).filter((e) => e.diff.length > 0).map((e) => e.diff).event(this.onDidModelChange, this, disposables);
    disposables.add(this.widget);
    disposables.add(toDisposable(() => {
      this.model = null;
      this.widget = null;
      this.isDirtyDiffVisible.set(false);
      this.editor.focus();
    }));
    this.session = disposables;
    return true;
  }
  onDidModelChange(splices) {
    if (!this.model || !this.widget || this.widget.hasFocus()) {
      return;
    }
    for (const splice of splices) {
      if (splice.start <= this.widget.index) {
        this.next();
        return;
      }
    }
    this.refresh();
  }
  onEditorMouseDown(e) {
    this.mouseDownInfo = null;
    const range = e.target.range;
    if (!range) {
      return;
    }
    if (!e.event.leftButton) {
      return;
    }
    if (e.target.type !== 4) {
      return;
    }
    if (!e.target.element) {
      return;
    }
    if (e.target.element.className.indexOf("dirty-diff-glyph") < 0) {
      return;
    }
    const data = e.target.detail;
    const offsetLeftInGutter = e.target.element.offsetLeft;
    const gutterOffsetX = data.offsetX - offsetLeftInGutter;
    if (gutterOffsetX < -3 || gutterOffsetX > 3) {
      return;
    }
    this.mouseDownInfo = { lineNumber: range.startLineNumber };
  }
  onEditorMouseUp(e) {
    var _a12;
    if (!this.mouseDownInfo) {
      return;
    }
    const { lineNumber } = this.mouseDownInfo;
    this.mouseDownInfo = null;
    const range = e.target.range;
    if (!range || range.startLineNumber !== lineNumber) {
      return;
    }
    if (e.target.type !== 4) {
      return;
    }
    if (!this.modelRegistry) {
      return;
    }
    const editorModel = this.editor.getModel();
    if (!editorModel) {
      return;
    }
    const model = this.modelRegistry.getModel(editorModel);
    if (!model) {
      return;
    }
    const index = model.changes.findIndex((change) => lineIntersectsChange(lineNumber, change.change));
    if (index < 0) {
      return;
    }
    if (index === ((_a12 = this.widget) == null ? void 0 : _a12.index)) {
      this.close();
    } else {
      this.next(lineNumber);
    }
  }
  getChanges() {
    if (!this.modelRegistry) {
      return [];
    }
    if (!this.editor.hasModel()) {
      return [];
    }
    const model = this.modelRegistry.getModel(this.editor.getModel());
    if (!model) {
      return [];
    }
    return model.changes.map((change) => change.change);
  }
  dispose() {
    this.gutterActionDisposables.dispose();
    super.dispose();
  }
}, DirtyDiffController_1 = _a6, _a6.ID = "editor.contrib.dirtydiff", _a6);
DirtyDiffController = DirtyDiffController_1 = __decorate([
  __param(1, IContextKeyService),
  __param(2, IConfigurationService),
  __param(3, IInstantiationService)
], DirtyDiffController);
var editorGutterModifiedBackground = registerColor("editorGutter.modifiedBackground", {
  dark: "#1B81A8",
  light: "#2090D3",
  hcDark: "#1B81A8",
  hcLight: "#2090D3"
}, localize(
  "editorGutterModifiedBackground",
  "Editor gutter background color for lines that are modified."
));
var editorGutterAddedBackground = registerColor("editorGutter.addedBackground", {
  dark: "#487E02",
  light: "#48985D",
  hcDark: "#487E02",
  hcLight: "#48985D"
}, localize(
  "editorGutterAddedBackground",
  "Editor gutter background color for lines that are added."
));
var editorGutterDeletedBackground = registerColor("editorGutter.deletedBackground", {
  dark: editorErrorForeground,
  light: editorErrorForeground,
  hcDark: editorErrorForeground,
  hcLight: editorErrorForeground
}, localize(
  "editorGutterDeletedBackground",
  "Editor gutter background color for lines that are deleted."
));
registerColor("minimapGutter.modifiedBackground", {
  dark: editorGutterModifiedBackground,
  light: editorGutterModifiedBackground,
  hcDark: editorGutterModifiedBackground,
  hcLight: editorGutterModifiedBackground
}, localize(
  "minimapGutterModifiedBackground",
  "Minimap gutter background color for lines that are modified."
));
registerColor("minimapGutter.addedBackground", {
  dark: editorGutterAddedBackground,
  light: editorGutterAddedBackground,
  hcDark: editorGutterAddedBackground,
  hcLight: editorGutterAddedBackground
}, localize(
  "minimapGutterAddedBackground",
  "Minimap gutter background color for lines that are added."
));
registerColor("minimapGutter.deletedBackground", {
  dark: editorGutterDeletedBackground,
  light: editorGutterDeletedBackground,
  hcDark: editorGutterDeletedBackground,
  hcLight: editorGutterDeletedBackground
}, localize(
  "minimapGutterDeletedBackground",
  "Minimap gutter background color for lines that are deleted."
));
registerColor("editorOverviewRuler.modifiedForeground", { dark: transparent(editorGutterModifiedBackground, 0.6), light: transparent(editorGutterModifiedBackground, 0.6), hcDark: transparent(editorGutterModifiedBackground, 0.6), hcLight: transparent(editorGutterModifiedBackground, 0.6) }, localize(
  "overviewRulerModifiedForeground",
  "Overview ruler marker color for modified content."
));
registerColor("editorOverviewRuler.addedForeground", { dark: transparent(editorGutterAddedBackground, 0.6), light: transparent(editorGutterAddedBackground, 0.6), hcDark: transparent(editorGutterAddedBackground, 0.6), hcLight: transparent(editorGutterAddedBackground, 0.6) }, localize(
  "overviewRulerAddedForeground",
  "Overview ruler marker color for added content."
));
registerColor("editorOverviewRuler.deletedForeground", { dark: transparent(editorGutterDeletedBackground, 0.6), light: transparent(editorGutterDeletedBackground, 0.6), hcDark: transparent(editorGutterDeletedBackground, 0.6), hcLight: transparent(editorGutterDeletedBackground, 0.6) }, localize(
  "overviewRulerDeletedForeground",
  "Overview ruler marker color for deleted content."
));
async function getOriginalResource(quickDiffService, uri, language, isSynchronized) {
  const quickDiffs = await quickDiffService.getQuickDiffs(uri, language, isSynchronized);
  return quickDiffs.length > 0 ? quickDiffs[0].originalResource : null;
}
registerEditorContribution(DirtyDiffController.ID, DirtyDiffController, 1);

// node_modules/vscode/vscode/src/vs/workbench/contrib/format/browser/formatModified.js
registerEditorAction(class FormatModifiedAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatChanges",
      label: localize("formatChanges", "Format Modified Lines"),
      alias: "Format Modified Lines",
      precondition: ContextKeyExpr.and(
        EditorContextKeys.writable,
        EditorContextKeys.hasDocumentSelectionFormattingProvider
      )
    });
  }
  async run(accessor, editor) {
    const instaService = accessor.get(IInstantiationService);
    if (!editor.hasModel()) {
      return;
    }
    const ranges = await instaService.invokeFunction(getModifiedRanges, editor.getModel());
    if (isNonEmptyArray(ranges)) {
      return instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor, ranges, 1, Progress.None, CancellationToken.None);
    }
  }
});
async function getModifiedRanges(accessor, modified) {
  const quickDiffService = accessor.get(IQuickDiffService);
  const workerService = accessor.get(IEditorWorkerService);
  const modelService = accessor.get(ITextModelService);
  const original = await getOriginalResource(quickDiffService, modified.uri, modified.getLanguageId(), shouldSynchronizeModel(modified));
  if (!original) {
    return null;
  }
  const ranges = [];
  const ref = await modelService.createModelReference(original);
  try {
    if (!workerService.canComputeDirtyDiff(original, modified.uri)) {
      return void 0;
    }
    const changes = await workerService.computeDirtyDiff(original, modified.uri, false);
    if (!isNonEmptyArray(changes)) {
      return void 0;
    }
    for (const change of changes) {
      ranges.push(modified.validateRange(new Range(
        change.modifiedStartLineNumber,
        1,
        change.modifiedEndLineNumber || change.modifiedStartLineNumber,
        Number.MAX_SAFE_INTEGER
      )));
    }
  } finally {
    ref.dispose();
  }
  return ranges;
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/saveParticipants.js
init_languageFeatures();
var TrimWhitespaceParticipant = class TrimWhitespaceParticipant2 {
  constructor(configurationService, codeEditorService) {
    this.configurationService = configurationService;
    this.codeEditorService = codeEditorService;
  }
  async participate(model, env) {
    if (!model.textEditorModel) {
      return;
    }
    if (this.configurationService.getValue("files.trimTrailingWhitespace", { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource })) {
      this.doTrimTrailingWhitespace(model.textEditorModel, env.reason === 2);
    }
  }
  doTrimTrailingWhitespace(model, isAutoSaved) {
    var _a12;
    let prevSelection = [];
    let cursors = [];
    const editor = findEditor(model, this.codeEditorService);
    if (editor) {
      prevSelection = editor.getSelections();
      if (isAutoSaved) {
        cursors = prevSelection.map((s) => s.getPosition());
        const snippetsRange = (_a12 = SnippetController2.get(editor)) == null ? void 0 : _a12.getSessionEnclosingRange();
        if (snippetsRange) {
          for (let lineNumber = snippetsRange.startLineNumber; lineNumber <= snippetsRange.endLineNumber; lineNumber++) {
            cursors.push(new Position(lineNumber, model.getLineMaxColumn(lineNumber)));
          }
        }
      }
    }
    const ops = trimTrailingWhitespace(model, cursors);
    if (!ops.length) {
      return;
    }
    model.pushEditOperations(prevSelection, ops, (_edits) => prevSelection);
  }
};
TrimWhitespaceParticipant = __decorate([
  __param(0, IConfigurationService),
  __param(1, ICodeEditorService)
], TrimWhitespaceParticipant);
function findEditor(model, codeEditorService) {
  let candidate = null;
  if (model.isAttachedToEditor()) {
    for (const editor of codeEditorService.listCodeEditors()) {
      if (editor.hasModel() && editor.getModel() === model) {
        if (editor.hasTextFocus()) {
          return editor;
        }
        candidate = editor;
      }
    }
  }
  return candidate;
}
var FinalNewLineParticipant = class FinalNewLineParticipant2 {
  constructor(configurationService, codeEditorService) {
    this.configurationService = configurationService;
    this.codeEditorService = codeEditorService;
  }
  async participate(model, _env) {
    if (!model.textEditorModel) {
      return;
    }
    if (this.configurationService.getValue("files.insertFinalNewline", { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource })) {
      this.doInsertFinalNewLine(model.textEditorModel);
    }
  }
  doInsertFinalNewLine(model) {
    const lineCount = model.getLineCount();
    const lastLine = model.getLineContent(lineCount);
    const lastLineIsEmptyOrWhitespace = lastNonWhitespaceIndex(lastLine) === -1;
    if (!lineCount || lastLineIsEmptyOrWhitespace) {
      return;
    }
    const edits = [EditOperation.insert(new Position(lineCount, model.getLineMaxColumn(lineCount)), model.getEOL())];
    const editor = findEditor(model, this.codeEditorService);
    if (editor) {
      editor.executeEdits("insertFinalNewLine", edits, editor.getSelections());
    } else {
      model.pushEditOperations([], edits, () => null);
    }
  }
};
FinalNewLineParticipant = __decorate([
  __param(0, IConfigurationService),
  __param(1, ICodeEditorService)
], FinalNewLineParticipant);
var TrimFinalNewLinesParticipant = class TrimFinalNewLinesParticipant2 {
  constructor(configurationService, codeEditorService) {
    this.configurationService = configurationService;
    this.codeEditorService = codeEditorService;
  }
  async participate(model, env) {
    if (!model.textEditorModel) {
      return;
    }
    if (this.configurationService.getValue("files.trimFinalNewlines", { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource })) {
      this.doTrimFinalNewLines(model.textEditorModel, env.reason === 2);
    }
  }
  findLastNonEmptyLine(model) {
    for (let lineNumber = model.getLineCount(); lineNumber >= 1; lineNumber--) {
      const lineContent = model.getLineContent(lineNumber);
      if (lineContent.length > 0) {
        return lineNumber;
      }
    }
    return 0;
  }
  doTrimFinalNewLines(model, isAutoSaved) {
    const lineCount = model.getLineCount();
    if (lineCount === 1) {
      return;
    }
    let prevSelection = [];
    let cannotTouchLineNumber = 0;
    const editor = findEditor(model, this.codeEditorService);
    if (editor) {
      prevSelection = editor.getSelections();
      if (isAutoSaved) {
        for (let i = 0, len = prevSelection.length; i < len; i++) {
          const positionLineNumber = prevSelection[i].positionLineNumber;
          if (positionLineNumber > cannotTouchLineNumber) {
            cannotTouchLineNumber = positionLineNumber;
          }
        }
      }
    }
    const lastNonEmptyLine = this.findLastNonEmptyLine(model);
    const deleteFromLineNumber = Math.max(lastNonEmptyLine + 1, cannotTouchLineNumber + 1);
    const deletionRange = model.validateRange(new Range(deleteFromLineNumber, 1, lineCount, model.getLineMaxColumn(lineCount)));
    if (deletionRange.isEmpty()) {
      return;
    }
    model.pushEditOperations(prevSelection, [EditOperation.delete(deletionRange)], (_edits) => prevSelection);
    editor == null ? void 0 : editor.setSelections(prevSelection);
  }
};
TrimFinalNewLinesParticipant = __decorate([
  __param(0, IConfigurationService),
  __param(1, ICodeEditorService)
], TrimFinalNewLinesParticipant);
var FormatOnSaveParticipant = class FormatOnSaveParticipant2 {
  constructor(configurationService, codeEditorService, instantiationService) {
    this.configurationService = configurationService;
    this.codeEditorService = codeEditorService;
    this.instantiationService = instantiationService;
  }
  async participate(model, env, progress, token) {
    if (!model.textEditorModel) {
      return;
    }
    if (env.reason === 2) {
      return void 0;
    }
    const textEditorModel = model.textEditorModel;
    const overrides = { overrideIdentifier: textEditorModel.getLanguageId(), resource: textEditorModel.uri };
    const nestedProgress = new Progress((provider) => {
      progress.report({
        message: localize(
          { key: "formatting2", comment: ["[configure]({1}) is a link. Only translate `configure`. Do not change brackets and parentheses or {1}"] },
          "Running '{0}' Formatter ([configure]({1})).",
          provider.displayName || provider.extensionId && provider.extensionId.value || "???",
          "command:workbench.action.openSettings?%5B%22editor.formatOnSave%22%5D"
        )
      });
    });
    const enabled = this.configurationService.getValue("editor.formatOnSave", overrides);
    if (!enabled) {
      return void 0;
    }
    const editorOrModel = findEditor(textEditorModel, this.codeEditorService) || textEditorModel;
    const mode = this.configurationService.getValue("editor.formatOnSaveMode", overrides);
    if (mode === "file") {
      await this.instantiationService.invokeFunction(formatDocumentWithSelectedProvider, editorOrModel, 2, nestedProgress, token);
    } else {
      const ranges = await this.instantiationService.invokeFunction(getModifiedRanges, isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel);
      if (ranges === null && mode === "modificationsIfAvailable") {
        await this.instantiationService.invokeFunction(formatDocumentWithSelectedProvider, editorOrModel, 2, nestedProgress, token);
      } else if (ranges) {
        await this.instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, editorOrModel, ranges, 2, nestedProgress, token);
      }
    }
  }
};
FormatOnSaveParticipant = __decorate([
  __param(0, IConfigurationService),
  __param(1, ICodeEditorService),
  __param(2, IInstantiationService)
], FormatOnSaveParticipant);
var CodeActionOnSaveParticipant = class CodeActionOnSaveParticipant2 {
  constructor(configurationService, instantiationService, languageFeaturesService) {
    this.configurationService = configurationService;
    this.instantiationService = instantiationService;
    this.languageFeaturesService = languageFeaturesService;
  }
  async participate(model, env, progress, token) {
    if (!model.textEditorModel) {
      return;
    }
    if (env.reason !== 1) {
      return void 0;
    }
    const textEditorModel = model.textEditorModel;
    const settingsOverrides = { overrideIdentifier: textEditorModel.getLanguageId(), resource: model.resource };
    const setting = this.configurationService.getValue("editor.codeActionsOnSave", settingsOverrides);
    if (!setting) {
      return void 0;
    }
    const settingItems = Array.isArray(setting) ? setting : Object.keys(setting).filter((x) => setting[x]);
    const codeActionsOnSave = this.createCodeActionsOnSave(settingItems);
    if (!Array.isArray(setting)) {
      codeActionsOnSave.sort((a, b) => {
        if (CodeActionKind.SourceFixAll.contains(a)) {
          if (CodeActionKind.SourceFixAll.contains(b)) {
            return 0;
          }
          return -1;
        }
        if (CodeActionKind.SourceFixAll.contains(b)) {
          return 1;
        }
        return 0;
      });
    }
    if (!codeActionsOnSave.length) {
      return void 0;
    }
    const excludedActions = Array.isArray(setting) ? [] : Object.keys(setting).filter((x) => setting[x] === false).map((x) => new CodeActionKind(x));
    progress.report({ message: localize("codeaction", "Quick Fixes") });
    await this.applyOnSaveActions(textEditorModel, codeActionsOnSave, excludedActions, progress, token);
  }
  createCodeActionsOnSave(settingItems) {
    const kinds = settingItems.map((x) => new CodeActionKind(x));
    return kinds.filter((kind) => {
      return kinds.every((otherKind) => otherKind.equals(kind) || !otherKind.contains(kind));
    });
  }
  async applyOnSaveActions(model, codeActionsOnSave, excludes, progress, token) {
    const getActionProgress = new class {
      constructor() {
        this._names = /* @__PURE__ */ new Set();
      }
      _report() {
        progress.report({
          message: localize(
            { key: "codeaction.get2", comment: ["[configure]({1}) is a link. Only translate `configure`. Do not change brackets and parentheses or {1}"] },
            "Getting code actions from '{0}' ([configure]({1})).",
            [...this._names].map((name) => `'${name}'`).join(", "),
            "command:workbench.action.openSettings?%5B%22editor.codeActionsOnSave%22%5D"
          )
        });
      }
      report(provider) {
        if (provider.displayName && !this._names.has(provider.displayName)) {
          this._names.add(provider.displayName);
          this._report();
        }
      }
    }();
    for (const codeActionKind of codeActionsOnSave) {
      const actionsToRun = await this.getActionsToRun(model, codeActionKind, excludes, getActionProgress, token);
      if (token.isCancellationRequested) {
        actionsToRun.dispose();
        return;
      }
      try {
        for (const action of actionsToRun.validActions) {
          progress.report({ message: localize("codeAction.apply", "Applying code action '{0}'.", action.action.title) });
          await this.instantiationService.invokeFunction(applyCodeAction, action, ApplyCodeActionReason.OnSave, {}, token);
          if (token.isCancellationRequested) {
            return;
          }
        }
      } catch {
      } finally {
        actionsToRun.dispose();
      }
    }
  }
  getActionsToRun(model, codeActionKind, excludes, progress, token) {
    return getCodeActions(this.languageFeaturesService.codeActionProvider, model, model.getFullModelRange(), {
      type: 2,
      triggerAction: CodeActionTriggerSource.OnSave,
      filter: { include: codeActionKind, excludes, includeSourceActions: true }
    }, progress, token);
  }
};
CodeActionOnSaveParticipant = __decorate([
  __param(0, IConfigurationService),
  __param(1, IInstantiationService),
  __param(2, ILanguageFeaturesService)
], CodeActionOnSaveParticipant);
var SaveParticipantsContribution = class SaveParticipantsContribution2 extends Disposable {
  constructor(instantiationService, textFileService) {
    super();
    this.instantiationService = instantiationService;
    this.textFileService = textFileService;
    this.registerSaveParticipants();
  }
  registerSaveParticipants() {
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(TrimWhitespaceParticipant)));
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(CodeActionOnSaveParticipant)));
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(FormatOnSaveParticipant)));
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(FinalNewLineParticipant)));
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(TrimFinalNewLinesParticipant)));
  }
};
SaveParticipantsContribution = __decorate([
  __param(0, IInstantiationService),
  __param(1, ITextFileService)
], SaveParticipantsContribution);
var workbenchContributionsRegistry = Registry.as(Extensions2.Workbench);
workbenchContributionsRegistry.registerWorkbenchContribution(SaveParticipantsContribution, 3);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/toggleMinimap.js
init_nls();
init_actions2();
init_configuration();
init_contextkey();
var _ToggleMinimapAction = class _ToggleMinimapAction extends Action2 {
  constructor() {
    super({
      id: _ToggleMinimapAction.ID,
      title: {
        value: localize("toggleMinimap", "Toggle Minimap"),
        original: "Toggle Minimap",
        mnemonicTitle: localize({ key: "miMinimap", comment: ["&& denotes a mnemonic"] }, "&&Minimap")
      },
      category: Categories.View,
      f1: true,
      toggled: ContextKeyExpr.equals("config.editor.minimap.enabled", true),
      menu: {
        id: MenuId.MenubarAppearanceMenu,
        group: "4_editor",
        order: 1
      }
    });
  }
  async run(accessor) {
    const configurationService = accessor.get(IConfigurationService);
    const newValue = !configurationService.getValue("editor.minimap.enabled");
    return configurationService.updateValue("editor.minimap.enabled", newValue);
  }
};
_ToggleMinimapAction.ID = "editor.action.toggleMinimap";
var ToggleMinimapAction = _ToggleMinimapAction;
registerAction2(ToggleMinimapAction);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/toggleMultiCursorModifier.js
init_tslib_es6();
init_nls();
init_platform();
init_actions2();
init_configuration();
init_contextkey();
init_platform2();
var _ToggleMultiCursorModifierAction = class _ToggleMultiCursorModifierAction extends Action2 {
  constructor() {
    super({
      id: _ToggleMultiCursorModifierAction.ID,
      title: { value: localize("toggleLocation", "Toggle Multi-Cursor Modifier"), original: "Toggle Multi-Cursor Modifier" },
      f1: true
    });
  }
  run(accessor) {
    const configurationService = accessor.get(IConfigurationService);
    const editorConf = configurationService.getValue("editor");
    const newValue = editorConf.multiCursorModifier === "ctrlCmd" ? "alt" : "ctrlCmd";
    return configurationService.updateValue(_ToggleMultiCursorModifierAction.multiCursorModifierConfigurationKey, newValue);
  }
};
_ToggleMultiCursorModifierAction.ID = "workbench.action.toggleMultiCursorModifier";
_ToggleMultiCursorModifierAction.multiCursorModifierConfigurationKey = "editor.multiCursorModifier";
var ToggleMultiCursorModifierAction = _ToggleMultiCursorModifierAction;
var multiCursorModifier = new RawContextKey("multiCursorModifier", "altKey");
var MultiCursorModifierContextKeyController = class MultiCursorModifierContextKeyController2 {
  constructor(configurationService, contextKeyService) {
    this.configurationService = configurationService;
    this._multiCursorModifier = multiCursorModifier.bindTo(contextKeyService);
    this._update();
    configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("editor.multiCursorModifier")) {
        this._update();
      }
    });
  }
  _update() {
    const editorConf = this.configurationService.getValue("editor");
    const value = editorConf.multiCursorModifier === "ctrlCmd" ? "ctrlCmd" : "altKey";
    this._multiCursorModifier.set(value);
  }
};
MultiCursorModifierContextKeyController = __decorate([
  __param(0, IConfigurationService),
  __param(1, IContextKeyService)
], MultiCursorModifierContextKeyController);
Registry.as(Extensions2.Workbench).registerWorkbenchContribution(MultiCursorModifierContextKeyController, 3);
registerAction2(ToggleMultiCursorModifierAction);
MenuRegistry.appendMenuItem(MenuId.MenubarSelectionMenu, {
  group: "4_config",
  command: {
    id: ToggleMultiCursorModifierAction.ID,
    title: localize("miMultiCursorAlt", "Switch to Alt+Click for Multi-Cursor")
  },
  when: multiCursorModifier.isEqualTo("ctrlCmd"),
  order: 1
});
MenuRegistry.appendMenuItem(MenuId.MenubarSelectionMenu, {
  group: "4_config",
  command: {
    id: ToggleMultiCursorModifierAction.ID,
    title: isMacintosh ? localize("miMultiCursorCmd", "Switch to Cmd+Click for Multi-Cursor") : localize("miMultiCursorCtrl", "Switch to Ctrl+Click for Multi-Cursor")
  },
  when: multiCursorModifier.isEqualTo("altKey"),
  order: 1
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/toggleRenderControlCharacter.js
init_nls();
init_actions2();
init_configuration();
init_contextkey();
var _ToggleRenderControlCharacterAction = class _ToggleRenderControlCharacterAction extends Action2 {
  constructor() {
    super({
      id: _ToggleRenderControlCharacterAction.ID,
      title: {
        value: localize("toggleRenderControlCharacters", "Toggle Control Characters"),
        mnemonicTitle: localize(
          { key: "miToggleRenderControlCharacters", comment: ["&& denotes a mnemonic"] },
          "Render &&Control Characters"
        ),
        original: "Toggle Control Characters"
      },
      category: Categories.View,
      f1: true,
      toggled: ContextKeyExpr.equals("config.editor.renderControlCharacters", true),
      menu: {
        id: MenuId.MenubarAppearanceMenu,
        group: "4_editor",
        order: 5
      }
    });
  }
  run(accessor) {
    const configurationService = accessor.get(IConfigurationService);
    const newRenderControlCharacters = !configurationService.getValue("editor.renderControlCharacters");
    return configurationService.updateValue("editor.renderControlCharacters", newRenderControlCharacters);
  }
};
_ToggleRenderControlCharacterAction.ID = "editor.action.toggleRenderControlCharacter";
var ToggleRenderControlCharacterAction = _ToggleRenderControlCharacterAction;
registerAction2(ToggleRenderControlCharacterAction);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/toggleWordWrap.js
init_tslib_es6();
init_nls();
init_lifecycle();
init_editorExtensions();
init_codeEditorService();
init_actions2();
init_contextkey();
init_editorContextKeys();
init_codicons();
init_platform2();
var transientWordWrapState = "transientWordWrapState";
var isWordWrapMinifiedKey = "isWordWrapMinified";
var isDominatedByLongLinesKey = "isDominatedByLongLines";
var CAN_TOGGLE_WORD_WRAP = new RawContextKey("canToggleWordWrap", false, true);
var EDITOR_WORD_WRAP = new RawContextKey("editorWordWrap", false, localize("editorWordWrap", "Whether the editor is currently using word wrapping."));
function writeTransientState(model, state, codeEditorService) {
  codeEditorService.setTransientModelProperty(model, transientWordWrapState, state);
}
function readTransientState(model, codeEditorService) {
  return codeEditorService.getTransientModelProperty(model, transientWordWrapState);
}
var TOGGLE_WORD_WRAP_ID = "editor.action.toggleWordWrap";
var ToggleWordWrapAction = class extends EditorAction {
  constructor() {
    super({
      id: TOGGLE_WORD_WRAP_ID,
      label: localize("toggle.wordwrap", "View: Toggle Word Wrap"),
      alias: "View: Toggle Word Wrap",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 512 | 56,
        weight: 100
      }
    });
  }
  run(accessor, editor) {
    const codeEditorService = accessor.get(ICodeEditorService);
    if (!canToggleWordWrap(codeEditorService, editor)) {
      return;
    }
    const model = editor.getModel();
    const transientState = readTransientState(model, codeEditorService);
    let newState;
    if (transientState) {
      newState = null;
    } else {
      const actualWrappingInfo = editor.getOption(143);
      const wordWrapOverride = actualWrappingInfo.wrappingColumn === -1 ? "on" : "off";
      newState = { wordWrapOverride };
    }
    writeTransientState(model, newState, codeEditorService);
    const diffEditor = findDiffEditorContainingCodeEditor(editor, codeEditorService);
    if (diffEditor) {
      const originalEditor = diffEditor.getOriginalEditor();
      const modifiedEditor = diffEditor.getModifiedEditor();
      const otherEditor = originalEditor === editor ? modifiedEditor : originalEditor;
      if (canToggleWordWrap(codeEditorService, otherEditor)) {
        writeTransientState(otherEditor.getModel(), newState, codeEditorService);
        diffEditor.updateOptions({});
      }
    }
  }
};
function findDiffEditorContainingCodeEditor(editor, codeEditorService) {
  if (!editor.getOption(60)) {
    return null;
  }
  for (const diffEditor of codeEditorService.listDiffEditors()) {
    const originalEditor = diffEditor.getOriginalEditor();
    const modifiedEditor = diffEditor.getModifiedEditor();
    if (originalEditor === editor || modifiedEditor === editor) {
      return diffEditor;
    }
  }
  return null;
}
var _a7;
var ToggleWordWrapController = (_a7 = class extends Disposable {
  constructor(_editor, _contextKeyService, _codeEditorService) {
    super();
    this._editor = _editor;
    this._contextKeyService = _contextKeyService;
    this._codeEditorService = _codeEditorService;
    const options = this._editor.getOptions();
    const wrappingInfo = options.get(143);
    const isWordWrapMinified = this._contextKeyService.createKey(isWordWrapMinifiedKey, wrappingInfo.isWordWrapMinified);
    const isDominatedByLongLines = this._contextKeyService.createKey(isDominatedByLongLinesKey, wrappingInfo.isDominatedByLongLines);
    let currentlyApplyingEditorConfig = false;
    this._register(_editor.onDidChangeConfiguration((e) => {
      if (!e.hasChanged(143)) {
        return;
      }
      const options2 = this._editor.getOptions();
      const wrappingInfo2 = options2.get(143);
      isWordWrapMinified.set(wrappingInfo2.isWordWrapMinified);
      isDominatedByLongLines.set(wrappingInfo2.isDominatedByLongLines);
      if (!currentlyApplyingEditorConfig) {
        ensureWordWrapSettings();
      }
    }));
    this._register(_editor.onDidChangeModel((e) => {
      ensureWordWrapSettings();
    }));
    this._register(_codeEditorService.onDidChangeTransientModelProperty(() => {
      ensureWordWrapSettings();
    }));
    const ensureWordWrapSettings = () => {
      if (!canToggleWordWrap(this._codeEditorService, this._editor)) {
        return;
      }
      const transientState = readTransientState(this._editor.getModel(), this._codeEditorService);
      try {
        currentlyApplyingEditorConfig = true;
        this._applyWordWrapState(transientState);
      } finally {
        currentlyApplyingEditorConfig = false;
      }
    };
  }
  _applyWordWrapState(state) {
    const wordWrapOverride2 = state ? state.wordWrapOverride : "inherit";
    this._editor.updateOptions({
      wordWrapOverride2
    });
  }
}, _a7.ID = "editor.contrib.toggleWordWrapController", _a7);
ToggleWordWrapController = __decorate([
  __param(1, IContextKeyService),
  __param(2, ICodeEditorService)
], ToggleWordWrapController);
var _a8;
var DiffToggleWordWrapController = (_a8 = class extends Disposable {
  constructor(_diffEditor, _codeEditorService) {
    super();
    this._diffEditor = _diffEditor;
    this._codeEditorService = _codeEditorService;
    this._register(this._diffEditor.onDidChangeModel(() => {
      this._ensureSyncedWordWrapToggle();
    }));
  }
  _ensureSyncedWordWrapToggle() {
    const originalEditor = this._diffEditor.getOriginalEditor();
    const modifiedEditor = this._diffEditor.getModifiedEditor();
    if (!originalEditor.hasModel() || !modifiedEditor.hasModel()) {
      return;
    }
    const originalTransientState = readTransientState(originalEditor.getModel(), this._codeEditorService);
    const modifiedTransientState = readTransientState(modifiedEditor.getModel(), this._codeEditorService);
    if (originalTransientState && !modifiedTransientState && canToggleWordWrap(this._codeEditorService, originalEditor)) {
      writeTransientState(modifiedEditor.getModel(), originalTransientState, this._codeEditorService);
      this._diffEditor.updateOptions({});
    }
    if (!originalTransientState && modifiedTransientState && canToggleWordWrap(this._codeEditorService, modifiedEditor)) {
      writeTransientState(originalEditor.getModel(), modifiedTransientState, this._codeEditorService);
      this._diffEditor.updateOptions({});
    }
  }
}, _a8.ID = "diffeditor.contrib.toggleWordWrapController", _a8);
DiffToggleWordWrapController = __decorate([
  __param(1, ICodeEditorService)
], DiffToggleWordWrapController);
function canToggleWordWrap(codeEditorService, editor) {
  if (!editor) {
    return false;
  }
  if (editor.isSimpleWidget) {
    return false;
  }
  const model = editor.getModel();
  if (!model) {
    return false;
  }
  if (model.uri.scheme === "output") {
    return false;
  }
  if (editor.getOption(60)) {
    for (const diffEditor of codeEditorService.listDiffEditors()) {
      if (diffEditor.getOriginalEditor() === editor && !diffEditor.renderSideBySide) {
        return false;
      }
    }
  }
  return true;
}
var EditorWordWrapContextKeyTracker = class EditorWordWrapContextKeyTracker2 {
  constructor(_editorService, _codeEditorService, _contextService) {
    this._editorService = _editorService;
    this._codeEditorService = _codeEditorService;
    this._contextService = _contextService;
    window.addEventListener("focus", () => this._update(), true);
    window.addEventListener("blur", () => this._update(), true);
    this._editorService.onDidActiveEditorChange(() => this._update());
    this._canToggleWordWrap = CAN_TOGGLE_WORD_WRAP.bindTo(this._contextService);
    this._editorWordWrap = EDITOR_WORD_WRAP.bindTo(this._contextService);
    this._activeEditor = null;
    this._activeEditorListener = new DisposableStore();
    this._update();
  }
  _update() {
    const activeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
    if (this._activeEditor === activeEditor) {
      return;
    }
    this._activeEditorListener.clear();
    this._activeEditor = activeEditor;
    if (activeEditor) {
      this._activeEditorListener.add(activeEditor.onDidChangeModel(() => this._updateFromCodeEditor()));
      this._activeEditorListener.add(activeEditor.onDidChangeConfiguration((e) => {
        if (e.hasChanged(143)) {
          this._updateFromCodeEditor();
        }
      }));
      this._updateFromCodeEditor();
    }
  }
  _updateFromCodeEditor() {
    if (!canToggleWordWrap(this._codeEditorService, this._activeEditor)) {
      return this._setValues(false, false);
    } else {
      const wrappingInfo = this._activeEditor.getOption(143);
      this._setValues(true, wrappingInfo.wrappingColumn !== -1);
    }
  }
  _setValues(canToggleWordWrap2, isWordWrap) {
    this._canToggleWordWrap.set(canToggleWordWrap2);
    this._editorWordWrap.set(isWordWrap);
  }
};
EditorWordWrapContextKeyTracker = __decorate([
  __param(0, IEditorService),
  __param(1, ICodeEditorService),
  __param(2, IContextKeyService)
], EditorWordWrapContextKeyTracker);
var workbenchRegistry = Registry.as(Extensions2.Workbench);
workbenchRegistry.registerWorkbenchContribution(EditorWordWrapContextKeyTracker, 2);
registerEditorContribution(ToggleWordWrapController.ID, ToggleWordWrapController, 0);
registerDiffEditorContribution(DiffToggleWordWrapController.ID, DiffToggleWordWrapController);
registerEditorAction(ToggleWordWrapAction);
MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
  command: {
    id: TOGGLE_WORD_WRAP_ID,
    title: localize("unwrapMinified", "Disable wrapping for this file"),
    icon: Codicon.wordWrap
  },
  group: "navigation",
  order: 1,
  when: ContextKeyExpr.and(ContextKeyExpr.has(isDominatedByLongLinesKey), ContextKeyExpr.has(isWordWrapMinifiedKey))
});
MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
  command: {
    id: TOGGLE_WORD_WRAP_ID,
    title: localize("wrapMinified", "Enable wrapping for this file"),
    icon: Codicon.wordWrap
  },
  group: "navigation",
  order: 1,
  when: ContextKeyExpr.and(EditorContextKeys.inDiffEditor.negate(), ContextKeyExpr.has(isDominatedByLongLinesKey), ContextKeyExpr.not(isWordWrapMinifiedKey))
});
MenuRegistry.appendMenuItem(MenuId.MenubarViewMenu, {
  command: {
    id: TOGGLE_WORD_WRAP_ID,
    title: localize(
      { key: "miToggleWordWrap", comment: ["&& denotes a mnemonic"] },
      "&&Word Wrap"
    ),
    toggled: EDITOR_WORD_WRAP,
    precondition: CAN_TOGGLE_WORD_WRAP
  },
  order: 1,
  group: "5_editor"
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/toggleRenderWhitespace.js
init_nls();
init_actions2();
init_configuration();
init_contextkey();
var _ToggleRenderWhitespaceAction = class _ToggleRenderWhitespaceAction extends Action2 {
  constructor() {
    super({
      id: _ToggleRenderWhitespaceAction.ID,
      title: {
        value: localize("toggleRenderWhitespace", "Toggle Render Whitespace"),
        mnemonicTitle: localize(
          { key: "miToggleRenderWhitespace", comment: ["&& denotes a mnemonic"] },
          "&&Render Whitespace"
        ),
        original: "Toggle Render Whitespace"
      },
      category: Categories.View,
      f1: true,
      toggled: ContextKeyExpr.notEquals("config.editor.renderWhitespace", "none"),
      menu: {
        id: MenuId.MenubarAppearanceMenu,
        group: "4_editor",
        order: 4
      }
    });
  }
  run(accessor) {
    const configurationService = accessor.get(IConfigurationService);
    const renderWhitespace = configurationService.getValue("editor.renderWhitespace");
    let newRenderWhitespace;
    if (renderWhitespace === "none") {
      newRenderWhitespace = "all";
    } else {
      newRenderWhitespace = "none";
    }
    return configurationService.updateValue("editor.renderWhitespace", newRenderWhitespace);
  }
};
_ToggleRenderWhitespaceAction.ID = "editor.action.toggleRenderWhitespace";
var ToggleRenderWhitespaceAction = _ToggleRenderWhitespaceAction;
registerAction2(ToggleRenderWhitespaceAction);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/editorLineNumberMenu.js
init_tslib_es6();
init_actions();
init_lifecycle();
init_platform();
init_editorExtensions();
init_actions2();
init_contextkey();
init_instantiation();
init_platform2();
var GutterActionsRegistryImpl = class {
  constructor() {
    this._registeredGutterActionsGenerators = /* @__PURE__ */ new Set();
  }
  registerGutterActionsGenerator(gutterActionsGenerator) {
    this._registeredGutterActionsGenerators.add(gutterActionsGenerator);
    return {
      dispose: () => {
        this._registeredGutterActionsGenerators.delete(gutterActionsGenerator);
      }
    };
  }
  getGutterActionsGenerators() {
    return Array.from(this._registeredGutterActionsGenerators.values());
  }
};
Registry.add("gutterActionsRegistry", new GutterActionsRegistryImpl());
var GutterActionsRegistry = Registry.as("gutterActionsRegistry");
var _a9;
var EditorLineNumberContextMenu = (_a9 = class extends Disposable {
  constructor(editor, contextMenuService, menuService, contextKeyService, instantiationService) {
    super();
    this.editor = editor;
    this.contextMenuService = contextMenuService;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this.instantiationService = instantiationService;
    this._register(this.editor.onMouseDown((e) => this.doShow(e, false)));
  }
  show(e) {
    this.doShow(e, true);
  }
  doShow(e, force) {
    const model = this.editor.getModel();
    if (!e.event.rightButton && !(isMacintosh && e.event.leftButton && e.event.ctrlKey) && !force || e.target.type !== 3 && e.target.type !== 2 || !e.target.position || !model) {
      return;
    }
    const lineNumber = e.target.position.lineNumber;
    const contextKeyService = this.contextKeyService.createOverlay([["editorLineNumber", lineNumber]]);
    const menu = this.menuService.createMenu(MenuId.EditorLineNumberContext, contextKeyService);
    const allActions = [];
    this.instantiationService.invokeFunction((accessor) => {
      for (const generator of GutterActionsRegistry.getGutterActionsGenerators()) {
        const collectedActions = /* @__PURE__ */ new Map();
        generator({ lineNumber, editor: this.editor, accessor }, {
          push: (action, group = "navigation") => {
            const actions = collectedActions.get(group) ?? [];
            actions.push(action);
            collectedActions.set(group, actions);
          }
        });
        for (const [group, actions] of collectedActions.entries()) {
          allActions.push([group, actions]);
        }
      }
      allActions.sort((a, b) => a[0].localeCompare(b[0]));
      const menuActions = menu.getActions({ arg: { lineNumber, uri: model.uri }, shouldForwardArgs: true });
      allActions.push(...menuActions);
      if (e.target.type === 3) {
        const currentSelections = this.editor.getSelections();
        const lineRange = {
          startLineNumber: lineNumber,
          endLineNumber: lineNumber,
          startColumn: 1,
          endColumn: model.getLineLength(lineNumber) + 1
        };
        const containsSelection = currentSelections == null ? void 0 : currentSelections.some((selection) => !selection.isEmpty() && selection.intersectRanges(lineRange) !== null);
        if (!containsSelection) {
          this.editor.setSelection(lineRange, "api");
        }
      }
      this.contextMenuService.showContextMenu({
        getAnchor: () => e.event,
        getActions: () => Separator.join(...allActions.map((a) => a[1])),
        onHide: () => menu.dispose()
      });
    });
  }
}, _a9.ID = "workbench.contrib.editorLineNumberContextMenu", _a9);
EditorLineNumberContextMenu = __decorate([
  __param(1, IContextMenuService),
  __param(2, IMenuService),
  __param(3, IContextKeyService),
  __param(4, IInstantiationService)
], EditorLineNumberContextMenu);
registerEditorContribution(EditorLineNumberContextMenu.ID, EditorLineNumberContextMenu, 1);

// node_modules/vscode/vscode/src/vs/workbench/contrib/folding/browser/folding.contribution.js
init_tslib_es6();
init_lifecycle();
init_nls();
init_platform2();
init_configurationRegistry();
init_configuration();
var DefaultFoldingRangeProvider_1;
var _a10;
var DefaultFoldingRangeProvider = (_a10 = class extends Disposable {
  constructor(_extensionService, _configurationService) {
    super();
    this._extensionService = _extensionService;
    this._configurationService = _configurationService;
    this._store.add(this._extensionService.onDidChangeExtensions(this._updateConfigValues, this));
    this._store.add(FoldingController.setFoldingRangeProviderSelector(this._selectFoldingRangeProvider.bind(this)));
    this._updateConfigValues();
  }
  async _updateConfigValues() {
    var _a12;
    await this._extensionService.whenInstalledExtensionsRegistered();
    DefaultFoldingRangeProvider_1.extensionIds.length = 0;
    DefaultFoldingRangeProvider_1.extensionItemLabels.length = 0;
    DefaultFoldingRangeProvider_1.extensionDescriptions.length = 0;
    DefaultFoldingRangeProvider_1.extensionIds.push(null);
    DefaultFoldingRangeProvider_1.extensionItemLabels.push(localize("null", "All"));
    DefaultFoldingRangeProvider_1.extensionDescriptions.push(localize("nullFormatterDescription", "All active folding range providers"));
    const languageExtensions = [];
    const otherExtensions = [];
    for (const extension of this._extensionService.extensions) {
      if (extension.main || extension.browser) {
        if ((_a12 = extension.categories) == null ? void 0 : _a12.find((cat) => cat === "Programming Languages")) {
          languageExtensions.push(extension);
        } else {
          otherExtensions.push(extension);
        }
      }
    }
    const sorter = (a, b) => a.name.localeCompare(b.name);
    for (const extension of languageExtensions.sort(sorter)) {
      DefaultFoldingRangeProvider_1.extensionIds.push(extension.identifier.value);
      DefaultFoldingRangeProvider_1.extensionItemLabels.push(extension.displayName ?? "");
      DefaultFoldingRangeProvider_1.extensionDescriptions.push(extension.description ?? "");
    }
    for (const extension of otherExtensions.sort(sorter)) {
      DefaultFoldingRangeProvider_1.extensionIds.push(extension.identifier.value);
      DefaultFoldingRangeProvider_1.extensionItemLabels.push(extension.displayName ?? "");
      DefaultFoldingRangeProvider_1.extensionDescriptions.push(extension.description ?? "");
    }
  }
  _selectFoldingRangeProvider(providers, document2) {
    const value = this._configurationService.getValue(DefaultFoldingRangeProvider_1.configName, { overrideIdentifier: document2.getLanguageId() });
    if (value) {
      return providers.filter((p) => p.id === value);
    }
    return void 0;
  }
}, DefaultFoldingRangeProvider_1 = _a10, _a10.configName = "editor.defaultFoldingRangeProvider", _a10.extensionIds = [], _a10.extensionItemLabels = [], _a10.extensionDescriptions = [], _a10);
DefaultFoldingRangeProvider = DefaultFoldingRangeProvider_1 = __decorate([
  __param(0, IExtensionService),
  __param(1, IConfigurationService)
], DefaultFoldingRangeProvider);
Registry.as(Extensions3.Configuration).registerConfiguration({
  ...editorConfigurationBaseNode,
  properties: {
    [DefaultFoldingRangeProvider.configName]: {
      description: localize(
        "formatter.default",
        "Defines a default folding range provider that takes precedence over all other folding range providers. Must be the identifier of an extension contributing a folding range provider."
      ),
      type: ["string", "null"],
      default: null,
      enum: DefaultFoldingRangeProvider.extensionIds,
      enumItemLabels: DefaultFoldingRangeProvider.extensionItemLabels,
      markdownEnumDescriptions: DefaultFoldingRangeProvider.extensionDescriptions
    }
  }
});
Registry.as(Extensions2.Workbench).registerWorkbenchContribution(DefaultFoldingRangeProvider, 3);

// node_modules/vscode/vscode/src/vs/workbench/contrib/inlayHints/browser/inlayHintsAccessibilty.js
init_tslib_es6();
init_dom();
init_cancellation();
init_lifecycle();
init_editorExtensions();
init_editorContextKeys();
init_nls();
init_actions2();
init_contextkey();
init_instantiation();
var InlayHintsAccessibility_1;
var _a11;
var InlayHintsAccessibility = (_a11 = class {
  static get(editor) {
    return editor.getContribution(InlayHintsAccessibility_1.ID) ?? void 0;
  }
  constructor(_editor, contextKeyService, _audioCueService, _instaService) {
    this._editor = _editor;
    this._audioCueService = _audioCueService;
    this._instaService = _instaService;
    this._sessionDispoosables = new DisposableStore();
    this._ariaElement = document.createElement("span");
    this._ariaElement.style.position = "fixed";
    this._ariaElement.className = "inlayhint-accessibility-element";
    this._ariaElement.tabIndex = 0;
    this._ariaElement.setAttribute("aria-description", localize("description", "Code with Inlay Hint Information"));
    this._ctxIsReading = InlayHintsAccessibility_1.IsReading.bindTo(contextKeyService);
  }
  dispose() {
    this._sessionDispoosables.dispose();
    this._ctxIsReading.reset();
    this._ariaElement.remove();
  }
  _reset() {
    clearNode(this._ariaElement);
    this._sessionDispoosables.clear();
    this._ctxIsReading.reset();
  }
  async _read(line, hints) {
    var _a12;
    this._sessionDispoosables.clear();
    if (!this._ariaElement.isConnected) {
      (_a12 = this._editor.getDomNode()) == null ? void 0 : _a12.appendChild(this._ariaElement);
    }
    if (!this._editor.hasModel() || !this._ariaElement.isConnected) {
      this._ctxIsReading.set(false);
      return;
    }
    const cts = new CancellationTokenSource();
    this._sessionDispoosables.add(cts);
    for (const hint of hints) {
      await hint.resolve(cts.token);
    }
    if (cts.token.isCancellationRequested) {
      return;
    }
    const model = this._editor.getModel();
    const newChildren = [];
    let start = 0;
    let tooLongToRead = false;
    for (const item of hints) {
      const part = model.getValueInRange({ startLineNumber: line, startColumn: start + 1, endLineNumber: line, endColumn: item.hint.position.column });
      if (part.length > 0) {
        newChildren.push(part);
        start = item.hint.position.column - 1;
      }
      if (start > 750) {
        newChildren.push("…");
        tooLongToRead = true;
        break;
      }
      const em = document.createElement("em");
      const { label } = item.hint;
      if (typeof label === "string") {
        em.innerText = label;
      } else {
        for (const part2 of label) {
          if (part2.command) {
            const link = this._instaService.createInstance(Link, em, { href: asCommandLink(part2.command), label: part2.label, title: part2.command.title }, void 0);
            this._sessionDispoosables.add(link);
          } else {
            em.innerText += part2.label;
          }
        }
      }
      newChildren.push(em);
    }
    if (!tooLongToRead) {
      newChildren.push(model.getValueInRange({ startLineNumber: line, startColumn: start + 1, endLineNumber: line, endColumn: Number.MAX_SAFE_INTEGER }));
    }
    reset(this._ariaElement, ...newChildren);
    this._ariaElement.focus();
    this._ctxIsReading.set(true);
    this._sessionDispoosables.add(addDisposableListener(this._ariaElement, "focusout", () => {
      this._reset();
    }));
  }
  startInlayHintsReading() {
    var _a12;
    if (!this._editor.hasModel()) {
      return;
    }
    const line = this._editor.getPosition().lineNumber;
    const hints = (_a12 = InlayHintsController.get(this._editor)) == null ? void 0 : _a12.getInlayHintsForLine(line);
    if (!hints || hints.length === 0) {
      this._audioCueService.playAudioCue(AudioCue.noInlayHints);
    } else {
      this._read(line, hints);
    }
  }
  stopInlayHintsReading() {
    this._reset();
    this._editor.focus();
  }
}, InlayHintsAccessibility_1 = _a11, _a11.IsReading = new RawContextKey(
  "isReadingLineWithInlayHints",
  false,
  { type: "boolean", description: localize(
    "isReadingLineWithInlayHints",
    "Whether the current line and its inlay hints are currently focused"
  ) }
), _a11.ID = "editor.contrib.InlayHintsAccessibility", _a11);
InlayHintsAccessibility = InlayHintsAccessibility_1 = __decorate([
  __param(1, IContextKeyService),
  __param(2, IAudioCueService),
  __param(3, IInstantiationService)
], InlayHintsAccessibility);
registerAction2(class StartReadHints extends EditorAction2 {
  constructor() {
    super({
      id: "inlayHints.startReadingLineWithHint",
      title: {
        value: localize("read.title", "Read Line With Inline Hints"),
        original: "Read Line With Inline Hints"
      },
      precondition: EditorContextKeys.hasInlayHintsProvider,
      f1: true
    });
  }
  runEditorCommand(_accessor, editor) {
    const ctrl = InlayHintsAccessibility.get(editor);
    ctrl == null ? void 0 : ctrl.startInlayHintsReading();
  }
});
registerAction2(class StopReadHints extends EditorAction2 {
  constructor() {
    super({
      id: "inlayHints.stopReadingLineWithHint",
      title: {
        value: localize("stop.title", "Stop Inlay Hints Reading"),
        original: "Stop Inlay Hints Reading"
      },
      precondition: InlayHintsAccessibility.IsReading,
      f1: true,
      keybinding: {
        weight: 100,
        primary: 9
      }
    });
  }
  runEditorCommand(_accessor, editor) {
    const ctrl = InlayHintsAccessibility.get(editor);
    ctrl == null ? void 0 : ctrl.stopInlayHintsReading();
  }
});
registerEditorContribution(InlayHintsAccessibility.ID, InlayHintsAccessibility, 4);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeActions/browser/codeActions.contribution.js
init_tslib_es6();
init_configurationRegistry();
init_instantiation();
init_platform2();

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeActions/common/codeActionsExtensionPoint.js
init_nls();
var CodeActionExtensionPointFields;
(function(CodeActionExtensionPointFields2) {
  CodeActionExtensionPointFields2["languages"] = "languages";
  CodeActionExtensionPointFields2["actions"] = "actions";
  CodeActionExtensionPointFields2["kind"] = "kind";
  CodeActionExtensionPointFields2["title"] = "title";
  CodeActionExtensionPointFields2["description"] = "description";
})(CodeActionExtensionPointFields || (CodeActionExtensionPointFields = {}));
var codeActionsExtensionPointSchema = Object.freeze({
  type: "array",
  markdownDescription: localize("contributes.codeActions", "Configure which editor to use for a resource."),
  items: {
    type: "object",
    required: [CodeActionExtensionPointFields.languages, CodeActionExtensionPointFields.actions],
    properties: {
      [CodeActionExtensionPointFields.languages]: {
        type: "array",
        description: localize(
          "contributes.codeActions.languages",
          "Language modes that the code actions are enabled for."
        ),
        items: { type: "string" }
      },
      [CodeActionExtensionPointFields.actions]: {
        type: "object",
        required: [CodeActionExtensionPointFields.kind, CodeActionExtensionPointFields.title],
        properties: {
          [CodeActionExtensionPointFields.kind]: {
            type: "string",
            markdownDescription: localize(
              "contributes.codeActions.kind",
              "`CodeActionKind` of the contributed code action."
            )
          },
          [CodeActionExtensionPointFields.title]: {
            type: "string",
            description: localize(
              "contributes.codeActions.title",
              "Label for the code action used in the UI."
            )
          },
          [CodeActionExtensionPointFields.description]: {
            type: "string",
            description: localize(
              "contributes.codeActions.description",
              "Description of what the code action does."
            )
          }
        }
      }
    }
  }
});
var codeActionsExtensionPointDescriptor = {
  extensionPoint: "codeActions",
  deps: [languagesExtPoint],
  jsonSchema: codeActionsExtensionPointSchema
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeActions/common/documentationExtensionPoint.js
init_nls();
var DocumentationExtensionPointFields;
(function(DocumentationExtensionPointFields2) {
  DocumentationExtensionPointFields2["when"] = "when";
  DocumentationExtensionPointFields2["title"] = "title";
  DocumentationExtensionPointFields2["command"] = "command";
})(
  DocumentationExtensionPointFields || (DocumentationExtensionPointFields = {})
);
var documentationExtensionPointSchema = Object.freeze({
  type: "object",
  description: localize("contributes.documentation", "Contributed documentation."),
  properties: {
    "refactoring": {
      type: "array",
      description: localize(
        "contributes.documentation.refactorings",
        "Contributed documentation for refactorings."
      ),
      items: {
        type: "object",
        description: localize(
          "contributes.documentation.refactoring",
          "Contributed documentation for refactoring."
        ),
        required: [
          DocumentationExtensionPointFields.title,
          DocumentationExtensionPointFields.when,
          DocumentationExtensionPointFields.command
        ],
        properties: {
          [DocumentationExtensionPointFields.title]: {
            type: "string",
            description: localize(
              "contributes.documentation.refactoring.title",
              "Label for the documentation used in the UI."
            )
          },
          [DocumentationExtensionPointFields.when]: {
            type: "string",
            description: localize("contributes.documentation.refactoring.when", "When clause.")
          },
          [DocumentationExtensionPointFields.command]: {
            type: "string",
            description: localize("contributes.documentation.refactoring.command", "Command executed.")
          }
        }
      }
    }
  }
});
var documentationExtensionPointDescriptor = {
  extensionPoint: "documentation",
  deps: [languagesExtPoint],
  jsonSchema: documentationExtensionPointSchema
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeActions/browser/codeActionsContribution.js
init_tslib_es6();
init_event();
init_lifecycle();
init_nls();
init_configurationRegistry();
init_platform2();
var codeActionsOnSaveDefaultProperties = Object.freeze({
  "source.fixAll": {
    type: "boolean",
    description: localize(
      "codeActionsOnSave.fixAll",
      "Controls whether auto fix action should be run on file save."
    )
  }
});
var codeActionsOnSaveSchema = {
  oneOf: [
    {
      type: "object",
      properties: codeActionsOnSaveDefaultProperties,
      additionalProperties: {
        type: "boolean"
      }
    },
    {
      type: "array",
      items: { type: "string" }
    }
  ],
  default: {},
  description: localize("codeActionsOnSave", "Code Action kinds to be run on save."),
  scope: 5
};
var editorConfiguration = Object.freeze({
  ...editorConfigurationBaseNode,
  properties: {
    "editor.codeActionsOnSave": codeActionsOnSaveSchema
  }
});
var CodeActionsContribution = class CodeActionsContribution2 extends Disposable {
  constructor(codeActionsExtensionPoint2, keybindingService) {
    super();
    this._contributedCodeActions = [];
    this._onDidChangeContributions = this._register(new Emitter());
    codeActionsExtensionPoint2.setHandler((extensionPoints) => {
      this._contributedCodeActions = extensionPoints.map((x) => x.value).flat();
      this.updateConfigurationSchema(this._contributedCodeActions);
      this._onDidChangeContributions.fire();
    });
    keybindingService.registerSchemaContribution({
      getSchemaAdditions: () => this.getSchemaAdditions(),
      onDidChange: this._onDidChangeContributions.event
    });
  }
  updateConfigurationSchema(codeActionContributions) {
    const newProperties = { ...codeActionsOnSaveDefaultProperties };
    for (const [sourceAction, props] of this.getSourceActions(codeActionContributions)) {
      newProperties[sourceAction] = {
        type: "boolean",
        description: localize(
          "codeActionsOnSave.generic",
          "Controls whether '{0}' actions should be run on file save.",
          props.title
        )
      };
    }
    codeActionsOnSaveSchema.properties = newProperties;
    Registry.as(Extensions3.Configuration).notifyConfigurationSchemaUpdated(editorConfiguration);
  }
  getSourceActions(contributions) {
    const defaultKinds = Object.keys(codeActionsOnSaveDefaultProperties).map((value) => new CodeActionKind(value));
    const sourceActions = /* @__PURE__ */ new Map();
    for (const contribution of contributions) {
      for (const action of contribution.actions) {
        const kind = new CodeActionKind(action.kind);
        if (CodeActionKind.Source.contains(kind) && !defaultKinds.some((defaultKind) => defaultKind.contains(kind))) {
          sourceActions.set(kind.value, action);
        }
      }
    }
    return sourceActions;
  }
  getSchemaAdditions() {
    const conditionalSchema = (command, actions) => {
      return {
        if: {
          required: ["command"],
          properties: {
            "command": { const: command }
          }
        },
        then: {
          properties: {
            "args": {
              required: ["kind"],
              properties: {
                "kind": {
                  anyOf: [
                    {
                      enum: actions.map((action) => action.kind),
                      enumDescriptions: actions.map((action) => action.description ?? action.title)
                    },
                    { type: "string" }
                  ]
                }
              }
            }
          }
        }
      };
    };
    const getActions = (ofKind) => {
      const allActions = this._contributedCodeActions.map((desc) => desc.actions).flat();
      const out = /* @__PURE__ */ new Map();
      for (const action of allActions) {
        if (!out.has(action.kind) && ofKind.contains(new CodeActionKind(action.kind))) {
          out.set(action.kind, action);
        }
      }
      return Array.from(out.values());
    };
    return [
      conditionalSchema(codeActionCommandId, getActions(CodeActionKind.Empty)),
      conditionalSchema(refactorCommandId, getActions(CodeActionKind.Refactor)),
      conditionalSchema(sourceActionCommandId, getActions(CodeActionKind.Source))
    ];
  }
};
CodeActionsContribution = __decorate([
  __param(1, IKeybindingService)
], CodeActionsContribution);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeActions/browser/documentationContribution.js
init_tslib_es6();
init_lifecycle();
init_languageFeatures();
init_contextkey();
var CodeActionDocumentationContribution = class CodeActionDocumentationContribution2 extends Disposable {
  constructor(extensionPoint, contextKeyService, languageFeaturesService) {
    super();
    this.contextKeyService = contextKeyService;
    this.contributions = [];
    this.emptyCodeActionsList = {
      actions: [],
      dispose: () => {
      }
    };
    this._register(languageFeaturesService.codeActionProvider.register("*", this));
    extensionPoint.setHandler((points) => {
      this.contributions = [];
      for (const documentation of points) {
        if (!documentation.value.refactoring) {
          continue;
        }
        for (const contribution of documentation.value.refactoring) {
          const precondition = ContextKeyExpr.deserialize(contribution.when);
          if (!precondition) {
            continue;
          }
          this.contributions.push({
            title: contribution.title,
            when: precondition,
            command: contribution.command
          });
        }
      }
    });
  }
  async provideCodeActions(_model, _range, context, _token) {
    return this.emptyCodeActionsList;
  }
  _getAdditionalMenuItems(context, actions) {
    if (context.only !== CodeActionKind.Refactor.value) {
      if (!actions.some((action) => action.kind && CodeActionKind.Refactor.contains(new CodeActionKind(action.kind)))) {
        return [];
      }
    }
    return this.contributions.filter((contribution) => this.contextKeyService.contextMatchesRules(contribution.when)).map((contribution) => {
      return {
        id: contribution.command,
        title: contribution.title
      };
    });
  }
};
CodeActionDocumentationContribution = __decorate([
  __param(1, IContextKeyService),
  __param(2, ILanguageFeaturesService)
], CodeActionDocumentationContribution);

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeActions/browser/codeActions.contribution.js
var codeActionsExtensionPoint = ExtensionsRegistry.registerExtensionPoint(codeActionsExtensionPointDescriptor);
var documentationExtensionPoint = ExtensionsRegistry.registerExtensionPoint(documentationExtensionPointDescriptor);
Registry.as(Extensions3.Configuration).registerConfiguration(editorConfiguration);
var WorkbenchConfigurationContribution = class WorkbenchConfigurationContribution2 {
  constructor(instantiationService) {
    instantiationService.createInstance(CodeActionsContribution, codeActionsExtensionPoint);
    instantiationService.createInstance(CodeActionDocumentationContribution, documentationExtensionPoint);
  }
};
WorkbenchConfigurationContribution = __decorate([
  __param(0, IInstantiationService)
], WorkbenchConfigurationContribution);
Registry.as(Extensions2.Workbench).registerWorkbenchContribution(WorkbenchConfigurationContribution, 4);

// node_modules/vscode/vscode/src/vs/workbench/contrib/list/browser/list.contribution.js
init_tslib_es6();
init_contextkey();
init_platform2();
var ListContext = class ListContext2 {
  constructor(contextKeyService) {
    contextKeyService.createKey("listSupportsTypeNavigation", true);
    contextKeyService.createKey("listSupportsKeyboardNavigation", true);
  }
};
ListContext = __decorate([
  __param(0, IContextKeyService)
], ListContext);
Registry.as(Extensions2.Workbench).registerWorkbenchContribution(ListContext, 1);

// node_modules/vscode/monaco.js
var ExtensionPoints = class ExtensionPoints2 {
  constructor(instantiationService) {
    this.instantiationService = instantiationService;
    this.instantiationService.createInstance(JSONValidationExtensionPoint);
    this.instantiationService.createInstance(ColorExtensionPoint);
  }
};
ExtensionPoints = __decorate([
  __param(0, IInstantiationService)
], ExtensionPoints);
Registry.as(Extensions2.Workbench).registerWorkbenchContribution(ExtensionPoints, 1);
function computeConfiguration(configuration, isDiffEditor, overrides) {
  const editorConfiguration2 = isObject(configuration.editor) ? deepClone(configuration.editor) : /* @__PURE__ */ Object.create(null);
  if (isDiffEditor && isObject(configuration.diffEditor)) {
    Object.assign(editorConfiguration2, deepClone(configuration.diffEditor));
  }
  Object.assign(editorConfiguration2, deepClone(overrides));
  return editorConfiguration2;
}
var ConfiguredStandaloneEditor = class ConfiguredStandaloneEditor2 extends createInjectedClass(StandaloneEditor) {
  constructor(domElement, isDiffEditor, _options = {}, instantiationService, textResourceConfigurationService) {
    var _a12;
    const { theme, autoDetectHighContrast, model, value, language, accessibilityHelpUrl, ariaContainerElement, overflowWidgetsDomNode, dimension, ...options } = _options;
    const computedOptions = computeConfiguration(textResourceConfigurationService.getValue((_a12 = _options.model) == null ? void 0 : _a12.uri), isDiffEditor, options);
    super(instantiationService, domElement, { ...computedOptions, overflowWidgetsDomNode, dimension, theme, autoDetectHighContrast, model, value, language, accessibilityHelpUrl, ariaContainerElement });
    this.isDiffEditor = isDiffEditor;
    this.textResourceConfigurationService = textResourceConfigurationService;
    this.optionsOverrides = {};
    this.lastAppliedEditorOptions = computedOptions;
    this.optionsOverrides = options;
    this._register(textResourceConfigurationService.onDidChangeConfiguration(() => this.updateEditorConfiguration()));
    this._register(this.onDidChangeModelLanguage(() => this.updateEditorConfiguration()));
    this._register(this.onDidChangeModel(() => this.updateEditorConfiguration()));
    this.updateEditorConfiguration();
  }
  updateEditorConfiguration() {
    if (!this.hasModel() || this.textResourceConfigurationService == null) {
      return;
    }
    const resource = this.getModel().uri;
    const configuration = this.textResourceConfigurationService.getValue(resource);
    if (configuration == null) {
      return;
    }
    const editorConfiguration2 = computeConfiguration(configuration, this.isDiffEditor, this.optionsOverrides);
    let editorSettingsToApply = editorConfiguration2;
    if (this.lastAppliedEditorOptions != null) {
      editorSettingsToApply = distinct(this.lastAppliedEditorOptions, editorSettingsToApply);
    }
    if (Object.keys(editorSettingsToApply).length > 0) {
      this.lastAppliedEditorOptions = editorConfiguration2;
      super.updateOptions(editorSettingsToApply);
    }
  }
  updateOptions(newOptions) {
    this.optionsOverrides ?? (this.optionsOverrides = {});
    const didChange = EditorOptionsUtil.applyUpdate(this.optionsOverrides, newOptions);
    if (!didChange) {
      return;
    }
    this.updateEditorConfiguration();
  }
};
ConfiguredStandaloneEditor = __decorate([
  __param(3, IInstantiationService),
  __param(4, ITextResourceConfigurationService)
], ConfiguredStandaloneEditor);
var ConfiguredStandaloneDiffEditor = class extends StandaloneDiffEditor {
  _createInnerEditor(instantiationService, container, options) {
    return instantiationService.createInstance(ConfiguredStandaloneEditor, container, true, options);
  }
};
async function writeFile(uri, content) {
  await StandaloneServices.get(IFileService).writeFile(uri, VSBuffer.fromString(content));
}
async function deleteFile(uri, options) {
  await StandaloneServices.get(IFileService).del(uri, options);
}
async function createModelReference(resource, content) {
  if (content != null) {
    await writeFile(resource, content);
  }
  return await StandaloneServices.get(ITextModelService).createModelReference(resource);
}
function isDynamicKeybindingService(keybindingService) {
  return keybindingService.registerKeybindingProvider != null;
}
var DelegateStandaloneKeybindingService = class DelegateStandaloneKeybindingService2 extends StandaloneKeybindingService {
  constructor(delegate, contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {
    super(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService);
    this.delegate = delegate;
    this._register(delegate.registerKeybindingProvider(() => this.getUserKeybindingItems()));
  }
  _getResolver() {
    return this.delegate._getResolver();
  }
  resolveKeyboardEvent(keyboardEvent) {
    return this.delegate.resolveKeyboardEvent(keyboardEvent);
  }
};
DelegateStandaloneKeybindingService = __decorate([
  __param(1, IContextKeyService),
  __param(2, ICommandService),
  __param(3, ITelemetryService),
  __param(4, INotificationService),
  __param(5, ILogService),
  __param(6, ICodeEditorService)
], DelegateStandaloneKeybindingService);
var standaloneEditorInstantiationService = null;
function getStandaloneEditorInstantiationService() {
  if (standaloneEditorInstantiationService == null) {
    const serviceCollection = new ServiceCollection();
    serviceCollection.set(IQuickInputService, new SyncDescriptor(StandaloneQuickInputService, void 0, true));
    const keybindingService = StandaloneServices.get(IKeybindingService);
    if (!(keybindingService instanceof StandaloneKeybindingService) && isDynamicKeybindingService(keybindingService)) {
      serviceCollection.set(IKeybindingService, new SyncDescriptor(DelegateStandaloneKeybindingService, [keybindingService], true));
    }
    standaloneEditorInstantiationService = StandaloneServices.get(IInstantiationService).createChild(serviceCollection);
  }
  return standaloneEditorInstantiationService;
}
var createConfiguredEditor = (domElement, options, override) => {
  StandaloneServices.initialize(override ?? {});
  return getStandaloneEditorInstantiationService().createInstance(ConfiguredStandaloneEditor, domElement, false, options);
};
var createConfiguredDiffEditor = (domElement, options, override) => {
  StandaloneServices.initialize(override ?? {});
  return getStandaloneEditorInstantiationService().createInstance(ConfiguredStandaloneDiffEditor, domElement, options);
};
var Extensions5 = {
  ...Extensions,
  ...Extensions3
};
export {
  CommandsRegistry,
  ContextKeyExpr,
  DisposableStore,
  Extensions5 as Extensions,
  FoldingController,
  FoldingModel,
  KeybindingsRegistry,
  MenuId,
  MenuRegistry,
  RawContextKey,
  Registry,
  createConfiguredDiffEditor,
  createConfiguredEditor,
  createModelReference,
  deleteFile,
  errorHandler,
  registerColor,
  setCollapseStateForMatchingLines,
  writeFile
};
//# sourceMappingURL=vscode_monaco.js.map
