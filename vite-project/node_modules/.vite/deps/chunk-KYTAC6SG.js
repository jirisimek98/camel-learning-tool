import {
  ILanguageFeatureDebounceService,
  ILanguageFeaturesService,
  IModelService,
  Position,
  Range,
  init_extensions,
  init_languageFeatureDebounce,
  init_languageFeatures,
  init_model,
  init_position,
  init_range,
  registerSingleton
} from "./chunk-O3SOEW3V.js";
import {
  CancellationTokenSource,
  DisposableStore,
  Iterable,
  LRUCache,
  VSBuffer,
  binarySearch,
  coalesceInPlace,
  commonPrefixLength,
  createDecorator,
  equals,
  init_arrays,
  init_buffer,
  init_cancellation,
  init_errors,
  init_instantiation,
  init_iterator,
  init_lifecycle,
  init_map,
  init_platform,
  init_strings,
  isLittleEndian,
  onUnexpectedExternalError
} from "./chunk-N5MAMNNV.js";
import {
  __esm
} from "./chunk-PGWBAY6J.js";

// node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js
var __decorate, __param, __awaiter, TreeElement, OutlineElement, OutlineGroup, OutlineModel, IOutlineModelService, OutlineModelService;
var init_outlineModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js"() {
    init_arrays();
    init_cancellation();
    init_errors();
    init_iterator();
    init_map();
    init_strings();
    init_position();
    init_range();
    init_languageFeatureDebounce();
    init_instantiation();
    init_extensions();
    init_model();
    init_lifecycle();
    init_languageFeatures();
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    TreeElement = class _TreeElement {
      remove() {
        var _a;
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.delete(this.id);
      }
      static findId(candidate, container) {
        let candidateId;
        if (typeof candidate === "string") {
          candidateId = `${container.id}/${candidate}`;
        } else {
          candidateId = `${container.id}/${candidate.name}`;
          if (container.children.get(candidateId) !== void 0) {
            candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;
          }
        }
        let id = candidateId;
        for (let i = 0; container.children.get(id) !== void 0; i++) {
          id = `${candidateId}_${i}`;
        }
        return id;
      }
      static getElementById(id, element) {
        if (!id) {
          return void 0;
        }
        const len = commonPrefixLength(id, element.id);
        if (len === id.length) {
          return element;
        }
        if (len < element.id.length) {
          return void 0;
        }
        for (const [, child] of element.children) {
          const candidate = _TreeElement.getElementById(id, child);
          if (candidate) {
            return candidate;
          }
        }
        return void 0;
      }
      static size(element) {
        let res = 1;
        for (const [, child] of element.children) {
          res += _TreeElement.size(child);
        }
        return res;
      }
      static empty(element) {
        return element.children.size === 0;
      }
    };
    OutlineElement = class extends TreeElement {
      constructor(id, parent, symbol) {
        super();
        this.id = id;
        this.parent = parent;
        this.symbol = symbol;
        this.children = /* @__PURE__ */ new Map();
      }
    };
    OutlineGroup = class extends TreeElement {
      constructor(id, parent, label, order) {
        super();
        this.id = id;
        this.parent = parent;
        this.label = label;
        this.order = order;
        this.children = /* @__PURE__ */ new Map();
      }
      getItemEnclosingPosition(position) {
        return position ? this._getItemEnclosingPosition(position, this.children) : void 0;
      }
      _getItemEnclosingPosition(position, children) {
        for (const [, item] of children) {
          if (!item.symbol.range || !Range.containsPosition(item.symbol.range, position)) {
            continue;
          }
          return this._getItemEnclosingPosition(position, item.children) || item;
        }
        return void 0;
      }
      updateMarker(marker) {
        for (const [, child] of this.children) {
          this._updateMarker(marker, child);
        }
      }
      _updateMarker(markers, item) {
        item.marker = void 0;
        const idx = binarySearch(markers, item.symbol.range, Range.compareRangesUsingStarts);
        let start;
        if (idx < 0) {
          start = ~idx;
          if (start > 0 && Range.areIntersecting(markers[start - 1], item.symbol.range)) {
            start -= 1;
          }
        } else {
          start = idx;
        }
        const myMarkers = [];
        let myTopSev;
        for (; start < markers.length && Range.areIntersecting(item.symbol.range, markers[start]); start++) {
          const marker = markers[start];
          myMarkers.push(marker);
          markers[start] = void 0;
          if (!myTopSev || marker.severity > myTopSev) {
            myTopSev = marker.severity;
          }
        }
        for (const [, child] of item.children) {
          this._updateMarker(myMarkers, child);
        }
        if (myTopSev) {
          item.marker = {
            count: myMarkers.length,
            topSev: myTopSev
          };
        }
        coalesceInPlace(markers);
      }
    };
    OutlineModel = class _OutlineModel extends TreeElement {
      static create(registry, textModel, token) {
        const cts = new CancellationTokenSource(token);
        const result = new _OutlineModel(textModel.uri);
        const provider = registry.ordered(textModel);
        const promises = provider.map((provider2, index) => {
          var _a;
          const id = TreeElement.findId(`provider_${index}`, result);
          const group = new OutlineGroup(id, result, (_a = provider2.displayName) !== null && _a !== void 0 ? _a : "Unknown Outline Provider", index);
          return Promise.resolve(provider2.provideDocumentSymbols(textModel, cts.token)).then((result2) => {
            for (const info of result2 || []) {
              _OutlineModel._makeOutlineElement(info, group);
            }
            return group;
          }, (err) => {
            onUnexpectedExternalError(err);
            return group;
          }).then((group2) => {
            if (!TreeElement.empty(group2)) {
              result._groups.set(id, group2);
            } else {
              group2.remove();
            }
          });
        });
        const listener = registry.onDidChange(() => {
          const newProvider = registry.ordered(textModel);
          if (!equals(newProvider, provider)) {
            cts.cancel();
          }
        });
        return Promise.all(promises).then(() => {
          if (cts.token.isCancellationRequested && !token.isCancellationRequested) {
            return _OutlineModel.create(registry, textModel, token);
          } else {
            return result._compact();
          }
        }).finally(() => {
          listener.dispose();
        });
      }
      static _makeOutlineElement(info, container) {
        const id = TreeElement.findId(info, container);
        const res = new OutlineElement(id, container, info);
        if (info.children) {
          for (const childInfo of info.children) {
            _OutlineModel._makeOutlineElement(childInfo, res);
          }
        }
        container.children.set(res.id, res);
      }
      static get(element) {
        while (element) {
          if (element instanceof _OutlineModel) {
            return element;
          }
          element = element.parent;
        }
        return void 0;
      }
      constructor(uri) {
        super();
        this.uri = uri;
        this.id = "root";
        this.parent = void 0;
        this._groups = /* @__PURE__ */ new Map();
        this.children = /* @__PURE__ */ new Map();
        this.id = "root";
        this.parent = void 0;
      }
      _compact() {
        let count = 0;
        for (const [key, group] of this._groups) {
          if (group.children.size === 0) {
            this._groups.delete(key);
          } else {
            count += 1;
          }
        }
        if (count !== 1) {
          this.children = this._groups;
        } else {
          const group = Iterable.first(this._groups.values());
          for (const [, child] of group.children) {
            child.parent = this;
            this.children.set(child.id, child);
          }
        }
        return this;
      }
      merge(other) {
        if (this.uri.toString() !== other.uri.toString()) {
          return false;
        }
        if (this._groups.size !== other._groups.size) {
          return false;
        }
        this._groups = other._groups;
        this.children = other.children;
        return true;
      }
      getItemEnclosingPosition(position, context) {
        let preferredGroup;
        if (context) {
          let candidate = context.parent;
          while (candidate && !preferredGroup) {
            if (candidate instanceof OutlineGroup) {
              preferredGroup = candidate;
            }
            candidate = candidate.parent;
          }
        }
        let result = void 0;
        for (const [, group] of this._groups) {
          result = group.getItemEnclosingPosition(position);
          if (result && (!preferredGroup || preferredGroup === group)) {
            break;
          }
        }
        return result;
      }
      getItemById(id) {
        return TreeElement.getElementById(id, this);
      }
      updateMarker(marker) {
        marker.sort(Range.compareRangesUsingStarts);
        for (const [, group] of this._groups) {
          group.updateMarker(marker.slice(0));
        }
      }
      getTopLevelSymbols() {
        const roots = [];
        for (const child of this.children.values()) {
          if (child instanceof OutlineElement) {
            roots.push(child.symbol);
          } else {
            roots.push(...Iterable.map(child.children.values(), (child2) => child2.symbol));
          }
        }
        return roots.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
      }
      asListOfDocumentSymbols() {
        const roots = this.getTopLevelSymbols();
        const bucket = [];
        _OutlineModel._flattenDocumentSymbols(bucket, roots, "");
        return bucket.sort((a, b) => Position.compare(Range.getStartPosition(a.range), Range.getStartPosition(b.range)) || Position.compare(Range.getEndPosition(b.range), Range.getEndPosition(a.range)));
      }
      static _flattenDocumentSymbols(bucket, entries, overrideContainerLabel) {
        for (const entry of entries) {
          bucket.push({
            kind: entry.kind,
            tags: entry.tags,
            name: entry.name,
            detail: entry.detail,
            containerName: entry.containerName || overrideContainerLabel,
            range: entry.range,
            selectionRange: entry.selectionRange,
            children: void 0
            // we flatten it...
          });
          if (entry.children) {
            _OutlineModel._flattenDocumentSymbols(bucket, entry.children, entry.name);
          }
        }
      }
    };
    IOutlineModelService = createDecorator("IOutlineModelService");
    OutlineModelService = class OutlineModelService2 {
      constructor(_languageFeaturesService, debounces, modelService) {
        this._languageFeaturesService = _languageFeaturesService;
        this._disposables = new DisposableStore();
        this._cache = new LRUCache(10, 0.7);
        this._debounceInformation = debounces.for(_languageFeaturesService.documentSymbolProvider, "DocumentSymbols", { min: 350 });
        this._disposables.add(modelService.onModelRemoved((textModel) => {
          this._cache.delete(textModel.id);
        }));
      }
      dispose() {
        this._disposables.dispose();
      }
      getOrCreate(textModel, token) {
        return __awaiter(this, void 0, void 0, function* () {
          const registry = this._languageFeaturesService.documentSymbolProvider;
          const provider = registry.ordered(textModel);
          let data = this._cache.get(textModel.id);
          if (!data || data.versionId !== textModel.getVersionId() || !equals(data.provider, provider)) {
            const source = new CancellationTokenSource();
            data = {
              versionId: textModel.getVersionId(),
              provider,
              promiseCnt: 0,
              source,
              promise: OutlineModel.create(registry, textModel, source.token),
              model: void 0
            };
            this._cache.set(textModel.id, data);
            const now = Date.now();
            data.promise.then((outlineModel) => {
              data.model = outlineModel;
              this._debounceInformation.update(textModel, Date.now() - now);
            }).catch((_err) => {
              this._cache.delete(textModel.id);
            });
          }
          if (data.model) {
            return data.model;
          }
          data.promiseCnt += 1;
          const listener = token.onCancellationRequested(() => {
            if (--data.promiseCnt === 0) {
              data.source.cancel();
              this._cache.delete(textModel.id);
            }
          });
          try {
            return yield data.promise;
          } finally {
            listener.dispose();
          }
        });
      }
      getDebounceValue(textModel) {
        return this._debounceInformation.get(textModel);
      }
    };
    OutlineModelService = __decorate([
      __param(0, ILanguageFeaturesService),
      __param(1, ILanguageFeatureDebounceService),
      __param(2, IModelService)
    ], OutlineModelService);
    registerSingleton(
      IOutlineModelService,
      OutlineModelService,
      1
      /* InstantiationType.Delayed */
    );
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js
init_buffer();
init_platform();
function reverseEndianness(arr) {
  for (let i = 0, len = arr.length; i < len; i += 4) {
    const b0 = arr[i + 0];
    const b1 = arr[i + 1];
    const b2 = arr[i + 2];
    const b3 = arr[i + 3];
    arr[i + 0] = b3;
    arr[i + 1] = b2;
    arr[i + 2] = b1;
    arr[i + 3] = b0;
  }
}
function toLittleEndianBuffer(arr) {
  const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);
  if (!isLittleEndian()) {
    reverseEndianness(uint8Arr);
  }
  return VSBuffer.wrap(uint8Arr);
}
function fromLittleEndianBuffer(buff) {
  const uint8Arr = buff.buffer;
  if (!isLittleEndian()) {
    reverseEndianness(uint8Arr);
  }
  if (uint8Arr.byteOffset % 4 === 0) {
    return new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);
  } else {
    const data = new Uint8Array(uint8Arr.byteLength);
    data.set(uint8Arr);
    return new Uint32Array(data.buffer, data.byteOffset, data.length / 4);
  }
}
function encodeSemanticTokensDto(semanticTokens) {
  const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));
  let offset = 0;
  dest[offset++] = semanticTokens.id;
  if (semanticTokens.type === "full") {
    dest[offset++] = 1;
    dest[offset++] = semanticTokens.data.length;
    dest.set(semanticTokens.data, offset);
    offset += semanticTokens.data.length;
  } else {
    dest[offset++] = 2;
    dest[offset++] = semanticTokens.deltas.length;
    for (const delta of semanticTokens.deltas) {
      dest[offset++] = delta.start;
      dest[offset++] = delta.deleteCount;
      if (delta.data) {
        dest[offset++] = delta.data.length;
        dest.set(delta.data, offset);
        offset += delta.data.length;
      } else {
        dest[offset++] = 0;
      }
    }
  }
  return toLittleEndianBuffer(dest);
}
function encodeSemanticTokensDtoSize(semanticTokens) {
  let result = 0;
  result += 1 + 1;
  if (semanticTokens.type === "full") {
    result += 1 + semanticTokens.data.length;
  } else {
    result += 1;
    result += (1 + 1 + 1) * semanticTokens.deltas.length;
    for (const delta of semanticTokens.deltas) {
      if (delta.data) {
        result += delta.data.length;
      }
    }
  }
  return result;
}
function decodeSemanticTokensDto(_buff) {
  const src = fromLittleEndianBuffer(_buff);
  let offset = 0;
  const id = src[offset++];
  const type = src[offset++];
  if (type === 1) {
    const length = src[offset++];
    const data = src.subarray(offset, offset + length);
    offset += length;
    return {
      id,
      type: "full",
      data
    };
  }
  const deltaCount = src[offset++];
  const deltas = [];
  for (let i = 0; i < deltaCount; i++) {
    const start = src[offset++];
    const deleteCount = src[offset++];
    const length = src[offset++];
    let data;
    if (length > 0) {
      data = src.subarray(offset, offset + length);
      offset += length;
    }
    deltas[i] = { start, deleteCount, data };
  }
  return {
    id,
    type: "delta",
    deltas
  };
}

export {
  encodeSemanticTokensDto,
  decodeSemanticTokensDto,
  OutlineElement,
  OutlineGroup,
  OutlineModel,
  IOutlineModelService,
  init_outlineModel
};
//# sourceMappingURL=chunk-KYTAC6SG.js.map
