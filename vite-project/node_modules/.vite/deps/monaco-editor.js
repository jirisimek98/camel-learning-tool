import {
  ClickLinkGesture,
  DefinitionAction,
  FoldingController,
  FormattingConflicts,
  FormattingEdit,
  IndentRangeProvider,
  InlayHintsController,
  InlineCompletionsController,
  InlineSuggestionHintsContentWidget,
  RangesLimitReporter,
  RenderedInlayHintLabelPart,
  SEMANTIC_HIGHLIGHTING_SETTING_ID,
  SyntaxRangeProvider,
  TrimTrailingWhitespaceCommand,
  alertFormattingEdits,
  asCommandLink,
  foldingCollapsedIcon,
  foldingExpandedIcon,
  formatDocumentRangesWithSelectedProvider,
  formatDocumentWithSelectedProvider,
  getDefinitionsAtPosition,
  getOnTypeFormattingEdits,
  goToDefinitionWithLocation,
  init_format,
  init_formattingEdit,
  inlineSuggestCommitId,
  isSemanticColoringEnabled,
  showNextInlineSuggestionActionId,
  showPreviousInlineSuggestionActionId,
  toggleCollapseState
} from "./chunk-B6SX2JWG.js";
import {
  IOutlineModelService,
  OutlineElement,
  OutlineGroup,
  OutlineModel,
  encodeSemanticTokensDto,
  init_outlineModel
} from "./chunk-KYTAC6SG.js";
import {
  CodeDataTransfers,
  DraggedTreeItemsIdentifier,
  ITreeViewsDnDService,
  LocalSelectionTransfer,
  UriList,
  VSDataTransfer,
  buildReplaceStringWithCasePreserved,
  createFileDataTransferItem,
  createStringDataTransferItem,
  createWebWorker,
  matchesMimeType,
  showHistoryKeybindingHint
} from "./chunk-MEAKYGIF.js";
import {
  PeekContext,
  PeekViewWidget,
  StandaloneDiffEditor,
  StandaloneDiffEditor2,
  StandaloneEditor,
  createTextModel,
  peekViewTitleForeground,
  peekViewTitleInfoForeground
} from "./chunk-XHQJEB2N.js";
import {
  $,
  AccessibilitySupport,
  Action,
  Action2,
  ActionBar,
  AsyncIterableObject,
  BareFontInfo,
  BracketSelectionRangeProvider,
  Button,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  CaseSensitiveToggle,
  Categories,
  CharacterSet,
  ClipboardEventUtils,
  CodeActionCommandArgs,
  CodeActionController,
  CodeActionKind,
  CodeActionTriggerSource,
  CodeActionTriggerType,
  Color,
  CommandsRegistry,
  CompletionItemInsertTextRule,
  CompletionItemKind,
  CompletionItemTag,
  CompletionModel,
  CompletionOptions,
  CompletionTriggerKind,
  ContentWidgetPositionPreference,
  Context,
  ContextScopedFindInput,
  ContextScopedReplaceInput,
  CopyOptions,
  CoreEditingCommands,
  CursorChangeReason,
  CursorMoveCommands,
  CursorState,
  DataTransfers,
  DefaultEndOfLine,
  Delayer,
  DiffNavigator,
  Dimension,
  DocumentHighlightKind,
  DocumentHighlightKind2,
  DomScrollableElement,
  DynamicCssRules,
  EditOperation,
  EditorAction,
  EditorAction2,
  EditorAutoIndentStrategy,
  EditorCommand,
  EditorContextKeys,
  EditorOption,
  EditorState,
  EditorStateCancellationTokenSource,
  EditorType,
  EditorWorkerClient,
  EditorZoom,
  EmbeddedCodeEditorWidget,
  EncodedTokenizationResult,
  EndOfLinePreference,
  EndOfLineSequence,
  EventHelper,
  EventType,
  Extensions2 as Extensions,
  FoldingRangeKind,
  FontInfo,
  FontMeasurements,
  GlobalPointerMoveMonitor,
  GlyphMarginLane,
  HSVA,
  IAccessibilityService,
  IBulkEditService,
  IClipboardService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextMenuService,
  IContextViewService,
  IDialogService,
  IEditorProgressService,
  IEditorWorkerService,
  IKeybindingService,
  ILabelService,
  ILanguageConfigurationService,
  ILanguageFeatureDebounceService,
  ILanguageFeaturesService,
  ILanguageService,
  IMarkerData,
  IMarkerDecorationsService,
  IMarkerService,
  IMenuService,
  IModelService,
  INotificationService,
  IOpenerService,
  IProgressService,
  IQuickInputService,
  ISemanticTokensStylingService,
  IStandaloneThemeService,
  IStorageService,
  ISuggestMemoryService,
  ITextModelService,
  ITextResourceConfigurationService,
  IThemeService,
  IWorkspaceContextService,
  IWorkspaceTrustManagementService,
  InMemoryClipboardMetadataManager,
  IndentAction as IndentAction2,
  InjectedTextCursorStops,
  InlayHintKind2 as InlayHintKind,
  InlineCompletionContextKeys,
  InlineCompletionTriggerKind2 as InlineCompletionTriggerKind,
  IsWindowsContext,
  KeyChord,
  LazyTokenizationSupport,
  LightBulbWidget,
  LineContext,
  LineDecoration,
  LineRange,
  LineRangeMapping,
  LineTokens,
  Link,
  MarkdownRenderer,
  MarkerSeverity,
  MenuId,
  MenuRegistry,
  MessageController,
  MinimapPosition as MinimapPosition2,
  ModelDecorationInjectedTextOptions,
  ModelDecorationOptions,
  ModesRegistry,
  MouseTargetType,
  MoveOperations,
  MovedText,
  MultiCommand,
  MultiEditorAction,
  NullState,
  OverlayWidgetPositionPreference,
  OverviewRulerLane as OverviewRulerLane2,
  PLAINTEXT_LANGUAGE_ID,
  PixelRatio,
  Position,
  PositionAffinity,
  Progress,
  QuickSuggestionsOptions,
  RGBA,
  Range,
  RangeMapping,
  RegexToggle,
  Registry,
  RenderLineInput,
  RenderLineNumbersType,
  RenderMinimap,
  ReplaceCommand,
  ReplaceCommandThatPreservesSelection,
  ReplaceCommandThatSelectsText,
  ResizableHTMLElement,
  ResourceTextEdit,
  RunOnceScheduler,
  SUPPORTED_CODE_ACTIONS,
  Sash,
  ScrollType,
  ScrollableElement,
  ScrollbarVisibility,
  SearchParams,
  SelectedSuggestionInfo,
  Selection,
  Severity,
  ShiftCommand,
  SignatureHelpTriggerKind,
  SignatureHelpTriggerKind2,
  SimpleLineRangeMapping,
  StableEditorScrollState,
  StandaloneKeybindingService,
  StandaloneServices,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StringBuilder,
  SymbolKind,
  SymbolTag,
  TabFocus,
  TextEditorCursorBlinkingStyle,
  TextEditorCursorStyle,
  TimeoutTimer,
  Toggle,
  Token,
  TokenizationRegistry,
  TokenizationResult,
  TrackedRangeStickiness,
  TypeOperations,
  UnicodeTextModelHighlighter,
  ViewLineRenderingData,
  WholeWordsToggle,
  Widget,
  WillSaveStateReason,
  WordDistance,
  WordOperations,
  WordPartOperations,
  WrappingIndent,
  activeContrastBorder,
  addDisposableListener,
  addStandardDisposableListener,
  alert,
  append,
  asCssVariable,
  autoFixCommandId,
  autorun,
  clearNode,
  codeActionCommandId,
  constObservable,
  contrastBorder,
  createAndFillInActionBarActions,
  createCancelableAsyncIterable,
  createCancelablePromise,
  createMonacoBaseAPI,
  createTrustedTypesPolicy,
  defaultInputBoxStyles,
  defaultToggleStyles,
  disposableTimeout,
  editorBackground,
  editorConfigurationBaseNode,
  editorErrorBorder,
  editorErrorForeground,
  editorFindMatch,
  editorFindMatchBorder,
  editorFindMatchHighlight,
  editorFindMatchHighlightBorder,
  editorFindRangeHighlight,
  editorFindRangeHighlightBorder,
  editorHoverBackground,
  editorHoverBorder,
  editorInfoBorder,
  editorInfoForeground,
  editorSelectionHighlight,
  editorWarningBorder,
  editorWarningForeground,
  editorWidgetBackground,
  editorWidgetBorder,
  editorWidgetForeground,
  editorWidgetResizeBorder,
  errorForeground,
  first,
  fixAllCommandId,
  focusBorder,
  getClientArea,
  getCodeActions,
  getColumnOfNodeOffset,
  getComputedStyle,
  getDomNodePagePosition,
  getEnterAction,
  getGoodIndentForLine,
  getIndentMetadata,
  getMapForWordSeparators,
  getTopLeftOffset,
  getTotalHeight,
  getTotalWidth,
  init_actions,
  init_actions2,
  init_aria,
  init_async,
  init_browser,
  init_characterClassifier,
  init_codeEditorService,
  init_color,
  init_colorRegistry,
  init_commands,
  init_configuration,
  init_configurationRegistry,
  init_dom,
  init_editOperation,
  init_editorColorRegistry,
  init_editorCommon,
  init_editorContextKeys,
  init_editorExtensions,
  init_editorState,
  init_editorWorker,
  init_extensions,
  init_indentation,
  init_keyCodes,
  init_keyboardEvent,
  init_language,
  init_languageConfigurationRegistry,
  init_languageFeatureDebounce,
  init_languageFeatures,
  init_languages,
  init_lineRange,
  init_lineTokens,
  init_model as init_model2,
  init_modesRegistry,
  init_mouseEvent,
  init_nullTokenize,
  init_opener,
  init_platform as init_platform2,
  init_position,
  init_progress,
  init_range,
  init_resolverService,
  init_selection,
  init_stableEditorScroll,
  init_stringBuilder,
  init_textModel,
  init_textModelSearch,
  init_theme,
  init_themeService,
  init_wordCharacterClassifier,
  inputActiveOptionBackground,
  inputActiveOptionBorder,
  inputActiveOptionForeground,
  inputBackground,
  inputBorder,
  inputForeground,
  isFirefox,
  isHighContrast,
  isInDOM,
  isModelDecorationInComment,
  isModelDecorationInString,
  isModelDecorationVisible,
  listHighlightForeground,
  minimapFindMatch,
  minimapSelectionOccurrenceHighlight,
  normalizeIndentation,
  nullTokenize,
  nullTokenizeEncoded,
  oneOf,
  organizeImportsCommandId,
  overviewRulerFindMatchForeground,
  overviewRulerRangeHighlight,
  overviewRulerSelectionHighlightForeground,
  provideSuggestionItems,
  quickFixCommandId,
  raceCancellation,
  refactorCommandId,
  registerAction2,
  registerColor,
  registerEditorAction,
  registerEditorCommand,
  registerEditorContribution,
  registerEditorFeature,
  registerIcon,
  registerModelAndPositionCommand,
  registerMultiEditorAction,
  registerSingleton,
  registerThemingParticipant,
  renderLabelWithIcons,
  renderViewLine,
  renderViewLine2,
  reset,
  runWhenIdle,
  severity_default,
  sourceActionCommandId,
  status,
  themeColorFromId,
  timeout,
  toAction,
  toMultilineTokens2,
  toolbarHoverBackground,
  trackFocus,
  transaction,
  transparent,
  widgetBorder,
  widgetClose,
  widgetShadow
} from "./chunk-O3SOEW3V.js";
import {
  ApplyUpdateResult,
  CancellationToken,
  CancellationTokenSource,
  Codicon,
  ConfigurationChangedEvent,
  ContextKeyExpr,
  Disposable,
  DisposableStore,
  EDITOR_FONT_DEFAULTS,
  EditorOptions,
  Emitter,
  Event,
  FindMatch,
  FuzzyScore,
  IContextKeyService,
  IInstantiationService,
  ILogService,
  ITelemetryService,
  IndentAction,
  InvisibleCharacters,
  Iterable,
  LRUCache,
  Lazy,
  LinkedList,
  MarkdownString,
  Mimes,
  MinimapPosition,
  MutableDisposable,
  OverviewRulerLane,
  RawContextKey,
  RefCountedDisposable,
  Schemas,
  StopWatch,
  TextModelResolvedOptions,
  ThemeIcon,
  URI,
  asArray,
  assertIsDefined,
  assertType,
  basename2 as basename,
  binarySearch,
  coalesce,
  commonPrefixLength,
  commonSuffixLength,
  compare,
  createDecorator,
  dispose,
  equals,
  escapeRegExpCharacters,
  findFirstInSorted,
  firstNonWhitespaceIndex,
  format,
  generateUuid,
  getLeadingWhitespace,
  illegalArgument,
  inUntrustedWorkspace,
  init_arrays,
  init_cancellation,
  init_codicons,
  init_contextkey,
  init_editorOptions,
  init_errors,
  init_event,
  init_filters,
  init_functional,
  init_htmlContent,
  init_instantiation,
  init_iterator,
  init_languageConfiguration,
  init_lazy,
  init_lifecycle,
  init_linkedList,
  init_log,
  init_map,
  init_mime,
  init_model,
  init_network,
  init_nls,
  init_platform,
  init_resources,
  init_stopwatch,
  init_strings,
  init_telemetry,
  init_themables,
  init_types,
  init_uri,
  init_uuid,
  isBasicASCII,
  isCancellationError,
  isDisposable,
  isEmptyMarkdownString,
  isIOS,
  isLinux,
  isLowerAsciiLetter,
  isMacintosh,
  isNative,
  isNonEmptyArray,
  isUpperAsciiLetter,
  isWeb,
  isWindows,
  joinPath,
  language,
  lastNonWhitespaceIndex,
  localize,
  noBreakWhitespace,
  onUnexpectedError,
  onUnexpectedExternalError,
  once,
  originalFSPath,
  relativePath,
  splitLines,
  startsWithUTF8BOM,
  toDisposable,
  unicodeHighlightConfigKeys
} from "./chunk-N5MAMNNV.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-PGWBAY6J.js";

// node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/formatActions.js
var require_formatActions = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/formatActions.js"(exports) {
    init_arrays();
    init_cancellation();
    init_errors();
    init_keyCodes();
    init_lifecycle();
    init_editorExtensions();
    init_codeEditorService();
    init_characterClassifier();
    init_range();
    init_editorContextKeys();
    init_editorWorker();
    init_languageFeatures();
    init_format();
    init_formattingEdit();
    init_nls();
    init_commands();
    init_contextkey();
    init_instantiation();
    init_progress();
    var __decorate45 = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param45 = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __awaiter43 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var FormatOnType = class FormatOnType {
      constructor(_editor, _languageFeaturesService, _workerService) {
        this._editor = _editor;
        this._languageFeaturesService = _languageFeaturesService;
        this._workerService = _workerService;
        this._disposables = new DisposableStore();
        this._sessionDisposables = new DisposableStore();
        this._disposables.add(_languageFeaturesService.onTypeFormattingEditProvider.onDidChange(this._update, this));
        this._disposables.add(_editor.onDidChangeModel(() => this._update()));
        this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
        this._disposables.add(_editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            55
            /* EditorOption.formatOnType */
          )) {
            this._update();
          }
        }));
        this._update();
      }
      dispose() {
        this._disposables.dispose();
        this._sessionDisposables.dispose();
      }
      _update() {
        this._sessionDisposables.clear();
        if (!this._editor.getOption(
          55
          /* EditorOption.formatOnType */
        )) {
          return;
        }
        if (!this._editor.hasModel()) {
          return;
        }
        const model = this._editor.getModel();
        const [support] = this._languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
        if (!support || !support.autoFormatTriggerCharacters) {
          return;
        }
        const triggerChars = new CharacterSet();
        for (const ch of support.autoFormatTriggerCharacters) {
          triggerChars.add(ch.charCodeAt(0));
        }
        this._sessionDisposables.add(this._editor.onDidType((text) => {
          const lastCharCode = text.charCodeAt(text.length - 1);
          if (triggerChars.has(lastCharCode)) {
            this._trigger(String.fromCharCode(lastCharCode));
          }
        }));
      }
      _trigger(ch) {
        if (!this._editor.hasModel()) {
          return;
        }
        if (this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty()) {
          return;
        }
        const model = this._editor.getModel();
        const position = this._editor.getPosition();
        const cts = new CancellationTokenSource();
        const unbind = this._editor.onDidChangeModelContent((e) => {
          if (e.isFlush) {
            cts.cancel();
            unbind.dispose();
            return;
          }
          for (let i = 0, len = e.changes.length; i < len; i++) {
            const change = e.changes[i];
            if (change.range.endLineNumber <= position.lineNumber) {
              cts.cancel();
              unbind.dispose();
              return;
            }
          }
        });
        getOnTypeFormattingEdits(this._workerService, this._languageFeaturesService, model, position, ch, model.getFormattingOptions(), cts.token).then((edits) => {
          if (cts.token.isCancellationRequested) {
            return;
          }
          if (isNonEmptyArray(edits)) {
            FormattingEdit.execute(this._editor, edits, true);
            alertFormattingEdits(edits);
          }
        }).finally(() => {
          unbind.dispose();
        });
      }
    };
    FormatOnType.ID = "editor.contrib.autoFormat";
    FormatOnType = __decorate45([
      __param45(1, ILanguageFeaturesService),
      __param45(2, IEditorWorkerService)
    ], FormatOnType);
    var FormatOnPaste = class FormatOnPaste {
      constructor(editor2, _languageFeaturesService, _instantiationService) {
        this.editor = editor2;
        this._languageFeaturesService = _languageFeaturesService;
        this._instantiationService = _instantiationService;
        this._callOnDispose = new DisposableStore();
        this._callOnModel = new DisposableStore();
        this._callOnDispose.add(editor2.onDidChangeConfiguration(() => this._update()));
        this._callOnDispose.add(editor2.onDidChangeModel(() => this._update()));
        this._callOnDispose.add(editor2.onDidChangeModelLanguage(() => this._update()));
        this._callOnDispose.add(_languageFeaturesService.documentRangeFormattingEditProvider.onDidChange(this._update, this));
      }
      dispose() {
        this._callOnDispose.dispose();
        this._callOnModel.dispose();
      }
      _update() {
        this._callOnModel.clear();
        if (!this.editor.getOption(
          54
          /* EditorOption.formatOnPaste */
        )) {
          return;
        }
        if (!this.editor.hasModel()) {
          return;
        }
        if (!this._languageFeaturesService.documentRangeFormattingEditProvider.has(this.editor.getModel())) {
          return;
        }
        this._callOnModel.add(this.editor.onDidPaste(({ range }) => this._trigger(range)));
      }
      _trigger(range) {
        if (!this.editor.hasModel()) {
          return;
        }
        if (this.editor.getSelections().length > 1) {
          return;
        }
        this._instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, this.editor, range, 2, Progress.None, CancellationToken.None).catch(onUnexpectedError);
      }
    };
    FormatOnPaste.ID = "editor.contrib.formatOnPaste";
    FormatOnPaste = __decorate45([
      __param45(1, ILanguageFeaturesService),
      __param45(2, IInstantiationService)
    ], FormatOnPaste);
    var FormatDocumentAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.formatDocument",
          label: localize("formatDocument.label", "Format Document"),
          alias: "Format Document",
          precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 512 | 36,
            linux: {
              primary: 2048 | 1024 | 39
              /* KeyCode.KeyI */
            },
            weight: 100
            /* KeybindingWeight.EditorContrib */
          },
          contextMenuOpts: {
            group: "1_modification",
            order: 1.3
          }
        });
      }
      run(accessor, editor2) {
        return __awaiter43(this, void 0, void 0, function* () {
          if (editor2.hasModel()) {
            const instaService = accessor.get(IInstantiationService);
            const progressService = accessor.get(IEditorProgressService);
            yield progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor2, 1, Progress.None, CancellationToken.None), 250);
          }
        });
      }
    };
    var FormatSelectionAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.formatSelection",
          label: localize("formatSelection.label", "Format Selection"),
          alias: "Format Selection",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 36
              /* KeyCode.KeyF */
            ),
            weight: 100
            /* KeybindingWeight.EditorContrib */
          },
          contextMenuOpts: {
            when: EditorContextKeys.hasNonEmptySelection,
            group: "1_modification",
            order: 1.31
          }
        });
      }
      run(accessor, editor2) {
        return __awaiter43(this, void 0, void 0, function* () {
          if (!editor2.hasModel()) {
            return;
          }
          const instaService = accessor.get(IInstantiationService);
          const model = editor2.getModel();
          const ranges = editor2.getSelections().map((range) => {
            return range.isEmpty() ? new Range(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber)) : range;
          });
          const progressService = accessor.get(IEditorProgressService);
          yield progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor2, ranges, 1, Progress.None, CancellationToken.None), 250);
        });
      }
    };
    registerEditorContribution(
      FormatOnType.ID,
      FormatOnType,
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    );
    registerEditorContribution(
      FormatOnPaste.ID,
      FormatOnPaste,
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    );
    registerEditorAction(FormatDocumentAction);
    registerEditorAction(FormatSelectionAction);
    CommandsRegistry.registerCommand("editor.action.format", (accessor) => __awaiter43(void 0, void 0, void 0, function* () {
      const editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
      if (!editor2 || !editor2.hasModel()) {
        return;
      }
      const commandService = accessor.get(ICommandService);
      if (editor2.getSelection().isEmpty()) {
        yield commandService.executeCommand("editor.action.formatDocument");
      } else {
        yield commandService.executeCommand("editor.action.formatSelection");
      }
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/documentSymbols.js
var require_documentSymbols = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/documentSymbols.js"(exports) {
    init_cancellation();
    init_types();
    init_uri();
    init_resolverService();
    init_outlineModel();
    init_commands();
    var __awaiter43 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    CommandsRegistry.registerCommand("_executeDocumentSymbolProvider", function(accessor, ...args) {
      return __awaiter43(this, void 0, void 0, function* () {
        const [resource] = args;
        assertType(URI.isUri(resource));
        const outlineService = accessor.get(IOutlineModelService);
        const modelService = accessor.get(ITextModelService);
        const reference = yield modelService.createModelReference(resource);
        try {
          return (yield outlineService.getOrCreate(reference.object.textEditorModel, CancellationToken.None)).getTopLevelSymbols();
        } finally {
          reference.dispose();
        }
      });
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplaceCommand.js
var InPlaceReplaceCommand;
var init_inPlaceReplaceCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplaceCommand.js"() {
    init_selection();
    InPlaceReplaceCommand = class {
      constructor(editRange, originalSelection, text) {
        this._editRange = editRange;
        this._originalSelection = originalSelection;
        this._text = text;
      }
      getEditOperations(model, builder) {
        builder.addTrackedEditOperation(this._editRange, this._text);
      }
      computeCursorState(model, helper) {
        const inverseEditOperations = helper.getInverseEditOperations();
        const srcRange = inverseEditOperations[0].range;
        if (!this._originalSelection.isEmpty()) {
          return new Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
        }
        return new Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.css";
var require_inPlaceReplace = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js"(exports) {
    init_async();
    init_errors();
    init_editorState();
    init_editorExtensions();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_textModel();
    init_editorWorker();
    init_nls();
    init_inPlaceReplaceCommand();
    var __decorate45 = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param45 = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var InPlaceReplaceController_1;
    var InPlaceReplaceController = InPlaceReplaceController_1 = class InPlaceReplaceController {
      static get(editor2) {
        return editor2.getContribution(InPlaceReplaceController_1.ID);
      }
      constructor(editor2, editorWorkerService) {
        this.editor = editor2;
        this.editorWorkerService = editorWorkerService;
        this.decorations = this.editor.createDecorationsCollection();
      }
      dispose() {
      }
      run(source, up) {
        var _a;
        (_a = this.currentRequest) === null || _a === void 0 ? void 0 : _a.cancel();
        const editorSelection = this.editor.getSelection();
        const model = this.editor.getModel();
        if (!model || !editorSelection) {
          return void 0;
        }
        let selection = editorSelection;
        if (selection.startLineNumber !== selection.endLineNumber) {
          return void 0;
        }
        const state = new EditorState(
          this.editor,
          1 | 4
          /* CodeEditorStateFlag.Position */
        );
        const modelURI = model.uri;
        if (!this.editorWorkerService.canNavigateValueSet(modelURI)) {
          return Promise.resolve(void 0);
        }
        this.currentRequest = createCancelablePromise((token) => this.editorWorkerService.navigateValueSet(modelURI, selection, up));
        return this.currentRequest.then((result) => {
          var _a2;
          if (!result || !result.range || !result.value) {
            return;
          }
          if (!state.validate(this.editor)) {
            return;
          }
          const editRange = Range.lift(result.range);
          let highlightRange = result.range;
          const diff = result.value.length - (selection.endColumn - selection.startColumn);
          highlightRange = {
            startLineNumber: highlightRange.startLineNumber,
            startColumn: highlightRange.startColumn,
            endLineNumber: highlightRange.endLineNumber,
            endColumn: highlightRange.startColumn + result.value.length
          };
          if (diff > 1) {
            selection = new Selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
          }
          const command = new InPlaceReplaceCommand(editRange, selection, result.value);
          this.editor.pushUndoStop();
          this.editor.executeCommand(source, command);
          this.editor.pushUndoStop();
          this.decorations.set([{
            range: highlightRange,
            options: InPlaceReplaceController_1.DECORATION
          }]);
          (_a2 = this.decorationRemover) === null || _a2 === void 0 ? void 0 : _a2.cancel();
          this.decorationRemover = timeout(350);
          this.decorationRemover.then(() => this.decorations.clear()).catch(onUnexpectedError);
        }).catch(onUnexpectedError);
      }
    };
    InPlaceReplaceController.ID = "editor.contrib.inPlaceReplaceController";
    InPlaceReplaceController.DECORATION = ModelDecorationOptions.register({
      description: "in-place-replace",
      className: "valueSetReplacement"
    });
    InPlaceReplaceController = InPlaceReplaceController_1 = __decorate45([
      __param45(1, IEditorWorkerService)
    ], InPlaceReplaceController);
    var InPlaceReplaceUp = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inPlaceReplace.up",
          label: localize("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
          alias: "Replace with Previous Value",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 87,
            weight: 100
            /* KeybindingWeight.EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        const controller = InPlaceReplaceController.get(editor2);
        if (!controller) {
          return Promise.resolve(void 0);
        }
        return controller.run(this.id, false);
      }
    };
    var InPlaceReplaceDown = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inPlaceReplace.down",
          label: localize("InPlaceReplaceAction.next.label", "Replace with Next Value"),
          alias: "Replace with Next Value",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 89,
            weight: 100
            /* KeybindingWeight.EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        const controller = InPlaceReplaceController.get(editor2);
        if (!controller) {
          return Promise.resolve(void 0);
        }
        return controller.run(this.id, true);
      }
    };
    registerEditorContribution(
      InPlaceReplaceController.ID,
      InPlaceReplaceController,
      4
      /* EditorContributionInstantiation.Lazy */
    );
    registerEditorAction(InPlaceReplaceUp);
    registerEditorAction(InPlaceReplaceDown);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/browser/anchorSelect.js
init_aria();
init_htmlContent();
init_keyCodes();
init_editorExtensions();
init_selection();
init_editorContextKeys();
init_nls();
init_contextkey();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/browser/anchorSelect.css";
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SelectionAnchorController_1;
var SelectionAnchorSet = new RawContextKey("selectionAnchorSet", false);
var SelectionAnchorController = SelectionAnchorController_1 = class SelectionAnchorController2 {
  static get(editor2) {
    return editor2.getContribution(SelectionAnchorController_1.ID);
  }
  constructor(editor2, contextKeyService) {
    this.editor = editor2;
    this.selectionAnchorSetContextKey = SelectionAnchorSet.bindTo(contextKeyService);
    this.modelChangeListener = editor2.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
  }
  setSelectionAnchor() {
    if (this.editor.hasModel()) {
      const position = this.editor.getPosition();
      this.editor.changeDecorations((accessor) => {
        if (this.decorationId) {
          accessor.removeDecoration(this.decorationId);
        }
        this.decorationId = accessor.addDecoration(Selection.fromPositions(position, position), {
          description: "selection-anchor",
          stickiness: 1,
          hoverMessage: new MarkdownString().appendText(localize("selectionAnchor", "Selection Anchor")),
          className: "selection-anchor"
        });
      });
      this.selectionAnchorSetContextKey.set(!!this.decorationId);
      alert(localize("anchorSet", "Anchor set at {0}:{1}", position.lineNumber, position.column));
    }
  }
  goToSelectionAnchor() {
    if (this.editor.hasModel() && this.decorationId) {
      const anchorPosition = this.editor.getModel().getDecorationRange(this.decorationId);
      if (anchorPosition) {
        this.editor.setPosition(anchorPosition.getStartPosition());
      }
    }
  }
  selectFromAnchorToCursor() {
    if (this.editor.hasModel() && this.decorationId) {
      const start = this.editor.getModel().getDecorationRange(this.decorationId);
      if (start) {
        const end = this.editor.getPosition();
        this.editor.setSelection(Selection.fromPositions(start.getStartPosition(), end));
        this.cancelSelectionAnchor();
      }
    }
  }
  cancelSelectionAnchor() {
    if (this.decorationId) {
      const decorationId = this.decorationId;
      this.editor.changeDecorations((accessor) => {
        accessor.removeDecoration(decorationId);
        this.decorationId = void 0;
      });
      this.selectionAnchorSetContextKey.set(false);
    }
  }
  dispose() {
    this.cancelSelectionAnchor();
    this.modelChangeListener.dispose();
  }
};
SelectionAnchorController.ID = "editor.contrib.selectionAnchorController";
SelectionAnchorController = SelectionAnchorController_1 = __decorate([
  __param(1, IContextKeyService)
], SelectionAnchorController);
var SetSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.setSelectionAnchor",
      label: localize("setSelectionAnchor", "Set Selection Anchor"),
      alias: "Set Selection Anchor",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 32
          /* KeyCode.KeyB */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      (_a = SelectionAnchorController.get(editor2)) === null || _a === void 0 ? void 0 : _a.setSelectionAnchor();
    });
  }
};
var GoToSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToSelectionAnchor",
      label: localize("goToSelectionAnchor", "Go to Selection Anchor"),
      alias: "Go to Selection Anchor",
      precondition: SelectionAnchorSet
    });
  }
  run(_accessor, editor2) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      (_a = SelectionAnchorController.get(editor2)) === null || _a === void 0 ? void 0 : _a.goToSelectionAnchor();
    });
  }
};
var SelectFromAnchorToCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectFromAnchorToCursor",
      label: localize("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
      alias: "Select from Anchor to Cursor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 41
          /* KeyCode.KeyK */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      (_a = SelectionAnchorController.get(editor2)) === null || _a === void 0 ? void 0 : _a.selectFromAnchorToCursor();
    });
  }
};
var CancelSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.cancelSelectionAnchor",
      label: localize("cancelSelectionAnchor", "Cancel Selection Anchor"),
      alias: "Cancel Selection Anchor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      (_a = SelectionAnchorController.get(editor2)) === null || _a === void 0 ? void 0 : _a.cancelSelectionAnchor();
    });
  }
};
registerEditorContribution(
  SelectionAnchorController.ID,
  SelectionAnchorController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(SetSelectionAnchor);
registerEditorAction(GoToSelectionAnchor);
registerEditorAction(SelectFromAnchorToCursor);
registerEditorAction(CancelSelectionAnchor);

// node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/browser/bracketMatching.js
init_async();
init_lifecycle();
init_editorExtensions();
init_position();
init_range();
init_selection();
init_editorContextKeys();
init_model();
init_textModel();
init_nls();
init_actions2();
init_colorRegistry();
init_themeService();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/browser/bracketMatching.css";
var overviewRulerBracketMatchForeground = registerColor("editorOverviewRuler.bracketMatchForeground", { dark: "#A0A0A0", light: "#A0A0A0", hcDark: "#A0A0A0", hcLight: "#A0A0A0" }, localize("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
var JumpToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.jumpToBracket",
      label: localize("smartSelect.jumpBracket", "Go to Bracket"),
      alias: "Go to Bracket",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 93,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    var _a;
    (_a = BracketMatchingController.get(editor2)) === null || _a === void 0 ? void 0 : _a.jumpToBracket();
  }
};
var SelectToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectToBracket",
      label: localize("smartSelect.selectToBracket", "Select to Bracket"),
      alias: "Select to Bracket",
      precondition: void 0,
      description: {
        description: `Select to Bracket`,
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "selectBrackets": {
                type: "boolean",
                default: true
              }
            }
          }
        }]
      }
    });
  }
  run(accessor, editor2, args) {
    var _a;
    let selectBrackets = true;
    if (args && args.selectBrackets === false) {
      selectBrackets = false;
    }
    (_a = BracketMatchingController.get(editor2)) === null || _a === void 0 ? void 0 : _a.selectToBracket(selectBrackets);
  }
};
var RemoveBracketsAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.removeBrackets",
      label: localize("smartSelect.removeBrackets", "Remove Brackets"),
      alias: "Remove Brackets",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 1,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    var _a;
    (_a = BracketMatchingController.get(editor2)) === null || _a === void 0 ? void 0 : _a.removeBrackets(this.id);
  }
};
var BracketsData = class {
  constructor(position, brackets, options) {
    this.position = position;
    this.brackets = brackets;
    this.options = options;
  }
};
var BracketMatchingController = class _BracketMatchingController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_BracketMatchingController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._lastBracketsData = [];
    this._lastVersionId = 0;
    this._decorations = this._editor.createDecorationsCollection();
    this._updateBracketsSoon = this._register(new RunOnceScheduler(() => this._updateBrackets(), 50));
    this._matchBrackets = this._editor.getOption(
      70
      /* EditorOption.matchBrackets */
    );
    this._updateBracketsSoon.schedule();
    this._register(editor2.onDidChangeCursorPosition((e) => {
      if (this._matchBrackets === "never") {
        return;
      }
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelLanguageConfiguration((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        70
        /* EditorOption.matchBrackets */
      )) {
        this._matchBrackets = this._editor.getOption(
          70
          /* EditorOption.matchBrackets */
        );
        this._decorations.clear();
        this._lastBracketsData = [];
        this._lastVersionId = 0;
        this._updateBracketsSoon.schedule();
      }
    }));
    this._register(editor2.onDidBlurEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidFocusEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
  }
  jumpToBracket() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = this._editor.getSelections().map((selection) => {
      const position = selection.getStartPosition();
      const brackets = model.bracketPairs.matchBracket(position);
      let newCursorPosition = null;
      if (brackets) {
        if (brackets[0].containsPosition(position) && !brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[1].getStartPosition();
        } else if (brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[0].getStartPosition();
        }
      } else {
        const enclosingBrackets = model.bracketPairs.findEnclosingBrackets(position);
        if (enclosingBrackets) {
          newCursorPosition = enclosingBrackets[1].getStartPosition();
        } else {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            newCursorPosition = nextBracket.range.getStartPosition();
          }
        }
      }
      if (newCursorPosition) {
        return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
      }
      return new Selection(position.lineNumber, position.column, position.lineNumber, position.column);
    });
    this._editor.setSelections(newSelections);
    this._editor.revealRange(newSelections[0]);
  }
  selectToBracket(selectBrackets) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = [];
    this._editor.getSelections().forEach((selection) => {
      const position = selection.getStartPosition();
      let brackets = model.bracketPairs.matchBracket(position);
      if (!brackets) {
        brackets = model.bracketPairs.findEnclosingBrackets(position);
        if (!brackets) {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            brackets = model.bracketPairs.matchBracket(nextBracket.range.getStartPosition());
          }
        }
      }
      let selectFrom = null;
      let selectTo = null;
      if (brackets) {
        brackets.sort(Range.compareRangesUsingStarts);
        const [open, close] = brackets;
        selectFrom = selectBrackets ? open.getStartPosition() : open.getEndPosition();
        selectTo = selectBrackets ? close.getEndPosition() : close.getStartPosition();
        if (close.containsPosition(position)) {
          const tmp = selectFrom;
          selectFrom = selectTo;
          selectTo = tmp;
        }
      }
      if (selectFrom && selectTo) {
        newSelections.push(new Selection(selectFrom.lineNumber, selectFrom.column, selectTo.lineNumber, selectTo.column));
      }
    });
    if (newSelections.length > 0) {
      this._editor.setSelections(newSelections);
      this._editor.revealRange(newSelections[0]);
    }
  }
  removeBrackets(editSource) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    this._editor.getSelections().forEach((selection) => {
      const position = selection.getPosition();
      let brackets = model.bracketPairs.matchBracket(position);
      if (!brackets) {
        brackets = model.bracketPairs.findEnclosingBrackets(position);
      }
      if (brackets) {
        this._editor.pushUndoStop();
        this._editor.executeEdits(editSource, [
          { range: brackets[0], text: "" },
          { range: brackets[1], text: "" }
        ]);
        this._editor.pushUndoStop();
      }
    });
  }
  _updateBrackets() {
    if (this._matchBrackets === "never") {
      return;
    }
    this._recomputeBrackets();
    const newDecorations = [];
    let newDecorationsLen = 0;
    for (const bracketData of this._lastBracketsData) {
      const brackets = bracketData.brackets;
      if (brackets) {
        newDecorations[newDecorationsLen++] = { range: brackets[0], options: bracketData.options };
        newDecorations[newDecorationsLen++] = { range: brackets[1], options: bracketData.options };
      }
    }
    this._decorations.set(newDecorations);
  }
  _recomputeBrackets() {
    if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const selections = this._editor.getSelections();
    if (selections.length > 100) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const model = this._editor.getModel();
    const versionId = model.getVersionId();
    let previousData = [];
    if (this._lastVersionId === versionId) {
      previousData = this._lastBracketsData;
    }
    const positions = [];
    let positionsLen = 0;
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (selection.isEmpty()) {
        positions[positionsLen++] = selection.getStartPosition();
      }
    }
    if (positions.length > 1) {
      positions.sort(Position.compare);
    }
    const newData = [];
    let newDataLen = 0;
    let previousIndex = 0;
    const previousLen = previousData.length;
    for (let i = 0, len = positions.length; i < len; i++) {
      const position = positions[i];
      while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
        previousIndex++;
      }
      if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
        newData[newDataLen++] = previousData[previousIndex];
      } else {
        let brackets = model.bracketPairs.matchBracket(
          position,
          20
          /* give at most 20ms to compute */
        );
        let options = _BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
        if (!brackets && this._matchBrackets === "always") {
          brackets = model.bracketPairs.findEnclosingBrackets(
            position,
            20
            /* give at most 20ms to compute */
          );
          options = _BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER;
        }
        newData[newDataLen++] = new BracketsData(position, brackets, options);
      }
    }
    this._lastBracketsData = newData;
    this._lastVersionId = versionId;
  }
};
BracketMatchingController.ID = "editor.contrib.bracketMatchingController";
BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-overview",
  stickiness: 1,
  className: "bracket-match",
  overviewRuler: {
    color: themeColorFromId(overviewRulerBracketMatchForeground),
    position: OverviewRulerLane.Center
  }
});
BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-no-overview",
  stickiness: 1,
  className: "bracket-match"
});
registerEditorContribution(
  BracketMatchingController.ID,
  BracketMatchingController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(SelectToBracketAction);
registerEditorAction(JumpToBracketAction);
registerEditorAction(RemoveBracketsAction);
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "editor.action.jumpToBracket",
    title: localize({ key: "miGoToBracket", comment: ["&& denotes a mnemonic"] }, "Go to &&Bracket")
  },
  order: 2
});

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/caretOperations.js
init_editorExtensions();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/moveCaretCommand.js
init_range();
init_selection();
var MoveCaretCommand = class {
  constructor(selection, isMovingLeft) {
    this._selection = selection;
    this._isMovingLeft = isMovingLeft;
  }
  getEditOperations(model, builder) {
    if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty()) {
      return;
    }
    const lineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    const endColumn = this._selection.endColumn;
    if (this._isMovingLeft && startColumn === 1) {
      return;
    }
    if (!this._isMovingLeft && endColumn === model.getLineMaxColumn(lineNumber)) {
      return;
    }
    if (this._isMovingLeft) {
      const rangeBefore = new Range(lineNumber, startColumn - 1, lineNumber, startColumn);
      const charBefore = model.getValueInRange(rangeBefore);
      builder.addEditOperation(rangeBefore, null);
      builder.addEditOperation(new Range(lineNumber, endColumn, lineNumber, endColumn), charBefore);
    } else {
      const rangeAfter = new Range(lineNumber, endColumn, lineNumber, endColumn + 1);
      const charAfter = model.getValueInRange(rangeAfter);
      builder.addEditOperation(rangeAfter, null);
      builder.addEditOperation(new Range(lineNumber, startColumn, lineNumber, startColumn), charAfter);
    }
  }
  computeCursorState(model, helper) {
    if (this._isMovingLeft) {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1);
    } else {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/caretOperations.js
init_nls();
var MoveCaretAction = class extends EditorAction {
  constructor(left, opts) {
    super(opts);
    this.left = left;
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      commands.push(new MoveCaretCommand(selection, this.left));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var MoveCaretLeftAction = class extends MoveCaretAction {
  constructor() {
    super(true, {
      id: "editor.action.moveCarretLeftAction",
      label: localize("caret.moveLeft", "Move Selected Text Left"),
      alias: "Move Selected Text Left",
      precondition: EditorContextKeys.writable
    });
  }
};
var MoveCaretRightAction = class extends MoveCaretAction {
  constructor() {
    super(false, {
      id: "editor.action.moveCarretRightAction",
      label: localize("caret.moveRight", "Move Selected Text Right"),
      alias: "Move Selected Text Right",
      precondition: EditorContextKeys.writable
    });
  }
};
registerEditorAction(MoveCaretLeftAction);
registerEditorAction(MoveCaretRightAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/transpose.js
init_editorExtensions();
init_range();
init_editorContextKeys();
init_nls();
var TransposeLettersAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transposeLetters",
      label: localize("transposeLetters.label", "Transpose Letters"),
      alias: "Transpose Letters",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 50
          /* KeyCode.KeyT */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      if (!selection.isEmpty()) {
        continue;
      }
      const lineNumber = selection.startLineNumber;
      const column = selection.startColumn;
      const lastColumn = model.getLineMaxColumn(lineNumber);
      if (lineNumber === 1 && (column === 1 || column === 2 && lastColumn === 2)) {
        continue;
      }
      const endPosition = column === lastColumn ? selection.getPosition() : MoveOperations.rightPosition(model, selection.getPosition().lineNumber, selection.getPosition().column);
      const middlePosition = MoveOperations.leftPosition(model, endPosition);
      const beginPosition = MoveOperations.leftPosition(model, middlePosition);
      const leftChar = model.getValueInRange(Range.fromPositions(beginPosition, middlePosition));
      const rightChar = model.getValueInRange(Range.fromPositions(middlePosition, endPosition));
      const replaceRange = Range.fromPositions(beginPosition, endPosition);
      commands.push(new ReplaceCommand(replaceRange, rightChar + leftChar));
    }
    if (commands.length > 0) {
      editor2.pushUndoStop();
      editor2.executeCommands(this.id, commands);
      editor2.pushUndoStop();
    }
  }
};
registerEditorAction(TransposeLettersAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/browser/clipboard.js
init_browser();
init_platform();
init_editorExtensions();
init_codeEditorService();
init_editorContextKeys();
init_nls();
init_actions2();
init_contextkey();
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CLIPBOARD_CONTEXT_MENU_GROUP = "9_cutcopypaste";
var supportsCut = isNative || document.queryCommandSupported("cut");
var supportsCopy = isNative || document.queryCommandSupported("copy");
var supportsPaste = typeof navigator.clipboard === "undefined" || isFirefox ? document.queryCommandSupported("paste") : true;
function registerCommand(command) {
  command.register();
  return command;
}
var CutAction = supportsCut ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCutAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind cut keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    isNative ? {
      primary: 2048 | 54,
      win: { primary: 2048 | 54, secondary: [
        1024 | 20
        /* KeyCode.Delete */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miCut", comment: ["&& denotes a mnemonic"] }, "Cu&&t"),
    order: 1
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.cutLabel", "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.cutLabel", "Cut"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.cutLabel", "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }]
})) : void 0;
var CopyAction = supportsCopy ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCopyAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind copy keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    isNative ? {
      primary: 2048 | 33,
      win: { primary: 2048 | 33, secondary: [
        2048 | 19
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miCopy", comment: ["&& denotes a mnemonic"] }, "&&Copy"),
    order: 2
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }]
})) : void 0;
MenuRegistry.appendMenuItem(MenuId.MenubarEditMenu, { submenu: MenuId.MenubarCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: "2_ccp", order: 3 });
MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: CLIPBOARD_CONTEXT_MENU_GROUP, order: 3 });
MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextShare, title: { value: localize("share", "Share"), original: "Share" }, group: "11_share", order: -1, when: ContextKeyExpr.and(ContextKeyExpr.notEquals("resourceScheme", "output"), EditorContextKeys.editorTextFocus) });
MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, { submenu: MenuId.EditorTitleContextShare, title: { value: localize("share", "Share"), original: "Share" }, group: "11_share", order: -1 });
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, { submenu: MenuId.ExplorerContextShare, title: { value: localize("share", "Share"), original: "Share" }, group: "11_share", order: -1 });
var PasteAction = supportsPaste ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardPasteAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind paste keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    isNative ? {
      primary: 2048 | 52,
      win: { primary: 2048 | 52, secondary: [
        1024 | 19
        /* KeyCode.Insert */
      ] },
      linux: { primary: 2048 | 52, secondary: [
        1024 | 19
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miPaste", comment: ["&& denotes a mnemonic"] }, "&&Paste"),
    order: 4
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }]
})) : void 0;
var ExecCommandCopyWithSyntaxHighlightingAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
      label: localize("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
      alias: "Copy With Syntax Highlighting",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const emptySelectionClipboard = editor2.getOption(
      36
      /* EditorOption.emptySelectionClipboard */
    );
    if (!emptySelectionClipboard && editor2.getSelection().isEmpty()) {
      return;
    }
    CopyOptions.forceCopyWithSyntaxHighlighting = true;
    editor2.focus();
    document.execCommand("copy");
    CopyOptions.forceCopyWithSyntaxHighlighting = false;
  }
};
function registerExecCommandImpl(target, browserCommand) {
  if (!target) {
    return;
  }
  target.addImplementation(1e4, "code-editor", (accessor, args) => {
    const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const emptySelectionClipboard = focusedEditor.getOption(
        36
        /* EditorOption.emptySelectionClipboard */
      );
      const selection = focusedEditor.getSelection();
      if (selection && selection.isEmpty() && !emptySelectionClipboard) {
        return true;
      }
      document.execCommand(browserCommand);
      return true;
    }
    return false;
  });
  target.addImplementation(0, "generic-dom", (accessor, args) => {
    document.execCommand(browserCommand);
    return true;
  });
}
registerExecCommandImpl(CutAction, "cut");
registerExecCommandImpl(CopyAction, "copy");
if (PasteAction) {
  PasteAction.addImplementation(1e4, "code-editor", (accessor, args) => {
    const codeEditorService = accessor.get(ICodeEditorService);
    const clipboardService = accessor.get(IClipboardService);
    const focusedEditor = codeEditorService.getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const result = document.execCommand("paste");
      if (!result && isWeb) {
        return (() => __awaiter2(void 0, void 0, void 0, function* () {
          const clipboardText = yield clipboardService.readText();
          if (clipboardText !== "") {
            const metadata = InMemoryClipboardMetadataManager.INSTANCE.get(clipboardText);
            let pasteOnNewLine = false;
            let multicursorText = null;
            let mode = null;
            if (metadata) {
              pasteOnNewLine = focusedEditor.getOption(
                36
                /* EditorOption.emptySelectionClipboard */
              ) && !!metadata.isFromEmptySelection;
              multicursorText = typeof metadata.multicursorText !== "undefined" ? metadata.multicursorText : null;
              mode = metadata.mode;
            }
            focusedEditor.trigger("keyboard", "paste", {
              text: clipboardText,
              pasteOnNewLine,
              multicursorText,
              mode
            });
          }
        }))();
      }
      return true;
    }
    return false;
  });
  PasteAction.addImplementation(0, "generic-dom", (accessor, args) => {
    document.execCommand("paste");
    return true;
  });
}
if (supportsCopy) {
  registerEditorAction(ExecCommandCopyWithSyntaxHighlightingAction);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionContributions.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionCommands.js
init_strings();
init_editorExtensions();
init_editorContextKeys();
init_nls();
init_contextkey();
function contextKeyForSupportedActions(kind) {
  return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp("(\\s|^)" + escapeRegExpCharacters(kind.value) + "\\b"));
}
var argsSchema = {
  type: "object",
  defaultSnippets: [{ body: { kind: "" } }],
  properties: {
    "kind": {
      type: "string",
      description: localize("args.schema.kind", "Kind of the code action to run.")
    },
    "apply": {
      type: "string",
      description: localize("args.schema.apply", "Controls when the returned actions are applied."),
      default: "ifSingle",
      enum: [
        "first",
        "ifSingle",
        "never"
        /* CodeActionAutoApply.Never */
      ],
      enumDescriptions: [
        localize("args.schema.apply.first", "Always apply the first returned code action."),
        localize("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
        localize("args.schema.apply.never", "Do not apply the returned code actions.")
      ]
    },
    "preferred": {
      type: "boolean",
      default: false,
      description: localize("args.schema.preferred", "Controls if only preferred code actions should be returned.")
    }
  }
};
function triggerCodeActionsForEditorSelection(editor2, notAvailableMessage, filter, autoApply, triggerAction = CodeActionTriggerSource.Default) {
  if (editor2.hasModel()) {
    const controller = CodeActionController.get(editor2);
    controller === null || controller === void 0 ? void 0 : controller.manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply);
  }
}
var QuickFixAction = class extends EditorAction {
  constructor() {
    super({
      id: quickFixCommandId,
      label: localize("quickfix.trigger.label", "Quick Fix..."),
      alias: "Quick Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 89,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0, CodeActionTriggerSource.QuickFix);
  }
};
var CodeActionCommand = class extends EditorCommand {
  constructor() {
    super({
      id: codeActionCommandId,
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      description: {
        description: "Trigger a code action",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  runEditorCommand(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Empty,
      apply: "ifSingle"
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", userArgs.kind) : localize("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : localize("editor.action.codeAction.noneMessage", "No code actions available"), {
      include: args.kind,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
};
var RefactorAction = class extends EditorAction {
  constructor() {
    super({
      id: refactorCommandId,
      label: localize("refactor.label", "Refactor..."),
      alias: "Refactor...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 48,
        mac: {
          primary: 256 | 1024 | 48
          /* KeyCode.KeyR */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 2,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Refactor))
      },
      description: {
        description: "Refactor...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Refactor,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", userArgs.kind) : localize("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : localize("editor.action.refactor.noneMessage", "No refactorings available"), {
      include: CodeActionKind.Refactor.contains(args.kind) ? args.kind : CodeActionKind.None,
      onlyIncludePreferredActions: args.preferred
    }, args.apply, CodeActionTriggerSource.Refactor);
  }
};
var SourceAction = class extends EditorAction {
  constructor() {
    super({
      id: sourceActionCommandId,
      label: localize("source.label", "Source Action..."),
      alias: "Source Action...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      contextMenuOpts: {
        group: "1_modification",
        order: 2.1,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Source))
      },
      description: {
        description: "Source Action...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Source,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", userArgs.kind) : localize("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.source.noneMessage.preferred", "No preferred source actions available") : localize("editor.action.source.noneMessage", "No source actions available"), {
      include: CodeActionKind.Source.contains(args.kind) ? args.kind : CodeActionKind.None,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply, CodeActionTriggerSource.SourceAction);
  }
};
var OrganizeImportsAction = class extends EditorAction {
  constructor() {
    super({
      id: organizeImportsCommandId,
      label: localize("organizeImports.label", "Organize Imports"),
      alias: "Organize Imports",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 1024 | 512 | 45,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.organize.noneMessage", "No organize imports action available"), { include: CodeActionKind.SourceOrganizeImports, includeSourceActions: true }, "ifSingle", CodeActionTriggerSource.OrganizeImports);
  }
};
var FixAllAction = class extends EditorAction {
  constructor() {
    super({
      id: fixAllCommandId,
      label: localize("fixAll.label", "Fix All"),
      alias: "Fix All",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("fixAll.noneMessage", "No fix all action available"), { include: CodeActionKind.SourceFixAll, includeSourceActions: true }, "ifSingle", CodeActionTriggerSource.FixAll);
  }
};
var AutoFixAction = class extends EditorAction {
  constructor() {
    super({
      id: autoFixCommandId,
      label: localize("autoFix.label", "Auto Fix..."),
      alias: "Auto Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 512 | 1024 | 89,
        mac: {
          primary: 2048 | 512 | 89
          /* KeyCode.Period */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.autoFix.noneMessage", "No auto fixes available"), {
      include: CodeActionKind.QuickFix,
      onlyIncludePreferredActions: true
    }, "ifSingle", CodeActionTriggerSource.AutoFix);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionContributions.js
init_nls();
init_configurationRegistry();
init_platform2();
registerEditorContribution(
  CodeActionController.ID,
  CodeActionController,
  3
  /* EditorContributionInstantiation.Eventually */
);
registerEditorContribution(
  LightBulbWidget.ID,
  LightBulbWidget,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(QuickFixAction);
registerEditorAction(RefactorAction);
registerEditorAction(SourceAction);
registerEditorAction(OrganizeImportsAction);
registerEditorAction(AutoFixAction);
registerEditorAction(FixAllAction);
registerEditorCommand(new CodeActionCommand());
Registry.as(Extensions.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {
  "editor.codeActionWidget.showHeaders": {
    type: "boolean",
    scope: 5,
    description: localize("showCodeActionHeaders", "Enable/disable showing group headers in the Code Action menu."),
    default: true
  }
} }));

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensController.js
init_async();
init_errors();
init_lifecycle();
init_stableEditorScroll();
init_editorExtensions();
init_editorOptions();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelens.js
init_cancellation();
init_errors();
init_lifecycle();
init_types();
init_uri();
init_model2();
init_commands();
init_languageFeatures();
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeLensModel = class {
  constructor() {
    this.lenses = [];
    this._disposables = new DisposableStore();
  }
  dispose() {
    this._disposables.dispose();
  }
  get isDisposed() {
    return this._disposables.isDisposed;
  }
  add(list, provider) {
    this._disposables.add(list);
    for (const symbol of list.lenses) {
      this.lenses.push({ symbol, provider });
    }
  }
};
function getCodeLensModel(registry, model, token) {
  return __awaiter3(this, void 0, void 0, function* () {
    const provider = registry.ordered(model);
    const providerRanks = /* @__PURE__ */ new Map();
    const result = new CodeLensModel();
    const promises = provider.map((provider2, i) => __awaiter3(this, void 0, void 0, function* () {
      providerRanks.set(provider2, i);
      try {
        const list = yield Promise.resolve(provider2.provideCodeLenses(model, token));
        if (list) {
          result.add(list, provider2);
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }));
    yield Promise.all(promises);
    result.lenses = result.lenses.sort((a, b) => {
      if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
        return -1;
      } else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
        return 1;
      } else if (providerRanks.get(a.provider) < providerRanks.get(b.provider)) {
        return -1;
      } else if (providerRanks.get(a.provider) > providerRanks.get(b.provider)) {
        return 1;
      } else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
        return -1;
      } else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
        return 1;
      } else {
        return 0;
      }
    });
    return result;
  });
}
CommandsRegistry.registerCommand("_executeCodeLensProvider", function(accessor, ...args) {
  let [uri, itemResolveCount] = args;
  assertType(URI.isUri(uri));
  assertType(typeof itemResolveCount === "number" || !itemResolveCount);
  const { codeLensProvider } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    throw illegalArgument();
  }
  const result = [];
  const disposables = new DisposableStore();
  return getCodeLensModel(codeLensProvider, model, CancellationToken.None).then((value) => {
    disposables.add(value);
    const resolve = [];
    for (const item of value.lenses) {
      if (itemResolveCount === void 0 || itemResolveCount === null || Boolean(item.symbol.command)) {
        result.push(item.symbol);
      } else if (itemResolveCount-- > 0 && item.provider.resolveCodeLens) {
        resolve.push(Promise.resolve(item.provider.resolveCodeLens(model, item.symbol, CancellationToken.None)).then((symbol) => result.push(symbol || item.symbol)));
      }
    }
    return Promise.all(resolve);
  }).then(() => {
    return result;
  }).finally(() => {
    setTimeout(() => disposables.dispose(), 100);
  });
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codeLensCache.js
init_async();
init_functional();
init_map();
init_range();
init_extensions();
init_instantiation();
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ICodeLensCache = createDecorator("ICodeLensCache");
var CacheItem = class {
  constructor(lineCount, data) {
    this.lineCount = lineCount;
    this.data = data;
  }
};
var CodeLensCache = class CodeLensCache2 {
  constructor(storageService) {
    this._fakeProvider = new class {
      provideCodeLenses() {
        throw new Error("not supported");
      }
    }();
    this._cache = new LRUCache(20, 0.75);
    const oldkey = "codelens/cache";
    runWhenIdle(() => storageService.remove(
      oldkey,
      1
      /* StorageScope.WORKSPACE */
    ));
    const key = "codelens/cache2";
    const raw = storageService.get(key, 1, "{}");
    this._deserialize(raw);
    once(storageService.onWillSaveState)((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        storageService.store(
          key,
          this._serialize(),
          1,
          1
          /* StorageTarget.MACHINE */
        );
      }
    });
  }
  put(model, data) {
    const copyItems = data.lenses.map((item2) => {
      var _a;
      return {
        range: item2.symbol.range,
        command: item2.symbol.command && { id: "", title: (_a = item2.symbol.command) === null || _a === void 0 ? void 0 : _a.title }
      };
    });
    const copyModel = new CodeLensModel();
    copyModel.add({ lenses: copyItems, dispose: () => {
    } }, this._fakeProvider);
    const item = new CacheItem(model.getLineCount(), copyModel);
    this._cache.set(model.uri.toString(), item);
  }
  get(model) {
    const item = this._cache.get(model.uri.toString());
    return item && item.lineCount === model.getLineCount() ? item.data : void 0;
  }
  delete(model) {
    this._cache.delete(model.uri.toString());
  }
  // --- persistence
  _serialize() {
    const data = /* @__PURE__ */ Object.create(null);
    for (const [key, value] of this._cache) {
      const lines = /* @__PURE__ */ new Set();
      for (const d of value.data.lenses) {
        lines.add(d.symbol.range.startLineNumber);
      }
      data[key] = {
        lineCount: value.lineCount,
        lines: [...lines.values()]
      };
    }
    return JSON.stringify(data);
  }
  _deserialize(raw) {
    try {
      const data = JSON.parse(raw);
      for (const key in data) {
        const element = data[key];
        const lenses = [];
        for (const line of element.lines) {
          lenses.push({ range: new Range(line, 1, line, 11) });
        }
        const model = new CodeLensModel();
        model.add({ lenses, dispose() {
        } }, this._fakeProvider);
        this._cache.set(key, new CacheItem(element.lineCount, model));
      }
    } catch (_a) {
    }
  }
};
CodeLensCache = __decorate2([
  __param2(0, IStorageService)
], CodeLensCache);
registerSingleton(
  ICodeLensCache,
  CodeLensCache,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensWidget.js
init_dom();
init_range();
init_textModel();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensWidget.css";
var CodeLensViewZone = class {
  constructor(afterLineNumber, heightInPx, onHeight) {
    this.afterColumn = 1073741824;
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = heightInPx;
    this._onHeight = onHeight;
    this.suppressMouseDown = true;
    this.domNode = document.createElement("div");
  }
  onComputedHeight(height) {
    if (this._lastHeight === void 0) {
      this._lastHeight = height;
    } else if (this._lastHeight !== height) {
      this._lastHeight = height;
      this._onHeight();
    }
  }
  isVisible() {
    return this._lastHeight !== 0 && this.domNode.hasAttribute("monaco-visible-view-zone");
  }
};
var CodeLensContentWidget = class _CodeLensContentWidget {
  constructor(editor2, line) {
    this.allowEditorOverflow = false;
    this.suppressMouseDown = true;
    this._commands = /* @__PURE__ */ new Map();
    this._isEmpty = true;
    this._editor = editor2;
    this._id = `codelens.widget-${_CodeLensContentWidget._idPool++}`;
    this.updatePosition(line);
    this._domNode = document.createElement("span");
    this._domNode.className = `codelens-decoration`;
  }
  withCommands(lenses, animate) {
    this._commands.clear();
    const children = [];
    let hasSymbol = false;
    for (let i = 0; i < lenses.length; i++) {
      const lens = lenses[i];
      if (!lens) {
        continue;
      }
      hasSymbol = true;
      if (lens.command) {
        const title = renderLabelWithIcons(lens.command.title.trim());
        if (lens.command.id) {
          children.push($("a", { id: String(i), title: lens.command.tooltip, role: "button" }, ...title));
          this._commands.set(String(i), lens.command);
        } else {
          children.push($("span", { title: lens.command.tooltip }, ...title));
        }
        if (i + 1 < lenses.length) {
          children.push($("span", void 0, "|"));
        }
      }
    }
    if (!hasSymbol) {
      reset(this._domNode, $("span", void 0, "no commands"));
    } else {
      reset(this._domNode, ...children);
      if (this._isEmpty && animate) {
        this._domNode.classList.add("fadein");
      }
      this._isEmpty = false;
    }
  }
  getCommand(link) {
    return link.parentElement === this._domNode ? this._commands.get(link.id) : void 0;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  updatePosition(line) {
    const column = this._editor.getModel().getLineFirstNonWhitespaceColumn(line);
    this._widgetPosition = {
      position: { lineNumber: line, column },
      preference: [
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  getPosition() {
    return this._widgetPosition || null;
  }
};
CodeLensContentWidget._idPool = 0;
var CodeLensHelper = class {
  constructor() {
    this._removeDecorations = [];
    this._addDecorations = [];
    this._addDecorationsCallbacks = [];
  }
  addDecoration(decoration2, callback) {
    this._addDecorations.push(decoration2);
    this._addDecorationsCallbacks.push(callback);
  }
  removeDecoration(decorationId) {
    this._removeDecorations.push(decorationId);
  }
  commit(changeAccessor) {
    const resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
    for (let i = 0, len = resultingDecorations.length; i < len; i++) {
      this._addDecorationsCallbacks[i](resultingDecorations[i]);
    }
  }
};
var codeLensDecorationOptions = ModelDecorationOptions.register({
  collapseOnReplaceEdit: true,
  description: "codelens"
});
var CodeLensWidget = class {
  constructor(data, editor2, helper, viewZoneChangeAccessor, heightInPx, updateCallback) {
    this._isDisposed = false;
    this._editor = editor2;
    this._data = data;
    this._decorationIds = [];
    let range;
    const lenses = [];
    this._data.forEach((codeLensData, i) => {
      if (codeLensData.symbol.command) {
        lenses.push(codeLensData.symbol);
      }
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: codeLensDecorationOptions
      }, (id) => this._decorationIds[i] = id);
      if (!range) {
        range = Range.lift(codeLensData.symbol.range);
      } else {
        range = Range.plusRange(range, codeLensData.symbol.range);
      }
    });
    this._viewZone = new CodeLensViewZone(range.startLineNumber - 1, heightInPx, updateCallback);
    this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
    if (lenses.length > 0) {
      this._createContentWidgetIfNecessary();
      this._contentWidget.withCommands(lenses, false);
    }
  }
  _createContentWidgetIfNecessary() {
    if (!this._contentWidget) {
      this._contentWidget = new CodeLensContentWidget(this._editor, this._viewZone.afterLineNumber + 1);
      this._editor.addContentWidget(this._contentWidget);
    } else {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  dispose(helper, viewZoneChangeAccessor) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    viewZoneChangeAccessor === null || viewZoneChangeAccessor === void 0 ? void 0 : viewZoneChangeAccessor.removeZone(this._viewZoneId);
    if (this._contentWidget) {
      this._editor.removeContentWidget(this._contentWidget);
      this._contentWidget = void 0;
    }
    this._isDisposed = true;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isValid() {
    return this._decorationIds.some((id, i) => {
      const range = this._editor.getModel().getDecorationRange(id);
      const symbol = this._data[i].symbol;
      return !!(range && Range.isEmpty(symbol.range) === range.isEmpty());
    });
  }
  updateCodeLensSymbols(data, helper) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    this._data = data;
    this._data.forEach((codeLensData, i) => {
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: codeLensDecorationOptions
      }, (id) => this._decorationIds[i] = id);
    });
  }
  updateHeight(height, viewZoneChangeAccessor) {
    this._viewZone.heightInPx = height;
    viewZoneChangeAccessor.layoutZone(this._viewZoneId);
    if (this._contentWidget) {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  computeIfNecessary(model) {
    if (!this._viewZone.isVisible()) {
      return null;
    }
    for (let i = 0; i < this._decorationIds.length; i++) {
      const range = model.getDecorationRange(this._decorationIds[i]);
      if (range) {
        this._data[i].symbol.range = range;
      }
    }
    return this._data;
  }
  updateCommands(symbols) {
    this._createContentWidgetIfNecessary();
    this._contentWidget.withCommands(symbols, true);
    for (let i = 0; i < this._data.length; i++) {
      const resolved = symbols[i];
      if (resolved) {
        const { symbol } = this._data[i];
        symbol.command = resolved.command || symbol.command;
      }
    }
  }
  getCommand(link) {
    var _a;
    return (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.getCommand(link);
  }
  getLineNumber() {
    const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
    if (range) {
      return range.startLineNumber;
    }
    return -1;
  }
  update(viewZoneChangeAccessor) {
    if (this.isValid()) {
      const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
      if (range) {
        this._viewZone.afterLineNumber = range.startLineNumber - 1;
        viewZoneChangeAccessor.layoutZone(this._viewZoneId);
        if (this._contentWidget) {
          this._contentWidget.updatePosition(range.startLineNumber);
          this._editor.layoutContentWidget(this._contentWidget);
        }
      }
    }
  }
  getItems() {
    return this._data;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensController.js
init_nls();
init_commands();
init_languageFeatureDebounce();
init_languageFeatures();
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeLensContribution = class CodeLensContribution2 {
  constructor(_editor, _languageFeaturesService, debounceService, _commandService, _notificationService, _codeLensCache) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._commandService = _commandService;
    this._notificationService = _notificationService;
    this._codeLensCache = _codeLensCache;
    this._disposables = new DisposableStore();
    this._localToDispose = new DisposableStore();
    this._lenses = [];
    this._oldCodeLensModels = new DisposableStore();
    this._provideCodeLensDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensProvide", { min: 250 });
    this._resolveCodeLensesDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensResolve", { min: 250, salt: "resolve" });
    this._resolveCodeLensesScheduler = new RunOnceScheduler(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDebounce.default());
    this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        49
        /* EditorOption.fontInfo */
      ) || e.hasChanged(
        18
        /* EditorOption.codeLensFontSize */
      ) || e.hasChanged(
        17
        /* EditorOption.codeLensFontFamily */
      )) {
        this._updateLensStyle();
      }
      if (e.hasChanged(
        16
        /* EditorOption.codeLens */
      )) {
        this._onModelChange();
      }
    }));
    this._disposables.add(_languageFeaturesService.codeLensProvider.onDidChange(this._onModelChange, this));
    this._onModelChange();
    this._updateLensStyle();
  }
  dispose() {
    var _a;
    this._localDispose();
    this._disposables.dispose();
    this._oldCodeLensModels.dispose();
    (_a = this._currentCodeLensModel) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  _getLayoutInfo() {
    const lineHeightFactor = Math.max(1.3, this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    ) / this._editor.getOption(
      51
      /* EditorOption.fontSize */
    ));
    let fontSize = this._editor.getOption(
      18
      /* EditorOption.codeLensFontSize */
    );
    if (!fontSize || fontSize < 5) {
      fontSize = this._editor.getOption(
        51
        /* EditorOption.fontSize */
      ) * 0.9 | 0;
    }
    return {
      fontSize,
      codeLensHeight: fontSize * lineHeightFactor | 0
    };
  }
  _updateLensStyle() {
    const { codeLensHeight, fontSize } = this._getLayoutInfo();
    const fontFamily = this._editor.getOption(
      17
      /* EditorOption.codeLensFontFamily */
    );
    const editorFontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    const { style } = this._editor.getContainerDomNode();
    style.setProperty("--vscode-editorCodeLens-lineHeight", `${codeLensHeight}px`);
    style.setProperty("--vscode-editorCodeLens-fontSize", `${fontSize}px`);
    style.setProperty("--vscode-editorCodeLens-fontFeatureSettings", editorFontInfo.fontFeatureSettings);
    if (fontFamily) {
      style.setProperty("--vscode-editorCodeLens-fontFamily", fontFamily);
      style.setProperty("--vscode-editorCodeLens-fontFamilyDefault", EDITOR_FONT_DEFAULTS.fontFamily);
    }
    this._editor.changeViewZones((accessor) => {
      for (const lens of this._lenses) {
        lens.updateHeight(codeLensHeight, accessor);
      }
    });
  }
  _localDispose() {
    var _a, _b, _c;
    (_a = this._getCodeLensModelPromise) === null || _a === void 0 ? void 0 : _a.cancel();
    this._getCodeLensModelPromise = void 0;
    (_b = this._resolveCodeLensesPromise) === null || _b === void 0 ? void 0 : _b.cancel();
    this._resolveCodeLensesPromise = void 0;
    this._localToDispose.clear();
    this._oldCodeLensModels.clear();
    (_c = this._currentCodeLensModel) === null || _c === void 0 ? void 0 : _c.dispose();
  }
  _onModelChange() {
    this._localDispose();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (!this._editor.getOption(
      16
      /* EditorOption.codeLens */
    )) {
      return;
    }
    const cachedLenses = this._codeLensCache.get(model);
    if (cachedLenses) {
      this._renderCodeLensSymbols(cachedLenses);
    }
    if (!this._languageFeaturesService.codeLensProvider.has(model)) {
      if (cachedLenses) {
        this._localToDispose.add(disposableTimeout(() => {
          const cachedLensesNow = this._codeLensCache.get(model);
          if (cachedLenses === cachedLensesNow) {
            this._codeLensCache.delete(model);
            this._onModelChange();
          }
        }, 30 * 1e3));
      }
      return;
    }
    for (const provider of this._languageFeaturesService.codeLensProvider.all(model)) {
      if (typeof provider.onDidChange === "function") {
        const registration = provider.onDidChange(() => scheduler.schedule());
        this._localToDispose.add(registration);
      }
    }
    const scheduler = new RunOnceScheduler(() => {
      var _a;
      const t1 = Date.now();
      (_a = this._getCodeLensModelPromise) === null || _a === void 0 ? void 0 : _a.cancel();
      this._getCodeLensModelPromise = createCancelablePromise((token) => getCodeLensModel(this._languageFeaturesService.codeLensProvider, model, token));
      this._getCodeLensModelPromise.then((result) => {
        if (this._currentCodeLensModel) {
          this._oldCodeLensModels.add(this._currentCodeLensModel);
        }
        this._currentCodeLensModel = result;
        this._codeLensCache.put(model, result);
        const newDelay = this._provideCodeLensDebounce.update(model, Date.now() - t1);
        scheduler.delay = newDelay;
        this._renderCodeLensSymbols(result);
        this._resolveCodeLensesInViewportSoon();
      }, onUnexpectedError);
    }, this._provideCodeLensDebounce.get(model));
    this._localToDispose.add(scheduler);
    this._localToDispose.add(toDisposable(() => this._resolveCodeLensesScheduler.cancel()));
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      var _a;
      this._editor.changeDecorations((decorationsAccessor) => {
        this._editor.changeViewZones((viewZonesAccessor) => {
          const toDispose = [];
          let lastLensLineNumber = -1;
          this._lenses.forEach((lens) => {
            if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {
              toDispose.push(lens);
            } else {
              lens.update(viewZonesAccessor);
              lastLensLineNumber = lens.getLineNumber();
            }
          });
          const helper = new CodeLensHelper();
          toDispose.forEach((l) => {
            l.dispose(helper, viewZonesAccessor);
            this._lenses.splice(this._lenses.indexOf(l), 1);
          });
          helper.commit(decorationsAccessor);
        });
      });
      scheduler.schedule();
      this._resolveCodeLensesScheduler.cancel();
      (_a = this._resolveCodeLensesPromise) === null || _a === void 0 ? void 0 : _a.cancel();
      this._resolveCodeLensesPromise = void 0;
    }));
    this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {
      scheduler.schedule();
    }));
    this._localToDispose.add(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged && this._lenses.length > 0) {
        this._resolveCodeLensesInViewportSoon();
      }
    }));
    this._localToDispose.add(this._editor.onDidLayoutChange(() => {
      this._resolveCodeLensesInViewportSoon();
    }));
    this._localToDispose.add(toDisposable(() => {
      if (this._editor.getModel()) {
        const scrollState = StableEditorScrollState.capture(this._editor);
        this._editor.changeDecorations((decorationsAccessor) => {
          this._editor.changeViewZones((viewZonesAccessor) => {
            this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);
          });
        });
        scrollState.restore(this._editor);
      } else {
        this._disposeAllLenses(void 0, void 0);
      }
    }));
    this._localToDispose.add(this._editor.onMouseDown((e) => {
      if (e.target.type !== 9) {
        return;
      }
      let target = e.target.element;
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "SPAN") {
        target = target.parentElement;
      }
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "A") {
        for (const lens of this._lenses) {
          const command = lens.getCommand(target);
          if (command) {
            this._commandService.executeCommand(command.id, ...command.arguments || []).catch((err) => this._notificationService.error(err));
            break;
          }
        }
      }
    }));
    scheduler.schedule();
  }
  _disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {
    const helper = new CodeLensHelper();
    for (const lens of this._lenses) {
      lens.dispose(helper, viewZoneChangeAccessor);
    }
    if (decChangeAccessor) {
      helper.commit(decChangeAccessor);
    }
    this._lenses.length = 0;
  }
  _renderCodeLensSymbols(symbols) {
    if (!this._editor.hasModel()) {
      return;
    }
    const maxLineNumber = this._editor.getModel().getLineCount();
    const groups = [];
    let lastGroup;
    for (const symbol of symbols.lenses) {
      const line = symbol.symbol.range.startLineNumber;
      if (line < 1 || line > maxLineNumber) {
        continue;
      } else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
        lastGroup.push(symbol);
      } else {
        lastGroup = [symbol];
        groups.push(lastGroup);
      }
    }
    if (!groups.length && !this._lenses.length) {
      return;
    }
    const scrollState = StableEditorScrollState.capture(this._editor);
    const layoutInfo = this._getLayoutInfo();
    this._editor.changeDecorations((decorationsAccessor) => {
      this._editor.changeViewZones((viewZoneAccessor) => {
        const helper = new CodeLensHelper();
        let codeLensIndex = 0;
        let groupsIndex = 0;
        while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {
          const symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
          const codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();
          if (codeLensLineNumber < symbolsLineNumber) {
            this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
            this._lenses.splice(codeLensIndex, 1);
          } else if (codeLensLineNumber === symbolsLineNumber) {
            this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
            groupsIndex++;
            codeLensIndex++;
          } else {
            this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], this._editor, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
            codeLensIndex++;
            groupsIndex++;
          }
        }
        while (codeLensIndex < this._lenses.length) {
          this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
          this._lenses.splice(codeLensIndex, 1);
        }
        while (groupsIndex < groups.length) {
          this._lenses.push(new CodeLensWidget(groups[groupsIndex], this._editor, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
          groupsIndex++;
        }
        helper.commit(decorationsAccessor);
      });
    });
    scrollState.restore(this._editor);
  }
  _resolveCodeLensesInViewportSoon() {
    const model = this._editor.getModel();
    if (model) {
      this._resolveCodeLensesScheduler.schedule();
    }
  }
  _resolveCodeLensesInViewport() {
    var _a;
    (_a = this._resolveCodeLensesPromise) === null || _a === void 0 ? void 0 : _a.cancel();
    this._resolveCodeLensesPromise = void 0;
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    const toResolve = [];
    const lenses = [];
    this._lenses.forEach((lens) => {
      const request = lens.computeIfNecessary(model);
      if (request) {
        toResolve.push(request);
        lenses.push(lens);
      }
    });
    if (toResolve.length === 0) {
      return;
    }
    const t1 = Date.now();
    const resolvePromise = createCancelablePromise((token) => {
      const promises = toResolve.map((request, i) => {
        const resolvedSymbols = new Array(request.length);
        const promises2 = request.map((request2, i2) => {
          if (!request2.symbol.command && typeof request2.provider.resolveCodeLens === "function") {
            return Promise.resolve(request2.provider.resolveCodeLens(model, request2.symbol, token)).then((symbol) => {
              resolvedSymbols[i2] = symbol;
            }, onUnexpectedExternalError);
          } else {
            resolvedSymbols[i2] = request2.symbol;
            return Promise.resolve(void 0);
          }
        });
        return Promise.all(promises2).then(() => {
          if (!token.isCancellationRequested && !lenses[i].isDisposed()) {
            lenses[i].updateCommands(resolvedSymbols);
          }
        });
      });
      return Promise.all(promises);
    });
    this._resolveCodeLensesPromise = resolvePromise;
    this._resolveCodeLensesPromise.then(() => {
      const newDelay = this._resolveCodeLensesDebounce.update(model, Date.now() - t1);
      this._resolveCodeLensesScheduler.delay = newDelay;
      if (this._currentCodeLensModel) {
        this._codeLensCache.put(model, this._currentCodeLensModel);
      }
      this._oldCodeLensModels.clear();
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    }, (err) => {
      onUnexpectedError(err);
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    });
  }
  getModel() {
    return this._currentCodeLensModel;
  }
};
CodeLensContribution.ID = "css.editor.codeLens";
CodeLensContribution = __decorate3([
  __param3(1, ILanguageFeaturesService),
  __param3(2, ILanguageFeatureDebounceService),
  __param3(3, ICommandService),
  __param3(4, INotificationService),
  __param3(5, ICodeLensCache)
], CodeLensContribution);
registerEditorContribution(
  CodeLensContribution.ID,
  CodeLensContribution,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(class ShowLensesInCurrentLine extends EditorAction {
  constructor() {
    super({
      id: "codelens.showLensesInCurrentLine",
      precondition: EditorContextKeys.hasCodeLensProvider,
      label: localize("showLensOnLine", "Show CodeLens Commands For Current Line"),
      alias: "Show CodeLens Commands For Current Line"
    });
  }
  run(accessor, editor2) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!editor2.hasModel()) {
        return;
      }
      const quickInputService = accessor.get(IQuickInputService);
      const commandService = accessor.get(ICommandService);
      const notificationService = accessor.get(INotificationService);
      const lineNumber = editor2.getSelection().positionLineNumber;
      const codelensController = editor2.getContribution(CodeLensContribution.ID);
      if (!codelensController) {
        return;
      }
      const model = codelensController.getModel();
      if (!model) {
        return;
      }
      const items = [];
      for (const lens of model.lenses) {
        if (lens.symbol.command && lens.symbol.range.startLineNumber === lineNumber) {
          items.push({
            label: lens.symbol.command.title,
            command: lens.symbol.command
          });
        }
      }
      if (items.length === 0) {
        return;
      }
      const item = yield quickInputService.pick(items, { canPickMany: false });
      if (!item) {
        return;
      }
      if (model.isDisposed) {
        return yield commandService.executeCommand(this.id);
      }
      try {
        yield commandService.executeCommand(item.command.id, ...item.command.arguments || []);
      } catch (err) {
        notificationService.error(err);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorContributions.js
init_lifecycle();
init_editorExtensions();
init_range();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorDetector.js
init_async();
init_color();
init_errors();
init_event();
init_lifecycle();
init_stopwatch();
init_strings();
init_editorExtensions();
init_range();
init_textModel();
init_languageFeatureDebounce();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/color.js
init_cancellation();
init_errors();
init_uri();
init_range();
init_model2();
init_commands();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/defaultDocumentColorProvider.js
init_color();
init_model2();
init_languageConfigurationRegistry();
init_lifecycle();
init_languageFeatures();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DefaultDocumentColorProvider = class {
  constructor(modelService, languageConfigurationService) {
    this._editorWorkerClient = new EditorWorkerClient(modelService, false, "editorWorkerService", languageConfigurationService);
  }
  provideDocumentColors(model, _token) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._editorWorkerClient.computeDefaultDocumentColors(model.uri);
    });
  }
  provideColorPresentations(_model, colorInfo, _token) {
    const range = colorInfo.range;
    const colorFromInfo = colorInfo.color;
    const alpha = colorFromInfo.alpha;
    const color = new Color(new RGBA(Math.round(255 * colorFromInfo.red), Math.round(255 * colorFromInfo.green), Math.round(255 * colorFromInfo.blue), alpha));
    const rgb = alpha ? Color.Format.CSS.formatRGB(color) : Color.Format.CSS.formatRGBA(color);
    const hsl = alpha ? Color.Format.CSS.formatHSL(color) : Color.Format.CSS.formatHSLA(color);
    const hex = alpha ? Color.Format.CSS.formatHex(color) : Color.Format.CSS.formatHexA(color);
    const colorPresentations = [];
    colorPresentations.push({ label: rgb, textEdit: { range, text: rgb } });
    colorPresentations.push({ label: hsl, textEdit: { range, text: hsl } });
    colorPresentations.push({ label: hex, textEdit: { range, text: hex } });
    return colorPresentations;
  }
};
var DefaultDocumentColorProviderFeature = class DefaultDocumentColorProviderFeature2 extends Disposable {
  constructor(_modelService, _languageConfigurationService, _languageFeaturesService) {
    super();
    this._register(_languageFeaturesService.colorProvider.register("*", new DefaultDocumentColorProvider(_modelService, _languageConfigurationService)));
  }
};
DefaultDocumentColorProviderFeature = __decorate4([
  __param4(0, IModelService),
  __param4(1, ILanguageConfigurationService),
  __param4(2, ILanguageFeaturesService)
], DefaultDocumentColorProviderFeature);
registerEditorFeature(DefaultDocumentColorProviderFeature);

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/color.js
init_configuration();
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getColors(colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled = true) {
  return __awaiter6(this, void 0, void 0, function* () {
    return _findColorData(new ColorDataCollector(), colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled);
  });
}
function getColorPresentations(model, colorInfo, provider, token) {
  return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
}
var ColorDataCollector = class {
  constructor() {
  }
  compute(provider, model, token, colors) {
    return __awaiter6(this, void 0, void 0, function* () {
      const documentColors = yield provider.provideDocumentColors(model, token);
      if (Array.isArray(documentColors)) {
        for (const colorInfo of documentColors) {
          colors.push({ colorInfo, provider });
        }
      }
      return Array.isArray(documentColors);
    });
  }
};
var ExtColorDataCollector = class {
  constructor() {
  }
  compute(provider, model, token, colors) {
    return __awaiter6(this, void 0, void 0, function* () {
      const documentColors = yield provider.provideDocumentColors(model, token);
      if (Array.isArray(documentColors)) {
        for (const colorInfo of documentColors) {
          colors.push({ range: colorInfo.range, color: [colorInfo.color.red, colorInfo.color.green, colorInfo.color.blue, colorInfo.color.alpha] });
        }
      }
      return Array.isArray(documentColors);
    });
  }
};
var ColorPresentationsCollector = class {
  constructor(colorInfo) {
    this.colorInfo = colorInfo;
  }
  compute(provider, model, _token, colors) {
    return __awaiter6(this, void 0, void 0, function* () {
      const documentColors = yield provider.provideColorPresentations(model, this.colorInfo, CancellationToken.None);
      if (Array.isArray(documentColors)) {
        colors.push(...documentColors);
      }
      return Array.isArray(documentColors);
    });
  }
};
function _findColorData(collector, colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled) {
  return __awaiter6(this, void 0, void 0, function* () {
    let validDocumentColorProviderFound = false;
    let defaultProvider;
    const colorData = [];
    const documentColorProviders = colorProviderRegistry.ordered(model);
    for (let i = documentColorProviders.length - 1; i >= 0; i--) {
      const provider = documentColorProviders[i];
      if (provider instanceof DefaultDocumentColorProvider) {
        defaultProvider = provider;
      } else {
        try {
          if (yield collector.compute(provider, model, token, colorData)) {
            validDocumentColorProviderFound = true;
          }
        } catch (e) {
          onUnexpectedExternalError(e);
        }
      }
    }
    if (validDocumentColorProviderFound) {
      return colorData;
    }
    if (defaultProvider && isDefaultColorDecoratorsEnabled) {
      yield collector.compute(defaultProvider, model, token, colorData);
      return colorData;
    }
    return [];
  });
}
function _setupColorCommand(accessor, resource) {
  const { colorProvider: colorProviderRegistry } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const isDefaultColorDecoratorsEnabled = accessor.get(IConfigurationService).getValue("editor.defaultColorDecorators", { resource });
  return { model, colorProviderRegistry, isDefaultColorDecoratorsEnabled };
}
CommandsRegistry.registerCommand("_executeDocumentColorProvider", function(accessor, ...args) {
  const [resource] = args;
  if (!(resource instanceof URI)) {
    throw illegalArgument();
  }
  const { model, colorProviderRegistry, isDefaultColorDecoratorsEnabled } = _setupColorCommand(accessor, resource);
  return _findColorData(new ExtColorDataCollector(), colorProviderRegistry, model, CancellationToken.None, isDefaultColorDecoratorsEnabled);
});
CommandsRegistry.registerCommand("_executeColorPresentationProvider", function(accessor, ...args) {
  const [color, context] = args;
  const { uri, range } = context;
  if (!(uri instanceof URI) || !Array.isArray(color) || color.length !== 4 || !Range.isIRange(range)) {
    throw illegalArgument();
  }
  const { model, colorProviderRegistry, isDefaultColorDecoratorsEnabled } = _setupColorCommand(accessor, uri);
  const [red, green, blue, alpha] = color;
  return _findColorData(new ColorPresentationsCollector({ range, color: { red, green, blue, alpha } }), colorProviderRegistry, model, CancellationToken.None, isDefaultColorDecoratorsEnabled);
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorDetector.js
init_configuration();
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ColorDetector_1;
var ColorDecorationInjectedTextMarker = /* @__PURE__ */ Object.create({});
var ColorDetector = ColorDetector_1 = class ColorDetector2 extends Disposable {
  constructor(_editor, _configurationService, _languageFeaturesService, languageFeatureDebounceService) {
    super();
    this._editor = _editor;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._localToDispose = this._register(new DisposableStore());
    this._decorationsIds = [];
    this._colorDatas = /* @__PURE__ */ new Map();
    this._colorDecoratorIds = this._editor.createDecorationsCollection();
    this._ruleFactory = new DynamicCssRules(this._editor);
    this._decoratorLimitReporter = new DecoratorLimitReporter();
    this._colorDecorationClassRefs = this._register(new DisposableStore());
    this._debounceInformation = languageFeatureDebounceService.for(_languageFeaturesService.colorProvider, "Document Colors", { min: ColorDetector_1.RECOMPUTE_TIME });
    this._register(_editor.onDidChangeModel(() => {
      this._isColorDecoratorsEnabled = this.isEnabled();
      this.updateColors();
    }));
    this._register(_editor.onDidChangeModelLanguage(() => this.updateColors()));
    this._register(_languageFeaturesService.colorProvider.onDidChange(() => this.updateColors()));
    this._register(_editor.onDidChangeConfiguration((e) => {
      const prevIsEnabled = this._isColorDecoratorsEnabled;
      this._isColorDecoratorsEnabled = this.isEnabled();
      this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
        144
        /* EditorOption.defaultColorDecorators */
      );
      const updatedColorDecoratorsSetting = prevIsEnabled !== this._isColorDecoratorsEnabled || e.hasChanged(
        20
        /* EditorOption.colorDecoratorsLimit */
      );
      const updatedDefaultColorDecoratorsSetting = e.hasChanged(
        144
        /* EditorOption.defaultColorDecorators */
      );
      if (updatedColorDecoratorsSetting || updatedDefaultColorDecoratorsSetting) {
        if (this._isColorDecoratorsEnabled) {
          this.updateColors();
        } else {
          this.removeAllDecorations();
        }
      }
    }));
    this._timeoutTimer = null;
    this._computePromise = null;
    this._isColorDecoratorsEnabled = this.isEnabled();
    this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
      144
      /* EditorOption.defaultColorDecorators */
    );
    this.updateColors();
  }
  isEnabled() {
    const model = this._editor.getModel();
    if (!model) {
      return false;
    }
    const languageId = model.getLanguageId();
    const deprecatedConfig = this._configurationService.getValue(languageId);
    if (deprecatedConfig && typeof deprecatedConfig === "object") {
      const colorDecorators = deprecatedConfig["colorDecorators"];
      if (colorDecorators && colorDecorators["enable"] !== void 0 && !colorDecorators["enable"]) {
        return colorDecorators["enable"];
      }
    }
    return this._editor.getOption(
      19
      /* EditorOption.colorDecorators */
    );
  }
  get limitReporter() {
    return this._decoratorLimitReporter;
  }
  static get(editor2) {
    return editor2.getContribution(this.ID);
  }
  dispose() {
    this.stop();
    this.removeAllDecorations();
    super.dispose();
  }
  updateColors() {
    this.stop();
    if (!this._isColorDecoratorsEnabled) {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !this._languageFeaturesService.colorProvider.has(model)) {
      return;
    }
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      if (!this._timeoutTimer) {
        this._timeoutTimer = new TimeoutTimer();
        this._timeoutTimer.cancelAndSet(() => {
          this._timeoutTimer = null;
          this.beginCompute();
        }, this._debounceInformation.get(model));
      }
    }));
    this.beginCompute();
  }
  beginCompute() {
    return __awaiter7(this, void 0, void 0, function* () {
      this._computePromise = createCancelablePromise((token) => __awaiter7(this, void 0, void 0, function* () {
        const model = this._editor.getModel();
        if (!model) {
          return [];
        }
        const sw = new StopWatch(false);
        const colors = yield getColors(this._languageFeaturesService.colorProvider, model, token, this._isDefaultColorDecoratorsEnabled);
        this._debounceInformation.update(model, sw.elapsed());
        return colors;
      }));
      try {
        const colors = yield this._computePromise;
        this.updateDecorations(colors);
        this.updateColorDecorators(colors);
        this._computePromise = null;
      } catch (e) {
        onUnexpectedError(e);
      }
    });
  }
  stop() {
    if (this._timeoutTimer) {
      this._timeoutTimer.cancel();
      this._timeoutTimer = null;
    }
    if (this._computePromise) {
      this._computePromise.cancel();
      this._computePromise = null;
    }
    this._localToDispose.clear();
  }
  updateDecorations(colorDatas) {
    const decorations = colorDatas.map((c) => ({
      range: {
        startLineNumber: c.colorInfo.range.startLineNumber,
        startColumn: c.colorInfo.range.startColumn,
        endLineNumber: c.colorInfo.range.endLineNumber,
        endColumn: c.colorInfo.range.endColumn
      },
      options: ModelDecorationOptions.EMPTY
    }));
    this._editor.changeDecorations((changeAccessor) => {
      this._decorationsIds = changeAccessor.deltaDecorations(this._decorationsIds, decorations);
      this._colorDatas = /* @__PURE__ */ new Map();
      this._decorationsIds.forEach((id, i) => this._colorDatas.set(id, colorDatas[i]));
    });
  }
  updateColorDecorators(colorData) {
    this._colorDecorationClassRefs.clear();
    const decorations = [];
    const limit = this._editor.getOption(
      20
      /* EditorOption.colorDecoratorsLimit */
    );
    for (let i = 0; i < colorData.length && decorations.length < limit; i++) {
      const { red, green, blue, alpha } = colorData[i].colorInfo.color;
      const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
      const color = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
      const ref = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
        backgroundColor: color
      }));
      decorations.push({
        range: {
          startLineNumber: colorData[i].colorInfo.range.startLineNumber,
          startColumn: colorData[i].colorInfo.range.startColumn,
          endLineNumber: colorData[i].colorInfo.range.endLineNumber,
          endColumn: colorData[i].colorInfo.range.endColumn
        },
        options: {
          description: "colorDetector",
          before: {
            content: noBreakWhitespace,
            inlineClassName: `${ref.className} colorpicker-color-decoration`,
            inlineClassNameAffectsLetterSpacing: true,
            attachedData: ColorDecorationInjectedTextMarker
          }
        }
      });
    }
    const limited = limit < colorData.length ? limit : false;
    this._decoratorLimitReporter.update(colorData.length, limited);
    this._colorDecoratorIds.set(decorations);
  }
  removeAllDecorations() {
    this._editor.removeDecorations(this._decorationsIds);
    this._decorationsIds = [];
    this._colorDecoratorIds.clear();
    this._colorDecorationClassRefs.clear();
  }
  getColorData(position) {
    const model = this._editor.getModel();
    if (!model) {
      return null;
    }
    const decorations = model.getDecorationsInRange(Range.fromPositions(position, position)).filter((d) => this._colorDatas.has(d.id));
    if (decorations.length === 0) {
      return null;
    }
    return this._colorDatas.get(decorations[0].id);
  }
  isColorDecoration(decoration2) {
    return this._colorDecoratorIds.has(decoration2);
  }
};
ColorDetector.ID = "editor.contrib.colorDetector";
ColorDetector.RECOMPUTE_TIME = 1e3;
ColorDetector = ColorDetector_1 = __decorate5([
  __param5(1, IConfigurationService),
  __param5(2, ILanguageFeaturesService),
  __param5(3, ILanguageFeatureDebounceService)
], ColorDetector);
var DecoratorLimitReporter = class {
  constructor() {
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._computed = 0;
    this._limited = false;
  }
  get computed() {
    return this._computed;
  }
  get limited() {
    return this._limited;
  }
  update(computed, limited) {
    if (computed !== this._computed || limited !== this._limited) {
      this._computed = computed;
      this._limited = limited;
      this._onDidChange.fire();
    }
  }
};
registerEditorContribution(
  ColorDetector.ID,
  ColorDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js
init_async();
init_cancellation();
init_color();
init_lifecycle();
init_range();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerModel.js
init_event();
var ColorPickerModel = class {
  get color() {
    return this._color;
  }
  set color(color) {
    if (this._color.equals(color)) {
      return;
    }
    this._color = color;
    this._onDidChangeColor.fire(color);
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(colorPresentations) {
    this._colorPresentations = colorPresentations;
    if (this.presentationIndex > colorPresentations.length - 1) {
      this.presentationIndex = 0;
    }
    this._onDidChangePresentation.fire(this.presentation);
  }
  constructor(color, availableColorPresentations, presentationIndex) {
    this.presentationIndex = presentationIndex;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this._onDidChangeColor = new Emitter();
    this.onDidChangeColor = this._onDidChangeColor.event;
    this._onDidChangePresentation = new Emitter();
    this.onDidChangePresentation = this._onDidChangePresentation.event;
    this.originalColor = color;
    this._color = color;
    this._colorPresentations = availableColorPresentations;
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;
    this.flushColor();
    this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(color, originalText) {
    let presentationIndex = -1;
    for (let i = 0; i < this.colorPresentations.length; i++) {
      if (originalText.toLowerCase() === this.colorPresentations[i].label) {
        presentationIndex = i;
        break;
      }
    }
    if (presentationIndex === -1) {
      const originalTextPrefix = originalText.split("(")[0].toLowerCase();
      for (let i = 0; i < this.colorPresentations.length; i++) {
        if (this.colorPresentations[i].label.toLowerCase().startsWith(originalTextPrefix)) {
          presentationIndex = i;
          break;
        }
      }
    }
    if (presentationIndex !== -1 && presentationIndex !== this.presentationIndex) {
      this.presentationIndex = presentationIndex;
      this._onDidChangePresentation.fire(this.presentation);
    }
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js
init_browser();
init_dom();
init_codicons();
init_color();
init_event();
init_lifecycle();
init_themables();
init_nls();
init_colorRegistry();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
var $2 = $;
var ColorPickerHeader = class extends Disposable {
  constructor(container, model, themeService, showingStandaloneColorPicker = false) {
    super();
    this.model = model;
    this.showingStandaloneColorPicker = showingStandaloneColorPicker;
    this._closeButton = null;
    this._domNode = $2(".colorpicker-header");
    append(container, this._domNode);
    this._pickedColorNode = append(this._domNode, $2(".picked-color"));
    append(this._pickedColorNode, $2("span.codicon.codicon-color-mode"));
    this._pickedColorPresentation = append(this._pickedColorNode, document.createElement("span"));
    this._pickedColorPresentation.classList.add("picked-color-presentation");
    const tooltip = localize("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
    this._pickedColorNode.setAttribute("title", tooltip);
    this._originalColorNode = append(this._domNode, $2(".original-color"));
    this._originalColorNode.style.backgroundColor = Color.Format.CSS.format(this.model.originalColor) || "";
    this.backgroundColor = themeService.getColorTheme().getColor(editorHoverBackground) || Color.white;
    this._register(themeService.onDidColorThemeChange((theme) => {
      this.backgroundColor = theme.getColor(editorHoverBackground) || Color.white;
    }));
    this._register(addDisposableListener(this._pickedColorNode, EventType.CLICK, () => this.model.selectNextColorPresentation()));
    this._register(addDisposableListener(this._originalColorNode, EventType.CLICK, () => {
      this.model.color = this.model.originalColor;
      this.model.flushColor();
    }));
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this._register(model.onDidChangePresentation(this.onDidChangePresentation, this));
    this._pickedColorNode.style.backgroundColor = Color.Format.CSS.format(model.color) || "";
    this._pickedColorNode.classList.toggle("light", model.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : model.color.isLighter());
    this.onDidChangeColor(this.model.color);
    if (this.showingStandaloneColorPicker) {
      this._domNode.classList.add("standalone-colorpicker");
      this._closeButton = this._register(new CloseButton(this._domNode));
    }
  }
  get domNode() {
    return this._domNode;
  }
  get closeButton() {
    return this._closeButton;
  }
  get pickedColorNode() {
    return this._pickedColorNode;
  }
  get originalColorNode() {
    return this._originalColorNode;
  }
  onDidChangeColor(color) {
    this._pickedColorNode.style.backgroundColor = Color.Format.CSS.format(color) || "";
    this._pickedColorNode.classList.toggle("light", color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : color.isLighter());
    this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this._pickedColorPresentation.textContent = this.model.presentation ? this.model.presentation.label : "";
  }
};
var CloseButton = class extends Disposable {
  constructor(container) {
    super();
    this._onClicked = this._register(new Emitter());
    this.onClicked = this._onClicked.event;
    this._button = document.createElement("div");
    this._button.classList.add("close-button");
    append(container, this._button);
    const innerDiv = document.createElement("div");
    innerDiv.classList.add("close-button-inner-div");
    append(this._button, innerDiv);
    const closeButton = append(innerDiv, $2(".button" + ThemeIcon.asCSSSelector(registerIcon("color-picker-close", Codicon.close, localize("closeIcon", "Icon to close the color picker")))));
    closeButton.classList.add("close-icon");
    this._button.onclick = () => {
      this._onClicked.fire();
    };
  }
};
var ColorPickerBody = class extends Disposable {
  constructor(container, model, pixelRatio, isStandaloneColorPicker = false) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._insertButton = null;
    this._domNode = $2(".colorpicker-body");
    append(container, this._domNode);
    this._saturationBox = new SaturationBox(this._domNode, this.model, this.pixelRatio);
    this._register(this._saturationBox);
    this._register(this._saturationBox.onDidChange(this.onDidSaturationValueChange, this));
    this._register(this._saturationBox.onColorFlushed(this.flushColor, this));
    this._opacityStrip = new OpacityStrip(this._domNode, this.model, isStandaloneColorPicker);
    this._register(this._opacityStrip);
    this._register(this._opacityStrip.onDidChange(this.onDidOpacityChange, this));
    this._register(this._opacityStrip.onColorFlushed(this.flushColor, this));
    this._hueStrip = new HueStrip(this._domNode, this.model, isStandaloneColorPicker);
    this._register(this._hueStrip);
    this._register(this._hueStrip.onDidChange(this.onDidHueChange, this));
    this._register(this._hueStrip.onColorFlushed(this.flushColor, this));
    if (isStandaloneColorPicker) {
      this._insertButton = this._register(new InsertButton(this._domNode));
      this._domNode.classList.add("standalone-colorpicker");
    }
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({ s, v }) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, s, v, hsva.a));
  }
  onDidOpacityChange(a) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, hsva.s, hsva.v, a));
  }
  onDidHueChange(value) {
    const hsva = this.model.color.hsva;
    const h = (1 - value) * 360;
    this.model.color = new Color(new HSVA(h === 360 ? 0 : h, hsva.s, hsva.v, hsva.a));
  }
  get domNode() {
    return this._domNode;
  }
  get saturationBox() {
    return this._saturationBox;
  }
  get opacityStrip() {
    return this._opacityStrip;
  }
  get hueStrip() {
    return this._hueStrip;
  }
  get enterButton() {
    return this._insertButton;
  }
  layout() {
    this._saturationBox.layout();
    this._opacityStrip.layout();
    this._hueStrip.layout();
  }
};
var SaturationBox = class extends Disposable {
  constructor(container, model, pixelRatio) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this._domNode = $2(".saturation-wrap");
    append(container, this._domNode);
    this._canvas = document.createElement("canvas");
    this._canvas.className = "saturation-box";
    append(this._domNode, this._canvas);
    this.selection = $2(".saturation-selection");
    append(this._domNode, this.selection);
    this.layout();
    this._register(addDisposableListener(this._domNode, EventType.POINTER_DOWN, (e) => this.onPointerDown(e)));
    this._register(this.model.onDidChangeColor(this.onDidChangeColor, this));
    this.monitor = null;
  }
  get domNode() {
    return this._domNode;
  }
  get canvas() {
    return this._canvas;
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    this.monitor = this._register(new GlobalPointerMoveMonitor());
    const origin = getDomNodePagePosition(this._domNode);
    if (e.target !== this.selection) {
      this.onDidChangePosition(e.offsetX, e.offsetY);
    }
    this.monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangePosition(event.pageX - origin.left, event.pageY - origin.top), () => null);
    const pointerUpListener = addDisposableListener(document, EventType.POINTER_UP, () => {
      this._onColorFlushed.fire();
      pointerUpListener.dispose();
      if (this.monitor) {
        this.monitor.stopMonitoring(true);
        this.monitor = null;
      }
    }, true);
  }
  onDidChangePosition(left, top) {
    const s = Math.max(0, Math.min(1, left / this.width));
    const v = Math.max(0, Math.min(1, 1 - top / this.height));
    this.paintSelection(s, v);
    this._onDidChange.fire({ s, v });
  }
  layout() {
    this.width = this._domNode.offsetWidth;
    this.height = this._domNode.offsetHeight;
    this._canvas.width = this.width * this.pixelRatio;
    this._canvas.height = this.height * this.pixelRatio;
    this.paint();
    const hsva = this.model.color.hsva;
    this.paintSelection(hsva.s, hsva.v);
  }
  paint() {
    const hsva = this.model.color.hsva;
    const saturatedColor = new Color(new HSVA(hsva.h, 1, 1, 1));
    const ctx = this._canvas.getContext("2d");
    const whiteGradient = ctx.createLinearGradient(0, 0, this._canvas.width, 0);
    whiteGradient.addColorStop(0, "rgba(255, 255, 255, 1)");
    whiteGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
    whiteGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
    const blackGradient = ctx.createLinearGradient(0, 0, 0, this._canvas.height);
    blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
    blackGradient.addColorStop(1, "rgba(0, 0, 0, 1)");
    ctx.rect(0, 0, this._canvas.width, this._canvas.height);
    ctx.fillStyle = Color.Format.CSS.format(saturatedColor);
    ctx.fill();
    ctx.fillStyle = whiteGradient;
    ctx.fill();
    ctx.fillStyle = blackGradient;
    ctx.fill();
  }
  paintSelection(s, v) {
    this.selection.style.left = `${s * this.width}px`;
    this.selection.style.top = `${this.height - v * this.height}px`;
  }
  onDidChangeColor(color) {
    if (this.monitor && this.monitor.isMonitoring()) {
      return;
    }
    this.paint();
    const hsva = color.hsva;
    this.paintSelection(hsva.s, hsva.v);
  }
};
var Strip = class extends Disposable {
  constructor(container, model, showingStandaloneColorPicker = false) {
    super();
    this.model = model;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    if (showingStandaloneColorPicker) {
      this.domNode = append(container, $2(".standalone-strip"));
      this.overlay = append(this.domNode, $2(".standalone-overlay"));
    } else {
      this.domNode = append(container, $2(".strip"));
      this.overlay = append(this.domNode, $2(".overlay"));
    }
    this.slider = append(this.domNode, $2(".slider"));
    this.slider.style.top = `0px`;
    this._register(addDisposableListener(this.domNode, EventType.POINTER_DOWN, (e) => this.onPointerDown(e)));
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const value = this.getValue(this.model.color);
    this.updateSliderPosition(value);
  }
  onDidChangeColor(color) {
    const value = this.getValue(color);
    this.updateSliderPosition(value);
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    const monitor = this._register(new GlobalPointerMoveMonitor());
    const origin = getDomNodePagePosition(this.domNode);
    this.domNode.classList.add("grabbing");
    if (e.target !== this.slider) {
      this.onDidChangeTop(e.offsetY);
    }
    monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangeTop(event.pageY - origin.top), () => null);
    const pointerUpListener = addDisposableListener(document, EventType.POINTER_UP, () => {
      this._onColorFlushed.fire();
      pointerUpListener.dispose();
      monitor.stopMonitoring(true);
      this.domNode.classList.remove("grabbing");
    }, true);
  }
  onDidChangeTop(top) {
    const value = Math.max(0, Math.min(1, 1 - top / this.height));
    this.updateSliderPosition(value);
    this._onDidChange.fire(value);
  }
  updateSliderPosition(value) {
    this.slider.style.top = `${(1 - value) * this.height}px`;
  }
};
var OpacityStrip = class extends Strip {
  constructor(container, model, showingStandaloneColorPicker = false) {
    super(container, model, showingStandaloneColorPicker);
    this.domNode.classList.add("opacity-strip");
    this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(color) {
    super.onDidChangeColor(color);
    const { r, g, b } = color.rgba;
    const opaque = new Color(new RGBA(r, g, b, 1));
    const transparent2 = new Color(new RGBA(r, g, b, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${opaque} 0%, ${transparent2} 100%)`;
  }
  getValue(color) {
    return color.hsva.a;
  }
};
var HueStrip = class extends Strip {
  constructor(container, model, showingStandaloneColorPicker = false) {
    super(container, model, showingStandaloneColorPicker);
    this.domNode.classList.add("hue-strip");
  }
  getValue(color) {
    return 1 - color.hsva.h / 360;
  }
};
var InsertButton = class extends Disposable {
  constructor(container) {
    super();
    this._onClicked = this._register(new Emitter());
    this.onClicked = this._onClicked.event;
    this._button = append(container, document.createElement("button"));
    this._button.classList.add("insert-button");
    this._button.textContent = "Insert";
    this._button.onclick = (e) => {
      this._onClicked.fire();
    };
  }
  get button() {
    return this._button;
  }
};
var ColorPickerWidget = class _ColorPickerWidget extends Widget {
  constructor(container, model, pixelRatio, themeService, standaloneColorPicker = false) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._register(PixelRatio.onDidChange(() => this.layout()));
    const element = $2(".colorpicker-widget");
    container.appendChild(element);
    this.header = this._register(new ColorPickerHeader(element, this.model, themeService, standaloneColorPicker));
    this.body = this._register(new ColorPickerBody(element, this.model, this.pixelRatio, standaloneColorPicker));
  }
  getId() {
    return _ColorPickerWidget.ID;
  }
  layout() {
    this.body.layout();
  }
};
ColorPickerWidget.ID = "editor.contrib.colorPickerWidget";

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js
init_themeService();
init_dom();
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ColorHover = class {
  constructor(owner, range, model, provider) {
    this.owner = owner;
    this.range = range;
    this.model = model;
    this.provider = provider;
    this.forceShowAtRange = true;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var ColorHoverParticipant = class ColorHoverParticipant2 {
  constructor(_editor, _themeService) {
    this._editor = _editor;
    this._themeService = _themeService;
    this.hoverOrdinal = 2;
  }
  computeSync(_anchor, _lineDecorations) {
    return [];
  }
  computeAsync(anchor, lineDecorations, token) {
    return AsyncIterableObject.fromPromise(this._computeAsync(anchor, lineDecorations, token));
  }
  _computeAsync(_anchor, lineDecorations, _token) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return [];
      }
      const colorDetector = ColorDetector.get(this._editor);
      if (!colorDetector) {
        return [];
      }
      for (const d of lineDecorations) {
        if (!colorDetector.isColorDecoration(d)) {
          continue;
        }
        const colorData = colorDetector.getColorData(d.range.getStartPosition());
        if (colorData) {
          const colorHover = yield _createColorHover(this, this._editor.getModel(), colorData.colorInfo, colorData.provider);
          return [colorHover];
        }
      }
      return [];
    });
  }
  renderHoverParts(context, hoverParts) {
    return renderHoverParts(this, this._editor, this._themeService, hoverParts, context);
  }
};
ColorHoverParticipant = __decorate6([
  __param6(1, IThemeService)
], ColorHoverParticipant);
var StandaloneColorPickerHover = class {
  constructor(owner, range, model, provider) {
    this.owner = owner;
    this.range = range;
    this.model = model;
    this.provider = provider;
  }
};
var StandaloneColorPickerParticipant = class StandaloneColorPickerParticipant2 {
  constructor(_editor, _themeService) {
    this._editor = _editor;
    this._themeService = _themeService;
    this.hoverOrdinal = 2;
    this._color = null;
  }
  createColorHover(defaultColorInfo, defaultColorProvider, colorProviderRegistry) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return null;
      }
      const colorDetector = ColorDetector.get(this._editor);
      if (!colorDetector) {
        return null;
      }
      const colors = yield getColors(colorProviderRegistry, this._editor.getModel(), CancellationToken.None);
      let foundColorInfo = null;
      let foundColorProvider = null;
      for (const colorData of colors) {
        const colorInfo2 = colorData.colorInfo;
        if (Range.containsRange(colorInfo2.range, defaultColorInfo.range)) {
          foundColorInfo = colorInfo2;
          foundColorProvider = colorData.provider;
        }
      }
      const colorInfo = foundColorInfo !== null && foundColorInfo !== void 0 ? foundColorInfo : defaultColorInfo;
      const colorProvider = foundColorProvider !== null && foundColorProvider !== void 0 ? foundColorProvider : defaultColorProvider;
      const foundInEditor = !!foundColorInfo;
      return { colorHover: yield _createColorHover(this, this._editor.getModel(), colorInfo, colorProvider), foundInEditor };
    });
  }
  updateEditorModel(colorHoverData) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return;
      }
      const colorPickerModel = colorHoverData.model;
      let range = new Range(colorHoverData.range.startLineNumber, colorHoverData.range.startColumn, colorHoverData.range.endLineNumber, colorHoverData.range.endColumn);
      if (this._color) {
        yield _updateColorPresentations(this._editor.getModel(), colorPickerModel, this._color, range, colorHoverData);
        range = _updateEditorModel(this._editor, range, colorPickerModel);
      }
    });
  }
  renderHoverParts(context, hoverParts) {
    return renderHoverParts(this, this._editor, this._themeService, hoverParts, context);
  }
  set color(color) {
    this._color = color;
  }
  get color() {
    return this._color;
  }
};
StandaloneColorPickerParticipant = __decorate6([
  __param6(1, IThemeService)
], StandaloneColorPickerParticipant);
function _createColorHover(participant, editorModel, colorInfo, provider) {
  return __awaiter8(this, void 0, void 0, function* () {
    const originalText = editorModel.getValueInRange(colorInfo.range);
    const { red, green, blue, alpha } = colorInfo.color;
    const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
    const color = new Color(rgba);
    const colorPresentations = yield getColorPresentations(editorModel, colorInfo, provider, CancellationToken.None);
    const model = new ColorPickerModel(color, [], 0);
    model.colorPresentations = colorPresentations || [];
    model.guessColorPresentation(color, originalText);
    if (participant instanceof ColorHoverParticipant) {
      return new ColorHover(participant, Range.lift(colorInfo.range), model, provider);
    } else {
      return new StandaloneColorPickerHover(participant, Range.lift(colorInfo.range), model, provider);
    }
  });
}
function renderHoverParts(participant, editor2, themeService, hoverParts, context) {
  if (hoverParts.length === 0 || !editor2.hasModel()) {
    return Disposable.None;
  }
  if (context.setMinimumDimensions) {
    const minimumHeight = editor2.getOption(
      65
      /* EditorOption.lineHeight */
    ) + 8;
    context.setMinimumDimensions(new Dimension(302, minimumHeight));
  }
  const disposables = new DisposableStore();
  const colorHover = hoverParts[0];
  const editorModel = editor2.getModel();
  const model = colorHover.model;
  const widget = disposables.add(new ColorPickerWidget(context.fragment, model, editor2.getOption(
    140
    /* EditorOption.pixelRatio */
  ), themeService, participant instanceof StandaloneColorPickerParticipant));
  context.setColorPicker(widget);
  let editorUpdatedByColorPicker = false;
  let range = new Range(colorHover.range.startLineNumber, colorHover.range.startColumn, colorHover.range.endLineNumber, colorHover.range.endColumn);
  if (participant instanceof StandaloneColorPickerParticipant) {
    const color = hoverParts[0].model.color;
    participant.color = color;
    _updateColorPresentations(editorModel, model, color, range, colorHover);
    disposables.add(model.onColorFlushed((color2) => {
      participant.color = color2;
    }));
  } else {
    disposables.add(model.onColorFlushed((color) => __awaiter8(this, void 0, void 0, function* () {
      yield _updateColorPresentations(editorModel, model, color, range, colorHover);
      editorUpdatedByColorPicker = true;
      range = _updateEditorModel(editor2, range, model, context);
    })));
  }
  disposables.add(model.onDidChangeColor((color) => {
    _updateColorPresentations(editorModel, model, color, range, colorHover);
  }));
  disposables.add(editor2.onDidChangeModelContent((e) => {
    if (editorUpdatedByColorPicker) {
      editorUpdatedByColorPicker = false;
    } else {
      context.hide();
      editor2.focus();
    }
  }));
  return disposables;
}
function _updateEditorModel(editor2, range, model, context) {
  let textEdits;
  let newRange;
  if (model.presentation.textEdit) {
    textEdits = [model.presentation.textEdit];
    newRange = new Range(model.presentation.textEdit.range.startLineNumber, model.presentation.textEdit.range.startColumn, model.presentation.textEdit.range.endLineNumber, model.presentation.textEdit.range.endColumn);
    const trackedRange = editor2.getModel()._setTrackedRange(
      null,
      newRange,
      3
      /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
    );
    editor2.pushUndoStop();
    editor2.executeEdits("colorpicker", textEdits);
    newRange = editor2.getModel()._getTrackedRange(trackedRange) || newRange;
  } else {
    textEdits = [{ range, text: model.presentation.label, forceMoveMarkers: false }];
    newRange = range.setEndPosition(range.endLineNumber, range.startColumn + model.presentation.label.length);
    editor2.pushUndoStop();
    editor2.executeEdits("colorpicker", textEdits);
  }
  if (model.presentation.additionalTextEdits) {
    textEdits = [...model.presentation.additionalTextEdits];
    editor2.executeEdits("colorpicker", textEdits);
    if (context) {
      context.hide();
    }
  }
  editor2.pushUndoStop();
  return newRange;
}
function _updateColorPresentations(editorModel, colorPickerModel, color, range, colorHover) {
  return __awaiter8(this, void 0, void 0, function* () {
    const colorPresentations = yield getColorPresentations(editorModel, {
      range,
      color: {
        red: color.rgba.r / 255,
        green: color.rgba.g / 255,
        blue: color.rgba.b / 255,
        alpha: color.rgba.a
      }
    }, colorHover.provider, CancellationToken.None);
    colorPickerModel.colorPresentations = colorPresentations || [];
  });
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js
init_keyCodes();
init_lifecycle();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_language();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js
init_async();
init_errors();
init_htmlContent();
init_lifecycle();
init_editorState();
init_editorExtensions();
init_range();
init_language();
init_resolverService();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.css";
init_nls();
init_contextkey();
init_languageFeatures();
init_textModel();
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var GotoDefinitionAtPositionEditorContribution_1;
var GotoDefinitionAtPositionEditorContribution = GotoDefinitionAtPositionEditorContribution_1 = class GotoDefinitionAtPositionEditorContribution2 {
  constructor(editor2, textModelResolverService, languageService, languageFeaturesService) {
    this.textModelResolverService = textModelResolverService;
    this.languageService = languageService;
    this.languageFeaturesService = languageFeaturesService;
    this.toUnhook = new DisposableStore();
    this.toUnhookForKeyboard = new DisposableStore();
    this.currentWordAtPosition = null;
    this.previousPromise = null;
    this.editor = editor2;
    this.linkDecorations = this.editor.createDecorationsCollection();
    const linkGesture = new ClickLinkGesture(editor2);
    this.toUnhook.add(linkGesture);
    this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this.startFindDefinitionFromMouse(mouseEvent, keyboardEvent !== null && keyboardEvent !== void 0 ? keyboardEvent : void 0);
    }));
    this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {
      if (this.isEnabled(mouseEvent)) {
        this.gotoDefinition(mouseEvent.target.position, mouseEvent.hasSideBySideModifier).catch((error) => {
          onUnexpectedError(error);
        }).finally(() => {
          this.removeLinkDecorations();
        });
      }
    }));
    this.toUnhook.add(linkGesture.onCancel(() => {
      this.removeLinkDecorations();
      this.currentWordAtPosition = null;
    }));
  }
  static get(editor2) {
    return editor2.getContribution(GotoDefinitionAtPositionEditorContribution_1.ID);
  }
  startFindDefinitionFromCursor(position) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.startFindDefinition(position);
      this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
        this.currentWordAtPosition = null;
        this.removeLinkDecorations();
        this.toUnhookForKeyboard.clear();
      }));
      this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
        if (e) {
          this.currentWordAtPosition = null;
          this.removeLinkDecorations();
          this.toUnhookForKeyboard.clear();
        }
      }));
    });
  }
  startFindDefinitionFromMouse(mouseEvent, withKey) {
    if (mouseEvent.target.type === 9 && this.linkDecorations.length > 0) {
      return;
    }
    if (!this.editor.hasModel() || !this.isEnabled(mouseEvent, withKey)) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return;
    }
    const position = mouseEvent.target.position;
    this.startFindDefinition(position);
  }
  startFindDefinition(position) {
    var _a;
    return __awaiter9(this, void 0, void 0, function* () {
      this.toUnhookForKeyboard.clear();
      const word = position ? (_a = this.editor.getModel()) === null || _a === void 0 ? void 0 : _a.getWordAtPosition(position) : null;
      if (!word) {
        this.currentWordAtPosition = null;
        this.removeLinkDecorations();
        return;
      }
      if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {
        return;
      }
      this.currentWordAtPosition = word;
      const state = new EditorState(
        this.editor,
        4 | 1 | 2 | 8
        /* CodeEditorStateFlag.Scroll */
      );
      if (this.previousPromise) {
        this.previousPromise.cancel();
        this.previousPromise = null;
      }
      this.previousPromise = createCancelablePromise((token) => this.findDefinition(position, token));
      let results;
      try {
        results = yield this.previousPromise;
      } catch (error) {
        onUnexpectedError(error);
        return;
      }
      if (!results || !results.length || !state.validate(this.editor)) {
        this.removeLinkDecorations();
        return;
      }
      const linkRange = results[0].originSelectionRange ? Range.lift(results[0].originSelectionRange) : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
      if (results.length > 1) {
        let combinedRange = linkRange;
        for (const { originSelectionRange } of results) {
          if (originSelectionRange) {
            combinedRange = Range.plusRange(combinedRange, originSelectionRange);
          }
        }
        this.addDecoration(combinedRange, new MarkdownString().appendText(localize("multipleResults", "Click to show {0} definitions.", results.length)));
      } else {
        const result = results[0];
        if (!result.uri) {
          return;
        }
        this.textModelResolverService.createModelReference(result.uri).then((ref) => {
          if (!ref.object || !ref.object.textEditorModel) {
            ref.dispose();
            return;
          }
          const { object: { textEditorModel } } = ref;
          const { startLineNumber } = result.range;
          if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
            ref.dispose();
            return;
          }
          const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
          const languageId = this.languageService.guessLanguageIdByFilepathOrFirstLine(textEditorModel.uri);
          this.addDecoration(linkRange, previewValue ? new MarkdownString().appendCodeblock(languageId ? languageId : "", previewValue) : void 0);
          ref.dispose();
        });
      }
    });
  }
  getPreviewValue(textEditorModel, startLineNumber, result) {
    let rangeToUse = result.range;
    const numberOfLinesInRange = rangeToUse.endLineNumber - rangeToUse.startLineNumber;
    if (numberOfLinesInRange >= GotoDefinitionAtPositionEditorContribution_1.MAX_SOURCE_PREVIEW_LINES) {
      rangeToUse = this.getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber);
    }
    const previewValue = this.stripIndentationFromPreviewRange(textEditorModel, startLineNumber, rangeToUse);
    return previewValue;
  }
  stripIndentationFromPreviewRange(textEditorModel, startLineNumber, previewRange) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    let minIndent = startIndent;
    for (let endLineNumber = startLineNumber + 1; endLineNumber < previewRange.endLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      minIndent = Math.min(minIndent, endIndent);
    }
    const previewValue = textEditorModel.getValueInRange(previewRange).replace(new RegExp(`^\\s{${minIndent - 1}}`, "gm"), "").trim();
    return previewValue;
  }
  getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution_1.MAX_SOURCE_PREVIEW_LINES);
    let endLineNumber = startLineNumber + 1;
    for (; endLineNumber < maxLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      if (startIndent === endIndent) {
        break;
      }
    }
    return new Range(startLineNumber, 1, endLineNumber + 1, 1);
  }
  addDecoration(range, hoverMessage) {
    const newDecorations = {
      range,
      options: {
        description: "goto-definition-link",
        inlineClassName: "goto-definition-link",
        hoverMessage
      }
    };
    this.linkDecorations.set([newDecorations]);
  }
  removeLinkDecorations() {
    this.linkDecorations.clear();
  }
  isEnabled(mouseEvent, withKey) {
    var _a;
    return this.editor.hasModel() && mouseEvent.isLeftClick && mouseEvent.isNoneOrSingleMouseDown && mouseEvent.target.type === 6 && !(((_a = mouseEvent.target.detail.injectedText) === null || _a === void 0 ? void 0 : _a.options) instanceof ModelDecorationInjectedTextOptions) && (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
  }
  findDefinition(position, token) {
    const model = this.editor.getModel();
    if (!model) {
      return Promise.resolve(null);
    }
    return getDefinitionsAtPosition(this.languageFeaturesService.definitionProvider, model, position, token);
  }
  gotoDefinition(position, openToSide) {
    this.editor.setPosition(position);
    return this.editor.invokeWithinContext((accessor) => {
      const canPeek = !openToSide && this.editor.getOption(
        86
        /* EditorOption.definitionLinkOpensInPeek */
      ) && !this.isInPeekEditor(accessor);
      const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: "", original: "" }, id: "", precondition: void 0 });
      return action.run(accessor);
    });
  }
  isInPeekEditor(accessor) {
    const contextKeyService = accessor.get(IContextKeyService);
    return PeekContext.inPeekEditor.getValue(contextKeyService);
  }
  dispose() {
    this.toUnhook.dispose();
    this.toUnhookForKeyboard.dispose();
  }
};
GotoDefinitionAtPositionEditorContribution.ID = "editor.contrib.gotodefinitionatposition";
GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES = 8;
GotoDefinitionAtPositionEditorContribution = GotoDefinitionAtPositionEditorContribution_1 = __decorate7([
  __param7(1, ITextModelService),
  __param7(2, ILanguageService),
  __param7(3, ILanguageFeaturesService)
], GotoDefinitionAtPositionEditorContribution);
registerEditorContribution(
  GotoDefinitionAtPositionEditorContribution.ID,
  GotoDefinitionAtPositionEditorContribution,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js
init_dom();
init_keyboardEvent();
init_lifecycle();
init_nls();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css";
var $3 = $;
var HoverWidget = class extends Disposable {
  constructor() {
    super();
    this.containerDomNode = document.createElement("div");
    this.containerDomNode.className = "monaco-hover";
    this.containerDomNode.tabIndex = 0;
    this.containerDomNode.setAttribute("role", "tooltip");
    this.contentsDomNode = document.createElement("div");
    this.contentsDomNode.className = "monaco-hover-content";
    this.scrollbar = this._register(new DomScrollableElement(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: true
    }));
    this.containerDomNode.appendChild(this.scrollbar.getDomNode());
  }
  onContentsChanged() {
    this.scrollbar.scanDomNode();
  }
};
var HoverAction = class _HoverAction extends Disposable {
  static render(parent, actionOptions, keybindingLabel) {
    return new _HoverAction(parent, actionOptions, keybindingLabel);
  }
  constructor(parent, actionOptions, keybindingLabel) {
    super();
    this.actionContainer = append(parent, $3("div.action-container"));
    this.actionContainer.setAttribute("tabindex", "0");
    this.action = append(this.actionContainer, $3("a.action"));
    this.action.setAttribute("role", "button");
    if (actionOptions.iconClass) {
      append(this.action, $3(`span.icon.${actionOptions.iconClass}`));
    }
    const label = append(this.action, $3("span"));
    label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;
    this._register(addDisposableListener(this.actionContainer, EventType.CLICK, (e) => {
      e.stopPropagation();
      e.preventDefault();
      actionOptions.run(this.actionContainer);
    }));
    this._register(addDisposableListener(this.actionContainer, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        3
        /* KeyCode.Enter */
      ) || event.equals(
        10
        /* KeyCode.Space */
      )) {
        e.stopPropagation();
        e.preventDefault();
        actionOptions.run(this.actionContainer);
      }
    }));
    this.setEnabled(true);
  }
  setEnabled(enabled) {
    if (enabled) {
      this.actionContainer.classList.remove("disabled");
      this.actionContainer.removeAttribute("aria-disabled");
    } else {
      this.actionContainer.classList.add("disabled");
      this.actionContainer.setAttribute("aria-disabled", "true");
    }
  }
};
function getHoverAccessibleViewHint(shouldHaveHint, keybinding) {
  return shouldHaveHint && keybinding ? localize("acessibleViewHint", "Inspect this in the accessible view with {0}.", keybinding) : shouldHaveHint ? localize("acessibleViewHintNoKbOpen", "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding.") : "";
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js
init_arrays();
init_lifecycle();
init_position();
init_range();
init_textModel();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverOperation.js
init_async();
init_errors();
init_event();
init_lifecycle();
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var HoverResult = class {
  constructor(value, isComplete, hasLoadingMessage) {
    this.value = value;
    this.isComplete = isComplete;
    this.hasLoadingMessage = hasLoadingMessage;
  }
};
var HoverOperation = class extends Disposable {
  constructor(_editor, _computer) {
    super();
    this._editor = _editor;
    this._computer = _computer;
    this._onResult = this._register(new Emitter());
    this.onResult = this._onResult.event;
    this._firstWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerAsyncComputation(), 0));
    this._secondWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerSyncComputation(), 0));
    this._loadingMessageScheduler = this._register(new RunOnceScheduler(() => this._triggerLoadingMessage(), 0));
    this._state = 0;
    this._asyncIterable = null;
    this._asyncIterableDone = false;
    this._result = [];
  }
  dispose() {
    if (this._asyncIterable) {
      this._asyncIterable.cancel();
      this._asyncIterable = null;
    }
    super.dispose();
  }
  get _hoverTime() {
    return this._editor.getOption(
      59
      /* EditorOption.hover */
    ).delay;
  }
  get _firstWaitTime() {
    return this._hoverTime / 2;
  }
  get _secondWaitTime() {
    return this._hoverTime - this._firstWaitTime;
  }
  get _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _setState(state, fireResult = true) {
    this._state = state;
    if (fireResult) {
      this._fireResult();
    }
  }
  _triggerAsyncComputation() {
    this._setState(
      2
      /* HoverOperationState.SecondWait */
    );
    this._secondWaitScheduler.schedule(this._secondWaitTime);
    if (this._computer.computeAsync) {
      this._asyncIterableDone = false;
      this._asyncIterable = createCancelableAsyncIterable((token) => this._computer.computeAsync(token));
      (() => __awaiter10(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        try {
          try {
            for (var _d = true, _e = __asyncValues(this._asyncIterable), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
              _c = _f.value;
              _d = false;
              const item = _c;
              if (item) {
                this._result.push(item);
                this._fireResult();
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = _e.return))
                yield _b.call(_e);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          this._asyncIterableDone = true;
          if (this._state === 3 || this._state === 4) {
            this._setState(
              0
              /* HoverOperationState.Idle */
            );
          }
        } catch (e) {
          onUnexpectedError(e);
        }
      }))();
    } else {
      this._asyncIterableDone = true;
    }
  }
  _triggerSyncComputation() {
    if (this._computer.computeSync) {
      this._result = this._result.concat(this._computer.computeSync());
    }
    this._setState(
      this._asyncIterableDone ? 0 : 3
      /* HoverOperationState.WaitingForAsync */
    );
  }
  _triggerLoadingMessage() {
    if (this._state === 3) {
      this._setState(
        4
        /* HoverOperationState.WaitingForAsyncShowingLoading */
      );
    }
  }
  _fireResult() {
    if (this._state === 1 || this._state === 2) {
      return;
    }
    const isComplete = this._state === 0;
    const hasLoadingMessage = this._state === 4;
    this._onResult.fire(new HoverResult(this._result.slice(0), isComplete, hasLoadingMessage));
  }
  start(mode) {
    if (mode === 0) {
      if (this._state === 0) {
        this._setState(
          1
          /* HoverOperationState.FirstWait */
        );
        this._firstWaitScheduler.schedule(this._firstWaitTime);
        this._loadingMessageScheduler.schedule(this._loadingMessageTime);
      }
    } else {
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation();
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
        case 2:
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
      }
    }
  }
  cancel() {
    this._firstWaitScheduler.cancel();
    this._secondWaitScheduler.cancel();
    this._loadingMessageScheduler.cancel();
    if (this._asyncIterable) {
      this._asyncIterable.cancel();
      this._asyncIterable = null;
    }
    this._result = [];
    this._setState(0, false);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverTypes.js
var HoverRangeAnchor = class {
  constructor(priority, range, initialMousePosX, initialMousePosY) {
    this.priority = priority;
    this.range = range;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.type = 1;
  }
  equals(other) {
    return other.type === 1 && this.range.equalsRange(other.range);
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 1 && showAtPosition.lineNumber === this.range.startLineNumber;
  }
};
var HoverForeignElementAnchor = class {
  constructor(priority, owner, range, initialMousePosX, initialMousePosY, supportsMarkerHover) {
    this.priority = priority;
    this.owner = owner;
    this.range = range;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.supportsMarkerHover = supportsMarkerHover;
    this.type = 2;
  }
  equals(other) {
    return other.type === 2 && this.owner === other.owner;
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 2 && this.owner === lastAnchor.owner;
  }
};
var HoverParticipantRegistry = new class HoverParticipantRegistry2 {
  constructor() {
    this._participants = [];
  }
  register(ctor) {
    this._participants.push(ctor);
  }
  getAll() {
    return this._participants;
  }
}();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js
init_instantiation();
init_async();
init_editorContextKeys();
init_contextkey();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/resizableContentWidget.js
init_lifecycle();
init_position();
init_dom();
var TOP_HEIGHT = 30;
var BOTTOM_HEIGHT = 24;
var ResizableContentWidget = class extends Disposable {
  constructor(_editor, minimumSize = new Dimension(10, 10)) {
    super();
    this._editor = _editor;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._resizableNode = this._register(new ResizableHTMLElement());
    this._contentPosition = null;
    this._isResizing = false;
    this._resizableNode.domNode.style.position = "absolute";
    this._resizableNode.minSize = Dimension.lift(minimumSize);
    this._resizableNode.layout(minimumSize.height, minimumSize.width);
    this._resizableNode.enableSashes(true, true, true, true);
    this._register(this._resizableNode.onDidResize((e) => {
      this._resize(new Dimension(e.dimension.width, e.dimension.height));
      if (e.done) {
        this._isResizing = false;
      }
    }));
    this._register(this._resizableNode.onDidWillResize(() => {
      this._isResizing = true;
    }));
  }
  get isResizing() {
    return this._isResizing;
  }
  getDomNode() {
    return this._resizableNode.domNode;
  }
  getPosition() {
    return this._contentPosition;
  }
  get position() {
    var _a;
    return ((_a = this._contentPosition) === null || _a === void 0 ? void 0 : _a.position) ? Position.lift(this._contentPosition.position) : void 0;
  }
  _availableVerticalSpaceAbove(position) {
    const editorDomNode = this._editor.getDomNode();
    const mouseBox = this._editor.getScrolledVisiblePosition(position);
    if (!editorDomNode || !mouseBox) {
      return;
    }
    const editorBox = getDomNodePagePosition(editorDomNode);
    return editorBox.top + mouseBox.top - TOP_HEIGHT;
  }
  _availableVerticalSpaceBelow(position) {
    const editorDomNode = this._editor.getDomNode();
    const mouseBox = this._editor.getScrolledVisiblePosition(position);
    if (!editorDomNode || !mouseBox) {
      return;
    }
    const editorBox = getDomNodePagePosition(editorDomNode);
    const bodyBox = getClientArea(document.body);
    const mouseBottom = editorBox.top + mouseBox.top + mouseBox.height;
    return bodyBox.height - mouseBottom - BOTTOM_HEIGHT;
  }
  _findPositionPreference(widgetHeight, showAtPosition) {
    var _a, _b;
    const maxHeightBelow = Math.min((_a = this._availableVerticalSpaceBelow(showAtPosition)) !== null && _a !== void 0 ? _a : Infinity, widgetHeight);
    const maxHeightAbove = Math.min((_b = this._availableVerticalSpaceAbove(showAtPosition)) !== null && _b !== void 0 ? _b : Infinity, widgetHeight);
    const maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow), widgetHeight);
    const height = Math.min(widgetHeight, maxHeight);
    let renderingAbove;
    if (this._editor.getOption(
      59
      /* EditorOption.hover */
    ).above) {
      renderingAbove = height <= maxHeightAbove ? 1 : 2;
    } else {
      renderingAbove = height <= maxHeightBelow ? 2 : 1;
    }
    if (renderingAbove === 1) {
      this._resizableNode.enableSashes(true, true, false, false);
    } else {
      this._resizableNode.enableSashes(false, true, true, false);
    }
    return renderingAbove;
  }
  _resize(dimension) {
    this._resizableNode.layout(dimension.height, dimension.width);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js
init_configuration();
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContentHoverController_1;
var ContentHoverWidget_1;
var $4 = $;
var ContentHoverController = ContentHoverController_1 = class ContentHoverController2 extends Disposable {
  getWidgetContent() {
    const node = this._widget.getDomNode();
    if (!node.textContent) {
      return void 0;
    }
    return node.textContent;
  }
  constructor(_editor, _instantiationService, _keybindingService) {
    super();
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._keybindingService = _keybindingService;
    this._currentResult = null;
    this._widget = this._register(this._instantiationService.createInstance(ContentHoverWidget, this._editor));
    this._participants = [];
    for (const participant of HoverParticipantRegistry.getAll()) {
      this._participants.push(this._instantiationService.createInstance(participant, this._editor));
    }
    this._participants.sort((p1, p2) => p1.hoverOrdinal - p2.hoverOrdinal);
    this._computer = new ContentHoverComputer(this._editor, this._participants);
    this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));
    this._register(this._hoverOperation.onResult((result) => {
      if (!this._computer.anchor) {
        return;
      }
      const messages = result.hasLoadingMessage ? this._addLoadingMessage(result.value) : result.value;
      this._withResult(new HoverResult2(this._computer.anchor, messages, result.isComplete));
    }));
    this._register(addStandardDisposableListener(this._widget.getDomNode(), "keydown", (e) => {
      if (e.equals(
        9
        /* KeyCode.Escape */
      )) {
        this.hide();
      }
    }));
    this._register(TokenizationRegistry.onDidChange(() => {
      if (this._widget.position && this._currentResult) {
        this._setCurrentResult(this._currentResult);
      }
    }));
  }
  get widget() {
    return this._widget;
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  maybeShowAt(mouseEvent) {
    if (this._widget.isResizing) {
      return true;
    }
    const anchorCandidates = [];
    for (const participant of this._participants) {
      if (participant.suggestHoverAnchor) {
        const anchor = participant.suggestHoverAnchor(mouseEvent);
        if (anchor) {
          anchorCandidates.push(anchor);
        }
      }
    }
    const target = mouseEvent.target;
    if (target.type === 6) {
      anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));
    }
    if (target.type === 7) {
      const epsilon = this._editor.getOption(
        49
        /* EditorOption.fontInfo */
      ).typicalHalfwidthCharacterWidth / 2;
      if (!target.detail.isAfterLines && typeof target.detail.horizontalDistanceToText === "number" && target.detail.horizontalDistanceToText < epsilon) {
        anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));
      }
    }
    if (anchorCandidates.length === 0) {
      return this._startShowingOrUpdateHover(null, 0, 0, false, mouseEvent);
    }
    anchorCandidates.sort((a, b) => b.priority - a.priority);
    return this._startShowingOrUpdateHover(anchorCandidates[0], 0, 0, false, mouseEvent);
  }
  startShowingAtRange(range, mode, source, focus) {
    this._startShowingOrUpdateHover(new HoverRangeAnchor(0, range, void 0, void 0), mode, source, focus, null);
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  _startShowingOrUpdateHover(anchor, mode, source, focus, mouseEvent) {
    if (!this._widget.position || !this._currentResult) {
      if (anchor) {
        this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
        return true;
      }
      return false;
    }
    const hoverIsSticky = this._editor.getOption(
      59
      /* EditorOption.hover */
    ).sticky;
    const isGettingCloser = hoverIsSticky && mouseEvent && this._widget.isMouseGettingCloser(mouseEvent.event.posx, mouseEvent.event.posy);
    if (isGettingCloser) {
      if (anchor) {
        this._startHoverOperationIfNecessary(anchor, mode, source, focus, true);
      }
      return true;
    }
    if (!anchor) {
      this._setCurrentResult(null);
      return false;
    }
    if (anchor && this._currentResult.anchor.equals(anchor)) {
      return true;
    }
    if (!anchor.canAdoptVisibleHover(this._currentResult.anchor, this._widget.position)) {
      this._setCurrentResult(null);
      this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
      return true;
    }
    this._setCurrentResult(this._currentResult.filter(anchor));
    this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
    return true;
  }
  _startHoverOperationIfNecessary(anchor, mode, source, focus, insistOnKeepingHoverVisible) {
    if (this._computer.anchor && this._computer.anchor.equals(anchor)) {
      return;
    }
    this._hoverOperation.cancel();
    this._computer.anchor = anchor;
    this._computer.shouldFocus = focus;
    this._computer.source = source;
    this._computer.insistOnKeepingHoverVisible = insistOnKeepingHoverVisible;
    this._hoverOperation.start(mode);
  }
  _setCurrentResult(hoverResult) {
    if (this._currentResult === hoverResult) {
      return;
    }
    if (hoverResult && hoverResult.messages.length === 0) {
      hoverResult = null;
    }
    this._currentResult = hoverResult;
    if (this._currentResult) {
      this._renderMessages(this._currentResult.anchor, this._currentResult.messages);
    } else {
      this._widget.hide();
    }
  }
  hide() {
    this._computer.anchor = null;
    this._hoverOperation.cancel();
    this._setCurrentResult(null);
  }
  get isColorPickerVisible() {
    return this._widget.isColorPickerVisible;
  }
  get isVisibleFromKeyboard() {
    return this._widget.isVisibleFromKeyboard;
  }
  get isVisible() {
    return this._widget.isVisible;
  }
  get isFocused() {
    return this._widget.isFocused;
  }
  get isResizing() {
    return this._widget.isResizing;
  }
  containsNode(node) {
    return node ? this._widget.getDomNode().contains(node) : false;
  }
  _addLoadingMessage(result) {
    if (this._computer.anchor) {
      for (const participant of this._participants) {
        if (participant.createLoadingMessage) {
          const loadingMessage = participant.createLoadingMessage(this._computer.anchor);
          if (loadingMessage) {
            return result.slice(0).concat([loadingMessage]);
          }
        }
      }
    }
    return result;
  }
  _withResult(hoverResult) {
    if (this._widget.position && this._currentResult && this._currentResult.isComplete) {
      if (!hoverResult.isComplete) {
        return;
      }
      if (this._computer.insistOnKeepingHoverVisible && hoverResult.messages.length === 0) {
        return;
      }
    }
    this._setCurrentResult(hoverResult);
  }
  _renderMessages(anchor, messages) {
    const { showAtPosition, showAtSecondaryPosition, highlightRange } = ContentHoverController_1.computeHoverRanges(this._editor, anchor.range, messages);
    const disposables = new DisposableStore();
    const statusBar = disposables.add(new EditorHoverStatusBar(this._keybindingService));
    const fragment = document.createDocumentFragment();
    let colorPicker = null;
    const context = {
      fragment,
      statusBar,
      setColorPicker: (widget) => colorPicker = widget,
      onContentsChanged: () => this._widget.onContentsChanged(),
      setMinimumDimensions: (dimensions) => this._widget.setMinimumDimensions(dimensions),
      hide: () => this.hide()
    };
    for (const participant of this._participants) {
      const hoverParts = messages.filter((msg) => msg.owner === participant);
      if (hoverParts.length > 0) {
        disposables.add(participant.renderHoverParts(context, hoverParts));
      }
    }
    const isBeforeContent = messages.some((m) => m.isBeforeContent);
    if (statusBar.hasContent) {
      fragment.appendChild(statusBar.hoverElement);
    }
    if (fragment.hasChildNodes()) {
      if (highlightRange) {
        const highlightDecoration = this._editor.createDecorationsCollection();
        highlightDecoration.set([{
          range: highlightRange,
          options: ContentHoverController_1._DECORATION_OPTIONS
        }]);
        disposables.add(toDisposable(() => {
          highlightDecoration.clear();
        }));
      }
      this._widget.showAt(fragment, new ContentHoverVisibleData(colorPicker, showAtPosition, showAtSecondaryPosition, this._editor.getOption(
        59
        /* EditorOption.hover */
      ).above, this._computer.shouldFocus, this._computer.source, isBeforeContent, anchor.initialMousePosX, anchor.initialMousePosY, disposables));
    } else {
      disposables.dispose();
    }
  }
  static computeHoverRanges(editor2, anchorRange, messages) {
    let startColumnBoundary = 1;
    if (editor2.hasModel()) {
      const viewModel = editor2._getViewModel();
      const coordinatesConverter = viewModel.coordinatesConverter;
      const anchorViewRange = coordinatesConverter.convertModelRangeToViewRange(anchorRange);
      const anchorViewRangeStart = new Position(anchorViewRange.startLineNumber, viewModel.getLineMinColumn(anchorViewRange.startLineNumber));
      startColumnBoundary = coordinatesConverter.convertViewPositionToModelPosition(anchorViewRangeStart).column;
    }
    const anchorLineNumber = anchorRange.startLineNumber;
    let renderStartColumn = anchorRange.startColumn;
    let highlightRange = messages[0].range;
    let forceShowAtRange = null;
    for (const msg of messages) {
      highlightRange = Range.plusRange(highlightRange, msg.range);
      if (msg.range.startLineNumber === anchorLineNumber && msg.range.endLineNumber === anchorLineNumber) {
        renderStartColumn = Math.max(Math.min(renderStartColumn, msg.range.startColumn), startColumnBoundary);
      }
      if (msg.forceShowAtRange) {
        forceShowAtRange = msg.range;
      }
    }
    return {
      showAtPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position(anchorLineNumber, anchorRange.startColumn),
      showAtSecondaryPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position(anchorLineNumber, renderStartColumn),
      highlightRange
    };
  }
  focus() {
    this._widget.focus();
  }
  scrollUp() {
    this._widget.scrollUp();
  }
  scrollDown() {
    this._widget.scrollDown();
  }
  scrollLeft() {
    this._widget.scrollLeft();
  }
  scrollRight() {
    this._widget.scrollRight();
  }
  pageUp() {
    this._widget.pageUp();
  }
  pageDown() {
    this._widget.pageDown();
  }
  goToTop() {
    this._widget.goToTop();
  }
  goToBottom() {
    this._widget.goToBottom();
  }
};
ContentHoverController._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "content-hover-highlight",
  className: "hoverHighlight"
});
ContentHoverController = ContentHoverController_1 = __decorate8([
  __param8(1, IInstantiationService),
  __param8(2, IKeybindingService)
], ContentHoverController);
var HoverResult2 = class {
  constructor(anchor, messages, isComplete) {
    this.anchor = anchor;
    this.messages = messages;
    this.isComplete = isComplete;
  }
  filter(anchor) {
    const filteredMessages = this.messages.filter((m) => m.isValidForHoverAnchor(anchor));
    if (filteredMessages.length === this.messages.length) {
      return this;
    }
    return new FilteredHoverResult(this, this.anchor, filteredMessages, this.isComplete);
  }
};
var FilteredHoverResult = class extends HoverResult2 {
  constructor(original, anchor, messages, isComplete) {
    super(anchor, messages, isComplete);
    this.original = original;
  }
  filter(anchor) {
    return this.original.filter(anchor);
  }
};
var ContentHoverVisibleData = class {
  constructor(colorPicker, showAtPosition, showAtSecondaryPosition, preferAbove, stoleFocus, source, isBeforeContent, initialMousePosX, initialMousePosY, disposables) {
    this.colorPicker = colorPicker;
    this.showAtPosition = showAtPosition;
    this.showAtSecondaryPosition = showAtSecondaryPosition;
    this.preferAbove = preferAbove;
    this.stoleFocus = stoleFocus;
    this.source = source;
    this.isBeforeContent = isBeforeContent;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.disposables = disposables;
    this.closestMouseDistance = void 0;
  }
};
var HORIZONTAL_SCROLLING_BY = 30;
var SCROLLBAR_WIDTH = 10;
var CONTAINER_HEIGHT_PADDING = 6;
var ContentHoverWidget = ContentHoverWidget_1 = class ContentHoverWidget2 extends ResizableContentWidget {
  get isColorPickerVisible() {
    var _a;
    return Boolean((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.colorPicker);
  }
  get isVisibleFromKeyboard() {
    var _a;
    return ((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.source) === 1;
  }
  get isVisible() {
    var _a;
    return (_a = this._hoverVisibleKey.get()) !== null && _a !== void 0 ? _a : false;
  }
  get isFocused() {
    var _a;
    return (_a = this._hoverFocusedKey.get()) !== null && _a !== void 0 ? _a : false;
  }
  constructor(editor2, contextKeyService, _configurationService, _accessibilityService, _keybindingService) {
    const minimumHeight = editor2.getOption(
      65
      /* EditorOption.lineHeight */
    ) + 8;
    const minimumWidth = 150;
    const minimumSize = new Dimension(minimumWidth, minimumHeight);
    super(editor2, minimumSize);
    this._configurationService = _configurationService;
    this._accessibilityService = _accessibilityService;
    this._keybindingService = _keybindingService;
    this._hover = this._register(new HoverWidget());
    this._minimumSize = minimumSize;
    this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(contextKeyService);
    this._hoverFocusedKey = EditorContextKeys.hoverFocused.bindTo(contextKeyService);
    append(this._resizableNode.domNode, this._hover.containerDomNode);
    this._resizableNode.domNode.style.zIndex = "50";
    this._register(this._editor.onDidLayoutChange(() => this._layout()));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        49
        /* EditorOption.fontInfo */
      )) {
        this._updateFont();
      }
    }));
    const focusTracker = this._register(trackFocus(this._resizableNode.domNode));
    this._register(focusTracker.onDidFocus(() => {
      this._hoverFocusedKey.set(true);
    }));
    this._register(focusTracker.onDidBlur(() => {
      this._hoverFocusedKey.set(false);
    }));
    this._setHoverData(void 0);
    this._layout();
    this._editor.addContentWidget(this);
  }
  dispose() {
    var _a;
    super.dispose();
    (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.disposables.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return ContentHoverWidget_1.ID;
  }
  static _applyDimensions(container, width, height) {
    const transformedWidth = typeof width === "number" ? `${width}px` : width;
    const transformedHeight = typeof height === "number" ? `${height}px` : height;
    container.style.width = transformedWidth;
    container.style.height = transformedHeight;
  }
  _setContentsDomNodeDimensions(width, height) {
    const contentsDomNode = this._hover.contentsDomNode;
    return ContentHoverWidget_1._applyDimensions(contentsDomNode, width, height);
  }
  _setContainerDomNodeDimensions(width, height) {
    const containerDomNode = this._hover.containerDomNode;
    return ContentHoverWidget_1._applyDimensions(containerDomNode, width, height);
  }
  _setHoverWidgetDimensions(width, height) {
    this._setContentsDomNodeDimensions(width, height);
    this._setContainerDomNodeDimensions(width, height);
    this._layoutContentWidget();
  }
  static _applyMaxDimensions(container, width, height) {
    const transformedWidth = typeof width === "number" ? `${width}px` : width;
    const transformedHeight = typeof height === "number" ? `${height}px` : height;
    container.style.maxWidth = transformedWidth;
    container.style.maxHeight = transformedHeight;
  }
  _setHoverWidgetMaxDimensions(width, height) {
    ContentHoverWidget_1._applyMaxDimensions(this._hover.contentsDomNode, width, height);
    ContentHoverWidget_1._applyMaxDimensions(this._hover.containerDomNode, width, height);
    this._hover.containerDomNode.style.setProperty("--vscode-hover-maxWidth", typeof width === "number" ? `${width}px` : width);
    this._layoutContentWidget();
  }
  _hasHorizontalScrollbar() {
    const scrollDimensions = this._hover.scrollbar.getScrollDimensions();
    const hasHorizontalScrollbar = scrollDimensions.scrollWidth > scrollDimensions.width;
    return hasHorizontalScrollbar;
  }
  _adjustContentsBottomPadding() {
    const contentsDomNode = this._hover.contentsDomNode;
    const extraBottomPadding = `${this._hover.scrollbar.options.horizontalScrollbarSize}px`;
    if (contentsDomNode.style.paddingBottom !== extraBottomPadding) {
      contentsDomNode.style.paddingBottom = extraBottomPadding;
    }
  }
  _setAdjustedHoverWidgetDimensions(size) {
    this._setHoverWidgetMaxDimensions("none", "none");
    const width = size.width;
    const height = size.height;
    this._setHoverWidgetDimensions(width, height);
    if (this._hasHorizontalScrollbar()) {
      this._adjustContentsBottomPadding();
      this._setContentsDomNodeDimensions(width, height - SCROLLBAR_WIDTH);
    }
  }
  _updateResizableNodeMaxDimensions() {
    var _a, _b;
    const maxRenderingWidth = (_a = this._findMaximumRenderingWidth()) !== null && _a !== void 0 ? _a : Infinity;
    const maxRenderingHeight = (_b = this._findMaximumRenderingHeight()) !== null && _b !== void 0 ? _b : Infinity;
    this._resizableNode.maxSize = new Dimension(maxRenderingWidth, maxRenderingHeight);
    this._setHoverWidgetMaxDimensions(maxRenderingWidth, maxRenderingHeight);
  }
  _resize(size) {
    var _a, _b;
    ContentHoverWidget_1._lastDimensions = new Dimension(size.width, size.height);
    this._setAdjustedHoverWidgetDimensions(size);
    this._resizableNode.layout(size.height, size.width);
    this._updateResizableNodeMaxDimensions();
    this._hover.scrollbar.scanDomNode();
    this._editor.layoutContentWidget(this);
    (_b = (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.colorPicker) === null || _b === void 0 ? void 0 : _b.layout();
  }
  _findAvailableSpaceVertically() {
    var _a;
    const position = (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.showAtPosition;
    if (!position) {
      return;
    }
    return this._positionPreference === 1 ? this._availableVerticalSpaceAbove(position) : this._availableVerticalSpaceBelow(position);
  }
  _findMaximumRenderingHeight() {
    const availableSpace = this._findAvailableSpaceVertically();
    if (!availableSpace) {
      return;
    }
    let maximumHeight = CONTAINER_HEIGHT_PADDING;
    Array.from(this._hover.contentsDomNode.children).forEach((hoverPart) => {
      maximumHeight += hoverPart.clientHeight;
    });
    if (this._hasHorizontalScrollbar()) {
      maximumHeight += SCROLLBAR_WIDTH;
    }
    return Math.min(availableSpace, maximumHeight);
  }
  _isHoverTextOverflowing() {
    this._hover.containerDomNode.style.setProperty("--vscode-hover-whiteSpace", "nowrap");
    this._hover.containerDomNode.style.setProperty("--vscode-hover-sourceWhiteSpace", "nowrap");
    const overflowing = Array.from(this._hover.contentsDomNode.children).some((hoverElement) => {
      return hoverElement.scrollWidth > hoverElement.clientWidth;
    });
    this._hover.containerDomNode.style.removeProperty("--vscode-hover-whiteSpace");
    this._hover.containerDomNode.style.removeProperty("--vscode-hover-sourceWhiteSpace");
    return overflowing;
  }
  _findMaximumRenderingWidth() {
    if (!this._editor || !this._editor.hasModel()) {
      return;
    }
    const overflowing = this._isHoverTextOverflowing();
    const initialWidth = typeof this._contentWidth === "undefined" ? 0 : this._contentWidth - 2;
    if (overflowing || this._hover.containerDomNode.clientWidth < initialWidth) {
      const bodyBoxWidth = getClientArea(document.body).width;
      const horizontalPadding = 14;
      return bodyBoxWidth - horizontalPadding;
    } else {
      return this._hover.containerDomNode.clientWidth + 2;
    }
  }
  isMouseGettingCloser(posx, posy) {
    if (!this._visibleData) {
      return false;
    }
    if (typeof this._visibleData.initialMousePosX === "undefined" || typeof this._visibleData.initialMousePosY === "undefined") {
      this._visibleData.initialMousePosX = posx;
      this._visibleData.initialMousePosY = posy;
      return false;
    }
    const widgetRect = getDomNodePagePosition(this.getDomNode());
    if (typeof this._visibleData.closestMouseDistance === "undefined") {
      this._visibleData.closestMouseDistance = computeDistanceFromPointToRectangle(this._visibleData.initialMousePosX, this._visibleData.initialMousePosY, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);
    }
    const distance = computeDistanceFromPointToRectangle(posx, posy, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);
    if (distance > this._visibleData.closestMouseDistance + 4) {
      return false;
    }
    this._visibleData.closestMouseDistance = Math.min(this._visibleData.closestMouseDistance, distance);
    return true;
  }
  _setHoverData(hoverData) {
    var _a;
    (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.disposables.dispose();
    this._visibleData = hoverData;
    this._hoverVisibleKey.set(!!hoverData);
    this._hover.containerDomNode.classList.toggle("hidden", !hoverData);
  }
  _layout() {
    const { fontSize, lineHeight } = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    const contentsDomNode = this._hover.contentsDomNode;
    contentsDomNode.style.fontSize = `${fontSize}px`;
    contentsDomNode.style.lineHeight = `${lineHeight / fontSize}`;
    this._updateMaxDimensions();
  }
  _updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  _updateContent(node) {
    const contentsDomNode = this._hover.contentsDomNode;
    contentsDomNode.style.paddingBottom = "";
    contentsDomNode.textContent = "";
    contentsDomNode.appendChild(node);
  }
  _layoutContentWidget() {
    this._editor.layoutContentWidget(this);
    this._hover.onContentsChanged();
  }
  _updateMaxDimensions() {
    const height = Math.max(this._editor.getLayoutInfo().height / 4, 250, ContentHoverWidget_1._lastDimensions.height);
    const width = Math.max(this._editor.getLayoutInfo().width * 0.66, 500, ContentHoverWidget_1._lastDimensions.width);
    this._setHoverWidgetMaxDimensions(width, height);
  }
  _render(node, hoverData) {
    this._setHoverData(hoverData);
    this._updateFont();
    this._updateContent(node);
    this._updateMaxDimensions();
    this.onContentsChanged();
    this._editor.render();
  }
  getPosition() {
    var _a;
    if (!this._visibleData) {
      return null;
    }
    return {
      position: this._visibleData.showAtPosition,
      secondaryPosition: this._visibleData.showAtSecondaryPosition,
      positionAffinity: this._visibleData.isBeforeContent ? 3 : void 0,
      preference: [
        (_a = this._positionPreference) !== null && _a !== void 0 ? _a : 1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  showAt(node, hoverData) {
    var _a, _b, _c, _d;
    if (!this._editor || !this._editor.hasModel()) {
      return;
    }
    this._render(node, hoverData);
    const widgetHeight = getTotalHeight(this._hover.containerDomNode);
    const widgetPosition = hoverData.showAtPosition;
    this._positionPreference = (_a = this._findPositionPreference(widgetHeight, widgetPosition)) !== null && _a !== void 0 ? _a : 1;
    this.onContentsChanged();
    if (hoverData.stoleFocus) {
      this._hover.containerDomNode.focus();
    }
    (_b = hoverData.colorPicker) === null || _b === void 0 ? void 0 : _b.layout();
    const accessibleViewHint = getHoverAccessibleViewHint(this._configurationService.getValue("accessibility.verbosity.hover") === true && this._accessibilityService.isScreenReaderOptimized(), (_d = (_c = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) === null || _c === void 0 ? void 0 : _c.getAriaLabel()) !== null && _d !== void 0 ? _d : "");
    if (accessibleViewHint) {
      this._hover.contentsDomNode.ariaLabel = this._hover.contentsDomNode.textContent + ", " + accessibleViewHint;
    }
  }
  hide() {
    if (!this._visibleData) {
      return;
    }
    const stoleFocus = this._visibleData.stoleFocus || this._hoverFocusedKey.get();
    this._setHoverData(void 0);
    this._resizableNode.maxSize = new Dimension(Infinity, Infinity);
    this._resizableNode.clearSashHoverState();
    this._hoverFocusedKey.set(false);
    this._editor.layoutContentWidget(this);
    if (stoleFocus) {
      this._editor.focus();
    }
  }
  _removeConstraintsRenderNormally() {
    const layoutInfo = this._editor.getLayoutInfo();
    this._resizableNode.layout(layoutInfo.height, layoutInfo.width);
    this._setHoverWidgetDimensions("auto", "auto");
  }
  _adjustHoverHeightForScrollbar(height) {
    var _a;
    const containerDomNode = this._hover.containerDomNode;
    const contentsDomNode = this._hover.contentsDomNode;
    const maxRenderingHeight = (_a = this._findMaximumRenderingHeight()) !== null && _a !== void 0 ? _a : Infinity;
    this._setContainerDomNodeDimensions(getTotalWidth(containerDomNode), Math.min(maxRenderingHeight, height));
    this._setContentsDomNodeDimensions(getTotalWidth(contentsDomNode), Math.min(maxRenderingHeight, height - SCROLLBAR_WIDTH));
  }
  setMinimumDimensions(dimensions) {
    this._minimumSize = new Dimension(Math.max(this._minimumSize.width, dimensions.width), Math.max(this._minimumSize.height, dimensions.height));
    this._updateMinimumWidth();
  }
  _updateMinimumWidth() {
    const width = typeof this._contentWidth === "undefined" ? this._minimumSize.width : Math.min(this._contentWidth, this._minimumSize.width);
    this._resizableNode.minSize = new Dimension(width, this._minimumSize.height);
  }
  onContentsChanged() {
    var _a;
    this._removeConstraintsRenderNormally();
    const containerDomNode = this._hover.containerDomNode;
    let height = getTotalHeight(containerDomNode);
    let width = getTotalWidth(containerDomNode);
    this._resizableNode.layout(height, width);
    this._setHoverWidgetDimensions(width, height);
    height = getTotalHeight(containerDomNode);
    width = getTotalWidth(containerDomNode);
    this._contentWidth = width;
    this._updateMinimumWidth();
    this._resizableNode.layout(height, width);
    if (this._hasHorizontalScrollbar()) {
      this._adjustContentsBottomPadding();
      this._adjustHoverHeightForScrollbar(height);
    }
    if ((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.showAtPosition) {
      const widgetHeight = getTotalHeight(this._hover.containerDomNode);
      this._positionPreference = this._findPositionPreference(widgetHeight, this._visibleData.showAtPosition);
    }
    this._layoutContentWidget();
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  scrollUp() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const fontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop - fontInfo.lineHeight });
  }
  scrollDown() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const fontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop + fontInfo.lineHeight });
  }
  scrollLeft() {
    const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: scrollLeft - HORIZONTAL_SCROLLING_BY });
  }
  scrollRight() {
    const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: scrollLeft + HORIZONTAL_SCROLLING_BY });
  }
  pageUp() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop - scrollHeight });
  }
  pageDown() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop + scrollHeight });
  }
  goToTop() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: 0 });
  }
  goToBottom() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: this._hover.scrollbar.getScrollDimensions().scrollHeight });
  }
};
ContentHoverWidget.ID = "editor.contrib.resizableContentHoverWidget";
ContentHoverWidget._lastDimensions = new Dimension(0, 0);
ContentHoverWidget = ContentHoverWidget_1 = __decorate8([
  __param8(1, IContextKeyService),
  __param8(2, IConfigurationService),
  __param8(3, IAccessibilityService),
  __param8(4, IKeybindingService)
], ContentHoverWidget);
var EditorHoverStatusBar = class EditorHoverStatusBar2 extends Disposable {
  get hasContent() {
    return this._hasContent;
  }
  constructor(_keybindingService) {
    super();
    this._keybindingService = _keybindingService;
    this._hasContent = false;
    this.hoverElement = $4("div.hover-row.status-bar");
    this.actionsElement = append(this.hoverElement, $4("div.actions"));
  }
  addAction(actionOptions) {
    const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);
    const keybindingLabel = keybinding ? keybinding.getLabel() : null;
    this._hasContent = true;
    return this._register(HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));
  }
  append(element) {
    const result = append(this.actionsElement, element);
    this._hasContent = true;
    return result;
  }
};
EditorHoverStatusBar = __decorate8([
  __param8(0, IKeybindingService)
], EditorHoverStatusBar);
var ContentHoverComputer = class _ContentHoverComputer {
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor = value;
  }
  get shouldFocus() {
    return this._shouldFocus;
  }
  set shouldFocus(value) {
    this._shouldFocus = value;
  }
  get source() {
    return this._source;
  }
  set source(value) {
    this._source = value;
  }
  get insistOnKeepingHoverVisible() {
    return this._insistOnKeepingHoverVisible;
  }
  set insistOnKeepingHoverVisible(value) {
    this._insistOnKeepingHoverVisible = value;
  }
  constructor(_editor, _participants) {
    this._editor = _editor;
    this._participants = _participants;
    this._anchor = null;
    this._shouldFocus = false;
    this._source = 0;
    this._insistOnKeepingHoverVisible = false;
  }
  static _getLineDecorations(editor2, anchor) {
    if (anchor.type !== 1 && !anchor.supportsMarkerHover) {
      return [];
    }
    const model = editor2.getModel();
    const lineNumber = anchor.range.startLineNumber;
    if (lineNumber > model.getLineCount()) {
      return [];
    }
    const maxColumn = model.getLineMaxColumn(lineNumber);
    return editor2.getLineDecorations(lineNumber).filter((d) => {
      if (d.options.isWholeLine) {
        return true;
      }
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      if (d.options.showIfCollapsed) {
        if (startColumn > anchor.range.startColumn + 1 || anchor.range.endColumn - 1 > endColumn) {
          return false;
        }
      } else {
        if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) {
          return false;
        }
      }
      return true;
    });
  }
  computeAsync(token) {
    const anchor = this._anchor;
    if (!this._editor.hasModel() || !anchor) {
      return AsyncIterableObject.EMPTY;
    }
    const lineDecorations = _ContentHoverComputer._getLineDecorations(this._editor, anchor);
    return AsyncIterableObject.merge(this._participants.map((participant) => {
      if (!participant.computeAsync) {
        return AsyncIterableObject.EMPTY;
      }
      return participant.computeAsync(anchor, lineDecorations, token);
    }));
  }
  computeSync() {
    if (!this._editor.hasModel() || !this._anchor) {
      return [];
    }
    const lineDecorations = _ContentHoverComputer._getLineDecorations(this._editor, this._anchor);
    let result = [];
    for (const participant of this._participants) {
      result = result.concat(participant.computeSync(this._anchor, lineDecorations));
    }
    return coalesce(result);
  }
};
function computeDistanceFromPointToRectangle(pointX, pointY, left, top, width, height) {
  const x = left + width / 2;
  const y = top + height / 2;
  const dx = Math.max(Math.abs(pointX - x) - width / 2, 0);
  const dy = Math.max(Math.abs(pointY - y) - height / 2, 0);
  return Math.sqrt(dx * dx + dy * dy);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/marginHover.js
init_dom();
init_arrays();
init_htmlContent();
init_lifecycle();
var $5 = $;
var MarginHoverWidget = class _MarginHoverWidget extends Disposable {
  constructor(editor2, languageService, openerService) {
    super();
    this._renderDisposeables = this._register(new DisposableStore());
    this._editor = editor2;
    this._isVisible = false;
    this._messages = [];
    this._hover = this._register(new HoverWidget());
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    this._markdownRenderer = this._register(new MarkdownRenderer({ editor: this._editor }, languageService, openerService));
    this._computer = new MarginHoverComputer(this._editor);
    this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));
    this._register(this._hoverOperation.onResult((result) => {
      this._withResult(result.value);
    }));
    this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged()));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        49
        /* EditorOption.fontInfo */
      )) {
        this._updateFont();
      }
    }));
    this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return _MarginHoverWidget.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    return null;
  }
  _updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  _onModelDecorationsChanged() {
    if (this._isVisible) {
      this._hoverOperation.cancel();
      this._hoverOperation.start(
        0
        /* HoverStartMode.Delayed */
      );
    }
  }
  startShowingAt(lineNumber) {
    if (this._computer.lineNumber === lineNumber) {
      return;
    }
    this._hoverOperation.cancel();
    this.hide();
    this._computer.lineNumber = lineNumber;
    this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    );
  }
  hide() {
    this._computer.lineNumber = -1;
    this._hoverOperation.cancel();
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
  }
  _withResult(result) {
    this._messages = result;
    if (this._messages.length > 0) {
      this._renderMessages(this._computer.lineNumber, this._messages);
    } else {
      this.hide();
    }
  }
  _renderMessages(lineNumber, messages) {
    this._renderDisposeables.clear();
    const fragment = document.createDocumentFragment();
    for (const msg of messages) {
      const markdownHoverElement = $5("div.hover-row.markdown-hover");
      const hoverContentsElement = append(markdownHoverElement, $5("div.hover-contents"));
      const renderedContents = this._renderDisposeables.add(this._markdownRenderer.render(msg.value));
      hoverContentsElement.appendChild(renderedContents.element);
      fragment.appendChild(markdownHoverElement);
    }
    this._updateContents(fragment);
    this._showAt(lineNumber);
  }
  _updateContents(node) {
    this._hover.contentsDomNode.textContent = "";
    this._hover.contentsDomNode.appendChild(node);
    this._updateFont();
  }
  _showAt(lineNumber) {
    if (!this._isVisible) {
      this._isVisible = true;
      this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    }
    const editorLayout = this._editor.getLayoutInfo();
    const topForLineNumber = this._editor.getTopForLineNumber(lineNumber);
    const editorScrollTop = this._editor.getScrollTop();
    const lineHeight = this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    const nodeHeight = this._hover.containerDomNode.clientHeight;
    const top = topForLineNumber - editorScrollTop - (nodeHeight - lineHeight) / 2;
    this._hover.containerDomNode.style.left = `${editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth}px`;
    this._hover.containerDomNode.style.top = `${Math.max(Math.round(top), 0)}px`;
  }
};
MarginHoverWidget.ID = "editor.contrib.modesGlyphHoverWidget";
var MarginHoverComputer = class {
  get lineNumber() {
    return this._lineNumber;
  }
  set lineNumber(value) {
    this._lineNumber = value;
  }
  constructor(_editor) {
    this._editor = _editor;
    this._lineNumber = -1;
  }
  computeSync() {
    const toHoverMessage = (contents) => {
      return {
        value: contents
      };
    };
    const lineDecorations = this._editor.getLineDecorations(this._lineNumber);
    const result = [];
    if (!lineDecorations) {
      return result;
    }
    for (const d of lineDecorations) {
      if (!d.options.glyphMarginClassName) {
        continue;
      }
      const hoverMessage = d.options.glyphMarginHoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      result.push(...asArray(hoverMessage).map(toHoverMessage));
    }
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js
init_instantiation();
init_opener();
init_colorRegistry();
init_themeService();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markdownHoverParticipant.js
init_dom();
init_arrays();
init_async();
init_htmlContent();
init_lifecycle();
init_position();
init_range();
init_language();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/getHover.js
init_async();
init_cancellation();
init_errors();
init_editorExtensions();
init_languageFeatures();
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HoverProviderResult = class {
  constructor(provider, hover, ordinal) {
    this.provider = provider;
    this.hover = hover;
    this.ordinal = ordinal;
  }
};
function executeProvider(provider, ordinal, model, position, token) {
  return __awaiter11(this, void 0, void 0, function* () {
    try {
      const result = yield Promise.resolve(provider.provideHover(model, position, token));
      if (result && isValid(result)) {
        return new HoverProviderResult(provider, result, ordinal);
      }
    } catch (err) {
      onUnexpectedExternalError(err);
    }
    return void 0;
  });
}
function getHover(registry, model, position, token) {
  const providers = registry.ordered(model);
  const promises = providers.map((provider, index) => executeProvider(provider, index, model, position, token));
  return AsyncIterableObject.fromPromises(promises).coalesce();
}
function getHoverPromise(registry, model, position, token) {
  return getHover(registry, model, position, token).map((item) => item.hover).toPromise();
}
registerModelAndPositionCommand("_executeHoverProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  return getHoverPromise(languageFeaturesService.hoverProvider, model, position, CancellationToken.None);
});
function isValid(result) {
  const hasRange = typeof result.range !== "undefined";
  const hasHtmlContent = typeof result.contents !== "undefined" && result.contents && result.contents.length > 0;
  return hasRange && hasHtmlContent;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markdownHoverParticipant.js
init_nls();
init_configuration();
init_opener();
init_languageFeatures();
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $6 = $;
var MarkdownHover = class {
  constructor(owner, range, contents, isBeforeContent, ordinal) {
    this.owner = owner;
    this.range = range;
    this.contents = contents;
    this.isBeforeContent = isBeforeContent;
    this.ordinal = ordinal;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var MarkdownHoverParticipant = class MarkdownHoverParticipant2 {
  constructor(_editor, _languageService, _openerService, _configurationService, _languageFeaturesService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this.hoverOrdinal = 3;
  }
  createLoadingMessage(anchor) {
    return new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("modesContentHover.loading", "Loading..."))], false, 2e3);
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    let index = 1e3;
    const lineLength = model.getLineLength(lineNumber);
    const languageId = model.getLanguageIdAtPosition(anchor.range.startLineNumber, anchor.range.startColumn);
    const stopRenderingLineAfter = this._editor.getOption(
      115
      /* EditorOption.stopRenderingLineAfter */
    );
    const maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: languageId
    });
    let stopRenderingMessage = false;
    if (stopRenderingLineAfter >= 0 && lineLength > stopRenderingLineAfter && anchor.range.startColumn >= stopRenderingLineAfter) {
      stopRenderingMessage = true;
      result.push(new MarkdownHover(this, anchor.range, [{
        value: localize("stopped rendering", "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
      }], false, index++));
    }
    if (!stopRenderingMessage && typeof maxTokenizationLineLength === "number" && lineLength >= maxTokenizationLineLength) {
      result.push(new MarkdownHover(this, anchor.range, [{
        value: localize("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
      }], false, index++));
    }
    let isBeforeContent = false;
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const hoverMessage = d.options.hoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      if (d.options.beforeContentClassName) {
        isBeforeContent = true;
      }
      const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkdownHover(this, range, asArray(hoverMessage), isBeforeContent, index++));
    }
    return result;
  }
  computeAsync(anchor, lineDecorations, token) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return AsyncIterableObject.EMPTY;
    }
    const model = this._editor.getModel();
    if (!this._languageFeaturesService.hoverProvider.has(model)) {
      return AsyncIterableObject.EMPTY;
    }
    const position = new Position(anchor.range.startLineNumber, anchor.range.startColumn);
    return getHover(this._languageFeaturesService.hoverProvider, model, position, token).filter((item) => !isEmptyMarkdownString(item.hover.contents)).map((item) => {
      const rng = item.hover.range ? Range.lift(item.hover.range) : anchor.range;
      return new MarkdownHover(this, rng, item.hover.contents, false, item.ordinal);
    });
  }
  renderHoverParts(context, hoverParts) {
    return renderMarkdownHovers(context, hoverParts, this._editor, this._languageService, this._openerService);
  }
};
MarkdownHoverParticipant = __decorate9([
  __param9(1, ILanguageService),
  __param9(2, IOpenerService),
  __param9(3, IConfigurationService),
  __param9(4, ILanguageFeaturesService)
], MarkdownHoverParticipant);
function renderMarkdownHovers(context, hoverParts, editor2, languageService, openerService) {
  hoverParts.sort((a, b) => a.ordinal - b.ordinal);
  const disposables = new DisposableStore();
  for (const hoverPart of hoverParts) {
    for (const contents of hoverPart.contents) {
      if (isEmptyMarkdownString(contents)) {
        continue;
      }
      const markdownHoverElement = $6("div.hover-row.markdown-hover");
      const hoverContentsElement = append(markdownHoverElement, $6("div.hover-contents"));
      const renderer = disposables.add(new MarkdownRenderer({ editor: editor2 }, languageService, openerService));
      disposables.add(renderer.onDidRenderAsync(() => {
        hoverContentsElement.className = "hover-contents code-hover-contents";
        context.onContentsChanged();
      }));
      const renderedContents = disposables.add(renderer.render(contents));
      hoverContentsElement.appendChild(renderedContents.element);
      context.fragment.appendChild(markdownHoverElement);
    }
  }
  return disposables;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markerHoverParticipant.js
init_dom();
init_arrays();
init_async();
init_errors();
init_lifecycle();
init_resources();
init_range();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
init_codicons();
init_lifecycle();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/markerNavigationService.js
init_arrays();
init_event();
init_lifecycle();
init_linkedList();
init_strings();
init_uri();
init_range();
init_extensions();
init_instantiation();
init_configuration();
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerCoordinate = class {
  constructor(marker, index, total) {
    this.marker = marker;
    this.index = index;
    this.total = total;
  }
};
var MarkerList = class MarkerList2 {
  constructor(resourceFilter, _markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._dispoables = new DisposableStore();
    this._markers = [];
    this._nextIdx = -1;
    if (URI.isUri(resourceFilter)) {
      this._resourceFilter = (uri) => uri.toString() === resourceFilter.toString();
    } else if (resourceFilter) {
      this._resourceFilter = resourceFilter;
    }
    const compareOrder = this._configService.getValue("problems.sortOrder");
    const compareMarker = (a, b) => {
      let res = compare(a.resource.toString(), b.resource.toString());
      if (res === 0) {
        if (compareOrder === "position") {
          res = Range.compareRangesUsingStarts(a, b) || MarkerSeverity.compare(a.severity, b.severity);
        } else {
          res = MarkerSeverity.compare(a.severity, b.severity) || Range.compareRangesUsingStarts(a, b);
        }
      }
      return res;
    };
    const updateMarker = () => {
      this._markers = this._markerService.read({
        resource: URI.isUri(resourceFilter) ? resourceFilter : void 0,
        severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info
      });
      if (typeof resourceFilter === "function") {
        this._markers = this._markers.filter((m) => this._resourceFilter(m.resource));
      }
      this._markers.sort(compareMarker);
    };
    updateMarker();
    this._dispoables.add(_markerService.onMarkerChanged((uris) => {
      if (!this._resourceFilter || uris.some((uri) => this._resourceFilter(uri))) {
        updateMarker();
        this._nextIdx = -1;
        this._onDidChange.fire();
      }
    }));
  }
  dispose() {
    this._dispoables.dispose();
    this._onDidChange.dispose();
  }
  matches(uri) {
    if (!this._resourceFilter && !uri) {
      return true;
    }
    if (!this._resourceFilter || !uri) {
      return false;
    }
    return this._resourceFilter(uri);
  }
  get selected() {
    const marker = this._markers[this._nextIdx];
    return marker && new MarkerCoordinate(marker, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(model, position, fwd) {
    let found = false;
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === model.uri.toString());
    if (idx < 0) {
      idx = binarySearch(this._markers, { resource: model.uri }, (a, b) => compare(a.resource.toString(), b.resource.toString()));
      if (idx < 0) {
        idx = ~idx;
      }
    }
    for (let i = idx; i < this._markers.length; i++) {
      let range = Range.lift(this._markers[i]);
      if (range.isEmpty()) {
        const word = model.getWordAtPosition(range.getStartPosition());
        if (word) {
          range = new Range(range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);
        }
      }
      if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {
        this._nextIdx = i;
        found = true;
        break;
      }
      if (this._markers[i].resource.toString() !== model.uri.toString()) {
        break;
      }
    }
    if (!found) {
      this._nextIdx = fwd ? 0 : this._markers.length - 1;
    }
    if (this._nextIdx < 0) {
      this._nextIdx = this._markers.length - 1;
    }
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(fwd, model, position) {
    if (this._markers.length === 0) {
      return false;
    }
    const oldIdx = this._nextIdx;
    if (this._nextIdx === -1) {
      this._initIdx(model, position, fwd);
    } else if (fwd) {
      this._nextIdx = (this._nextIdx + 1) % this._markers.length;
    } else if (!fwd) {
      this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;
    }
    if (oldIdx !== this._nextIdx) {
      return true;
    }
    return false;
  }
  find(uri, position) {
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === uri.toString());
    if (idx < 0) {
      return void 0;
    }
    for (; idx < this._markers.length; idx++) {
      if (Range.containsPosition(this._markers[idx], position)) {
        return new MarkerCoordinate(this._markers[idx], idx + 1, this._markers.length);
      }
    }
    return void 0;
  }
};
MarkerList = __decorate10([
  __param10(1, IMarkerService),
  __param10(2, IConfigurationService)
], MarkerList);
var IMarkerNavigationService = createDecorator("IMarkerNavigationService");
var MarkerNavigationService = class MarkerNavigationService2 {
  constructor(_markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._provider = new LinkedList();
  }
  registerProvider(provider) {
    const remove = this._provider.unshift(provider);
    return toDisposable(() => remove());
  }
  getMarkerList(resource) {
    for (const provider of this._provider) {
      const result = provider.getMarkerList(resource);
      if (result) {
        return result;
      }
    }
    return new MarkerList(resource, this._markerService, this._configService);
  }
};
MarkerNavigationService = __decorate10([
  __param10(0, IMarkerService),
  __param10(1, IConfigurationService)
], MarkerNavigationService);
registerSingleton(
  IMarkerNavigationService,
  MarkerNavigationService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
init_nls();
init_actions2();
init_contextkey();
init_instantiation();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js
init_dom();
init_arrays();
init_color();
init_event();
init_lifecycle();
init_resources();
init_strings();
init_range();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/media/gotoErrorWidget.css";
init_nls();
init_actions2();
init_contextkey();
init_instantiation();
init_opener();

// node_modules/monaco-editor/esm/vs/platform/severityIcon/browser/severityIcon.js
init_codicons();
init_themables();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/platform/severityIcon/browser/media/severityIcon.css";
var SeverityIcon;
(function(SeverityIcon2) {
  function className(severity) {
    switch (severity) {
      case severity_default.Ignore:
        return "severity-ignore " + ThemeIcon.asClassName(Codicon.info);
      case severity_default.Info:
        return ThemeIcon.asClassName(Codicon.info);
      case severity_default.Warning:
        return ThemeIcon.asClassName(Codicon.warning);
      case severity_default.Error:
        return ThemeIcon.asClassName(Codicon.error);
      default:
        return "";
    }
  }
  SeverityIcon2.className = className;
})(SeverityIcon || (SeverityIcon = {}));

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js
init_colorRegistry();
init_themeService();
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerNavigationWidget_1;
var MessageWidget = class {
  constructor(parent, editor2, onRelatedInformation, _openerService, _labelService) {
    this._openerService = _openerService;
    this._labelService = _labelService;
    this._lines = 0;
    this._longestLineLength = 0;
    this._relatedDiagnostics = /* @__PURE__ */ new WeakMap();
    this._disposables = new DisposableStore();
    this._editor = editor2;
    const domNode = document.createElement("div");
    domNode.className = "descriptioncontainer";
    this._messageBlock = document.createElement("div");
    this._messageBlock.classList.add("message");
    this._messageBlock.setAttribute("aria-live", "assertive");
    this._messageBlock.setAttribute("role", "alert");
    domNode.appendChild(this._messageBlock);
    this._relatedBlock = document.createElement("div");
    domNode.appendChild(this._relatedBlock);
    this._disposables.add(addStandardDisposableListener(this._relatedBlock, "click", (event) => {
      event.preventDefault();
      const related = this._relatedDiagnostics.get(event.target);
      if (related) {
        onRelatedInformation(related);
      }
    }));
    this._scrollable = new ScrollableElement(domNode, {
      horizontal: 1,
      vertical: 1,
      useShadows: false,
      horizontalScrollbarSize: 6,
      verticalScrollbarSize: 6
    });
    parent.appendChild(this._scrollable.getDomNode());
    this._disposables.add(this._scrollable.onScroll((e) => {
      domNode.style.left = `-${e.scrollLeft}px`;
      domNode.style.top = `-${e.scrollTop}px`;
    }));
    this._disposables.add(this._scrollable);
  }
  dispose() {
    dispose(this._disposables);
  }
  update(marker) {
    const { source, message, relatedInformation, code } = marker;
    let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + "()".length;
    if (code) {
      if (typeof code === "string") {
        sourceAndCodeLength += code.length;
      } else {
        sourceAndCodeLength += code.value.length;
      }
    }
    const lines = splitLines(message);
    this._lines = lines.length;
    this._longestLineLength = 0;
    for (const line of lines) {
      this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);
    }
    clearNode(this._messageBlock);
    this._messageBlock.setAttribute("aria-label", this.getAriaLabel(marker));
    this._editor.applyFontInfo(this._messageBlock);
    let lastLineElement = this._messageBlock;
    for (const line of lines) {
      lastLineElement = document.createElement("div");
      lastLineElement.innerText = line;
      if (line === "") {
        lastLineElement.style.height = this._messageBlock.style.lineHeight;
      }
      this._messageBlock.appendChild(lastLineElement);
    }
    if (source || code) {
      const detailsElement = document.createElement("span");
      detailsElement.classList.add("details");
      lastLineElement.appendChild(detailsElement);
      if (source) {
        const sourceElement = document.createElement("span");
        sourceElement.innerText = source;
        sourceElement.classList.add("source");
        detailsElement.appendChild(sourceElement);
      }
      if (code) {
        if (typeof code === "string") {
          const codeElement = document.createElement("span");
          codeElement.innerText = `(${code})`;
          codeElement.classList.add("code");
          detailsElement.appendChild(codeElement);
        } else {
          this._codeLink = $("a.code-link");
          this._codeLink.setAttribute("href", `${code.target.toString()}`);
          this._codeLink.onclick = (e) => {
            this._openerService.open(code.target, { allowCommands: true });
            e.preventDefault();
            e.stopPropagation();
          };
          const codeElement = append(this._codeLink, $("span"));
          codeElement.innerText = code.value;
          detailsElement.appendChild(this._codeLink);
        }
      }
    }
    clearNode(this._relatedBlock);
    this._editor.applyFontInfo(this._relatedBlock);
    if (isNonEmptyArray(relatedInformation)) {
      const relatedInformationNode = this._relatedBlock.appendChild(document.createElement("div"));
      relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(
        65
        /* EditorOption.lineHeight */
      ) * 0.66)}px`;
      this._lines += 1;
      for (const related of relatedInformation) {
        const container = document.createElement("div");
        const relatedResource = document.createElement("a");
        relatedResource.classList.add("filename");
        relatedResource.innerText = `${this._labelService.getUriBasenameLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;
        relatedResource.title = this._labelService.getUriLabel(related.resource);
        this._relatedDiagnostics.set(relatedResource, related);
        const relatedMessage = document.createElement("span");
        relatedMessage.innerText = related.message;
        container.appendChild(relatedResource);
        container.appendChild(relatedMessage);
        this._lines += 1;
        relatedInformationNode.appendChild(container);
      }
    }
    const fontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75);
    const scrollHeight = fontInfo.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({ scrollWidth, scrollHeight });
  }
  layout(height, width) {
    this._scrollable.getDomNode().style.height = `${height}px`;
    this._scrollable.getDomNode().style.width = `${width}px`;
    this._scrollable.setScrollDimensions({ width, height });
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(marker) {
    let severityLabel = "";
    switch (marker.severity) {
      case MarkerSeverity.Error:
        severityLabel = localize("Error", "Error");
        break;
      case MarkerSeverity.Warning:
        severityLabel = localize("Warning", "Warning");
        break;
      case MarkerSeverity.Info:
        severityLabel = localize("Info", "Info");
        break;
      case MarkerSeverity.Hint:
        severityLabel = localize("Hint", "Hint");
        break;
    }
    let ariaLabel = localize("marker aria", "{0} at {1}. ", severityLabel, marker.startLineNumber + ":" + marker.startColumn);
    const model = this._editor.getModel();
    if (model && marker.startLineNumber <= model.getLineCount() && marker.startLineNumber >= 1) {
      const lineContent = model.getLineContent(marker.startLineNumber);
      ariaLabel = `${lineContent}, ${ariaLabel}`;
    }
    return ariaLabel;
  }
};
var MarkerNavigationWidget = MarkerNavigationWidget_1 = class MarkerNavigationWidget2 extends PeekViewWidget {
  constructor(editor2, _themeService, _openerService, _menuService, instantiationService, _contextKeyService, _labelService) {
    super(editor2, { showArrow: true, showFrame: true, isAccessible: true, frameWidth: 1 }, instantiationService);
    this._themeService = _themeService;
    this._openerService = _openerService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._labelService = _labelService;
    this._callOnDispose = new DisposableStore();
    this._onDidSelectRelatedInformation = new Emitter();
    this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;
    this._severity = MarkerSeverity.Warning;
    this._backgroundColor = Color.white;
    this._applyTheme(_themeService.getColorTheme());
    this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this.create();
  }
  _applyTheme(theme) {
    this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);
    let colorId = editorMarkerNavigationError;
    let headerBackground = editorMarkerNavigationErrorHeader;
    if (this._severity === MarkerSeverity.Warning) {
      colorId = editorMarkerNavigationWarning;
      headerBackground = editorMarkerNavigationWarningHeader;
    } else if (this._severity === MarkerSeverity.Info) {
      colorId = editorMarkerNavigationInfo;
      headerBackground = editorMarkerNavigationInfoHeader;
    }
    const frameColor = theme.getColor(colorId);
    const headerBg = theme.getColor(headerBackground);
    this.style({
      arrowColor: frameColor,
      frameColor,
      headerBackgroundColor: headerBg,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  _applyStyles() {
    if (this._parentContainer) {
      this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : "";
    }
    super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose();
    super.dispose();
  }
  focus() {
    this._parentContainer.focus();
  }
  _fillHead(container) {
    super._fillHead(container);
    this._disposables.add(this._actionbarWidget.actionRunner.onWillRun((e) => this.editor.focus()));
    const actions = [];
    const menu = this._menuService.createMenu(MarkerNavigationWidget_1.TitleMenu, this._contextKeyService);
    createAndFillInActionBarActions(menu, void 0, actions);
    this._actionbarWidget.push(actions, { label: false, icon: true, index: 0 });
    menu.dispose();
  }
  _fillTitleIcon(container) {
    this._icon = append(container, $(""));
  }
  _fillBody(container) {
    this._parentContainer = container;
    container.classList.add("marker-widget");
    this._parentContainer.tabIndex = 0;
    this._parentContainer.setAttribute("role", "tooltip");
    this._container = document.createElement("div");
    container.appendChild(this._container);
    this._message = new MessageWidget(this._container, this.editor, (related) => this._onDidSelectRelatedInformation.fire(related), this._openerService, this._labelService);
    this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(marker, markerIdx, markerCount) {
    this._container.classList.remove("stale");
    this._message.update(marker);
    this._severity = marker.severity;
    this._applyTheme(this._themeService.getColorTheme());
    const range = Range.lift(marker);
    const editorPosition = this.editor.getPosition();
    const position = editorPosition && range.containsPosition(editorPosition) ? editorPosition : range.getStartPosition();
    super.show(position, this.computeRequiredHeight());
    const model = this.editor.getModel();
    if (model) {
      const detail = markerCount > 1 ? localize("problems", "{0} of {1} problems", markerIdx, markerCount) : localize("change", "{0} of {1} problem", markerIdx, markerCount);
      this.setTitle(basename(model.uri), detail);
    }
    this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity.toSeverity(this._severity))}`;
    this.editor.revealPositionNearTop(
      position,
      0
      /* ScrollType.Smooth */
    );
    this.editor.focus();
  }
  updateMarker(marker) {
    this._container.classList.remove("stale");
    this._message.update(marker);
  }
  showStale() {
    this._container.classList.add("stale");
    this._relayout();
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._heightInPixel = heightInPixel;
    this._message.layout(heightInPixel, widthInPixel);
    this._container.style.height = `${heightInPixel}px`;
  }
  _onWidth(widthInPixel) {
    this._message.layout(this._heightInPixel, widthInPixel);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
};
MarkerNavigationWidget.TitleMenu = new MenuId("gotoErrorTitleMenu");
MarkerNavigationWidget = MarkerNavigationWidget_1 = __decorate11([
  __param11(1, IThemeService),
  __param11(2, IOpenerService),
  __param11(3, IMenuService),
  __param11(4, IInstantiationService),
  __param11(5, IContextKeyService),
  __param11(6, ILabelService)
], MarkerNavigationWidget);
var errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
var warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
var infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
var editorMarkerNavigationError = registerColor("editorMarkerNavigationError.background", { dark: errorDefault, light: errorDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorMarkerNavigationError", "Editor marker navigation widget error color."));
var editorMarkerNavigationErrorHeader = registerColor("editorMarkerNavigationError.headerBackground", { dark: transparent(editorMarkerNavigationError, 0.1), light: transparent(editorMarkerNavigationError, 0.1), hcDark: null, hcLight: null }, localize("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background."));
var editorMarkerNavigationWarning = registerColor("editorMarkerNavigationWarning.background", { dark: warningDefault, light: warningDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorMarkerNavigationWarning", "Editor marker navigation widget warning color."));
var editorMarkerNavigationWarningHeader = registerColor("editorMarkerNavigationWarning.headerBackground", { dark: transparent(editorMarkerNavigationWarning, 0.1), light: transparent(editorMarkerNavigationWarning, 0.1), hcDark: "#0C141F", hcLight: transparent(editorMarkerNavigationWarning, 0.2) }, localize("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background."));
var editorMarkerNavigationInfo = registerColor("editorMarkerNavigationInfo.background", { dark: infoDefault, light: infoDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorMarkerNavigationInfo", "Editor marker navigation widget info color."));
var editorMarkerNavigationInfoHeader = registerColor("editorMarkerNavigationInfo.headerBackground", { dark: transparent(editorMarkerNavigationInfo, 0.1), light: transparent(editorMarkerNavigationInfo, 0.1), hcDark: null, hcLight: null }, localize("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background."));
var editorMarkerNavigationBackground = registerColor("editorMarkerNavigation.background", { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, localize("editorMarkerNavigationBackground", "Editor marker navigation widget background."));

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MarkerController_1;
var MarkerController = MarkerController_1 = class MarkerController2 {
  static get(editor2) {
    return editor2.getContribution(MarkerController_1.ID);
  }
  constructor(editor2, _markerNavigationService, _contextKeyService, _editorService, _instantiationService) {
    this._markerNavigationService = _markerNavigationService;
    this._contextKeyService = _contextKeyService;
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._sessionDispoables = new DisposableStore();
    this._editor = editor2;
    this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
  }
  dispose() {
    this._cleanUp();
    this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset();
    this._sessionDispoables.clear();
    this._widget = void 0;
    this._model = void 0;
  }
  _getOrCreateModel(uri) {
    if (this._model && this._model.matches(uri)) {
      return this._model;
    }
    let reusePosition = false;
    if (this._model) {
      reusePosition = true;
      this._cleanUp();
    }
    this._model = this._markerNavigationService.getMarkerList(uri);
    if (reusePosition) {
      this._model.move(true, this._editor.getModel(), this._editor.getPosition());
    }
    this._widget = this._instantiationService.createInstance(MarkerNavigationWidget, this._editor);
    this._widget.onDidClose(() => this.close(), this, this._sessionDispoables);
    this._widgetVisible.set(true);
    this._sessionDispoables.add(this._model);
    this._sessionDispoables.add(this._widget);
    this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((e) => {
      var _a, _b, _c;
      if (!((_a = this._model) === null || _a === void 0 ? void 0 : _a.selected) || !Range.containsPosition((_b = this._model) === null || _b === void 0 ? void 0 : _b.selected.marker, e.position)) {
        (_c = this._model) === null || _c === void 0 ? void 0 : _c.resetIndex();
      }
    }));
    this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model) {
        return;
      }
      const info = this._model.find(this._editor.getModel().uri, this._widget.position);
      if (info) {
        this._widget.updateMarker(info.marker);
      } else {
        this._widget.showStale();
      }
    }));
    this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((related) => {
      this._editorService.openCodeEditor({
        resource: related.resource,
        options: { pinned: true, revealIfOpened: true, selection: Range.lift(related).collapseToStart() }
      }, this._editor);
      this.close(false);
    }));
    this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp()));
    return this._model;
  }
  close(focusEditor = true) {
    this._cleanUp();
    if (focusEditor) {
      this._editor.focus();
    }
  }
  showAtMarker(marker) {
    if (this._editor.hasModel()) {
      const model = this._getOrCreateModel(this._editor.getModel().uri);
      model.resetIndex();
      model.move(true, this._editor.getModel(), new Position(marker.startLineNumber, marker.startColumn));
      if (model.selected) {
        this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
      }
    }
  }
  nagivate(next, multiFile) {
    var _a, _b;
    return __awaiter12(this, void 0, void 0, function* () {
      if (this._editor.hasModel()) {
        const model = this._getOrCreateModel(multiFile ? void 0 : this._editor.getModel().uri);
        model.move(next, this._editor.getModel(), this._editor.getPosition());
        if (!model.selected) {
          return;
        }
        if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
          this._cleanUp();
          const otherEditor = yield this._editorService.openCodeEditor({
            resource: model.selected.marker.resource,
            options: { pinned: false, revealIfOpened: true, selectionRevealType: 2, selection: model.selected.marker }
          }, this._editor);
          if (otherEditor) {
            (_a = MarkerController_1.get(otherEditor)) === null || _a === void 0 ? void 0 : _a.close();
            (_b = MarkerController_1.get(otherEditor)) === null || _b === void 0 ? void 0 : _b.nagivate(next, multiFile);
          }
        } else {
          this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
        }
      }
    });
  }
};
MarkerController.ID = "editor.contrib.markerController";
MarkerController = MarkerController_1 = __decorate12([
  __param12(1, IMarkerNavigationService),
  __param12(2, IContextKeyService),
  __param12(3, ICodeEditorService),
  __param12(4, IInstantiationService)
], MarkerController);
var MarkerNavigationAction = class extends EditorAction {
  constructor(_next, _multiFile, opts) {
    super(opts);
    this._next = _next;
    this._multiFile = _multiFile;
  }
  run(_accessor, editor2) {
    var _a;
    return __awaiter12(this, void 0, void 0, function* () {
      if (editor2.hasModel()) {
        (_a = MarkerController.get(editor2)) === null || _a === void 0 ? void 0 : _a.nagivate(this._next, this._multiFile);
      }
    });
  }
};
var NextMarkerAction = class _NextMarkerAction extends MarkerNavigationAction {
  constructor() {
    super(true, false, {
      id: _NextMarkerAction.ID,
      label: _NextMarkerAction.LABEL,
      alias: "Go to Next Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 512 | 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: _NextMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-next", Codicon.arrowDown, localize("nextMarkerIcon", "Icon for goto next marker.")),
        group: "navigation",
        order: 1
      }
    });
  }
};
NextMarkerAction.ID = "editor.action.marker.next";
NextMarkerAction.LABEL = localize("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
var PrevMarkerAction = class _PrevMarkerAction extends MarkerNavigationAction {
  constructor() {
    super(false, false, {
      id: _PrevMarkerAction.ID,
      label: _PrevMarkerAction.LABEL,
      alias: "Go to Previous Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 512 | 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: _PrevMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-previous", Codicon.arrowUp, localize("previousMarkerIcon", "Icon for goto previous marker.")),
        group: "navigation",
        order: 2
      }
    });
  }
};
PrevMarkerAction.ID = "editor.action.marker.prev";
PrevMarkerAction.LABEL = localize("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
var NextMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(true, true, {
      id: "editor.action.marker.nextInFiles",
      label: localize("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
      alias: "Go to Next Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
};
var PrevMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(false, true, {
      id: "editor.action.marker.prevInFiles",
      label: localize("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
      alias: "Go to Previous Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
};
registerEditorContribution(
  MarkerController.ID,
  MarkerController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(NextMarkerAction);
registerEditorAction(PrevMarkerAction);
registerEditorAction(NextMarkerInFilesAction);
registerEditorAction(PrevMarkerInFilesAction);
var CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey("markersNavigationVisible", false);
var MarkerCommand = EditorCommand.bindToContribution(MarkerController.get);
registerEditorCommand(new MarkerCommand({
  id: "closeMarkersNavigation",
  precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
  handler: (x) => x.close(),
  kbOpts: {
    weight: 100 + 50,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markerHoverParticipant.js
init_nls();
init_opener();
init_progress();
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $7 = $;
var MarkerHover = class {
  constructor(owner, range, marker) {
    this.owner = owner;
    this.range = range;
    this.marker = marker;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var markerCodeActionTrigger = {
  type: 1,
  filter: { include: CodeActionKind.QuickFix },
  triggerAction: CodeActionTriggerSource.QuickFixHover
};
var MarkerHoverParticipant = class MarkerHoverParticipant2 {
  constructor(_editor, _markerDecorationsService, _openerService, _languageFeaturesService) {
    this._editor = _editor;
    this._markerDecorationsService = _markerDecorationsService;
    this._openerService = _openerService;
    this._languageFeaturesService = _languageFeaturesService;
    this.hoverOrdinal = 1;
    this.recentMarkerCodeActionsInfo = void 0;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1 && !anchor.supportsMarkerHover) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const marker = this._markerDecorationsService.getMarker(model.uri, d);
      if (!marker) {
        continue;
      }
      const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkerHover(this, range, marker));
    }
    return result;
  }
  renderHoverParts(context, hoverParts) {
    if (!hoverParts.length) {
      return Disposable.None;
    }
    const disposables = new DisposableStore();
    hoverParts.forEach((msg) => context.fragment.appendChild(this.renderMarkerHover(msg, disposables)));
    const markerHoverForStatusbar = hoverParts.length === 1 ? hoverParts[0] : hoverParts.sort((a, b) => MarkerSeverity.compare(a.marker.severity, b.marker.severity))[0];
    this.renderMarkerStatusbar(context, markerHoverForStatusbar, disposables);
    return disposables;
  }
  renderMarkerHover(markerHover, disposables) {
    const hoverElement = $7("div.hover-row");
    const markerElement = append(hoverElement, $7("div.marker.hover-contents"));
    const { source, message, code, relatedInformation } = markerHover.marker;
    this._editor.applyFontInfo(markerElement);
    const messageElement = append(markerElement, $7("span"));
    messageElement.style.whiteSpace = "pre-wrap";
    messageElement.innerText = message;
    if (source || code) {
      if (code && typeof code !== "string") {
        const sourceAndCodeElement = $7("span");
        if (source) {
          const sourceElement = append(sourceAndCodeElement, $7("span"));
          sourceElement.innerText = source;
        }
        const codeLink = append(sourceAndCodeElement, $7("a.code-link"));
        codeLink.setAttribute("href", code.target.toString());
        disposables.add(addDisposableListener(codeLink, "click", (e) => {
          this._openerService.open(code.target, { allowCommands: true });
          e.preventDefault();
          e.stopPropagation();
        }));
        const codeElement = append(codeLink, $7("span"));
        codeElement.innerText = code.value;
        const detailsElement = append(markerElement, sourceAndCodeElement);
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
      } else {
        const detailsElement = append(markerElement, $7("span"));
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
        detailsElement.innerText = source && code ? `${source}(${code})` : source ? source : `(${code})`;
      }
    }
    if (isNonEmptyArray(relatedInformation)) {
      for (const { message: message2, resource, startLineNumber, startColumn } of relatedInformation) {
        const relatedInfoContainer = append(markerElement, $7("div"));
        relatedInfoContainer.style.marginTop = "8px";
        const a = append(relatedInfoContainer, $7("a"));
        a.innerText = `${basename(resource)}(${startLineNumber}, ${startColumn}): `;
        a.style.cursor = "pointer";
        disposables.add(addDisposableListener(a, "click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (this._openerService) {
            this._openerService.open(resource, {
              fromUserGesture: true,
              editorOptions: { selection: { startLineNumber, startColumn } }
            }).catch(onUnexpectedError);
          }
        }));
        const messageElement2 = append(relatedInfoContainer, $7("span"));
        messageElement2.innerText = message2;
        this._editor.applyFontInfo(messageElement2);
      }
    }
    return hoverElement;
  }
  renderMarkerStatusbar(context, markerHover, disposables) {
    if (markerHover.marker.severity === MarkerSeverity.Error || markerHover.marker.severity === MarkerSeverity.Warning || markerHover.marker.severity === MarkerSeverity.Info) {
      context.statusBar.addAction({
        label: localize("view problem", "View Problem"),
        commandId: NextMarkerAction.ID,
        run: () => {
          var _a;
          context.hide();
          (_a = MarkerController.get(this._editor)) === null || _a === void 0 ? void 0 : _a.showAtMarker(markerHover.marker);
          this._editor.focus();
        }
      });
    }
    if (!this._editor.getOption(
      89
      /* EditorOption.readOnly */
    )) {
      const quickfixPlaceholderElement = context.statusBar.append($7("div"));
      if (this.recentMarkerCodeActionsInfo) {
        if (IMarkerData.makeKey(this.recentMarkerCodeActionsInfo.marker) === IMarkerData.makeKey(markerHover.marker)) {
          if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
            quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
          }
        } else {
          this.recentMarkerCodeActionsInfo = void 0;
        }
      }
      const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? Disposable.None : disposables.add(disposableTimeout(() => quickfixPlaceholderElement.textContent = localize("checkingForQuickFixes", "Checking for quick fixes..."), 200));
      if (!quickfixPlaceholderElement.textContent) {
        quickfixPlaceholderElement.textContent = String.fromCharCode(160);
      }
      const codeActionsPromise = this.getCodeActions(markerHover.marker);
      disposables.add(toDisposable(() => codeActionsPromise.cancel()));
      codeActionsPromise.then((actions) => {
        updatePlaceholderDisposable.dispose();
        this.recentMarkerCodeActionsInfo = { marker: markerHover.marker, hasCodeActions: actions.validActions.length > 0 };
        if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
          actions.dispose();
          quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
          return;
        }
        quickfixPlaceholderElement.style.display = "none";
        let showing = false;
        disposables.add(toDisposable(() => {
          if (!showing) {
            actions.dispose();
          }
        }));
        context.statusBar.addAction({
          label: localize("quick fixes", "Quick Fix..."),
          commandId: quickFixCommandId,
          run: (target) => {
            showing = true;
            const controller = CodeActionController.get(this._editor);
            const elementPosition = getDomNodePagePosition(target);
            context.hide();
            controller === null || controller === void 0 ? void 0 : controller.showCodeActions(markerCodeActionTrigger, actions, {
              x: elementPosition.left,
              y: elementPosition.top,
              width: elementPosition.width,
              height: elementPosition.height
            });
          }
        });
      }, onUnexpectedError);
    }
  }
  getCodeActions(marker) {
    return createCancelablePromise((cancellationToken) => {
      return getCodeActions(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), markerCodeActionTrigger, Progress.None, cancellationToken);
    });
  }
};
MarkerHoverParticipant = __decorate13([
  __param13(1, IMarkerDecorationsService),
  __param13(2, IOpenerService),
  __param13(3, ILanguageFeaturesService)
], MarkerHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js
init_nls();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.css";
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ModesHoverController_1;
var _sticky = false;
var ModesHoverController = ModesHoverController_1 = class ModesHoverController2 {
  getWidgetContent() {
    var _a;
    return (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.getWidgetContent();
  }
  static get(editor2) {
    return editor2.getContribution(ModesHoverController_1.ID);
  }
  constructor(_editor, _instantiationService, _openerService, _languageService, _keybindingService) {
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._openerService = _openerService;
    this._languageService = _languageService;
    this._keybindingService = _keybindingService;
    this._toUnhook = new DisposableStore();
    this._hoverActivatedByColorDecoratorClick = false;
    this._isMouseDown = false;
    this._hoverClicked = false;
    this._contentWidget = null;
    this._glyphWidget = null;
    this._hookEvents();
    this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        59
        /* EditorOption.hover */
      )) {
        this._unhookEvents();
        this._hookEvents();
      }
    });
  }
  _hookEvents() {
    const hideWidgetsEventHandler = () => this._hideWidgets();
    const hoverOpts = this._editor.getOption(
      59
      /* EditorOption.hover */
    );
    this._isHoverEnabled = hoverOpts.enabled;
    this._isHoverSticky = hoverOpts.sticky;
    if (this._isHoverEnabled) {
      this._toUnhook.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
      this._toUnhook.add(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
      this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    } else {
      this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    }
    this._toUnhook.add(this._editor.onMouseLeave((e) => this._onEditorMouseLeave(e)));
    this._toUnhook.add(this._editor.onDidChangeModel(hideWidgetsEventHandler));
    this._toUnhook.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));
  }
  _unhookEvents() {
    this._toUnhook.clear();
  }
  _onEditorScrollChanged(e) {
    if (e.scrollTopChanged || e.scrollLeftChanged) {
      this._hideWidgets();
    }
  }
  _onEditorMouseDown(mouseEvent) {
    var _a;
    this._isMouseDown = true;
    const target = mouseEvent.target;
    if (target.type === 9 && target.detail === ContentHoverWidget.ID) {
      this._hoverClicked = true;
      return;
    }
    if (target.type === 12 && target.detail === MarginHoverWidget.ID) {
      return;
    }
    if (target.type !== 12) {
      this._hoverClicked = false;
    }
    if (!((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.widget.isResizing)) {
      this._hideWidgets();
    }
  }
  _onEditorMouseUp(mouseEvent) {
    this._isMouseDown = false;
  }
  _onEditorMouseLeave(mouseEvent) {
    var _a, _b;
    const targetEm = mouseEvent.event.browserEvent.relatedTarget;
    if (((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.widget.isResizing) || ((_b = this._contentWidget) === null || _b === void 0 ? void 0 : _b.containsNode(targetEm))) {
      return;
    }
    if (!_sticky) {
      this._hideWidgets();
    }
  }
  _onEditorMouseMove(mouseEvent) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const target = mouseEvent.target;
    if (((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isFocused) || ((_b = this._contentWidget) === null || _b === void 0 ? void 0 : _b.isResizing)) {
      return;
    }
    if (this._isMouseDown && this._hoverClicked) {
      return;
    }
    if (this._isHoverSticky && target.type === 9 && target.detail === ContentHoverWidget.ID) {
      return;
    }
    if (this._isHoverSticky && ((_c = this._contentWidget) === null || _c === void 0 ? void 0 : _c.containsNode((_d = mouseEvent.event.browserEvent.view) === null || _d === void 0 ? void 0 : _d.document.activeElement)) && !((_f = (_e = mouseEvent.event.browserEvent.view) === null || _e === void 0 ? void 0 : _e.getSelection()) === null || _f === void 0 ? void 0 : _f.isCollapsed)) {
      return;
    }
    if (!this._isHoverSticky && target.type === 9 && target.detail === ContentHoverWidget.ID && ((_g = this._contentWidget) === null || _g === void 0 ? void 0 : _g.isColorPickerVisible)) {
      return;
    }
    if (this._isHoverSticky && target.type === 12 && target.detail === MarginHoverWidget.ID) {
      return;
    }
    if (this._isHoverSticky && ((_h = this._contentWidget) === null || _h === void 0 ? void 0 : _h.isVisibleFromKeyboard)) {
      return;
    }
    const mouseOnDecorator = (_j = target.element) === null || _j === void 0 ? void 0 : _j.classList.contains("colorpicker-color-decoration");
    const decoratorActivatedOn = this._editor.getOption(
      145
      /* EditorOption.colorDecoratorsActivatedOn */
    );
    if (mouseOnDecorator && (decoratorActivatedOn === "click" && !this._hoverActivatedByColorDecoratorClick || decoratorActivatedOn === "hover" && !this._isHoverEnabled && !_sticky || decoratorActivatedOn === "clickAndHover" && !this._isHoverEnabled && !this._hoverActivatedByColorDecoratorClick) || !mouseOnDecorator && !this._isHoverEnabled && !this._hoverActivatedByColorDecoratorClick) {
      this._hideWidgets();
      return;
    }
    const contentWidget = this._getOrCreateContentWidget();
    if (contentWidget.maybeShowAt(mouseEvent)) {
      (_k = this._glyphWidget) === null || _k === void 0 ? void 0 : _k.hide();
      return;
    }
    if (target.type === 2 && target.position) {
      (_l = this._contentWidget) === null || _l === void 0 ? void 0 : _l.hide();
      if (!this._glyphWidget) {
        this._glyphWidget = new MarginHoverWidget(this._editor, this._languageService, this._openerService);
      }
      this._glyphWidget.startShowingAt(target.position.lineNumber);
      return;
    }
    if (_sticky) {
      return;
    }
    this._hideWidgets();
  }
  _onKeyDown(e) {
    var _a;
    if (!this._editor.hasModel()) {
      return;
    }
    const resolvedKeyboardEvent = this._keybindingService.softDispatch(e, this._editor.getDomNode());
    const mightTriggerFocus = resolvedKeyboardEvent.kind === 1 || resolvedKeyboardEvent.kind === 2 && resolvedKeyboardEvent.commandId === "editor.action.showHover" && ((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isVisible);
    if (e.keyCode !== 5 && e.keyCode !== 6 && e.keyCode !== 57 && e.keyCode !== 4 && !mightTriggerFocus) {
      this._hideWidgets();
    }
  }
  _hideWidgets() {
    var _a, _b, _c;
    if (_sticky) {
      return;
    }
    if (this._isMouseDown && this._hoverClicked && ((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isColorPickerVisible) || InlineSuggestionHintsContentWidget.dropDownVisible) {
      return;
    }
    this._hoverActivatedByColorDecoratorClick = false;
    this._hoverClicked = false;
    (_b = this._glyphWidget) === null || _b === void 0 ? void 0 : _b.hide();
    (_c = this._contentWidget) === null || _c === void 0 ? void 0 : _c.hide();
  }
  _getOrCreateContentWidget() {
    if (!this._contentWidget) {
      this._contentWidget = this._instantiationService.createInstance(ContentHoverController, this._editor);
    }
    return this._contentWidget;
  }
  showContentHover(range, mode, source, focus, activatedByColorDecoratorClick = false) {
    this._hoverActivatedByColorDecoratorClick = activatedByColorDecoratorClick;
    this._getOrCreateContentWidget().startShowingAtRange(range, mode, source, focus);
  }
  focus() {
    var _a;
    (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.focus();
  }
  scrollUp() {
    var _a;
    (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.scrollUp();
  }
  scrollDown() {
    var _a;
    (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.scrollDown();
  }
  scrollLeft() {
    var _a;
    (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.scrollLeft();
  }
  scrollRight() {
    var _a;
    (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.scrollRight();
  }
  pageUp() {
    var _a;
    (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.pageUp();
  }
  pageDown() {
    var _a;
    (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.pageDown();
  }
  goToTop() {
    var _a;
    (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.goToTop();
  }
  goToBottom() {
    var _a;
    (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.goToBottom();
  }
  get isColorPickerVisible() {
    var _a;
    return (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isColorPickerVisible;
  }
  get isHoverVisible() {
    var _a;
    return (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isVisible;
  }
  dispose() {
    var _a, _b;
    this._unhookEvents();
    this._toUnhook.dispose();
    this._didChangeConfigurationHandler.dispose();
    (_a = this._glyphWidget) === null || _a === void 0 ? void 0 : _a.dispose();
    (_b = this._contentWidget) === null || _b === void 0 ? void 0 : _b.dispose();
  }
};
ModesHoverController.ID = "editor.contrib.hover";
ModesHoverController = ModesHoverController_1 = __decorate14([
  __param14(1, IInstantiationService),
  __param14(2, IOpenerService),
  __param14(3, ILanguageService),
  __param14(4, IKeybindingService)
], ModesHoverController);
var ShowOrFocusHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showHover",
      label: localize({
        key: "showOrFocusHover",
        comment: [
          "Label for action that will trigger the showing/focusing of a hover in the editor.",
          "If the hover is not visible, it will show the hover.",
          "This allows for users to show the hover without using the mouse.",
          "If the hover is already visible, it will take focus."
        ]
      }, "Show or Focus Hover"),
      description: {
        description: `Show or Focus Hover`,
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "focus": {
                description: "Controls if when triggered with the keyboard, the hover should take focus immediately.",
                type: "boolean",
                default: false
              }
            }
          }
        }]
      },
      alias: "Show or Focus Hover",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 39
          /* KeyCode.KeyI */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const position = editor2.getPosition();
    const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
    const focus = editor2.getOption(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 || !!(args === null || args === void 0 ? void 0 : args.focus);
    if (controller.isHoverVisible) {
      controller.focus();
    } else {
      controller.showContentHover(range, 1, 1, focus);
    }
  }
};
var ShowDefinitionPreviewHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showDefinitionPreviewHover",
      label: localize({
        key: "showDefinitionPreviewHover",
        comment: [
          "Label for action that will trigger the showing of definition preview hover in the editor.",
          "This allows for users to show the definition preview hover without using the mouse."
        ]
      }, "Show Definition Preview Hover"),
      alias: "Show Definition Preview Hover",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const position = editor2.getPosition();
    if (!position) {
      return;
    }
    const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
    const goto = GotoDefinitionAtPositionEditorContribution.get(editor2);
    if (!goto) {
      return;
    }
    const promise = goto.startFindDefinitionFromCursor(position);
    promise.then(() => {
      controller.showContentHover(range, 1, 1, true);
    });
  }
};
var ScrollUpHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.scrollUpHover",
      label: localize({
        key: "scrollUpHover",
        comment: [
          "Action that allows to scroll up in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Up Hover"),
      alias: "Scroll Up Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 16,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollUp();
  }
};
var ScrollDownHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.scrollDownHover",
      label: localize({
        key: "scrollDownHover",
        comment: [
          "Action that allows to scroll down in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Down Hover"),
      alias: "Scroll Down Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 18,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollDown();
  }
};
var ScrollLeftHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.scrollLeftHover",
      label: localize({
        key: "scrollLeftHover",
        comment: [
          "Action that allows to scroll left in the hover widget with the left arrow when the hover widget is focused."
        ]
      }, "Scroll Left Hover"),
      alias: "Scroll Left Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 15,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollLeft();
  }
};
var ScrollRightHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.scrollRightHover",
      label: localize({
        key: "scrollRightHover",
        comment: [
          "Action that allows to scroll right in the hover widget with the right arrow when the hover widget is focused."
        ]
      }, "Scroll Right Hover"),
      alias: "Scroll Right Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 17,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollRight();
  }
};
var PageUpHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.pageUpHover",
      label: localize({
        key: "pageUpHover",
        comment: [
          "Action that allows to page up in the hover widget with the page up command when the hover widget is focused."
        ]
      }, "Page Up Hover"),
      alias: "Page Up Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 11,
        secondary: [
          512 | 16
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.pageUp();
  }
};
var PageDownHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.pageDownHover",
      label: localize({
        key: "pageDownHover",
        comment: [
          "Action that allows to page down in the hover widget with the page down command when the hover widget is focused."
        ]
      }, "Page Down Hover"),
      alias: "Page Down Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 12,
        secondary: [
          512 | 18
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.pageDown();
  }
};
var GoToTopHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToTopHover",
      label: localize({
        key: "goToTopHover",
        comment: [
          "Action that allows to go to the top of the hover widget with the home command when the hover widget is focused."
        ]
      }, "Go To Top Hover"),
      alias: "Go To Bottom Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 14,
        secondary: [
          2048 | 16
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.goToTop();
  }
};
var GoToBottomHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToBottomHover",
      label: localize({
        key: "goToBottomHover",
        comment: [
          "Action that allows to go to the bottom in the hover widget with the end command when the hover widget is focused."
        ]
      }, "Go To Bottom Hover"),
      alias: "Go To Bottom Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 13,
        secondary: [
          2048 | 18
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.goToBottom();
  }
};
registerEditorContribution(
  ModesHoverController.ID,
  ModesHoverController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(ShowOrFocusHoverAction);
registerEditorAction(ShowDefinitionPreviewHoverAction);
registerEditorAction(ScrollUpHoverAction);
registerEditorAction(ScrollDownHoverAction);
registerEditorAction(ScrollLeftHoverAction);
registerEditorAction(ScrollRightHoverAction);
registerEditorAction(PageUpHoverAction);
registerEditorAction(PageDownHoverAction);
registerEditorAction(GoToTopHoverAction);
registerEditorAction(GoToBottomHoverAction);
HoverParticipantRegistry.register(MarkdownHoverParticipant);
HoverParticipantRegistry.register(MarkerHoverParticipant);
registerThemingParticipant((theme, collector) => {
  const hoverBorder = theme.getColor(editorHoverBorder);
  if (hoverBorder) {
    collector.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${hoverBorder.transparent(0.5)}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorContributions.js
var ColorContribution = class extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._register(_editor.onMouseDown((e) => this.onMouseDown(e)));
  }
  dispose() {
    super.dispose();
  }
  onMouseDown(mouseEvent) {
    const colorDecoratorsActivatedOn = this._editor.getOption(
      145
      /* EditorOption.colorDecoratorsActivatedOn */
    );
    if (colorDecoratorsActivatedOn !== "click" && colorDecoratorsActivatedOn !== "clickAndHover") {
      return;
    }
    const target = mouseEvent.target;
    if (target.type !== 6) {
      return;
    }
    if (!target.detail.injectedText) {
      return;
    }
    if (target.detail.injectedText.options.attachedData !== ColorDecorationInjectedTextMarker) {
      return;
    }
    if (!target.range) {
      return;
    }
    const hoverController = this._editor.getContribution(ModesHoverController.ID);
    if (!hoverController) {
      return;
    }
    if (!hoverController.isColorPickerVisible) {
      const range = new Range(target.range.startLineNumber, target.range.startColumn + 1, target.range.endLineNumber, target.range.endColumn + 1);
      hoverController.showContentHover(range, 1, 0, false, true);
    }
  }
};
ColorContribution.ID = "editor.contrib.colorContribution";
ColorContribution.RECOMPUTE_TIME = 1e3;
registerEditorContribution(
  ColorContribution.ID,
  ColorContribution,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
HoverParticipantRegistry.register(ColorHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions.js
init_editorExtensions();
init_nls();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPickerWidget.js
init_lifecycle();
init_instantiation();
init_event();
init_languageFeatures();
init_editorExtensions();
init_editorContextKeys();
init_contextkey();
init_model2();
init_languageConfigurationRegistry();
init_dom();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StandaloneColorPickerController_1;
var StandaloneColorPickerWidget_1;
var StandaloneColorPickerController = StandaloneColorPickerController_1 = class StandaloneColorPickerController2 extends Disposable {
  constructor(_editor, _contextKeyService, _modelService, _keybindingService, _instantiationService, _languageFeatureService, _languageConfigurationService) {
    super();
    this._editor = _editor;
    this._modelService = _modelService;
    this._keybindingService = _keybindingService;
    this._instantiationService = _instantiationService;
    this._languageFeatureService = _languageFeatureService;
    this._languageConfigurationService = _languageConfigurationService;
    this._standaloneColorPickerWidget = null;
    this._standaloneColorPickerVisible = EditorContextKeys.standaloneColorPickerVisible.bindTo(_contextKeyService);
    this._standaloneColorPickerFocused = EditorContextKeys.standaloneColorPickerFocused.bindTo(_contextKeyService);
  }
  showOrFocus() {
    var _a;
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._standaloneColorPickerVisible.get()) {
      this._standaloneColorPickerWidget = new StandaloneColorPickerWidget(this._editor, this._standaloneColorPickerVisible, this._standaloneColorPickerFocused, this._instantiationService, this._modelService, this._keybindingService, this._languageFeatureService, this._languageConfigurationService);
    } else if (!this._standaloneColorPickerFocused.get()) {
      (_a = this._standaloneColorPickerWidget) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }
  hide() {
    var _a;
    this._standaloneColorPickerFocused.set(false);
    this._standaloneColorPickerVisible.set(false);
    (_a = this._standaloneColorPickerWidget) === null || _a === void 0 ? void 0 : _a.hide();
    this._editor.focus();
  }
  insertColor() {
    var _a;
    (_a = this._standaloneColorPickerWidget) === null || _a === void 0 ? void 0 : _a.updateEditor();
    this.hide();
  }
  static get(editor2) {
    return editor2.getContribution(StandaloneColorPickerController_1.ID);
  }
};
StandaloneColorPickerController.ID = "editor.contrib.standaloneColorPickerController";
StandaloneColorPickerController = StandaloneColorPickerController_1 = __decorate15([
  __param15(1, IContextKeyService),
  __param15(2, IModelService),
  __param15(3, IKeybindingService),
  __param15(4, IInstantiationService),
  __param15(5, ILanguageFeaturesService),
  __param15(6, ILanguageConfigurationService)
], StandaloneColorPickerController);
registerEditorContribution(
  StandaloneColorPickerController.ID,
  StandaloneColorPickerController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
var PADDING = 8;
var CLOSE_BUTTON_WIDTH = 22;
var StandaloneColorPickerWidget = StandaloneColorPickerWidget_1 = class StandaloneColorPickerWidget2 extends Disposable {
  constructor(_editor, _standaloneColorPickerVisible, _standaloneColorPickerFocused, _instantiationService, _modelService, _keybindingService, _languageFeaturesService, _languageConfigurationService) {
    var _a;
    super();
    this._editor = _editor;
    this._standaloneColorPickerVisible = _standaloneColorPickerVisible;
    this._standaloneColorPickerFocused = _standaloneColorPickerFocused;
    this._modelService = _modelService;
    this._keybindingService = _keybindingService;
    this._languageFeaturesService = _languageFeaturesService;
    this._languageConfigurationService = _languageConfigurationService;
    this.allowEditorOverflow = true;
    this._position = void 0;
    this._body = document.createElement("div");
    this._colorHover = null;
    this._selectionSetInEditor = false;
    this._onResult = this._register(new Emitter());
    this.onResult = this._onResult.event;
    this._standaloneColorPickerVisible.set(true);
    this._standaloneColorPickerParticipant = _instantiationService.createInstance(StandaloneColorPickerParticipant, this._editor);
    this._position = (_a = this._editor._getViewModel()) === null || _a === void 0 ? void 0 : _a.getPrimaryCursorState().modelState.position;
    const editorSelection = this._editor.getSelection();
    const selection = editorSelection ? {
      startLineNumber: editorSelection.startLineNumber,
      startColumn: editorSelection.startColumn,
      endLineNumber: editorSelection.endLineNumber,
      endColumn: editorSelection.endColumn
    } : { startLineNumber: 0, endLineNumber: 0, endColumn: 0, startColumn: 0 };
    const focusTracker = this._register(trackFocus(this._body));
    this._register(focusTracker.onDidBlur((_) => {
      this.hide();
    }));
    this._register(focusTracker.onDidFocus((_) => {
      this.focus();
    }));
    this._register(this._editor.onDidChangeCursorPosition(() => {
      if (!this._selectionSetInEditor) {
        this.hide();
      } else {
        this._selectionSetInEditor = false;
      }
    }));
    this._register(this._editor.onMouseMove((e) => {
      var _a2;
      const classList = (_a2 = e.target.element) === null || _a2 === void 0 ? void 0 : _a2.classList;
      if (classList && classList.contains("colorpicker-color-decoration")) {
        this.hide();
      }
    }));
    this._register(this.onResult((result) => {
      this._render(result.value, result.foundInEditor);
    }));
    this._start(selection);
    this._body.style.zIndex = "50";
    this._editor.addContentWidget(this);
  }
  updateEditor() {
    if (this._colorHover) {
      this._standaloneColorPickerParticipant.updateEditorModel(this._colorHover);
    }
  }
  getId() {
    return StandaloneColorPickerWidget_1.ID;
  }
  getDomNode() {
    return this._body;
  }
  getPosition() {
    if (!this._position) {
      return null;
    }
    const positionPreference = this._editor.getOption(
      59
      /* EditorOption.hover */
    ).above;
    return {
      position: this._position,
      secondaryPosition: this._position,
      preference: positionPreference ? [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ] : [
        2,
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ],
      positionAffinity: 2
      /* PositionAffinity.None */
    };
  }
  hide() {
    this.dispose();
    this._standaloneColorPickerVisible.set(false);
    this._standaloneColorPickerFocused.set(false);
    this._editor.removeContentWidget(this);
    this._editor.focus();
  }
  focus() {
    this._standaloneColorPickerFocused.set(true);
    this._body.focus();
  }
  _start(selection) {
    return __awaiter13(this, void 0, void 0, function* () {
      const computeAsyncResult = yield this._computeAsync(selection);
      if (!computeAsyncResult) {
        return;
      }
      this._onResult.fire(new StandaloneColorPickerResult(computeAsyncResult.result, computeAsyncResult.foundInEditor));
    });
  }
  _computeAsync(range) {
    return __awaiter13(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return null;
      }
      const colorInfo = {
        range,
        color: { red: 0, green: 0, blue: 0, alpha: 1 }
      };
      const colorHoverResult = yield this._standaloneColorPickerParticipant.createColorHover(colorInfo, new DefaultDocumentColorProvider(this._modelService, this._languageConfigurationService), this._languageFeaturesService.colorProvider);
      if (!colorHoverResult) {
        return null;
      }
      return { result: colorHoverResult.colorHover, foundInEditor: colorHoverResult.foundInEditor };
    });
  }
  _render(colorHover, foundInEditor) {
    const fragment = document.createDocumentFragment();
    const statusBar = this._register(new EditorHoverStatusBar(this._keybindingService));
    let colorPickerWidget;
    const context = {
      fragment,
      statusBar,
      setColorPicker: (widget) => colorPickerWidget = widget,
      onContentsChanged: () => {
      },
      hide: () => this.hide()
    };
    this._colorHover = colorHover;
    this._register(this._standaloneColorPickerParticipant.renderHoverParts(context, [colorHover]));
    if (colorPickerWidget === void 0) {
      return;
    }
    this._body.classList.add("standalone-colorpicker-body");
    this._body.style.maxHeight = Math.max(this._editor.getLayoutInfo().height / 4, 250) + "px";
    this._body.style.maxWidth = Math.max(this._editor.getLayoutInfo().width * 0.66, 500) + "px";
    this._body.tabIndex = 0;
    this._body.appendChild(fragment);
    colorPickerWidget.layout();
    const colorPickerBody = colorPickerWidget.body;
    const saturationBoxWidth = colorPickerBody.saturationBox.domNode.clientWidth;
    const widthOfOriginalColorBox = colorPickerBody.domNode.clientWidth - saturationBoxWidth - CLOSE_BUTTON_WIDTH - PADDING;
    const enterButton = colorPickerWidget.body.enterButton;
    enterButton === null || enterButton === void 0 ? void 0 : enterButton.onClicked(() => {
      this.updateEditor();
      this.hide();
    });
    const colorPickerHeader = colorPickerWidget.header;
    const pickedColorNode = colorPickerHeader.pickedColorNode;
    pickedColorNode.style.width = saturationBoxWidth + PADDING + "px";
    const originalColorNode = colorPickerHeader.originalColorNode;
    originalColorNode.style.width = widthOfOriginalColorBox + "px";
    const closeButton = colorPickerWidget.header.closeButton;
    closeButton === null || closeButton === void 0 ? void 0 : closeButton.onClicked(() => {
      this.hide();
    });
    if (foundInEditor) {
      if (enterButton) {
        enterButton.button.textContent = "Replace";
      }
      this._selectionSetInEditor = true;
      this._editor.setSelection(colorHover.range);
    }
    this._editor.layoutContentWidget(this);
  }
};
StandaloneColorPickerWidget.ID = "editor.contrib.standaloneColorPickerWidget";
StandaloneColorPickerWidget = StandaloneColorPickerWidget_1 = __decorate15([
  __param15(3, IInstantiationService),
  __param15(4, IModelService),
  __param15(5, IKeybindingService),
  __param15(6, ILanguageFeaturesService),
  __param15(7, ILanguageConfigurationService)
], StandaloneColorPickerWidget);
var StandaloneColorPickerResult = class {
  // The color picker result consists of: an array of color results and a boolean indicating if the color was found in the editor
  constructor(value, foundInEditor) {
    this.value = value;
    this.foundInEditor = foundInEditor;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPickerActions.js
init_editorContextKeys();
init_actions2();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
var ShowOrFocusStandaloneColorPicker = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.showOrFocusStandaloneColorPicker",
      title: {
        value: localize("showOrFocusStandaloneColorPicker", "Show or Focus Standalone Color Picker"),
        mnemonicTitle: localize({ key: "mishowOrFocusStandaloneColorPicker", comment: ["&& denotes a mnemonic"] }, "&&Show or Focus Standalone Color Picker"),
        original: "Show or Focus Standalone Color Picker"
      },
      precondition: void 0,
      menu: [
        { id: MenuId.CommandPalette }
      ]
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a;
    (_a = StandaloneColorPickerController.get(editor2)) === null || _a === void 0 ? void 0 : _a.showOrFocus();
  }
};
var HideStandaloneColorPicker = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.hideColorPicker",
      label: localize({
        key: "hideColorPicker",
        comment: [
          "Action that hides the color picker"
        ]
      }, "Hide the Color Picker"),
      alias: "Hide the Color Picker",
      precondition: EditorContextKeys.standaloneColorPickerVisible.isEqualTo(true),
      kbOpts: {
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a;
    (_a = StandaloneColorPickerController.get(editor2)) === null || _a === void 0 ? void 0 : _a.hide();
  }
};
var InsertColorWithStandaloneColorPicker = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertColorWithStandaloneColorPicker",
      label: localize({
        key: "insertColorWithStandaloneColorPicker",
        comment: [
          "Action that inserts color with standalone color picker"
        ]
      }, "Insert Color with Standalone Color Picker"),
      alias: "Insert Color with Standalone Color Picker",
      precondition: EditorContextKeys.standaloneColorPickerFocused.isEqualTo(true),
      kbOpts: {
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a;
    (_a = StandaloneColorPickerController.get(editor2)) === null || _a === void 0 ? void 0 : _a.insertColor();
  }
};
registerEditorAction(HideStandaloneColorPicker);
registerEditorAction(InsertColorWithStandaloneColorPicker);
registerAction2(ShowOrFocusStandaloneColorPicker);

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/comment.js
init_keyCodes();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_languageConfigurationRegistry();

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/blockCommentCommand.js
init_editOperation();
init_position();
init_range();
init_selection();
var BlockCommentCommand = class _BlockCommentCommand {
  constructor(selection, insertSpace, languageConfigurationService) {
    this.languageConfigurationService = languageConfigurationService;
    this._selection = selection;
    this._insertSpace = insertSpace;
    this._usedEndToken = null;
  }
  static _haystackHasNeedleAtOffset(haystack, needle, offset) {
    if (offset < 0) {
      return false;
    }
    const needleLength = needle.length;
    const haystackLength = haystack.length;
    if (offset + needleLength > haystackLength) {
      return false;
    }
    for (let i = 0; i < needleLength; i++) {
      const codeA = haystack.charCodeAt(offset + i);
      const codeB = needle.charCodeAt(i);
      if (codeA === codeB) {
        continue;
      }
      if (codeA >= 65 && codeA <= 90 && codeA + 32 === codeB) {
        continue;
      }
      if (codeB >= 65 && codeB <= 90 && codeB + 32 === codeA) {
        continue;
      }
      return false;
    }
    return true;
  }
  _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {
    const startLineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endLineNumber = selection.endLineNumber;
    const endColumn = selection.endColumn;
    const startLineText = model.getLineContent(startLineNumber);
    const endLineText = model.getLineContent(endLineNumber);
    let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);
    let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (startLineNumber === endLineNumber) {
        const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);
        if (lineBetweenTokens.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      } else {
        const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);
        const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);
        if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      }
    }
    let ops;
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32) {
        startToken = startToken + " ";
      }
      if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32) {
        endToken = " " + endToken;
        endTokenIndex -= 1;
      }
      ops = _BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    } else {
      ops = _BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);
      this._usedEndToken = ops.length === 1 ? endToken : null;
    }
    for (const op of ops) {
      builder.addTrackedEditOperation(op.range, op.text);
    }
  }
  static _createRemoveBlockCommentOperations(r, startToken, endToken) {
    const res = [];
    if (!Range.isEmpty(r)) {
      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
      res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
    } else {
      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
    }
    return res;
  }
  static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {
    const res = [];
    if (!Range.isEmpty(r)) {
      res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? " " : "")));
      res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? " " : "") + endToken));
    } else {
      res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + "  " + endToken));
    }
    return res;
  }
  getEditOperations(model, builder) {
    const startLineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    model.tokenization.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    if (inverseEditOperations.length === 2) {
      const startTokenEditOperation = inverseEditOperations[0];
      const endTokenEditOperation = inverseEditOperations[1];
      return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
    } else {
      const srcRange = inverseEditOperations[0].range;
      const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
      return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/lineCommentCommand.js
init_strings();
init_editOperation();
init_position();
init_range();
init_selection();
var LineCommentCommand = class _LineCommentCommand {
  constructor(languageConfigurationService, selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {
    this.languageConfigurationService = languageConfigurationService;
    this._selection = selection;
    this._tabSize = tabSize;
    this._type = type;
    this._insertSpace = insertSpace;
    this._selectionId = null;
    this._deltaColumn = 0;
    this._moveEndPositionDown = false;
    this._ignoreEmptyLines = ignoreEmptyLines;
    this._ignoreFirstLine = ignoreFirstLine || false;
  }
  /**
   * Do an initial pass over the lines and gather info about the line comment string.
   * Returns null if any of the lines doesn't support a line comment string.
   */
  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {
    model.tokenization.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
    const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;
    const commentStr = config ? config.lineCommentToken : null;
    if (!commentStr) {
      return null;
    }
    const lines = [];
    for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {
      lines[i] = {
        ignore: false,
        commentStr,
        commentStrOffset: 0,
        commentStrLength: commentStr.length
      };
    }
    return lines;
  }
  /**
   * Analyze lines and decide which lines are relevant and what the toggle should do.
   * Also, build up several offsets and lengths useful in the generation of editor operations.
   */
  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {
    let onlyWhitespaceLines = true;
    let shouldRemoveComments;
    if (type === 0) {
      shouldRemoveComments = true;
    } else if (type === 1) {
      shouldRemoveComments = false;
    } else {
      shouldRemoveComments = true;
    }
    for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
      const lineData = lines[i];
      const lineNumber = startLineNumber + i;
      if (lineNumber === startLineNumber && ignoreFirstLine) {
        lineData.ignore = true;
        continue;
      }
      const lineContent = model.getLineContent(lineNumber);
      const lineContentStartOffset = firstNonWhitespaceIndex(lineContent);
      if (lineContentStartOffset === -1) {
        lineData.ignore = ignoreEmptyLines;
        lineData.commentStrOffset = lineContent.length;
        continue;
      }
      onlyWhitespaceLines = false;
      lineData.ignore = false;
      lineData.commentStrOffset = lineContentStartOffset;
      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {
        if (type === 0) {
          shouldRemoveComments = false;
        } else if (type === 1) {
        } else {
          lineData.ignore = true;
        }
      }
      if (shouldRemoveComments && insertSpace) {
        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32) {
          lineData.commentStrLength += 1;
        }
      }
    }
    if (type === 0 && onlyWhitespaceLines) {
      shouldRemoveComments = false;
      for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
        lines[i].ignore = false;
      }
    }
    return {
      supported: true,
      shouldRemoveComments,
      lines
    };
  }
  /**
   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
   */
  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {
    const lines = _LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);
    if (lines === null) {
      return {
        supported: false
      };
    }
    return _LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);
  }
  /**
   * Given a successful analysis, execute either insert line comments, either remove line comments
   */
  _executeLineComments(model, builder, data, s) {
    let ops;
    if (data.shouldRemoveComments) {
      ops = _LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
    } else {
      _LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);
    }
    const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);
    for (let i = 0, len = ops.length; i < len; i++) {
      builder.addEditOperation(ops[i].range, ops[i].text);
      if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {
        const lineContent = model.getLineContent(cursorPosition.lineNumber);
        if (lineContent.length + 1 === cursorPosition.column) {
          this._deltaColumn = (ops[i].text || "").length;
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  _attemptRemoveBlockComment(model, s, startToken, endToken) {
    let startLineNumber = s.startLineNumber;
    let endLineNumber = s.endLineNumber;
    const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
    if (startTokenIndex !== -1 && endTokenIndex === -1) {
      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      endLineNumber = startLineNumber;
    }
    if (startTokenIndex === -1 && endTokenIndex !== -1) {
      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
      startLineNumber = endLineNumber;
    }
    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
      if (startTokenIndex !== -1) {
        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      }
    }
    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32) {
      startToken += " ";
    }
    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32) {
      endToken = " " + endToken;
      endTokenIndex -= 1;
    }
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    }
    return null;
  }
  /**
   * Given an unsuccessful analysis, delegate to the block comment command
   */
  _executeBlockComment(model, builder, s) {
    model.tokenization.tokenizeIfCheap(s.startLineNumber);
    const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);
    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    const startToken = config.blockCommentStartToken;
    const endToken = config.blockCommentEndToken;
    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
    if (!ops) {
      if (s.isEmpty()) {
        const lineContent = model.getLineContent(s.startLineNumber);
        let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineContent);
        if (firstNonWhitespaceIndex2 === -1) {
          firstNonWhitespaceIndex2 = lineContent.length;
        }
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex2 + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);
      } else {
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);
      }
      if (ops.length === 1) {
        this._deltaColumn = startToken.length + 1;
      }
    }
    this._selectionId = builder.trackSelection(s);
    for (const op of ops) {
      builder.addEditOperation(op.range, op.text);
    }
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._moveEndPositionDown = false;
    if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {
      builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? "" : "\n");
      this._selectionId = builder.trackSelection(s);
      return;
    }
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const data = _LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);
    if (data.supported) {
      return this._executeLineComments(model, builder, data, s);
    }
    return this._executeBlockComment(model, builder, s);
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);
  }
  /**
   * Generate edit operations in the remove line comment case
   */
  static _createRemoveLineCommentsOperations(lines, startLineNumber) {
    const res = [];
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
    }
    return res;
  }
  /**
   * Generate edit operations in the add line comment case
   */
  _createAddLineCommentsOperations(lines, startLineNumber) {
    const res = [];
    const afterCommentStr = this._insertSpace ? " " : "";
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));
    }
    return res;
  }
  static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {
    if (isTab) {
      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);
    }
    return currentVisibleColumn + columnSize;
  }
  /**
   * Adjust insertion points to have them vertically aligned in the add line comment case
   */
  static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {
    let minVisibleColumn = 1073741824;
    let j;
    let lenJ;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (let j2 = 0, lenJ2 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j2 < lenJ2; j2++) {
        currentVisibleColumn = _LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j2) === 9, 1);
      }
      if (currentVisibleColumn < minVisibleColumn) {
        minVisibleColumn = currentVisibleColumn;
      }
    }
    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
        currentVisibleColumn = _LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9, 1);
      }
      if (currentVisibleColumn > minVisibleColumn) {
        lines[i].commentStrOffset = j - 1;
      } else {
        lines[i].commentStrOffset = j;
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/comment.js
init_nls();
init_actions2();
var CommentLineAction = class extends EditorAction {
  constructor(type, opts) {
    super(opts);
    this._type = type;
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const commands = [];
    const modelOptions = model.getOptions();
    const commentsOptions = editor2.getOption(
      22
      /* EditorOption.comments */
    );
    const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignoreFirstLine: false }));
    selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i = 1; i < selections.length; i++) {
      const curr = selections[i];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignoreFirstLine = true;
        } else {
          prev.ignoreFirstLine = true;
          prev = curr;
        }
      }
    }
    for (const selection of selections) {
      commands.push(new LineCommentCommand(languageConfigurationService, selection.selection, modelOptions.tabSize, this._type, commentsOptions.insertSpace, commentsOptions.ignoreEmptyLines, selection.ignoreFirstLine));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var ToggleCommentLineAction = class extends CommentLineAction {
  constructor() {
    super(0, {
      id: "editor.action.commentLine",
      label: localize("comment.line", "Toggle Line Comment"),
      alias: "Toggle Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 90,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({ key: "miToggleLineComment", comment: ["&& denotes a mnemonic"] }, "&&Toggle Line Comment"),
        order: 1
      }
    });
  }
};
var AddLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(1, {
      id: "editor.action.addCommentLine",
      label: localize("comment.line.add", "Add Line Comment"),
      alias: "Add Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 33
          /* KeyCode.KeyC */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var RemoveLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(2, {
      id: "editor.action.removeCommentLine",
      label: localize("comment.line.remove", "Remove Line Comment"),
      alias: "Remove Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 51
          /* KeyCode.KeyU */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var BlockCommentAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.blockComment",
      label: localize("comment.block", "Toggle Block Comment"),
      alias: "Toggle Block Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 31,
        linux: {
          primary: 2048 | 1024 | 31
          /* KeyCode.KeyA */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({ key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"] }, "Toggle &&Block Comment"),
        order: 2
      }
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const commentsOptions = editor2.getOption(
      22
      /* EditorOption.comments */
    );
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      commands.push(new BlockCommentCommand(selection, commentsOptions.insertSpace, languageConfigurationService));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
registerEditorAction(ToggleCommentLineAction);
registerEditorAction(AddLineCommentAction);
registerEditorAction(RemoveLineCommentAction);
registerEditorAction(BlockCommentAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/cursorUndo/browser/cursorUndo.js
init_lifecycle();
init_editorExtensions();
init_editorContextKeys();
init_nls();
var CursorState2 = class {
  constructor(selections) {
    this.selections = selections;
  }
  equals(other) {
    const thisLen = this.selections.length;
    const otherLen = other.selections.length;
    if (thisLen !== otherLen) {
      return false;
    }
    for (let i = 0; i < thisLen; i++) {
      if (!this.selections[i].equalsSelection(other.selections[i])) {
        return false;
      }
    }
    return true;
  }
};
var StackElement = class {
  constructor(cursorState, scrollTop, scrollLeft) {
    this.cursorState = cursorState;
    this.scrollTop = scrollTop;
    this.scrollLeft = scrollLeft;
  }
};
var CursorUndoRedoController = class _CursorUndoRedoController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_CursorUndoRedoController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._isCursorUndoRedo = false;
    this._undoStack = [];
    this._redoStack = [];
    this._register(editor2.onDidChangeModel((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (this._isCursorUndoRedo) {
        return;
      }
      if (!e.oldSelections) {
        return;
      }
      if (e.oldModelVersionId !== e.modelVersionId) {
        return;
      }
      const prevState = new CursorState2(e.oldSelections);
      const isEqualToLastUndoStack = this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(prevState);
      if (!isEqualToLastUndoStack) {
        this._undoStack.push(new StackElement(prevState, editor2.getScrollTop(), editor2.getScrollLeft()));
        this._redoStack = [];
        if (this._undoStack.length > 50) {
          this._undoStack.shift();
        }
      }
    }));
  }
  cursorUndo() {
    if (!this._editor.hasModel() || this._undoStack.length === 0) {
      return;
    }
    this._redoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._undoStack.pop());
  }
  cursorRedo() {
    if (!this._editor.hasModel() || this._redoStack.length === 0) {
      return;
    }
    this._undoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._redoStack.pop());
  }
  _applyState(stackElement) {
    this._isCursorUndoRedo = true;
    this._editor.setSelections(stackElement.cursorState.selections);
    this._editor.setScrollPosition({
      scrollTop: stackElement.scrollTop,
      scrollLeft: stackElement.scrollLeft
    });
    this._isCursorUndoRedo = false;
  }
};
CursorUndoRedoController.ID = "editor.contrib.cursorUndoRedoController";
var CursorUndo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorUndo",
      label: localize("cursor.undo", "Cursor Undo"),
      alias: "Cursor Undo",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 51,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2, args) {
    var _a;
    (_a = CursorUndoRedoController.get(editor2)) === null || _a === void 0 ? void 0 : _a.cursorUndo();
  }
};
var CursorRedo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorRedo",
      label: localize("cursor.redo", "Cursor Redo"),
      alias: "Cursor Redo",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    var _a;
    (_a = CursorUndoRedoController.get(editor2)) === null || _a === void 0 ? void 0 : _a.cursorRedo();
  }
};
registerEditorContribution(
  CursorUndoRedoController.ID,
  CursorUndoRedoController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(CursorUndo);
registerEditorAction(CursorRedo);

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.js
init_lifecycle();
init_platform();
init_editorExtensions();
init_position();
init_range();
init_selection();
init_textModel();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dragAndDropCommand.js
init_range();
init_selection();
var DragAndDropCommand = class {
  constructor(selection, targetPosition, copy) {
    this.selection = selection;
    this.targetPosition = targetPosition;
    this.copy = copy;
    this.targetSelection = null;
  }
  getEditOperations(model, builder) {
    const text = model.getValueInRange(this.selection);
    if (!this.copy) {
      builder.addEditOperation(this.selection, null);
    }
    builder.addEditOperation(new Range(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), text);
    if (this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
      this.targetSelection = this.selection;
      return;
    }
    if (this.copy) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.selection.endColumn <= this.targetPosition.column) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn);
    } else {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
    }
  }
  computeCursorState(model, helper) {
    return this.targetSelection;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.js
function hasTriggerModifier(e) {
  if (isMacintosh) {
    return e.altKey;
  } else {
    return e.ctrlKey;
  }
}
var DragAndDropController = class _DragAndDropController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_DragAndDropController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._dndDecorationIds = this._editor.createDecorationsCollection();
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
    this._register(this._editor.onMouseDrag((e) => this._onEditorMouseDrag(e)));
    this._register(this._editor.onMouseDrop((e) => this._onEditorMouseDrop(e)));
    this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled()));
    this._register(this._editor.onKeyDown((e) => this.onEditorKeyDown(e)));
    this._register(this._editor.onKeyUp((e) => this.onEditorKeyUp(e)));
    this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur()));
    this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur()));
    this._mouseDown = false;
    this._modifierPressed = false;
    this._dragSelection = null;
  }
  onEditorBlur() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
  }
  onEditorKeyDown(e) {
    if (!this._editor.getOption(
      34
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      21
      /* EditorOption.columnSelection */
    )) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = true;
    }
    if (this._mouseDown && hasTriggerModifier(e)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    }
  }
  onEditorKeyUp(e) {
    if (!this._editor.getOption(
      34
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      21
      /* EditorOption.columnSelection */
    )) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = false;
    }
    if (this._mouseDown && e.keyCode === _DragAndDropController.TRIGGER_KEY_VALUE) {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._mouseDown = true;
  }
  _onEditorMouseUp(mouseEvent) {
    this._mouseDown = false;
    this._editor.updateOptions({
      mouseStyle: "text"
    });
  }
  _onEditorMouseDrag(mouseEvent) {
    const target = mouseEvent.target;
    if (this._dragSelection === null) {
      const selections = this._editor.getSelections() || [];
      const possibleSelections = selections.filter((selection) => target.position && selection.containsPosition(target.position));
      if (possibleSelections.length === 1) {
        this._dragSelection = possibleSelections[0];
      } else {
        return;
      }
    }
    if (hasTriggerModifier(mouseEvent.event)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    } else {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
    if (target.position) {
      if (this._dragSelection.containsPosition(target.position)) {
        this._removeDecoration();
      } else {
        this.showAt(target.position);
      }
    }
  }
  _onEditorMouseDropCanceled() {
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  _onEditorMouseDrop(mouseEvent) {
    if (mouseEvent.target && (this._hitContent(mouseEvent.target) || this._hitMargin(mouseEvent.target)) && mouseEvent.target.position) {
      const newCursorPosition = new Position(mouseEvent.target.position.lineNumber, mouseEvent.target.position.column);
      if (this._dragSelection === null) {
        let newSelections = null;
        if (mouseEvent.event.shiftKey) {
          const primarySelection = this._editor.getSelection();
          if (primarySelection) {
            const { selectionStartLineNumber, selectionStartColumn } = primarySelection;
            newSelections = [new Selection(selectionStartLineNumber, selectionStartColumn, newCursorPosition.lineNumber, newCursorPosition.column)];
          }
        } else {
          newSelections = (this._editor.getSelections() || []).map((selection) => {
            if (selection.containsPosition(newCursorPosition)) {
              return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
            } else {
              return selection;
            }
          });
        }
        this._editor.setSelections(
          newSelections || [],
          "mouse",
          3
          /* CursorChangeReason.Explicit */
        );
      } else if (!this._dragSelection.containsPosition(newCursorPosition) || (hasTriggerModifier(mouseEvent.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(newCursorPosition) || this._dragSelection.getStartPosition().equals(newCursorPosition))) {
        this._editor.pushUndoStop();
        this._editor.executeCommand(_DragAndDropController.ID, new DragAndDropCommand(this._dragSelection, newCursorPosition, hasTriggerModifier(mouseEvent.event) || this._modifierPressed));
        this._editor.pushUndoStop();
      }
    }
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  showAt(position) {
    this._dndDecorationIds.set([{
      range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
      options: _DragAndDropController._DECORATION_OPTIONS
    }]);
    this._editor.revealPosition(
      position,
      1
      /* ScrollType.Immediate */
    );
  }
  _removeDecoration() {
    this._dndDecorationIds.clear();
  }
  _hitContent(target) {
    return target.type === 6 || target.type === 7;
  }
  _hitMargin(target) {
    return target.type === 2 || target.type === 3 || target.type === 4;
  }
  dispose() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
    super.dispose();
  }
};
DragAndDropController.ID = "editor.contrib.dragAndDrop";
DragAndDropController.TRIGGER_KEY_VALUE = isMacintosh ? 6 : 5;
DragAndDropController._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "dnd-target",
  className: "dnd-target"
});
registerEditorContribution(
  DragAndDropController.ID,
  DragAndDropController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteContribution.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
init_dom();
init_arrays();
init_async();
init_lifecycle();
init_mime();
init_platform();
init_uuid();

// node_modules/monaco-editor/esm/vs/editor/browser/dnd.js
init_mime();
init_uri();
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function toVSDataTransfer(dataTransfer) {
  const vsDataTransfer = new VSDataTransfer();
  for (const item of dataTransfer.items) {
    const type = item.type;
    if (item.kind === "string") {
      const asStringValue = new Promise((resolve) => item.getAsString(resolve));
      vsDataTransfer.append(type, createStringDataTransferItem(asStringValue));
    } else if (item.kind === "file") {
      const file = item.getAsFile();
      if (file) {
        vsDataTransfer.append(type, createFileDataTransferItemFromFile(file));
      }
    }
  }
  return vsDataTransfer;
}
function createFileDataTransferItemFromFile(file) {
  const uri = file.path ? URI.parse(file.path) : void 0;
  return createFileDataTransferItem(file.name, uri, () => __awaiter14(this, void 0, void 0, function* () {
    return new Uint8Array(yield file.arrayBuffer());
  }));
}
var INTERNAL_DND_MIME_TYPES = Object.freeze([
  CodeDataTransfers.EDITORS,
  CodeDataTransfers.FILES,
  DataTransfers.RESOURCES,
  DataTransfers.INTERNAL_URI_LIST
]);
function toExternalVSDataTransfer(sourceDataTransfer, overwriteUriList = false) {
  const vsDataTransfer = toVSDataTransfer(sourceDataTransfer);
  const uriList = vsDataTransfer.get(DataTransfers.INTERNAL_URI_LIST);
  if (uriList) {
    vsDataTransfer.replace(Mimes.uriList, uriList);
  } else {
    if (overwriteUriList || !vsDataTransfer.has(Mimes.uriList)) {
      const editorData = [];
      for (const item of sourceDataTransfer.items) {
        const file = item.getAsFile();
        if (file) {
          const path = file.path;
          try {
            if (path) {
              editorData.push(URI.file(path).toString());
            } else {
              editorData.push(URI.parse(file.name, true).toString());
            }
          } catch (_a) {
          }
        }
      }
      if (editorData.length) {
        vsDataTransfer.replace(Mimes.uriList, createStringDataTransferItem(UriList.create(editorData)));
      }
    }
  }
  for (const internal of INTERNAL_DND_MIME_TYPES) {
    vsDataTransfer.delete(internal);
  }
  return vsDataTransfer;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
init_range();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/edit.js
function createCombinedWorkspaceEdit(uri, ranges, edit) {
  var _a, _b;
  return {
    edits: [
      ...ranges.map((range) => new ResourceTextEdit(uri, typeof edit.insertText === "string" ? { range, text: edit.insertText, insertAsSnippet: false } : { range, text: edit.insertText.snippet, insertAsSnippet: true })),
      ...(_b = (_a = edit.additionalEdit) === null || _a === void 0 ? void 0 : _a.edits) !== null && _b !== void 0 ? _b : []
    ]
  };
}
function sortEditsByYieldTo(edits) {
  var _a;
  function yieldsTo(yTo, other) {
    return "providerId" in yTo && yTo.providerId === other.providerId || "mimeType" in yTo && yTo.mimeType === other.handledMimeType;
  }
  const yieldsToMap = /* @__PURE__ */ new Map();
  for (const edit of edits) {
    for (const yTo of (_a = edit.yieldTo) !== null && _a !== void 0 ? _a : []) {
      for (const other of edits) {
        if (other === edit) {
          continue;
        }
        if (yieldsTo(yTo, other)) {
          let arr = yieldsToMap.get(edit);
          if (!arr) {
            arr = [];
            yieldsToMap.set(edit, arr);
          }
          arr.push(other);
        }
      }
    }
  }
  if (!yieldsToMap.size) {
    return Array.from(edits);
  }
  const visited = /* @__PURE__ */ new Set();
  const tempStack = [];
  function visit(nodes) {
    if (!nodes.length) {
      return [];
    }
    const node = nodes[0];
    if (tempStack.includes(node)) {
      console.warn(`Yield to cycle detected for ${node.providerId}`);
      return nodes;
    }
    if (visited.has(node)) {
      return visit(nodes.slice(1));
    }
    let pre = [];
    const yTo = yieldsToMap.get(node);
    if (yTo) {
      tempStack.push(node);
      pre = visit(yTo);
      tempStack.pop();
    }
    visited.add(node);
    return [...pre, node, ...visit(nodes.slice(1))];
  }
  return visit(Array.from(edits));
}

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
init_editorState();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineProgress/browser/inlineProgress.js
init_dom();
init_async();
init_codicons();
init_lifecycle();
init_strings();
init_themables();
init_range();
init_textModel();
init_instantiation();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/inlineProgress/browser/inlineProgressWidget.css";
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var inlineProgressDecoration = ModelDecorationOptions.register({
  description: "inline-progress-widget",
  stickiness: 1,
  showIfCollapsed: true,
  after: {
    content: noBreakWhitespace,
    inlineClassName: "inline-editor-progress-decoration",
    inlineClassNameAffectsLetterSpacing: true
  }
});
var InlineProgressWidget = class _InlineProgressWidget extends Disposable {
  constructor(typeId, editor2, range, title, delegate) {
    super();
    this.typeId = typeId;
    this.editor = editor2;
    this.range = range;
    this.delegate = delegate;
    this.allowEditorOverflow = false;
    this.suppressMouseDown = true;
    this.create(title);
    this.editor.addContentWidget(this);
    this.editor.layoutContentWidget(this);
  }
  create(title) {
    this.domNode = $(".inline-progress-widget");
    this.domNode.role = "button";
    this.domNode.title = title;
    const iconElement = $("span.icon");
    this.domNode.append(iconElement);
    iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.loading), "codicon-modifier-spin");
    const updateSize = () => {
      const lineHeight = this.editor.getOption(
        65
        /* EditorOption.lineHeight */
      );
      this.domNode.style.height = `${lineHeight}px`;
      this.domNode.style.width = `${Math.ceil(0.8 * lineHeight)}px`;
    };
    updateSize();
    this._register(this.editor.onDidChangeConfiguration((c) => {
      if (c.hasChanged(
        51
        /* EditorOption.fontSize */
      ) || c.hasChanged(
        65
        /* EditorOption.lineHeight */
      )) {
        updateSize();
      }
    }));
    this._register(addDisposableListener(this.domNode, EventType.CLICK, (e) => {
      this.delegate.cancel();
    }));
  }
  getId() {
    return _InlineProgressWidget.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: { lineNumber: this.range.startLineNumber, column: this.range.startColumn },
      preference: [
        0
        /* ContentWidgetPositionPreference.EXACT */
      ]
    };
  }
  dispose() {
    super.dispose();
    this.editor.removeContentWidget(this);
  }
};
InlineProgressWidget.baseId = "editor.widget.inlineProgressWidget";
var InlineProgressManager = class InlineProgressManager2 extends Disposable {
  constructor(id, _editor, _instantiationService) {
    super();
    this.id = id;
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._showDelay = 500;
    this._showPromise = this._register(new MutableDisposable());
    this._currentWidget = new MutableDisposable();
    this._operationIdPool = 0;
    this._currentDecorations = _editor.createDecorationsCollection();
  }
  showWhile(position, title, promise) {
    return __awaiter15(this, void 0, void 0, function* () {
      const operationId = this._operationIdPool++;
      this._currentOperation = operationId;
      this.clear();
      this._showPromise.value = disposableTimeout(() => {
        const range = Range.fromPositions(position);
        const decorationIds = this._currentDecorations.set([{
          range,
          options: inlineProgressDecoration
        }]);
        if (decorationIds.length > 0) {
          this._currentWidget.value = this._instantiationService.createInstance(InlineProgressWidget, this.id, this._editor, range, title, promise);
        }
      }, this._showDelay);
      try {
        return yield promise;
      } finally {
        if (this._currentOperation === operationId) {
          this.clear();
          this._currentOperation = void 0;
        }
      }
    });
  }
  clear() {
    this._showPromise.clear();
    this._currentDecorations.clear();
    this._currentWidget.clear();
  }
};
InlineProgressManager = __decorate16([
  __param16(2, IInstantiationService)
], InlineProgressManager);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
init_nls();
init_contextkey();
init_instantiation();
init_progress();

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.js
init_dom();
init_actions();
init_event();
init_lifecycle();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.css";
init_contextkey();
init_instantiation();
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PostEditWidget_1;
var PostEditWidget = PostEditWidget_1 = class PostEditWidget2 extends Disposable {
  constructor(typeId, editor2, visibleContext, showCommand, range, edits, onSelectNewEdit, _contextMenuService, contextKeyService, _keybindingService) {
    super();
    this.typeId = typeId;
    this.editor = editor2;
    this.showCommand = showCommand;
    this.range = range;
    this.edits = edits;
    this.onSelectNewEdit = onSelectNewEdit;
    this._contextMenuService = _contextMenuService;
    this._keybindingService = _keybindingService;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = true;
    this.create();
    this.visibleContext = visibleContext.bindTo(contextKeyService);
    this.visibleContext.set(true);
    this._register(toDisposable(() => this.visibleContext.reset()));
    this.editor.addContentWidget(this);
    this.editor.layoutContentWidget(this);
    this._register(toDisposable(() => this.editor.removeContentWidget(this)));
    this._register(this.editor.onDidChangeCursorPosition((e) => {
      if (!range.containsPosition(e.position)) {
        this.dispose();
      }
    }));
    this._register(Event.runAndSubscribe(_keybindingService.onDidUpdateKeybindings, () => {
      this._updateButtonTitle();
    }));
  }
  _updateButtonTitle() {
    var _a;
    const binding = (_a = this._keybindingService.lookupKeybinding(this.showCommand.id)) === null || _a === void 0 ? void 0 : _a.getLabel();
    this.button.element.title = this.showCommand.label + (binding ? ` (${binding})` : "");
  }
  create() {
    this.domNode = $(".post-edit-widget");
    this.button = this._register(new Button(this.domNode, {
      supportIcons: true
    }));
    this.button.label = "$(insert)";
    this._register(addDisposableListener(this.domNode, EventType.CLICK, () => this.showSelector()));
  }
  getId() {
    return PostEditWidget_1.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: this.range.getEndPosition(),
      preference: [
        2
        /* ContentWidgetPositionPreference.BELOW */
      ]
    };
  }
  showSelector() {
    this._contextMenuService.showContextMenu({
      getAnchor: () => {
        const pos = getDomNodePagePosition(this.button.element);
        return { x: pos.left + pos.width, y: pos.top + pos.height };
      },
      getActions: () => {
        return this.edits.allEdits.map((edit, i) => toAction({
          id: "",
          label: edit.label,
          checked: i === this.edits.activeEditIndex,
          run: () => {
            if (i !== this.edits.activeEditIndex) {
              return this.onSelectNewEdit(i);
            }
          }
        }));
      }
    });
  }
};
PostEditWidget.baseId = "editor.widget.postEditWidget";
PostEditWidget = PostEditWidget_1 = __decorate17([
  __param17(7, IContextMenuService),
  __param17(8, IContextKeyService),
  __param17(9, IKeybindingService)
], PostEditWidget);
var PostEditWidgetManager = class PostEditWidgetManager2 extends Disposable {
  constructor(_id, _editor, _visibleContext, _showCommand, _instantiationService, _bulkEditService) {
    super();
    this._id = _id;
    this._editor = _editor;
    this._visibleContext = _visibleContext;
    this._showCommand = _showCommand;
    this._instantiationService = _instantiationService;
    this._bulkEditService = _bulkEditService;
    this._currentWidget = this._register(new MutableDisposable());
    this._register(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelContent)(() => this.clear()));
  }
  applyEditAndShowIfNeeded(ranges, edits, canShowWidget, token) {
    var _a, _b;
    return __awaiter16(this, void 0, void 0, function* () {
      const model = this._editor.getModel();
      if (!model || !ranges.length) {
        return;
      }
      const edit = edits.allEdits[edits.activeEditIndex];
      if (!edit) {
        return;
      }
      let insertTextEdit = [];
      if (typeof edit.insertText === "string" ? edit.insertText === "" : edit.insertText.snippet === "") {
        insertTextEdit = [];
      } else {
        insertTextEdit = ranges.map((range) => new ResourceTextEdit(model.uri, typeof edit.insertText === "string" ? { range, text: edit.insertText, insertAsSnippet: false } : { range, text: edit.insertText.snippet, insertAsSnippet: true }));
      }
      const allEdits = [
        ...insertTextEdit,
        ...(_b = (_a = edit.additionalEdit) === null || _a === void 0 ? void 0 : _a.edits) !== null && _b !== void 0 ? _b : []
      ];
      const combinedWorkspaceEdit = {
        edits: allEdits
      };
      const primaryRange = ranges[0];
      const editTrackingDecoration = model.deltaDecorations([], [{
        range: primaryRange,
        options: {
          description: "paste-line-suffix",
          stickiness: 0
          /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
        }
      }]);
      let editResult;
      let editRange;
      try {
        editResult = yield this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor, token });
        editRange = model.getDecorationRange(editTrackingDecoration[0]);
      } finally {
        model.deltaDecorations(editTrackingDecoration, []);
      }
      if (canShowWidget && editResult.isApplied && edits.allEdits.length > 1) {
        this.show(editRange !== null && editRange !== void 0 ? editRange : primaryRange, edits, (newEditIndex) => __awaiter16(this, void 0, void 0, function* () {
          const model2 = this._editor.getModel();
          if (!model2) {
            return;
          }
          yield model2.undo();
          this.applyEditAndShowIfNeeded(ranges, { activeEditIndex: newEditIndex, allEdits: edits.allEdits }, canShowWidget, token);
        }));
      }
    });
  }
  show(range, edits, onDidSelectEdit) {
    this.clear();
    if (this._editor.hasModel()) {
      this._currentWidget.value = this._instantiationService.createInstance(PostEditWidget, this._id, this._editor, this._visibleContext, this._showCommand, range, edits, onDidSelectEdit);
    }
  }
  clear() {
    this._currentWidget.clear();
  }
  tryShowSelector() {
    var _a;
    (_a = this._currentWidget.value) === null || _a === void 0 ? void 0 : _a.showSelector();
  }
};
PostEditWidgetManager = __decorate17([
  __param17(4, IInstantiationService),
  __param17(5, IBulkEditService)
], PostEditWidgetManager);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CopyPasteController_1;
var changePasteTypeCommandId = "editor.changePasteType";
var pasteWidgetVisibleCtx = new RawContextKey("pasteWidgetVisible", false, localize("pasteWidgetVisible", "Whether the paste widget is showing"));
var vscodeClipboardMime = "application/vnd.code.copyMetadata";
var CopyPasteController = CopyPasteController_1 = class CopyPasteController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(CopyPasteController_1.ID);
  }
  constructor(editor2, instantiationService, _bulkEditService, _clipboardService, _languageFeaturesService, _quickInputService, _progressService) {
    super();
    this._bulkEditService = _bulkEditService;
    this._clipboardService = _clipboardService;
    this._languageFeaturesService = _languageFeaturesService;
    this._quickInputService = _quickInputService;
    this._progressService = _progressService;
    this._editor = editor2;
    const container = editor2.getContainerDomNode();
    this._register(addDisposableListener(container, "copy", (e) => this.handleCopy(e)));
    this._register(addDisposableListener(container, "cut", (e) => this.handleCopy(e)));
    this._register(addDisposableListener(container, "paste", (e) => this.handlePaste(e), true));
    this._pasteProgressManager = this._register(new InlineProgressManager("pasteIntoEditor", editor2, instantiationService));
    this._postPasteWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, "pasteIntoEditor", editor2, pasteWidgetVisibleCtx, { id: changePasteTypeCommandId, label: localize("postPasteWidgetTitle", "Show paste options...") }));
  }
  changePasteType() {
    this._postPasteWidgetManager.tryShowSelector();
  }
  pasteAs(preferredId) {
    this._editor.focus();
    try {
      this._pasteAsActionContext = { preferredId };
      document.execCommand("paste");
    } finally {
      this._pasteAsActionContext = void 0;
    }
  }
  clearWidgets() {
    this._postPasteWidgetManager.clear();
  }
  isPasteAsEnabled() {
    return this._editor.getOption(
      83
      /* EditorOption.pasteAs */
    ).enabled && !this._editor.getOption(
      89
      /* EditorOption.readOnly */
    );
  }
  handleCopy(e) {
    var _a, _b;
    if (!this._editor.hasTextFocus()) {
      return;
    }
    if (isWeb) {
      this._clipboardService.writeResources([]);
    }
    if (!e.clipboardData || !this.isPasteAsEnabled()) {
      return;
    }
    const model = this._editor.getModel();
    const selections = this._editor.getSelections();
    if (!model || !(selections === null || selections === void 0 ? void 0 : selections.length)) {
      return;
    }
    const enableEmptySelectionClipboard = this._editor.getOption(
      36
      /* EditorOption.emptySelectionClipboard */
    );
    let ranges = selections;
    const wasFromEmptySelection = selections.length === 1 && selections[0].isEmpty();
    if (wasFromEmptySelection) {
      if (!enableEmptySelectionClipboard) {
        return;
      }
      ranges = [new Range(ranges[0].startLineNumber, 1, ranges[0].startLineNumber, 1 + model.getLineLength(ranges[0].startLineNumber))];
    }
    const toCopy = (_a = this._editor._getViewModel()) === null || _a === void 0 ? void 0 : _a.getPlainTextToCopy(selections, enableEmptySelectionClipboard, isWindows);
    const multicursorText = Array.isArray(toCopy) ? toCopy : null;
    const defaultPastePayload = {
      multicursorText,
      pasteOnNewLine: wasFromEmptySelection,
      mode: null
    };
    const providers = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter((x) => !!x.prepareDocumentPaste);
    if (!providers.length) {
      this.setCopyMetadata(e.clipboardData, { defaultPastePayload });
      return;
    }
    const dataTransfer = toVSDataTransfer(e.clipboardData);
    const providerCopyMimeTypes = providers.flatMap((x) => {
      var _a2;
      return (_a2 = x.copyMimeTypes) !== null && _a2 !== void 0 ? _a2 : [];
    });
    const handle = generateUuid();
    this.setCopyMetadata(e.clipboardData, {
      id: handle,
      providerCopyMimeTypes,
      defaultPastePayload
    });
    const promise = createCancelablePromise((token) => __awaiter17(this, void 0, void 0, function* () {
      const results = coalesce(yield Promise.all(providers.map((provider) => __awaiter17(this, void 0, void 0, function* () {
        try {
          return yield provider.prepareDocumentPaste(model, ranges, dataTransfer, token);
        } catch (err) {
          console.error(err);
          return void 0;
        }
      }))));
      results.reverse();
      for (const result of results) {
        for (const [mime, value] of result) {
          dataTransfer.replace(mime, value);
        }
      }
      return dataTransfer;
    }));
    (_b = this._currentCopyOperation) === null || _b === void 0 ? void 0 : _b.dataTransferPromise.cancel();
    this._currentCopyOperation = { handle, dataTransferPromise: promise };
  }
  handlePaste(e) {
    var _a, _b;
    return __awaiter17(this, void 0, void 0, function* () {
      if (!e.clipboardData || !this._editor.hasTextFocus()) {
        return;
      }
      (_a = this._currentPasteOperation) === null || _a === void 0 ? void 0 : _a.cancel();
      this._currentPasteOperation = void 0;
      const model = this._editor.getModel();
      const selections = this._editor.getSelections();
      if (!(selections === null || selections === void 0 ? void 0 : selections.length) || !model) {
        return;
      }
      if (!this.isPasteAsEnabled()) {
        return;
      }
      const metadata = this.fetchCopyMetadata(e);
      const dataTransfer = toExternalVSDataTransfer(e.clipboardData);
      dataTransfer.delete(vscodeClipboardMime);
      const allPotentialMimeTypes = [
        ...e.clipboardData.types,
        ...(_b = metadata === null || metadata === void 0 ? void 0 : metadata.providerCopyMimeTypes) !== null && _b !== void 0 ? _b : [],
        // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.
        // However we can only check the system clipboard async. For this early check, just add it in.
        // We filter providers again once we have the final dataTransfer we will use.
        Mimes.uriList
      ];
      const allProviders = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter((provider) => {
        var _a2;
        return (_a2 = provider.pasteMimeTypes) === null || _a2 === void 0 ? void 0 : _a2.some((type) => matchesMimeType(type, allPotentialMimeTypes));
      });
      if (!allProviders.length) {
        return;
      }
      e.preventDefault();
      e.stopImmediatePropagation();
      if (this._pasteAsActionContext) {
        this.showPasteAsPick(this._pasteAsActionContext.preferredId, allProviders, selections, dataTransfer, metadata);
      } else {
        this.doPasteInline(allProviders, selections, dataTransfer, metadata);
      }
    });
  }
  doPasteInline(allProviders, selections, dataTransfer, metadata) {
    const p = createCancelablePromise((token) => __awaiter17(this, void 0, void 0, function* () {
      const editor2 = this._editor;
      if (!editor2.hasModel()) {
        return;
      }
      const model = editor2.getModel();
      const tokenSource = new EditorStateCancellationTokenSource(editor2, 1 | 2, void 0, token);
      try {
        yield this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        const supportedProviders = allProviders.filter((provider) => isSupportedPasteProvider(provider, dataTransfer));
        if (!supportedProviders.length || supportedProviders.length === 1 && supportedProviders[0].id === "text") {
          yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
          return;
        }
        const providerEdits = yield this.getPasteEdits(supportedProviders, dataTransfer, model, selections, tokenSource.token);
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        if (providerEdits.length === 1 && providerEdits[0].providerId === "text") {
          yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
          return;
        }
        if (providerEdits.length) {
          const canShowWidget = editor2.getOption(
            83
            /* EditorOption.pasteAs */
          ).showPasteSelector === "afterPaste";
          return this._postPasteWidgetManager.applyEditAndShowIfNeeded(selections, { activeEditIndex: 0, allEdits: providerEdits }, canShowWidget, tokenSource.token);
        }
        yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
      } finally {
        tokenSource.dispose();
        if (this._currentPasteOperation === p) {
          this._currentPasteOperation = void 0;
        }
      }
    }));
    this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize("pasteIntoEditorProgress", "Running paste handlers. Click to cancel"), p);
    this._currentPasteOperation = p;
  }
  showPasteAsPick(preferredId, allProviders, selections, dataTransfer, metadata) {
    const p = createCancelablePromise((token) => __awaiter17(this, void 0, void 0, function* () {
      const editor2 = this._editor;
      if (!editor2.hasModel()) {
        return;
      }
      const model = editor2.getModel();
      const tokenSource = new EditorStateCancellationTokenSource(editor2, 1 | 2, void 0, token);
      try {
        yield this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        let supportedProviders = allProviders.filter((provider) => isSupportedPasteProvider(provider, dataTransfer));
        if (preferredId) {
          supportedProviders = supportedProviders.filter((edit) => edit.id === preferredId);
        }
        const providerEdits = yield this.getPasteEdits(supportedProviders, dataTransfer, model, selections, tokenSource.token);
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        if (!providerEdits.length) {
          return;
        }
        let pickedEdit;
        if (preferredId) {
          pickedEdit = providerEdits.at(0);
        } else {
          const selected = yield this._quickInputService.pick(providerEdits.map((edit) => ({
            label: edit.label,
            description: edit.providerId,
            detail: edit.detail,
            edit
          })), {
            placeHolder: localize("pasteAsPickerPlaceholder", "Select Paste Action")
          });
          pickedEdit = selected === null || selected === void 0 ? void 0 : selected.edit;
        }
        if (!pickedEdit) {
          return;
        }
        const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, selections, pickedEdit);
        yield this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor });
      } finally {
        tokenSource.dispose();
        if (this._currentPasteOperation === p) {
          this._currentPasteOperation = void 0;
        }
      }
    }));
    this._progressService.withProgress({
      location: 10,
      title: localize("pasteAsProgress", "Running paste handlers")
    }, () => p);
  }
  setCopyMetadata(dataTransfer, metadata) {
    dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));
  }
  fetchCopyMetadata(e) {
    var _a;
    if (!e.clipboardData) {
      return;
    }
    const rawMetadata = e.clipboardData.getData(vscodeClipboardMime);
    if (rawMetadata) {
      try {
        return JSON.parse(rawMetadata);
      } catch (_b) {
        return void 0;
      }
    }
    const [_, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);
    if (metadata) {
      return {
        defaultPastePayload: {
          mode: metadata.mode,
          multicursorText: (_a = metadata.multicursorText) !== null && _a !== void 0 ? _a : null,
          pasteOnNewLine: !!metadata.isFromEmptySelection
        }
      };
    }
    return void 0;
  }
  mergeInDataFromCopy(dataTransfer, metadata, token) {
    var _a;
    return __awaiter17(this, void 0, void 0, function* () {
      if ((metadata === null || metadata === void 0 ? void 0 : metadata.id) && ((_a = this._currentCopyOperation) === null || _a === void 0 ? void 0 : _a.handle) === metadata.id) {
        const toMergeDataTransfer = yield this._currentCopyOperation.dataTransferPromise;
        if (token.isCancellationRequested) {
          return;
        }
        for (const [key, value] of toMergeDataTransfer) {
          dataTransfer.replace(key, value);
        }
      }
      if (!dataTransfer.has(Mimes.uriList)) {
        const resources = yield this._clipboardService.readResources();
        if (token.isCancellationRequested) {
          return;
        }
        if (resources.length) {
          dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));
        }
      }
    });
  }
  getPasteEdits(providers, dataTransfer, model, selections, token) {
    return __awaiter17(this, void 0, void 0, function* () {
      const results = yield raceCancellation(Promise.all(providers.map((provider) => __awaiter17(this, void 0, void 0, function* () {
        var _a;
        try {
          const edit = yield (_a = provider.provideDocumentPasteEdits) === null || _a === void 0 ? void 0 : _a.call(provider, model, selections, dataTransfer, token);
          if (edit) {
            return Object.assign(Object.assign({}, edit), { providerId: provider.id });
          }
        } catch (err) {
          console.error(err);
        }
        return void 0;
      }))), token);
      const edits = coalesce(results !== null && results !== void 0 ? results : []);
      sortEditsByYieldTo(edits);
      return edits;
    });
  }
  applyDefaultPasteHandler(dataTransfer, metadata, token) {
    var _a, _b, _c;
    return __awaiter17(this, void 0, void 0, function* () {
      const textDataTransfer = (_a = dataTransfer.get(Mimes.text)) !== null && _a !== void 0 ? _a : dataTransfer.get("text");
      if (!textDataTransfer) {
        return;
      }
      const text = yield textDataTransfer.asString();
      if (token.isCancellationRequested) {
        return;
      }
      const payload = {
        text,
        pasteOnNewLine: (_b = metadata === null || metadata === void 0 ? void 0 : metadata.defaultPastePayload.pasteOnNewLine) !== null && _b !== void 0 ? _b : false,
        multicursorText: (_c = metadata === null || metadata === void 0 ? void 0 : metadata.defaultPastePayload.multicursorText) !== null && _c !== void 0 ? _c : null,
        mode: null
      };
      this._editor.trigger("keyboard", "paste", payload);
    });
  }
};
CopyPasteController.ID = "editor.contrib.copyPasteActionController";
CopyPasteController = CopyPasteController_1 = __decorate18([
  __param18(1, IInstantiationService),
  __param18(2, IBulkEditService),
  __param18(3, IClipboardService),
  __param18(4, ILanguageFeaturesService),
  __param18(5, IQuickInputService),
  __param18(6, IProgressService)
], CopyPasteController);
function isSupportedPasteProvider(provider, dataTransfer) {
  var _a;
  return Boolean((_a = provider.pasteMimeTypes) === null || _a === void 0 ? void 0 : _a.some((type) => dataTransfer.matches(type)));
}

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/defaultProviders.js
init_arrays();
init_lifecycle();
init_mime();
init_network();
init_resources();
init_uri();
init_languageFeatures();
init_nls();
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var builtInLabel = localize("builtIn", "Built-in");
var SimplePasteAndDropProvider = class {
  provideDocumentPasteEdits(_model, _ranges, dataTransfer, token) {
    return __awaiter18(this, void 0, void 0, function* () {
      const edit = yield this.getEdit(dataTransfer, token);
      return edit ? { insertText: edit.insertText, label: edit.label, detail: edit.detail, handledMimeType: edit.handledMimeType, yieldTo: edit.yieldTo } : void 0;
    });
  }
  provideDocumentOnDropEdits(_model, _position, dataTransfer, token) {
    return __awaiter18(this, void 0, void 0, function* () {
      const edit = yield this.getEdit(dataTransfer, token);
      return edit ? { insertText: edit.insertText, label: edit.label, handledMimeType: edit.handledMimeType, yieldTo: edit.yieldTo } : void 0;
    });
  }
};
var DefaultTextProvider = class extends SimplePasteAndDropProvider {
  constructor() {
    super(...arguments);
    this.id = "text";
    this.dropMimeTypes = [Mimes.text];
    this.pasteMimeTypes = [Mimes.text];
  }
  getEdit(dataTransfer, _token) {
    return __awaiter18(this, void 0, void 0, function* () {
      const textEntry = dataTransfer.get(Mimes.text);
      if (!textEntry) {
        return;
      }
      if (dataTransfer.has(Mimes.uriList)) {
        return;
      }
      const insertText = yield textEntry.asString();
      return {
        handledMimeType: Mimes.text,
        label: localize("text.label", "Insert Plain Text"),
        detail: builtInLabel,
        insertText
      };
    });
  }
};
var PathProvider = class extends SimplePasteAndDropProvider {
  constructor() {
    super(...arguments);
    this.id = "uri";
    this.dropMimeTypes = [Mimes.uriList];
    this.pasteMimeTypes = [Mimes.uriList];
  }
  getEdit(dataTransfer, token) {
    return __awaiter18(this, void 0, void 0, function* () {
      const entries = yield extractUriList(dataTransfer);
      if (!entries.length || token.isCancellationRequested) {
        return;
      }
      let uriCount = 0;
      const insertText = entries.map(({ uri, originalText }) => {
        if (uri.scheme === Schemas.file) {
          return uri.fsPath;
        } else {
          uriCount++;
          return originalText;
        }
      }).join(" ");
      let label;
      if (uriCount > 0) {
        label = entries.length > 1 ? localize("defaultDropProvider.uriList.uris", "Insert Uris") : localize("defaultDropProvider.uriList.uri", "Insert Uri");
      } else {
        label = entries.length > 1 ? localize("defaultDropProvider.uriList.paths", "Insert Paths") : localize("defaultDropProvider.uriList.path", "Insert Path");
      }
      return {
        handledMimeType: Mimes.uriList,
        insertText,
        label,
        detail: builtInLabel
      };
    });
  }
};
var RelativePathProvider = class RelativePathProvider2 extends SimplePasteAndDropProvider {
  constructor(_workspaceContextService) {
    super();
    this._workspaceContextService = _workspaceContextService;
    this.id = "relativePath";
    this.dropMimeTypes = [Mimes.uriList];
    this.pasteMimeTypes = [Mimes.uriList];
  }
  getEdit(dataTransfer, token) {
    return __awaiter18(this, void 0, void 0, function* () {
      const entries = yield extractUriList(dataTransfer);
      if (!entries.length || token.isCancellationRequested) {
        return;
      }
      const relativeUris = coalesce(entries.map(({ uri }) => {
        const root = this._workspaceContextService.getWorkspaceFolder(uri);
        return root ? relativePath(root.uri, uri) : void 0;
      }));
      if (!relativeUris.length) {
        return;
      }
      return {
        handledMimeType: Mimes.uriList,
        insertText: relativeUris.join(" "),
        label: entries.length > 1 ? localize("defaultDropProvider.uriList.relativePaths", "Insert Relative Paths") : localize("defaultDropProvider.uriList.relativePath", "Insert Relative Path"),
        detail: builtInLabel
      };
    });
  }
};
RelativePathProvider = __decorate19([
  __param19(0, IWorkspaceContextService)
], RelativePathProvider);
function extractUriList(dataTransfer) {
  return __awaiter18(this, void 0, void 0, function* () {
    const urlListEntry = dataTransfer.get(Mimes.uriList);
    if (!urlListEntry) {
      return [];
    }
    const strUriList = yield urlListEntry.asString();
    const entries = [];
    for (const entry of UriList.parse(strUriList)) {
      try {
        entries.push({ uri: URI.parse(entry), originalText: entry });
      } catch (_a) {
      }
    }
    return entries;
  });
}
var DefaultDropProvidersFeature = class DefaultDropProvidersFeature2 extends Disposable {
  constructor(languageFeaturesService, workspaceContextService) {
    super();
    this._register(languageFeaturesService.documentOnDropEditProvider.register("*", new DefaultTextProvider()));
    this._register(languageFeaturesService.documentOnDropEditProvider.register("*", new PathProvider()));
    this._register(languageFeaturesService.documentOnDropEditProvider.register("*", new RelativePathProvider(workspaceContextService)));
  }
};
DefaultDropProvidersFeature = __decorate19([
  __param19(0, ILanguageFeaturesService),
  __param19(1, IWorkspaceContextService)
], DefaultDropProvidersFeature);
var DefaultPasteProvidersFeature = class DefaultPasteProvidersFeature2 extends Disposable {
  constructor(languageFeaturesService, workspaceContextService) {
    super();
    this._register(languageFeaturesService.documentPasteEditProvider.register("*", new DefaultTextProvider()));
    this._register(languageFeaturesService.documentPasteEditProvider.register("*", new PathProvider()));
    this._register(languageFeaturesService.documentPasteEditProvider.register("*", new RelativePathProvider(workspaceContextService)));
  }
};
DefaultPasteProvidersFeature = __decorate19([
  __param19(0, ILanguageFeaturesService),
  __param19(1, IWorkspaceContextService)
], DefaultPasteProvidersFeature);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteContribution.js
init_nls();
registerEditorContribution(
  CopyPasteController.ID,
  CopyPasteController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorFeature(DefaultPasteProvidersFeature);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: changePasteTypeCommandId,
      precondition: pasteWidgetVisibleCtx,
      kbOpts: {
        weight: 100,
        primary: 2048 | 89
      }
    });
  }
  runEditorCommand(_accessor, editor2, _args) {
    var _a;
    return (_a = CopyPasteController.get(editor2)) === null || _a === void 0 ? void 0 : _a.changePasteType();
  }
}());
registerEditorAction(class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.pasteAs",
      label: localize("pasteAs", "Paste As..."),
      alias: "Paste As...",
      precondition: void 0,
      description: {
        description: "Paste as",
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "id": {
                type: "string",
                description: localize("pasteAs.id", "The id of the paste edit to try applying. If not provided, the editor will show a picker.")
              }
            }
          }
        }]
      }
    });
  }
  run(_accessor, editor2, args) {
    var _a;
    const id = typeof (args === null || args === void 0 ? void 0 : args.id) === "string" ? args.id : void 0;
    return (_a = CopyPasteController.get(editor2)) === null || _a === void 0 ? void 0 : _a.pasteAs(id);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorContribution.js
init_editorExtensions();
init_nls();
init_configurationRegistry();
init_platform2();

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js
init_arrays();
init_async();
init_lifecycle();
init_range();
init_languageFeatures();
init_editorState();
init_nls();
init_configuration();
init_contextkey();
init_instantiation();
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DropIntoEditorController_1;
var defaultProviderConfig = "editor.experimental.dropIntoEditor.defaultProvider";
var changeDropTypeCommandId = "editor.changeDropType";
var dropWidgetVisibleCtx = new RawContextKey("dropWidgetVisible", false, localize("dropWidgetVisible", "Whether the drop widget is showing"));
var DropIntoEditorController = DropIntoEditorController_1 = class DropIntoEditorController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(DropIntoEditorController_1.ID);
  }
  constructor(editor2, instantiationService, _configService, _languageFeaturesService, _treeViewsDragAndDropService) {
    super();
    this._configService = _configService;
    this._languageFeaturesService = _languageFeaturesService;
    this._treeViewsDragAndDropService = _treeViewsDragAndDropService;
    this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
    this._dropProgressManager = this._register(instantiationService.createInstance(InlineProgressManager, "dropIntoEditor", editor2));
    this._postDropWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, "dropIntoEditor", editor2, dropWidgetVisibleCtx, { id: changeDropTypeCommandId, label: localize("postDropWidgetTitle", "Show drop options...") }));
    this._register(editor2.onDropIntoEditor((e) => this.onDropIntoEditor(editor2, e.position, e.event)));
  }
  clearWidgets() {
    this._postDropWidgetManager.clear();
  }
  changeDropType() {
    this._postDropWidgetManager.tryShowSelector();
  }
  onDropIntoEditor(editor2, position, dragEvent) {
    var _a;
    return __awaiter19(this, void 0, void 0, function* () {
      if (!dragEvent.dataTransfer || !editor2.hasModel()) {
        return;
      }
      (_a = this._currentOperation) === null || _a === void 0 ? void 0 : _a.cancel();
      editor2.focus();
      editor2.setPosition(position);
      const p = createCancelablePromise((token) => __awaiter19(this, void 0, void 0, function* () {
        const tokenSource = new EditorStateCancellationTokenSource(editor2, 1, void 0, token);
        try {
          const ourDataTransfer = yield this.extractDataTransferData(dragEvent);
          if (ourDataTransfer.size === 0 || tokenSource.token.isCancellationRequested) {
            return;
          }
          const model = editor2.getModel();
          if (!model) {
            return;
          }
          const providers = this._languageFeaturesService.documentOnDropEditProvider.ordered(model).filter((provider) => {
            if (!provider.dropMimeTypes) {
              return true;
            }
            return provider.dropMimeTypes.some((mime) => ourDataTransfer.matches(mime));
          });
          const edits = yield this.getDropEdits(providers, model, position, ourDataTransfer, tokenSource);
          if (tokenSource.token.isCancellationRequested) {
            return;
          }
          if (edits.length) {
            const activeEditIndex = this.getInitialActiveEditIndex(model, edits);
            const canShowWidget = editor2.getOption(
              35
              /* EditorOption.dropIntoEditor */
            ).showDropSelector === "afterDrop";
            yield this._postDropWidgetManager.applyEditAndShowIfNeeded([Range.fromPositions(position)], { activeEditIndex, allEdits: edits }, canShowWidget, token);
          }
        } finally {
          tokenSource.dispose();
          if (this._currentOperation === p) {
            this._currentOperation = void 0;
          }
        }
      }));
      this._dropProgressManager.showWhile(position, localize("dropIntoEditorProgress", "Running drop handlers. Click to cancel"), p);
      this._currentOperation = p;
    });
  }
  getDropEdits(providers, model, position, dataTransfer, tokenSource) {
    return __awaiter19(this, void 0, void 0, function* () {
      const results = yield raceCancellation(Promise.all(providers.map((provider) => __awaiter19(this, void 0, void 0, function* () {
        try {
          const edit = yield provider.provideDocumentOnDropEdits(model, position, dataTransfer, tokenSource.token);
          if (edit) {
            return Object.assign(Object.assign({}, edit), { providerId: provider.id });
          }
        } catch (err) {
          console.error(err);
        }
        return void 0;
      }))), tokenSource.token);
      const edits = coalesce(results !== null && results !== void 0 ? results : []);
      return sortEditsByYieldTo(edits);
    });
  }
  getInitialActiveEditIndex(model, edits) {
    const preferredProviders = this._configService.getValue(defaultProviderConfig, { resource: model.uri });
    for (const [configMime, desiredId] of Object.entries(preferredProviders)) {
      const editIndex = edits.findIndex((edit) => desiredId === edit.providerId && edit.handledMimeType && matchesMimeType(configMime, [edit.handledMimeType]));
      if (editIndex >= 0) {
        return editIndex;
      }
    }
    return 0;
  }
  extractDataTransferData(dragEvent) {
    return __awaiter19(this, void 0, void 0, function* () {
      if (!dragEvent.dataTransfer) {
        return new VSDataTransfer();
      }
      const dataTransfer = toExternalVSDataTransfer(dragEvent.dataTransfer);
      if (this.treeItemsTransfer.hasData(DraggedTreeItemsIdentifier.prototype)) {
        const data = this.treeItemsTransfer.getData(DraggedTreeItemsIdentifier.prototype);
        if (Array.isArray(data)) {
          for (const id of data) {
            const treeDataTransfer = yield this._treeViewsDragAndDropService.removeDragOperationTransfer(id.identifier);
            if (treeDataTransfer) {
              for (const [type, value] of treeDataTransfer) {
                dataTransfer.replace(type, value);
              }
            }
          }
        }
      }
      return dataTransfer;
    });
  }
};
DropIntoEditorController.ID = "editor.contrib.dropIntoEditorController";
DropIntoEditorController = DropIntoEditorController_1 = __decorate20([
  __param20(1, IInstantiationService),
  __param20(2, IConfigurationService),
  __param20(3, ILanguageFeaturesService),
  __param20(4, ITreeViewsDnDService)
], DropIntoEditorController);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorContribution.js
registerEditorContribution(
  DropIntoEditorController.ID,
  DropIntoEditorController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: changeDropTypeCommandId,
      precondition: dropWidgetVisibleCtx,
      kbOpts: {
        weight: 100,
        primary: 2048 | 89
      }
    });
  }
  runEditorCommand(_accessor, editor2, _args) {
    var _a;
    (_a = DropIntoEditorController.get(editor2)) === null || _a === void 0 ? void 0 : _a.changeDropType();
  }
}());
registerEditorFeature(DefaultDropProvidersFeature);
Registry.as(Extensions.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {
  [defaultProviderConfig]: {
    type: "object",
    scope: 5,
    description: localize("defaultProviderDescription", "Configures the default drop provider to use for content of a given mime type."),
    default: {},
    additionalProperties: {
      type: "string"
    }
  }
} }));

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findController.js
init_async();
init_lifecycle();
init_strings();
init_editorExtensions();
init_editorColorRegistry();
init_editorContextKeys();
init_model();

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js
init_arrays();
init_async();
init_lifecycle();
init_position();
init_range();
init_selection();
init_textModelSearch();

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findDecorations.js
init_range();
init_model();
init_textModel();
init_colorRegistry();
init_themeService();
var FindDecorations = class _FindDecorations {
  constructor(editor2) {
    this._editor = editor2;
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
    this._startPosition = this._editor.getPosition();
  }
  dispose() {
    this._editor.removeDecorations(this._allDecorations());
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  reset() {
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  getCount() {
    return this._decorations.length;
  }
  /** @deprecated use getFindScopes to support multiple selections */
  getFindScope() {
    if (this._findScopeDecorationIds[0]) {
      return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);
    }
    return null;
  }
  getFindScopes() {
    if (this._findScopeDecorationIds.length) {
      const scopes = this._findScopeDecorationIds.map((findScopeDecorationId) => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter((element) => !!element);
      if (scopes.length) {
        return scopes;
      }
    }
    return null;
  }
  getStartPosition() {
    return this._startPosition;
  }
  setStartPosition(newStartPosition) {
    this._startPosition = newStartPosition;
    this.setCurrentFindMatch(null);
  }
  _getDecorationIndex(decorationId) {
    const index = this._decorations.indexOf(decorationId);
    if (index >= 0) {
      return index + 1;
    }
    return 1;
  }
  getDecorationRangeAt(index) {
    const decorationId = index < this._decorations.length ? this._decorations[index] : null;
    if (decorationId) {
      return this._editor.getModel().getDecorationRange(decorationId);
    }
    return null;
  }
  getCurrentMatchesPosition(desiredRange) {
    const candidates = this._editor.getModel().getDecorationsInRange(desiredRange);
    for (const candidate of candidates) {
      const candidateOpts = candidate.options;
      if (candidateOpts === _FindDecorations._FIND_MATCH_DECORATION || candidateOpts === _FindDecorations._CURRENT_FIND_MATCH_DECORATION) {
        return this._getDecorationIndex(candidate.id);
      }
    }
    return 0;
  }
  setCurrentFindMatch(nextMatch) {
    let newCurrentDecorationId = null;
    let matchPosition = 0;
    if (nextMatch) {
      for (let i = 0, len = this._decorations.length; i < len; i++) {
        const range = this._editor.getModel().getDecorationRange(this._decorations[i]);
        if (nextMatch.equalsRange(range)) {
          newCurrentDecorationId = this._decorations[i];
          matchPosition = i + 1;
          break;
        }
      }
    }
    if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
      this._editor.changeDecorations((changeAccessor) => {
        if (this._highlightedDecorationId !== null) {
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, _FindDecorations._FIND_MATCH_DECORATION);
          this._highlightedDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          this._highlightedDecorationId = newCurrentDecorationId;
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, _FindDecorations._CURRENT_FIND_MATCH_DECORATION);
        }
        if (this._rangeHighlightDecorationId !== null) {
          changeAccessor.removeDecoration(this._rangeHighlightDecorationId);
          this._rangeHighlightDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);
          if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {
            const lineBeforeEnd = rng.endLineNumber - 1;
            const lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);
            rng = new Range(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);
          }
          this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, _FindDecorations._RANGE_HIGHLIGHT_DECORATION);
        }
      });
    }
    return matchPosition;
  }
  set(findMatches, findScopes) {
    this._editor.changeDecorations((accessor) => {
      let findMatchesOptions = _FindDecorations._FIND_MATCH_DECORATION;
      const newOverviewRulerApproximateDecorations = [];
      if (findMatches.length > 1e3) {
        findMatchesOptions = _FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;
        const lineCount = this._editor.getModel().getLineCount();
        const height = this._editor.getLayoutInfo().height;
        const approxPixelsPerLine = height / lineCount;
        const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));
        let prevStartLineNumber = findMatches[0].range.startLineNumber;
        let prevEndLineNumber = findMatches[0].range.endLineNumber;
        for (let i = 1, len = findMatches.length; i < len; i++) {
          const range = findMatches[i].range;
          if (prevEndLineNumber + mergeLinesDelta >= range.startLineNumber) {
            if (range.endLineNumber > prevEndLineNumber) {
              prevEndLineNumber = range.endLineNumber;
            }
          } else {
            newOverviewRulerApproximateDecorations.push({
              range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
              options: _FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
            });
            prevStartLineNumber = range.startLineNumber;
            prevEndLineNumber = range.endLineNumber;
          }
        }
        newOverviewRulerApproximateDecorations.push({
          range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
          options: _FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
        });
      }
      const newFindMatchesDecorations = new Array(findMatches.length);
      for (let i = 0, len = findMatches.length; i < len; i++) {
        newFindMatchesDecorations[i] = {
          range: findMatches[i].range,
          options: findMatchesOptions
        };
      }
      this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations);
      this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);
      if (this._rangeHighlightDecorationId) {
        accessor.removeDecoration(this._rangeHighlightDecorationId);
        this._rangeHighlightDecorationId = null;
      }
      if (this._findScopeDecorationIds.length) {
        this._findScopeDecorationIds.forEach((findScopeDecorationId) => accessor.removeDecoration(findScopeDecorationId));
        this._findScopeDecorationIds = [];
      }
      if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) {
        this._findScopeDecorationIds = findScopes.map((findScope) => accessor.addDecoration(findScope, _FindDecorations._FIND_SCOPE_DECORATION));
      }
    });
  }
  matchBeforePosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = this._decorations.length - 1; i >= 0; i--) {
      const decorationId = this._decorations[i];
      const r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.endLineNumber > position.lineNumber) {
        continue;
      }
      if (r.endLineNumber < position.lineNumber) {
        return r;
      }
      if (r.endColumn > position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
  }
  matchAfterPosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = 0, len = this._decorations.length; i < len; i++) {
      const decorationId = this._decorations[i];
      const r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.startLineNumber < position.lineNumber) {
        continue;
      }
      if (r.startLineNumber > position.lineNumber) {
        return r;
      }
      if (r.startColumn < position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[0]);
  }
  _allDecorations() {
    let result = [];
    result = result.concat(this._decorations);
    result = result.concat(this._overviewRulerApproximateDecorations);
    if (this._findScopeDecorationIds.length) {
      result.push(...this._findScopeDecorationIds);
    }
    if (this._rangeHighlightDecorationId) {
      result.push(this._rangeHighlightDecorationId);
    }
    return result;
  }
};
FindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "current-find-match",
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "find-match",
  stickiness: 1,
  zIndex: 10,
  className: "findMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-no-overview",
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: true
});
FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-only-overview",
  stickiness: 1,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  }
});
FindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
  description: "find-range-highlight",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: true
});
FindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({
  description: "find-scope",
  className: "findScope",
  isWholeLine: true
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replaceAllCommand.js
init_range();
var ReplaceAllCommand = class {
  constructor(editorSelection, ranges, replaceStrings) {
    this._editorSelection = editorSelection;
    this._ranges = ranges;
    this._replaceStrings = replaceStrings;
    this._trackedEditorSelectionId = null;
  }
  getEditOperations(model, builder) {
    if (this._ranges.length > 0) {
      const ops = [];
      for (let i = 0; i < this._ranges.length; i++) {
        ops.push({
          range: this._ranges[i],
          text: this._replaceStrings[i]
        });
      }
      ops.sort((o1, o2) => {
        return Range.compareRangesUsingStarts(o1.range, o2.range);
      });
      const resultOps = [];
      let previousOp = ops[0];
      for (let i = 1; i < ops.length; i++) {
        if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {
          previousOp.range = previousOp.range.plusRange(ops[i].range);
          previousOp.text = previousOp.text + ops[i].text;
        } else {
          resultOps.push(previousOp);
          previousOp = ops[i];
        }
      }
      resultOps.push(previousOp);
      for (const op of resultOps) {
        builder.addEditOperation(op.range, op.text);
      }
    }
    this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._trackedEditorSelectionId);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replacePattern.js
var StaticValueReplacePattern = class {
  constructor(staticValue) {
    this.staticValue = staticValue;
    this.kind = 0;
  }
};
var DynamicPiecesReplacePattern = class {
  constructor(pieces) {
    this.pieces = pieces;
    this.kind = 1;
  }
};
var ReplacePattern = class _ReplacePattern {
  static fromStaticValue(value) {
    return new _ReplacePattern([ReplacePiece.staticValue(value)]);
  }
  get hasReplacementPatterns() {
    return this._state.kind === 1;
  }
  constructor(pieces) {
    if (!pieces || pieces.length === 0) {
      this._state = new StaticValueReplacePattern("");
    } else if (pieces.length === 1 && pieces[0].staticValue !== null) {
      this._state = new StaticValueReplacePattern(pieces[0].staticValue);
    } else {
      this._state = new DynamicPiecesReplacePattern(pieces);
    }
  }
  buildReplaceString(matches, preserveCase) {
    if (this._state.kind === 0) {
      if (preserveCase) {
        return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);
      } else {
        return this._state.staticValue;
      }
    }
    let result = "";
    for (let i = 0, len = this._state.pieces.length; i < len; i++) {
      const piece = this._state.pieces[i];
      if (piece.staticValue !== null) {
        result += piece.staticValue;
        continue;
      }
      let match = _ReplacePattern._substitute(piece.matchIndex, matches);
      if (piece.caseOps !== null && piece.caseOps.length > 0) {
        const repl = [];
        const lenOps = piece.caseOps.length;
        let opIdx = 0;
        for (let idx = 0, len2 = match.length; idx < len2; idx++) {
          if (opIdx >= lenOps) {
            repl.push(match.slice(idx));
            break;
          }
          switch (piece.caseOps[opIdx]) {
            case "U":
              repl.push(match[idx].toUpperCase());
              break;
            case "u":
              repl.push(match[idx].toUpperCase());
              opIdx++;
              break;
            case "L":
              repl.push(match[idx].toLowerCase());
              break;
            case "l":
              repl.push(match[idx].toLowerCase());
              opIdx++;
              break;
            default:
              repl.push(match[idx]);
          }
        }
        match = repl.join("");
      }
      result += match;
    }
    return result;
  }
  static _substitute(matchIndex, matches) {
    if (matches === null) {
      return "";
    }
    if (matchIndex === 0) {
      return matches[0];
    }
    let remainder = "";
    while (matchIndex > 0) {
      if (matchIndex < matches.length) {
        const match = matches[matchIndex] || "";
        return match + remainder;
      }
      remainder = String(matchIndex % 10) + remainder;
      matchIndex = Math.floor(matchIndex / 10);
    }
    return "$" + remainder;
  }
};
var ReplacePiece = class _ReplacePiece {
  static staticValue(value) {
    return new _ReplacePiece(value, -1, null);
  }
  static matchIndex(index) {
    return new _ReplacePiece(null, index, null);
  }
  static caseOps(index, caseOps) {
    return new _ReplacePiece(null, index, caseOps);
  }
  constructor(staticValue, matchIndex, caseOps) {
    this.staticValue = staticValue;
    this.matchIndex = matchIndex;
    if (!caseOps || caseOps.length === 0) {
      this.caseOps = null;
    } else {
      this.caseOps = caseOps.slice(0);
    }
  }
};
var ReplacePieceBuilder = class {
  constructor(source) {
    this._source = source;
    this._lastCharIndex = 0;
    this._result = [];
    this._resultLen = 0;
    this._currentStaticPiece = "";
  }
  emitUnchanged(toCharIndex) {
    this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
    this._lastCharIndex = toCharIndex;
  }
  emitStatic(value, toCharIndex) {
    this._emitStatic(value);
    this._lastCharIndex = toCharIndex;
  }
  _emitStatic(value) {
    if (value.length === 0) {
      return;
    }
    this._currentStaticPiece += value;
  }
  emitMatchIndex(index, toCharIndex, caseOps) {
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    this._result[this._resultLen++] = ReplacePiece.caseOps(index, caseOps);
    this._lastCharIndex = toCharIndex;
  }
  finalize() {
    this.emitUnchanged(this._source.length);
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    return new ReplacePattern(this._result);
  }
};
function parseReplaceString(replaceString) {
  if (!replaceString || replaceString.length === 0) {
    return new ReplacePattern(null);
  }
  const caseOps = [];
  const result = new ReplacePieceBuilder(replaceString);
  for (let i = 0, len = replaceString.length; i < len; i++) {
    const chCode = replaceString.charCodeAt(i);
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = replaceString.charCodeAt(i);
      switch (nextChCode) {
        case 92:
          result.emitUnchanged(i - 1);
          result.emitStatic("\\", i + 1);
          break;
        case 110:
          result.emitUnchanged(i - 1);
          result.emitStatic("\n", i + 1);
          break;
        case 116:
          result.emitUnchanged(i - 1);
          result.emitStatic("	", i + 1);
          break;
        case 117:
        case 85:
        case 108:
        case 76:
          result.emitUnchanged(i - 1);
          result.emitStatic("", i + 1);
          caseOps.push(String.fromCharCode(nextChCode));
          break;
      }
      continue;
    }
    if (chCode === 36) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = replaceString.charCodeAt(i);
      if (nextChCode === 36) {
        result.emitUnchanged(i - 1);
        result.emitStatic("$", i + 1);
        continue;
      }
      if (nextChCode === 48 || nextChCode === 38) {
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(0, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
      if (49 <= nextChCode && nextChCode <= 57) {
        let matchIndex = nextChCode - 48;
        if (i + 1 < len) {
          const nextNextChCode = replaceString.charCodeAt(i + 1);
          if (48 <= nextNextChCode && nextNextChCode <= 57) {
            i++;
            matchIndex = matchIndex * 10 + (nextNextChCode - 48);
            result.emitUnchanged(i - 2);
            result.emitMatchIndex(matchIndex, i + 1, caseOps);
            caseOps.length = 0;
            continue;
          }
        }
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(matchIndex, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
    }
  }
  return result.finalize();
}

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js
init_contextkey();
var CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey("findWidgetVisible", false);
var CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();
var CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey("findInputFocussed", false);
var CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey("replaceInputFocussed", false);
var ToggleCaseSensitiveKeybinding = {
  primary: 512 | 33,
  mac: {
    primary: 2048 | 512 | 33
    /* KeyCode.KeyC */
  }
};
var ToggleWholeWordKeybinding = {
  primary: 512 | 53,
  mac: {
    primary: 2048 | 512 | 53
    /* KeyCode.KeyW */
  }
};
var ToggleRegexKeybinding = {
  primary: 512 | 48,
  mac: {
    primary: 2048 | 512 | 48
    /* KeyCode.KeyR */
  }
};
var ToggleSearchScopeKeybinding = {
  primary: 512 | 42,
  mac: {
    primary: 2048 | 512 | 42
    /* KeyCode.KeyL */
  }
};
var TogglePreserveCaseKeybinding = {
  primary: 512 | 46,
  mac: {
    primary: 2048 | 512 | 46
    /* KeyCode.KeyP */
  }
};
var FIND_IDS = {
  StartFindAction: "actions.find",
  StartFindWithSelection: "actions.findWithSelection",
  StartFindWithArgs: "editor.actions.findWithArgs",
  NextMatchFindAction: "editor.action.nextMatchFindAction",
  PreviousMatchFindAction: "editor.action.previousMatchFindAction",
  GoToMatchFindAction: "editor.action.goToMatchFindAction",
  NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
  PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
  StartFindReplaceAction: "editor.action.startFindReplaceAction",
  CloseFindWidgetCommand: "closeFindWidget",
  ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
  ToggleWholeWordCommand: "toggleFindWholeWord",
  ToggleRegexCommand: "toggleFindRegex",
  ToggleSearchScopeCommand: "toggleFindInSelection",
  TogglePreserveCaseCommand: "togglePreserveCase",
  ReplaceOneAction: "editor.action.replaceOne",
  ReplaceAllAction: "editor.action.replaceAll",
  SelectAllMatchesAction: "editor.action.selectAllMatches"
};
var MATCHES_LIMIT = 19999;
var RESEARCH_DELAY = 240;
var FindModelBoundToEditorModel = class _FindModelBoundToEditorModel {
  constructor(editor2, state) {
    this._toDispose = new DisposableStore();
    this._editor = editor2;
    this._state = state;
    this._isDisposed = false;
    this._startSearchingTimer = new TimeoutTimer();
    this._decorations = new FindDecorations(editor2);
    this._toDispose.add(this._decorations);
    this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);
    this._toDispose.add(this._updateDecorationsScheduler);
    this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {
      if (e.reason === 3 || e.reason === 5 || e.reason === 6) {
        this._decorations.setStartPosition(this._editor.getPosition());
      }
    }));
    this._ignoreModelContentChanged = false;
    this._toDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (this._ignoreModelContentChanged) {
        return;
      }
      if (e.isFlush) {
        this._decorations.reset();
      }
      this._decorations.setStartPosition(this._editor.getPosition());
      this._updateDecorationsScheduler.schedule();
    }));
    this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this.research(false, this._state.searchScope);
  }
  dispose() {
    this._isDisposed = true;
    dispose(this._startSearchingTimer);
    this._toDispose.dispose();
  }
  _onStateChanged(e) {
    if (this._isDisposed) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
      const model = this._editor.getModel();
      if (model.isTooLargeForSyncing()) {
        this._startSearchingTimer.cancel();
        this._startSearchingTimer.setIfNotSet(() => {
          if (e.searchScope) {
            this.research(e.moveCursor, this._state.searchScope);
          } else {
            this.research(e.moveCursor);
          }
        }, RESEARCH_DELAY);
      } else {
        if (e.searchScope) {
          this.research(e.moveCursor, this._state.searchScope);
        } else {
          this.research(e.moveCursor);
        }
      }
    }
  }
  static _getSearchRange(model, findScope) {
    if (findScope) {
      return findScope;
    }
    return model.getFullModelRange();
  }
  research(moveCursor, newFindScope) {
    let findScopes = null;
    if (typeof newFindScope !== "undefined") {
      if (newFindScope !== null) {
        if (!Array.isArray(newFindScope)) {
          findScopes = [newFindScope];
        } else {
          findScopes = newFindScope;
        }
      }
    } else {
      findScopes = this._decorations.getFindScopes();
    }
    if (findScopes !== null) {
      findScopes = findScopes.map((findScope) => {
        if (findScope.startLineNumber !== findScope.endLineNumber) {
          let endLineNumber = findScope.endLineNumber;
          if (findScope.endColumn === 1) {
            endLineNumber = endLineNumber - 1;
          }
          return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));
        }
        return findScope;
      });
    }
    const findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);
    this._decorations.set(findMatches, findScopes);
    const editorSelection = this._editor.getSelection();
    let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);
    if (currentMatchesPosition === 0 && findMatches.length > 0) {
      const matchAfterSelection = findFirstInSorted(findMatches.map((match) => match.range), (range) => Range.compareRangesUsingStarts(range, editorSelection) >= 0);
      currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 : currentMatchesPosition;
    }
    this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), void 0);
    if (moveCursor && this._editor.getOption(
      40
      /* EditorOption.find */
    ).cursorMoveOnType) {
      this._moveToNextMatch(this._decorations.getStartPosition());
    }
  }
  _hasMatches() {
    return this._state.matchesCount > 0;
  }
  _cannotFind() {
    if (!this._hasMatches()) {
      const findScope = this._decorations.getFindScope();
      if (findScope) {
        this._editor.revealRangeInCenterIfOutsideViewport(
          findScope,
          0
          /* ScrollType.Smooth */
        );
      }
      return true;
    }
    return false;
  }
  _setCurrentFindMatch(match) {
    const matchesPosition = this._decorations.setCurrentFindMatch(match);
    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);
    this._editor.setSelection(match);
    this._editor.revealRangeInCenterIfOutsideViewport(
      match,
      0
      /* ScrollType.Smooth */
    );
  }
  _prevSearchPosition(before) {
    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = before;
    const model = this._editor.getModel();
    if (isUsingLineStops || column === 1) {
      if (lineNumber === 1) {
        lineNumber = model.getLineCount();
      } else {
        lineNumber--;
      }
      column = model.getLineMaxColumn(lineNumber);
    } else {
      column--;
    }
    return new Position(lineNumber, column);
  }
  _moveToPrevMatch(before, isRecursed = false) {
    if (!this._state.canNavigateBack()) {
      const nextMatchRange = this._decorations.matchAfterPosition(before);
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let prevMatchRange = this._decorations.matchBeforePosition(before);
      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {
        before = this._prevSearchPosition(before);
        prevMatchRange = this._decorations.matchBeforePosition(before);
      }
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._cannotFind()) {
      return;
    }
    const findScope = this._decorations.getFindScope();
    const searchRange = _FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(before)) {
      before = searchRange.getEndPosition();
    }
    if (before.isBefore(searchRange.getStartPosition())) {
      before = searchRange.getEndPosition();
    }
    const { lineNumber, column } = before;
    const model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, false);
    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
      position = this._prevSearchPosition(position);
      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
        128
        /* EditorOption.wordSeparators */
      ) : null, false);
    }
    if (!prevMatch) {
      return;
    }
    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {
      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
    }
    this._setCurrentFindMatch(prevMatch.range);
  }
  moveToPrevMatch() {
    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
  }
  _nextSearchPosition(after) {
    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = after;
    const model = this._editor.getModel();
    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
      if (lineNumber === model.getLineCount()) {
        lineNumber = 1;
      } else {
        lineNumber++;
      }
      column = 1;
    } else {
      column++;
    }
    return new Position(lineNumber, column);
  }
  _moveToNextMatch(after) {
    if (!this._state.canNavigateForward()) {
      const prevMatchRange = this._decorations.matchBeforePosition(after);
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let nextMatchRange = this._decorations.matchAfterPosition(after);
      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {
        after = this._nextSearchPosition(after);
        nextMatchRange = this._decorations.matchAfterPosition(after);
      }
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    const nextMatch = this._getNextMatch(after, false, true);
    if (nextMatch) {
      this._setCurrentFindMatch(nextMatch.range);
    }
  }
  _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {
    if (this._cannotFind()) {
      return null;
    }
    const findScope = this._decorations.getFindScope();
    const searchRange = _FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(after)) {
      after = searchRange.getStartPosition();
    }
    if (after.isBefore(searchRange.getStartPosition())) {
      after = searchRange.getStartPosition();
    }
    const { lineNumber, column } = after;
    const model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, captureMatches);
    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
      position = this._nextSearchPosition(position);
      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
        128
        /* EditorOption.wordSeparators */
      ) : null, captureMatches);
    }
    if (!nextMatch) {
      return null;
    }
    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {
      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);
    }
    return nextMatch;
  }
  moveToNextMatch() {
    this._moveToNextMatch(this._editor.getSelection().getEndPosition());
  }
  _moveToMatch(index) {
    const decorationRange = this._decorations.getDecorationRangeAt(index);
    if (decorationRange) {
      this._setCurrentFindMatch(decorationRange);
    }
  }
  moveToMatch(index) {
    this._moveToMatch(index);
  }
  _getReplacePattern() {
    if (this._state.isRegex) {
      return parseReplaceString(this._state.replaceString);
    }
    return ReplacePattern.fromStaticValue(this._state.replaceString);
  }
  replace() {
    if (!this._hasMatches()) {
      return;
    }
    const replacePattern = this._getReplacePattern();
    const selection = this._editor.getSelection();
    const nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);
    if (nextMatch) {
      if (selection.equalsRange(nextMatch.range)) {
        const replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);
        const command = new ReplaceCommand(selection, replaceString);
        this._executeEditorCommand("replace", command);
        this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));
        this.research(true);
      } else {
        this._decorations.setStartPosition(this._editor.getPosition());
        this._setCurrentFindMatch(nextMatch.range);
      }
    }
  }
  _findMatches(findScopes, captureMatches, limitResultCount) {
    const searchRanges = (findScopes || [null]).map((scope) => _FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));
    return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, captureMatches, limitResultCount);
  }
  replaceAll() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {
      this._largeReplaceAll();
    } else {
      this._regularReplaceAll(findScopes);
    }
    this.research(false);
  }
  _largeReplaceAll() {
    const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return;
    }
    let searchRegex = searchData.regex;
    if (!searchRegex.multiline) {
      let mod = "mu";
      if (searchRegex.ignoreCase) {
        mod += "i";
      }
      if (searchRegex.global) {
        mod += "g";
      }
      searchRegex = new RegExp(searchRegex.source, mod);
    }
    const model = this._editor.getModel();
    const modelText = model.getValue(
      1
      /* EndOfLinePreference.LF */
    );
    const fullModelRange = model.getFullModelRange();
    const replacePattern = this._getReplacePattern();
    let resultText;
    const preserveCase = this._state.preserveCase;
    if (replacePattern.hasReplacementPatterns || preserveCase) {
      resultText = modelText.replace(searchRegex, function() {
        return replacePattern.buildReplaceString(arguments, preserveCase);
      });
    } else {
      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));
    }
    const command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());
    this._executeEditorCommand("replaceAll", command);
  }
  _regularReplaceAll(findScopes) {
    const replacePattern = this._getReplacePattern();
    const matches = this._findMatches(
      findScopes,
      replacePattern.hasReplacementPatterns || this._state.preserveCase,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    const replaceStrings = [];
    for (let i = 0, len = matches.length; i < len; i++) {
      replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);
    }
    const command = new ReplaceAllCommand(this._editor.getSelection(), matches.map((m) => m.range), replaceStrings);
    this._executeEditorCommand("replaceAll", command);
  }
  selectAllMatches() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    const matches = this._findMatches(
      findScopes,
      false,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    let selections = matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));
    const editorSelection = this._editor.getSelection();
    for (let i = 0, len = selections.length; i < len; i++) {
      const sel = selections[i];
      if (sel.equalsRange(editorSelection)) {
        selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));
        break;
      }
    }
    this._editor.setSelections(selections);
  }
  _executeEditorCommand(source, command) {
    try {
      this._ignoreModelContentChanged = true;
      this._editor.pushUndoStop();
      this._editor.executeCommand(source, command);
      this._editor.pushUndoStop();
    } finally {
      this._ignoreModelContentChanged = false;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findOptionsWidget.js
init_dom();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findOptionsWidget.css";
init_async();
init_colorRegistry();
var FindOptionsWidget = class _FindOptionsWidget extends Widget {
  constructor(editor2, state, keybindingService) {
    super();
    this._hideSoon = this._register(new RunOnceScheduler(() => this._hide(), 2e3));
    this._isVisible = false;
    this._editor = editor2;
    this._state = state;
    this._keybindingService = keybindingService;
    this._domNode = document.createElement("div");
    this._domNode.className = "findOptionsWidget";
    this._domNode.style.display = "none";
    this._domNode.style.top = "10px";
    this._domNode.style.zIndex = "12";
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
    const toggleStyles = {
      inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
      inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),
      inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground)
    };
    this.caseSensitive = this._register(new CaseSensitiveToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand), isChecked: this._state.matchCase }, toggleStyles)));
    this._domNode.appendChild(this.caseSensitive.domNode);
    this._register(this.caseSensitive.onChange(() => {
      this._state.change({
        matchCase: this.caseSensitive.checked
      }, false);
    }));
    this.wholeWords = this._register(new WholeWordsToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand), isChecked: this._state.wholeWord }, toggleStyles)));
    this._domNode.appendChild(this.wholeWords.domNode);
    this._register(this.wholeWords.onChange(() => {
      this._state.change({
        wholeWord: this.wholeWords.checked
      }, false);
    }));
    this.regex = this._register(new RegexToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand), isChecked: this._state.isRegex }, toggleStyles)));
    this._domNode.appendChild(this.regex.domNode);
    this._register(this.regex.onChange(() => {
      this._state.change({
        isRegex: this.regex.checked
      }, false);
    }));
    this._editor.addOverlayWidget(this);
    this._register(this._state.onFindReplaceStateChange((e) => {
      let somethingChanged = false;
      if (e.isRegex) {
        this.regex.checked = this._state.isRegex;
        somethingChanged = true;
      }
      if (e.wholeWord) {
        this.wholeWords.checked = this._state.wholeWord;
        somethingChanged = true;
      }
      if (e.matchCase) {
        this.caseSensitive.checked = this._state.matchCase;
        somethingChanged = true;
      }
      if (!this._state.isRevealed && somethingChanged) {
        this._revealTemporarily();
      }
    }));
    this._register(addDisposableListener(this._domNode, EventType.MOUSE_LEAVE, (e) => this._onMouseLeave()));
    this._register(addDisposableListener(this._domNode, "mouseover", (e) => this._onMouseOver()));
  }
  _keybindingLabelFor(actionId) {
    const kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return _FindOptionsWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 0
      /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
    };
  }
  highlightFindOptions() {
    this._revealTemporarily();
  }
  _revealTemporarily() {
    this._show();
    this._hideSoon.schedule();
  }
  _onMouseLeave() {
    this._hideSoon.schedule();
  }
  _onMouseOver() {
    this._hideSoon.cancel();
  }
  _show() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._domNode.style.display = "block";
  }
  _hide() {
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._domNode.style.display = "none";
  }
};
FindOptionsWidget.ID = "editor.contrib.findOptionsWidget";

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findState.js
init_event();
init_lifecycle();
init_range();
function effectiveOptionValue(override, value) {
  if (override === 1) {
    return true;
  }
  if (override === 2) {
    return false;
  }
  return value;
}
var FindReplaceState = class extends Disposable {
  get searchString() {
    return this._searchString;
  }
  get replaceString() {
    return this._replaceString;
  }
  get isRevealed() {
    return this._isRevealed;
  }
  get isReplaceRevealed() {
    return this._isReplaceRevealed;
  }
  get isRegex() {
    return effectiveOptionValue(this._isRegexOverride, this._isRegex);
  }
  get wholeWord() {
    return effectiveOptionValue(this._wholeWordOverride, this._wholeWord);
  }
  get matchCase() {
    return effectiveOptionValue(this._matchCaseOverride, this._matchCase);
  }
  get preserveCase() {
    return effectiveOptionValue(this._preserveCaseOverride, this._preserveCase);
  }
  get actualIsRegex() {
    return this._isRegex;
  }
  get actualWholeWord() {
    return this._wholeWord;
  }
  get actualMatchCase() {
    return this._matchCase;
  }
  get actualPreserveCase() {
    return this._preserveCase;
  }
  get searchScope() {
    return this._searchScope;
  }
  get matchesPosition() {
    return this._matchesPosition;
  }
  get matchesCount() {
    return this._matchesCount;
  }
  get currentMatch() {
    return this._currentMatch;
  }
  get isSearching() {
    return this._isSearching;
  }
  get filters() {
    return this._filters;
  }
  constructor() {
    super();
    this._onFindReplaceStateChange = this._register(new Emitter());
    this.onFindReplaceStateChange = this._onFindReplaceStateChange.event;
    this._searchString = "";
    this._replaceString = "";
    this._isRevealed = false;
    this._isReplaceRevealed = false;
    this._isRegex = false;
    this._isRegexOverride = 0;
    this._wholeWord = false;
    this._wholeWordOverride = 0;
    this._matchCase = false;
    this._matchCaseOverride = 0;
    this._preserveCase = false;
    this._preserveCaseOverride = 0;
    this._searchScope = null;
    this._matchesPosition = 0;
    this._matchesCount = 0;
    this._currentMatch = null;
    this._loop = true;
    this._isSearching = false;
    this._filters = null;
  }
  changeMatchInfo(matchesPosition, matchesCount, currentMatch) {
    const changeEvent = {
      moveCursor: false,
      updateHistory: false,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false,
      isSearching: false,
      filters: false
    };
    let somethingChanged = false;
    if (matchesCount === 0) {
      matchesPosition = 0;
    }
    if (matchesPosition > matchesCount) {
      matchesPosition = matchesCount;
    }
    if (this._matchesPosition !== matchesPosition) {
      this._matchesPosition = matchesPosition;
      changeEvent.matchesPosition = true;
      somethingChanged = true;
    }
    if (this._matchesCount !== matchesCount) {
      this._matchesCount = matchesCount;
      changeEvent.matchesCount = true;
      somethingChanged = true;
    }
    if (typeof currentMatch !== "undefined") {
      if (!Range.equalsRange(this._currentMatch, currentMatch)) {
        this._currentMatch = currentMatch;
        changeEvent.currentMatch = true;
        somethingChanged = true;
      }
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  change(newState, moveCursor, updateHistory = true) {
    var _a;
    const changeEvent = {
      moveCursor,
      updateHistory,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false,
      isSearching: false,
      filters: false
    };
    let somethingChanged = false;
    const oldEffectiveIsRegex = this.isRegex;
    const oldEffectiveWholeWords = this.wholeWord;
    const oldEffectiveMatchCase = this.matchCase;
    const oldEffectivePreserveCase = this.preserveCase;
    if (typeof newState.searchString !== "undefined") {
      if (this._searchString !== newState.searchString) {
        this._searchString = newState.searchString;
        changeEvent.searchString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.replaceString !== "undefined") {
      if (this._replaceString !== newState.replaceString) {
        this._replaceString = newState.replaceString;
        changeEvent.replaceString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRevealed !== "undefined") {
      if (this._isRevealed !== newState.isRevealed) {
        this._isRevealed = newState.isRevealed;
        changeEvent.isRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isReplaceRevealed !== "undefined") {
      if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
        this._isReplaceRevealed = newState.isReplaceRevealed;
        changeEvent.isReplaceRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRegex !== "undefined") {
      this._isRegex = newState.isRegex;
    }
    if (typeof newState.wholeWord !== "undefined") {
      this._wholeWord = newState.wholeWord;
    }
    if (typeof newState.matchCase !== "undefined") {
      this._matchCase = newState.matchCase;
    }
    if (typeof newState.preserveCase !== "undefined") {
      this._preserveCase = newState.preserveCase;
    }
    if (typeof newState.searchScope !== "undefined") {
      if (!((_a = newState.searchScope) === null || _a === void 0 ? void 0 : _a.every((newSearchScope) => {
        var _a2;
        return (_a2 = this._searchScope) === null || _a2 === void 0 ? void 0 : _a2.some((existingSearchScope) => {
          return !Range.equalsRange(existingSearchScope, newSearchScope);
        });
      }))) {
        this._searchScope = newState.searchScope;
        changeEvent.searchScope = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.loop !== "undefined") {
      if (this._loop !== newState.loop) {
        this._loop = newState.loop;
        changeEvent.loop = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isSearching !== "undefined") {
      if (this._isSearching !== newState.isSearching) {
        this._isSearching = newState.isSearching;
        changeEvent.isSearching = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.filters !== "undefined") {
      if (this._filters) {
        this._filters.update(newState.filters);
      } else {
        this._filters = newState.filters;
      }
      changeEvent.filters = true;
      somethingChanged = true;
    }
    this._isRegexOverride = typeof newState.isRegexOverride !== "undefined" ? newState.isRegexOverride : 0;
    this._wholeWordOverride = typeof newState.wholeWordOverride !== "undefined" ? newState.wholeWordOverride : 0;
    this._matchCaseOverride = typeof newState.matchCaseOverride !== "undefined" ? newState.matchCaseOverride : 0;
    this._preserveCaseOverride = typeof newState.preserveCaseOverride !== "undefined" ? newState.preserveCaseOverride : 0;
    if (oldEffectiveIsRegex !== this.isRegex) {
      somethingChanged = true;
      changeEvent.isRegex = true;
    }
    if (oldEffectiveWholeWords !== this.wholeWord) {
      somethingChanged = true;
      changeEvent.wholeWord = true;
    }
    if (oldEffectiveMatchCase !== this.matchCase) {
      somethingChanged = true;
      changeEvent.matchCase = true;
    }
    if (oldEffectivePreserveCase !== this.preserveCase) {
      somethingChanged = true;
      changeEvent.preserveCase = true;
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  canNavigateBack() {
    return this.canNavigateInLoop() || this.matchesPosition !== 1;
  }
  canNavigateForward() {
    return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
  }
  canNavigateInLoop() {
    return this._loop || this.matchesCount >= MATCHES_LIMIT;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.js
init_dom();
init_aria();
init_async();
init_codicons();
init_errors();
init_lifecycle();
init_platform();
init_strings();
init_range();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.css";
init_nls();
init_colorRegistry();
init_themeService();
init_themables();
init_theme();
init_types();
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var findSelectionIcon = registerIcon("find-selection", Codicon.selection, localize("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget."));
var findCollapsedIcon = registerIcon("find-collapsed", Codicon.chevronRight, localize("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed."));
var findExpandedIcon = registerIcon("find-expanded", Codicon.chevronDown, localize("findExpandedIcon", "Icon to indicate that the editor find widget is expanded."));
var findReplaceIcon = registerIcon("find-replace", Codicon.replace, localize("findReplaceIcon", "Icon for 'Replace' in the editor find widget."));
var findReplaceAllIcon = registerIcon("find-replace-all", Codicon.replaceAll, localize("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget."));
var findPreviousMatchIcon = registerIcon("find-previous-match", Codicon.arrowUp, localize("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget."));
var findNextMatchIcon = registerIcon("find-next-match", Codicon.arrowDown, localize("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget."));
var NLS_FIND_DIALOG_LABEL = localize("label.findDialog", "Find / Replace");
var NLS_FIND_INPUT_LABEL = localize("label.find", "Find");
var NLS_FIND_INPUT_PLACEHOLDER = localize("placeholder.find", "Find");
var NLS_PREVIOUS_MATCH_BTN_LABEL = localize("label.previousMatchButton", "Previous Match");
var NLS_NEXT_MATCH_BTN_LABEL = localize("label.nextMatchButton", "Next Match");
var NLS_TOGGLE_SELECTION_FIND_TITLE = localize("label.toggleSelectionFind", "Find in Selection");
var NLS_CLOSE_BTN_LABEL = localize("label.closeButton", "Close");
var NLS_REPLACE_INPUT_LABEL = localize("label.replace", "Replace");
var NLS_REPLACE_INPUT_PLACEHOLDER = localize("placeholder.replace", "Replace");
var NLS_REPLACE_BTN_LABEL = localize("label.replaceButton", "Replace");
var NLS_REPLACE_ALL_BTN_LABEL = localize("label.replaceAllButton", "Replace All");
var NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = localize("label.toggleReplaceButton", "Toggle Replace");
var NLS_MATCHES_COUNT_LIMIT_TITLE = localize("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
var NLS_MATCHES_LOCATION = localize("label.matchesLocation", "{0} of {1}");
var NLS_NO_RESULTS = localize("label.noResults", "No results");
var FIND_WIDGET_INITIAL_WIDTH = 419;
var PART_WIDTH = 275;
var FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;
var MAX_MATCHES_COUNT_WIDTH = 69;
var FIND_INPUT_AREA_HEIGHT = 33;
var ctrlEnterReplaceAllWarningPromptedKey = "ctrlEnterReplaceAll.windows.donotask";
var ctrlKeyMod = isMacintosh ? 256 : 2048;
var FindWidgetViewZone = class {
  constructor(afterLineNumber) {
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = FIND_INPUT_AREA_HEIGHT;
    this.suppressMouseDown = false;
    this.domNode = document.createElement("div");
    this.domNode.className = "dock-find-viewzone";
  }
};
function stopPropagationForMultiLineUpwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionStart > 0) {
    event.stopPropagation();
    return;
  }
}
function stopPropagationForMultiLineDownwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {
    event.stopPropagation();
    return;
  }
}
var FindWidget = class _FindWidget extends Widget {
  constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService, storageService, notificationService) {
    super();
    this._cachedHeight = null;
    this._revealTimeouts = [];
    this._codeEditor = codeEditor;
    this._controller = controller;
    this._state = state;
    this._contextViewProvider = contextViewProvider;
    this._keybindingService = keybindingService;
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._notificationService = notificationService;
    this._ctrlEnterReplaceAllWarningPrompted = !!storageService.getBoolean(
      ctrlEnterReplaceAllWarningPromptedKey,
      0
      /* StorageScope.PROFILE */
    );
    this._isVisible = false;
    this._isReplaceVisible = false;
    this._ignoreChangeEvent = false;
    this._updateHistoryDelayer = new Delayer(500);
    this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._buildDomNode();
    this._updateButtons();
    this._tryUpdateWidgetWidth();
    this._findInput.inputBox.layout();
    this._register(this._codeEditor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        89
        /* EditorOption.readOnly */
      )) {
        if (this._codeEditor.getOption(
          89
          /* EditorOption.readOnly */
        )) {
          this._state.change({ isReplaceRevealed: false }, false);
        }
        this._updateButtons();
      }
      if (e.hasChanged(
        142
        /* EditorOption.layoutInfo */
      )) {
        this._tryUpdateWidgetWidth();
      }
      if (e.hasChanged(
        2
        /* EditorOption.accessibilitySupport */
      )) {
        this.updateAccessibilitySupport();
      }
      if (e.hasChanged(
        40
        /* EditorOption.find */
      )) {
        const supportLoop = this._codeEditor.getOption(
          40
          /* EditorOption.find */
        ).loop;
        this._state.change({ loop: supportLoop }, false);
        const addExtraSpaceOnTop = this._codeEditor.getOption(
          40
          /* EditorOption.find */
        ).addExtraSpaceOnTop;
        if (addExtraSpaceOnTop && !this._viewZone) {
          this._viewZone = new FindWidgetViewZone(0);
          this._showViewZone();
        }
        if (!addExtraSpaceOnTop && this._viewZone) {
          this._removeViewZone();
        }
      }
    }));
    this.updateAccessibilitySupport();
    this._register(this._codeEditor.onDidChangeCursorSelection(() => {
      if (this._isVisible) {
        this._updateToggleSelectionFindButton();
      }
    }));
    this._register(this._codeEditor.onDidFocusEditorWidget(() => __awaiter20(this, void 0, void 0, function* () {
      if (this._isVisible) {
        const globalBufferTerm = yield this._controller.getGlobalBufferTerm();
        if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {
          this._state.change({ searchString: globalBufferTerm }, false);
          this._findInput.select();
        }
      }
    })));
    this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
    this._findFocusTracker = this._register(trackFocus(this._findInput.inputBox.inputElement));
    this._register(this._findFocusTracker.onDidFocus(() => {
      this._findInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._findFocusTracker.onDidBlur(() => {
      this._findInputFocused.set(false);
    }));
    this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);
    this._replaceFocusTracker = this._register(trackFocus(this._replaceInput.inputBox.inputElement));
    this._register(this._replaceFocusTracker.onDidFocus(() => {
      this._replaceInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._replaceFocusTracker.onDidBlur(() => {
      this._replaceInputFocused.set(false);
    }));
    this._codeEditor.addOverlayWidget(this);
    if (this._codeEditor.getOption(
      40
      /* EditorOption.find */
    ).addExtraSpaceOnTop) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    this._register(this._codeEditor.onDidChangeModel(() => {
      if (!this._isVisible) {
        return;
      }
      this._viewZoneId = void 0;
    }));
    this._register(this._codeEditor.onDidScrollChange((e) => {
      if (e.scrollTopChanged) {
        this._layoutViewZone();
        return;
      }
      setTimeout(() => {
        this._layoutViewZone();
      }, 0);
    }));
  }
  // ----- IOverlayWidget API
  getId() {
    return _FindWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    if (this._isVisible) {
      return {
        preference: 0
        /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
      };
    }
    return null;
  }
  // ----- React to state changes
  _onStateChanged(e) {
    if (e.searchString) {
      try {
        this._ignoreChangeEvent = true;
        this._findInput.setValue(this._state.searchString);
      } finally {
        this._ignoreChangeEvent = false;
      }
      this._updateButtons();
    }
    if (e.replaceString) {
      this._replaceInput.inputBox.value = this._state.replaceString;
    }
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._reveal();
      } else {
        this._hide(true);
      }
    }
    if (e.isReplaceRevealed) {
      if (this._state.isReplaceRevealed) {
        if (!this._codeEditor.getOption(
          89
          /* EditorOption.readOnly */
        ) && !this._isReplaceVisible) {
          this._isReplaceVisible = true;
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._updateButtons();
          this._replaceInput.inputBox.layout();
        }
      } else {
        if (this._isReplaceVisible) {
          this._isReplaceVisible = false;
          this._updateButtons();
        }
      }
    }
    if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }
    if (e.isRegex) {
      this._findInput.setRegex(this._state.isRegex);
    }
    if (e.wholeWord) {
      this._findInput.setWholeWords(this._state.wholeWord);
    }
    if (e.matchCase) {
      this._findInput.setCaseSensitive(this._state.matchCase);
    }
    if (e.preserveCase) {
      this._replaceInput.setPreserveCase(this._state.preserveCase);
    }
    if (e.searchScope) {
      if (this._state.searchScope) {
        this._toggleSelectionFind.checked = true;
      } else {
        this._toggleSelectionFind.checked = false;
      }
      this._updateToggleSelectionFindButton();
    }
    if (e.searchString || e.matchesCount || e.matchesPosition) {
      const showRedOutline = this._state.searchString.length > 0 && this._state.matchesCount === 0;
      this._domNode.classList.toggle("no-results", showRedOutline);
      this._updateMatchesCount();
      this._updateButtons();
    }
    if (e.searchString || e.currentMatch) {
      this._layoutViewZone();
    }
    if (e.updateHistory) {
      this._delayedUpdateHistory();
    }
    if (e.loop) {
      this._updateButtons();
    }
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, onUnexpectedError);
  }
  _updateHistory() {
    if (this._state.searchString) {
      this._findInput.inputBox.addToHistory();
    }
    if (this._state.replaceString) {
      this._replaceInput.inputBox.addToHistory();
    }
  }
  _updateMatchesCount() {
    this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + "px";
    if (this._state.matchesCount >= MATCHES_LIMIT) {
      this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
    } else {
      this._matchesCount.title = "";
    }
    if (this._matchesCount.firstChild) {
      this._matchesCount.removeChild(this._matchesCount.firstChild);
    }
    let label;
    if (this._state.matchesCount > 0) {
      let matchesCount = String(this._state.matchesCount);
      if (this._state.matchesCount >= MATCHES_LIMIT) {
        matchesCount += "+";
      }
      let matchesPosition = String(this._state.matchesPosition);
      if (matchesPosition === "0") {
        matchesPosition = "?";
      }
      label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
    } else {
      label = NLS_NO_RESULTS;
    }
    this._matchesCount.appendChild(document.createTextNode(label));
    alert(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));
    MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
  }
  // ----- actions
  _getAriaLabel(label, currentMatch, searchString) {
    if (label === NLS_NO_RESULTS) {
      return searchString === "" ? localize("ariaSearchNoResultEmpty", "{0} found", label) : localize("ariaSearchNoResult", "{0} found for '{1}'", label, searchString);
    }
    if (currentMatch) {
      const ariaLabel = localize("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ":" + currentMatch.startColumn);
      const model = this._codeEditor.getModel();
      if (model && currentMatch.startLineNumber <= model.getLineCount() && currentMatch.startLineNumber >= 1) {
        const lineContent = model.getLineContent(currentMatch.startLineNumber);
        return `${lineContent}, ${ariaLabel}`;
      }
      return ariaLabel;
    }
    return localize("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", label, searchString);
  }
  /**
   * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
   * If 'selection find' is OFF we enable the button only if there is a selection.
   */
  _updateToggleSelectionFindButton() {
    const selection = this._codeEditor.getSelection();
    const isSelection = selection ? selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn : false;
    const isChecked = this._toggleSelectionFind.checked;
    if (this._isVisible && (isChecked || isSelection)) {
      this._toggleSelectionFind.enable();
    } else {
      this._toggleSelectionFind.disable();
    }
  }
  _updateButtons() {
    this._findInput.setEnabled(this._isVisible);
    this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);
    this._updateToggleSelectionFindButton();
    this._closeBtn.setEnabled(this._isVisible);
    const findInputIsNonEmpty = this._state.searchString.length > 0;
    const matchesCount = this._state.matchesCount ? true : false;
    this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());
    this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());
    this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible);
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    const canReplace = !this._codeEditor.getOption(
      89
      /* EditorOption.readOnly */
    );
    this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
  }
  _reveal() {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (!this._isVisible) {
      this._isVisible = true;
      const selection = this._codeEditor.getSelection();
      switch (this._codeEditor.getOption(
        40
        /* EditorOption.find */
      ).autoFindInSelection) {
        case "always":
          this._toggleSelectionFind.checked = true;
          break;
        case "never":
          this._toggleSelectionFind.checked = false;
          break;
        case "multiline": {
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          this._toggleSelectionFind.checked = isSelectionMultipleLine;
          break;
        }
        default:
          break;
      }
      this._tryUpdateWidgetWidth();
      this._updateButtons();
      this._revealTimeouts.push(setTimeout(() => {
        this._domNode.classList.add("visible");
        this._domNode.setAttribute("aria-hidden", "false");
      }, 0));
      this._revealTimeouts.push(setTimeout(() => {
        this._findInput.validate();
      }, 200));
      this._codeEditor.layoutOverlayWidget(this);
      let adjustEditorScrollTop = true;
      if (this._codeEditor.getOption(
        40
        /* EditorOption.find */
      ).seedSearchStringFromSelection && selection) {
        const domNode = this._codeEditor.getDomNode();
        if (domNode) {
          const editorCoords = getDomNodePagePosition(domNode);
          const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());
          const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);
          const startTop = startCoords ? startCoords.top : 0;
          if (this._viewZone && startTop < this._viewZone.heightInPx) {
            if (selection.endLineNumber > selection.startLineNumber) {
              adjustEditorScrollTop = false;
            }
            const leftOfFindWidget = getTopLeftOffset(this._domNode).left;
            if (startLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
            const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());
            const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);
            if (endLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
          }
        }
      }
      this._showViewZone(adjustEditorScrollTop);
    }
  }
  _hide(focusTheEditor) {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (this._isVisible) {
      this._isVisible = false;
      this._updateButtons();
      this._domNode.classList.remove("visible");
      this._domNode.setAttribute("aria-hidden", "true");
      this._findInput.clearMessage();
      if (focusTheEditor) {
        this._codeEditor.focus();
      }
      this._codeEditor.layoutOverlayWidget(this);
      this._removeViewZone();
    }
  }
  _layoutViewZone(targetScrollTop) {
    const addExtraSpaceOnTop = this._codeEditor.getOption(
      40
      /* EditorOption.find */
    ).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      this._removeViewZone();
      return;
    }
    if (!this._isVisible) {
      return;
    }
    const viewZone = this._viewZone;
    if (this._viewZoneId !== void 0 || !viewZone) {
      return;
    }
    this._codeEditor.changeViewZones((accessor) => {
      viewZone.heightInPx = this._getHeight();
      this._viewZoneId = accessor.addZone(viewZone);
      this._codeEditor.setScrollTop(targetScrollTop || this._codeEditor.getScrollTop() + viewZone.heightInPx);
    });
  }
  _showViewZone(adjustScroll = true) {
    if (!this._isVisible) {
      return;
    }
    const addExtraSpaceOnTop = this._codeEditor.getOption(
      40
      /* EditorOption.find */
    ).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      return;
    }
    if (this._viewZone === void 0) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    const viewZone = this._viewZone;
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        const newHeight = this._getHeight();
        if (newHeight === viewZone.heightInPx) {
          return;
        }
        const scrollAdjustment = newHeight - viewZone.heightInPx;
        viewZone.heightInPx = newHeight;
        accessor.layoutZone(this._viewZoneId);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
        return;
      } else {
        let scrollAdjustment = this._getHeight();
        scrollAdjustment -= this._codeEditor.getOption(
          82
          /* EditorOption.padding */
        ).top;
        if (scrollAdjustment <= 0) {
          return;
        }
        viewZone.heightInPx = scrollAdjustment;
        this._viewZoneId = accessor.addZone(viewZone);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
      }
    });
  }
  _removeViewZone() {
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        accessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
        if (this._viewZone) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);
          this._viewZone = void 0;
        }
      }
    });
  }
  _tryUpdateWidgetWidth() {
    if (!this._isVisible) {
      return;
    }
    if (!isInDOM(this._domNode)) {
      return;
    }
    const layoutInfo = this._codeEditor.getLayoutInfo();
    const editorContentWidth = layoutInfo.contentWidth;
    if (editorContentWidth <= 0) {
      this._domNode.classList.add("hiddenEditor");
      return;
    } else if (this._domNode.classList.contains("hiddenEditor")) {
      this._domNode.classList.remove("hiddenEditor");
    }
    const editorWidth = layoutInfo.width;
    const minimapWidth = layoutInfo.minimap.minimapWidth;
    let collapsedFindWidget = false;
    let reducedFindWidget = false;
    let narrowFindWidget = false;
    if (this._resized) {
      const widgetWidth = getTotalWidth(this._domNode);
      if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {
        this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
        return;
      }
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {
      reducedFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {
      narrowFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {
      collapsedFindWidget = true;
    }
    this._domNode.classList.toggle("collapsed-find-widget", collapsedFindWidget);
    this._domNode.classList.toggle("narrow-find-widget", narrowFindWidget);
    this._domNode.classList.toggle("reduced-find-widget", reducedFindWidget);
    if (!narrowFindWidget && !collapsedFindWidget) {
      this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
    }
    this._findInput.layout({ collapsedFindWidget, narrowFindWidget, reducedFindWidget });
    if (this._resized) {
      const findInputWidth = this._findInput.inputBox.element.clientWidth;
      if (findInputWidth > 0) {
        this._replaceInput.width = findInputWidth;
      }
    } else if (this._isReplaceVisible) {
      this._replaceInput.width = getTotalWidth(this._findInput.domNode);
    }
  }
  _getHeight() {
    let totalheight = 0;
    totalheight += 4;
    totalheight += this._findInput.inputBox.height + 2;
    if (this._isReplaceVisible) {
      totalheight += 4;
      totalheight += this._replaceInput.inputBox.height + 2;
    }
    totalheight += 4;
    return totalheight;
  }
  _tryUpdateHeight() {
    const totalHeight = this._getHeight();
    if (this._cachedHeight !== null && this._cachedHeight === totalHeight) {
      return false;
    }
    this._cachedHeight = totalHeight;
    this._domNode.style.height = `${totalHeight}px`;
    return true;
  }
  // ----- Public
  focusFindInput() {
    this._findInput.select();
    this._findInput.focus();
  }
  focusReplaceInput() {
    this._replaceInput.select();
    this._replaceInput.focus();
  }
  highlightFindOptions() {
    this._findInput.highlightFindOptions();
  }
  _updateSearchScope() {
    if (!this._codeEditor.hasModel()) {
      return;
    }
    if (this._toggleSelectionFind.checked) {
      const selections = this._codeEditor.getSelections();
      selections.map((selection) => {
        if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
          selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
        }
        const currentMatch = this._state.currentMatch;
        if (selection.startLineNumber !== selection.endLineNumber) {
          if (!Range.equalsRange(selection, currentMatch)) {
            return selection;
          }
        }
        return null;
      }).filter((element) => !!element);
      if (selections.length) {
        this._state.change({ searchScope: selections }, true);
      }
    }
  }
  _onFindInputMouseDown(e) {
    if (e.middleButton) {
      e.stopPropagation();
    }
  }
  _onFindInputKeyDown(e) {
    if (e.equals(
      ctrlKeyMod | 3
      /* KeyCode.Enter */
    )) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        this._findInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      if (this._isReplaceVisible) {
        this._replaceInput.focus();
      } else {
        this._findInput.focusOnCaseSensitive();
      }
      e.preventDefault();
      return;
    }
    if (e.equals(
      2048 | 18
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    )) {
      return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    )) {
      return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
  }
  _onReplaceInputKeyDown(e) {
    if (e.equals(
      ctrlKeyMod | 3
      /* KeyCode.Enter */
    )) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        if (isWindows && isNative && !this._ctrlEnterReplaceAllWarningPrompted) {
          this._notificationService.info(localize("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior."));
          this._ctrlEnterReplaceAllWarningPrompted = true;
          this._storageService.store(
            ctrlEnterReplaceAllWarningPromptedKey,
            true,
            0,
            0
            /* StorageTarget.USER */
          );
        }
        this._replaceInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      this._findInput.focusOnCaseSensitive();
      e.preventDefault();
      return;
    }
    if (e.equals(
      1024 | 2
      /* KeyCode.Tab */
    )) {
      this._findInput.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(
      2048 | 18
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    )) {
      return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    )) {
      return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
  }
  // ----- sash
  getVerticalSashLeft(_sash) {
    return 0;
  }
  // ----- initialization
  _keybindingLabelFor(actionId) {
    const kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  _buildDomNode() {
    const flexibleHeight = true;
    const flexibleWidth = true;
    this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {
      width: FIND_INPUT_AREA_WIDTH,
      label: NLS_FIND_INPUT_LABEL,
      placeholder: NLS_FIND_INPUT_PLACEHOLDER,
      appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
      appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
      appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
      validation: (value) => {
        if (value.length === 0 || !this._findInput.getRegex()) {
          return null;
        }
        try {
          new RegExp(value, "gu");
          return null;
        } catch (e) {
          return { content: e.message };
        }
      },
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showCommonFindToggles: true,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),
      inputBoxStyles: defaultInputBoxStyles,
      toggleStyles: defaultToggleStyles
    }, this._contextKeyService));
    this._findInput.setRegex(!!this._state.isRegex);
    this._findInput.setCaseSensitive(!!this._state.matchCase);
    this._findInput.setWholeWords(!!this._state.wholeWord);
    this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));
    this._register(this._findInput.inputBox.onDidChange(() => {
      if (this._ignoreChangeEvent) {
        return;
      }
      this._state.change({ searchString: this._findInput.getValue() }, true);
    }));
    this._register(this._findInput.onDidOptionChange(() => {
      this._state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, true);
    }));
    this._register(this._findInput.onCaseSensitiveKeyDown((e) => {
      if (e.equals(
        1024 | 2
        /* KeyCode.Tab */
      )) {
        if (this._isReplaceVisible) {
          this._replaceInput.focus();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.onRegexKeyDown((e) => {
      if (e.equals(
        2
        /* KeyCode.Tab */
      )) {
        if (this._isReplaceVisible) {
          this._replaceInput.focusOnPreserve();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.inputBox.onDidHeightChange((e) => {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    if (isLinux) {
      this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));
    }
    this._matchesCount = document.createElement("div");
    this._matchesCount.className = "matchesCount";
    this._updateMatchesCount();
    this._prevBtn = this._register(new SimpleButton({
      label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),
      icon: findPreviousMatchIcon,
      onTrigger: () => {
        assertIsDefined(this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction)).run().then(void 0, onUnexpectedError);
      }
    }));
    this._nextBtn = this._register(new SimpleButton({
      label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),
      icon: findNextMatchIcon,
      onTrigger: () => {
        assertIsDefined(this._codeEditor.getAction(FIND_IDS.NextMatchFindAction)).run().then(void 0, onUnexpectedError);
      }
    }));
    const findPart = document.createElement("div");
    findPart.className = "find-part";
    findPart.appendChild(this._findInput.domNode);
    const actionsContainer = document.createElement("div");
    actionsContainer.className = "find-actions";
    findPart.appendChild(actionsContainer);
    actionsContainer.appendChild(this._matchesCount);
    actionsContainer.appendChild(this._prevBtn.domNode);
    actionsContainer.appendChild(this._nextBtn.domNode);
    this._toggleSelectionFind = this._register(new Toggle({
      icon: findSelectionIcon,
      title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),
      isChecked: false,
      inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground),
      inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
      inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground)
    }));
    this._register(this._toggleSelectionFind.onChange(() => {
      if (this._toggleSelectionFind.checked) {
        if (this._codeEditor.hasModel()) {
          const selections = this._codeEditor.getSelections();
          selections.map((selection) => {
            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
              selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
            }
            if (!selection.isEmpty()) {
              return selection;
            }
            return null;
          }).filter((element) => !!element);
          if (selections.length) {
            this._state.change({ searchScope: selections }, true);
          }
        }
      } else {
        this._state.change({ searchScope: null }, true);
      }
    }));
    actionsContainer.appendChild(this._toggleSelectionFind.domNode);
    this._closeBtn = this._register(new SimpleButton({
      label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),
      icon: widgetClose,
      onTrigger: () => {
        this._state.change({ isRevealed: false, searchScope: null }, false);
      },
      onKeyDown: (e) => {
        if (e.equals(
          2
          /* KeyCode.Tab */
        )) {
          if (this._isReplaceVisible) {
            if (this._replaceBtn.isEnabled()) {
              this._replaceBtn.focus();
            } else {
              this._codeEditor.focus();
            }
            e.preventDefault();
          }
        }
      }
    }));
    this._replaceInput = this._register(new ContextScopedReplaceInput(null, void 0, {
      label: NLS_REPLACE_INPUT_LABEL,
      placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,
      appendPreserveCaseLabel: this._keybindingLabelFor(FIND_IDS.TogglePreserveCaseCommand),
      history: [],
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),
      inputBoxStyles: defaultInputBoxStyles,
      toggleStyles: defaultToggleStyles
    }, this._contextKeyService, true));
    this._replaceInput.setPreserveCase(!!this._state.preserveCase);
    this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));
    this._register(this._replaceInput.inputBox.onDidChange(() => {
      this._state.change({ replaceString: this._replaceInput.inputBox.value }, false);
    }));
    this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {
      if (this._isReplaceVisible && this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    this._register(this._replaceInput.onDidOptionChange(() => {
      this._state.change({
        preserveCase: this._replaceInput.getPreserveCase()
      }, true);
    }));
    this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {
      if (e.equals(
        2
        /* KeyCode.Tab */
      )) {
        if (this._prevBtn.isEnabled()) {
          this._prevBtn.focus();
        } else if (this._nextBtn.isEnabled()) {
          this._nextBtn.focus();
        } else if (this._toggleSelectionFind.enabled) {
          this._toggleSelectionFind.focus();
        } else if (this._closeBtn.isEnabled()) {
          this._closeBtn.focus();
        }
        e.preventDefault();
      }
    }));
    this._replaceBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),
      icon: findReplaceIcon,
      onTrigger: () => {
        this._controller.replace();
      },
      onKeyDown: (e) => {
        if (e.equals(
          1024 | 2
          /* KeyCode.Tab */
        )) {
          this._closeBtn.focus();
          e.preventDefault();
        }
      }
    }));
    this._replaceAllBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),
      icon: findReplaceAllIcon,
      onTrigger: () => {
        this._controller.replaceAll();
      }
    }));
    const replacePart = document.createElement("div");
    replacePart.className = "replace-part";
    replacePart.appendChild(this._replaceInput.domNode);
    const replaceActionsContainer = document.createElement("div");
    replaceActionsContainer.className = "replace-actions";
    replacePart.appendChild(replaceActionsContainer);
    replaceActionsContainer.appendChild(this._replaceBtn.domNode);
    replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);
    this._toggleReplaceBtn = this._register(new SimpleButton({
      label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
      className: "codicon toggle left",
      onTrigger: () => {
        this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);
        if (this._isReplaceVisible) {
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._replaceInput.inputBox.layout();
        }
        this._showViewZone();
      }
    }));
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    this._domNode = document.createElement("div");
    this._domNode.className = "editor-widget find-widget";
    this._domNode.setAttribute("aria-hidden", "true");
    this._domNode.ariaLabel = NLS_FIND_DIALOG_LABEL;
    this._domNode.role = "dialog";
    this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;
    this._domNode.appendChild(this._toggleReplaceBtn.domNode);
    this._domNode.appendChild(findPart);
    this._domNode.appendChild(this._closeBtn.domNode);
    this._domNode.appendChild(replacePart);
    this._resizeSash = new Sash(this._domNode, this, { orientation: 0, size: 2 });
    this._resized = false;
    let originalWidth = FIND_WIDGET_INITIAL_WIDTH;
    this._register(this._resizeSash.onDidStart(() => {
      originalWidth = getTotalWidth(this._domNode);
    }));
    this._register(this._resizeSash.onDidChange((evt) => {
      this._resized = true;
      const width = originalWidth + evt.startX - evt.currentX;
      if (width < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      const maxWidth = parseFloat(getComputedStyle(this._domNode).maxWidth) || 0;
      if (width > maxWidth) {
        return;
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
      this._tryUpdateHeight();
    }));
    this._register(this._resizeSash.onDidReset(() => {
      const currentWidth = getTotalWidth(this._domNode);
      if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      let width = FIND_WIDGET_INITIAL_WIDTH;
      if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {
        const layoutInfo = this._codeEditor.getLayoutInfo();
        width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;
        this._resized = true;
      } else {
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
    }));
  }
  updateAccessibilitySupport() {
    const value = this._codeEditor.getOption(
      2
      /* EditorOption.accessibilitySupport */
    );
    this._findInput.setFocusInputOnOptionClick(
      value !== 2
      /* AccessibilitySupport.Enabled */
    );
  }
  getViewState() {
    let widgetViewZoneVisible = false;
    if (this._viewZone && this._viewZoneId) {
      widgetViewZoneVisible = this._viewZone.heightInPx > this._codeEditor.getScrollTop();
    }
    return {
      widgetViewZoneVisible,
      scrollTop: this._codeEditor.getScrollTop()
    };
  }
  setViewState(state) {
    if (!state) {
      return;
    }
    if (state.widgetViewZoneVisible) {
      this._layoutViewZone(state.scrollTop);
    }
  }
};
FindWidget.ID = "editor.contrib.findWidget";
var SimpleButton = class extends Widget {
  constructor(opts) {
    super();
    this._opts = opts;
    let className = "button";
    if (this._opts.className) {
      className = className + " " + this._opts.className;
    }
    if (this._opts.icon) {
      className = className + " " + ThemeIcon.asClassName(this._opts.icon);
    }
    this._domNode = document.createElement("div");
    this._domNode.title = this._opts.label;
    this._domNode.tabIndex = 0;
    this._domNode.className = className;
    this._domNode.setAttribute("role", "button");
    this._domNode.setAttribute("aria-label", this._opts.label);
    this.onclick(this._domNode, (e) => {
      this._opts.onTrigger();
      e.preventDefault();
    });
    this.onkeydown(this._domNode, (e) => {
      var _a, _b;
      if (e.equals(
        10
        /* KeyCode.Space */
      ) || e.equals(
        3
        /* KeyCode.Enter */
      )) {
        this._opts.onTrigger();
        e.preventDefault();
        return;
      }
      (_b = (_a = this._opts).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    });
  }
  get domNode() {
    return this._domNode;
  }
  isEnabled() {
    return this._domNode.tabIndex >= 0;
  }
  focus() {
    this._domNode.focus();
  }
  setEnabled(enabled) {
    this._domNode.classList.toggle("disabled", !enabled);
    this._domNode.setAttribute("aria-disabled", String(!enabled));
    this._domNode.tabIndex = enabled ? 0 : -1;
  }
  setExpanded(expanded) {
    this._domNode.setAttribute("aria-expanded", String(!!expanded));
    if (expanded) {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findCollapsedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findExpandedIcon));
    } else {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findExpandedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findCollapsedIcon));
    }
  }
};
registerThemingParticipant((theme, collector) => {
  const addBackgroundColorRule = (selector, color) => {
    if (color) {
      collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);
    }
  };
  addBackgroundColorRule(".findMatch", theme.getColor(editorFindMatchHighlight));
  addBackgroundColorRule(".currentFindMatch", theme.getColor(editorFindMatch));
  addBackgroundColorRule(".findScope", theme.getColor(editorFindRangeHighlight));
  const widgetBackground = theme.getColor(editorWidgetBackground);
  addBackgroundColorRule(".find-widget", widgetBackground);
  const widgetShadowColor = theme.getColor(widgetShadow);
  if (widgetShadowColor) {
    collector.addRule(`.monaco-editor .find-widget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);
  }
  const widgetBorderColor = theme.getColor(widgetBorder);
  if (widgetBorderColor) {
    collector.addRule(`.monaco-editor .find-widget { border-left: 1px solid ${widgetBorderColor}; border-right: 1px solid ${widgetBorderColor}; border-bottom: 1px solid ${widgetBorderColor}; }`);
  }
  const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
  if (findMatchHighlightBorder) {
    collector.addRule(`.monaco-editor .findMatch { border: 1px ${isHighContrast(theme.type) ? "dotted" : "solid"} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
  }
  const findMatchBorder = theme.getColor(editorFindMatchBorder);
  if (findMatchBorder) {
    collector.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${findMatchBorder}; padding: 1px; box-sizing: border-box; }`);
  }
  const findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);
  if (findRangeHighlightBorder) {
    collector.addRule(`.monaco-editor .findScope { border: 1px ${isHighContrast(theme.type) ? "dashed" : "solid"} ${findRangeHighlightBorder}; }`);
  }
  const hcBorder = theme.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);
  }
  const foreground = theme.getColor(editorWidgetForeground);
  if (foreground) {
    collector.addRule(`.monaco-editor .find-widget { color: ${foreground}; }`);
  }
  const error = theme.getColor(errorForeground);
  if (error) {
    collector.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${error}; }`);
  }
  const resizeBorderBackground = theme.getColor(editorWidgetResizeBorder);
  if (resizeBorderBackground) {
    collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${resizeBorderBackground}; }`);
  } else {
    const border = theme.getColor(editorWidgetBorder);
    if (border) {
      collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${border}; }`);
    }
  }
  const toolbarHoverBackgroundColor = theme.getColor(toolbarHoverBackground);
  if (toolbarHoverBackgroundColor) {
    collector.addRule(`
		.monaco-editor .find-widget .button:not(.disabled):hover,
		.monaco-editor .find-widget .codicon-find-selection:hover {
			background-color: ${toolbarHoverBackgroundColor} !important;
		}
	`);
  }
  const focusOutline = theme.getColor(focusBorder);
  if (focusOutline) {
    collector.addRule(`.monaco-editor .find-widget .monaco-inputbox.synthetic-focus { outline-color: ${focusOutline}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findController.js
init_nls();
init_actions2();
init_contextkey();
init_themeService();
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CommonFindController_1;
var SEARCH_STRING_MAX_LENGTH = 524288;
function getSelectionSearchString(editor2, seedSearchStringFromSelection = "single", seedSearchStringFromNonEmptySelection = false) {
  if (!editor2.hasModel()) {
    return null;
  }
  const selection = editor2.getSelection();
  if (seedSearchStringFromSelection === "single" && selection.startLineNumber === selection.endLineNumber || seedSearchStringFromSelection === "multiple") {
    if (selection.isEmpty()) {
      const wordAtPosition = editor2.getConfiguredWordAtPosition(selection.getStartPosition());
      if (wordAtPosition && false === seedSearchStringFromNonEmptySelection) {
        return wordAtPosition.word;
      }
    } else {
      if (editor2.getModel().getValueLengthInRange(selection) < SEARCH_STRING_MAX_LENGTH) {
        return editor2.getModel().getValueInRange(selection);
      }
    }
  }
  return null;
}
var CommonFindController = CommonFindController_1 = class CommonFindController2 extends Disposable {
  get editor() {
    return this._editor;
  }
  static get(editor2) {
    return editor2.getContribution(CommonFindController_1.ID);
  }
  constructor(editor2, contextKeyService, storageService, clipboardService) {
    super();
    this._editor = editor2;
    this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._clipboardService = clipboardService;
    this._updateHistoryDelayer = new Delayer(500);
    this._state = this._register(new FindReplaceState());
    this.loadQueryState();
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._model = null;
    this._register(this._editor.onDidChangeModel(() => {
      const shouldRestartFind = this._editor.getModel() && this._state.isRevealed;
      this.disposeModel();
      this._state.change({
        searchScope: null,
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, false),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, false),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, false),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, false)
      }, false);
      if (shouldRestartFind) {
        this._start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "none",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: false,
          updateSearchScope: false,
          loop: this._editor.getOption(
            40
            /* EditorOption.find */
          ).loop
        });
      }
    }));
  }
  dispose() {
    this.disposeModel();
    super.dispose();
  }
  disposeModel() {
    if (this._model) {
      this._model.dispose();
      this._model = null;
    }
  }
  _onStateChanged(e) {
    this.saveQueryState(e);
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._findWidgetVisible.set(true);
      } else {
        this._findWidgetVisible.reset();
        this.disposeModel();
      }
    }
    if (e.searchString) {
      this.setGlobalBufferTerm(this._state.searchString);
    }
  }
  saveQueryState(e) {
    if (e.isRegex) {
      this._storageService.store(
        "editor.isRegex",
        this._state.actualIsRegex,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    if (e.wholeWord) {
      this._storageService.store(
        "editor.wholeWord",
        this._state.actualWholeWord,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    if (e.matchCase) {
      this._storageService.store(
        "editor.matchCase",
        this._state.actualMatchCase,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    if (e.preserveCase) {
      this._storageService.store(
        "editor.preserveCase",
        this._state.actualPreserveCase,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
  }
  loadQueryState() {
    this._state.change({
      matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
      wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
      isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
      preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
    }, false);
  }
  isFindInputFocused() {
    return !!CONTEXT_FIND_INPUT_FOCUSED.getValue(this._contextKeyService);
  }
  getState() {
    return this._state;
  }
  closeFindWidget() {
    this._state.change({
      isRevealed: false,
      searchScope: null
    }, false);
    this._editor.focus();
  }
  toggleCaseSensitive() {
    this._state.change({ matchCase: !this._state.matchCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleWholeWords() {
    this._state.change({ wholeWord: !this._state.wholeWord }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleRegex() {
    this._state.change({ isRegex: !this._state.isRegex }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  togglePreserveCase() {
    this._state.change({ preserveCase: !this._state.preserveCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleSearchScope() {
    if (this._state.searchScope) {
      this._state.change({ searchScope: null }, true);
    } else {
      if (this._editor.hasModel()) {
        const selections = this._editor.getSelections();
        selections.map((selection) => {
          if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
            selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
          }
          if (!selection.isEmpty()) {
            return selection;
          }
          return null;
        }).filter((element) => !!element);
        if (selections.length) {
          this._state.change({ searchScope: selections }, true);
        }
      }
    }
  }
  setSearchString(searchString) {
    if (this._state.isRegex) {
      searchString = escapeRegExpCharacters(searchString);
    }
    this._state.change({ searchString }, false);
  }
  highlightFindOptions(ignoreWhenVisible = false) {
  }
  _start(opts, newState) {
    return __awaiter21(this, void 0, void 0, function* () {
      this.disposeModel();
      if (!this._editor.hasModel()) {
        return;
      }
      const stateChanges = Object.assign(Object.assign({}, newState), { isRevealed: true });
      if (opts.seedSearchStringFromSelection === "single") {
        const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);
        if (selectionSearchString) {
          if (this._state.isRegex) {
            stateChanges.searchString = escapeRegExpCharacters(selectionSearchString);
          } else {
            stateChanges.searchString = selectionSearchString;
          }
        }
      } else if (opts.seedSearchStringFromSelection === "multiple" && !opts.updateSearchScope) {
        const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);
        if (selectionSearchString) {
          stateChanges.searchString = selectionSearchString;
        }
      }
      if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
        const selectionSearchString = yield this.getGlobalBufferTerm();
        if (!this._editor.hasModel()) {
          return;
        }
        if (selectionSearchString) {
          stateChanges.searchString = selectionSearchString;
        }
      }
      if (opts.forceRevealReplace || stateChanges.isReplaceRevealed) {
        stateChanges.isReplaceRevealed = true;
      } else if (!this._findWidgetVisible.get()) {
        stateChanges.isReplaceRevealed = false;
      }
      if (opts.updateSearchScope) {
        const currentSelections = this._editor.getSelections();
        if (currentSelections.some((selection) => !selection.isEmpty())) {
          stateChanges.searchScope = currentSelections;
        }
      }
      stateChanges.loop = opts.loop;
      this._state.change(stateChanges, false);
      if (!this._model) {
        this._model = new FindModelBoundToEditorModel(this._editor, this._state);
      }
    });
  }
  start(opts, newState) {
    return this._start(opts, newState);
  }
  moveToNextMatch() {
    if (this._model) {
      this._model.moveToNextMatch();
      return true;
    }
    return false;
  }
  moveToPrevMatch() {
    if (this._model) {
      this._model.moveToPrevMatch();
      return true;
    }
    return false;
  }
  goToMatch(index) {
    if (this._model) {
      this._model.moveToMatch(index);
      return true;
    }
    return false;
  }
  replace() {
    if (this._model) {
      this._model.replace();
      return true;
    }
    return false;
  }
  replaceAll() {
    if (this._model) {
      this._model.replaceAll();
      return true;
    }
    return false;
  }
  selectAllMatches() {
    if (this._model) {
      this._model.selectAllMatches();
      this._editor.focus();
      return true;
    }
    return false;
  }
  getGlobalBufferTerm() {
    return __awaiter21(this, void 0, void 0, function* () {
      if (this._editor.getOption(
        40
        /* EditorOption.find */
      ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
        return this._clipboardService.readFindText();
      }
      return "";
    });
  }
  setGlobalBufferTerm(text) {
    if (this._editor.getOption(
      40
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
      this._clipboardService.writeFindText(text);
    }
  }
};
CommonFindController.ID = "editor.contrib.findController";
CommonFindController = CommonFindController_1 = __decorate21([
  __param21(1, IContextKeyService),
  __param21(2, IStorageService),
  __param21(3, IClipboardService)
], CommonFindController);
var FindController = class FindController2 extends CommonFindController {
  constructor(editor2, _contextViewService, _contextKeyService, _keybindingService, _themeService, _notificationService, _storageService, clipboardService) {
    super(editor2, _contextKeyService, _storageService, clipboardService);
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._themeService = _themeService;
    this._notificationService = _notificationService;
    this._widget = null;
    this._findOptionsWidget = null;
  }
  _start(opts, newState) {
    const _super = Object.create(null, {
      _start: { get: () => super._start }
    });
    return __awaiter21(this, void 0, void 0, function* () {
      if (!this._widget) {
        this._createFindWidget();
      }
      const selection = this._editor.getSelection();
      let updateSearchScope = false;
      switch (this._editor.getOption(
        40
        /* EditorOption.find */
      ).autoFindInSelection) {
        case "always":
          updateSearchScope = true;
          break;
        case "never":
          updateSearchScope = false;
          break;
        case "multiline": {
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          updateSearchScope = isSelectionMultipleLine;
          break;
        }
        default:
          break;
      }
      opts.updateSearchScope = opts.updateSearchScope || updateSearchScope;
      yield _super._start.call(this, opts, newState);
      if (this._widget) {
        if (opts.shouldFocus === 2) {
          this._widget.focusReplaceInput();
        } else if (opts.shouldFocus === 1) {
          this._widget.focusFindInput();
        }
      }
    });
  }
  highlightFindOptions(ignoreWhenVisible = false) {
    if (!this._widget) {
      this._createFindWidget();
    }
    if (this._state.isRevealed && !ignoreWhenVisible) {
      this._widget.highlightFindOptions();
    } else {
      this._findOptionsWidget.highlightFindOptions();
    }
  }
  _createFindWidget() {
    this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService));
    this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService));
  }
  saveViewState() {
    var _a;
    return (_a = this._widget) === null || _a === void 0 ? void 0 : _a.getViewState();
  }
  restoreViewState(state) {
    var _a;
    (_a = this._widget) === null || _a === void 0 ? void 0 : _a.setViewState(state);
  }
};
FindController = __decorate21([
  __param21(1, IContextViewService),
  __param21(2, IContextKeyService),
  __param21(3, IKeybindingService),
  __param21(4, IThemeService),
  __param21(5, INotificationService),
  __param21(6, IStorageService),
  __param21(7, IClipboardService)
], FindController);
var StartFindAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindAction,
  label: localize("startFindAction", "Find"),
  alias: "Find",
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 36,
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize({ key: "miFind", comment: ["&& denotes a mnemonic"] }, "&&Find"),
    order: 1
  }
}));
StartFindAction.addImplementation(0, (accessor, editor2, args) => {
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  return controller.start({
    forceRevealReplace: false,
    seedSearchStringFromSelection: editor2.getOption(
      40
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never" ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(
      40
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(
      40
      /* EditorOption.find */
    ).globalFindClipboard,
    shouldFocus: 1,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(
      40
      /* EditorOption.find */
    ).loop
  });
});
var findArgDescription = {
  description: "Open a new In-Editor Find Widget.",
  args: [{
    name: "Open a new In-Editor Find Widget args",
    schema: {
      properties: {
        searchString: { type: "string" },
        replaceString: { type: "string" },
        regex: { type: "boolean" },
        regexOverride: {
          type: "number",
          description: localize("actions.find.isRegexOverride", 'Overrides "Use Regular Expression" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        wholeWord: { type: "boolean" },
        wholeWordOverride: {
          type: "number",
          description: localize("actions.find.wholeWordOverride", 'Overrides "Match Whole Word" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        matchCase: { type: "boolean" },
        matchCaseOverride: {
          type: "number",
          description: localize("actions.find.matchCaseOverride", 'Overrides "Math Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        preserveCase: { type: "boolean" },
        preserveCaseOverride: {
          type: "number",
          description: localize("actions.find.preserveCaseOverride", 'Overrides "Preserve Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        findInSelection: { type: "boolean" }
      }
    }
  }]
};
var StartFindWithArgsAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithArgs,
      label: localize("startFindWithArgsAction", "Find With Arguments"),
      alias: "Find With Arguments",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      description: findArgDescription
    });
  }
  run(accessor, editor2, args) {
    return __awaiter21(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (controller) {
        const newState = args ? {
          searchString: args.searchString,
          replaceString: args.replaceString,
          isReplaceRevealed: args.replaceString !== void 0,
          isRegex: args.isRegex,
          // isRegexOverride: args.regexOverride,
          wholeWord: args.matchWholeWord,
          // wholeWordOverride: args.wholeWordOverride,
          matchCase: args.isCaseSensitive,
          // matchCaseOverride: args.matchCaseOverride,
          preserveCase: args.preserveCase
          // preserveCaseOverride: args.preserveCaseOverride,
        } : {};
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(
            40
            /* EditorOption.find */
          ).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: editor2.getOption(
            40
            /* EditorOption.find */
          ).seedSearchStringFromSelection === "selection",
          seedSearchStringFromGlobalClipboard: true,
          shouldFocus: 1,
          shouldAnimate: true,
          updateSearchScope: (args === null || args === void 0 ? void 0 : args.findInSelection) || false,
          loop: editor2.getOption(
            40
            /* EditorOption.find */
          ).loop
        }, newState);
        controller.setGlobalBufferTerm(controller.getState().searchString);
      }
    });
  }
};
var StartFindWithSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithSelection,
      label: localize("startFindWithSelectionAction", "Find With Selection"),
      alias: "Find With Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        mac: {
          primary: 2048 | 35
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter21(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (controller) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "multiple",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(
            40
            /* EditorOption.find */
          ).loop
        });
        controller.setGlobalBufferTerm(controller.getState().searchString);
      }
    });
  }
};
var MatchFindAction = class extends EditorAction {
  run(accessor, editor2) {
    return __awaiter21(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (controller && !this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(
            40
            /* EditorOption.find */
          ).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: editor2.getOption(
            40
            /* EditorOption.find */
          ).seedSearchStringFromSelection === "selection",
          seedSearchStringFromGlobalClipboard: true,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(
            40
            /* EditorOption.find */
          ).loop
        });
        this._run(controller);
      }
    });
  }
};
var NextMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextMatchFindAction,
      label: localize("findNextMatchAction", "Find Next"),
      alias: "Find Next",
      precondition: void 0,
      kbOpts: [{
        kbExpr: EditorContextKeys.focus,
        primary: 61,
        mac: { primary: 2048 | 37, secondary: [
          61
          /* KeyCode.F3 */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    });
  }
  _run(controller) {
    const result = controller.moveToNextMatch();
    if (result) {
      controller.editor.pushUndoStop();
      return true;
    }
    return false;
  }
};
var PreviousMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousMatchFindAction,
      label: localize("findPreviousMatchAction", "Find Previous"),
      alias: "Find Previous",
      precondition: void 0,
      kbOpts: [
        {
          kbExpr: EditorContextKeys.focus,
          primary: 1024 | 61,
          mac: { primary: 2048 | 1024 | 37, secondary: [
            1024 | 61
            /* KeyCode.F3 */
          ] },
          weight: 100
          /* KeybindingWeight.EditorContrib */
        },
        {
          kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
          primary: 1024 | 3,
          weight: 100
          /* KeybindingWeight.EditorContrib */
        }
      ]
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
var MoveToMatchFindAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.GoToMatchFindAction,
      label: localize("findMatchAction.goToMatch", "Go to Match..."),
      alias: "Go to Match...",
      precondition: CONTEXT_FIND_WIDGET_VISIBLE
    });
    this._highlightDecorations = [];
  }
  run(accessor, editor2, args) {
    const controller = CommonFindController.get(editor2);
    if (!controller) {
      return;
    }
    const matchesCount = controller.getState().matchesCount;
    if (matchesCount < 1) {
      const notificationService = accessor.get(INotificationService);
      notificationService.notify({
        severity: Severity.Warning,
        message: localize("findMatchAction.noResults", "No matches. Try searching for something else.")
      });
      return;
    }
    const quickInputService = accessor.get(IQuickInputService);
    const inputBox = quickInputService.createInputBox();
    inputBox.placeholder = localize("findMatchAction.inputPlaceHolder", "Type a number to go to a specific match (between 1 and {0})", matchesCount);
    const toFindMatchIndex = (value) => {
      const index = parseInt(value);
      if (isNaN(index)) {
        return void 0;
      }
      const matchCount = controller.getState().matchesCount;
      if (index > 0 && index <= matchCount) {
        return index - 1;
      } else if (index < 0 && index >= -matchCount) {
        return matchCount + index;
      }
      return void 0;
    };
    const updatePickerAndEditor = (value) => {
      const index = toFindMatchIndex(value);
      if (typeof index === "number") {
        inputBox.validationMessage = void 0;
        controller.goToMatch(index);
        const currentMatch = controller.getState().currentMatch;
        if (currentMatch) {
          this.addDecorations(editor2, currentMatch);
        }
      } else {
        inputBox.validationMessage = localize("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", controller.getState().matchesCount);
        this.clearDecorations(editor2);
      }
    };
    inputBox.onDidChangeValue((value) => {
      updatePickerAndEditor(value);
    });
    inputBox.onDidAccept(() => {
      const index = toFindMatchIndex(inputBox.value);
      if (typeof index === "number") {
        controller.goToMatch(index);
        inputBox.hide();
      } else {
        inputBox.validationMessage = localize("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", controller.getState().matchesCount);
      }
    });
    inputBox.onDidHide(() => {
      this.clearDecorations(editor2);
      inputBox.dispose();
    });
    inputBox.show();
  }
  clearDecorations(editor2) {
    editor2.changeDecorations((changeAccessor) => {
      this._highlightDecorations = changeAccessor.deltaDecorations(this._highlightDecorations, []);
    });
  }
  addDecorations(editor2, range) {
    editor2.changeDecorations((changeAccessor) => {
      this._highlightDecorations = changeAccessor.deltaDecorations(this._highlightDecorations, [
        {
          range,
          options: {
            description: "find-match-quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: true
          }
        },
        {
          range,
          options: {
            description: "find-match-quick-access-range-highlight-overview",
            overviewRuler: {
              color: themeColorFromId(overviewRulerRangeHighlight),
              position: OverviewRulerLane.Full
            }
          }
        }
      ]);
    });
  }
};
var SelectionMatchFindAction = class extends EditorAction {
  run(accessor, editor2) {
    return __awaiter21(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (!controller) {
        return;
      }
      const selectionSearchString = getSelectionSearchString(editor2, "single", false);
      if (selectionSearchString) {
        controller.setSearchString(selectionSearchString);
      }
      if (!this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "none",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(
            40
            /* EditorOption.find */
          ).loop
        });
        this._run(controller);
      }
    });
  }
};
var NextSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextSelectionMatchFindAction,
      label: localize("nextSelectionMatchFindAction", "Find Next Selection"),
      alias: "Find Next Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 61,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(controller) {
    return controller.moveToNextMatch();
  }
};
var PreviousSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousSelectionMatchFindAction,
      label: localize("previousSelectionMatchFindAction", "Find Previous Selection"),
      alias: "Find Previous Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 61,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
var StartFindReplaceAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindReplaceAction,
  label: localize("startReplace", "Replace"),
  alias: "Replace",
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 38,
    mac: {
      primary: 2048 | 512 | 36
      /* KeyCode.KeyF */
    },
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize({ key: "miReplace", comment: ["&& denotes a mnemonic"] }, "&&Replace"),
    order: 2
  }
}));
StartFindReplaceAction.addImplementation(0, (accessor, editor2, args) => {
  if (!editor2.hasModel() || editor2.getOption(
    89
    /* EditorOption.readOnly */
  )) {
    return false;
  }
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  const currentSelection = editor2.getSelection();
  const findInputFocused = controller.isFindInputFocused();
  const seedSearchStringFromSelection = !currentSelection.isEmpty() && currentSelection.startLineNumber === currentSelection.endLineNumber && editor2.getOption(
    40
    /* EditorOption.find */
  ).seedSearchStringFromSelection !== "never" && !findInputFocused;
  const shouldFocus = findInputFocused || seedSearchStringFromSelection ? 2 : 1;
  return controller.start({
    forceRevealReplace: true,
    seedSearchStringFromSelection: seedSearchStringFromSelection ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(
      40
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(
      40
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never",
    shouldFocus,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(
      40
      /* EditorOption.find */
    ).loop
  });
});
registerEditorContribution(
  CommonFindController.ID,
  FindController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(StartFindWithArgsAction);
registerEditorAction(StartFindWithSelectionAction);
registerEditorAction(NextMatchFindAction);
registerEditorAction(PreviousMatchFindAction);
registerEditorAction(MoveToMatchFindAction);
registerEditorAction(NextSelectionMatchFindAction);
registerEditorAction(PreviousSelectionMatchFindAction);
var FindCommand = EditorCommand.bindToContribution(CommonFindController.get);
registerEditorCommand(new FindCommand({
  id: FIND_IDS.CloseFindWidgetCommand,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.closeFindWidget(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleCaseSensitiveCommand,
  precondition: void 0,
  handler: (x) => x.toggleCaseSensitive(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleCaseSensitiveKeybinding.primary,
    mac: ToggleCaseSensitiveKeybinding.mac,
    win: ToggleCaseSensitiveKeybinding.win,
    linux: ToggleCaseSensitiveKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleWholeWordCommand,
  precondition: void 0,
  handler: (x) => x.toggleWholeWords(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleWholeWordKeybinding.primary,
    mac: ToggleWholeWordKeybinding.mac,
    win: ToggleWholeWordKeybinding.win,
    linux: ToggleWholeWordKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleRegexCommand,
  precondition: void 0,
  handler: (x) => x.toggleRegex(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleRegexKeybinding.primary,
    mac: ToggleRegexKeybinding.mac,
    win: ToggleRegexKeybinding.win,
    linux: ToggleRegexKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleSearchScopeCommand,
  precondition: void 0,
  handler: (x) => x.toggleSearchScope(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleSearchScopeKeybinding.primary,
    mac: ToggleSearchScopeKeybinding.mac,
    win: ToggleSearchScopeKeybinding.win,
    linux: ToggleSearchScopeKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.TogglePreserveCaseCommand,
  precondition: void 0,
  handler: (x) => x.togglePreserveCase(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: TogglePreserveCaseKeybinding.primary,
    mac: TogglePreserveCaseKeybinding.mac,
    win: TogglePreserveCaseKeybinding.win,
    linux: TogglePreserveCaseKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 1024 | 22
    /* KeyCode.Digit1 */
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 512 | 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: void 0,
    mac: {
      primary: 2048 | 3
    }
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.SelectAllMatchesAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.selectAllMatches(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 512 | 3
    /* KeyCode.Enter */
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/fontZoom/browser/fontZoom.js
init_editorExtensions();
init_nls();
var EditorFontZoomIn = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomIn",
      label: localize("EditorFontZoomIn.label", "Editor Font Zoom In"),
      alias: "Editor Font Zoom In",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() + 1);
  }
};
var EditorFontZoomOut = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomOut",
      label: localize("EditorFontZoomOut.label", "Editor Font Zoom Out"),
      alias: "Editor Font Zoom Out",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() - 1);
  }
};
var EditorFontZoomReset = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomReset",
      label: localize("EditorFontZoomReset.label", "Editor Font Zoom Reset"),
      alias: "Editor Font Zoom Reset",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(0);
  }
};
registerEditorAction(EditorFontZoomIn);
registerEditorAction(EditorFontZoomOut);
registerEditorAction(EditorFontZoomReset);

// node_modules/monaco-editor/esm/vs/editor/editor.all.js
var import_formatActions = __toESM(require_formatActions());
var import_documentSymbols = __toESM(require_documentSymbols());

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletions.contribution.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/commands.js
init_editorExtensions();
init_editorContextKeys();
init_nls();
init_actions2();
init_configuration();
init_contextkey();
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ShowNextInlineSuggestionAction = class _ShowNextInlineSuggestionAction extends EditorAction {
  constructor() {
    super({
      id: _ShowNextInlineSuggestionAction.ID,
      label: localize("action.inlineSuggest.showNext", "Show Next Inline Suggestion"),
      alias: "Show Next Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 94
      }
    });
  }
  run(accessor, editor2) {
    var _a;
    return __awaiter22(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.next();
    });
  }
};
ShowNextInlineSuggestionAction.ID = showNextInlineSuggestionActionId;
var ShowPreviousInlineSuggestionAction = class _ShowPreviousInlineSuggestionAction extends EditorAction {
  constructor() {
    super({
      id: _ShowPreviousInlineSuggestionAction.ID,
      label: localize("action.inlineSuggest.showPrevious", "Show Previous Inline Suggestion"),
      alias: "Show Previous Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 92
      }
    });
  }
  run(accessor, editor2) {
    var _a;
    return __awaiter22(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.previous();
    });
  }
};
ShowPreviousInlineSuggestionAction.ID = showPreviousInlineSuggestionActionId;
var TriggerInlineSuggestionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.trigger",
      label: localize("action.inlineSuggest.trigger", "Trigger Inline Suggestion"),
      alias: "Trigger Inline Suggestion",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    var _a;
    return __awaiter22(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.triggerExplicitly();
    });
  }
};
var AcceptNextWordOfInlineCompletion = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextWord",
      label: localize("action.inlineSuggest.acceptNextWord", "Accept Next Word Of Inline Suggestion"),
      alias: "Accept Next Word Of Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100 + 1,
        primary: 2048 | 17,
        kbExpr: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible)
      },
      menuOpts: [{
        menuId: MenuId.InlineSuggestionToolbar,
        title: localize("acceptWord", "Accept Word"),
        group: "primary",
        order: 2
      }]
    });
  }
  run(accessor, editor2) {
    var _a;
    return __awaiter22(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      yield (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.acceptNextWord(controller.editor);
    });
  }
};
var AcceptNextLineOfInlineCompletion = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextLine",
      label: localize("action.inlineSuggest.acceptNextLine", "Accept Next Line Of Inline Suggestion"),
      alias: "Accept Next Line Of Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100 + 1
      },
      menuOpts: [{
        menuId: MenuId.InlineSuggestionToolbar,
        title: localize("acceptLine", "Accept Line"),
        group: "secondary",
        order: 2
      }]
    });
  }
  run(accessor, editor2) {
    var _a;
    return __awaiter22(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      yield (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.acceptNextLine(controller.editor);
    });
  }
};
var AcceptInlineCompletion = class extends EditorAction {
  constructor() {
    super({
      id: inlineSuggestCommitId,
      label: localize("action.inlineSuggest.accept", "Accept Inline Suggestion"),
      alias: "Accept Inline Suggestion",
      precondition: InlineCompletionContextKeys.inlineSuggestionVisible,
      menuOpts: [{
        menuId: MenuId.InlineSuggestionToolbar,
        title: localize("accept", "Accept"),
        group: "primary",
        order: 1
      }],
      kbOpts: {
        primary: 2,
        weight: 200,
        kbExpr: ContextKeyExpr.and(InlineCompletionContextKeys.inlineSuggestionVisible, EditorContextKeys.tabMovesFocus.toNegated(), InlineCompletionContextKeys.inlineSuggestionHasIndentationLessThanTabSize, Context.Visible.toNegated(), EditorContextKeys.hoverFocused.toNegated())
      }
    });
  }
  run(accessor, editor2) {
    var _a;
    return __awaiter22(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      if (controller) {
        (_a = controller.model.get()) === null || _a === void 0 ? void 0 : _a.accept(controller.editor);
        controller.editor.focus();
      }
    });
  }
};
var HideInlineCompletion = class _HideInlineCompletion extends EditorAction {
  constructor() {
    super({
      id: _HideInlineCompletion.ID,
      label: localize("action.inlineSuggest.hide", "Hide Inline Suggestion"),
      alias: "Hide Inline Suggestion",
      precondition: InlineCompletionContextKeys.inlineSuggestionVisible,
      kbOpts: {
        weight: 100,
        primary: 9
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter22(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      transaction((tx) => {
        var _a;
        (_a = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a === void 0 ? void 0 : _a.stop(tx);
      });
    });
  }
};
HideInlineCompletion.ID = "editor.action.inlineSuggest.hide";
var ToggleAlwaysShowInlineSuggestionToolbar = class _ToggleAlwaysShowInlineSuggestionToolbar extends Action2 {
  constructor() {
    super({
      id: _ToggleAlwaysShowInlineSuggestionToolbar.ID,
      title: localize("action.inlineSuggest.alwaysShowToolbar", "Always Show Toolbar"),
      f1: false,
      precondition: void 0,
      menu: [{
        id: MenuId.InlineSuggestionToolbar,
        group: "secondary",
        order: 10
      }],
      toggled: ContextKeyExpr.equals("config.editor.inlineSuggest.showToolbar", "always")
    });
  }
  run(accessor, editor2) {
    return __awaiter22(this, void 0, void 0, function* () {
      const configService = accessor.get(IConfigurationService);
      const currentValue = configService.getValue("editor.inlineSuggest.showToolbar");
      const newValue = currentValue === "always" ? "onHover" : "always";
      configService.updateValue("editor.inlineSuggest.showToolbar", newValue);
    });
  }
};
ToggleAlwaysShowInlineSuggestionToolbar.ID = "editor.action.inlineSuggest.toggleAlwaysShowToolbar";

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/hoverParticipant.js
init_dom();
init_htmlContent();
init_lifecycle();
init_range();
init_language();
init_nls();
init_instantiation();
init_opener();
init_telemetry();
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineCompletionsHover = class {
  constructor(owner, range, controller) {
    this.owner = owner;
    this.range = range;
    this.controller = controller;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var InlineCompletionsHoverParticipant = class InlineCompletionsHoverParticipant2 {
  constructor(_editor, _languageService, _openerService, accessibilityService, _instantiationService, _telemetryService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this.accessibilityService = accessibilityService;
    this._instantiationService = _instantiationService;
    this._telemetryService = _telemetryService;
    this.hoverOrdinal = 4;
  }
  suggestHoverAnchor(mouseEvent) {
    const controller = InlineCompletionsController.get(this._editor);
    if (!controller) {
      return null;
    }
    const target = mouseEvent.target;
    if (target.type === 8) {
      const viewZoneData = target.detail;
      if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) {
        return new HoverForeignElementAnchor(1e3, this, Range.fromPositions(this._editor.getModel().validatePosition(viewZoneData.positionBefore || viewZoneData.position)), mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    if (target.type === 7) {
      if (controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1e3, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    if (target.type === 6) {
      const mightBeForeignElement = target.detail.mightBeForeignElement;
      if (mightBeForeignElement && controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1e3, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    return null;
  }
  computeSync(anchor, lineDecorations) {
    if (this._editor.getOption(
      61
      /* EditorOption.inlineSuggest */
    ).showToolbar === "always") {
      return [];
    }
    const controller = InlineCompletionsController.get(this._editor);
    if (controller && controller.shouldShowHoverAt(anchor.range)) {
      return [new InlineCompletionsHover(this, anchor.range, controller)];
    }
    return [];
  }
  renderHoverParts(context, hoverParts) {
    const disposableStore = new DisposableStore();
    const part = hoverParts[0];
    this._telemetryService.publicLog2("inlineCompletionHover.shown");
    if (this.accessibilityService.isScreenReaderOptimized() && !this._editor.getOption(
      7
      /* EditorOption.screenReaderAnnounceInlineSuggestion */
    )) {
      this.renderScreenReaderText(context, part, disposableStore);
    }
    const model = part.controller.model.get();
    const w = this._instantiationService.createInstance(InlineSuggestionHintsContentWidget, this._editor, false, constObservable(null), model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.selectedInlineCompletion.map((v) => {
      var _a;
      return (_a = v === null || v === void 0 ? void 0 : v.inlineCompletion.source.inlineCompletions.commands) !== null && _a !== void 0 ? _a : [];
    }));
    context.fragment.appendChild(w.getDomNode());
    model.triggerExplicitly();
    disposableStore.add(w);
    return disposableStore;
  }
  renderScreenReaderText(context, part, disposableStore) {
    const $9 = $;
    const markdownHoverElement = $9("div.hover-row.markdown-hover");
    const hoverContentsElement = append(markdownHoverElement, $9("div.hover-contents", { ["aria-live"]: "assertive" }));
    const renderer = disposableStore.add(new MarkdownRenderer({ editor: this._editor }, this._languageService, this._openerService));
    const render = (code) => {
      disposableStore.add(renderer.onDidRenderAsync(() => {
        hoverContentsElement.className = "hover-contents code-hover-contents";
        context.onContentsChanged();
      }));
      const inlineSuggestionAvailable = localize("inlineSuggestionFollows", "Suggestion:");
      const renderedContents = disposableStore.add(renderer.render(new MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock("text", code)));
      hoverContentsElement.replaceChildren(renderedContents.element);
    };
    disposableStore.add(autorun((reader) => {
      var _a;
      const ghostText = (_a = part.controller.model.read(reader)) === null || _a === void 0 ? void 0 : _a.ghostText.read(reader);
      if (ghostText) {
        const lineText = this._editor.getModel().getLineContent(ghostText.lineNumber);
        render(ghostText.renderForScreenReader(lineText));
      } else {
        reset(hoverContentsElement);
      }
    }));
    context.fragment.appendChild(markdownHoverElement);
  }
};
InlineCompletionsHoverParticipant = __decorate22([
  __param22(1, ILanguageService),
  __param22(2, IOpenerService),
  __param22(3, IAccessibilityService),
  __param22(4, IInstantiationService),
  __param22(5, ITelemetryService)
], InlineCompletionsHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletions.contribution.js
init_actions2();
registerEditorContribution(
  InlineCompletionsController.ID,
  InlineCompletionsController,
  3
  /* EditorContributionInstantiation.Eventually */
);
registerEditorAction(TriggerInlineSuggestionAction);
registerEditorAction(ShowNextInlineSuggestionAction);
registerEditorAction(ShowPreviousInlineSuggestionAction);
registerEditorAction(AcceptNextWordOfInlineCompletion);
registerEditorAction(AcceptNextLineOfInlineCompletion);
registerEditorAction(AcceptInlineCompletion);
registerEditorAction(HideInlineCompletion);
registerAction2(ToggleAlwaysShowInlineSuggestionToolbar);
HoverParticipantRegistry.register(InlineCompletionsHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentation.js
init_lifecycle();
init_strings();
init_editorExtensions();
init_editOperation();
init_range();
init_selection();
init_editorContextKeys();
init_languageConfigurationRegistry();
init_model2();

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentUtils.js
function getSpaceCnt(str, tabSize) {
  let spacesCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) === "	") {
      spacesCnt += tabSize;
    } else {
      spacesCnt++;
    }
  }
  return spacesCnt;
}
function generateIndent(spacesCnt, tabSize, insertSpaces) {
  spacesCnt = spacesCnt < 0 ? 0 : spacesCnt;
  let result = "";
  if (!insertSpaces) {
    const tabsCnt = Math.floor(spacesCnt / tabSize);
    spacesCnt = spacesCnt % tabSize;
    for (let i = 0; i < tabsCnt; i++) {
      result += "	";
    }
  }
  for (let i = 0; i < spacesCnt; i++) {
    result += " ";
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentation.js
init_nls();
init_indentation();
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber, inheritedIndent) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return [];
  }
  const indentationRules = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentationRules;
  if (!indentationRules) {
    return [];
  }
  endLineNumber = Math.min(endLineNumber, model.getLineCount());
  while (startLineNumber <= endLineNumber) {
    if (!indentationRules.unIndentedLinePattern) {
      break;
    }
    const text = model.getLineContent(startLineNumber);
    if (!indentationRules.unIndentedLinePattern.test(text)) {
      break;
    }
    startLineNumber++;
  }
  if (startLineNumber > endLineNumber - 1) {
    return [];
  }
  const { tabSize, indentSize, insertSpaces } = model.getOptions();
  const shiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  const unshiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  const indentEdits = [];
  let globalIndent;
  const currentLineText = model.getLineContent(startLineNumber);
  let adjustedLineContent = currentLineText;
  if (inheritedIndent !== void 0 && inheritedIndent !== null) {
    globalIndent = inheritedIndent;
    const oldIndentation = getLeadingWhitespace(currentLineText);
    adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {
      globalIndent = unshiftIndent(globalIndent);
      adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    }
    if (currentLineText !== adjustedLineContent) {
      indentEdits.push(EditOperation.replaceMove(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), normalizeIndentation(globalIndent, indentSize, insertSpaces)));
    }
  } else {
    globalIndent = getLeadingWhitespace(currentLineText);
  }
  let idealIndentForNextLine = globalIndent;
  if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    globalIndent = shiftIndent(globalIndent);
  } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
  }
  startLineNumber++;
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    const text = model.getLineContent(lineNumber);
    const oldIndentation = getLeadingWhitespace(text);
    const adjustedLineContent2 = idealIndentForNextLine + text.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);
      globalIndent = unshiftIndent(globalIndent);
    }
    if (oldIndentation !== idealIndentForNextLine) {
      indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));
    }
    if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {
      continue;
    } else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent2)) {
      globalIndent = shiftIndent(globalIndent);
      idealIndentForNextLine = globalIndent;
    } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    } else {
      idealIndentForNextLine = globalIndent;
    }
  }
  return indentEdits;
}
var IndentationToSpacesAction = class _IndentationToSpacesAction extends EditorAction {
  constructor() {
    super({
      id: _IndentationToSpacesAction.ID,
      label: localize("indentationToSpaces", "Convert Indentation to Spaces"),
      alias: "Convert Indentation to Spaces",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const modelOpts = model.getOptions();
    const selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: true
    });
  }
};
IndentationToSpacesAction.ID = "editor.action.indentationToSpaces";
var IndentationToTabsAction = class _IndentationToTabsAction extends EditorAction {
  constructor() {
    super({
      id: _IndentationToTabsAction.ID,
      label: localize("indentationToTabs", "Convert Indentation to Tabs"),
      alias: "Convert Indentation to Tabs",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const modelOpts = model.getOptions();
    const selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: false
    });
  }
};
IndentationToTabsAction.ID = "editor.action.indentationToTabs";
var ChangeIndentationSizeAction = class extends EditorAction {
  constructor(insertSpaces, displaySizeOnly, opts) {
    super(opts);
    this.insertSpaces = insertSpaces;
    this.displaySizeOnly = displaySizeOnly;
  }
  run(accessor, editor2) {
    const quickInputService = accessor.get(IQuickInputService);
    const modelService = accessor.get(IModelService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    const modelOpts = model.getOptions();
    const picks = [1, 2, 3, 4, 5, 6, 7, 8].map((n) => ({
      id: n.toString(),
      label: n.toString(),
      // add description for tabSize value set in the configuration
      description: n === creationOpts.tabSize && n === modelOpts.tabSize ? localize("configuredTabSize", "Configured Tab Size") : n === creationOpts.tabSize ? localize("defaultTabSize", "Default Tab Size") : n === modelOpts.tabSize ? localize("currentTabSize", "Current Tab Size") : void 0
    }));
    const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
    setTimeout(
      () => {
        quickInputService.pick(picks, { placeHolder: localize({ key: "selectTabWidth", comment: ["Tab corresponds to the tab key"] }, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex] }).then((pick) => {
          if (pick) {
            if (model && !model.isDisposed()) {
              const pickedVal = parseInt(pick.label, 10);
              if (this.displaySizeOnly) {
                model.updateOptions({
                  tabSize: pickedVal
                });
              } else {
                model.updateOptions({
                  tabSize: pickedVal,
                  indentSize: pickedVal,
                  insertSpaces: this.insertSpaces
                });
              }
            }
          }
        });
      },
      50
      /* quick input is sensitive to being opened so soon after another */
    );
  }
};
var IndentUsingTabs = class _IndentUsingTabs extends ChangeIndentationSizeAction {
  constructor() {
    super(false, false, {
      id: _IndentUsingTabs.ID,
      label: localize("indentUsingTabs", "Indent Using Tabs"),
      alias: "Indent Using Tabs",
      precondition: void 0
    });
  }
};
IndentUsingTabs.ID = "editor.action.indentUsingTabs";
var IndentUsingSpaces = class _IndentUsingSpaces extends ChangeIndentationSizeAction {
  constructor() {
    super(true, false, {
      id: _IndentUsingSpaces.ID,
      label: localize("indentUsingSpaces", "Indent Using Spaces"),
      alias: "Indent Using Spaces",
      precondition: void 0
    });
  }
};
IndentUsingSpaces.ID = "editor.action.indentUsingSpaces";
var ChangeTabDisplaySize = class _ChangeTabDisplaySize extends ChangeIndentationSizeAction {
  constructor() {
    super(true, true, {
      id: _ChangeTabDisplaySize.ID,
      label: localize("changeTabDisplaySize", "Change Tab Display Size"),
      alias: "Change Tab Display Size",
      precondition: void 0
    });
  }
};
ChangeTabDisplaySize.ID = "editor.action.changeTabDisplaySize";
var DetectIndentation = class _DetectIndentation extends EditorAction {
  constructor() {
    super({
      id: _DetectIndentation.ID,
      label: localize("detectIndentation", "Detect Indentation from Content"),
      alias: "Detect Indentation from Content",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const modelService = accessor.get(IModelService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
  }
};
DetectIndentation.ID = "editor.action.detectIndentation";
var ReindentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentlines",
      label: localize("editor.reindentlines", "Reindent Lines"),
      alias: "Reindent Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const edits = getReindentEditOperations(model, languageConfigurationService, 1, model.getLineCount());
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
};
var ReindentSelectedLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentselectedlines",
      label: localize("editor.reindentselectedlines", "Reindent Selected Lines"),
      alias: "Reindent Selected Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const edits = [];
    for (const selection of selections) {
      let startLineNumber = selection.startLineNumber;
      let endLineNumber = selection.endLineNumber;
      if (startLineNumber !== endLineNumber && selection.endColumn === 1) {
        endLineNumber--;
      }
      if (startLineNumber === 1) {
        if (startLineNumber === endLineNumber) {
          continue;
        }
      } else {
        startLineNumber--;
      }
      const editOperations = getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber);
      edits.push(...editOperations);
    }
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
};
var AutoIndentOnPasteCommand = class {
  constructor(edits, initialSelection) {
    this._initialSelection = initialSelection;
    this._edits = [];
    this._selectionId = null;
    for (const edit of edits) {
      if (edit.range && typeof edit.text === "string") {
        this._edits.push(edit);
      }
    }
  }
  getEditOperations(model, builder) {
    for (const edit of this._edits) {
      builder.addEditOperation(Range.lift(edit.range), edit.text);
    }
    let selectionIsSet = false;
    if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
      if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, true);
      } else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, false);
      }
    }
    if (!selectionIsSet) {
      this._selectionId = builder.trackSelection(this._initialSelection);
    }
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
var AutoIndentOnPaste = class AutoIndentOnPaste2 {
  constructor(editor2, _languageConfigurationService) {
    this.editor = editor2;
    this._languageConfigurationService = _languageConfigurationService;
    this.callOnDispose = new DisposableStore();
    this.callOnModel = new DisposableStore();
    this.callOnDispose.add(editor2.onDidChangeConfiguration(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModel(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModelLanguage(() => this.update()));
  }
  update() {
    this.callOnModel.clear();
    if (this.editor.getOption(
      11
      /* EditorOption.autoIndent */
    ) < 4 || this.editor.getOption(
      54
      /* EditorOption.formatOnPaste */
    )) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    this.callOnModel.add(this.editor.onDidPaste(({ range }) => {
      this.trigger(range);
    }));
  }
  trigger(range) {
    const selections = this.editor.getSelections();
    if (selections === null || selections.length > 1) {
      return;
    }
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber)) {
      return;
    }
    const autoIndent = this.editor.getOption(
      11
      /* EditorOption.autoIndent */
    );
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    const textEdits = [];
    const indentConverter = {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
    let startLineNumber = range.startLineNumber;
    while (startLineNumber <= range.endLineNumber) {
      if (this.shouldIgnoreLine(model, startLineNumber)) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber > range.endLineNumber) {
      return;
    }
    let firstLineText = model.getLineContent(startLineNumber);
    if (!/\S/.test(firstLineText.substring(0, range.startColumn - 1))) {
      const indentOfFirstLine = getGoodIndentForLine(autoIndent, model, model.getLanguageId(), startLineNumber, indentConverter, this._languageConfigurationService);
      if (indentOfFirstLine !== null) {
        const oldIndentation = getLeadingWhitespace(firstLineText);
        const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
        const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        if (newSpaceCnt !== oldSpaceCnt) {
          const newIndent = generateIndent(newSpaceCnt, tabSize, insertSpaces);
          textEdits.push({
            range: new Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),
            text: newIndent
          });
          firstLineText = newIndent + firstLineText.substr(oldIndentation.length);
        } else {
          const indentMetadata = getIndentMetadata(model, startLineNumber, this._languageConfigurationService);
          if (indentMetadata === 0 || indentMetadata === 8) {
            return;
          }
        }
      }
    }
    const firstLineNumber = startLineNumber;
    while (startLineNumber < range.endLineNumber) {
      if (!/\S/.test(model.getLineContent(startLineNumber + 1))) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber !== range.endLineNumber) {
      const virtualModel = {
        tokenization: {
          getLineTokens: (lineNumber) => {
            return model.tokenization.getLineTokens(lineNumber);
          },
          getLanguageId: () => {
            return model.getLanguageId();
          },
          getLanguageIdAtPosition: (lineNumber, column) => {
            return model.getLanguageIdAtPosition(lineNumber, column);
          }
        },
        getLineContent: (lineNumber) => {
          if (lineNumber === firstLineNumber) {
            return firstLineText;
          } else {
            return model.getLineContent(lineNumber);
          }
        }
      };
      const indentOfSecondLine = getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageId(), startLineNumber + 1, indentConverter, this._languageConfigurationService);
      if (indentOfSecondLine !== null) {
        const newSpaceCntOfSecondLine = getSpaceCnt(indentOfSecondLine, tabSize);
        const oldSpaceCntOfSecondLine = getSpaceCnt(getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);
        if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {
          const spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;
          for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {
            const lineContent = model.getLineContent(i);
            const originalIndent = getLeadingWhitespace(lineContent);
            const originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
            const newSpacesCnt = originalSpacesCnt + spaceCntOffset;
            const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
            if (newIndent !== originalIndent) {
              textEdits.push({
                range: new Range(i, 1, i, originalIndent.length + 1),
                text: newIndent
              });
            }
          }
        }
      }
    }
    if (textEdits.length > 0) {
      this.editor.pushUndoStop();
      const cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());
      this.editor.executeCommand("autoIndentOnPaste", cmd);
      this.editor.pushUndoStop();
    }
  }
  shouldIgnoreLine(model, lineNumber) {
    model.tokenization.forceTokenization(lineNumber);
    const nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (nonWhitespaceColumn === 0) {
      return true;
    }
    const tokens = model.tokenization.getLineTokens(lineNumber);
    if (tokens.getCount() > 0) {
      const firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);
      if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1) {
        return true;
      }
    }
    return false;
  }
  dispose() {
    this.callOnDispose.dispose();
    this.callOnModel.dispose();
  }
};
AutoIndentOnPaste.ID = "editor.contrib.autoIndentOnPaste";
AutoIndentOnPaste = __decorate23([
  __param23(1, ILanguageConfigurationService)
], AutoIndentOnPaste);
function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return;
  }
  let spaces = "";
  for (let i = 0; i < tabSize; i++) {
    spaces += " ";
  }
  const spacesRegExp = new RegExp(spaces, "gi");
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (lastIndentationColumn === 0) {
      lastIndentationColumn = model.getLineMaxColumn(lineNumber);
    }
    if (lastIndentationColumn === 1) {
      continue;
    }
    const originalIndentationRange = new Range(lineNumber, 1, lineNumber, lastIndentationColumn);
    const originalIndentation = model.getValueInRange(originalIndentationRange);
    const newIndentation = tabsToSpaces ? originalIndentation.replace(/\t/ig, spaces) : originalIndentation.replace(spacesRegExp, "	");
    builder.addEditOperation(originalIndentationRange, newIndentation);
  }
}
var IndentationToSpacesCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, true);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
var IndentationToTabsCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, false);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
registerEditorContribution(
  AutoIndentOnPaste.ID,
  AutoIndentOnPaste,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(IndentationToSpacesAction);
registerEditorAction(IndentationToTabsAction);
registerEditorAction(IndentUsingTabs);
registerEditorAction(IndentUsingSpaces);
registerEditorAction(ChangeTabDisplaySize);
registerEditorAction(DetectIndentation);
registerEditorAction(ReindentLinesAction);
registerEditorAction(ReindentSelectedLinesAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsContribution.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsHover.js
init_async();
init_htmlContent();
init_position();
init_textModel();
init_language();
init_resolverService();
init_configuration();
init_opener();
init_languageFeatures();
init_nls();
init_platform();
init_arrays();
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues2 = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var InlayHintsHoverAnchor = class extends HoverForeignElementAnchor {
  constructor(part, owner, initialMousePosX, initialMousePosY) {
    super(10, owner, part.item.anchor.range, initialMousePosX, initialMousePosY, true);
    this.part = part;
  }
};
var InlayHintsHover = class InlayHintsHover2 extends MarkdownHoverParticipant {
  constructor(editor2, languageService, openerService, configurationService, _resolverService, languageFeaturesService) {
    super(editor2, languageService, openerService, configurationService, languageFeaturesService);
    this._resolverService = _resolverService;
    this.hoverOrdinal = 6;
  }
  suggestHoverAnchor(mouseEvent) {
    var _a;
    const controller = InlayHintsController.get(this._editor);
    if (!controller) {
      return null;
    }
    if (mouseEvent.target.type !== 6) {
      return null;
    }
    const options = (_a = mouseEvent.target.detail.injectedText) === null || _a === void 0 ? void 0 : _a.options;
    if (!(options instanceof ModelDecorationInjectedTextOptions && options.attachedData instanceof RenderedInlayHintLabelPart)) {
      return null;
    }
    return new InlayHintsHoverAnchor(options.attachedData, this, mouseEvent.event.posx, mouseEvent.event.posy);
  }
  computeSync() {
    return [];
  }
  computeAsync(anchor, _lineDecorations, token) {
    if (!(anchor instanceof InlayHintsHoverAnchor)) {
      return AsyncIterableObject.EMPTY;
    }
    return new AsyncIterableObject((executor) => __awaiter23(this, void 0, void 0, function* () {
      var _a, e_1, _b, _c;
      const { part } = anchor;
      yield part.item.resolve(token);
      if (token.isCancellationRequested) {
        return;
      }
      let itemTooltip;
      if (typeof part.item.hint.tooltip === "string") {
        itemTooltip = new MarkdownString().appendText(part.item.hint.tooltip);
      } else if (part.item.hint.tooltip) {
        itemTooltip = part.item.hint.tooltip;
      }
      if (itemTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [itemTooltip], false, 0));
      }
      if (isNonEmptyArray(part.item.hint.textEdits)) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("hint.dbl", "Double-click to insert"))], false, 10001));
      }
      let partTooltip;
      if (typeof part.part.tooltip === "string") {
        partTooltip = new MarkdownString().appendText(part.part.tooltip);
      } else if (part.part.tooltip) {
        partTooltip = part.part.tooltip;
      }
      if (partTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [partTooltip], false, 1));
      }
      if (part.part.location || part.part.command) {
        let linkHint;
        const useMetaKey = this._editor.getOption(
          76
          /* EditorOption.multiCursorModifier */
        ) === "altKey";
        const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
        if (part.part.location && part.part.command) {
          linkHint = new MarkdownString().appendText(localize("hint.defAndCommand", "Go to Definition ({0}), right click for more", kb));
        } else if (part.part.location) {
          linkHint = new MarkdownString().appendText(localize("hint.def", "Go to Definition ({0})", kb));
        } else if (part.part.command) {
          linkHint = new MarkdownString(`[${localize("hint.cmd", "Execute Command")}](${asCommandLink(part.part.command)} "${part.part.command.title}") (${kb})`, { isTrusted: true });
        }
        if (linkHint) {
          executor.emitOne(new MarkdownHover(this, anchor.range, [linkHint], false, 1e4));
        }
      }
      const iterable = yield this._resolveInlayHintLabelPartHover(part, token);
      try {
        for (var _d = true, iterable_1 = __asyncValues2(iterable), iterable_1_1; iterable_1_1 = yield iterable_1.next(), _a = iterable_1_1.done, !_a; _d = true) {
          _c = iterable_1_1.value;
          _d = false;
          const item = _c;
          executor.emitOne(item);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = iterable_1.return))
            yield _b.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }));
  }
  _resolveInlayHintLabelPartHover(part, token) {
    return __awaiter23(this, void 0, void 0, function* () {
      if (!part.part.location) {
        return AsyncIterableObject.EMPTY;
      }
      const { uri, range } = part.part.location;
      const ref = yield this._resolverService.createModelReference(uri);
      try {
        const model = ref.object.textEditorModel;
        if (!this._languageFeaturesService.hoverProvider.has(model)) {
          return AsyncIterableObject.EMPTY;
        }
        return getHover(this._languageFeaturesService.hoverProvider, model, new Position(range.startLineNumber, range.startColumn), token).filter((item) => !isEmptyMarkdownString(item.hover.contents)).map((item) => new MarkdownHover(this, part.item.anchor.range, item.hover.contents, false, 2 + item.ordinal));
      } finally {
        ref.dispose();
      }
    });
  }
};
InlayHintsHover = __decorate24([
  __param24(1, ILanguageService),
  __param24(2, IOpenerService),
  __param24(3, IConfigurationService),
  __param24(4, ITextModelService),
  __param24(5, ILanguageFeaturesService)
], InlayHintsHover);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsContribution.js
registerEditorContribution(
  InlayHintsController.ID,
  InlayHintsController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
HoverParticipantRegistry.register(InlayHintsHover);

// node_modules/monaco-editor/esm/vs/editor/editor.all.js
var import_inPlaceReplace2 = __toESM(require_inPlaceReplace());

// node_modules/monaco-editor/esm/vs/editor/contrib/lineSelection/browser/lineSelection.js
init_editorExtensions();
init_editorContextKeys();
init_nls();
var ExpandLineSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "expandLineSelection",
      label: localize("expandLineSelection", "Expand Line Selection"),
      alias: "Expand Line Selection",
      precondition: void 0,
      kbOpts: {
        weight: 0,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 42
        /* KeyCode.KeyL */
      }
    });
  }
  run(_accessor, editor2, args) {
    args = args || {};
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    viewModel.model.pushStackElement();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.expandLineSelection(viewModel, viewModel.getCursorStates()));
    viewModel.revealPrimaryCursor(args.source, true);
  }
};
registerEditorAction(ExpandLineSelectionAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js
init_keyCodes();
init_editorExtensions();
init_editOperation();
init_position();
init_range();
init_selection();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/copyLinesCommand.js
init_range();
init_selection();
var CopyLinesCommand = class {
  constructor(selection, isCopyingDown, noop) {
    this._selection = selection;
    this._isCopyingDown = isCopyingDown;
    this._noop = noop || false;
    this._selectionDirection = 0;
    this._selectionId = null;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._endLineNumberDelta = 1;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const sourceLines = [];
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      sourceLines.push(model.getLineContent(i));
    }
    const sourceText = sourceLines.join("\n");
    if (sourceText === "") {
      if (this._isCopyingDown) {
        this._startLineNumberDelta++;
        this._endLineNumberDelta++;
      }
    }
    if (this._noop) {
      builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber + 1, 1), s.endLineNumber === model.getLineCount() ? "" : "\n");
    } else {
      if (!this._isCopyingDown) {
        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + sourceText);
      } else {
        builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + "\n");
      }
    }
    this._selectionId = builder.trackSelection(s);
    this._selectionDirection = this._selection.getDirection();
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
      let startLineNumber = result.startLineNumber;
      let startColumn = result.startColumn;
      let endLineNumber = result.endLineNumber;
      let endColumn = result.endColumn;
      if (this._startLineNumberDelta !== 0) {
        startLineNumber = startLineNumber + this._startLineNumberDelta;
        startColumn = 1;
      }
      if (this._endLineNumberDelta !== 0) {
        endLineNumber = endLineNumber + this._endLineNumberDelta;
        endColumn = 1;
      }
      result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
    }
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js
init_strings();
init_range();
init_selection();
init_languageConfiguration();
init_languageConfigurationRegistry();
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MoveLinesCommand = class MoveLinesCommand2 {
  constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {
    this._languageConfigurationService = _languageConfigurationService;
    this._selection = selection;
    this._isMovingDown = isMovingDown;
    this._autoIndent = autoIndent;
    this._selectionId = null;
    this._moveEndLineSelectionShrink = false;
  }
  getEditOperations(model, builder) {
    const modelLineCount = model.getLineCount();
    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    if (!this._isMovingDown && this._selection.startLineNumber === 1) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    this._moveEndPositionDown = false;
    let s = this._selection;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);
    const virtualModel = {
      tokenization: {
        getLineTokens: (lineNumber) => {
          return model.tokenization.getLineTokens(lineNumber);
        },
        getLanguageId: () => {
          return model.getLanguageId();
        },
        getLanguageIdAtPosition: (lineNumber, column) => {
          return model.getLanguageIdAtPosition(lineNumber, column);
        }
      },
      getLineContent: null
    };
    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
      const lineNumber = s.startLineNumber;
      const otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;
      if (model.getLineMaxColumn(otherLineNumber) === 1) {
        builder.addEditOperation(new Range(1, 1, 1, 1), null);
      } else {
        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
        builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
      }
      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);
    } else {
      let movingLineNumber;
      let movingLineText;
      if (this._isMovingDown) {
        movingLineNumber = s.endLineNumber + 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
        let insertingText = movingLineText;
        if (this.shouldAutoIndent(model, s)) {
          const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);
          if (movingLineMatchResult !== null) {
            const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
            const newSpaceCnt = movingLineMatchResult + getSpaceCnt(oldIndentation, tabSize);
            const newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
            insertingText = newIndentation + this.trimStart(movingLineText);
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return model.getLineContent(movingLineNumber);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);
            if (indentOfMovingLine !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
              const newSpaceCnt = getSpaceCnt(indentOfMovingLine, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                insertingText = newIndentation + this.trimStart(movingLineText);
              }
            }
          }
          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
          const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return insertingText;
              } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {
                return model.getLineContent(lineNumber - 1);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);
            if (newIndentatOfMovingBlock !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(newIndentatOfMovingBlock, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        } else {
          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
        }
      } else {
        movingLineNumber = s.startLineNumber - 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);
        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + movingLineText);
        if (this.shouldAutoIndent(model, s)) {
          virtualModel.getLineContent = (lineNumber) => {
            if (lineNumber === movingLineNumber) {
              return model.getLineContent(s.startLineNumber);
            } else {
              return model.getLineContent(lineNumber);
            }
          };
          const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);
            if (indentOfFirstLine !== null) {
              const oldIndent = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndent, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  buildIndentConverter(tabSize, indentSize, insertSpaces) {
    return {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
  }
  parseEnterResult(model, indentConverter, tabSize, line, enter) {
    if (enter) {
      let enterPrefix = enter.indentation;
      if (enter.indentAction === IndentAction.None) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.Indent) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.IndentOutdent) {
        enterPrefix = enter.indentation;
      } else if (enter.indentAction === IndentAction.Outdent) {
        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;
      }
      const movingLineText = model.getLineContent(line);
      if (this.trimStart(movingLineText).indexOf(this.trimStart(enterPrefix)) >= 0) {
        const oldIndentation = getLeadingWhitespace(model.getLineContent(line));
        let newIndentation = getLeadingWhitespace(enterPrefix);
        const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);
        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2) {
          newIndentation = indentConverter.unshiftIndent(newIndentation);
        }
        const newSpaceCnt = getSpaceCnt(newIndentation, tabSize);
        const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        return newSpaceCnt - oldSpaceCnt;
      }
    }
    return null;
  }
  /**
   *
   * @param model
   * @param indentConverter
   * @param tabSize
   * @param line the line moving down
   * @param futureAboveLineNumber the line which will be at the `line` position
   * @param futureAboveLineText
   */
  matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {
    if (lastNonWhitespaceIndex(futureAboveLineText) >= 0) {
      const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);
      const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    } else {
      let validPrecedingLine = line - 1;
      while (validPrecedingLine >= 1) {
        const lineContent = model.getLineContent(validPrecedingLine);
        const nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
        if (nonWhitespaceIdx >= 0) {
          break;
        }
        validPrecedingLine--;
      }
      if (validPrecedingLine < 1 || line > model.getLineCount()) {
        return null;
      }
      const maxColumn = model.getLineMaxColumn(validPrecedingLine);
      const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    }
  }
  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {
    let validPrecedingLine = oneLineAbove;
    while (validPrecedingLine >= 1) {
      let lineContent;
      if (validPrecedingLine === oneLineAbove && previousLineText !== void 0) {
        lineContent = previousLineText;
      } else {
        lineContent = model.getLineContent(validPrecedingLine);
      }
      const nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
      if (nonWhitespaceIdx >= 0) {
        break;
      }
      validPrecedingLine--;
    }
    if (validPrecedingLine < 1 || line > model.getLineCount()) {
      return null;
    }
    const maxColumn = model.getLineMaxColumn(validPrecedingLine);
    const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
    return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
  }
  trimStart(str) {
    return str.replace(/^\s+/, "");
  }
  shouldAutoIndent(model, selection) {
    if (this._autoIndent < 4) {
      return false;
    }
    if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {
      return false;
    }
    const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);
    const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);
    if (languageAtSelectionStart !== languageAtSelectionEnd) {
      return false;
    }
    if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {
      return false;
    }
    return true;
  }
  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      const lineContent = model.getLineContent(i);
      const originalIndent = getLeadingWhitespace(lineContent);
      const originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
      const newSpacesCnt = originalSpacesCnt + offset;
      const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
      if (newIndent !== originalIndent) {
        builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);
        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === "") {
          this._moveEndLineSelectionShrink = true;
        }
      }
    }
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {
      result = result.setEndPosition(result.endLineNumber, 2);
    }
    return result;
  }
};
MoveLinesCommand = __decorate25([
  __param25(3, ILanguageConfigurationService)
], MoveLinesCommand);

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/sortLinesCommand.js
init_editOperation();
init_range();
var SortLinesCommand = class _SortLinesCommand {
  static getCollator() {
    if (!_SortLinesCommand._COLLATOR) {
      _SortLinesCommand._COLLATOR = new Intl.Collator();
    }
    return _SortLinesCommand._COLLATOR;
  }
  constructor(selection, descending) {
    this.selection = selection;
    this.descending = descending;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    const op = sortLines(model, this.selection, this.descending);
    if (op) {
      builder.addEditOperation(op.range, op.text);
    }
    this.selectionId = builder.trackSelection(this.selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
  static canRun(model, selection, descending) {
    if (model === null) {
      return false;
    }
    const data = getSortData(model, selection, descending);
    if (!data) {
      return false;
    }
    for (let i = 0, len = data.before.length; i < len; i++) {
      if (data.before[i] !== data.after[i]) {
        return true;
      }
    }
    return false;
  }
};
SortLinesCommand._COLLATOR = null;
function getSortData(model, selection, descending) {
  const startLineNumber = selection.startLineNumber;
  let endLineNumber = selection.endLineNumber;
  if (selection.endColumn === 1) {
    endLineNumber--;
  }
  if (startLineNumber >= endLineNumber) {
    return null;
  }
  const linesToSort = [];
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    linesToSort.push(model.getLineContent(lineNumber));
  }
  let sorted = linesToSort.slice(0);
  sorted.sort(SortLinesCommand.getCollator().compare);
  if (descending === true) {
    sorted = sorted.reverse();
  }
  return {
    startLineNumber,
    endLineNumber,
    before: linesToSort,
    after: sorted
  };
}
function sortLines(model, selection, descending) {
  const data = getSortData(model, selection, descending);
  if (!data) {
    return null;
  }
  return EditOperation.replace(new Range(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join("\n"));
}

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js
init_nls();
init_actions2();
init_languageConfigurationRegistry();
var AbstractCopyLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignore: false }));
    selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i = 1; i < selections.length; i++) {
      const curr = selections[i];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignore = true;
        } else {
          prev.ignore = true;
          prev = curr;
        }
      }
    }
    const commands = [];
    for (const selection of selections) {
      commands.push(new CopyLinesCommand(selection.selection, this.down, selection.ignore));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var CopyLinesUpAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.copyLinesUpAction",
      label: localize("lines.copyUp", "Copy Line Up"),
      alias: "Copy Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 16,
        linux: {
          primary: 2048 | 512 | 1024 | 16
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miCopyLinesUp", comment: ["&& denotes a mnemonic"] }, "&&Copy Line Up"),
        order: 1
      }
    });
  }
};
var CopyLinesDownAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.copyLinesDownAction",
      label: localize("lines.copyDown", "Copy Line Down"),
      alias: "Copy Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 18,
        linux: {
          primary: 2048 | 512 | 1024 | 18
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miCopyLinesDown", comment: ["&& denotes a mnemonic"] }, "Co&&py Line Down"),
        order: 2
      }
    });
  }
};
var DuplicateSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.duplicateSelection",
      label: localize("duplicateSelection", "Duplicate Selection"),
      alias: "Duplicate Selection",
      precondition: EditorContextKeys.writable,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miDuplicateSelection", comment: ["&& denotes a mnemonic"] }, "&&Duplicate Selection"),
        order: 5
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const commands = [];
    const selections = editor2.getSelections();
    const model = editor2.getModel();
    for (const selection of selections) {
      if (selection.isEmpty()) {
        commands.push(new CopyLinesCommand(selection, true));
      } else {
        const insertSelection = new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);
        commands.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var AbstractMoveLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const commands = [];
    const selections = editor2.getSelections() || [];
    const autoIndent = editor2.getOption(
      11
      /* EditorOption.autoIndent */
    );
    for (const selection of selections) {
      commands.push(new MoveLinesCommand(selection, this.down, autoIndent, languageConfigurationService));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var MoveLinesUpAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.moveLinesUpAction",
      label: localize("lines.moveUp", "Move Line Up"),
      alias: "Move Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 16,
        linux: {
          primary: 512 | 16
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miMoveLinesUp", comment: ["&& denotes a mnemonic"] }, "Mo&&ve Line Up"),
        order: 3
      }
    });
  }
};
var MoveLinesDownAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.moveLinesDownAction",
      label: localize("lines.moveDown", "Move Line Down"),
      alias: "Move Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 18,
        linux: {
          primary: 512 | 18
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miMoveLinesDown", comment: ["&& denotes a mnemonic"] }, "Move &&Line Down"),
        order: 4
      }
    });
  }
};
var AbstractSortLinesAction = class extends EditorAction {
  constructor(descending, opts) {
    super(opts);
    this.descending = descending;
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections() || [];
    for (const selection of selections) {
      if (!SortLinesCommand.canRun(editor2.getModel(), selection, this.descending)) {
        return;
      }
    }
    const commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = new SortLinesCommand(selections[i], this.descending);
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var SortLinesAscendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.sortLinesAscending",
      label: localize("lines.sortAscending", "Sort Lines Ascending"),
      alias: "Sort Lines Ascending",
      precondition: EditorContextKeys.writable
    });
  }
};
var SortLinesDescendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.sortLinesDescending",
      label: localize("lines.sortDescending", "Sort Lines Descending"),
      alias: "Sort Lines Descending",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteDuplicateLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.removeDuplicateLines",
      label: localize("lines.deleteDuplicates", "Delete Duplicate Lines"),
      alias: "Delete Duplicate Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    const edits = [];
    const endCursorState = [];
    let linesDeleted = 0;
    for (const selection of editor2.getSelections()) {
      const uniqueLines = /* @__PURE__ */ new Set();
      const lines = [];
      for (let i = selection.startLineNumber; i <= selection.endLineNumber; i++) {
        const line = model.getLineContent(i);
        if (uniqueLines.has(line)) {
          continue;
        }
        lines.push(line);
        uniqueLines.add(line);
      }
      const selectionToReplace = new Selection(selection.startLineNumber, 1, selection.endLineNumber, model.getLineMaxColumn(selection.endLineNumber));
      const adjustedSelectionStart = selection.startLineNumber - linesDeleted;
      const finalSelection = new Selection(adjustedSelectionStart, 1, adjustedSelectionStart + lines.length - 1, lines[lines.length - 1].length);
      edits.push(EditOperation.replace(selectionToReplace, lines.join("\n")));
      endCursorState.push(finalSelection);
      linesDeleted += selection.endLineNumber - selection.startLineNumber + 1 - lines.length;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
var TrimTrailingWhitespaceAction = class _TrimTrailingWhitespaceAction extends EditorAction {
  constructor() {
    super({
      id: _TrimTrailingWhitespaceAction.ID,
      label: localize("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
      alias: "Trim Trailing Whitespace",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 54
          /* KeyCode.KeyX */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2, args) {
    let cursors = [];
    if (args.reason === "auto-save") {
      cursors = (editor2.getSelections() || []).map((s) => new Position(s.positionLineNumber, s.positionColumn));
    }
    const selection = editor2.getSelection();
    if (selection === null) {
      return;
    }
    const command = new TrimTrailingWhitespaceCommand(selection, cursors);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
  }
};
TrimTrailingWhitespaceAction.ID = "editor.action.trimTrailingWhitespace";
var DeleteLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.deleteLines",
      label: localize("lines.delete", "Delete Line"),
      alias: "Delete Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 41,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const ops = this._getLinesToRemove(editor2);
    const model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    let linesDeleted = 0;
    const edits = [];
    const cursorState = [];
    for (let i = 0, len = ops.length; i < len; i++) {
      const op = ops[i];
      let startLineNumber = op.startLineNumber;
      let endLineNumber = op.endLineNumber;
      let startColumn = 1;
      let endColumn = model.getLineMaxColumn(endLineNumber);
      if (endLineNumber < model.getLineCount()) {
        endLineNumber += 1;
        endColumn = 1;
      } else if (startLineNumber > 1) {
        startLineNumber -= 1;
        startColumn = model.getLineMaxColumn(startLineNumber);
      }
      edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ""));
      cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));
      linesDeleted += op.endLineNumber - op.startLineNumber + 1;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, cursorState);
    editor2.pushUndoStop();
  }
  _getLinesToRemove(editor2) {
    const operations = editor2.getSelections().map((s) => {
      let endLineNumber = s.endLineNumber;
      if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
        endLineNumber -= 1;
      }
      return {
        startLineNumber: s.startLineNumber,
        selectionStartColumn: s.selectionStartColumn,
        endLineNumber,
        positionColumn: s.positionColumn
      };
    });
    operations.sort((a, b) => {
      if (a.startLineNumber === b.startLineNumber) {
        return a.endLineNumber - b.endLineNumber;
      }
      return a.startLineNumber - b.startLineNumber;
    });
    const mergedOperations = [];
    let previousOperation = operations[0];
    for (let i = 1; i < operations.length; i++) {
      if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {
        previousOperation.endLineNumber = operations[i].endLineNumber;
      } else {
        mergedOperations.push(previousOperation);
        previousOperation = operations[i];
      }
    }
    mergedOperations.push(previousOperation);
    return mergedOperations;
  }
};
var IndentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.indentLines",
      label: localize("lines.indent", "Indent Line"),
      alias: "Indent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 94,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
    editor2.pushUndoStop();
  }
};
var OutdentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.outdentLines",
      label: localize("lines.outdent", "Outdent Line"),
      alias: "Outdent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 92,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor2, null);
  }
};
var InsertLineBeforeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineBefore",
      label: localize("lines.insertBefore", "Insert Line Above"),
      alias: "Insert Line Above",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.lineInsertBefore(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
};
var InsertLineAfterAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineAfter",
      label: localize("lines.insertAfter", "Insert Line Below"),
      alias: "Insert Line Below",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.lineInsertAfter(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
};
var AbstractDeleteAllToBoundaryAction = class extends EditorAction {
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const primaryCursor = editor2.getSelection();
    const rangesToDelete = this._getRangesToDelete(editor2);
    const effectiveRanges = [];
    for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {
      const range = rangesToDelete[i];
      const nextRange = rangesToDelete[i + 1];
      if (Range.intersectRanges(range, nextRange) === null) {
        effectiveRanges.push(range);
      } else {
        rangesToDelete[i + 1] = Range.plusRange(range, nextRange);
      }
    }
    effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
    const endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
    const edits = effectiveRanges.map((range) => {
      return EditOperation.replace(range, "");
    });
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
var DeleteAllLeftAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllLeft",
      label: localize("lines.deleteAllLeft", "Delete All Left"),
      alias: "Delete All Left",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 2048 | 1
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    const endCursorState = [];
    let deletedLines = 0;
    rangesToDelete.forEach((range) => {
      let endCursor;
      if (range.endColumn === 1 && deletedLines > 0) {
        const newStartLine = range.startLineNumber - deletedLines;
        endCursor = new Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);
      } else {
        endCursor = new Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
      }
      deletedLines += range.endLineNumber - range.startLineNumber;
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    });
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    let rangesToDelete = selections;
    const model = editor2.getModel();
    if (model === null) {
      return [];
    }
    rangesToDelete.sort(Range.compareRangesUsingStarts);
    rangesToDelete = rangesToDelete.map((selection) => {
      if (selection.isEmpty()) {
        if (selection.startColumn === 1) {
          const deleteFromLine = Math.max(1, selection.startLineNumber - 1);
          const deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1;
          return new Range(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);
        } else {
          return new Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
        }
      } else {
        return new Range(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);
      }
    });
    return rangesToDelete;
  }
};
var DeleteAllRightAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllRight",
      label: localize("lines.deleteAllRight", "Delete All Right"),
      alias: "Delete All Right",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 41, secondary: [
          2048 | 20
          /* KeyCode.Delete */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    const endCursorState = [];
    for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {
      const range = rangesToDelete[i];
      const endCursor = new Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    }
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    const model = editor2.getModel();
    if (model === null) {
      return [];
    }
    const selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    const rangesToDelete = selections.map((sel) => {
      if (sel.isEmpty()) {
        const maxColumn = model.getLineMaxColumn(sel.startLineNumber);
        if (sel.startColumn === maxColumn) {
          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
        } else {
          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
        }
      }
      return sel;
    });
    rangesToDelete.sort(Range.compareRangesUsingStarts);
    return rangesToDelete;
  }
};
var JoinLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.joinLines",
      label: localize("lines.joinLines", "Join Lines"),
      alias: "Join Lines",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        mac: {
          primary: 256 | 40
          /* KeyCode.KeyJ */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    let primaryCursor = editor2.getSelection();
    if (primaryCursor === null) {
      return;
    }
    selections.sort(Range.compareRangesUsingStarts);
    const reducedSelections = [];
    const lastSelection = selections.reduce((previousValue, currentValue) => {
      if (previousValue.isEmpty()) {
        if (previousValue.endLineNumber === currentValue.startLineNumber) {
          if (primaryCursor.equalsSelection(previousValue)) {
            primaryCursor = currentValue;
          }
          return currentValue;
        }
        if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      } else {
        if (currentValue.startLineNumber > previousValue.endLineNumber) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      }
    });
    reducedSelections.push(lastSelection);
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const edits = [];
    const endCursorState = [];
    let endPrimaryCursor = primaryCursor;
    let lineOffset = 0;
    for (let i = 0, len = reducedSelections.length; i < len; i++) {
      const selection = reducedSelections[i];
      const startLineNumber = selection.startLineNumber;
      const startColumn = 1;
      let columnDeltaOffset = 0;
      let endLineNumber, endColumn;
      const selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;
      if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
        const position = selection.getStartPosition();
        if (position.lineNumber < model.getLineCount()) {
          endLineNumber = startLineNumber + 1;
          endColumn = model.getLineMaxColumn(endLineNumber);
        } else {
          endLineNumber = position.lineNumber;
          endColumn = model.getLineMaxColumn(position.lineNumber);
        }
      } else {
        endLineNumber = selection.endLineNumber;
        endColumn = model.getLineMaxColumn(endLineNumber);
      }
      let trimmedLinesContent = model.getLineContent(startLineNumber);
      for (let i2 = startLineNumber + 1; i2 <= endLineNumber; i2++) {
        const lineText = model.getLineContent(i2);
        const firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i2);
        if (firstNonWhitespaceIdx >= 1) {
          let insertSpace = true;
          if (trimmedLinesContent === "") {
            insertSpace = false;
          }
          if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === " " || trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === "	")) {
            insertSpace = false;
            trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, " ");
          }
          const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
          trimmedLinesContent += (insertSpace ? " " : "") + lineTextWithoutIndent;
          if (insertSpace) {
            columnDeltaOffset = lineTextWithoutIndent.length + 1;
          } else {
            columnDeltaOffset = lineTextWithoutIndent.length;
          }
        } else {
          columnDeltaOffset = 0;
        }
      }
      const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
      if (!deleteSelection.isEmpty()) {
        let resultSelection;
        if (selection.isEmpty()) {
          edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
          resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
        } else {
          if (selection.startLineNumber === selection.endLineNumber) {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
          } else {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
          }
        }
        if (Range.intersectRanges(deleteSelection, primaryCursor) !== null) {
          endPrimaryCursor = resultSelection;
        } else {
          endCursorState.push(resultSelection);
        }
      }
      lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
    }
    endCursorState.unshift(endPrimaryCursor);
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
var TransposeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transpose",
      label: localize("editor.transpose", "Transpose Characters around the Cursor"),
      alias: "Transpose Characters around the Cursor",
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (!selection.isEmpty()) {
        continue;
      }
      const cursor = selection.getStartPosition();
      const maxColumn = model.getLineMaxColumn(cursor.lineNumber);
      if (cursor.column >= maxColumn) {
        if (cursor.lineNumber === model.getLineCount()) {
          continue;
        }
        const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
        const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
      } else {
        const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
        const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var AbstractCaseAction = class extends EditorAction {
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const wordSeparators = editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    );
    const textEdits = [];
    for (const selection of selections) {
      if (selection.isEmpty()) {
        const cursor = selection.getStartPosition();
        const word = editor2.getConfiguredWordAtPosition(cursor);
        if (!word) {
          continue;
        }
        const wordRange = new Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
        const text = model.getValueInRange(wordRange);
        textEdits.push(EditOperation.replace(wordRange, this._modifyText(text, wordSeparators)));
      } else {
        const text = model.getValueInRange(selection);
        textEdits.push(EditOperation.replace(selection, this._modifyText(text, wordSeparators)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, textEdits);
    editor2.pushUndoStop();
  }
};
var UpperCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToUppercase",
      label: localize("editor.transformToUppercase", "Transform to Uppercase"),
      alias: "Transform to Uppercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    return text.toLocaleUpperCase();
  }
};
var LowerCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToLowercase",
      label: localize("editor.transformToLowercase", "Transform to Lowercase"),
      alias: "Transform to Lowercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    return text.toLocaleLowerCase();
  }
};
var BackwardsCompatibleRegExp = class {
  constructor(_pattern, _flags) {
    this._pattern = _pattern;
    this._flags = _flags;
    this._actual = null;
    this._evaluated = false;
  }
  get() {
    if (!this._evaluated) {
      this._evaluated = true;
      try {
        this._actual = new RegExp(this._pattern, this._flags);
      } catch (err) {
      }
    }
    return this._actual;
  }
  isSupported() {
    return this.get() !== null;
  }
};
var TitleCaseAction = class _TitleCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToTitlecase",
      label: localize("editor.transformToTitlecase", "Transform to Title Case"),
      alias: "Transform to Title Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const titleBoundary = _TitleCaseAction.titleBoundary.get();
    if (!titleBoundary) {
      return text;
    }
    return text.toLocaleLowerCase().replace(titleBoundary, (b) => b.toLocaleUpperCase());
  }
};
TitleCaseAction.titleBoundary = new BackwardsCompatibleRegExp("(^|[^\\p{L}\\p{N}']|((^|\\P{L})'))\\p{L}", "gmu");
var SnakeCaseAction = class _SnakeCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToSnakecase",
      label: localize("editor.transformToSnakecase", "Transform to Snake Case"),
      alias: "Transform to Snake Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const caseBoundary = _SnakeCaseAction.caseBoundary.get();
    const singleLetters = _SnakeCaseAction.singleLetters.get();
    if (!caseBoundary || !singleLetters) {
      return text;
    }
    return text.replace(caseBoundary, "$1_$2").replace(singleLetters, "$1_$2$3").toLocaleLowerCase();
  }
};
SnakeCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
SnakeCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
var CamelCaseAction = class _CamelCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToCamelcase",
      label: localize("editor.transformToCamelcase", "Transform to Camel Case"),
      alias: "Transform to Camel Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const wordBoundary = _CamelCaseAction.wordBoundary.get();
    if (!wordBoundary) {
      return text;
    }
    const words = text.split(wordBoundary);
    const firstWord = words.shift();
    return firstWord + words.map((word) => word.substring(0, 1).toLocaleUpperCase() + word.substring(1)).join("");
  }
};
CamelCaseAction.wordBoundary = new BackwardsCompatibleRegExp("[_\\s-]", "gm");
var KebabCaseAction = class _KebabCaseAction extends AbstractCaseAction {
  static isSupported() {
    const areAllRegexpsSupported = [
      this.caseBoundary,
      this.singleLetters,
      this.underscoreBoundary
    ].every((regexp) => regexp.isSupported());
    return areAllRegexpsSupported;
  }
  constructor() {
    super({
      id: "editor.action.transformToKebabcase",
      label: localize("editor.transformToKebabcase", "Transform to Kebab Case"),
      alias: "Transform to Kebab Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, _) {
    const caseBoundary = _KebabCaseAction.caseBoundary.get();
    const singleLetters = _KebabCaseAction.singleLetters.get();
    const underscoreBoundary = _KebabCaseAction.underscoreBoundary.get();
    if (!caseBoundary || !singleLetters || !underscoreBoundary) {
      return text;
    }
    return text.replace(underscoreBoundary, "$1-$3").replace(caseBoundary, "$1-$2").replace(singleLetters, "$1-$2").toLocaleLowerCase();
  }
};
KebabCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
KebabCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu}\\p{Ll})", "gmu");
KebabCaseAction.underscoreBoundary = new BackwardsCompatibleRegExp("(\\S)(_)(\\S)", "gm");
registerEditorAction(CopyLinesUpAction);
registerEditorAction(CopyLinesDownAction);
registerEditorAction(DuplicateSelectionAction);
registerEditorAction(MoveLinesUpAction);
registerEditorAction(MoveLinesDownAction);
registerEditorAction(SortLinesAscendingAction);
registerEditorAction(SortLinesDescendingAction);
registerEditorAction(DeleteDuplicateLinesAction);
registerEditorAction(TrimTrailingWhitespaceAction);
registerEditorAction(DeleteLinesAction);
registerEditorAction(IndentLinesAction);
registerEditorAction(OutdentLinesAction);
registerEditorAction(InsertLineBeforeAction);
registerEditorAction(InsertLineAfterAction);
registerEditorAction(DeleteAllLeftAction);
registerEditorAction(DeleteAllRightAction);
registerEditorAction(JoinLinesAction);
registerEditorAction(TransposeAction);
registerEditorAction(UpperCaseAction);
registerEditorAction(LowerCaseAction);
if (SnakeCaseAction.caseBoundary.isSupported() && SnakeCaseAction.singleLetters.isSupported()) {
  registerEditorAction(SnakeCaseAction);
}
if (CamelCaseAction.wordBoundary.isSupported()) {
  registerEditorAction(CamelCaseAction);
}
if (TitleCaseAction.titleBoundary.isSupported()) {
  registerEditorAction(TitleCaseAction);
}
if (KebabCaseAction.isSupported()) {
  registerEditorAction(KebabCaseAction);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/browser/linkedEditing.js
init_arrays();
init_async();
init_cancellation();
init_color();
init_errors();
init_event();
init_lifecycle();
init_strings();
init_uri();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();
init_textModel();
init_languageConfigurationRegistry();
init_nls();
init_contextkey();
init_languageFeatures();
init_colorRegistry();
init_languageFeatureDebounce();
init_stopwatch();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/browser/linkedEditing.css";
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LinkedEditingContribution_1;
var CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE = new RawContextKey("LinkedEditingInputVisible", false);
var DECORATION_CLASS_NAME = "linked-editing-decoration";
var LinkedEditingContribution = LinkedEditingContribution_1 = class LinkedEditingContribution2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(LinkedEditingContribution_1.ID);
  }
  constructor(editor2, contextKeyService, languageFeaturesService, languageConfigurationService, languageFeatureDebounceService) {
    super();
    this.languageConfigurationService = languageConfigurationService;
    this._syncRangesToken = 0;
    this._localToDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._providers = languageFeaturesService.linkedEditingRangeProvider;
    this._enabled = false;
    this._visibleContextKey = CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._debounceInformation = languageFeatureDebounceService.for(this._providers, "Linked Editing", { max: 200 });
    this._currentDecorations = this._editor.createDecorationsCollection();
    this._languageWordPattern = null;
    this._currentWordPattern = null;
    this._ignoreChangeEvent = false;
    this._localToDispose = this._register(new DisposableStore());
    this._rangeUpdateTriggerPromise = null;
    this._rangeSyncTriggerPromise = null;
    this._currentRequest = null;
    this._currentRequestPosition = null;
    this._currentRequestModelVersion = null;
    this._register(this._editor.onDidChangeModel(() => this.reinitialize(true)));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        68
        /* EditorOption.linkedEditing */
      ) || e.hasChanged(
        91
        /* EditorOption.renameOnType */
      )) {
        this.reinitialize(false);
      }
    }));
    this._register(this._providers.onDidChange(() => this.reinitialize(false)));
    this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(true)));
    this.reinitialize(true);
  }
  reinitialize(forceRefresh) {
    const model = this._editor.getModel();
    const isEnabled = model !== null && (this._editor.getOption(
      68
      /* EditorOption.linkedEditing */
    ) || this._editor.getOption(
      91
      /* EditorOption.renameOnType */
    )) && this._providers.has(model);
    if (isEnabled === this._enabled && !forceRefresh) {
      return;
    }
    this._enabled = isEnabled;
    this.clearRanges();
    this._localToDispose.clear();
    if (!isEnabled || model === null) {
      return;
    }
    this._localToDispose.add(Event.runAndSubscribe(model.onDidChangeLanguageConfiguration, () => {
      this._languageWordPattern = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
    }));
    const rangeUpdateScheduler = new Delayer(this._debounceInformation.get(model));
    const triggerRangeUpdate = () => {
      var _a;
      this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), (_a = this._debounceDuration) !== null && _a !== void 0 ? _a : this._debounceInformation.get(model));
    };
    const rangeSyncScheduler = new Delayer(0);
    const triggerRangeSync = (token) => {
      this._rangeSyncTriggerPromise = rangeSyncScheduler.trigger(() => this._syncRanges(token));
    };
    this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
      triggerRangeUpdate();
    }));
    this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (!this._ignoreChangeEvent) {
        if (this._currentDecorations.length > 0) {
          const referenceRange = this._currentDecorations.getRange(0);
          if (referenceRange && e.changes.every((c) => referenceRange.intersectRanges(c.range))) {
            triggerRangeSync(this._syncRangesToken);
            return;
          }
        }
      }
      triggerRangeUpdate();
    }));
    this._localToDispose.add({
      dispose: () => {
        rangeUpdateScheduler.dispose();
        rangeSyncScheduler.dispose();
      }
    });
    this.updateRanges();
  }
  _syncRanges(token) {
    if (!this._editor.hasModel() || token !== this._syncRangesToken || this._currentDecorations.length === 0) {
      return;
    }
    const model = this._editor.getModel();
    const referenceRange = this._currentDecorations.getRange(0);
    if (!referenceRange || referenceRange.startLineNumber !== referenceRange.endLineNumber) {
      return this.clearRanges();
    }
    const referenceValue = model.getValueInRange(referenceRange);
    if (this._currentWordPattern) {
      const match = referenceValue.match(this._currentWordPattern);
      const matchLength = match ? match[0].length : 0;
      if (matchLength !== referenceValue.length) {
        return this.clearRanges();
      }
    }
    const edits = [];
    for (let i = 1, len = this._currentDecorations.length; i < len; i++) {
      const mirrorRange = this._currentDecorations.getRange(i);
      if (!mirrorRange) {
        continue;
      }
      if (mirrorRange.startLineNumber !== mirrorRange.endLineNumber) {
        edits.push({
          range: mirrorRange,
          text: referenceValue
        });
      } else {
        let oldValue = model.getValueInRange(mirrorRange);
        let newValue = referenceValue;
        let rangeStartColumn = mirrorRange.startColumn;
        let rangeEndColumn = mirrorRange.endColumn;
        const commonPrefixLength2 = commonPrefixLength(oldValue, newValue);
        rangeStartColumn += commonPrefixLength2;
        oldValue = oldValue.substr(commonPrefixLength2);
        newValue = newValue.substr(commonPrefixLength2);
        const commonSuffixLength2 = commonSuffixLength(oldValue, newValue);
        rangeEndColumn -= commonSuffixLength2;
        oldValue = oldValue.substr(0, oldValue.length - commonSuffixLength2);
        newValue = newValue.substr(0, newValue.length - commonSuffixLength2);
        if (rangeStartColumn !== rangeEndColumn || newValue.length !== 0) {
          edits.push({
            range: new Range(mirrorRange.startLineNumber, rangeStartColumn, mirrorRange.endLineNumber, rangeEndColumn),
            text: newValue
          });
        }
      }
    }
    if (edits.length === 0) {
      return;
    }
    try {
      this._editor.popUndoStop();
      this._ignoreChangeEvent = true;
      const prevEditOperationType = this._editor._getViewModel().getPrevEditOperationType();
      this._editor.executeEdits("linkedEditing", edits);
      this._editor._getViewModel().setPrevEditOperationType(prevEditOperationType);
    } finally {
      this._ignoreChangeEvent = false;
    }
  }
  dispose() {
    this.clearRanges();
    super.dispose();
  }
  clearRanges() {
    this._visibleContextKey.set(false);
    this._currentDecorations.clear();
    if (this._currentRequest) {
      this._currentRequest.cancel();
      this._currentRequest = null;
      this._currentRequestPosition = null;
    }
  }
  get currentUpdateTriggerPromise() {
    return this._rangeUpdateTriggerPromise || Promise.resolve();
  }
  get currentSyncTriggerPromise() {
    return this._rangeSyncTriggerPromise || Promise.resolve();
  }
  updateRanges(force = false) {
    return __awaiter24(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        this.clearRanges();
        return;
      }
      const position = this._editor.getPosition();
      if (!this._enabled && !force || this._editor.getSelections().length > 1) {
        this.clearRanges();
        return;
      }
      const model = this._editor.getModel();
      const modelVersionId = model.getVersionId();
      if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
        if (position.equals(this._currentRequestPosition)) {
          return;
        }
        if (this._currentDecorations.length > 0) {
          const range = this._currentDecorations.getRange(0);
          if (range && range.containsPosition(position)) {
            return;
          }
        }
      }
      this.clearRanges();
      this._currentRequestPosition = position;
      this._currentRequestModelVersion = modelVersionId;
      const request = createCancelablePromise((token) => __awaiter24(this, void 0, void 0, function* () {
        try {
          const sw = new StopWatch(false);
          const response = yield getLinkedEditingRanges(this._providers, model, position, token);
          this._debounceInformation.update(model, sw.elapsed());
          if (request !== this._currentRequest) {
            return;
          }
          this._currentRequest = null;
          if (modelVersionId !== model.getVersionId()) {
            return;
          }
          let ranges = [];
          if (response === null || response === void 0 ? void 0 : response.ranges) {
            ranges = response.ranges;
          }
          this._currentWordPattern = (response === null || response === void 0 ? void 0 : response.wordPattern) || this._languageWordPattern;
          let foundReferenceRange = false;
          for (let i = 0, len = ranges.length; i < len; i++) {
            if (Range.containsPosition(ranges[i], position)) {
              foundReferenceRange = true;
              if (i !== 0) {
                const referenceRange = ranges[i];
                ranges.splice(i, 1);
                ranges.unshift(referenceRange);
              }
              break;
            }
          }
          if (!foundReferenceRange) {
            this.clearRanges();
            return;
          }
          const decorations = ranges.map((range) => ({ range, options: LinkedEditingContribution_1.DECORATION }));
          this._visibleContextKey.set(true);
          this._currentDecorations.set(decorations);
          this._syncRangesToken++;
        } catch (err) {
          if (!isCancellationError(err)) {
            onUnexpectedError(err);
          }
          if (this._currentRequest === request || !this._currentRequest) {
            this.clearRanges();
          }
        }
      }));
      this._currentRequest = request;
      return request;
    });
  }
  // for testing
  setDebounceDuration(timeInMS) {
    this._debounceDuration = timeInMS;
  }
};
LinkedEditingContribution.ID = "editor.contrib.linkedEditing";
LinkedEditingContribution.DECORATION = ModelDecorationOptions.register({
  description: "linked-editing",
  stickiness: 0,
  className: DECORATION_CLASS_NAME
});
LinkedEditingContribution = LinkedEditingContribution_1 = __decorate26([
  __param26(1, IContextKeyService),
  __param26(2, ILanguageFeaturesService),
  __param26(3, ILanguageConfigurationService),
  __param26(4, ILanguageFeatureDebounceService)
], LinkedEditingContribution);
var LinkedEditingAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.linkedEditing",
      label: localize("linkedEditing.label", "Start Linked Editing"),
      alias: "Start Linked Editing",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(_accessor, editor2) {
    const controller = LinkedEditingContribution.get(editor2);
    if (controller) {
      return Promise.resolve(controller.updateRanges(true));
    }
    return Promise.resolve();
  }
};
var LinkedEditingCommand = EditorCommand.bindToContribution(LinkedEditingContribution.get);
registerEditorCommand(new LinkedEditingCommand({
  id: "cancelLinkedEditingInput",
  precondition: CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE,
  handler: (x) => x.clearRanges(),
  kbOpts: {
    kbExpr: EditorContextKeys.editorTextFocus,
    weight: 100 + 99,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
function getLinkedEditingRanges(providers, model, position, token) {
  const orderedByScore = providers.ordered(model);
  return first(orderedByScore.map((provider) => () => __awaiter24(this, void 0, void 0, function* () {
    try {
      return yield provider.provideLinkedEditingRanges(model, position, token);
    } catch (e) {
      onUnexpectedExternalError(e);
      return void 0;
    }
  })), (result) => !!result && isNonEmptyArray(result === null || result === void 0 ? void 0 : result.ranges));
}
var editorLinkedEditingBackground = registerColor("editor.linkedEditingBackground", { dark: Color.fromHex("#f00").transparent(0.3), light: Color.fromHex("#f00").transparent(0.3), hcDark: Color.fromHex("#f00").transparent(0.3), hcLight: Color.white }, localize("editorLinkedEditingBackground", "Background color when the editor auto renames on type."));
registerModelAndPositionCommand("_executeLinkedEditingProvider", (_accessor, model, position) => {
  const { linkedEditingRangeProvider } = _accessor.get(ILanguageFeaturesService);
  return getLinkedEditingRanges(linkedEditingRangeProvider, model, position, CancellationToken.None);
});
registerEditorContribution(
  LinkedEditingContribution.ID,
  LinkedEditingContribution,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(LinkedEditingAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.js
init_async();
init_cancellation();
init_errors();
init_htmlContent();
init_lifecycle();
init_network();
init_platform();
init_resources();
init_stopwatch();
init_uri();
init_editorExtensions();
init_textModel();
init_languageFeatureDebounce();
init_languageFeatures();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/getLinks.js
init_arrays();
init_cancellation();
init_errors();
init_lifecycle();
init_types();
init_uri();
init_range();
init_model2();
init_commands();
init_languageFeatures();
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Link2 = class {
  constructor(link, provider) {
    this._link = link;
    this._provider = provider;
  }
  toJSON() {
    return {
      range: this.range,
      url: this.url,
      tooltip: this.tooltip
    };
  }
  get range() {
    return this._link.range;
  }
  get url() {
    return this._link.url;
  }
  get tooltip() {
    return this._link.tooltip;
  }
  resolve(token) {
    return __awaiter25(this, void 0, void 0, function* () {
      if (this._link.url) {
        return this._link.url;
      }
      if (typeof this._provider.resolveLink === "function") {
        return Promise.resolve(this._provider.resolveLink(this._link, token)).then((value) => {
          this._link = value || this._link;
          if (this._link.url) {
            return this.resolve(token);
          }
          return Promise.reject(new Error("missing"));
        });
      }
      return Promise.reject(new Error("missing"));
    });
  }
};
var LinksList = class _LinksList {
  constructor(tuples) {
    this._disposables = new DisposableStore();
    let links = [];
    for (const [list, provider] of tuples) {
      const newLinks = list.links.map((link) => new Link2(link, provider));
      links = _LinksList._union(links, newLinks);
      if (isDisposable(list)) {
        this._disposables.add(list);
      }
    }
    this.links = links;
  }
  dispose() {
    this._disposables.dispose();
    this.links.length = 0;
  }
  static _union(oldLinks, newLinks) {
    const result = [];
    let oldIndex;
    let oldLen;
    let newIndex;
    let newLen;
    for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen; ) {
      const oldLink = oldLinks[oldIndex];
      const newLink = newLinks[newIndex];
      if (Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {
        oldIndex++;
        continue;
      }
      const comparisonResult = Range.compareRangesUsingStarts(oldLink.range, newLink.range);
      if (comparisonResult < 0) {
        result.push(oldLink);
        oldIndex++;
      } else {
        result.push(newLink);
        newIndex++;
      }
    }
    for (; oldIndex < oldLen; oldIndex++) {
      result.push(oldLinks[oldIndex]);
    }
    for (; newIndex < newLen; newIndex++) {
      result.push(newLinks[newIndex]);
    }
    return result;
  }
};
function getLinks(providers, model, token) {
  const lists = [];
  const promises = providers.ordered(model).reverse().map((provider, i) => {
    return Promise.resolve(provider.provideLinks(model, token)).then((result) => {
      if (result) {
        lists[i] = [result, provider];
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then(() => {
    const result = new LinksList(coalesce(lists));
    if (!token.isCancellationRequested) {
      return result;
    }
    result.dispose();
    return new LinksList([]);
  });
}
CommandsRegistry.registerCommand("_executeLinkProvider", (accessor, ...args) => __awaiter25(void 0, void 0, void 0, function* () {
  let [uri, resolveCount] = args;
  assertType(uri instanceof URI);
  if (typeof resolveCount !== "number") {
    resolveCount = 0;
  }
  const { linkProvider } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return [];
  }
  const list = yield getLinks(linkProvider, model, CancellationToken.None);
  if (!list) {
    return [];
  }
  for (let i = 0; i < Math.min(resolveCount, list.links.length); i++) {
    yield list.links[i].resolve(CancellationToken.None);
  }
  const result = list.links.slice(0);
  list.dispose();
  return result;
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.js
init_nls();
init_opener();
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LinkDetector_1;
var LinkDetector = LinkDetector_1 = class LinkDetector2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(LinkDetector_1.ID);
  }
  constructor(editor2, openerService, notificationService, languageFeaturesService, languageFeatureDebounceService) {
    super();
    this.editor = editor2;
    this.openerService = openerService;
    this.notificationService = notificationService;
    this.languageFeaturesService = languageFeaturesService;
    this.providers = this.languageFeaturesService.linkProvider;
    this.debounceInformation = languageFeatureDebounceService.for(this.providers, "Links", { min: 1e3, max: 4e3 });
    this.computeLinks = this._register(new RunOnceScheduler(() => this.computeLinksNow(), 1e3));
    this.computePromise = null;
    this.activeLinksList = null;
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    const clickLinkGesture = this._register(new ClickLinkGesture(editor2));
    this._register(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this._onEditorMouseMove(mouseEvent, keyboardEvent);
    }));
    this._register(clickLinkGesture.onExecute((e) => {
      this.onEditorMouseUp(e);
    }));
    this._register(clickLinkGesture.onCancel((e) => {
      this.cleanUpActiveLinkDecoration();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (!e.hasChanged(
        69
        /* EditorOption.links */
      )) {
        return;
      }
      this.updateDecorations([]);
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      if (!this.editor.hasModel()) {
        return;
      }
      this.computeLinks.schedule(this.debounceInformation.get(this.editor.getModel()));
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor2.onDidChangeModelLanguage((e) => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(this.providers.onDidChange((e) => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this.computeLinks.schedule(0);
  }
  computeLinksNow() {
    return __awaiter26(this, void 0, void 0, function* () {
      if (!this.editor.hasModel() || !this.editor.getOption(
        69
        /* EditorOption.links */
      )) {
        return;
      }
      const model = this.editor.getModel();
      if (!this.providers.has(model)) {
        return;
      }
      if (this.activeLinksList) {
        this.activeLinksList.dispose();
        this.activeLinksList = null;
      }
      this.computePromise = createCancelablePromise((token) => getLinks(this.providers, model, token));
      try {
        const sw = new StopWatch(false);
        this.activeLinksList = yield this.computePromise;
        this.debounceInformation.update(model, sw.elapsed());
        if (model.isDisposed()) {
          return;
        }
        this.updateDecorations(this.activeLinksList.links);
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        this.computePromise = null;
      }
    });
  }
  updateDecorations(links) {
    const useMetaKey = this.editor.getOption(
      76
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    const oldDecorations = [];
    const keys = Object.keys(this.currentOccurrences);
    for (const decorationId of keys) {
      const occurence = this.currentOccurrences[decorationId];
      oldDecorations.push(occurence.decorationId);
    }
    const newDecorations = [];
    if (links) {
      for (const link of links) {
        newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));
      }
    }
    this.editor.changeDecorations((changeAccessor) => {
      const decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      for (let i = 0, len = decorations.length; i < len; i++) {
        const occurence = new LinkOccurrence(links[i], decorations[i]);
        this.currentOccurrences[occurence.decorationId] = occurence;
      }
    });
  }
  _onEditorMouseMove(mouseEvent, withKey) {
    const useMetaKey = this.editor.getOption(
      76
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.isEnabled(mouseEvent, withKey)) {
      this.cleanUpActiveLinkDecoration();
      const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.activate(changeAccessor, useMetaKey);
          this.activeLinkDecorationId = occurrence.decorationId;
        });
      }
    } else {
      this.cleanUpActiveLinkDecoration();
    }
  }
  cleanUpActiveLinkDecoration() {
    const useMetaKey = this.editor.getOption(
      76
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.activeLinkDecorationId) {
      const occurrence = this.currentOccurrences[this.activeLinkDecorationId];
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.deactivate(changeAccessor, useMetaKey);
        });
      }
      this.activeLinkDecorationId = null;
    }
  }
  onEditorMouseUp(mouseEvent) {
    if (!this.isEnabled(mouseEvent)) {
      return;
    }
    const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
    if (!occurrence) {
      return;
    }
    this.openLinkOccurrence(
      occurrence,
      mouseEvent.hasSideBySideModifier,
      true
      /* from user gesture */
    );
  }
  openLinkOccurrence(occurrence, openToSide, fromUserGesture = false) {
    if (!this.openerService) {
      return;
    }
    const { link } = occurrence;
    link.resolve(CancellationToken.None).then((uri) => {
      if (typeof uri === "string" && this.editor.hasModel()) {
        const modelUri = this.editor.getModel().uri;
        if (modelUri.scheme === Schemas.file && uri.startsWith(`${Schemas.file}:`)) {
          const parsedUri = URI.parse(uri);
          if (parsedUri.scheme === Schemas.file) {
            const fsPath = originalFSPath(parsedUri);
            let relativePath2 = null;
            if (fsPath.startsWith("/./")) {
              relativePath2 = `.${fsPath.substr(1)}`;
            } else if (fsPath.startsWith("//./")) {
              relativePath2 = `.${fsPath.substr(2)}`;
            }
            if (relativePath2) {
              uri = joinPath(modelUri, relativePath2);
            }
          }
        }
      }
      return this.openerService.open(uri, { openToSide, fromUserGesture, allowContributedOpeners: true, allowCommands: true, fromWorkspace: true });
    }, (err) => {
      const messageOrError = err instanceof Error ? err.message : err;
      if (messageOrError === "invalid") {
        this.notificationService.warn(localize("invalid.url", "Failed to open this link because it is not well-formed: {0}", link.url.toString()));
      } else if (messageOrError === "missing") {
        this.notificationService.warn(localize("missing.url", "Failed to open this link because its target is missing."));
      } else {
        onUnexpectedError(err);
      }
    });
  }
  getLinkOccurrence(position) {
    if (!this.editor.hasModel() || !position) {
      return null;
    }
    const decorations = this.editor.getModel().getDecorationsInRange({
      startLineNumber: position.lineNumber,
      startColumn: position.column,
      endLineNumber: position.lineNumber,
      endColumn: position.column
    }, 0, true);
    for (const decoration2 of decorations) {
      const currentOccurrence = this.currentOccurrences[decoration2.id];
      if (currentOccurrence) {
        return currentOccurrence;
      }
    }
    return null;
  }
  isEnabled(mouseEvent, withKey) {
    return Boolean(mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || withKey && withKey.keyCodeIsTriggerKey));
  }
  stop() {
    var _a;
    this.computeLinks.cancel();
    if (this.activeLinksList) {
      (_a = this.activeLinksList) === null || _a === void 0 ? void 0 : _a.dispose();
      this.activeLinksList = null;
    }
    if (this.computePromise) {
      this.computePromise.cancel();
      this.computePromise = null;
    }
  }
  dispose() {
    super.dispose();
    this.stop();
  }
};
LinkDetector.ID = "editor.linkDetector";
LinkDetector = LinkDetector_1 = __decorate27([
  __param27(1, IOpenerService),
  __param27(2, INotificationService),
  __param27(3, ILanguageFeaturesService),
  __param27(4, ILanguageFeatureDebounceService)
], LinkDetector);
var decoration = {
  general: ModelDecorationOptions.register({
    description: "detected-link",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link"
  }),
  active: ModelDecorationOptions.register({
    description: "detected-link-active",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link-active"
  })
};
var LinkOccurrence = class _LinkOccurrence {
  static decoration(link, useMetaKey) {
    return {
      range: link.range,
      options: _LinkOccurrence._getOptions(link, useMetaKey, false)
    };
  }
  static _getOptions(link, useMetaKey, isActive) {
    const options = Object.assign({}, isActive ? decoration.active : decoration.general);
    options.hoverMessage = getHoverMessage(link, useMetaKey);
    return options;
  }
  constructor(link, decorationId) {
    this.link = link;
    this.decorationId = decorationId;
  }
  activate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, _LinkOccurrence._getOptions(this.link, useMetaKey, true));
  }
  deactivate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, _LinkOccurrence._getOptions(this.link, useMetaKey, false));
  }
};
function getHoverMessage(link, useMetaKey) {
  const executeCmd = link.url && /^command:/i.test(link.url.toString());
  const label = link.tooltip ? link.tooltip : executeCmd ? localize("links.navigate.executeCmd", "Execute command") : localize("links.navigate.follow", "Follow link");
  const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
  if (link.url) {
    let nativeLabel = "";
    if (/^command:/i.test(link.url.toString())) {
      const match = link.url.toString().match(/^command:([^?#]+)/);
      if (match) {
        const commandId = match[1];
        nativeLabel = localize("tooltip.explanation", "Execute command {0}", commandId);
      }
    }
    const hoverMessage = new MarkdownString("", true).appendLink(link.url.toString(true).replace(/ /g, "%20"), label, nativeLabel).appendMarkdown(` (${kb})`);
    return hoverMessage;
  } else {
    return new MarkdownString().appendText(`${label} (${kb})`);
  }
}
var OpenLinkAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.openLink",
      label: localize("label", "Open Link"),
      alias: "Open Link",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const linkDetector = LinkDetector.get(editor2);
    if (!linkDetector) {
      return;
    }
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    for (const sel of selections) {
      const link = linkDetector.getLinkOccurrence(sel.getEndPosition());
      if (link) {
        linkDetector.openLinkOccurrence(link, false);
      }
    }
  }
};
registerEditorContribution(
  LinkDetector.ID,
  LinkDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(OpenLinkAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js
init_lifecycle();
init_editorExtensions();
var LongLinesHelper = class _LongLinesHelper extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_LongLinesHelper.ID);
  }
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._register(this._editor.onMouseDown((e) => {
      const stopRenderingLineAfter = this._editor.getOption(
        115
        /* EditorOption.stopRenderingLineAfter */
      );
      if (stopRenderingLineAfter >= 0 && e.target.type === 6 && e.target.position.column >= stopRenderingLineAfter) {
        this._editor.updateOptions({
          stopRenderingLineAfter: -1
        });
      }
    }));
  }
};
LongLinesHelper.ID = "editor.contrib.longLinesHelper";
registerEditorContribution(
  LongLinesHelper.ID,
  LongLinesHelper,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/browser/multicursor.js
init_aria();
init_async();
init_keyCodes();
init_lifecycle();
init_editorExtensions();
init_range();
init_selection();
init_editorContextKeys();
init_nls();
init_actions2();
init_contextkey();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/highlightDecorations.js
init_model();
init_textModel();
init_languages();
init_nls();
init_colorRegistry();
init_themeService();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/highlightDecorations.css";
var wordHighlightBackground = registerColor("editor.wordHighlightBackground", { dark: "#575757B8", light: "#57575740", hcDark: null, hcLight: null }, localize("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editor.wordHighlightStrongBackground", { dark: "#004972B8", light: "#0e639c40", hcDark: null, hcLight: null }, localize("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editor.wordHighlightTextBackground", { light: wordHighlightBackground, dark: wordHighlightBackground, hcDark: wordHighlightBackground, hcLight: wordHighlightBackground }, localize("wordHighlightText", "Background color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), true);
var wordHighlightBorder = registerColor("editor.wordHighlightBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable."));
registerColor("editor.wordHighlightStrongBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable."));
registerColor("editor.wordHighlightTextBorder", { light: wordHighlightBorder, dark: wordHighlightBorder, hcDark: wordHighlightBorder, hcLight: wordHighlightBorder }, localize("wordHighlightTextBorder", "Border color of a textual occurrence for a symbol."));
var overviewRulerWordHighlightForeground = registerColor("editorOverviewRuler.wordHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hcDark: "#A0A0A0CC", hcLight: "#A0A0A0CC" }, localize("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerWordHighlightStrongForeground = registerColor("editorOverviewRuler.wordHighlightStrongForeground", { dark: "#C0A0C0CC", light: "#C0A0C0CC", hcDark: "#C0A0C0CC", hcLight: "#C0A0C0CC" }, localize("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerWordHighlightTextForeground = registerColor("editorOverviewRuler.wordHighlightTextForeground", { dark: overviewRulerSelectionHighlightForeground, light: overviewRulerSelectionHighlightForeground, hcDark: overviewRulerSelectionHighlightForeground, hcLight: overviewRulerSelectionHighlightForeground }, localize("overviewRulerWordHighlightTextForeground", "Overview ruler marker color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), true);
var _WRITE_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight-strong",
  stickiness: 1,
  className: "wordHighlightStrong",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightStrongForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
var _TEXT_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight-text",
  stickiness: 1,
  className: "wordHighlightText",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightTextForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
var _SELECTION_HIGHLIGHT_OPTIONS = ModelDecorationOptions.register({
  description: "selection-highlight-overview",
  stickiness: 1,
  className: "selectionHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerSelectionHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
var _SELECTION_HIGHLIGHT_OPTIONS_NO_OVERVIEW = ModelDecorationOptions.register({
  description: "selection-highlight",
  stickiness: 1,
  className: "selectionHighlight"
});
var _REGULAR_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight",
  stickiness: 1,
  className: "wordHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
function getHighlightDecorationOptions(kind) {
  if (kind === DocumentHighlightKind.Write) {
    return _WRITE_OPTIONS;
  } else if (kind === DocumentHighlightKind.Text) {
    return _TEXT_OPTIONS;
  } else {
    return _REGULAR_OPTIONS;
  }
}
function getSelectionHighlightDecorationOptions(hasSemanticHighlights) {
  return hasSemanticHighlights ? _SELECTION_HIGHLIGHT_OPTIONS_NO_OVERVIEW : _SELECTION_HIGHLIGHT_OPTIONS;
}
registerThemingParticipant((theme, collector) => {
  const selectionHighlight = theme.getColor(editorSelectionHighlight);
  if (selectionHighlight) {
    collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/browser/multicursor.js
init_instantiation();
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SelectionHighlighter_1;
function announceCursorChange(previousCursorState, cursorState) {
  const cursorDiff = cursorState.filter((cs) => !previousCursorState.find((pcs) => pcs.equals(cs)));
  if (cursorDiff.length >= 1) {
    const cursorPositions = cursorDiff.map((cs) => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(", ");
    const msg = cursorDiff.length === 1 ? localize("cursorAdded", "Cursor added: {0}", cursorPositions) : localize("cursorsAdded", "Cursors added: {0}", cursorPositions);
    status(msg);
  }
}
var InsertCursorAbove = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAbove",
      label: localize("mutlicursor.insertAbove", "Add Cursor Above"),
      alias: "Add Cursor Above",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 16,
        linux: {
          primary: 1024 | 512 | 16,
          secondary: [
            2048 | 1024 | 16
            /* KeyCode.UpArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorAbove", comment: ["&& denotes a mnemonic"] }, "&&Add Cursor Above"),
        order: 2
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorUp(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealTopMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorBelow = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorBelow",
      label: localize("mutlicursor.insertBelow", "Add Cursor Below"),
      alias: "Add Cursor Below",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 18,
        linux: {
          primary: 1024 | 512 | 18,
          secondary: [
            2048 | 1024 | 18
            /* KeyCode.DownArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorBelow", comment: ["&& denotes a mnemonic"] }, "A&&dd Cursor Below"),
        order: 3
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorDown(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealBottomMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorAtEndOfEachLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAtEndOfEachLineSelected",
      label: localize("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
      alias: "Add Cursors to Line Ends",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 39,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorAtEndOfEachLineSelected", comment: ["&& denotes a mnemonic"] }, "Add C&&ursors to Line Ends"),
        order: 4
      }
    });
  }
  getCursorsForSelection(selection, model, result) {
    if (selection.isEmpty()) {
      return;
    }
    for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {
      const currentLineMaxColumn = model.getLineMaxColumn(i);
      result.push(new Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));
    }
    if (selection.endColumn > 1) {
      result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));
    }
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    const newSelections = [];
    selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorAtEndOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToBottom",
      label: localize("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
      alias: "Add Cursors To Bottom",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    const lineCount = editor2.getModel().getLineCount();
    const newSelections = [];
    for (let i = selections[0].startLineNumber; i <= lineCount; i++) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorAtTopOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToTop",
      label: localize("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
      alias: "Add Cursors To Top",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    const newSelections = [];
    for (let i = selections[0].startLineNumber; i >= 1; i--) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var MultiCursorSessionResult = class {
  constructor(selections, revealRange, revealScrollType) {
    this.selections = selections;
    this.revealRange = revealRange;
    this.revealScrollType = revealScrollType;
  }
};
var MultiCursorSession = class _MultiCursorSession {
  static create(editor2, findController) {
    if (!editor2.hasModel()) {
      return null;
    }
    const findState = findController.getState();
    if (!editor2.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {
      return new _MultiCursorSession(editor2, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);
    }
    let isDisconnectedFromFindController = false;
    let wholeWord;
    let matchCase;
    const selections = editor2.getSelections();
    if (selections.length === 1 && selections[0].isEmpty()) {
      isDisconnectedFromFindController = true;
      wholeWord = true;
      matchCase = true;
    } else {
      wholeWord = findState.wholeWord;
      matchCase = findState.matchCase;
    }
    const s = editor2.getSelection();
    let searchText;
    let currentMatch = null;
    if (s.isEmpty()) {
      const word = editor2.getConfiguredWordAtPosition(s.getStartPosition());
      if (!word) {
        return null;
      }
      searchText = word.word;
      currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
    } else {
      searchText = editor2.getModel().getValueInRange(s).replace(/\r\n/g, "\n");
    }
    return new _MultiCursorSession(editor2, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);
  }
  constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {
    this._editor = _editor;
    this.findController = findController;
    this.isDisconnectedFromFindController = isDisconnectedFromFindController;
    this.searchText = searchText;
    this.wholeWord = wholeWord;
    this.matchCase = matchCase;
    this.currentMatch = currentMatch;
  }
  addSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.concat(nextMatch),
      nextMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.slice(0, allSelections.length - 1).concat(nextMatch),
      nextMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  _getNextMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, false);
    if (!nextMatch) {
      return null;
    }
    return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
  }
  addSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.concat(previousMatch),
      previousMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.slice(0, allSelections.length - 1).concat(previousMatch),
      previousMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  _getPreviousMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, false);
    if (!previousMatch) {
      return null;
    }
    return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
  }
  selectAll(searchScope) {
    if (!this._editor.hasModel()) {
      return [];
    }
    this.findController.highlightFindOptions();
    const editorModel = this._editor.getModel();
    if (searchScope) {
      return editorModel.findMatches(
        this.searchText,
        searchScope,
        false,
        this.matchCase,
        this.wholeWord ? this._editor.getOption(
          128
          /* EditorOption.wordSeparators */
        ) : null,
        false,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      );
    }
    return editorModel.findMatches(
      this.searchText,
      true,
      false,
      this.matchCase,
      this.wholeWord ? this._editor.getOption(
        128
        /* EditorOption.wordSeparators */
      ) : null,
      false,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
  }
};
var MultiCursorSelectionController = class _MultiCursorSelectionController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_MultiCursorSelectionController.ID);
  }
  constructor(editor2) {
    super();
    this._sessionDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._ignoreSelectionChange = false;
    this._session = null;
  }
  dispose() {
    this._endSession();
    super.dispose();
  }
  _beginSessionIfNeeded(findController) {
    if (!this._session) {
      const session = MultiCursorSession.create(this._editor, findController);
      if (!session) {
        return;
      }
      this._session = session;
      const newState = { searchString: this._session.searchText };
      if (this._session.isDisconnectedFromFindController) {
        newState.wholeWordOverride = 1;
        newState.matchCaseOverride = 1;
        newState.isRegexOverride = 2;
      }
      findController.getState().change(newState, false);
      this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {
        if (this._ignoreSelectionChange) {
          return;
        }
        this._endSession();
      }));
      this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
        this._endSession();
      }));
      this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {
        if (e.matchCase || e.wholeWord) {
          this._endSession();
        }
      }));
    }
  }
  _endSession() {
    this._sessionDispose.clear();
    if (this._session && this._session.isDisconnectedFromFindController) {
      const newState = {
        wholeWordOverride: 0,
        matchCaseOverride: 0,
        isRegexOverride: 0
      };
      this._session.findController.getState().change(newState, false);
    }
    this._session = null;
  }
  _setSelections(selections) {
    this._ignoreSelectionChange = true;
    this._editor.setSelections(selections);
    this._ignoreSelectionChange = false;
  }
  _expandEmptyToWord(model, selection) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());
    if (!word) {
      return selection;
    }
    return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
  }
  _applySessionResult(result) {
    if (!result) {
      return;
    }
    this._setSelections(result.selections);
    if (result.revealRange) {
      this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);
    }
  }
  getSession(findController) {
    return this._session;
  }
  addSelectionToNextFindMatch(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._session) {
      const allSelections = this._editor.getSelections();
      if (allSelections.length > 1) {
        const findState = findController.getState();
        const matchCase = findState.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          const model = this._editor.getModel();
          const resultingSelections = [];
          for (let i = 0, len = allSelections.length; i < len; i++) {
            resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);
          }
          this._editor.setSelections(resultingSelections);
          return;
        }
      }
    }
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToNextFindMatch());
    }
  }
  addSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
    }
  }
  moveSelectionToNextFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToNextFindMatch());
    }
  }
  moveSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
    }
  }
  selectAll(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    let matches = null;
    const findState = findController.getState();
    if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {
      const editorModel = this._editor.getModel();
      if (findState.searchScope) {
        matches = editorModel.findMatches(
          findState.searchString,
          findState.searchScope,
          findState.isRegex,
          findState.matchCase,
          findState.wholeWord ? this._editor.getOption(
            128
            /* EditorOption.wordSeparators */
          ) : null,
          false,
          1073741824
          /* Constants.MAX_SAFE_SMALL_INTEGER */
        );
      } else {
        matches = editorModel.findMatches(
          findState.searchString,
          true,
          findState.isRegex,
          findState.matchCase,
          findState.wholeWord ? this._editor.getOption(
            128
            /* EditorOption.wordSeparators */
          ) : null,
          false,
          1073741824
          /* Constants.MAX_SAFE_SMALL_INTEGER */
        );
      }
    } else {
      this._beginSessionIfNeeded(findController);
      if (!this._session) {
        return;
      }
      matches = this._session.selectAll(findState.searchScope);
    }
    if (matches.length > 0) {
      const editorSelection = this._editor.getSelection();
      for (let i = 0, len = matches.length; i < len; i++) {
        const match = matches[i];
        const intersection = match.range.intersectRanges(editorSelection);
        if (intersection) {
          matches[i] = matches[0];
          matches[0] = match;
          break;
        }
      }
      this._setSelections(matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
    }
  }
  selectAllUsingSelections(selections) {
    if (selections.length > 0) {
      this._setSelections(selections);
    }
  }
};
MultiCursorSelectionController.ID = "editor.contrib.multiCursorController";
var MultiCursorSelectionControllerAction = class extends EditorAction {
  run(accessor, editor2) {
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel) {
      const previousCursorState = viewModel.getCursorStates();
      const findController = CommonFindController.get(editor2);
      if (findController) {
        this._run(multiCursorController, findController);
      } else {
        const newFindController = accessor.get(IInstantiationService).createInstance(CommonFindController, editor2);
        this._run(multiCursorController, newFindController);
        newFindController.dispose();
      }
      announceCursorChange(previousCursorState, viewModel.getCursorStates());
    }
  }
};
var AddSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToNextFindMatch",
      label: localize("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
      alias: "Add Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 34,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miAddSelectionToNextFindMatch", comment: ["&& denotes a mnemonic"] }, "Add &&Next Occurrence"),
        order: 5
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToNextFindMatch(findController);
  }
};
var AddSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToPreviousFindMatch",
      label: localize("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
      alias: "Add Selection To Previous Find Match",
      precondition: void 0,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miAddSelectionToPreviousFindMatch", comment: ["&& denotes a mnemonic"] }, "Add P&&revious Occurrence"),
        order: 6
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToPreviousFindMatch(findController);
  }
};
var MoveSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToNextFindMatch",
      label: localize("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
      alias: "Move Last Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: KeyChord(
          2048 | 41,
          2048 | 34
          /* KeyCode.KeyD */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToNextFindMatch(findController);
  }
};
var MoveSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToPreviousFindMatch",
      label: localize("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
      alias: "Move Last Selection To Previous Find Match",
      precondition: void 0
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToPreviousFindMatch(findController);
  }
};
var SelectHighlightsAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.selectHighlights",
      label: localize("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
      alias: "Select All Occurrences of Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 42,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miSelectHighlights", comment: ["&& denotes a mnemonic"] }, "Select All &&Occurrences"),
        order: 7
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
var CompatChangeAll = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.changeAll",
      label: localize("changeAll.label", "Change All Occurrences"),
      alias: "Change All Occurrences",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.2
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
var SelectionHighlighterState = class {
  constructor(_model, _searchText, _matchCase, _wordSeparators, prevState) {
    this._model = _model;
    this._searchText = _searchText;
    this._matchCase = _matchCase;
    this._wordSeparators = _wordSeparators;
    this._modelVersionId = this._model.getVersionId();
    this._cachedFindMatches = null;
    if (prevState && this._model === prevState._model && this._searchText === prevState._searchText && this._matchCase === prevState._matchCase && this._wordSeparators === prevState._wordSeparators && this._modelVersionId === prevState._modelVersionId) {
      this._cachedFindMatches = prevState._cachedFindMatches;
    }
  }
  findMatches() {
    if (this._cachedFindMatches === null) {
      this._cachedFindMatches = this._model.findMatches(this._searchText, true, false, this._matchCase, this._wordSeparators, false).map((m) => m.range);
      this._cachedFindMatches.sort(Range.compareRangesUsingStarts);
    }
    return this._cachedFindMatches;
  }
};
var SelectionHighlighter = SelectionHighlighter_1 = class SelectionHighlighter2 extends Disposable {
  constructor(editor2, _languageFeaturesService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
    this.editor = editor2;
    this._isEnabled = editor2.getOption(
      106
      /* EditorOption.selectionHighlight */
    );
    this._decorations = editor2.createDecorationsCollection();
    this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));
    this.state = null;
    this._register(editor2.onDidChangeConfiguration((e) => {
      this._isEnabled = editor2.getOption(
        106
        /* EditorOption.selectionHighlight */
      );
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (!this._isEnabled) {
        return;
      }
      if (e.selection.isEmpty()) {
        if (e.reason === 3) {
          if (this.state) {
            this._setState(null);
          }
          this.updateSoon.schedule();
        } else {
          this._setState(null);
        }
      } else {
        this._update();
      }
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._setState(null);
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      if (this._isEnabled) {
        this.updateSoon.schedule();
      }
    }));
    const findController = CommonFindController.get(editor2);
    if (findController) {
      this._register(findController.getState().onFindReplaceStateChange((e) => {
        this._update();
      }));
    }
    this.updateSoon.schedule();
  }
  _update() {
    this._setState(SelectionHighlighter_1._createState(this.state, this._isEnabled, this.editor));
  }
  static _createState(oldState, isEnabled, editor2) {
    if (!isEnabled) {
      return null;
    }
    if (!editor2.hasModel()) {
      return null;
    }
    const s = editor2.getSelection();
    if (s.startLineNumber !== s.endLineNumber) {
      return null;
    }
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return null;
    }
    const findController = CommonFindController.get(editor2);
    if (!findController) {
      return null;
    }
    let r = multiCursorController.getSession(findController);
    if (!r) {
      const allSelections = editor2.getSelections();
      if (allSelections.length > 1) {
        const findState2 = findController.getState();
        const matchCase = findState2.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(editor2.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          return null;
        }
      }
      r = MultiCursorSession.create(editor2, findController);
    }
    if (!r) {
      return null;
    }
    if (r.currentMatch) {
      return null;
    }
    if (/^[ \t]+$/.test(r.searchText)) {
      return null;
    }
    if (r.searchText.length > 200) {
      return null;
    }
    const findState = findController.getState();
    const caseSensitive = findState.matchCase;
    if (findState.isRevealed) {
      let findStateSearchString = findState.searchString;
      if (!caseSensitive) {
        findStateSearchString = findStateSearchString.toLowerCase();
      }
      let mySearchString = r.searchText;
      if (!caseSensitive) {
        mySearchString = mySearchString.toLowerCase();
      }
      if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {
        return null;
      }
    }
    return new SelectionHighlighterState(editor2.getModel(), r.searchText, r.matchCase, r.wholeWord ? editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, oldState);
  }
  _setState(newState) {
    this.state = newState;
    if (!this.state) {
      this._decorations.clear();
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const model = this.editor.getModel();
    if (model.isTooLargeForTokenization()) {
      return;
    }
    const allMatches = this.state.findMatches();
    const selections = this.editor.getSelections();
    selections.sort(Range.compareRangesUsingStarts);
    const matches = [];
    for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len; ) {
      const match = allMatches[i];
      if (j >= lenJ) {
        matches.push(match);
        i++;
      } else {
        const cmp = Range.compareRangesUsingStarts(match, selections[j]);
        if (cmp < 0) {
          if (selections[j].isEmpty() || !Range.areIntersecting(match, selections[j])) {
            matches.push(match);
          }
          i++;
        } else if (cmp > 0) {
          j++;
        } else {
          i++;
          j++;
        }
      }
    }
    const hasSemanticHighlights = this._languageFeaturesService.documentHighlightProvider.has(model) && this.editor.getOption(
      79
      /* EditorOption.occurrencesHighlight */
    );
    const decorations = matches.map((r) => {
      return {
        range: r,
        options: getSelectionHighlightDecorationOptions(hasSemanticHighlights)
      };
    });
    this._decorations.set(decorations);
  }
  dispose() {
    this._setState(null);
    super.dispose();
  }
};
SelectionHighlighter.ID = "editor.contrib.selectionHighlighter";
SelectionHighlighter = SelectionHighlighter_1 = __decorate28([
  __param28(1, ILanguageFeaturesService)
], SelectionHighlighter);
function modelRangesContainSameText(model, ranges, matchCase) {
  const selectedText = getValueInRange(model, ranges[0], !matchCase);
  for (let i = 1, len = ranges.length; i < len; i++) {
    const range = ranges[i];
    if (range.isEmpty()) {
      return false;
    }
    const thisSelectedText = getValueInRange(model, range, !matchCase);
    if (selectedText !== thisSelectedText) {
      return false;
    }
  }
  return true;
}
function getValueInRange(model, range, toLowerCase) {
  const text = model.getValueInRange(range);
  return toLowerCase ? text.toLowerCase() : text;
}
var FocusNextCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.focusNextCursor",
      label: localize("mutlicursor.focusNextCursor", "Focus Next Cursor"),
      description: {
        description: localize("mutlicursor.focusNextCursor.description", "Focuses the next cursor"),
        args: []
      },
      alias: "Focus Next Cursor",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = Array.from(viewModel.getCursorStates());
    const firstCursor = previousCursorState.shift();
    if (!firstCursor) {
      return;
    }
    previousCursorState.push(firstCursor);
    viewModel.setCursorStates(args.source, 3, previousCursorState);
    viewModel.revealPrimaryCursor(args.source, true);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var FocusPreviousCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.focusPreviousCursor",
      label: localize("mutlicursor.focusPreviousCursor", "Focus Previous Cursor"),
      description: {
        description: localize("mutlicursor.focusPreviousCursor.description", "Focuses the previous cursor"),
        args: []
      },
      alias: "Focus Previous Cursor",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = Array.from(viewModel.getCursorStates());
    const firstCursor = previousCursorState.pop();
    if (!firstCursor) {
      return;
    }
    previousCursorState.unshift(firstCursor);
    viewModel.setCursorStates(args.source, 3, previousCursorState);
    viewModel.revealPrimaryCursor(args.source, true);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
registerEditorContribution(
  MultiCursorSelectionController.ID,
  MultiCursorSelectionController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorContribution(
  SelectionHighlighter.ID,
  SelectionHighlighter,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(InsertCursorAbove);
registerEditorAction(InsertCursorBelow);
registerEditorAction(InsertCursorAtEndOfEachLineSelected);
registerEditorAction(AddSelectionToNextFindMatchAction);
registerEditorAction(AddSelectionToPreviousFindMatchAction);
registerEditorAction(MoveSelectionToNextFindMatchAction);
registerEditorAction(MoveSelectionToPreviousFindMatchAction);
registerEditorAction(SelectHighlightsAction);
registerEditorAction(CompatChangeAll);
registerEditorAction(InsertCursorAtEndOfLineSelected);
registerEditorAction(InsertCursorAtTopOfLineSelected);
registerEditorAction(FocusNextCursor);
registerEditorAction(FocusPreviousCursor);

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
init_lazy();
init_lifecycle();
init_editorExtensions();
init_editorContextKeys();
init_languages();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js
init_async();
init_errors();
init_event();
init_lifecycle();
init_characterClassifier();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/provideSignatureHelp.js
init_cancellation();
init_errors();
init_types();
init_uri();
init_position();
init_languages();
init_languageFeatures();
init_resolverService();
init_commands();
init_contextkey();
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Context2 = {
  Visible: new RawContextKey("parameterHintsVisible", false),
  MultipleSignatures: new RawContextKey("parameterHintsMultipleSignatures", false)
};
function provideSignatureHelp(registry, model, position, context, token) {
  return __awaiter27(this, void 0, void 0, function* () {
    const supports = registry.ordered(model);
    for (const support of supports) {
      try {
        const result = yield support.provideSignatureHelp(model, position, token, context);
        if (result) {
          return result;
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }
    return void 0;
  });
}
CommandsRegistry.registerCommand("_executeSignatureHelpProvider", (accessor, ...args) => __awaiter27(void 0, void 0, void 0, function* () {
  const [uri, position, triggerCharacter] = args;
  assertType(URI.isUri(uri));
  assertType(Position.isIPosition(position));
  assertType(typeof triggerCharacter === "string" || !triggerCharacter);
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const ref = yield accessor.get(ITextModelService).createModelReference(uri);
  try {
    const result = yield provideSignatureHelp(languageFeaturesService.signatureHelpProvider, ref.object.textEditorModel, Position.lift(position), {
      triggerKind: SignatureHelpTriggerKind.Invoke,
      isRetrigger: false,
      triggerCharacter
    }, CancellationToken.None);
    if (!result) {
      return void 0;
    }
    setTimeout(() => result.dispose(), 0);
    return result.value;
  } finally {
    ref.dispose();
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ParameterHintState;
(function(ParameterHintState2) {
  ParameterHintState2.Default = {
    type: 0
    /* Type.Default */
  };
  class Pending {
    constructor(request, previouslyActiveHints) {
      this.request = request;
      this.previouslyActiveHints = previouslyActiveHints;
      this.type = 2;
    }
  }
  ParameterHintState2.Pending = Pending;
  class Active {
    constructor(hints) {
      this.hints = hints;
      this.type = 1;
    }
  }
  ParameterHintState2.Active = Active;
})(ParameterHintState || (ParameterHintState = {}));
var ParameterHintsModel = class _ParameterHintsModel extends Disposable {
  constructor(editor2, providers, delay = _ParameterHintsModel.DEFAULT_DELAY) {
    super();
    this._onChangedHints = this._register(new Emitter());
    this.onChangedHints = this._onChangedHints.event;
    this.triggerOnType = false;
    this._state = ParameterHintState.Default;
    this._pendingTriggers = [];
    this._lastSignatureHelpResult = this._register(new MutableDisposable());
    this.triggerChars = new CharacterSet();
    this.retriggerChars = new CharacterSet();
    this.triggerId = 0;
    this.editor = editor2;
    this.providers = providers;
    this.throttledDelayer = new Delayer(delay);
    this._register(this.editor.onDidBlurEditorWidget(() => this.cancel()));
    this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange()));
    this._register(this.editor.onDidChangeModel((e) => this.onModelChanged()));
    this._register(this.editor.onDidChangeModelLanguage((_) => this.onModelChanged()));
    this._register(this.editor.onDidChangeCursorSelection((e) => this.onCursorChange(e)));
    this._register(this.editor.onDidChangeModelContent((e) => this.onModelContentChange()));
    this._register(this.providers.onDidChange(this.onModelChanged, this));
    this._register(this.editor.onDidType((text) => this.onDidType(text)));
    this.onEditorConfigurationChange();
    this.onModelChanged();
  }
  get state() {
    return this._state;
  }
  set state(value) {
    if (this._state.type === 2) {
      this._state.request.cancel();
    }
    this._state = value;
  }
  cancel(silent = false) {
    this.state = ParameterHintState.Default;
    this.throttledDelayer.cancel();
    if (!silent) {
      this._onChangedHints.fire(void 0);
    }
  }
  trigger(context, delay) {
    const model = this.editor.getModel();
    if (!model || !this.providers.has(model)) {
      return;
    }
    const triggerId = ++this.triggerId;
    this._pendingTriggers.push(context);
    this.throttledDelayer.trigger(() => {
      return this.doTrigger(triggerId);
    }, delay).catch(onUnexpectedError);
  }
  next() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const last = activeSignature % length === length - 1;
    const cycle = this.editor.getOption(
      84
      /* EditorOption.parameterHints */
    ).cycle;
    if ((length < 2 || last) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(last && cycle ? 0 : activeSignature + 1);
  }
  previous() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const first2 = activeSignature === 0;
    const cycle = this.editor.getOption(
      84
      /* EditorOption.parameterHints */
    ).cycle;
    if ((length < 2 || first2) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(first2 && cycle ? length - 1 : activeSignature - 1);
  }
  updateActiveSignature(activeSignature) {
    if (this.state.type !== 1) {
      return;
    }
    this.state = new ParameterHintState.Active(Object.assign(Object.assign({}, this.state.hints), { activeSignature }));
    this._onChangedHints.fire(this.state.hints);
  }
  doTrigger(triggerId) {
    return __awaiter28(this, void 0, void 0, function* () {
      const isRetrigger = this.state.type === 1 || this.state.type === 2;
      const activeSignatureHelp = this.getLastActiveHints();
      this.cancel(true);
      if (this._pendingTriggers.length === 0) {
        return false;
      }
      const context = this._pendingTriggers.reduce(mergeTriggerContexts);
      this._pendingTriggers = [];
      const triggerContext = {
        triggerKind: context.triggerKind,
        triggerCharacter: context.triggerCharacter,
        isRetrigger,
        activeSignatureHelp
      };
      if (!this.editor.hasModel()) {
        return false;
      }
      const model = this.editor.getModel();
      const position = this.editor.getPosition();
      this.state = new ParameterHintState.Pending(createCancelablePromise((token) => provideSignatureHelp(this.providers, model, position, triggerContext, token)), activeSignatureHelp);
      try {
        const result = yield this.state.request;
        if (triggerId !== this.triggerId) {
          result === null || result === void 0 ? void 0 : result.dispose();
          return false;
        }
        if (!result || !result.value.signatures || result.value.signatures.length === 0) {
          result === null || result === void 0 ? void 0 : result.dispose();
          this._lastSignatureHelpResult.clear();
          this.cancel();
          return false;
        } else {
          this.state = new ParameterHintState.Active(result.value);
          this._lastSignatureHelpResult.value = result;
          this._onChangedHints.fire(this.state.hints);
          return true;
        }
      } catch (error) {
        if (triggerId === this.triggerId) {
          this.state = ParameterHintState.Default;
        }
        onUnexpectedError(error);
        return false;
      }
    });
  }
  getLastActiveHints() {
    switch (this.state.type) {
      case 1:
        return this.state.hints;
      case 2:
        return this.state.previouslyActiveHints;
      default:
        return void 0;
    }
  }
  get isTriggered() {
    return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
  }
  onModelChanged() {
    this.cancel();
    this.triggerChars.clear();
    this.retriggerChars.clear();
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    for (const support of this.providers.ordered(model)) {
      for (const ch of support.signatureHelpTriggerCharacters || []) {
        if (ch.length) {
          const charCode = ch.charCodeAt(0);
          this.triggerChars.add(charCode);
          this.retriggerChars.add(charCode);
        }
      }
      for (const ch of support.signatureHelpRetriggerCharacters || []) {
        if (ch.length) {
          this.retriggerChars.add(ch.charCodeAt(0));
        }
      }
    }
  }
  onDidType(text) {
    if (!this.triggerOnType) {
      return;
    }
    const lastCharIndex = text.length - 1;
    const triggerCharCode = text.charCodeAt(lastCharIndex);
    if (this.triggerChars.has(triggerCharCode) || this.isTriggered && this.retriggerChars.has(triggerCharCode)) {
      this.trigger({
        triggerKind: SignatureHelpTriggerKind.TriggerCharacter,
        triggerCharacter: text.charAt(lastCharIndex)
      });
    }
  }
  onCursorChange(e) {
    if (e.source === "mouse") {
      this.cancel();
    } else if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onModelContentChange() {
    if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onEditorConfigurationChange() {
    this.triggerOnType = this.editor.getOption(
      84
      /* EditorOption.parameterHints */
    ).enabled;
    if (!this.triggerOnType) {
      this.cancel();
    }
  }
  dispose() {
    this.cancel(true);
    super.dispose();
  }
};
ParameterHintsModel.DEFAULT_DELAY = 120;
function mergeTriggerContexts(previous, current) {
  switch (current.triggerKind) {
    case SignatureHelpTriggerKind.Invoke:
      return current;
    case SignatureHelpTriggerKind.ContentChange:
      return previous;
    case SignatureHelpTriggerKind.TriggerCharacter:
    default:
      return current;
  }
}

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
init_nls();
init_contextkey();
init_instantiation();

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.js
init_dom();
init_aria();
init_codicons();
init_event();
init_lifecycle();
init_strings();
init_types();
init_language();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.css";
init_nls();
init_contextkey();
init_opener();
init_colorRegistry();
init_themables();
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ParameterHintsWidget_1;
var $8 = $;
var parameterHintsNextIcon = registerIcon("parameter-hints-next", Codicon.chevronDown, localize("parameterHintsNextIcon", "Icon for show next parameter hint."));
var parameterHintsPreviousIcon = registerIcon("parameter-hints-previous", Codicon.chevronUp, localize("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
var ParameterHintsWidget = ParameterHintsWidget_1 = class ParameterHintsWidget2 extends Disposable {
  constructor(editor2, model, contextKeyService, openerService, languageService) {
    super();
    this.editor = editor2;
    this.model = model;
    this.renderDisposeables = this._register(new DisposableStore());
    this.visible = false;
    this.announcedLabel = null;
    this.allowEditorOverflow = true;
    this.markdownRenderer = this._register(new MarkdownRenderer({ editor: editor2 }, languageService, openerService));
    this.keyVisible = Context2.Visible.bindTo(contextKeyService);
    this.keyMultipleSignatures = Context2.MultipleSignatures.bindTo(contextKeyService);
  }
  createParameterHintDOMNodes() {
    const element = $8(".editor-widget.parameter-hints-widget");
    const wrapper = append(element, $8(".phwrapper"));
    wrapper.tabIndex = -1;
    const controls = append(wrapper, $8(".controls"));
    const previous = append(controls, $8(".button" + ThemeIcon.asCSSSelector(parameterHintsPreviousIcon)));
    const overloads = append(controls, $8(".overloads"));
    const next = append(controls, $8(".button" + ThemeIcon.asCSSSelector(parameterHintsNextIcon)));
    this._register(addDisposableListener(previous, "click", (e) => {
      EventHelper.stop(e);
      this.previous();
    }));
    this._register(addDisposableListener(next, "click", (e) => {
      EventHelper.stop(e);
      this.next();
    }));
    const body = $8(".body");
    const scrollbar = new DomScrollableElement(body, {
      alwaysConsumeMouseWheel: true
    });
    this._register(scrollbar);
    wrapper.appendChild(scrollbar.getDomNode());
    const signature = append(body, $8(".signature"));
    const docs = append(body, $8(".docs"));
    element.style.userSelect = "text";
    this.domNodes = {
      element,
      signature,
      overloads,
      docs,
      scrollbar
    };
    this.editor.addContentWidget(this);
    this.hide();
    this._register(this.editor.onDidChangeCursorSelection((e) => {
      if (this.visible) {
        this.editor.layoutContentWidget(this);
      }
    }));
    const updateFont = () => {
      if (!this.domNodes) {
        return;
      }
      const fontInfo = this.editor.getOption(
        49
        /* EditorOption.fontInfo */
      );
      this.domNodes.element.style.fontSize = `${fontInfo.fontSize}px`;
      this.domNodes.element.style.lineHeight = `${fontInfo.lineHeight / fontInfo.fontSize}`;
    };
    updateFont();
    this._register(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((e) => e.hasChanged(
      49
      /* EditorOption.fontInfo */
    )).on(updateFont, null));
    this._register(this.editor.onDidLayoutChange((e) => this.updateMaxHeight()));
    this.updateMaxHeight();
  }
  show() {
    if (this.visible) {
      return;
    }
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    this.keyVisible.set(true);
    this.visible = true;
    setTimeout(() => {
      var _a;
      (_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.element.classList.add("visible");
    }, 100);
    this.editor.layoutContentWidget(this);
  }
  hide() {
    var _a;
    this.renderDisposeables.clear();
    if (!this.visible) {
      return;
    }
    this.keyVisible.reset();
    this.visible = false;
    this.announcedLabel = null;
    (_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.element.classList.remove("visible");
    this.editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this.visible) {
      return {
        position: this.editor.getPosition(),
        preference: [
          1,
          2
          /* ContentWidgetPositionPreference.BELOW */
        ]
      };
    }
    return null;
  }
  render(hints) {
    var _a;
    this.renderDisposeables.clear();
    if (!this.domNodes) {
      return;
    }
    const multiple = hints.signatures.length > 1;
    this.domNodes.element.classList.toggle("multiple", multiple);
    this.keyMultipleSignatures.set(multiple);
    this.domNodes.signature.innerText = "";
    this.domNodes.docs.innerText = "";
    const signature = hints.signatures[hints.activeSignature];
    if (!signature) {
      return;
    }
    const code = append(this.domNodes.signature, $8(".code"));
    const fontInfo = this.editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    code.style.fontSize = `${fontInfo.fontSize}px`;
    code.style.fontFamily = fontInfo.fontFamily;
    const hasParameters = signature.parameters.length > 0;
    const activeParameterIndex = (_a = signature.activeParameter) !== null && _a !== void 0 ? _a : hints.activeParameter;
    if (!hasParameters) {
      const label = append(code, $8("span"));
      label.textContent = signature.label;
    } else {
      this.renderParameters(code, signature, activeParameterIndex);
    }
    const activeParameter = signature.parameters[activeParameterIndex];
    if (activeParameter === null || activeParameter === void 0 ? void 0 : activeParameter.documentation) {
      const documentation = $8("span.documentation");
      if (typeof activeParameter.documentation === "string") {
        documentation.textContent = activeParameter.documentation;
      } else {
        const renderedContents = this.renderMarkdownDocs(activeParameter.documentation);
        documentation.appendChild(renderedContents.element);
      }
      append(this.domNodes.docs, $8("p", {}, documentation));
    }
    if (signature.documentation === void 0) {
    } else if (typeof signature.documentation === "string") {
      append(this.domNodes.docs, $8("p", {}, signature.documentation));
    } else {
      const renderedContents = this.renderMarkdownDocs(signature.documentation);
      append(this.domNodes.docs, renderedContents.element);
    }
    const hasDocs = this.hasDocs(signature, activeParameter);
    this.domNodes.signature.classList.toggle("has-docs", hasDocs);
    this.domNodes.docs.classList.toggle("empty", !hasDocs);
    this.domNodes.overloads.textContent = String(hints.activeSignature + 1).padStart(hints.signatures.length.toString().length, "0") + "/" + hints.signatures.length;
    if (activeParameter) {
      let labelToAnnounce = "";
      const param = signature.parameters[activeParameterIndex];
      if (Array.isArray(param.label)) {
        labelToAnnounce = signature.label.substring(param.label[0], param.label[1]);
      } else {
        labelToAnnounce = param.label;
      }
      if (param.documentation) {
        labelToAnnounce += typeof param.documentation === "string" ? `, ${param.documentation}` : `, ${param.documentation.value}`;
      }
      if (signature.documentation) {
        labelToAnnounce += typeof signature.documentation === "string" ? `, ${signature.documentation}` : `, ${signature.documentation.value}`;
      }
      if (this.announcedLabel !== labelToAnnounce) {
        alert(localize("hint", "{0}, hint", labelToAnnounce));
        this.announcedLabel = labelToAnnounce;
      }
    }
    this.editor.layoutContentWidget(this);
    this.domNodes.scrollbar.scanDomNode();
  }
  renderMarkdownDocs(markdown) {
    const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(markdown, {
      asyncRenderCallback: () => {
        var _a;
        (_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.scrollbar.scanDomNode();
      }
    }));
    renderedContents.element.classList.add("markdown-docs");
    return renderedContents;
  }
  hasDocs(signature, activeParameter) {
    if (activeParameter && typeof activeParameter.documentation === "string" && assertIsDefined(activeParameter.documentation).length > 0) {
      return true;
    }
    if (activeParameter && typeof activeParameter.documentation === "object" && assertIsDefined(activeParameter.documentation).value.length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "string" && assertIsDefined(signature.documentation).length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "object" && assertIsDefined(signature.documentation.value).length > 0) {
      return true;
    }
    return false;
  }
  renderParameters(parent, signature, activeParameterIndex) {
    const [start, end] = this.getParameterLabelOffsets(signature, activeParameterIndex);
    const beforeSpan = document.createElement("span");
    beforeSpan.textContent = signature.label.substring(0, start);
    const paramSpan = document.createElement("span");
    paramSpan.textContent = signature.label.substring(start, end);
    paramSpan.className = "parameter active";
    const afterSpan = document.createElement("span");
    afterSpan.textContent = signature.label.substring(end);
    append(parent, beforeSpan, paramSpan, afterSpan);
  }
  getParameterLabelOffsets(signature, paramIdx) {
    const param = signature.parameters[paramIdx];
    if (!param) {
      return [0, 0];
    } else if (Array.isArray(param.label)) {
      return param.label;
    } else if (!param.label.length) {
      return [0, 0];
    } else {
      const regex = new RegExp(`(\\W|^)${escapeRegExpCharacters(param.label)}(?=\\W|$)`, "g");
      regex.test(signature.label);
      const idx = regex.lastIndex - param.label.length;
      return idx >= 0 ? [idx, regex.lastIndex] : [0, 0];
    }
  }
  next() {
    this.editor.focus();
    this.model.next();
  }
  previous() {
    this.editor.focus();
    this.model.previous();
  }
  getDomNode() {
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    return this.domNodes.element;
  }
  getId() {
    return ParameterHintsWidget_1.ID;
  }
  updateMaxHeight() {
    if (!this.domNodes) {
      return;
    }
    const height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
    const maxHeight = `${height}px`;
    this.domNodes.element.style.maxHeight = maxHeight;
    const wrapper = this.domNodes.element.getElementsByClassName("phwrapper");
    if (wrapper.length) {
      wrapper[0].style.maxHeight = maxHeight;
    }
  }
};
ParameterHintsWidget.ID = "editor.widget.parameterHintsWidget";
ParameterHintsWidget = ParameterHintsWidget_1 = __decorate29([
  __param29(2, IContextKeyService),
  __param29(3, IOpenerService),
  __param29(4, ILanguageService)
], ParameterHintsWidget);
registerColor("editorHoverWidget.highlightForeground", { dark: listHighlightForeground, light: listHighlightForeground, hcDark: listHighlightForeground, hcLight: listHighlightForeground }, localize("editorHoverWidgetHighlightForeground", "Foreground color of the active item in the parameter hint."));

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ParameterHintsController_1;
var ParameterHintsController = ParameterHintsController_1 = class ParameterHintsController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(ParameterHintsController_1.ID);
  }
  constructor(editor2, instantiationService, languageFeaturesService) {
    super();
    this.editor = editor2;
    this.model = this._register(new ParameterHintsModel(editor2, languageFeaturesService.signatureHelpProvider));
    this._register(this.model.onChangedHints((newParameterHints) => {
      var _a;
      if (newParameterHints) {
        this.widget.value.show();
        this.widget.value.render(newParameterHints);
      } else {
        (_a = this.widget.rawValue) === null || _a === void 0 ? void 0 : _a.hide();
      }
    }));
    this.widget = new Lazy(() => this._register(instantiationService.createInstance(ParameterHintsWidget, this.editor, this.model)));
  }
  cancel() {
    this.model.cancel();
  }
  previous() {
    var _a;
    (_a = this.widget.rawValue) === null || _a === void 0 ? void 0 : _a.previous();
  }
  next() {
    var _a;
    (_a = this.widget.rawValue) === null || _a === void 0 ? void 0 : _a.next();
  }
  trigger(context) {
    this.model.trigger(context, 0);
  }
};
ParameterHintsController.ID = "editor.controller.parameterHints";
ParameterHintsController = ParameterHintsController_1 = __decorate30([
  __param30(1, IInstantiationService),
  __param30(2, ILanguageFeaturesService)
], ParameterHintsController);
var TriggerParameterHintsAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.triggerParameterHints",
      label: localize("parameterHints.trigger.label", "Trigger Parameter Hints"),
      alias: "Trigger Parameter Hints",
      precondition: EditorContextKeys.hasSignatureHelpProvider,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 10,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ParameterHintsController.get(editor2);
    controller === null || controller === void 0 ? void 0 : controller.trigger({
      triggerKind: SignatureHelpTriggerKind.Invoke
    });
  }
};
registerEditorContribution(
  ParameterHintsController.ID,
  ParameterHintsController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(TriggerParameterHintsAction);
var weight = 100 + 75;
var ParameterHintsCommand = EditorCommand.bindToContribution(ParameterHintsController.get);
registerEditorCommand(new ParameterHintsCommand({
  id: "closeParameterHints",
  precondition: Context2.Visible,
  handler: (x) => x.cancel(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showPrevParameterHint",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
  handler: (x) => x.previous(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.focus,
    primary: 16,
    secondary: [
      512 | 16
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      512 | 16,
      256 | 46
      /* KeyCode.KeyP */
    ] }
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showNextParameterHint",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
  handler: (x) => x.next(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.focus,
    primary: 18,
    secondary: [
      512 | 18
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      512 | 18,
      256 | 44
      /* KeyCode.KeyN */
    ] }
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/rename.js
init_aria();
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_types();
init_uri();
init_editorState();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();
init_nls();
init_configurationRegistry();
init_contextkey();
init_instantiation();
init_log();
init_progress();
init_platform2();

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/renameInputField.js
init_lifecycle();
init_position();
init_nls();
init_contextkey();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/renameInputField.css";
init_colorRegistry();
init_themeService();
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey("renameInputVisible", false, localize("renameInputVisible", "Whether the rename input widget is visible"));
var RenameInputField = class RenameInputField2 {
  constructor(_editor, _acceptKeybindings, _themeService, _keybindingService, contextKeyService) {
    this._editor = _editor;
    this._acceptKeybindings = _acceptKeybindings;
    this._themeService = _themeService;
    this._keybindingService = _keybindingService;
    this._disposables = new DisposableStore();
    this.allowEditorOverflow = true;
    this._visibleContextKey = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._editor.addContentWidget(this);
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        49
        /* EditorOption.fontInfo */
      )) {
        this._updateFont();
      }
    }));
    this._disposables.add(_themeService.onDidColorThemeChange(this._updateStyles, this));
  }
  dispose() {
    this._disposables.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "__renameInputWidget";
  }
  getDomNode() {
    if (!this._domNode) {
      this._domNode = document.createElement("div");
      this._domNode.className = "monaco-editor rename-box";
      this._input = document.createElement("input");
      this._input.className = "rename-input";
      this._input.type = "text";
      this._input.setAttribute("aria-label", localize("renameAriaLabel", "Rename input. Type new name and press Enter to commit."));
      this._domNode.appendChild(this._input);
      this._label = document.createElement("div");
      this._label.className = "rename-label";
      this._domNode.appendChild(this._label);
      this._updateFont();
      this._updateStyles(this._themeService.getColorTheme());
    }
    return this._domNode;
  }
  _updateStyles(theme) {
    var _a, _b, _c, _d;
    if (!this._input || !this._domNode) {
      return;
    }
    const widgetShadowColor = theme.getColor(widgetShadow);
    const widgetBorderColor = theme.getColor(widgetBorder);
    this._domNode.style.backgroundColor = String((_a = theme.getColor(editorWidgetBackground)) !== null && _a !== void 0 ? _a : "");
    this._domNode.style.boxShadow = widgetShadowColor ? ` 0 0 8px 2px ${widgetShadowColor}` : "";
    this._domNode.style.border = widgetBorderColor ? `1px solid ${widgetBorderColor}` : "";
    this._domNode.style.color = String((_b = theme.getColor(inputForeground)) !== null && _b !== void 0 ? _b : "");
    this._input.style.backgroundColor = String((_c = theme.getColor(inputBackground)) !== null && _c !== void 0 ? _c : "");
    const border = theme.getColor(inputBorder);
    this._input.style.borderWidth = border ? "1px" : "0px";
    this._input.style.borderStyle = border ? "solid" : "none";
    this._input.style.borderColor = (_d = border === null || border === void 0 ? void 0 : border.toString()) !== null && _d !== void 0 ? _d : "none";
  }
  _updateFont() {
    if (!this._input || !this._label) {
      return;
    }
    const fontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    this._input.style.fontFamily = fontInfo.fontFamily;
    this._input.style.fontWeight = fontInfo.fontWeight;
    this._input.style.fontSize = `${fontInfo.fontSize}px`;
    this._label.style.fontSize = `${fontInfo.fontSize * 0.8}px`;
  }
  getPosition() {
    if (!this._visible) {
      return null;
    }
    return {
      position: this._position,
      preference: [
        2,
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  beforeRender() {
    var _a, _b;
    const [accept, preview] = this._acceptKeybindings;
    this._label.innerText = localize({ key: "label", comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", (_a = this._keybindingService.lookupKeybinding(accept)) === null || _a === void 0 ? void 0 : _a.getLabel(), (_b = this._keybindingService.lookupKeybinding(preview)) === null || _b === void 0 ? void 0 : _b.getLabel());
    return null;
  }
  afterRender(position) {
    if (!position) {
      this.cancelInput(true);
    }
  }
  acceptInput(wantsPreview) {
    var _a;
    (_a = this._currentAcceptInput) === null || _a === void 0 ? void 0 : _a.call(this, wantsPreview);
  }
  cancelInput(focusEditor) {
    var _a;
    (_a = this._currentCancelInput) === null || _a === void 0 ? void 0 : _a.call(this, focusEditor);
  }
  getInput(where, value, selectionStart, selectionEnd, supportPreview, token) {
    this._domNode.classList.toggle("preview", supportPreview);
    this._position = new Position(where.startLineNumber, where.startColumn);
    this._input.value = value;
    this._input.setAttribute("selectionStart", selectionStart.toString());
    this._input.setAttribute("selectionEnd", selectionEnd.toString());
    this._input.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
    const disposeOnDone = new DisposableStore();
    return new Promise((resolve) => {
      this._currentCancelInput = (focusEditor) => {
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve(focusEditor);
        return true;
      };
      this._currentAcceptInput = (wantsPreview) => {
        if (this._input.value.trim().length === 0 || this._input.value === value) {
          this.cancelInput(true);
          return;
        }
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve({
          newName: this._input.value,
          wantsPreview: supportPreview && wantsPreview
        });
      };
      disposeOnDone.add(token.onCancellationRequested(() => this.cancelInput(true)));
      disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(!document.hasFocus())));
      this._show();
    }).finally(() => {
      disposeOnDone.dispose();
      this._hide();
    });
  }
  _show() {
    this._editor.revealLineInCenterIfOutsideViewport(
      this._position.lineNumber,
      0
      /* ScrollType.Smooth */
    );
    this._visible = true;
    this._visibleContextKey.set(true);
    this._editor.layoutContentWidget(this);
    setTimeout(() => {
      this._input.focus();
      this._input.setSelectionRange(parseInt(this._input.getAttribute("selectionStart")), parseInt(this._input.getAttribute("selectionEnd")));
    }, 100);
  }
  _hide() {
    this._visible = false;
    this._visibleContextKey.reset();
    this._editor.layoutContentWidget(this);
  }
};
RenameInputField = __decorate31([
  __param31(2, IThemeService),
  __param31(3, IKeybindingService),
  __param31(4, IContextKeyService)
], RenameInputField);

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/rename.js
init_languageFeatures();
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RenameController_1;
var RenameSkeleton = class {
  constructor(model, position, registry) {
    this.model = model;
    this.position = position;
    this._providerRenameIdx = 0;
    this._providers = registry.ordered(model);
  }
  hasProvider() {
    return this._providers.length > 0;
  }
  resolveRenameLocation(token) {
    return __awaiter29(this, void 0, void 0, function* () {
      const rejects = [];
      for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
        const provider = this._providers[this._providerRenameIdx];
        if (!provider.resolveRenameLocation) {
          break;
        }
        const res = yield provider.resolveRenameLocation(this.model, this.position, token);
        if (!res) {
          continue;
        }
        if (res.rejectReason) {
          rejects.push(res.rejectReason);
          continue;
        }
        return res;
      }
      const word = this.model.getWordAtPosition(this.position);
      if (!word) {
        return {
          range: Range.fromPositions(this.position),
          text: "",
          rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
        };
      }
      return {
        range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
        text: word.word,
        rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
      };
    });
  }
  provideRenameEdits(newName, token) {
    return __awaiter29(this, void 0, void 0, function* () {
      return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
    });
  }
  _provideRenameEdits(newName, i, rejects, token) {
    return __awaiter29(this, void 0, void 0, function* () {
      const provider = this._providers[i];
      if (!provider) {
        return {
          edits: [],
          rejectReason: rejects.join("\n")
        };
      }
      const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);
      if (!result) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(localize("no result", "No result.")), token);
      } else if (result.rejectReason) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
      }
      return result;
    });
  }
};
function rename(registry, model, position, newName) {
  return __awaiter29(this, void 0, void 0, function* () {
    const skeleton = new RenameSkeleton(model, position, registry);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      return { edits: [], rejectReason: loc.rejectReason };
    }
    return skeleton.provideRenameEdits(newName, CancellationToken.None);
  });
}
var RenameController = RenameController_1 = class RenameController2 {
  static get(editor2) {
    return editor2.getContribution(RenameController_1.ID);
  }
  constructor(editor2, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService, _languageFeaturesService) {
    this.editor = editor2;
    this._instaService = _instaService;
    this._notificationService = _notificationService;
    this._bulkEditService = _bulkEditService;
    this._progressService = _progressService;
    this._logService = _logService;
    this._configService = _configService;
    this._languageFeaturesService = _languageFeaturesService;
    this._disposableStore = new DisposableStore();
    this._cts = new CancellationTokenSource();
    this._renameInputField = this._disposableStore.add(this._instaService.createInstance(RenameInputField, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]));
  }
  dispose() {
    this._disposableStore.dispose();
    this._cts.dispose(true);
  }
  run() {
    var _a, _b;
    return __awaiter29(this, void 0, void 0, function* () {
      this._cts.dispose(true);
      this._cts = new CancellationTokenSource();
      if (!this.editor.hasModel()) {
        return void 0;
      }
      const position = this.editor.getPosition();
      const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);
      if (!skeleton.hasProvider()) {
        return void 0;
      }
      const cts1 = new EditorStateCancellationTokenSource(this.editor, 4 | 1, void 0, this._cts.token);
      let loc;
      try {
        const resolveLocationOperation = skeleton.resolveRenameLocation(cts1.token);
        this._progressService.showWhile(resolveLocationOperation, 250);
        loc = yield resolveLocationOperation;
      } catch (e) {
        (_a = MessageController.get(this.editor)) === null || _a === void 0 ? void 0 : _a.showMessage(e || localize("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), position);
        return void 0;
      } finally {
        cts1.dispose();
      }
      if (!loc) {
        return void 0;
      }
      if (loc.rejectReason) {
        (_b = MessageController.get(this.editor)) === null || _b === void 0 ? void 0 : _b.showMessage(loc.rejectReason, position);
        return void 0;
      }
      if (cts1.token.isCancellationRequested) {
        return void 0;
      }
      const cts2 = new EditorStateCancellationTokenSource(this.editor, 4 | 1, loc.range, this._cts.token);
      const selection = this.editor.getSelection();
      let selectionStart = 0;
      let selectionEnd = loc.text.length;
      if (!Range.isEmpty(selection) && !Range.spansMultipleLines(selection) && Range.containsRange(loc.range, selection)) {
        selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
        selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
      }
      const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview");
      const inputFieldResult = yield this._renameInputField.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, cts2.token);
      if (typeof inputFieldResult === "boolean") {
        if (inputFieldResult) {
          this.editor.focus();
        }
        cts2.dispose();
        return void 0;
      }
      this.editor.focus();
      const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, cts2.token), cts2.token).then((renameResult) => __awaiter29(this, void 0, void 0, function* () {
        if (!renameResult || !this.editor.hasModel()) {
          return;
        }
        if (renameResult.rejectReason) {
          this._notificationService.info(renameResult.rejectReason);
          return;
        }
        this.editor.setSelection(Range.fromPositions(this.editor.getSelection().getPosition()));
        this._bulkEditService.apply(renameResult, {
          editor: this.editor,
          showPreview: inputFieldResult.wantsPreview,
          label: localize("label", "Renaming '{0}' to '{1}'", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
          code: "undoredo.rename",
          quotableLabel: localize("quotableLabel", "Renaming {0} to {1}", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
          respectAutoSaveConfig: true
        }).then((result) => {
          if (result.ariaSummary) {
            alert(localize("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
          }
        }).catch((err) => {
          this._notificationService.error(localize("rename.failedApply", "Rename failed to apply edits"));
          this._logService.error(err);
        });
      }), (err) => {
        this._notificationService.error(localize("rename.failed", "Rename failed to compute edits"));
        this._logService.error(err);
      }).finally(() => {
        cts2.dispose();
      });
      this._progressService.showWhile(renameOperation, 250);
      return renameOperation;
    });
  }
  acceptRenameInput(wantsPreview) {
    this._renameInputField.acceptInput(wantsPreview);
  }
  cancelRenameInput() {
    this._renameInputField.cancelInput(true);
  }
};
RenameController.ID = "editor.contrib.renameController";
RenameController = RenameController_1 = __decorate32([
  __param32(1, IInstantiationService),
  __param32(2, INotificationService),
  __param32(3, IBulkEditService),
  __param32(4, IEditorProgressService),
  __param32(5, ILogService),
  __param32(6, ITextResourceConfigurationService),
  __param32(7, ILanguageFeaturesService)
], RenameController);
var RenameAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.rename",
      label: localize("rename.label", "Rename Symbol"),
      alias: "Rename Symbol",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.1
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(accessor, editor2) {
    const controller = RenameController.get(editor2);
    if (controller) {
      return controller.run();
    }
    return Promise.resolve();
  }
};
registerEditorContribution(
  RenameController.ID,
  RenameController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(RenameAction);
var RenameCommand = EditorCommand.bindToContribution(RenameController.get);
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.acceptRenameInput(false),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInputWithPreview",
  precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has("config.editor.rename.enablePreview")),
  handler: (x) => x.acceptRenameInput(true),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 1024 + 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new RenameCommand({
  id: "cancelRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.cancelRenameInput(),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerModelAndPositionCommand("_executeDocumentRenameProvider", function(accessor, model, position, ...args) {
  const [newName] = args;
  assertType(typeof newName === "string");
  const { renameProvider } = accessor.get(ILanguageFeaturesService);
  return rename(renameProvider, model, position, newName);
});
registerModelAndPositionCommand("_executePrepareRename", function(accessor, model, position) {
  return __awaiter29(this, void 0, void 0, function* () {
    const { renameProvider } = accessor.get(ILanguageFeaturesService);
    const skeleton = new RenameSkeleton(model, position, renameProvider);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      throw new Error(loc.rejectReason);
    }
    return loc;
  });
});
Registry.as(Extensions.Configuration).registerConfiguration({
  id: "editor",
  properties: {
    "editor.rename.enablePreview": {
      scope: 5,
      description: localize("enablePreview", "Enable/disable the ability to preview changes before renaming"),
      default: true,
      type: "boolean"
    }
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/browser/documentSemanticTokens.js
init_lifecycle();
init_errors();
init_model2();
init_configuration();
init_async();
init_cancellation();
init_themeService();

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js
init_cancellation();
init_errors();
init_uri();
init_model2();
init_commands();
init_types();
init_range();
init_languageFeatures();
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function isSemanticTokens(v) {
  return v && !!v.data;
}
function isSemanticTokensEdits(v) {
  return v && Array.isArray(v.edits);
}
var DocumentSemanticTokensResult = class {
  constructor(provider, tokens, error) {
    this.provider = provider;
    this.tokens = tokens;
    this.error = error;
  }
};
function hasDocumentSemanticTokensProvider(registry, model) {
  return registry.has(model);
}
function getDocumentSemanticTokensProviders(registry, model) {
  const groups = registry.orderedGroups(model);
  return groups.length > 0 ? groups[0] : [];
}
function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {
  return __awaiter30(this, void 0, void 0, function* () {
    const providers = getDocumentSemanticTokensProviders(registry, model);
    const results = yield Promise.all(providers.map((provider) => __awaiter30(this, void 0, void 0, function* () {
      let result;
      let error = null;
      try {
        result = yield provider.provideDocumentSemanticTokens(model, provider === lastProvider ? lastResultId : null, token);
      } catch (err) {
        error = err;
        result = null;
      }
      if (!result || !isSemanticTokens(result) && !isSemanticTokensEdits(result)) {
        result = null;
      }
      return new DocumentSemanticTokensResult(provider, result, error);
    })));
    for (const result of results) {
      if (result.error) {
        throw result.error;
      }
      if (result.tokens) {
        return result;
      }
    }
    if (results.length > 0) {
      return results[0];
    }
    return null;
  });
}
function _getDocumentSemanticTokensProviderHighestGroup(registry, model) {
  const result = registry.orderedGroups(model);
  return result.length > 0 ? result[0] : null;
}
var DocumentRangeSemanticTokensResult = class {
  constructor(provider, tokens) {
    this.provider = provider;
    this.tokens = tokens;
  }
};
function hasDocumentRangeSemanticTokensProvider(providers, model) {
  return providers.has(model);
}
function getDocumentRangeSemanticTokensProviders(providers, model) {
  const groups = providers.orderedGroups(model);
  return groups.length > 0 ? groups[0] : [];
}
function getDocumentRangeSemanticTokens(registry, model, range, token) {
  return __awaiter30(this, void 0, void 0, function* () {
    const providers = getDocumentRangeSemanticTokensProviders(registry, model);
    const results = yield Promise.all(providers.map((provider) => __awaiter30(this, void 0, void 0, function* () {
      let result;
      try {
        result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);
      } catch (err) {
        onUnexpectedExternalError(err);
        result = null;
      }
      if (!result || !isSemanticTokens(result)) {
        result = null;
      }
      return new DocumentRangeSemanticTokensResult(provider, result);
    })));
    for (const result of results) {
      if (result.tokens) {
        return result;
      }
    }
    if (results.length > 0) {
      return results[0];
    }
    return null;
  });
}
CommandsRegistry.registerCommand("_provideDocumentSemanticTokensLegend", (accessor, ...args) => __awaiter30(void 0, void 0, void 0, function* () {
  const [uri] = args;
  assertType(uri instanceof URI);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);
  if (!providers) {
    return accessor.get(ICommandService).executeCommand("_provideDocumentRangeSemanticTokensLegend", uri);
  }
  return providers[0].getLegend();
}));
CommandsRegistry.registerCommand("_provideDocumentSemanticTokens", (accessor, ...args) => __awaiter30(void 0, void 0, void 0, function* () {
  const [uri] = args;
  assertType(uri instanceof URI);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {
    return accessor.get(ICommandService).executeCommand("_provideDocumentRangeSemanticTokens", uri, model.getFullModelRange());
  }
  const r = yield getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);
  if (!r) {
    return void 0;
  }
  const { provider, tokens } = r;
  if (!tokens || !isSemanticTokens(tokens)) {
    return void 0;
  }
  const buff = encodeSemanticTokensDto({
    id: 0,
    type: "full",
    data: tokens.data
  });
  if (tokens.resultId) {
    provider.releaseDocumentSemanticTokens(tokens.resultId);
  }
  return buff;
}));
CommandsRegistry.registerCommand("_provideDocumentRangeSemanticTokensLegend", (accessor, ...args) => __awaiter30(void 0, void 0, void 0, function* () {
  const [uri, range] = args;
  assertType(uri instanceof URI);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);
  if (providers.length === 0) {
    return void 0;
  }
  if (providers.length === 1) {
    return providers[0].getLegend();
  }
  if (!range || !Range.isIRange(range)) {
    console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);
    return providers[0].getLegend();
  }
  const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);
  if (!result) {
    return void 0;
  }
  return result.provider.getLegend();
}));
CommandsRegistry.registerCommand("_provideDocumentRangeSemanticTokens", (accessor, ...args) => __awaiter30(void 0, void 0, void 0, function* () {
  const [uri, range] = args;
  assertType(uri instanceof URI);
  assertType(Range.isIRange(range));
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);
  if (!result || !result.tokens) {
    return void 0;
  }
  return encodeSemanticTokensDto({
    id: 0,
    type: "full",
    data: result.tokens.data
  });
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/browser/documentSemanticTokens.js
init_languageFeatureDebounce();
init_stopwatch();
init_languageFeatures();
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ModelSemanticColoring_1;
var DocumentSemanticTokensFeature = class DocumentSemanticTokensFeature2 extends Disposable {
  constructor(semanticTokensStylingService, modelService, themeService, configurationService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this._watchers = /* @__PURE__ */ Object.create(null);
    const register2 = (model) => {
      this._watchers[model.uri.toString()] = new ModelSemanticColoring(model, semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService);
    };
    const deregister = (model, modelSemanticColoring) => {
      modelSemanticColoring.dispose();
      delete this._watchers[model.uri.toString()];
    };
    const handleSettingOrThemeChange = () => {
      for (const model of modelService.getModels()) {
        const curr = this._watchers[model.uri.toString()];
        if (isSemanticColoringEnabled(model, themeService, configurationService)) {
          if (!curr) {
            register2(model);
          }
        } else {
          if (curr) {
            deregister(model, curr);
          }
        }
      }
    };
    this._register(modelService.onModelAdded((model) => {
      if (isSemanticColoringEnabled(model, themeService, configurationService)) {
        register2(model);
      }
    }));
    this._register(modelService.onModelRemoved((model) => {
      const curr = this._watchers[model.uri.toString()];
      if (curr) {
        deregister(model, curr);
      }
    }));
    this._register(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        handleSettingOrThemeChange();
      }
    }));
    this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));
  }
  dispose() {
    for (const watcher of Object.values(this._watchers)) {
      watcher.dispose();
    }
    super.dispose();
  }
};
DocumentSemanticTokensFeature = __decorate33([
  __param33(0, ISemanticTokensStylingService),
  __param33(1, IModelService),
  __param33(2, IThemeService),
  __param33(3, IConfigurationService),
  __param33(4, ILanguageFeatureDebounceService),
  __param33(5, ILanguageFeaturesService)
], DocumentSemanticTokensFeature);
var ModelSemanticColoring = ModelSemanticColoring_1 = class ModelSemanticColoring2 extends Disposable {
  constructor(model, _semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this._semanticTokensStylingService = _semanticTokensStylingService;
    this._isDisposed = false;
    this._model = model;
    this._provider = languageFeaturesService.documentSemanticTokensProvider;
    this._debounceInformation = languageFeatureDebounceService.for(this._provider, "DocumentSemanticTokens", { min: ModelSemanticColoring_1.REQUEST_MIN_DELAY, max: ModelSemanticColoring_1.REQUEST_MAX_DELAY });
    this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), ModelSemanticColoring_1.REQUEST_MIN_DELAY));
    this._currentDocumentResponse = null;
    this._currentDocumentRequestCancellationTokenSource = null;
    this._documentProvidersChangeListeners = [];
    this._providersChangedDuringRequest = false;
    this._register(this._model.onDidChangeContent(() => {
      if (!this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      }
    }));
    this._register(this._model.onDidChangeAttached(() => {
      if (!this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      }
    }));
    this._register(this._model.onDidChangeLanguage(() => {
      if (this._currentDocumentResponse) {
        this._currentDocumentResponse.dispose();
        this._currentDocumentResponse = null;
      }
      if (this._currentDocumentRequestCancellationTokenSource) {
        this._currentDocumentRequestCancellationTokenSource.cancel();
        this._currentDocumentRequestCancellationTokenSource = null;
      }
      this._setDocumentSemanticTokens(null, null, null, []);
      this._fetchDocumentSemanticTokens.schedule(0);
    }));
    const bindDocumentChangeListeners = () => {
      dispose(this._documentProvidersChangeListeners);
      this._documentProvidersChangeListeners = [];
      for (const provider of this._provider.all(model)) {
        if (typeof provider.onDidChange === "function") {
          this._documentProvidersChangeListeners.push(provider.onDidChange(() => {
            if (this._currentDocumentRequestCancellationTokenSource) {
              this._providersChangedDuringRequest = true;
              return;
            }
            this._fetchDocumentSemanticTokens.schedule(0);
          }));
        }
      }
    };
    bindDocumentChangeListeners();
    this._register(this._provider.onDidChange(() => {
      bindDocumentChangeListeners();
      this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    }));
    this._register(themeService.onDidColorThemeChange((_) => {
      this._setDocumentSemanticTokens(null, null, null, []);
      this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    }));
    this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._currentDocumentRequestCancellationTokenSource) {
      this._currentDocumentRequestCancellationTokenSource.cancel();
      this._currentDocumentRequestCancellationTokenSource = null;
    }
    dispose(this._documentProvidersChangeListeners);
    this._documentProvidersChangeListeners = [];
    this._setDocumentSemanticTokens(null, null, null, []);
    this._isDisposed = true;
    super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource) {
      return;
    }
    if (!hasDocumentSemanticTokensProvider(this._provider, this._model)) {
      if (this._currentDocumentResponse) {
        this._model.tokenization.setSemanticTokens(null, false);
      }
      return;
    }
    if (!this._model.isAttachedToEditor()) {
      return;
    }
    const cancellationTokenSource = new CancellationTokenSource();
    const lastProvider = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null;
    const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;
    const request = getDocumentSemanticTokens(this._provider, this._model, lastProvider, lastResultId, cancellationTokenSource.token);
    this._currentDocumentRequestCancellationTokenSource = cancellationTokenSource;
    this._providersChangedDuringRequest = false;
    const pendingChanges = [];
    const contentChangeListener = this._model.onDidChangeContent((e) => {
      pendingChanges.push(e);
    });
    const sw = new StopWatch(false);
    request.then((res) => {
      this._debounceInformation.update(this._model, sw.elapsed());
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      if (!res) {
        this._setDocumentSemanticTokens(null, null, null, pendingChanges);
      } else {
        const { provider, tokens } = res;
        const styling = this._semanticTokensStylingService.getStyling(provider);
        this._setDocumentSemanticTokens(provider, tokens || null, styling, pendingChanges);
      }
    }, (err) => {
      const isExpectedError = err && (isCancellationError(err) || typeof err.message === "string" && err.message.indexOf("busy") !== -1);
      if (!isExpectedError) {
        onUnexpectedError(err);
      }
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      if (pendingChanges.length > 0 || this._providersChangedDuringRequest) {
        if (!this._fetchDocumentSemanticTokens.isScheduled()) {
          this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
        }
      }
    });
  }
  static _copy(src, srcOffset, dest, destOffset, length) {
    length = Math.min(length, dest.length - destOffset, src.length - srcOffset);
    for (let i = 0; i < length; i++) {
      dest[destOffset + i] = src[srcOffset + i];
    }
  }
  _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {
    const currentResponse = this._currentDocumentResponse;
    const rescheduleIfNeeded = () => {
      if ((pendingChanges.length > 0 || this._providersChangedDuringRequest) && !this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      }
    };
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._isDisposed) {
      if (provider && tokens) {
        provider.releaseDocumentSemanticTokens(tokens.resultId);
      }
      return;
    }
    if (!provider || !styling) {
      this._model.tokenization.setSemanticTokens(null, false);
      return;
    }
    if (!tokens) {
      this._model.tokenization.setSemanticTokens(null, true);
      rescheduleIfNeeded();
      return;
    }
    if (isSemanticTokensEdits(tokens)) {
      if (!currentResponse) {
        this._model.tokenization.setSemanticTokens(null, true);
        return;
      }
      if (tokens.edits.length === 0) {
        tokens = {
          resultId: tokens.resultId,
          data: currentResponse.data
        };
      } else {
        let deltaLength = 0;
        for (const edit of tokens.edits) {
          deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;
        }
        const srcData = currentResponse.data;
        const destData = new Uint32Array(srcData.length + deltaLength);
        let srcLastStart = srcData.length;
        let destLastStart = destData.length;
        for (let i = tokens.edits.length - 1; i >= 0; i--) {
          const edit = tokens.edits[i];
          if (edit.start > srcData.length) {
            styling.warnInvalidEditStart(currentResponse.resultId, tokens.resultId, i, edit.start, srcData.length);
            this._model.tokenization.setSemanticTokens(null, true);
            return;
          }
          const copyCount = srcLastStart - (edit.start + edit.deleteCount);
          if (copyCount > 0) {
            ModelSemanticColoring_1._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);
            destLastStart -= copyCount;
          }
          if (edit.data) {
            ModelSemanticColoring_1._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);
            destLastStart -= edit.data.length;
          }
          srcLastStart = edit.start;
        }
        if (srcLastStart > 0) {
          ModelSemanticColoring_1._copy(srcData, 0, destData, 0, srcLastStart);
        }
        tokens = {
          resultId: tokens.resultId,
          data: destData
        };
      }
    }
    if (isSemanticTokens(tokens)) {
      this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);
      const result = toMultilineTokens2(tokens, styling, this._model.getLanguageId());
      if (pendingChanges.length > 0) {
        for (const change of pendingChanges) {
          for (const area of result) {
            for (const singleChange of change.changes) {
              area.applyEdit(singleChange.range, singleChange.text);
            }
          }
        }
      }
      this._model.tokenization.setSemanticTokens(result, true);
    } else {
      this._model.tokenization.setSemanticTokens(null, true);
    }
    rescheduleIfNeeded();
  }
};
ModelSemanticColoring.REQUEST_MIN_DELAY = 300;
ModelSemanticColoring.REQUEST_MAX_DELAY = 2e3;
ModelSemanticColoring = ModelSemanticColoring_1 = __decorate33([
  __param33(1, ISemanticTokensStylingService),
  __param33(2, IThemeService),
  __param33(3, ILanguageFeatureDebounceService),
  __param33(4, ILanguageFeaturesService)
], ModelSemanticColoring);
var SemanticTokensResponse = class {
  constructor(provider, resultId, data) {
    this.provider = provider;
    this.resultId = resultId;
    this.data = data;
  }
  dispose() {
    this.provider.releaseDocumentSemanticTokens(this.resultId);
  }
};
registerEditorFeature(DocumentSemanticTokensFeature);

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js
init_async();
init_lifecycle();
init_editorExtensions();
init_configuration();
init_themeService();
init_languageFeatureDebounce();
init_stopwatch();
init_languageFeatures();
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param34 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ViewportSemanticTokensContribution_1;
var ViewportSemanticTokensContribution = ViewportSemanticTokensContribution_1 = class ViewportSemanticTokensContribution2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(ViewportSemanticTokensContribution_1.ID);
  }
  constructor(editor2, _semanticTokensStylingService, _themeService, _configurationService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this._semanticTokensStylingService = _semanticTokensStylingService;
    this._themeService = _themeService;
    this._configurationService = _configurationService;
    this._editor = editor2;
    this._provider = languageFeaturesService.documentRangeSemanticTokensProvider;
    this._debounceInformation = languageFeatureDebounceService.for(this._provider, "DocumentRangeSemanticTokens", { min: 100, max: 500 });
    this._tokenizeViewport = this._register(new RunOnceScheduler(() => this._tokenizeViewportNow(), 100));
    this._outstandingRequests = [];
    const scheduleTokenizeViewport = () => {
      if (this._editor.hasModel()) {
        this._tokenizeViewport.schedule(this._debounceInformation.get(this._editor.getModel()));
      }
    };
    this._register(this._editor.onDidScrollChange(() => {
      scheduleTokenizeViewport();
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    this._register(this._provider.onDidChange(() => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        this._cancelAll();
        scheduleTokenizeViewport();
      }
    }));
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    scheduleTokenizeViewport();
  }
  _cancelAll() {
    for (const request of this._outstandingRequests) {
      request.cancel();
    }
    this._outstandingRequests = [];
  }
  _removeOutstandingRequest(req) {
    for (let i = 0, len = this._outstandingRequests.length; i < len; i++) {
      if (this._outstandingRequests[i] === req) {
        this._outstandingRequests.splice(i, 1);
        return;
      }
    }
  }
  _tokenizeViewportNow() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    if (model.tokenization.hasCompleteSemanticTokens()) {
      return;
    }
    if (!isSemanticColoringEnabled(model, this._themeService, this._configurationService)) {
      if (model.tokenization.hasSomeSemanticTokens()) {
        model.tokenization.setSemanticTokens(null, false);
      }
      return;
    }
    if (!hasDocumentRangeSemanticTokensProvider(this._provider, model)) {
      if (model.tokenization.hasSomeSemanticTokens()) {
        model.tokenization.setSemanticTokens(null, false);
      }
      return;
    }
    const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
    this._outstandingRequests = this._outstandingRequests.concat(visibleRanges.map((range) => this._requestRange(model, range)));
  }
  _requestRange(model, range) {
    const requestVersionId = model.getVersionId();
    const request = createCancelablePromise((token) => Promise.resolve(getDocumentRangeSemanticTokens(this._provider, model, range, token)));
    const sw = new StopWatch(false);
    request.then((r) => {
      this._debounceInformation.update(model, sw.elapsed());
      if (!r || !r.tokens || model.isDisposed() || model.getVersionId() !== requestVersionId) {
        return;
      }
      const { provider, tokens: result } = r;
      const styling = this._semanticTokensStylingService.getStyling(provider);
      model.tokenization.setPartialSemanticTokens(range, toMultilineTokens2(result, styling, model.getLanguageId()));
    }).then(() => this._removeOutstandingRequest(request), () => this._removeOutstandingRequest(request));
    return request;
  }
};
ViewportSemanticTokensContribution.ID = "editor.contrib.viewportSemanticTokens";
ViewportSemanticTokensContribution = ViewportSemanticTokensContribution_1 = __decorate34([
  __param34(1, ISemanticTokensStylingService),
  __param34(2, IThemeService),
  __param34(3, IConfigurationService),
  __param34(4, ILanguageFeatureDebounceService),
  __param34(5, ILanguageFeaturesService)
], ViewportSemanticTokensContribution);
registerEditorContribution(
  ViewportSemanticTokensContribution.ID,
  ViewportSemanticTokensContribution,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/smartSelect.js
init_arrays();
init_cancellation();
init_errors();
init_editorExtensions();
init_position();
init_range();
init_selection();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/wordSelections.js
init_strings();
init_range();
var WordSelectionRangeProvider = class {
  constructor(selectSubwords = true) {
    this.selectSubwords = selectSubwords;
  }
  provideSelectionRanges(model, positions) {
    const result = [];
    for (const position of positions) {
      const bucket = [];
      result.push(bucket);
      if (this.selectSubwords) {
        this._addInWordRanges(bucket, model, position);
      }
      this._addWordRanges(bucket, model, position);
      this._addWhitespaceLine(bucket, model, position);
      bucket.push({ range: model.getFullModelRange() });
    }
    return result;
  }
  _addInWordRanges(bucket, model, pos) {
    const obj = model.getWordAtPosition(pos);
    if (!obj) {
      return;
    }
    const { word, startColumn } = obj;
    const offset = pos.column - startColumn;
    let start = offset;
    let end = offset;
    let lastCh = 0;
    for (; start >= 0; start--) {
      const ch = word.charCodeAt(start);
      if (start !== offset && (ch === 95 || ch === 45)) {
        break;
      } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {
        break;
      }
      lastCh = ch;
    }
    start += 1;
    for (; end < word.length; end++) {
      const ch = word.charCodeAt(end);
      if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {
        break;
      } else if (ch === 95 || ch === 45) {
        break;
      }
      lastCh = ch;
    }
    if (start < end) {
      bucket.push({ range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });
    }
  }
  _addWordRanges(bucket, model, pos) {
    const word = model.getWordAtPosition(pos);
    if (word) {
      bucket.push({ range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });
    }
  }
  _addWhitespaceLine(bucket, model, pos) {
    if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {
      bucket.push({ range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/smartSelect.js
init_nls();
init_actions2();
init_commands();
init_languageFeatures();
init_resolverService();
init_types();
init_uri();
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param35 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SmartSelectController_1;
var SelectionRanges = class _SelectionRanges {
  constructor(index, ranges) {
    this.index = index;
    this.ranges = ranges;
  }
  mov(fwd) {
    const index = this.index + (fwd ? 1 : -1);
    if (index < 0 || index >= this.ranges.length) {
      return this;
    }
    const res = new _SelectionRanges(index, this.ranges);
    if (res.ranges[index].equalsRange(this.ranges[this.index])) {
      return res.mov(fwd);
    }
    return res;
  }
};
var SmartSelectController = SmartSelectController_1 = class SmartSelectController2 {
  static get(editor2) {
    return editor2.getContribution(SmartSelectController_1.ID);
  }
  constructor(_editor, _languageFeaturesService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._ignoreSelection = false;
  }
  dispose() {
    var _a;
    (_a = this._selectionListener) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  run(forward) {
    return __awaiter31(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return;
      }
      const selections = this._editor.getSelections();
      const model = this._editor.getModel();
      if (!this._state) {
        yield provideSelectionRanges(this._languageFeaturesService.selectionRangeProvider, model, selections.map((s) => s.getPosition()), this._editor.getOption(
          111
          /* EditorOption.smartSelect */
        ), CancellationToken.None).then((ranges) => {
          var _a;
          if (!isNonEmptyArray(ranges) || ranges.length !== selections.length) {
            return;
          }
          if (!this._editor.hasModel() || !equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {
            return;
          }
          for (let i = 0; i < ranges.length; i++) {
            ranges[i] = ranges[i].filter((range) => {
              return range.containsPosition(selections[i].getStartPosition()) && range.containsPosition(selections[i].getEndPosition());
            });
            ranges[i].unshift(selections[i]);
          }
          this._state = ranges.map((ranges2) => new SelectionRanges(0, ranges2));
          (_a = this._selectionListener) === null || _a === void 0 ? void 0 : _a.dispose();
          this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
            var _a2;
            if (!this._ignoreSelection) {
              (_a2 = this._selectionListener) === null || _a2 === void 0 ? void 0 : _a2.dispose();
              this._state = void 0;
            }
          });
        });
      }
      if (!this._state) {
        return;
      }
      this._state = this._state.map((state) => state.mov(forward));
      const newSelections = this._state.map((state) => Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
      this._ignoreSelection = true;
      try {
        this._editor.setSelections(newSelections);
      } finally {
        this._ignoreSelection = false;
      }
    });
  }
};
SmartSelectController.ID = "editor.contrib.smartSelectController";
SmartSelectController = SmartSelectController_1 = __decorate35([
  __param35(1, ILanguageFeaturesService)
], SmartSelectController);
var AbstractSmartSelect = class extends EditorAction {
  constructor(forward, opts) {
    super(opts);
    this._forward = forward;
  }
  run(_accessor, editor2) {
    return __awaiter31(this, void 0, void 0, function* () {
      const controller = SmartSelectController.get(editor2);
      if (controller) {
        yield controller.run(this._forward);
      }
    });
  }
};
var GrowSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(true, {
      id: "editor.action.smartSelect.expand",
      label: localize("smartSelect.expand", "Expand Selection"),
      alias: "Expand Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 17,
        mac: {
          primary: 2048 | 256 | 1024 | 17,
          secondary: [
            256 | 1024 | 17
            /* KeyCode.RightArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({ key: "miSmartSelectGrow", comment: ["&& denotes a mnemonic"] }, "&&Expand Selection"),
        order: 2
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
var ShrinkSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(false, {
      id: "editor.action.smartSelect.shrink",
      label: localize("smartSelect.shrink", "Shrink Selection"),
      alias: "Shrink Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 15,
        mac: {
          primary: 2048 | 256 | 1024 | 15,
          secondary: [
            256 | 1024 | 15
            /* KeyCode.LeftArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({ key: "miSmartSelectShrink", comment: ["&& denotes a mnemonic"] }, "&&Shrink Selection"),
        order: 3
      }
    });
  }
};
registerEditorContribution(
  SmartSelectController.ID,
  SmartSelectController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(GrowSelectionAction);
registerEditorAction(ShrinkSelectionAction);
function provideSelectionRanges(registry, model, positions, options, token) {
  return __awaiter31(this, void 0, void 0, function* () {
    const providers = registry.all(model).concat(new WordSelectionRangeProvider(options.selectSubwords));
    if (providers.length === 1) {
      providers.unshift(new BracketSelectionRangeProvider());
    }
    const work = [];
    const allRawRanges = [];
    for (const provider of providers) {
      work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then((allProviderRanges) => {
        if (isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {
          for (let i = 0; i < positions.length; i++) {
            if (!allRawRanges[i]) {
              allRawRanges[i] = [];
            }
            for (const oneProviderRanges of allProviderRanges[i]) {
              if (Range.isIRange(oneProviderRanges.range) && Range.containsPosition(oneProviderRanges.range, positions[i])) {
                allRawRanges[i].push(Range.lift(oneProviderRanges.range));
              }
            }
          }
        }
      }, onUnexpectedExternalError));
    }
    yield Promise.all(work);
    return allRawRanges.map((oneRawRanges) => {
      if (oneRawRanges.length === 0) {
        return [];
      }
      oneRawRanges.sort((a, b) => {
        if (Position.isBefore(a.getStartPosition(), b.getStartPosition())) {
          return 1;
        } else if (Position.isBefore(b.getStartPosition(), a.getStartPosition())) {
          return -1;
        } else if (Position.isBefore(a.getEndPosition(), b.getEndPosition())) {
          return -1;
        } else if (Position.isBefore(b.getEndPosition(), a.getEndPosition())) {
          return 1;
        } else {
          return 0;
        }
      });
      const oneRanges = [];
      let last;
      for (const range of oneRawRanges) {
        if (!last || Range.containsRange(range, last) && !Range.equalsRange(range, last)) {
          oneRanges.push(range);
          last = range;
        }
      }
      if (!options.selectLeadingAndTrailingWhitespace) {
        return oneRanges;
      }
      const oneRangesWithTrivia = [oneRanges[0]];
      for (let i = 1; i < oneRanges.length; i++) {
        const prev = oneRanges[i - 1];
        const cur = oneRanges[i];
        if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
          const rangeNoWhitespace = new Range(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
          if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) {
            oneRangesWithTrivia.push(rangeNoWhitespace);
          }
          const rangeFull = new Range(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
          if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) {
            oneRangesWithTrivia.push(rangeFull);
          }
        }
        oneRangesWithTrivia.push(cur);
      }
      return oneRangesWithTrivia;
    });
  });
}
CommandsRegistry.registerCommand("_executeSelectionRangeProvider", function(accessor, ...args) {
  return __awaiter31(this, void 0, void 0, function* () {
    const [resource, positions] = args;
    assertType(URI.isUri(resource));
    const registry = accessor.get(ILanguageFeaturesService).selectionRangeProvider;
    const reference = yield accessor.get(ITextModelService).createModelReference(resource);
    try {
      return provideSelectionRanges(registry, reference.object.textEditorModel, positions, { selectLeadingAndTrailingWhitespace: true, selectSubwords: true }, CancellationToken.None);
    } finally {
      reference.dispose();
    }
  });
});

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollContribution.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js
init_editorExtensions();
init_nls();
init_actions2();
init_configuration();
init_contextkey();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js
init_lifecycle();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js
init_dom();
init_lifecycle();
init_themables();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScroll.css";
init_position();
init_stringBuilder();
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StickyScrollWidgetState = class {
  constructor(startLineNumbers, endLineNumbers, lastLineRelativePosition, showEndForLine = null) {
    this.startLineNumbers = startLineNumbers;
    this.endLineNumbers = endLineNumbers;
    this.lastLineRelativePosition = lastLineRelativePosition;
    this.showEndForLine = showEndForLine;
  }
};
var _ttPolicy = createTrustedTypesPolicy("stickyScrollViewLayer", { createHTML: (value) => value });
var STICKY_LINE_INDEX_ATTR = "data-sticky-line-index";
var StickyScrollWidget = class extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._foldingIconStore = new DisposableStore();
    this._rootDomNode = document.createElement("div");
    this._lineNumbersDomNode = document.createElement("div");
    this._linesDomNodeScrollable = document.createElement("div");
    this._linesDomNode = document.createElement("div");
    this._lineHeight = this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    this._stickyLines = [];
    this._lineNumbers = [];
    this._lastLineRelativePosition = 0;
    this._minContentWidthInPx = 0;
    this._isOnGlyphMargin = false;
    this._lineNumbersDomNode.className = "sticky-widget-line-numbers";
    this._lineNumbersDomNode.setAttribute("role", "none");
    this._linesDomNode.className = "sticky-widget-lines";
    this._linesDomNode.setAttribute("role", "list");
    this._linesDomNodeScrollable.className = "sticky-widget-lines-scrollable";
    this._linesDomNodeScrollable.appendChild(this._linesDomNode);
    this._rootDomNode.className = "sticky-widget";
    this._rootDomNode.classList.toggle("peek", _editor instanceof EmbeddedCodeEditorWidget);
    this._rootDomNode.appendChild(this._lineNumbersDomNode);
    this._rootDomNode.appendChild(this._linesDomNodeScrollable);
    const updateScrollLeftPosition = () => {
      this._linesDomNode.style.left = this._editor.getOption(
        113
        /* EditorOption.stickyScroll */
      ).scrollWithEditor ? `-${this._editor.getScrollLeft()}px` : "0px";
    };
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        113
        /* EditorOption.stickyScroll */
      )) {
        updateScrollLeftPosition();
      }
      if (e.hasChanged(
        65
        /* EditorOption.lineHeight */
      )) {
        this._lineHeight = this._editor.getOption(
          65
          /* EditorOption.lineHeight */
        );
      }
    }));
    this._register(this._editor.onDidScrollChange((e) => {
      if (e.scrollLeftChanged) {
        updateScrollLeftPosition();
      }
      if (e.scrollWidthChanged) {
        this._updateWidgetWidth();
      }
    }));
    this._register(this._editor.onDidChangeModel(() => {
      updateScrollLeftPosition();
      this._updateWidgetWidth();
    }));
    this._register(this._foldingIconStore);
    updateScrollLeftPosition();
    this._register(this._editor.onDidLayoutChange((e) => {
      this._updateWidgetWidth();
    }));
    this._updateWidgetWidth();
  }
  get lineNumbers() {
    return this._lineNumbers;
  }
  get lineNumberCount() {
    return this._lineNumbers.length;
  }
  getCurrentLines() {
    return this._lineNumbers;
  }
  setState(state) {
    this._clearStickyWidget();
    if (!state || !this._editor._getViewModel()) {
      return;
    }
    const futureWidgetHeight = state.startLineNumbers.length * this._lineHeight + state.lastLineRelativePosition;
    if (futureWidgetHeight > 0) {
      this._lastLineRelativePosition = state.lastLineRelativePosition;
      const lineNumbers = [...state.startLineNumbers];
      if (state.showEndForLine !== null) {
        lineNumbers[state.showEndForLine] = state.endLineNumbers[state.showEndForLine];
      }
      this._lineNumbers = lineNumbers;
    } else {
      this._lastLineRelativePosition = 0;
      this._lineNumbers = [];
    }
    this._renderRootNode();
  }
  _updateWidgetWidth() {
    const layoutInfo = this._editor.getLayoutInfo();
    const minimapSide = this._editor.getOption(
      71
      /* EditorOption.minimap */
    ).side;
    const lineNumbersWidth = minimapSide === "left" ? layoutInfo.contentLeft - layoutInfo.minimap.minimapCanvasOuterWidth : layoutInfo.contentLeft;
    this._lineNumbersDomNode.style.width = `${lineNumbersWidth}px`;
    this._linesDomNodeScrollable.style.setProperty("--vscode-editorStickyScroll-scrollableWidth", `${this._editor.getScrollWidth() - layoutInfo.verticalScrollbarWidth}px`);
    this._rootDomNode.style.width = `${layoutInfo.width - layoutInfo.minimap.minimapCanvasOuterWidth - layoutInfo.verticalScrollbarWidth}px`;
  }
  _clearStickyWidget() {
    this._stickyLines = [];
    this._foldingIconStore.clear();
    clearNode(this._lineNumbersDomNode);
    clearNode(this._linesDomNode);
    this._rootDomNode.style.display = "none";
  }
  _useFoldingOpacityTransition(requireTransitions) {
    this._lineNumbersDomNode.style.setProperty("--vscode-editorStickyScroll-foldingOpacityTransition", `opacity ${requireTransitions ? 0.5 : 0}s`);
  }
  _setFoldingIconsVisibility(allVisible) {
    for (const line of this._stickyLines) {
      const foldingIcon = line.foldingIcon;
      if (!foldingIcon) {
        continue;
      }
      foldingIcon.setVisible(allVisible ? true : foldingIcon.isCollapsed);
    }
  }
  _renderRootNode() {
    var _a;
    return __awaiter32(this, void 0, void 0, function* () {
      const foldingModel = yield (_a = FoldingController.get(this._editor)) === null || _a === void 0 ? void 0 : _a.getFoldingModel();
      const layoutInfo = this._editor.getLayoutInfo();
      for (const [index, line] of this._lineNumbers.entries()) {
        const renderedStickyLine = this._renderChildNode(index, line, layoutInfo, foldingModel);
        this._linesDomNode.appendChild(renderedStickyLine.lineDomNode);
        this._lineNumbersDomNode.appendChild(renderedStickyLine.lineNumberDomNode);
        this._stickyLines.push(renderedStickyLine);
      }
      if (foldingModel) {
        this._setFoldingHoverListeners();
        this._useFoldingOpacityTransition(!this._isOnGlyphMargin);
      }
      const widgetHeight = this._lineNumbers.length * this._lineHeight + this._lastLineRelativePosition;
      if (widgetHeight === 0) {
        this._clearStickyWidget();
        return;
      }
      this._rootDomNode.style.display = "block";
      this._lineNumbersDomNode.style.height = `${widgetHeight}px`;
      this._linesDomNodeScrollable.style.height = `${widgetHeight}px`;
      this._rootDomNode.style.height = `${widgetHeight}px`;
      const minimapSide = this._editor.getOption(
        71
        /* EditorOption.minimap */
      ).side;
      if (minimapSide === "left") {
        this._rootDomNode.style.marginLeft = layoutInfo.minimap.minimapCanvasOuterWidth + "px";
      } else {
        this._rootDomNode.style.marginLeft = "0px";
      }
      this._updateMinContentWidth();
      this._editor.layoutOverlayWidget(this);
    });
  }
  _setFoldingHoverListeners() {
    const showFoldingControls = this._editor.getOption(
      108
      /* EditorOption.showFoldingControls */
    );
    if (showFoldingControls !== "mouseover") {
      return;
    }
    this._foldingIconStore.add(addDisposableListener(this._lineNumbersDomNode, EventType.MOUSE_ENTER, (e) => {
      this._isOnGlyphMargin = true;
      this._setFoldingIconsVisibility(true);
    }));
    this._foldingIconStore.add(addDisposableListener(this._lineNumbersDomNode, EventType.MOUSE_LEAVE, () => {
      this._isOnGlyphMargin = false;
      this._useFoldingOpacityTransition(true);
      this._setFoldingIconsVisibility(false);
    }));
  }
  _renderChildNode(index, line, layoutInfo, foldingModel) {
    const viewModel = this._editor._getViewModel();
    const viewLineNumber = viewModel.coordinatesConverter.convertModelPositionToViewPosition(new Position(line, 1)).lineNumber;
    const lineRenderingData = viewModel.getViewLineRenderingData(viewLineNumber);
    const minimapSide = this._editor.getOption(
      71
      /* EditorOption.minimap */
    ).side;
    const lineNumberOption = this._editor.getOption(
      66
      /* EditorOption.lineNumbers */
    );
    let actualInlineDecorations;
    try {
      actualInlineDecorations = LineDecoration.filter(lineRenderingData.inlineDecorations, viewLineNumber, lineRenderingData.minColumn, lineRenderingData.maxColumn);
    } catch (err) {
      actualInlineDecorations = [];
    }
    const renderLineInput = new RenderLineInput(true, true, lineRenderingData.content, lineRenderingData.continuesWithWrappedLine, lineRenderingData.isBasicASCII, lineRenderingData.containsRTL, 0, lineRenderingData.tokens, actualInlineDecorations, lineRenderingData.tabSize, lineRenderingData.startVisibleColumn, 1, 1, 1, 500, "none", true, true, null);
    const sb = new StringBuilder(2e3);
    const renderOutput = renderViewLine(renderLineInput, sb);
    let newLine;
    if (_ttPolicy) {
      newLine = _ttPolicy.createHTML(sb.build());
    } else {
      newLine = sb.build();
    }
    const lineHTMLNode = document.createElement("span");
    lineHTMLNode.className = "sticky-line-content";
    lineHTMLNode.classList.add(`stickyLine${line}`);
    lineHTMLNode.style.lineHeight = `${this._lineHeight}px`;
    lineHTMLNode.innerHTML = newLine;
    const lineNumberHTMLNode = document.createElement("span");
    lineNumberHTMLNode.className = "sticky-line-number";
    lineNumberHTMLNode.style.lineHeight = `${this._lineHeight}px`;
    const lineNumbersWidth = minimapSide === "left" ? layoutInfo.contentLeft - layoutInfo.minimap.minimapCanvasOuterWidth : layoutInfo.contentLeft;
    lineNumberHTMLNode.style.width = `${lineNumbersWidth}px`;
    const innerLineNumberHTML = document.createElement("span");
    if (lineNumberOption.renderType === 1 || lineNumberOption.renderType === 3 && line % 10 === 0) {
      innerLineNumberHTML.innerText = line.toString();
    } else if (lineNumberOption.renderType === 2) {
      innerLineNumberHTML.innerText = Math.abs(line - this._editor.getPosition().lineNumber).toString();
    }
    innerLineNumberHTML.className = "sticky-line-number-inner";
    innerLineNumberHTML.style.lineHeight = `${this._lineHeight}px`;
    innerLineNumberHTML.style.width = `${layoutInfo.lineNumbersWidth}px`;
    innerLineNumberHTML.style.float = "left";
    if (minimapSide === "left") {
      innerLineNumberHTML.style.paddingLeft = `${layoutInfo.lineNumbersLeft - layoutInfo.minimap.minimapCanvasOuterWidth}px`;
    } else if (minimapSide === "right") {
      innerLineNumberHTML.style.paddingLeft = `${layoutInfo.lineNumbersLeft}px`;
    }
    lineNumberHTMLNode.appendChild(innerLineNumberHTML);
    const foldingIcon = this._renderFoldingIconForLine(lineNumberHTMLNode, foldingModel, index, line);
    this._editor.applyFontInfo(lineHTMLNode);
    this._editor.applyFontInfo(innerLineNumberHTML);
    lineHTMLNode.setAttribute("role", "listitem");
    lineHTMLNode.setAttribute(STICKY_LINE_INDEX_ATTR, String(index));
    lineHTMLNode.tabIndex = 0;
    lineNumberHTMLNode.style.lineHeight = `${this._lineHeight}px`;
    lineHTMLNode.style.lineHeight = `${this._lineHeight}px`;
    lineNumberHTMLNode.style.height = `${this._lineHeight}px`;
    lineHTMLNode.style.height = `${this._lineHeight}px`;
    const isLastLine = index === this._lineNumbers.length - 1;
    const lastLineZIndex = "0";
    const intermediateLineZIndex = "1";
    lineHTMLNode.style.zIndex = isLastLine ? lastLineZIndex : intermediateLineZIndex;
    lineNumberHTMLNode.style.zIndex = isLastLine ? lastLineZIndex : intermediateLineZIndex;
    const lastLineTop = `${index * this._lineHeight + this._lastLineRelativePosition + ((foldingIcon === null || foldingIcon === void 0 ? void 0 : foldingIcon.isCollapsed) ? 1 : 0)}px`;
    const intermediateLineTop = `${index * this._lineHeight}px`;
    lineHTMLNode.style.top = isLastLine ? lastLineTop : intermediateLineTop;
    lineNumberHTMLNode.style.top = isLastLine ? lastLineTop : intermediateLineTop;
    return new RenderedStickyLine(line, lineHTMLNode, lineNumberHTMLNode, foldingIcon, renderOutput.characterMapping);
  }
  _renderFoldingIconForLine(container, foldingModel, index, line) {
    const showFoldingControls = this._editor.getOption(
      108
      /* EditorOption.showFoldingControls */
    );
    if (!foldingModel || showFoldingControls === "never") {
      return;
    }
    const foldingRegions = foldingModel.regions;
    const indexOfFoldingRegion = foldingRegions.findRange(line);
    const startLineNumber = foldingRegions.getStartLineNumber(indexOfFoldingRegion);
    const isFoldingScope = line === startLineNumber;
    if (!isFoldingScope) {
      return;
    }
    const isCollapsed = foldingRegions.isCollapsed(indexOfFoldingRegion);
    const foldingIcon = new StickyFoldingIcon(isCollapsed, this._lineHeight);
    container.append(foldingIcon.domNode);
    foldingIcon.setVisible(this._isOnGlyphMargin ? true : isCollapsed || showFoldingControls === "always");
    this._foldingIconStore.add(addDisposableListener(foldingIcon.domNode, EventType.CLICK, () => {
      toggleCollapseState(foldingModel, Number.MAX_VALUE, [line]);
      foldingIcon.isCollapsed = !isCollapsed;
      const scrollTop = (isCollapsed ? this._editor.getTopForLineNumber(startLineNumber) : this._editor.getTopForLineNumber(foldingRegions.getEndLineNumber(indexOfFoldingRegion))) - this._lineHeight * index + 1;
      this._editor.setScrollTop(scrollTop);
    }));
    return foldingIcon;
  }
  _updateMinContentWidth() {
    this._minContentWidthInPx = 0;
    for (const stickyLine of this._stickyLines) {
      if (stickyLine.lineDomNode.scrollWidth > this._minContentWidthInPx) {
        this._minContentWidthInPx = stickyLine.lineDomNode.scrollWidth;
      }
    }
    this._minContentWidthInPx += this._editor.getLayoutInfo().verticalScrollbarWidth;
  }
  getId() {
    return "editor.contrib.stickyScrollWidget";
  }
  getDomNode() {
    return this._rootDomNode;
  }
  getPosition() {
    return {
      preference: null
    };
  }
  getMinContentWidthInPx() {
    return this._minContentWidthInPx;
  }
  focusLineWithIndex(index) {
    if (0 <= index && index < this._stickyLines.length) {
      this._stickyLines[index].lineDomNode.focus();
    }
  }
  /**
   * Given a leaf dom node, tries to find the editor position.
   */
  getEditorPositionFromNode(spanDomNode) {
    if (!spanDomNode || spanDomNode.children.length > 0) {
      return null;
    }
    const renderedStickyLine = this._getRenderedStickyLineFromChildDomNode(spanDomNode);
    if (!renderedStickyLine) {
      return null;
    }
    const column = getColumnOfNodeOffset(renderedStickyLine.characterMapping, spanDomNode, 0);
    return new Position(renderedStickyLine.lineNumber, column);
  }
  getLineNumberFromChildDomNode(domNode) {
    var _a, _b;
    return (_b = (_a = this._getRenderedStickyLineFromChildDomNode(domNode)) === null || _a === void 0 ? void 0 : _a.lineNumber) !== null && _b !== void 0 ? _b : null;
  }
  _getRenderedStickyLineFromChildDomNode(domNode) {
    const index = this.getStickyLineIndexFromChildDomNode(domNode);
    if (index === null || index < 0 || index >= this._stickyLines.length) {
      return null;
    }
    return this._stickyLines[index];
  }
  /**
   * Given a child dom node, tries to find the line number attribute
   * that was stored in the node. Returns null if none is found.
   */
  getStickyLineIndexFromChildDomNode(domNode) {
    while (domNode && domNode !== this._rootDomNode) {
      const line = domNode.getAttribute(STICKY_LINE_INDEX_ATTR);
      if (line) {
        return parseInt(line, 10);
      }
      domNode = domNode.parentElement;
    }
    return null;
  }
};
var RenderedStickyLine = class {
  constructor(lineNumber, lineDomNode, lineNumberDomNode, foldingIcon, characterMapping) {
    this.lineNumber = lineNumber;
    this.lineDomNode = lineDomNode;
    this.lineNumberDomNode = lineNumberDomNode;
    this.foldingIcon = foldingIcon;
    this.characterMapping = characterMapping;
  }
};
var StickyFoldingIcon = class {
  constructor(isCollapsed, dimension) {
    this.isCollapsed = isCollapsed;
    this.dimension = dimension;
    this.domNode = document.createElement("div");
    this.domNode.style.width = `${dimension}px`;
    this.domNode.style.height = `${dimension}px`;
    this.domNode.className = ThemeIcon.asClassName(isCollapsed ? foldingCollapsedIcon : foldingExpandedIcon);
  }
  setVisible(visible) {
    this.domNode.style.cursor = visible ? "pointer" : "default";
    this.domNode.style.opacity = visible ? "1" : "0";
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js
init_lifecycle();
init_languageFeatures();
init_cancellation();
init_async();
init_arrays();
init_event();
init_languageConfigurationRegistry();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js
init_lifecycle();
init_languageFeatures();
init_outlineModel();
init_async();
init_languageConfigurationRegistry();
init_errors();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollElement.js
var StickyRange = class {
  constructor(startLineNumber, endLineNumber) {
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
  }
};
var StickyElement = class {
  constructor(range, children, parent) {
    this.range = range;
    this.children = children;
    this.parent = parent;
  }
};
var StickyModel = class {
  constructor(uri, version, element, outlineProviderId) {
    this.uri = uri;
    this.version = version;
    this.element = element;
    this.outlineProviderId = outlineProviderId;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js
init_iterator();
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param36 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ModelProvider;
(function(ModelProvider2) {
  ModelProvider2["OUTLINE_MODEL"] = "outlineModel";
  ModelProvider2["FOLDING_PROVIDER_MODEL"] = "foldingProviderModel";
  ModelProvider2["INDENTATION_MODEL"] = "indentationModel";
})(ModelProvider || (ModelProvider = {}));
var Status;
(function(Status2) {
  Status2[Status2["VALID"] = 0] = "VALID";
  Status2[Status2["INVALID"] = 1] = "INVALID";
  Status2[Status2["CANCELED"] = 2] = "CANCELED";
})(Status || (Status = {}));
var StickyModelProvider = class StickyModelProvider2 extends Disposable {
  constructor(_editor, _languageConfigurationService, _languageFeaturesService, defaultModel) {
    super();
    this._editor = _editor;
    this._languageConfigurationService = _languageConfigurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._modelProviders = [];
    this._modelPromise = null;
    this._updateScheduler = this._register(new Delayer(300));
    this._updateOperation = this._register(new DisposableStore());
    const stickyModelFromCandidateOutlineProvider = new StickyModelFromCandidateOutlineProvider(_languageFeaturesService);
    const stickyModelFromSyntaxFoldingProvider = new StickyModelFromCandidateSyntaxFoldingProvider(this._editor, _languageFeaturesService);
    const stickyModelFromIndentationFoldingProvider = new StickyModelFromCandidateIndentationFoldingProvider(this._editor, _languageConfigurationService);
    switch (defaultModel) {
      case ModelProvider.OUTLINE_MODEL:
        this._modelProviders.push(stickyModelFromCandidateOutlineProvider);
        this._modelProviders.push(stickyModelFromSyntaxFoldingProvider);
        this._modelProviders.push(stickyModelFromIndentationFoldingProvider);
        break;
      case ModelProvider.FOLDING_PROVIDER_MODEL:
        this._modelProviders.push(stickyModelFromSyntaxFoldingProvider);
        this._modelProviders.push(stickyModelFromIndentationFoldingProvider);
        break;
      case ModelProvider.INDENTATION_MODEL:
        this._modelProviders.push(stickyModelFromIndentationFoldingProvider);
        break;
    }
  }
  _cancelModelPromise() {
    if (this._modelPromise) {
      this._modelPromise.cancel();
      this._modelPromise = null;
    }
  }
  update(textModel, textModelVersionId, token) {
    return __awaiter33(this, void 0, void 0, function* () {
      this._updateOperation.clear();
      this._updateOperation.add({
        dispose: () => {
          this._cancelModelPromise();
          this._updateScheduler.cancel();
        }
      });
      this._cancelModelPromise();
      return yield this._updateScheduler.trigger(() => __awaiter33(this, void 0, void 0, function* () {
        for (const modelProvider of this._modelProviders) {
          const { statusPromise, modelPromise } = modelProvider.computeStickyModel(textModel, textModelVersionId, token);
          this._modelPromise = modelPromise;
          const status2 = yield statusPromise;
          if (this._modelPromise !== modelPromise) {
            return null;
          }
          switch (status2) {
            case Status.CANCELED:
              this._updateOperation.clear();
              return null;
            case Status.VALID:
              return modelProvider.stickyModel;
          }
        }
        return null;
      })).catch((error) => {
        onUnexpectedError(error);
        return null;
      });
    });
  }
};
StickyModelProvider = __decorate36([
  __param36(1, ILanguageConfigurationService),
  __param36(2, ILanguageFeaturesService)
], StickyModelProvider);
var StickyModelCandidateProvider = class {
  constructor() {
    this._stickyModel = null;
  }
  get stickyModel() {
    return this._stickyModel;
  }
  _invalid() {
    this._stickyModel = null;
    return Status.INVALID;
  }
  computeStickyModel(textModel, modelVersionId, token) {
    if (token.isCancellationRequested || !this.isProviderValid(textModel)) {
      return { statusPromise: this._invalid(), modelPromise: null };
    }
    const providerModelPromise = createCancelablePromise((token2) => this.createModelFromProvider(textModel, modelVersionId, token2));
    return {
      statusPromise: providerModelPromise.then((providerModel) => {
        if (!this.isModelValid(providerModel)) {
          return this._invalid();
        }
        if (token.isCancellationRequested) {
          return Status.CANCELED;
        }
        this._stickyModel = this.createStickyModel(textModel, modelVersionId, token, providerModel);
        return Status.VALID;
      }).then(void 0, (err) => {
        onUnexpectedError(err);
        return Status.CANCELED;
      }),
      modelPromise: providerModelPromise
    };
  }
  /**
   * Method which checks whether the model returned by the provider is valid and can be used to compute a sticky model.
   * This method by default returns true.
   * @param model model returned by the provider
   * @returns boolean indicating whether the model is valid
   */
  isModelValid(model) {
    return true;
  }
  /**
   * Method which checks whether the provider is valid before applying it to find the provider model.
   * This method by default returns true.
   * @param textModel text-model of the editor
   * @returns boolean indicating whether the provider is valid
   */
  isProviderValid(textModel) {
    return true;
  }
};
var StickyModelFromCandidateOutlineProvider = class StickyModelFromCandidateOutlineProvider2 extends StickyModelCandidateProvider {
  constructor(_languageFeaturesService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
  }
  get provider() {
    return this._languageFeaturesService.documentSymbolProvider;
  }
  createModelFromProvider(textModel, modelVersionId, token) {
    return OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, textModel, token);
  }
  createStickyModel(textModel, modelVersionId, token, model) {
    var _a;
    const { stickyOutlineElement, providerID } = this._stickyModelFromOutlineModel(model, (_a = this._stickyModel) === null || _a === void 0 ? void 0 : _a.outlineProviderId);
    return new StickyModel(textModel.uri, modelVersionId, stickyOutlineElement, providerID);
  }
  isModelValid(model) {
    return model && model.children.size > 0;
  }
  _stickyModelFromOutlineModel(outlineModel, preferredProvider) {
    let outlineElements;
    if (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {
      const provider = Iterable.find(outlineModel.children.values(), (outlineGroupOfModel) => outlineGroupOfModel.id === preferredProvider);
      if (provider) {
        outlineElements = provider.children;
      } else {
        let tempID = "";
        let maxTotalSumOfRanges = -1;
        let optimalOutlineGroup = void 0;
        for (const [_key, outlineGroup] of outlineModel.children.entries()) {
          const totalSumRanges = this._findSumOfRangesOfGroup(outlineGroup);
          if (totalSumRanges > maxTotalSumOfRanges) {
            optimalOutlineGroup = outlineGroup;
            maxTotalSumOfRanges = totalSumRanges;
            tempID = outlineGroup.id;
          }
        }
        preferredProvider = tempID;
        outlineElements = optimalOutlineGroup.children;
      }
    } else {
      outlineElements = outlineModel.children;
    }
    const stickyChildren = [];
    const outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {
      const range1 = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);
      const range2 = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);
      return this._comparator(range1, range2);
    });
    for (const outlineElement of outlineElementsArray) {
      stickyChildren.push(this._stickyModelFromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));
    }
    const stickyOutlineElement = new StickyElement(void 0, stickyChildren, void 0);
    return {
      stickyOutlineElement,
      providerID: preferredProvider
    };
  }
  _stickyModelFromOutlineElement(outlineElement, previousStartLine) {
    const children = [];
    for (const child of outlineElement.children.values()) {
      if (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {
        if (child.symbol.selectionRange.startLineNumber !== previousStartLine) {
          children.push(this._stickyModelFromOutlineElement(child, child.symbol.selectionRange.startLineNumber));
        } else {
          for (const subchild of child.children.values()) {
            children.push(this._stickyModelFromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));
          }
        }
      }
    }
    children.sort((child1, child2) => this._comparator(child1.range, child2.range));
    const range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);
    return new StickyElement(range, children, void 0);
  }
  _comparator(range1, range2) {
    if (range1.startLineNumber !== range2.startLineNumber) {
      return range1.startLineNumber - range2.startLineNumber;
    } else {
      return range2.endLineNumber - range1.endLineNumber;
    }
  }
  _findSumOfRangesOfGroup(outline) {
    let res = 0;
    for (const child of outline.children.values()) {
      res += this._findSumOfRangesOfGroup(child);
    }
    if (outline instanceof OutlineElement) {
      return res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;
    } else {
      return res;
    }
  }
};
StickyModelFromCandidateOutlineProvider = __decorate36([
  __param36(0, ILanguageFeaturesService)
], StickyModelFromCandidateOutlineProvider);
var StickyModelFromCandidateFoldingProvider = class extends StickyModelCandidateProvider {
  constructor(editor2) {
    super();
    this._foldingLimitReporter = new RangesLimitReporter(editor2);
  }
  createStickyModel(textModel, modelVersionId, token, model) {
    const foldingElement = this._fromFoldingRegions(model);
    return new StickyModel(textModel.uri, modelVersionId, foldingElement, void 0);
  }
  isModelValid(model) {
    return model !== null;
  }
  _fromFoldingRegions(foldingRegions) {
    const length = foldingRegions.length;
    const orderedStickyElements = [];
    const stickyOutlineElement = new StickyElement(void 0, [], void 0);
    for (let i = 0; i < length; i++) {
      const parentIndex = foldingRegions.getParentIndex(i);
      let parentNode;
      if (parentIndex !== -1) {
        parentNode = orderedStickyElements[parentIndex];
      } else {
        parentNode = stickyOutlineElement;
      }
      const child = new StickyElement(new StickyRange(foldingRegions.getStartLineNumber(i), foldingRegions.getEndLineNumber(i) + 1), [], parentNode);
      parentNode.children.push(child);
      orderedStickyElements.push(child);
    }
    return stickyOutlineElement;
  }
};
var StickyModelFromCandidateIndentationFoldingProvider = class StickyModelFromCandidateIndentationFoldingProvider2 extends StickyModelFromCandidateFoldingProvider {
  constructor(editor2, _languageConfigurationService) {
    super(editor2);
    this._languageConfigurationService = _languageConfigurationService;
  }
  get provider() {
    return null;
  }
  createModelFromProvider(textModel, modelVersionId, token) {
    const provider = new IndentRangeProvider(textModel, this._languageConfigurationService, this._foldingLimitReporter);
    return provider.compute(token);
  }
};
StickyModelFromCandidateIndentationFoldingProvider = __decorate36([
  __param36(1, ILanguageConfigurationService)
], StickyModelFromCandidateIndentationFoldingProvider);
var StickyModelFromCandidateSyntaxFoldingProvider = class StickyModelFromCandidateSyntaxFoldingProvider2 extends StickyModelFromCandidateFoldingProvider {
  constructor(editor2, _languageFeaturesService) {
    super(editor2);
    this._languageFeaturesService = _languageFeaturesService;
  }
  get provider() {
    return this._languageFeaturesService.foldingRangeProvider;
  }
  isProviderValid(textModel) {
    const selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);
    return selectedProviders.length > 0;
  }
  createModelFromProvider(textModel, modelVersionId, token) {
    const selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);
    const provider = new SyntaxRangeProvider(textModel, selectedProviders, () => this.createModelFromProvider(textModel, modelVersionId, token), this._foldingLimitReporter, void 0);
    return provider.compute(token);
  }
};
StickyModelFromCandidateSyntaxFoldingProvider = __decorate36([
  __param36(1, ILanguageFeaturesService)
], StickyModelFromCandidateSyntaxFoldingProvider);

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js
var __decorate37 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param37 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StickyLineCandidate = class {
  constructor(startLineNumber, endLineNumber, nestingDepth) {
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
    this.nestingDepth = nestingDepth;
  }
};
var StickyLineCandidateProvider = class StickyLineCandidateProvider2 extends Disposable {
  constructor(editor2, _languageFeaturesService, _languageConfigurationService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
    this._languageConfigurationService = _languageConfigurationService;
    this._onDidChangeStickyScroll = this._register(new Emitter());
    this.onDidChangeStickyScroll = this._onDidChangeStickyScroll.event;
    this._options = null;
    this._model = null;
    this._cts = null;
    this._stickyModelProvider = null;
    this._editor = editor2;
    this._sessionStore = this._register(new DisposableStore());
    this._updateSoon = this._register(new RunOnceScheduler(() => this.update(), 50));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        113
        /* EditorOption.stickyScroll */
      )) {
        this.readConfiguration();
      }
    }));
    this.readConfiguration();
  }
  readConfiguration() {
    this._stickyModelProvider = null;
    this._sessionStore.clear();
    this._options = this._editor.getOption(
      113
      /* EditorOption.stickyScroll */
    );
    if (!this._options.enabled) {
      return;
    }
    this._stickyModelProvider = this._sessionStore.add(new StickyModelProvider(this._editor, this._languageConfigurationService, this._languageFeaturesService, this._options.defaultModel));
    this._sessionStore.add(this._editor.onDidChangeModel(() => {
      this._model = null;
      this._onDidChangeStickyScroll.fire();
      this.update();
    }));
    this._sessionStore.add(this._editor.onDidChangeHiddenAreas(() => this.update()));
    this._sessionStore.add(this._editor.onDidChangeModelContent(() => this._updateSoon.schedule()));
    this._sessionStore.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => this.update()));
    this.update();
  }
  getVersionId() {
    var _a;
    return (_a = this._model) === null || _a === void 0 ? void 0 : _a.version;
  }
  update() {
    var _a;
    return __awaiter34(this, void 0, void 0, function* () {
      (_a = this._cts) === null || _a === void 0 ? void 0 : _a.dispose(true);
      this._cts = new CancellationTokenSource();
      yield this.updateStickyModel(this._cts.token);
      this._onDidChangeStickyScroll.fire();
    });
  }
  updateStickyModel(token) {
    return __awaiter34(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._stickyModelProvider) {
        this._model = null;
        return;
      }
      const textModel = this._editor.getModel();
      const modelVersionId = textModel.getVersionId();
      const model = yield this._stickyModelProvider.update(textModel, modelVersionId, token);
      if (token.isCancellationRequested) {
        return;
      }
      this._model = model;
    });
  }
  updateIndex(index) {
    if (index === -1) {
      index = 0;
    } else if (index < 0) {
      index = -index - 2;
    }
    return index;
  }
  getCandidateStickyLinesIntersectingFromStickyModel(range, outlineModel, result, depth, lastStartLineNumber) {
    if (outlineModel.children.length === 0) {
      return;
    }
    let lastLine = lastStartLineNumber;
    const childrenStartLines = [];
    for (let i = 0; i < outlineModel.children.length; i++) {
      const child = outlineModel.children[i];
      if (child.range) {
        childrenStartLines.push(child.range.startLineNumber);
      }
    }
    const lowerBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber, (a, b) => {
      return a - b;
    }));
    const upperBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber + depth, (a, b) => {
      return a - b;
    }));
    for (let i = lowerBound; i <= upperBound; i++) {
      const child = outlineModel.children[i];
      if (!child) {
        return;
      }
      if (child.range) {
        const childStartLine = child.range.startLineNumber;
        const childEndLine = child.range.endLineNumber;
        if (range.startLineNumber <= childEndLine + 1 && childStartLine - 1 <= range.endLineNumber && childStartLine !== lastLine) {
          lastLine = childStartLine;
          result.push(new StickyLineCandidate(childStartLine, childEndLine - 1, depth + 1));
          this.getCandidateStickyLinesIntersectingFromStickyModel(range, child, result, depth + 1, childStartLine);
        }
      } else {
        this.getCandidateStickyLinesIntersectingFromStickyModel(range, child, result, depth, lastStartLineNumber);
      }
    }
  }
  getCandidateStickyLinesIntersecting(range) {
    var _a, _b;
    if (!((_a = this._model) === null || _a === void 0 ? void 0 : _a.element)) {
      return [];
    }
    let stickyLineCandidates = [];
    this.getCandidateStickyLinesIntersectingFromStickyModel(range, this._model.element, stickyLineCandidates, 0, -1);
    const hiddenRanges = (_b = this._editor._getViewModel()) === null || _b === void 0 ? void 0 : _b.getHiddenAreas();
    if (hiddenRanges) {
      for (const hiddenRange of hiddenRanges) {
        stickyLineCandidates = stickyLineCandidates.filter((stickyLine) => !(stickyLine.startLineNumber >= hiddenRange.startLineNumber && stickyLine.endLineNumber <= hiddenRange.endLineNumber + 1));
      }
    }
    return stickyLineCandidates;
  }
};
StickyLineCandidateProvider.ID = "store.contrib.stickyScrollController";
StickyLineCandidateProvider = __decorate37([
  __param37(1, ILanguageFeaturesService),
  __param37(2, ILanguageConfigurationService)
], StickyLineCandidateProvider);

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js
init_instantiation();
init_actions2();
init_contextkey();
init_editorContextKeys();
init_range();
init_position();
init_cancellation();
init_languageConfigurationRegistry();
init_languageFeatureDebounce();
init_dom();
init_mouseEvent();
var __decorate38 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param38 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StickyScrollController_1;
var StickyScrollController = StickyScrollController_1 = class StickyScrollController2 extends Disposable {
  constructor(_editor, _contextMenuService, _languageFeaturesService, _instaService, _languageConfigurationService, _languageFeatureDebounceService, _contextKeyService) {
    super();
    this._editor = _editor;
    this._contextMenuService = _contextMenuService;
    this._languageFeaturesService = _languageFeaturesService;
    this._instaService = _instaService;
    this._contextKeyService = _contextKeyService;
    this._sessionStore = new DisposableStore();
    this._maxStickyLines = Number.MAX_SAFE_INTEGER;
    this._candidateDefinitionsLength = -1;
    this._focusedStickyElementIndex = -1;
    this._enabled = false;
    this._focused = false;
    this._positionRevealed = false;
    this._onMouseDown = false;
    this._endLineNumbers = [];
    this._showEndForLine = null;
    this._stickyScrollWidget = new StickyScrollWidget(this._editor);
    this._stickyLineCandidateProvider = new StickyLineCandidateProvider(this._editor, _languageFeaturesService, _languageConfigurationService);
    this._register(this._stickyScrollWidget);
    this._register(this._stickyLineCandidateProvider);
    this._widgetState = new StickyScrollWidgetState([], [], 0);
    this._readConfiguration();
    const stickyScrollDomNode = this._stickyScrollWidget.getDomNode();
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        113
        /* EditorOption.stickyScroll */
      ) || e.hasChanged(
        71
        /* EditorOption.minimap */
      ) || e.hasChanged(
        65
        /* EditorOption.lineHeight */
      ) || e.hasChanged(
        108
        /* EditorOption.showFoldingControls */
      )) {
        this._readConfiguration();
      }
    }));
    this._register(addDisposableListener(stickyScrollDomNode, EventType.CONTEXT_MENU, (event) => __awaiter35(this, void 0, void 0, function* () {
      this._onContextMenu(event);
    })));
    this._stickyScrollFocusedContextKey = EditorContextKeys.stickyScrollFocused.bindTo(this._contextKeyService);
    this._stickyScrollVisibleContextKey = EditorContextKeys.stickyScrollVisible.bindTo(this._contextKeyService);
    const focusTracker = this._register(trackFocus(stickyScrollDomNode));
    this._register(focusTracker.onDidBlur((_) => {
      if (this._positionRevealed === false && stickyScrollDomNode.clientHeight === 0) {
        this._focusedStickyElementIndex = -1;
        this.focus();
      } else {
        this._disposeFocusStickyScrollStore();
      }
    }));
    this._register(focusTracker.onDidFocus((_) => {
      this.focus();
    }));
    this._registerMouseListeners();
    this._register(addDisposableListener(stickyScrollDomNode, EventType.MOUSE_DOWN, (e) => {
      this._onMouseDown = true;
    }));
  }
  get stickyScrollCandidateProvider() {
    return this._stickyLineCandidateProvider;
  }
  get stickyScrollWidgetState() {
    return this._widgetState;
  }
  static get(editor2) {
    return editor2.getContribution(StickyScrollController_1.ID);
  }
  _disposeFocusStickyScrollStore() {
    var _a;
    this._stickyScrollFocusedContextKey.set(false);
    (_a = this._focusDisposableStore) === null || _a === void 0 ? void 0 : _a.dispose();
    this._focused = false;
    this._positionRevealed = false;
    this._onMouseDown = false;
  }
  focus() {
    if (this._onMouseDown) {
      this._onMouseDown = false;
      this._editor.focus();
      return;
    }
    const focusState = this._stickyScrollFocusedContextKey.get();
    if (focusState === true) {
      return;
    }
    this._focused = true;
    this._focusDisposableStore = new DisposableStore();
    this._stickyScrollFocusedContextKey.set(true);
    this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumbers.length - 1;
    this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
  }
  focusNext() {
    if (this._focusedStickyElementIndex < this._stickyScrollWidget.lineNumberCount - 1) {
      this._focusNav(true);
    }
  }
  focusPrevious() {
    if (this._focusedStickyElementIndex > 0) {
      this._focusNav(false);
    }
  }
  selectEditor() {
    this._editor.focus();
  }
  // True is next, false is previous
  _focusNav(direction) {
    this._focusedStickyElementIndex = direction ? this._focusedStickyElementIndex + 1 : this._focusedStickyElementIndex - 1;
    this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
  }
  goToFocused() {
    const lineNumbers = this._stickyScrollWidget.lineNumbers;
    this._disposeFocusStickyScrollStore();
    this._revealPosition({ lineNumber: lineNumbers[this._focusedStickyElementIndex], column: 1 });
  }
  _revealPosition(position) {
    this._reveaInEditor(position, () => this._editor.revealPosition(position));
  }
  _revealLineInCenterIfOutsideViewport(position) {
    this._reveaInEditor(position, () => this._editor.revealLineInCenterIfOutsideViewport(
      position.lineNumber,
      0
      /* ScrollType.Smooth */
    ));
  }
  _reveaInEditor(position, revealFunction) {
    if (this._focused) {
      this._disposeFocusStickyScrollStore();
    }
    this._positionRevealed = true;
    revealFunction();
    this._editor.setSelection(Range.fromPositions(position));
    this._editor.focus();
  }
  _registerMouseListeners() {
    const sessionStore = this._register(new DisposableStore());
    const gesture = this._register(new ClickLinkGesture(this._editor, {
      extractLineNumberFromMouseEvent: (e) => {
        const position = this._stickyScrollWidget.getEditorPositionFromNode(e.target.element);
        return position ? position.lineNumber : 0;
      }
    }));
    const getMouseEventTarget = (mouseEvent) => {
      if (!this._editor.hasModel()) {
        return null;
      }
      if (mouseEvent.target.type !== 12 || mouseEvent.target.detail !== this._stickyScrollWidget.getId()) {
        return null;
      }
      const mouseTargetElement = mouseEvent.target.element;
      if (!mouseTargetElement || mouseTargetElement.innerText !== mouseTargetElement.innerHTML) {
        return null;
      }
      const position = this._stickyScrollWidget.getEditorPositionFromNode(mouseTargetElement);
      if (!position) {
        return null;
      }
      return {
        range: new Range(position.lineNumber, position.column, position.lineNumber, position.column + mouseTargetElement.innerText.length),
        textElement: mouseTargetElement
      };
    };
    const stickyScrollWidgetDomNode = this._stickyScrollWidget.getDomNode();
    this._register(addStandardDisposableListener(stickyScrollWidgetDomNode, EventType.CLICK, (mouseEvent) => {
      if (mouseEvent.ctrlKey || mouseEvent.altKey || mouseEvent.metaKey) {
        return;
      }
      if (!mouseEvent.leftButton) {
        return;
      }
      if (mouseEvent.shiftKey) {
        const lineIndex = this._stickyScrollWidget.getStickyLineIndexFromChildDomNode(mouseEvent.target);
        if (lineIndex === null) {
          return;
        }
        const position2 = new Position(this._endLineNumbers[lineIndex], 1);
        this._revealLineInCenterIfOutsideViewport(position2);
        return;
      }
      let position = this._stickyScrollWidget.getEditorPositionFromNode(mouseEvent.target);
      if (!position) {
        const lineNumber = this._stickyScrollWidget.getLineNumberFromChildDomNode(mouseEvent.target);
        if (lineNumber === null) {
          return;
        }
        position = new Position(lineNumber, 1);
      }
      this._revealPosition(position);
    }));
    this._register(addStandardDisposableListener(stickyScrollWidgetDomNode, EventType.MOUSE_MOVE, (mouseEvent) => {
      if (mouseEvent.shiftKey) {
        const currentEndForLineIndex = this._stickyScrollWidget.getStickyLineIndexFromChildDomNode(mouseEvent.target);
        if (currentEndForLineIndex === null || this._showEndForLine !== null && this._showEndForLine === currentEndForLineIndex) {
          return;
        }
        this._showEndForLine = currentEndForLineIndex;
        this._renderStickyScroll();
        return;
      }
      if (this._showEndForLine !== null) {
        this._showEndForLine = null;
        this._renderStickyScroll();
      }
    }));
    this._register(addDisposableListener(stickyScrollWidgetDomNode, EventType.MOUSE_LEAVE, (e) => {
      if (this._showEndForLine !== null) {
        this._showEndForLine = null;
        this._renderStickyScroll();
      }
    }));
    this._register(gesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, _keyboardEvent]) => {
      const mouseTarget = getMouseEventTarget(mouseEvent);
      if (!mouseTarget || !mouseEvent.hasTriggerModifier || !this._editor.hasModel()) {
        sessionStore.clear();
        return;
      }
      const { range, textElement } = mouseTarget;
      if (!range.equalsRange(this._stickyRangeProjectedOnEditor)) {
        this._stickyRangeProjectedOnEditor = range;
        sessionStore.clear();
      } else if (textElement.style.textDecoration === "underline") {
        return;
      }
      const cancellationToken = new CancellationTokenSource();
      sessionStore.add(toDisposable(() => cancellationToken.dispose(true)));
      let currentHTMLChild;
      getDefinitionsAtPosition(this._languageFeaturesService.definitionProvider, this._editor.getModel(), new Position(range.startLineNumber, range.startColumn + 1), cancellationToken.token).then((candidateDefinitions) => {
        if (cancellationToken.token.isCancellationRequested) {
          return;
        }
        if (candidateDefinitions.length !== 0) {
          this._candidateDefinitionsLength = candidateDefinitions.length;
          const childHTML = textElement;
          if (currentHTMLChild !== childHTML) {
            sessionStore.clear();
            currentHTMLChild = childHTML;
            currentHTMLChild.style.textDecoration = "underline";
            sessionStore.add(toDisposable(() => {
              currentHTMLChild.style.textDecoration = "none";
            }));
          } else if (!currentHTMLChild) {
            currentHTMLChild = childHTML;
            currentHTMLChild.style.textDecoration = "underline";
            sessionStore.add(toDisposable(() => {
              currentHTMLChild.style.textDecoration = "none";
            }));
          }
        } else {
          sessionStore.clear();
        }
      });
    }));
    this._register(gesture.onCancel(() => {
      sessionStore.clear();
    }));
    this._register(gesture.onExecute((e) => __awaiter35(this, void 0, void 0, function* () {
      if (e.target.type !== 12 || e.target.detail !== this._stickyScrollWidget.getId()) {
        return;
      }
      const position = this._stickyScrollWidget.getEditorPositionFromNode(e.target.element);
      if (!position) {
        return;
      }
      if (this._candidateDefinitionsLength > 1) {
        if (this._focused) {
          this._disposeFocusStickyScrollStore();
        }
        this._revealPosition({ lineNumber: position.lineNumber, column: 1 });
      }
      this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, { uri: this._editor.getModel().uri, range: this._stickyRangeProjectedOnEditor });
    })));
  }
  _onContextMenu(e) {
    const event = new StandardMouseEvent(e);
    this._contextMenuService.showContextMenu({
      menuId: MenuId.StickyScrollContext,
      getAnchor: () => event
    });
  }
  _readConfiguration() {
    const options = this._editor.getOption(
      113
      /* EditorOption.stickyScroll */
    );
    if (options.enabled === false) {
      this._editor.removeOverlayWidget(this._stickyScrollWidget);
      this._sessionStore.clear();
      this._enabled = false;
      return;
    } else if (options.enabled && !this._enabled) {
      this._editor.addOverlayWidget(this._stickyScrollWidget);
      this._sessionStore.add(this._editor.onDidScrollChange((e) => {
        if (e.scrollTopChanged) {
          this._showEndForLine = null;
          this._renderStickyScroll();
        }
      }));
      this._sessionStore.add(this._editor.onDidLayoutChange(() => this._onDidResize()));
      this._sessionStore.add(this._editor.onDidChangeModelTokens((e) => this._onTokensChange(e)));
      this._sessionStore.add(this._stickyLineCandidateProvider.onDidChangeStickyScroll(() => {
        this._showEndForLine = null;
        this._renderStickyScroll();
      }));
      this._enabled = true;
    }
    const lineNumberOption = this._editor.getOption(
      66
      /* EditorOption.lineNumbers */
    );
    if (lineNumberOption.renderType === 2) {
      this._sessionStore.add(this._editor.onDidChangeCursorPosition(() => {
        this._showEndForLine = null;
        this._renderStickyScroll();
      }));
    }
  }
  _needsUpdate(event) {
    const stickyLineNumbers = this._stickyScrollWidget.getCurrentLines();
    for (const stickyLineNumber of stickyLineNumbers) {
      for (const range of event.ranges) {
        if (stickyLineNumber >= range.fromLineNumber && stickyLineNumber <= range.toLineNumber) {
          return true;
        }
      }
    }
    return false;
  }
  _onTokensChange(event) {
    if (this._needsUpdate(event)) {
      this._renderStickyScroll();
    }
  }
  _onDidResize() {
    const layoutInfo = this._editor.getLayoutInfo();
    const theoreticalLines = layoutInfo.height / this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    this._maxStickyLines = Math.round(theoreticalLines * 0.25);
  }
  _renderStickyScroll() {
    const model = this._editor.getModel();
    if (!model || model.isTooLargeForTokenization()) {
      this._stickyScrollWidget.setState(void 0);
      return;
    }
    const stickyLineVersion = this._stickyLineCandidateProvider.getVersionId();
    if (stickyLineVersion === void 0 || stickyLineVersion === model.getVersionId()) {
      this._widgetState = this.findScrollWidgetState();
      this._stickyScrollVisibleContextKey.set(!(this._widgetState.startLineNumbers.length === 0));
      if (!this._focused) {
        this._stickyScrollWidget.setState(this._widgetState);
      } else {
        if (this._focusedStickyElementIndex === -1) {
          this._stickyScrollWidget.setState(this._widgetState);
          this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;
          if (this._focusedStickyElementIndex !== -1) {
            this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
          }
        } else {
          const focusedStickyElementLineNumber = this._stickyScrollWidget.lineNumbers[this._focusedStickyElementIndex];
          this._stickyScrollWidget.setState(this._widgetState);
          if (this._stickyScrollWidget.lineNumberCount === 0) {
            this._focusedStickyElementIndex = -1;
          } else {
            const previousFocusedLineNumberExists = this._stickyScrollWidget.lineNumbers.includes(focusedStickyElementLineNumber);
            if (!previousFocusedLineNumberExists) {
              this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;
            }
            this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
          }
        }
      }
    }
  }
  findScrollWidgetState() {
    const lineHeight = this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    const maxNumberStickyLines = Math.min(this._maxStickyLines, this._editor.getOption(
      113
      /* EditorOption.stickyScroll */
    ).maxLineCount);
    const scrollTop = this._editor.getScrollTop();
    let lastLineRelativePosition = 0;
    const startLineNumbers = [];
    const endLineNumbers = [];
    const arrayVisibleRanges = this._editor.getVisibleRanges();
    if (arrayVisibleRanges.length !== 0) {
      const fullVisibleRange = new StickyRange(arrayVisibleRanges[0].startLineNumber, arrayVisibleRanges[arrayVisibleRanges.length - 1].endLineNumber);
      const candidateRanges = this._stickyLineCandidateProvider.getCandidateStickyLinesIntersecting(fullVisibleRange);
      for (const range of candidateRanges) {
        const start = range.startLineNumber;
        const end = range.endLineNumber;
        const depth = range.nestingDepth;
        if (end - start > 0) {
          const topOfElementAtDepth = (depth - 1) * lineHeight;
          const bottomOfElementAtDepth = depth * lineHeight;
          const bottomOfBeginningLine = this._editor.getBottomForLineNumber(start) - scrollTop;
          const topOfEndLine = this._editor.getTopForLineNumber(end) - scrollTop;
          const bottomOfEndLine = this._editor.getBottomForLineNumber(end) - scrollTop;
          if (topOfElementAtDepth > topOfEndLine && topOfElementAtDepth <= bottomOfEndLine) {
            startLineNumbers.push(start);
            endLineNumbers.push(end + 1);
            lastLineRelativePosition = bottomOfEndLine - bottomOfElementAtDepth;
            break;
          } else if (bottomOfElementAtDepth > bottomOfBeginningLine && bottomOfElementAtDepth <= bottomOfEndLine) {
            startLineNumbers.push(start);
            endLineNumbers.push(end + 1);
          }
          if (startLineNumbers.length === maxNumberStickyLines) {
            break;
          }
        }
      }
    }
    this._endLineNumbers = endLineNumbers;
    return new StickyScrollWidgetState(startLineNumbers, endLineNumbers, lastLineRelativePosition, this._showEndForLine);
  }
  dispose() {
    super.dispose();
    this._sessionStore.dispose();
  }
};
StickyScrollController.ID = "store.contrib.stickyScrollController";
StickyScrollController = StickyScrollController_1 = __decorate38([
  __param38(1, IContextMenuService),
  __param38(2, ILanguageFeaturesService),
  __param38(3, IInstantiationService),
  __param38(4, ILanguageConfigurationService),
  __param38(5, ILanguageFeatureDebounceService),
  __param38(6, IContextKeyService)
], StickyScrollController);

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js
var __awaiter36 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ToggleStickyScroll = class extends Action2 {
  constructor() {
    super({
      id: "editor.action.toggleStickyScroll",
      title: {
        value: localize("toggleStickyScroll", "Toggle Sticky Scroll"),
        mnemonicTitle: localize({ key: "mitoggleStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Toggle Sticky Scroll"),
        original: "Toggle Sticky Scroll"
      },
      category: Categories.View,
      toggled: {
        condition: ContextKeyExpr.equals("config.editor.stickyScroll.enabled", true),
        title: localize("stickyScroll", "Sticky Scroll"),
        mnemonicTitle: localize({ key: "miStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Sticky Scroll")
      },
      menu: [
        { id: MenuId.CommandPalette },
        { id: MenuId.MenubarAppearanceMenu, group: "4_editor", order: 3 },
        { id: MenuId.StickyScrollContext }
      ]
    });
  }
  run(accessor) {
    return __awaiter36(this, void 0, void 0, function* () {
      const configurationService = accessor.get(IConfigurationService);
      const newValue = !configurationService.getValue("editor.stickyScroll.enabled");
      return configurationService.updateValue("editor.stickyScroll.enabled", newValue);
    });
  }
};
var weight2 = 100;
var FocusStickyScroll = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.focusStickyScroll",
      title: {
        value: localize("focusStickyScroll", "Focus Sticky Scroll"),
        mnemonicTitle: localize({ key: "mifocusStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Focus Sticky Scroll"),
        original: "Focus Sticky Scroll"
      },
      precondition: ContextKeyExpr.and(ContextKeyExpr.has("config.editor.stickyScroll.enabled"), EditorContextKeys.stickyScrollVisible),
      menu: [
        { id: MenuId.CommandPalette }
      ]
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a;
    (_a = StickyScrollController.get(editor2)) === null || _a === void 0 ? void 0 : _a.focus();
  }
};
var SelectNextStickyScrollLine = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.selectNextStickyScrollLine",
      title: {
        value: localize("selectNextStickyScrollLine.title", "Select next sticky scroll line"),
        original: "Select next sticky scroll line"
      },
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight: weight2,
        primary: 18
        /* KeyCode.DownArrow */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a;
    (_a = StickyScrollController.get(editor2)) === null || _a === void 0 ? void 0 : _a.focusNext();
  }
};
var SelectPreviousStickyScrollLine = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.selectPreviousStickyScrollLine",
      title: {
        value: localize("selectPreviousStickyScrollLine.title", "Select previous sticky scroll line"),
        original: "Select previous sticky scroll line"
      },
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight: weight2,
        primary: 16
        /* KeyCode.UpArrow */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a;
    (_a = StickyScrollController.get(editor2)) === null || _a === void 0 ? void 0 : _a.focusPrevious();
  }
};
var GoToStickyScrollLine = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.goToFocusedStickyScrollLine",
      title: {
        value: localize("goToFocusedStickyScrollLine.title", "Go to focused sticky scroll line"),
        original: "Go to focused sticky scroll line"
      },
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight: weight2,
        primary: 3
        /* KeyCode.Enter */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a;
    (_a = StickyScrollController.get(editor2)) === null || _a === void 0 ? void 0 : _a.goToFocused();
  }
};
var SelectEditor = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.selectEditor",
      title: {
        value: localize("selectEditor.title", "Select Editor"),
        original: "Select Editor"
      },
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight: weight2,
        primary: 9
        /* KeyCode.Escape */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a;
    (_a = StickyScrollController.get(editor2)) === null || _a === void 0 ? void 0 : _a.selectEditor();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollContribution.js
init_actions2();
registerEditorContribution(
  StickyScrollController.ID,
  StickyScrollController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerAction2(ToggleStickyScroll);
registerAction2(FocusStickyScroll);
registerAction2(SelectPreviousStickyScrollLine);
registerAction2(SelectNextStickyScrollLine);
registerAction2(GoToStickyScrollLine);
registerAction2(SelectEditor);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestInlineCompletions.js
init_cancellation();
init_filters();
init_iterator();
init_lifecycle();
init_editorExtensions();
init_codeEditorService();
init_range();
init_languageFeatures();
init_instantiation();
var __decorate39 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param39 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter37 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EditorContribution_1;
var SuggestInlineCompletion = class {
  constructor(range, insertText, filterText, additionalTextEdits, command, completion) {
    this.range = range;
    this.insertText = insertText;
    this.filterText = filterText;
    this.additionalTextEdits = additionalTextEdits;
    this.command = command;
    this.completion = completion;
  }
};
var InlineCompletionResults = class InlineCompletionResults2 extends RefCountedDisposable {
  constructor(model, line, word, completionModel, completions, _suggestMemoryService) {
    super(completions.disposable);
    this.model = model;
    this.line = line;
    this.word = word;
    this.completionModel = completionModel;
    this._suggestMemoryService = _suggestMemoryService;
  }
  canBeReused(model, line, word) {
    return this.model === model && this.line === line && this.word.word.length > 0 && this.word.startColumn === word.startColumn && this.word.endColumn < word.endColumn && this.completionModel.getIncompleteProvider().size === 0;
  }
  get items() {
    var _a;
    const result = [];
    const { items } = this.completionModel;
    const selectedIndex = this._suggestMemoryService.select(this.model, { lineNumber: this.line, column: this.word.endColumn + this.completionModel.lineContext.characterCountDelta }, items);
    const first2 = Iterable.slice(items, selectedIndex);
    const second = Iterable.slice(items, 0, selectedIndex);
    let resolveCount = 5;
    for (const item of Iterable.concat(first2, second)) {
      if (item.score === FuzzyScore.Default) {
        continue;
      }
      const range = new Range(
        item.editStart.lineNumber,
        item.editStart.column,
        item.editInsertEnd.lineNumber,
        item.editInsertEnd.column + this.completionModel.lineContext.characterCountDelta
        // end PLUS character delta
      );
      const insertText = item.completion.insertTextRules && item.completion.insertTextRules & 4 ? { snippet: item.completion.insertText } : item.completion.insertText;
      result.push(new SuggestInlineCompletion(range, insertText, (_a = item.filterTextLow) !== null && _a !== void 0 ? _a : item.labelLow, item.completion.additionalTextEdits, item.completion.command, item));
      if (resolveCount-- >= 0) {
        item.resolve(CancellationToken.None);
      }
    }
    return result;
  }
};
InlineCompletionResults = __decorate39([
  __param39(5, ISuggestMemoryService)
], InlineCompletionResults);
var SuggestInlineCompletions = class SuggestInlineCompletions2 {
  constructor(_getEditorOption, _languageFeatureService, _clipboardService, _suggestMemoryService) {
    this._getEditorOption = _getEditorOption;
    this._languageFeatureService = _languageFeatureService;
    this._clipboardService = _clipboardService;
    this._suggestMemoryService = _suggestMemoryService;
  }
  provideInlineCompletions(model, position, context, token) {
    var _a;
    return __awaiter37(this, void 0, void 0, function* () {
      if (context.selectedSuggestionInfo) {
        return;
      }
      const config = this._getEditorOption(87, model);
      if (QuickSuggestionsOptions.isAllOff(config)) {
        return;
      }
      model.tokenization.tokenizeIfCheap(position.lineNumber);
      const lineTokens = model.tokenization.getLineTokens(position.lineNumber);
      const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(position.column - 1 - 1, 0)));
      if (QuickSuggestionsOptions.valueFor(config, tokenType) !== "inline") {
        return void 0;
      }
      let wordInfo = model.getWordAtPosition(position);
      let triggerCharacterInfo;
      if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word)) {
        triggerCharacterInfo = this._getTriggerCharacterInfo(model, position);
      }
      if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word) && !triggerCharacterInfo) {
        return;
      }
      if (!wordInfo) {
        wordInfo = model.getWordUntilPosition(position);
      }
      if (wordInfo.endColumn !== position.column) {
        return;
      }
      let result;
      const leadingLineContents = model.getValueInRange(new Range(position.lineNumber, 1, position.lineNumber, position.column));
      if (!triggerCharacterInfo && ((_a = this._lastResult) === null || _a === void 0 ? void 0 : _a.canBeReused(model, position.lineNumber, wordInfo))) {
        const newLineContext = new LineContext(leadingLineContents, position.column - this._lastResult.word.endColumn);
        this._lastResult.completionModel.lineContext = newLineContext;
        this._lastResult.acquire();
        result = this._lastResult;
      } else {
        const completions = yield provideSuggestionItems(this._languageFeatureService.completionProvider, model, position, new CompletionOptions(void 0, void 0, triggerCharacterInfo === null || triggerCharacterInfo === void 0 ? void 0 : triggerCharacterInfo.providers), triggerCharacterInfo && { triggerKind: 1, triggerCharacter: triggerCharacterInfo.ch }, token);
        let clipboardText;
        if (completions.needsClipboard) {
          clipboardText = yield this._clipboardService.readText();
        }
        const completionModel = new CompletionModel(completions.items, position.column, new LineContext(leadingLineContents, 0), WordDistance.None, this._getEditorOption(116, model), this._getEditorOption(110, model), { boostFullMatch: false, firstMatchCanBeWeak: false }, clipboardText);
        result = new InlineCompletionResults(model, position.lineNumber, wordInfo, completionModel, completions, this._suggestMemoryService);
      }
      this._lastResult = result;
      return result;
    });
  }
  handleItemDidShow(_completions, item) {
    item.completion.resolve(CancellationToken.None);
  }
  freeInlineCompletions(result) {
    result.release();
  }
  _getTriggerCharacterInfo(model, position) {
    var _a;
    const ch = model.getValueInRange(Range.fromPositions({ lineNumber: position.lineNumber, column: position.column - 1 }, position));
    const providers = /* @__PURE__ */ new Set();
    for (const provider of this._languageFeatureService.completionProvider.all(model)) {
      if ((_a = provider.triggerCharacters) === null || _a === void 0 ? void 0 : _a.includes(ch)) {
        providers.add(provider);
      }
    }
    if (providers.size === 0) {
      return void 0;
    }
    return { providers, ch };
  }
};
SuggestInlineCompletions = __decorate39([
  __param39(1, ILanguageFeaturesService),
  __param39(2, IClipboardService),
  __param39(3, ISuggestMemoryService)
], SuggestInlineCompletions);
var EditorContribution = EditorContribution_1 = class EditorContribution2 {
  constructor(_editor, languageFeatureService, editorService, instaService) {
    if (++EditorContribution_1._counter === 1) {
      const provider = instaService.createInstance(SuggestInlineCompletions, (id, model) => {
        var _a;
        const editor2 = (_a = editorService.listCodeEditors().find((editor3) => editor3.getModel() === model)) !== null && _a !== void 0 ? _a : _editor;
        return editor2.getOption(id);
      });
      EditorContribution_1._disposable = languageFeatureService.inlineCompletionsProvider.register("*", provider);
    }
  }
  dispose() {
    var _a;
    if (--EditorContribution_1._counter === 0) {
      (_a = EditorContribution_1._disposable) === null || _a === void 0 ? void 0 : _a.dispose();
      EditorContribution_1._disposable = void 0;
    }
  }
};
EditorContribution._counter = 0;
EditorContribution = EditorContribution_1 = __decorate39([
  __param39(1, ILanguageFeaturesService),
  __param39(2, ICodeEditorService),
  __param39(3, IInstantiationService)
], EditorContribution);
registerEditorContribution(
  "suggest.inlineCompletionsProvider",
  EditorContribution,
  0
  /* EditorContributionInstantiation.Eager */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/tokenization/browser/tokenization.js
init_stopwatch();
init_editorExtensions();
init_nls();
var ForceRetokenizeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.forceRetokenize",
      label: localize("forceRetokenize", "Developer: Force Retokenize"),
      alias: "Developer: Force Retokenize",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    model.tokenization.resetTokenization();
    const sw = new StopWatch();
    model.tokenization.forceTokenization(model.getLineCount());
    sw.stop();
    console.log(`tokenization took ${sw.elapsed()}`);
  }
};
registerEditorAction(ForceRetokenizeAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js
init_aria();
init_nls();
init_actions2();
init_contextkey();
var ToggleTabFocusModeAction = class _ToggleTabFocusModeAction extends Action2 {
  constructor() {
    super({
      id: _ToggleTabFocusModeAction.ID,
      title: { value: localize({ key: "toggle.tabMovesFocus", comment: ["Turn on/off use of tab key for moving focus around VS Code"] }, "Toggle Tab Key Moves Focus"), original: "Toggle Tab Key Moves Focus" },
      precondition: void 0,
      keybinding: {
        primary: 2048 | 43,
        mac: {
          primary: 256 | 1024 | 43
          /* KeyCode.KeyM */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      f1: true
    });
  }
  run(accessor) {
    const context = accessor.get(IContextKeyService).getContextKeyValue("focusedView") === "terminal" ? "terminalFocus" : "editorFocus";
    const oldValue = TabFocus.getTabFocusMode(context);
    const newValue = !oldValue;
    TabFocus.setTabFocusMode(newValue, context);
    if (newValue) {
      alert(localize("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element"));
    } else {
      alert(localize("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
    }
  }
};
ToggleTabFocusModeAction.ID = "editor.action.toggleTabFocusMode";
registerAction2(ToggleTabFocusModeAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js
init_async();
init_codicons();
init_htmlContent();
init_lifecycle();
init_platform();
init_strings();
init_editorExtensions();
init_editorOptions();
init_textModel();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.css";
init_editorWorker();
init_language();

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js
init_dom();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/bannerController.css";
init_actions();
init_lifecycle();
init_instantiation();
init_themables();
var __decorate40 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param40 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BANNER_ELEMENT_HEIGHT = 26;
var BannerController = class BannerController2 extends Disposable {
  constructor(_editor, instantiationService) {
    super();
    this._editor = _editor;
    this.instantiationService = instantiationService;
    this.banner = this._register(this.instantiationService.createInstance(Banner));
  }
  hide() {
    this._editor.setBanner(null, 0);
    this.banner.clear();
  }
  show(item) {
    this.banner.show(Object.assign(Object.assign({}, item), { onClose: () => {
      var _a;
      this.hide();
      (_a = item.onClose) === null || _a === void 0 ? void 0 : _a.call(item);
    } }));
    this._editor.setBanner(this.banner.element, BANNER_ELEMENT_HEIGHT);
  }
};
BannerController = __decorate40([
  __param40(1, IInstantiationService)
], BannerController);
var Banner = class Banner2 extends Disposable {
  constructor(instantiationService) {
    super();
    this.instantiationService = instantiationService;
    this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
    this.element = $("div.editor-banner");
    this.element.tabIndex = 0;
  }
  getAriaLabel(item) {
    if (item.ariaLabel) {
      return item.ariaLabel;
    }
    if (typeof item.message === "string") {
      return item.message;
    }
    return void 0;
  }
  getBannerMessage(message) {
    if (typeof message === "string") {
      const element = $("span");
      element.innerText = message;
      return element;
    }
    return this.markdownRenderer.render(message).element;
  }
  clear() {
    clearNode(this.element);
  }
  show(item) {
    clearNode(this.element);
    const ariaLabel = this.getAriaLabel(item);
    if (ariaLabel) {
      this.element.setAttribute("aria-label", ariaLabel);
    }
    const iconContainer = append(this.element, $("div.icon-container"));
    iconContainer.setAttribute("aria-hidden", "true");
    if (item.icon) {
      iconContainer.appendChild($(`div${ThemeIcon.asCSSSelector(item.icon)}`));
    }
    const messageContainer = append(this.element, $("div.message-container"));
    messageContainer.setAttribute("aria-hidden", "true");
    messageContainer.appendChild(this.getBannerMessage(item.message));
    this.messageActionsContainer = append(this.element, $("div.message-actions-container"));
    if (item.actions) {
      for (const action of item.actions) {
        this._register(this.instantiationService.createInstance(Link, this.messageActionsContainer, Object.assign(Object.assign({}, action), { tabIndex: -1 }), {}));
      }
    }
    const actionBarContainer = append(this.element, $("div.action-container"));
    this.actionBar = this._register(new ActionBar(actionBarContainer));
    this.actionBar.push(this._register(new Action("banner.close", "Close Banner", ThemeIcon.asClassName(widgetClose), true, () => {
      if (typeof item.onClose === "function") {
        item.onClose();
      }
    })), { icon: true, label: false });
    this.actionBar.setFocusable(false);
  }
};
Banner = __decorate40([
  __param40(0, IInstantiationService)
], Banner);

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js
init_nls();
init_configuration();
init_instantiation();
init_opener();
var __decorate41 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param41 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter38 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var warningIcon = registerIcon("extensions-warning-message", Codicon.warning, localize("warningIcon", "Icon shown with a warning message in the extensions editor."));
var UnicodeHighlighter = class UnicodeHighlighter2 extends Disposable {
  constructor(_editor, _editorWorkerService, _workspaceTrustService, instantiationService) {
    super();
    this._editor = _editor;
    this._editorWorkerService = _editorWorkerService;
    this._workspaceTrustService = _workspaceTrustService;
    this._highlighter = null;
    this._bannerClosed = false;
    this._updateState = (state) => {
      if (state && state.hasMore) {
        if (this._bannerClosed) {
          return;
        }
        const max = Math.max(state.ambiguousCharacterCount, state.nonBasicAsciiCharacterCount, state.invisibleCharacterCount);
        let data;
        if (state.nonBasicAsciiCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters", "This document contains many non-basic ASCII unicode characters"),
            command: new DisableHighlightingOfNonBasicAsciiCharactersAction()
          };
        } else if (state.ambiguousCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters", "This document contains many ambiguous unicode characters"),
            command: new DisableHighlightingOfAmbiguousCharactersAction()
          };
        } else if (state.invisibleCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters", "This document contains many invisible unicode characters"),
            command: new DisableHighlightingOfInvisibleCharactersAction()
          };
        } else {
          throw new Error("Unreachable");
        }
        this._bannerController.show({
          id: "unicodeHighlightBanner",
          message: data.message,
          icon: warningIcon,
          actions: [
            {
              label: data.command.shortLabel,
              href: `command:${data.command.id}`
            }
          ],
          onClose: () => {
            this._bannerClosed = true;
          }
        });
      } else {
        this._bannerController.hide();
      }
    };
    this._bannerController = this._register(instantiationService.createInstance(BannerController, _editor));
    this._register(this._editor.onDidChangeModel(() => {
      this._bannerClosed = false;
      this._updateHighlighter();
    }));
    this._options = _editor.getOption(
      123
      /* EditorOption.unicodeHighlighting */
    );
    this._register(_workspaceTrustService.onDidChangeTrust((e) => {
      this._updateHighlighter();
    }));
    this._register(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        123
        /* EditorOption.unicodeHighlighting */
      )) {
        this._options = _editor.getOption(
          123
          /* EditorOption.unicodeHighlighting */
        );
        this._updateHighlighter();
      }
    }));
    this._updateHighlighter();
  }
  dispose() {
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    super.dispose();
  }
  _updateHighlighter() {
    this._updateState(null);
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const options = resolveOptions(this._workspaceTrustService.isWorkspaceTrusted(), this._options);
    if ([
      options.nonBasicASCII,
      options.ambiguousCharacters,
      options.invisibleCharacters
    ].every((option) => option === false)) {
      return;
    }
    const highlightOptions = {
      nonBasicASCII: options.nonBasicASCII,
      ambiguousCharacters: options.ambiguousCharacters,
      invisibleCharacters: options.invisibleCharacters,
      includeComments: options.includeComments,
      includeStrings: options.includeStrings,
      allowedCodePoints: Object.keys(options.allowedCharacters).map((c) => c.codePointAt(0)),
      allowedLocales: Object.keys(options.allowedLocales).map((locale) => {
        if (locale === "_os") {
          const osLocale = new Intl.NumberFormat().resolvedOptions().locale;
          return osLocale;
        } else if (locale === "_vscode") {
          return language;
        }
        return locale;
      })
    };
    if (this._editorWorkerService.canComputeUnicodeHighlights(this._editor.getModel().uri)) {
      this._highlighter = new DocumentUnicodeHighlighter(this._editor, highlightOptions, this._updateState, this._editorWorkerService);
    } else {
      this._highlighter = new ViewportUnicodeHighlighter(this._editor, highlightOptions, this._updateState);
    }
  }
  getDecorationInfo(decoration2) {
    if (this._highlighter) {
      return this._highlighter.getDecorationInfo(decoration2);
    }
    return null;
  }
};
UnicodeHighlighter.ID = "editor.contrib.unicodeHighlighter";
UnicodeHighlighter = __decorate41([
  __param41(1, IEditorWorkerService),
  __param41(2, IWorkspaceTrustManagementService),
  __param41(3, IInstantiationService)
], UnicodeHighlighter);
function resolveOptions(trusted, options) {
  return {
    nonBasicASCII: options.nonBasicASCII === inUntrustedWorkspace ? !trusted : options.nonBasicASCII,
    ambiguousCharacters: options.ambiguousCharacters,
    invisibleCharacters: options.invisibleCharacters,
    includeComments: options.includeComments === inUntrustedWorkspace ? !trusted : options.includeComments,
    includeStrings: options.includeStrings === inUntrustedWorkspace ? !trusted : options.includeStrings,
    allowedCharacters: options.allowedCharacters,
    allowedLocales: options.allowedLocales
  };
}
var DocumentUnicodeHighlighter = class DocumentUnicodeHighlighter2 extends Disposable {
  constructor(_editor, _options, _updateState, _editorWorkerService) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._editorWorkerService = _editorWorkerService;
    this._model = this._editor.getModel();
    this._decorations = this._editor.createDecorationsCollection();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear();
    super.dispose();
  }
  _update() {
    if (this._model.isDisposed()) {
      return;
    }
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const modelVersionId = this._model.getVersionId();
    this._editorWorkerService.computedUnicodeHighlights(this._model.uri, this._options).then((info) => {
      if (this._model.isDisposed()) {
        return;
      }
      if (this._model.getVersionId() !== modelVersionId) {
        return;
      }
      this._updateState(info);
      const decorations = [];
      if (!info.hasMore) {
        for (const range of info.ranges) {
          decorations.push({
            range,
            options: Decorations.instance.getDecorationFromOptions(this._options)
          });
        }
      }
      this._decorations.set(decorations);
    });
  }
  getDecorationInfo(decoration2) {
    if (!this._decorations.has(decoration2)) {
      return null;
    }
    const model = this._editor.getModel();
    if (!isModelDecorationVisible(model, decoration2)) {
      return null;
    }
    const text = model.getValueInRange(decoration2.range);
    return {
      reason: computeReason(text, this._options),
      inComment: isModelDecorationInComment(model, decoration2),
      inString: isModelDecorationInString(model, decoration2)
    };
  }
};
DocumentUnicodeHighlighter = __decorate41([
  __param41(3, IEditorWorkerService)
], DocumentUnicodeHighlighter);
var ViewportUnicodeHighlighter = class extends Disposable {
  constructor(_editor, _options, _updateState) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._model = this._editor.getModel();
    this._decorations = this._editor.createDecorationsCollection();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidLayoutChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidScrollChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeHiddenAreas(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear();
    super.dispose();
  }
  _update() {
    if (this._model.isDisposed()) {
      return;
    }
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const ranges = this._editor.getVisibleRanges();
    const decorations = [];
    const totalResult = {
      ranges: [],
      ambiguousCharacterCount: 0,
      invisibleCharacterCount: 0,
      nonBasicAsciiCharacterCount: 0,
      hasMore: false
    };
    for (const range of ranges) {
      const result = UnicodeTextModelHighlighter.computeUnicodeHighlights(this._model, this._options, range);
      for (const r of result.ranges) {
        totalResult.ranges.push(r);
      }
      totalResult.ambiguousCharacterCount += totalResult.ambiguousCharacterCount;
      totalResult.invisibleCharacterCount += totalResult.invisibleCharacterCount;
      totalResult.nonBasicAsciiCharacterCount += totalResult.nonBasicAsciiCharacterCount;
      totalResult.hasMore = totalResult.hasMore || result.hasMore;
    }
    if (!totalResult.hasMore) {
      for (const range of totalResult.ranges) {
        decorations.push({ range, options: Decorations.instance.getDecorationFromOptions(this._options) });
      }
    }
    this._updateState(totalResult);
    this._decorations.set(decorations);
  }
  getDecorationInfo(decoration2) {
    if (!this._decorations.has(decoration2)) {
      return null;
    }
    const model = this._editor.getModel();
    const text = model.getValueInRange(decoration2.range);
    if (!isModelDecorationVisible(model, decoration2)) {
      return null;
    }
    return {
      reason: computeReason(text, this._options),
      inComment: isModelDecorationInComment(model, decoration2),
      inString: isModelDecorationInString(model, decoration2)
    };
  }
};
var UnicodeHighlighterHoverParticipant = class UnicodeHighlighterHoverParticipant2 {
  constructor(_editor, _languageService, _openerService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this.hoverOrdinal = 5;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const unicodeHighlighter = this._editor.getContribution(UnicodeHighlighter.ID);
    if (!unicodeHighlighter) {
      return [];
    }
    const result = [];
    const existedReason = /* @__PURE__ */ new Set();
    let index = 300;
    for (const d of lineDecorations) {
      const highlightInfo = unicodeHighlighter.getDecorationInfo(d);
      if (!highlightInfo) {
        continue;
      }
      const char = model.getValueInRange(d.range);
      const codePoint = char.codePointAt(0);
      const codePointStr = formatCodePointMarkdown(codePoint);
      let reason;
      switch (highlightInfo.reason.kind) {
        case 0: {
          if (isBasicASCII(highlightInfo.reason.confusableWith)) {
            reason = localize("unicodeHighlight.characterIsAmbiguousASCII", "The character {0} could be confused with the ASCII character {1}, which is more common in source code.", codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
          } else {
            reason = localize("unicodeHighlight.characterIsAmbiguous", "The character {0} could be confused with the character {1}, which is more common in source code.", codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
          }
          break;
        }
        case 1:
          reason = localize("unicodeHighlight.characterIsInvisible", "The character {0} is invisible.", codePointStr);
          break;
        case 2:
          reason = localize("unicodeHighlight.characterIsNonBasicAscii", "The character {0} is not a basic ASCII character.", codePointStr);
          break;
      }
      if (existedReason.has(reason)) {
        continue;
      }
      existedReason.add(reason);
      const adjustSettingsArgs = {
        codePoint,
        reason: highlightInfo.reason,
        inComment: highlightInfo.inComment,
        inString: highlightInfo.inString
      };
      const adjustSettings = localize("unicodeHighlight.adjustSettings", "Adjust settings");
      const uri = `command:${ShowExcludeOptions.ID}?${encodeURIComponent(JSON.stringify(adjustSettingsArgs))}`;
      const markdown = new MarkdownString("", true).appendMarkdown(reason).appendText(" ").appendLink(uri, adjustSettings);
      result.push(new MarkdownHover(this, d.range, [markdown], false, index++));
    }
    return result;
  }
  renderHoverParts(context, hoverParts) {
    return renderMarkdownHovers(context, hoverParts, this._editor, this._languageService, this._openerService);
  }
};
UnicodeHighlighterHoverParticipant = __decorate41([
  __param41(1, ILanguageService),
  __param41(2, IOpenerService)
], UnicodeHighlighterHoverParticipant);
function codePointToHex(codePoint) {
  return `U+${codePoint.toString(16).padStart(4, "0")}`;
}
function formatCodePointMarkdown(codePoint) {
  let value = `\`${codePointToHex(codePoint)}\``;
  if (!InvisibleCharacters.isInvisibleCharacter(codePoint)) {
    value += ` "${`${renderCodePointAsInlineCode(codePoint)}`}"`;
  }
  return value;
}
function renderCodePointAsInlineCode(codePoint) {
  if (codePoint === 96) {
    return "`` ` ``";
  }
  return "`" + String.fromCodePoint(codePoint) + "`";
}
function computeReason(char, options) {
  return UnicodeTextModelHighlighter.computeUnicodeHighlightReason(char, options);
}
var Decorations = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  getDecorationFromOptions(options) {
    return this.getDecoration(!options.includeComments, !options.includeStrings);
  }
  getDecoration(hideInComments, hideInStrings) {
    const key = `${hideInComments}${hideInStrings}`;
    let options = this.map.get(key);
    if (!options) {
      options = ModelDecorationOptions.createDynamic({
        description: "unicode-highlight",
        stickiness: 1,
        className: "unicode-highlight",
        showIfCollapsed: true,
        overviewRuler: null,
        minimap: null,
        hideInCommentTokens: hideInComments,
        hideInStringTokens: hideInStrings
      });
      this.map.set(key, options);
    }
    return options;
  }
};
Decorations.instance = new Decorations();
var DisableHighlightingInCommentsAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingInComments", "Disable highlighting of characters in comments"),
      alias: "Disable highlighting of characters in comments",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingInComments.shortLabel", "Disable Highlight In Comments");
  }
  run(accessor, editor2, args) {
    return __awaiter38(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter38(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.includeComments,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
};
DisableHighlightingInCommentsAction.ID = "editor.action.unicodeHighlight.disableHighlightingInComments";
var DisableHighlightingInStringsAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingInStrings", "Disable highlighting of characters in strings"),
      alias: "Disable highlighting of characters in strings",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingInStrings.shortLabel", "Disable Highlight In Strings");
  }
  run(accessor, editor2, args) {
    return __awaiter38(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter38(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.includeStrings,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
};
DisableHighlightingInStringsAction.ID = "editor.action.unicodeHighlight.disableHighlightingInStrings";
var DisableHighlightingOfAmbiguousCharactersAction = class _DisableHighlightingOfAmbiguousCharactersAction extends EditorAction {
  constructor() {
    super({
      id: _DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters", "Disable highlighting of ambiguous characters"),
      alias: "Disable highlighting of ambiguous characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel", "Disable Ambiguous Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter38(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter38(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.ambiguousCharacters,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
};
DisableHighlightingOfAmbiguousCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters";
var DisableHighlightingOfInvisibleCharactersAction = class _DisableHighlightingOfInvisibleCharactersAction extends EditorAction {
  constructor() {
    super({
      id: _DisableHighlightingOfInvisibleCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfInvisibleCharacters", "Disable highlighting of invisible characters"),
      alias: "Disable highlighting of invisible characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel", "Disable Invisible Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter38(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter38(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.invisibleCharacters,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
};
DisableHighlightingOfInvisibleCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters";
var DisableHighlightingOfNonBasicAsciiCharactersAction = class _DisableHighlightingOfNonBasicAsciiCharactersAction extends EditorAction {
  constructor() {
    super({
      id: _DisableHighlightingOfNonBasicAsciiCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters", "Disable highlighting of non basic ASCII characters"),
      alias: "Disable highlighting of non basic ASCII characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel", "Disable Non ASCII Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter38(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter38(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.nonBasicASCII,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
};
DisableHighlightingOfNonBasicAsciiCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters";
var ShowExcludeOptions = class _ShowExcludeOptions extends EditorAction {
  constructor() {
    super({
      id: _ShowExcludeOptions.ID,
      label: localize("action.unicodeHighlight.showExcludeOptions", "Show Exclude Options"),
      alias: "Show Exclude Options",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    return __awaiter38(this, void 0, void 0, function* () {
      const { codePoint, reason, inString, inComment } = args;
      const char = String.fromCodePoint(codePoint);
      const quickPickService = accessor.get(IQuickInputService);
      const configurationService = accessor.get(IConfigurationService);
      function getExcludeCharFromBeingHighlightedLabel(codePoint2) {
        if (InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
          return localize("unicodeHighlight.excludeInvisibleCharFromBeingHighlighted", "Exclude {0} (invisible character) from being highlighted", codePointToHex(codePoint2));
        }
        return localize("unicodeHighlight.excludeCharFromBeingHighlighted", "Exclude {0} from being highlighted", `${codePointToHex(codePoint2)} "${char}"`);
      }
      const options = [];
      if (reason.kind === 0) {
        for (const locale of reason.notAmbiguousInLocales) {
          options.push({
            label: localize("unicodeHighlight.allowCommonCharactersInLanguage", 'Allow unicode characters that are more common in the language "{0}".', locale),
            run: () => __awaiter38(this, void 0, void 0, function* () {
              excludeLocaleFromBeingHighlighted(configurationService, [locale]);
            })
          });
        }
      }
      options.push({
        label: getExcludeCharFromBeingHighlightedLabel(codePoint),
        run: () => excludeCharFromBeingHighlighted(configurationService, [codePoint])
      });
      if (inComment) {
        const action = new DisableHighlightingInCommentsAction();
        options.push({ label: action.label, run: () => __awaiter38(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (inString) {
        const action = new DisableHighlightingInStringsAction();
        options.push({ label: action.label, run: () => __awaiter38(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      }
      if (reason.kind === 0) {
        const action = new DisableHighlightingOfAmbiguousCharactersAction();
        options.push({ label: action.label, run: () => __awaiter38(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (reason.kind === 1) {
        const action = new DisableHighlightingOfInvisibleCharactersAction();
        options.push({ label: action.label, run: () => __awaiter38(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (reason.kind === 2) {
        const action = new DisableHighlightingOfNonBasicAsciiCharactersAction();
        options.push({ label: action.label, run: () => __awaiter38(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else {
        expectNever(reason);
      }
      const result = yield quickPickService.pick(options, { title: localize("unicodeHighlight.configureUnicodeHighlightOptions", "Configure Unicode Highlight Options") });
      if (result) {
        yield result.run();
      }
    });
  }
};
ShowExcludeOptions.ID = "editor.action.unicodeHighlight.showExcludeOptions";
function excludeCharFromBeingHighlighted(configurationService, charCodes) {
  return __awaiter38(this, void 0, void 0, function* () {
    const existingValue = configurationService.getValue(unicodeHighlightConfigKeys.allowedCharacters);
    let value;
    if (typeof existingValue === "object" && existingValue) {
      value = existingValue;
    } else {
      value = {};
    }
    for (const charCode of charCodes) {
      value[String.fromCodePoint(charCode)] = true;
    }
    yield configurationService.updateValue(
      unicodeHighlightConfigKeys.allowedCharacters,
      value,
      2
      /* ConfigurationTarget.USER */
    );
  });
}
function excludeLocaleFromBeingHighlighted(configurationService, locales) {
  var _a;
  return __awaiter38(this, void 0, void 0, function* () {
    const existingValue = (_a = configurationService.inspect(unicodeHighlightConfigKeys.allowedLocales).user) === null || _a === void 0 ? void 0 : _a.value;
    let value;
    if (typeof existingValue === "object" && existingValue) {
      value = Object.assign({}, existingValue);
    } else {
      value = {};
    }
    for (const locale of locales) {
      value[locale] = true;
    }
    yield configurationService.updateValue(
      unicodeHighlightConfigKeys.allowedLocales,
      value,
      2
      /* ConfigurationTarget.USER */
    );
  });
}
function expectNever(value) {
  throw new Error(`Unexpected value: ${value}`);
}
registerEditorAction(DisableHighlightingOfAmbiguousCharactersAction);
registerEditorAction(DisableHighlightingOfInvisibleCharactersAction);
registerEditorAction(DisableHighlightingOfNonBasicAsciiCharactersAction);
registerEditorAction(ShowExcludeOptions);
registerEditorContribution(
  UnicodeHighlighter.ID,
  UnicodeHighlighter,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
HoverParticipantRegistry.register(UnicodeHighlighterHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators.js
init_lifecycle();
init_resources();
init_editorExtensions();
init_codeEditorService();
init_nls();
var __decorate42 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param42 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter39 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ignoreUnusualLineTerminators = "ignoreUnusualLineTerminators";
function writeIgnoreState(codeEditorService, model, state) {
  codeEditorService.setModelProperty(model.uri, ignoreUnusualLineTerminators, state);
}
function readIgnoreState(codeEditorService, model) {
  return codeEditorService.getModelProperty(model.uri, ignoreUnusualLineTerminators);
}
var UnusualLineTerminatorsDetector = class UnusualLineTerminatorsDetector2 extends Disposable {
  constructor(_editor, _dialogService, _codeEditorService) {
    super();
    this._editor = _editor;
    this._dialogService = _dialogService;
    this._codeEditorService = _codeEditorService;
    this._isPresentingDialog = false;
    this._config = this._editor.getOption(
      124
      /* EditorOption.unusualLineTerminators */
    );
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        124
        /* EditorOption.unusualLineTerminators */
      )) {
        this._config = this._editor.getOption(
          124
          /* EditorOption.unusualLineTerminators */
        );
        this._checkForUnusualLineTerminators();
      }
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._checkForUnusualLineTerminators();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      if (e.isUndoing) {
        return;
      }
      this._checkForUnusualLineTerminators();
    }));
    this._checkForUnusualLineTerminators();
  }
  _checkForUnusualLineTerminators() {
    return __awaiter39(this, void 0, void 0, function* () {
      if (this._config === "off") {
        return;
      }
      if (!this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      if (!model.mightContainUnusualLineTerminators()) {
        return;
      }
      const ignoreState = readIgnoreState(this._codeEditorService, model);
      if (ignoreState === true) {
        return;
      }
      if (this._editor.getOption(
        89
        /* EditorOption.readOnly */
      )) {
        return;
      }
      if (this._config === "auto") {
        model.removeUnusualLineTerminators(this._editor.getSelections());
        return;
      }
      if (this._isPresentingDialog) {
        return;
      }
      let result;
      try {
        this._isPresentingDialog = true;
        result = yield this._dialogService.confirm({
          title: localize("unusualLineTerminators.title", "Unusual Line Terminators"),
          message: localize("unusualLineTerminators.message", "Detected unusual line terminators"),
          detail: localize("unusualLineTerminators.detail", "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", basename(model.uri)),
          primaryButton: localize({ key: "unusualLineTerminators.fix", comment: ["&& denotes a mnemonic"] }, "&&Remove Unusual Line Terminators"),
          cancelButton: localize("unusualLineTerminators.ignore", "Ignore")
        });
      } finally {
        this._isPresentingDialog = false;
      }
      if (!result.confirmed) {
        writeIgnoreState(this._codeEditorService, model, true);
        return;
      }
      model.removeUnusualLineTerminators(this._editor.getSelections());
    });
  }
};
UnusualLineTerminatorsDetector.ID = "editor.contrib.unusualLineTerminatorsDetector";
UnusualLineTerminatorsDetector = __decorate42([
  __param42(1, IDialogService),
  __param42(2, ICodeEditorService)
], UnusualLineTerminatorsDetector);
registerEditorContribution(
  UnusualLineTerminatorsDetector.ID,
  UnusualLineTerminatorsDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js
init_aria();
init_arrays();
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_languages();
init_nls();
init_contextkey();
init_languageFeatures();
init_iterator();
var __decorate43 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param43 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var WordHighlighterContribution_1;
var ctxHasWordHighlights = new RawContextKey("hasWordHighlights", false);
function getOccurrencesAtPosition(registry, model, position, token) {
  const orderedByScore = registry.ordered(model);
  return first(orderedByScore.map((provider) => () => {
    return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(void 0, onUnexpectedExternalError);
  }), isNonEmptyArray);
}
var OccurenceAtPositionRequest = class {
  constructor(_model, _selection, _wordSeparators) {
    this._model = _model;
    this._selection = _selection;
    this._wordSeparators = _wordSeparators;
    this._wordRange = this._getCurrentWordRange(_model, _selection);
    this._result = null;
  }
  get result() {
    if (!this._result) {
      this._result = createCancelablePromise((token) => this._compute(this._model, this._selection, this._wordSeparators, token));
    }
    return this._result;
  }
  _getCurrentWordRange(model, selection) {
    const word = model.getWordAtPosition(selection.getPosition());
    if (word) {
      return new Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
    }
    return null;
  }
  isValid(model, selection, decorations) {
    const lineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endColumn = selection.endColumn;
    const currentWordRange = this._getCurrentWordRange(model, selection);
    let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));
    for (let i = 0, len = decorations.length; !requestIsValid && i < len; i++) {
      const range = decorations.getRange(i);
      if (range && range.startLineNumber === lineNumber) {
        if (range.startColumn <= startColumn && range.endColumn >= endColumn) {
          requestIsValid = true;
        }
      }
    }
    return requestIsValid;
  }
  cancel() {
    this.result.cancel();
  }
};
var SemanticOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators, providers) {
    super(model, selection, wordSeparators);
    this._providers = providers;
  }
  _compute(model, selection, wordSeparators, token) {
    return getOccurrencesAtPosition(this._providers, model, selection.getPosition(), token).then((value) => value || []);
  }
};
var TextualOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators) {
    super(model, selection, wordSeparators);
    this._selectionIsEmpty = selection.isEmpty();
  }
  _compute(model, selection, wordSeparators, token) {
    return timeout(250, token).then(() => {
      if (!selection.isEmpty()) {
        return [];
      }
      const word = model.getWordAtPosition(selection.getPosition());
      if (!word || word.word.length > 1e3) {
        return [];
      }
      const matches = model.findMatches(word.word, true, false, true, wordSeparators, false);
      return matches.map((m) => {
        return {
          range: m.range,
          kind: DocumentHighlightKind.Text
        };
      });
    });
  }
  isValid(model, selection, decorations) {
    const currentSelectionIsEmpty = selection.isEmpty();
    if (this._selectionIsEmpty !== currentSelectionIsEmpty) {
      return false;
    }
    return super.isValid(model, selection, decorations);
  }
};
function computeOccurencesAtPosition(registry, model, selection, wordSeparators) {
  if (registry.has(model)) {
    return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators, registry);
  }
  return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);
}
registerModelAndPositionCommand("_executeDocumentHighlights", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  return getOccurrencesAtPosition(languageFeaturesService.documentHighlightProvider, model, position, CancellationToken.None);
});
var WordHighlighter = class {
  constructor(editor2, providers, linkedHighlighters, contextKeyService) {
    this.toUnhook = new DisposableStore();
    this.workerRequestTokenId = 0;
    this.workerRequestCompleted = false;
    this.workerRequestValue = [];
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
    this.editor = editor2;
    this.providers = providers;
    this.linkedHighlighters = linkedHighlighters;
    this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);
    this._ignorePositionChangeEvent = false;
    this.occurrencesHighlight = this.editor.getOption(
      79
      /* EditorOption.occurrencesHighlight */
    );
    this.model = this.editor.getModel();
    this.toUnhook.add(editor2.onDidChangeCursorPosition((e) => {
      if (this._ignorePositionChangeEvent) {
        return;
      }
      if (!this.occurrencesHighlight) {
        return;
      }
      this._onPositionChanged(e);
    }));
    this.toUnhook.add(editor2.onDidChangeModelContent((e) => {
      this._stopAll();
    }));
    this.toUnhook.add(editor2.onDidChangeConfiguration((e) => {
      const newValue = this.editor.getOption(
        79
        /* EditorOption.occurrencesHighlight */
      );
      if (this.occurrencesHighlight !== newValue) {
        this.occurrencesHighlight = newValue;
        this._stopAll();
      }
    }));
    this.decorations = this.editor.createDecorationsCollection();
    this.workerRequestTokenId = 0;
    this.workerRequest = null;
    this.workerRequestCompleted = false;
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
  }
  hasDecorations() {
    return this.decorations.length > 0;
  }
  restore() {
    if (!this.occurrencesHighlight) {
      return;
    }
    this._run();
  }
  stop() {
    if (!this.occurrencesHighlight) {
      return;
    }
    this._stopAll();
  }
  _getSortedHighlights() {
    return this.decorations.getRanges().sort(Range.compareRangesUsingStarts);
  }
  moveNext() {
    const highlights = this._getSortedHighlights();
    const index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    const newIndex = (index + 1) % highlights.length;
    const dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  moveBack() {
    const highlights = this._getSortedHighlights();
    const index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    const newIndex = (index - 1 + highlights.length) % highlights.length;
    const dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  _removeDecorations() {
    if (this.decorations.length > 0) {
      this.decorations.clear();
      this._hasWordHighlights.set(false);
    }
  }
  _stopAll() {
    this._removeDecorations();
    if (this.renderDecorationsTimer !== -1) {
      clearTimeout(this.renderDecorationsTimer);
      this.renderDecorationsTimer = -1;
    }
    if (this.workerRequest !== null) {
      this.workerRequest.cancel();
      this.workerRequest = null;
    }
    if (!this.workerRequestCompleted) {
      this.workerRequestTokenId++;
      this.workerRequestCompleted = true;
    }
  }
  _onPositionChanged(e) {
    if (!this.occurrencesHighlight) {
      this._stopAll();
      return;
    }
    if (e.reason !== 3) {
      this._stopAll();
      return;
    }
    this._run();
  }
  _getWord() {
    const editorSelection = this.editor.getSelection();
    const lineNumber = editorSelection.startLineNumber;
    const startColumn = editorSelection.startColumn;
    return this.model.getWordAtPosition({
      lineNumber,
      column: startColumn
    });
  }
  _run() {
    const editorSelection = this.editor.getSelection();
    if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
      this._stopAll();
      return;
    }
    const startColumn = editorSelection.startColumn;
    const endColumn = editorSelection.endColumn;
    const word = this._getWord();
    if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
      this._stopAll();
      return;
    }
    const workerRequestIsValid = this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this.decorations);
    this.lastCursorPositionChangeTime = (/* @__PURE__ */ new Date()).getTime();
    if (workerRequestIsValid) {
      if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
        clearTimeout(this.renderDecorationsTimer);
        this.renderDecorationsTimer = -1;
        this._beginRenderDecorations();
      }
    } else {
      this._stopAll();
      const myRequestId = ++this.workerRequestTokenId;
      this.workerRequestCompleted = false;
      this.workerRequest = computeOccurencesAtPosition(this.providers, this.model, this.editor.getSelection(), this.editor.getOption(
        128
        /* EditorOption.wordSeparators */
      ));
      this.workerRequest.result.then((data) => {
        if (myRequestId === this.workerRequestTokenId) {
          this.workerRequestCompleted = true;
          this.workerRequestValue = data || [];
          this._beginRenderDecorations();
        }
      }, onUnexpectedError);
    }
  }
  _beginRenderDecorations() {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const minimumRenderTime = this.lastCursorPositionChangeTime + 250;
    if (currentTime >= minimumRenderTime) {
      this.renderDecorationsTimer = -1;
      this.renderDecorations();
    } else {
      this.renderDecorationsTimer = setTimeout(() => {
        this.renderDecorations();
      }, minimumRenderTime - currentTime);
    }
  }
  renderDecorations() {
    this.renderDecorationsTimer = -1;
    const decorations = [];
    for (const info of this.workerRequestValue) {
      if (info.range) {
        decorations.push({
          range: info.range,
          options: getHighlightDecorationOptions(info.kind)
        });
      }
    }
    this.decorations.set(decorations);
    this._hasWordHighlights.set(this.hasDecorations());
    for (const other of this.linkedHighlighters()) {
      if ((other === null || other === void 0 ? void 0 : other.editor.getModel()) === this.editor.getModel()) {
        other._stopAll();
        other.decorations.set(decorations);
        other._hasWordHighlights.set(other.hasDecorations());
      }
    }
  }
  dispose() {
    this._stopAll();
    this.toUnhook.dispose();
  }
};
var WordHighlighterContribution = WordHighlighterContribution_1 = class WordHighlighterContribution2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(WordHighlighterContribution_1.ID);
  }
  constructor(editor2, contextKeyService, languageFeaturesService) {
    super();
    this.wordHighlighter = null;
    this.linkedContributions = /* @__PURE__ */ new Set();
    const createWordHighlighterIfPossible = () => {
      if (editor2.hasModel()) {
        this.wordHighlighter = new WordHighlighter(editor2, languageFeaturesService.documentHighlightProvider, () => Iterable.map(this.linkedContributions, (c) => c.wordHighlighter), contextKeyService);
      }
    };
    this._register(editor2.onDidChangeModel((e) => {
      if (this.wordHighlighter) {
        this.wordHighlighter.dispose();
        this.wordHighlighter = null;
      }
      createWordHighlighterIfPossible();
    }));
    createWordHighlighterIfPossible();
  }
  saveViewState() {
    if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) {
      return true;
    }
    return false;
  }
  moveNext() {
    var _a;
    (_a = this.wordHighlighter) === null || _a === void 0 ? void 0 : _a.moveNext();
  }
  moveBack() {
    var _a;
    (_a = this.wordHighlighter) === null || _a === void 0 ? void 0 : _a.moveBack();
  }
  restoreViewState(state) {
    if (this.wordHighlighter && state) {
      this.wordHighlighter.restore();
    }
  }
  stopHighlighting() {
    var _a;
    (_a = this.wordHighlighter) === null || _a === void 0 ? void 0 : _a.stop();
  }
  linkWordHighlighters(editor2) {
    const other = WordHighlighterContribution_1.get(editor2);
    if (!other) {
      return Disposable.None;
    }
    this.linkedContributions.add(other);
    other.linkedContributions.add(this);
    return toDisposable(() => {
      this.linkedContributions.delete(other);
      other.linkedContributions.delete(this);
    });
  }
  dispose() {
    if (this.wordHighlighter) {
      this.wordHighlighter.dispose();
      this.wordHighlighter = null;
    }
    super.dispose();
  }
};
WordHighlighterContribution.ID = "editor.contrib.wordHighlighter";
WordHighlighterContribution = WordHighlighterContribution_1 = __decorate43([
  __param43(1, IContextKeyService),
  __param43(2, ILanguageFeaturesService)
], WordHighlighterContribution);
var WordHighlightNavigationAction = class extends EditorAction {
  constructor(next, opts) {
    super(opts);
    this._isNext = next;
  }
  run(accessor, editor2) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    if (this._isNext) {
      controller.moveNext();
    } else {
      controller.moveBack();
    }
  }
};
var NextWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(true, {
      id: "editor.action.wordHighlight.next",
      label: localize("wordHighlight.next.label", "Go to Next Symbol Highlight"),
      alias: "Go to Next Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var PrevWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(false, {
      id: "editor.action.wordHighlight.prev",
      label: localize("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
      alias: "Go to Previous Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var TriggerWordHighlightAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.wordHighlight.trigger",
      label: localize("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
      alias: "Trigger Symbol Highlight",
      precondition: ctxHasWordHighlights.toNegated(),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2, args) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    controller.restoreViewState(true);
  }
};
registerEditorContribution(
  WordHighlighterContribution.ID,
  WordHighlighterContribution,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(NextWordHighlightAction);
registerEditorAction(PrevWordHighlightAction);
registerEditorAction(TriggerWordHighlightAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/wordOperations/browser/wordOperations.js
init_editorExtensions();
init_editorOptions();
init_wordCharacterClassifier();
init_position();
init_range();
init_selection();
init_editorContextKeys();
init_languageConfigurationRegistry();
init_nls();
init_contextkey();
var MoveWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._inSelectionMode = opts.inSelectionMode;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    ));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const result = selections.map((sel) => {
      const inPosition = new Position(sel.positionLineNumber, sel.positionColumn);
      const outPosition = this._move(wordSeparators, model, inPosition, this._wordNavigationType);
      return this._moveTo(sel, outPosition, this._inSelectionMode);
    });
    model.pushStackElement();
    editor2._getViewModel().setCursorStates("moveWordCommand", 3, result.map((r) => CursorState.fromModelSelection(r)));
    if (result.length === 1) {
      const pos = new Position(result[0].positionLineNumber, result[0].positionColumn);
      editor2.revealPosition(
        pos,
        0
        /* ScrollType.Smooth */
      );
    }
  }
  _moveTo(from, to, inSelectionMode) {
    if (inSelectionMode) {
      return new Selection(from.selectionStartLineNumber, from.selectionStartColumn, to.lineNumber, to.column);
    } else {
      return new Selection(to.lineNumber, to.column, to.lineNumber, to.column);
    }
  }
};
var WordLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordOperations.moveWordLeft(wordSeparators, model, position, wordNavigationType);
  }
};
var WordRightCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordOperations.moveWordRight(wordSeparators, model, position, wordNavigationType);
  }
};
var CursorWordStartLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartLeft",
      precondition: void 0
    });
  }
};
var CursorWordEndLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndLeft",
      precondition: void 0
    });
  }
};
var CursorWordLeft = class extends WordLeftCommand {
  constructor() {
    var _a;
    super({
      inSelectionMode: false,
      wordNavigationType: 1,
      id: "cursorWordLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a === void 0 ? void 0 : _a.negate()),
        primary: 2048 | 15,
        mac: {
          primary: 512 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordStartLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartLeftSelect",
      precondition: void 0
    });
  }
};
var CursorWordEndLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndLeftSelect",
      precondition: void 0
    });
  }
};
var CursorWordLeftSelect = class extends WordLeftCommand {
  constructor() {
    var _a;
    super({
      inSelectionMode: true,
      wordNavigationType: 1,
      id: "cursorWordLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a === void 0 ? void 0 : _a.negate()),
        primary: 2048 | 1024 | 15,
        mac: {
          primary: 512 | 1024 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordAccessibilityLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeft",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var CursorWordAccessibilityLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeftSelect",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var CursorWordStartRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartRight",
      precondition: void 0
    });
  }
};
var CursorWordEndRight = class extends WordRightCommand {
  constructor() {
    var _a;
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a === void 0 ? void 0 : _a.negate()),
        primary: 2048 | 17,
        mac: {
          primary: 512 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordRight",
      precondition: void 0
    });
  }
};
var CursorWordStartRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartRightSelect",
      precondition: void 0
    });
  }
};
var CursorWordEndRightSelect = class extends WordRightCommand {
  constructor() {
    var _a;
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a === void 0 ? void 0 : _a.negate()),
        primary: 2048 | 1024 | 17,
        mac: {
          primary: 512 | 1024 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordRightSelect",
      precondition: void 0
    });
  }
};
var CursorWordAccessibilityRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRight",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var CursorWordAccessibilityRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRightSelect",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var DeleteWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._whitespaceHeuristics = opts.whitespaceHeuristics;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    ));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const autoClosingBrackets = editor2.getOption(
      6
      /* EditorOption.autoClosingBrackets */
    );
    const autoClosingQuotes = editor2.getOption(
      10
      /* EditorOption.autoClosingQuotes */
    );
    const autoClosingPairs = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getAutoClosingPairs();
    const viewModel = editor2._getViewModel();
    const commands = selections.map((sel) => {
      const deleteRange = this._delete({
        wordSeparators,
        model,
        selection: sel,
        whitespaceHeuristics: this._whitespaceHeuristics,
        autoClosingDelete: editor2.getOption(
          8
          /* EditorOption.autoClosingDelete */
        ),
        autoClosingBrackets,
        autoClosingQuotes,
        autoClosingPairs,
        autoClosedCharacters: viewModel.getCursorAutoClosedCharacters()
      }, this._wordNavigationType);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var DeleteWordLeftCommand = class extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    const r = WordOperations.deleteWordLeft(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    return new Range(1, 1, 1, 1);
  }
};
var DeleteWordRightCommand = class extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    const r = WordOperations.deleteWordRight(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range(lineCount, maxColumn, lineCount, maxColumn);
  }
};
var DeleteWordStartLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordEndLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1,
        mac: {
          primary: 512 | 1
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var DeleteWordStartRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartRight",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordEndRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndRight",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 20,
        mac: {
          primary: 512 | 20
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var DeleteInsideWord = class extends EditorAction {
  constructor() {
    super({
      id: "deleteInsideWord",
      precondition: EditorContextKeys.writable,
      label: localize("deleteInsideWord", "Delete Word"),
      alias: "Delete Word"
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    ));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const commands = selections.map((sel) => {
      const deleteRange = WordOperations.deleteInsideWord(wordSeparators, model, sel);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
registerEditorCommand(new CursorWordStartLeft());
registerEditorCommand(new CursorWordEndLeft());
registerEditorCommand(new CursorWordLeft());
registerEditorCommand(new CursorWordStartLeftSelect());
registerEditorCommand(new CursorWordEndLeftSelect());
registerEditorCommand(new CursorWordLeftSelect());
registerEditorCommand(new CursorWordStartRight());
registerEditorCommand(new CursorWordEndRight());
registerEditorCommand(new CursorWordRight());
registerEditorCommand(new CursorWordStartRightSelect());
registerEditorCommand(new CursorWordEndRightSelect());
registerEditorCommand(new CursorWordRightSelect());
registerEditorCommand(new CursorWordAccessibilityLeft());
registerEditorCommand(new CursorWordAccessibilityLeftSelect());
registerEditorCommand(new CursorWordAccessibilityRight());
registerEditorCommand(new CursorWordAccessibilityRightSelect());
registerEditorCommand(new DeleteWordStartLeft());
registerEditorCommand(new DeleteWordEndLeft());
registerEditorCommand(new DeleteWordLeft());
registerEditorCommand(new DeleteWordStartRight());
registerEditorCommand(new DeleteWordEndRight());
registerEditorCommand(new DeleteWordRight());
registerEditorAction(DeleteInsideWord);

// node_modules/monaco-editor/esm/vs/editor/contrib/wordPartOperations/browser/wordPartOperations.js
init_editorExtensions();
init_range();
init_editorContextKeys();
init_commands();
var DeleteWordPartLeft = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordPartLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 1
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    const r = WordPartOperations.deleteWordPartLeft(ctx);
    if (r) {
      return r;
    }
    return new Range(1, 1, 1, 1);
  }
};
var DeleteWordPartRight = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordPartRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 20
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    const r = WordPartOperations.deleteWordPartRight(ctx);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range(lineCount, maxColumn, lineCount, maxColumn);
  }
};
var WordPartLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartLeft(wordSeparators, model, position);
  }
};
var CursorWordPartLeft = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordPartLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
var CursorWordPartLeftSelect = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordPartLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 1024 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
var WordPartRightCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartRight(wordSeparators, model, position);
  }
};
var CursorWordPartRight = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordPartRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordPartRightSelect = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordPartRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 1024 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
registerEditorCommand(new DeleteWordPartLeft());
registerEditorCommand(new DeleteWordPartRight());
registerEditorCommand(new CursorWordPartLeft());
registerEditorCommand(new CursorWordPartLeftSelect());
registerEditorCommand(new CursorWordPartRight());
registerEditorCommand(new CursorWordPartRightSelect());

// node_modules/monaco-editor/esm/vs/editor/contrib/readOnlyMessage/browser/contribution.js
init_htmlContent();
init_lifecycle();
init_editorExtensions();
init_nls();
var ReadOnlyMessageController = class extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._register(this.editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit()));
  }
  _onDidAttemptReadOnlyEdit() {
    const messageController = MessageController.get(this.editor);
    if (messageController && this.editor.hasModel()) {
      let message = this.editor.getOptions().get(
        90
        /* EditorOption.readOnlyMessage */
      );
      if (!message) {
        if (this.editor.isSimpleWidget) {
          message = new MarkdownString(localize("editor.simple.readonly", "Cannot edit in read-only input"));
        } else {
          message = new MarkdownString(localize("editor.readonly", "Cannot edit in read-only editor"));
        }
      }
      messageController.showMessage(message, this.editor.getPosition());
    }
  }
};
ReadOnlyMessageController.ID = "editor.contrib.readOnlyMessageController";
registerEditorContribution(
  ReadOnlyMessageController.ID,
  ReadOnlyMessageController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js
init_dom();
init_lifecycle();
init_editorExtensions();
init_platform();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.css";
var IPadShowKeyboard = class extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this.widget = null;
    if (isIOS) {
      this._register(editor2.onDidChangeConfiguration(() => this.update()));
      this.update();
    }
  }
  update() {
    const shouldHaveWidget = !this.editor.getOption(
      89
      /* EditorOption.readOnly */
    );
    if (!this.widget && shouldHaveWidget) {
      this.widget = new ShowKeyboardWidget(this.editor);
    } else if (this.widget && !shouldHaveWidget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
  dispose() {
    super.dispose();
    if (this.widget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
};
IPadShowKeyboard.ID = "editor.contrib.iPadShowKeyboard";
var ShowKeyboardWidget = class _ShowKeyboardWidget extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._domNode = document.createElement("textarea");
    this._domNode.className = "iPadShowKeyboard";
    this._register(addDisposableListener(this._domNode, "touchstart", (e) => {
      this.editor.focus();
    }));
    this._register(addDisposableListener(this._domNode, "focus", (e) => {
      this.editor.focus();
    }));
    this.editor.addOverlayWidget(this);
  }
  dispose() {
    this.editor.removeOverlayWidget(this);
    super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return _ShowKeyboardWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 1
      /* OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER */
    };
  }
};
ShowKeyboardWidget.ID = "editor.contrib.ShowKeyboardWidget";
registerEditorContribution(
  IPadShowKeyboard.ID,
  IPadShowKeyboard,
  3
  /* EditorContributionInstantiation.Eventually */
);

// node_modules/monaco-editor/esm/vs/editor/editor.api.js
init_editorOptions();

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneEditor.js
init_lifecycle();
init_strings();
init_uri();
import "/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/monaco-editor/esm/vs/editor/standalone/browser/standalone-tokens.css";
init_codeEditorService();
init_editorOptions();
init_editorCommon();
init_model();
init_languages();
init_languageConfigurationRegistry();
init_nullTokenize();
init_language();
init_model2();

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/colorizer.js
init_strings();
init_languages();
init_lineTokens();

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js
init_languages();
init_nullTokenize();

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCommon.js
function isFuzzyActionArr(what) {
  return Array.isArray(what);
}
function isFuzzyAction(what) {
  return !isFuzzyActionArr(what);
}
function isString(what) {
  return typeof what === "string";
}
function isIAction(what) {
  return !isString(what);
}
function empty(s) {
  return s ? false : true;
}
function fixCase(lexer, str) {
  return lexer.ignoreCase && str ? str.toLowerCase() : str;
}
function sanitize(s) {
  return s.replace(/[&<>'"_]/g, "-");
}
function log(lexer, msg) {
  console.log(`${lexer.languageId}: ${msg}`);
}
function createError(lexer, msg) {
  return new Error(`${lexer.languageId}: ${msg}`);
}
function substituteMatches(lexer, str, id, matches, state) {
  const re = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let stateMatches = null;
  return str.replace(re, function(full, sub, dollar, hash, n, s, attr, ofs, total) {
    if (!empty(dollar)) {
      return "$";
    }
    if (!empty(hash)) {
      return fixCase(lexer, id);
    }
    if (!empty(n) && n < matches.length) {
      return fixCase(lexer, matches[n]);
    }
    if (!empty(attr) && lexer && typeof lexer[attr] === "string") {
      return lexer[attr];
    }
    if (stateMatches === null) {
      stateMatches = state.split(".");
      stateMatches.unshift(state);
    }
    if (!empty(s) && s < stateMatches.length) {
      return fixCase(lexer, stateMatches[s]);
    }
    return "";
  });
}
function findRules(lexer, inState) {
  let state = inState;
  while (state && state.length > 0) {
    const rules = lexer.tokenizer[state];
    if (rules) {
      return rules;
    }
    const idx = state.lastIndexOf(".");
    if (idx < 0) {
      state = null;
    } else {
      state = state.substr(0, idx);
    }
  }
  return null;
}
function stateExists(lexer, inState) {
  let state = inState;
  while (state && state.length > 0) {
    const exist = lexer.stateNames[state];
    if (exist) {
      return true;
    }
    const idx = state.lastIndexOf(".");
    if (idx < 0) {
      state = null;
    } else {
      state = state.substr(0, idx);
    }
  }
  return false;
}

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js
init_configuration();
var __decorate44 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param44 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MonarchTokenizer_1;
var CACHE_STACK_DEPTH = 5;
var MonarchStackElementFactory = class {
  static create(parent, state) {
    return this._INSTANCE.create(parent, state);
  }
  constructor(maxCacheDepth) {
    this._maxCacheDepth = maxCacheDepth;
    this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(parent, state) {
    if (parent !== null && parent.depth >= this._maxCacheDepth) {
      return new MonarchStackElement(parent, state);
    }
    let stackElementId = MonarchStackElement.getStackElementId(parent);
    if (stackElementId.length > 0) {
      stackElementId += "|";
    }
    stackElementId += state;
    let result = this._entries[stackElementId];
    if (result) {
      return result;
    }
    result = new MonarchStackElement(parent, state);
    this._entries[stackElementId] = result;
    return result;
  }
};
MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);
var MonarchStackElement = class _MonarchStackElement {
  constructor(parent, state) {
    this.parent = parent;
    this.state = state;
    this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(element) {
    let result = "";
    while (element !== null) {
      if (result.length > 0) {
        result += "|";
      }
      result += element.state;
      element = element.parent;
    }
    return result;
  }
  static _equals(a, b) {
    while (a !== null && b !== null) {
      if (a === b) {
        return true;
      }
      if (a.state !== b.state) {
        return false;
      }
      a = a.parent;
      b = b.parent;
    }
    if (a === null && b === null) {
      return true;
    }
    return false;
  }
  equals(other) {
    return _MonarchStackElement._equals(this, other);
  }
  push(state) {
    return MonarchStackElementFactory.create(this, state);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let result = this;
    while (result.parent) {
      result = result.parent;
    }
    return result;
  }
  switchTo(state) {
    return MonarchStackElementFactory.create(this.parent, state);
  }
};
var EmbeddedLanguageData = class _EmbeddedLanguageData {
  constructor(languageId, state) {
    this.languageId = languageId;
    this.state = state;
  }
  equals(other) {
    return this.languageId === other.languageId && this.state.equals(other.state);
  }
  clone() {
    const stateClone = this.state.clone();
    if (stateClone === this.state) {
      return this;
    }
    return new _EmbeddedLanguageData(this.languageId, this.state);
  }
};
var MonarchLineStateFactory = class {
  static create(stack, embeddedLanguageData) {
    return this._INSTANCE.create(stack, embeddedLanguageData);
  }
  constructor(maxCacheDepth) {
    this._maxCacheDepth = maxCacheDepth;
    this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(stack, embeddedLanguageData) {
    if (embeddedLanguageData !== null) {
      return new MonarchLineState(stack, embeddedLanguageData);
    }
    if (stack !== null && stack.depth >= this._maxCacheDepth) {
      return new MonarchLineState(stack, embeddedLanguageData);
    }
    const stackElementId = MonarchStackElement.getStackElementId(stack);
    let result = this._entries[stackElementId];
    if (result) {
      return result;
    }
    result = new MonarchLineState(stack, null);
    this._entries[stackElementId] = result;
    return result;
  }
};
MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);
var MonarchLineState = class _MonarchLineState {
  constructor(stack, embeddedLanguageData) {
    this.stack = stack;
    this.embeddedLanguageData = embeddedLanguageData;
  }
  clone() {
    const embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null;
    if (embeddedlanguageDataClone === this.embeddedLanguageData) {
      return this;
    }
    return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);
  }
  equals(other) {
    if (!(other instanceof _MonarchLineState)) {
      return false;
    }
    if (!this.stack.equals(other.stack)) {
      return false;
    }
    if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {
      return true;
    }
    if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {
      return false;
    }
    return this.embeddedLanguageData.equals(other.embeddedLanguageData);
  }
};
var MonarchClassicTokensCollector = class {
  constructor() {
    this._tokens = [];
    this._languageId = null;
    this._lastTokenType = null;
    this._lastTokenLanguage = null;
  }
  enterLanguage(languageId) {
    this._languageId = languageId;
  }
  emit(startOffset, type) {
    if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {
      return;
    }
    this._lastTokenType = type;
    this._lastTokenLanguage = this._languageId;
    this._tokens.push(new Token(startOffset, type, this._languageId));
  }
  nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {
    const nestedLanguageId = embeddedLanguageData.languageId;
    const embeddedModeState = embeddedLanguageData.state;
    const nestedLanguageTokenizationSupport = TokenizationRegistry.get(nestedLanguageId);
    if (!nestedLanguageTokenizationSupport) {
      this.enterLanguage(nestedLanguageId);
      this.emit(offsetDelta, "");
      return embeddedModeState;
    }
    const nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);
    if (offsetDelta !== 0) {
      for (const token of nestedResult.tokens) {
        this._tokens.push(new Token(token.offset + offsetDelta, token.type, token.language));
      }
    } else {
      this._tokens = this._tokens.concat(nestedResult.tokens);
    }
    this._lastTokenType = null;
    this._lastTokenLanguage = null;
    this._languageId = null;
    return nestedResult.endState;
  }
  finalize(endState) {
    return new TokenizationResult(this._tokens, endState);
  }
};
var MonarchModernTokensCollector = class _MonarchModernTokensCollector {
  constructor(languageService, theme) {
    this._languageService = languageService;
    this._theme = theme;
    this._prependTokens = null;
    this._tokens = [];
    this._currentLanguageId = 0;
    this._lastTokenMetadata = 0;
  }
  enterLanguage(languageId) {
    this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);
  }
  emit(startOffset, type) {
    const metadata = this._theme.match(this._currentLanguageId, type) | 1024;
    if (this._lastTokenMetadata === metadata) {
      return;
    }
    this._lastTokenMetadata = metadata;
    this._tokens.push(startOffset);
    this._tokens.push(metadata);
  }
  static _merge(a, b, c) {
    const aLen = a !== null ? a.length : 0;
    const bLen = b.length;
    const cLen = c !== null ? c.length : 0;
    if (aLen === 0 && bLen === 0 && cLen === 0) {
      return new Uint32Array(0);
    }
    if (aLen === 0 && bLen === 0) {
      return c;
    }
    if (bLen === 0 && cLen === 0) {
      return a;
    }
    const result = new Uint32Array(aLen + bLen + cLen);
    if (a !== null) {
      result.set(a);
    }
    for (let i = 0; i < bLen; i++) {
      result[aLen + i] = b[i];
    }
    if (c !== null) {
      result.set(c, aLen + bLen);
    }
    return result;
  }
  nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {
    const nestedLanguageId = embeddedLanguageData.languageId;
    const embeddedModeState = embeddedLanguageData.state;
    const nestedLanguageTokenizationSupport = TokenizationRegistry.get(nestedLanguageId);
    if (!nestedLanguageTokenizationSupport) {
      this.enterLanguage(nestedLanguageId);
      this.emit(offsetDelta, "");
      return embeddedModeState;
    }
    const nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);
    if (offsetDelta !== 0) {
      for (let i = 0, len = nestedResult.tokens.length; i < len; i += 2) {
        nestedResult.tokens[i] += offsetDelta;
      }
    }
    this._prependTokens = _MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);
    this._tokens = [];
    this._currentLanguageId = 0;
    this._lastTokenMetadata = 0;
    return nestedResult.endState;
  }
  finalize(endState) {
    return new EncodedTokenizationResult(_MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);
  }
};
var MonarchTokenizer = MonarchTokenizer_1 = class MonarchTokenizer2 {
  constructor(languageService, standaloneThemeService, languageId, lexer, _configurationService) {
    this._configurationService = _configurationService;
    this._languageService = languageService;
    this._standaloneThemeService = standaloneThemeService;
    this._languageId = languageId;
    this._lexer = lexer;
    this._embeddedLanguages = /* @__PURE__ */ Object.create(null);
    this.embeddedLoaded = Promise.resolve(void 0);
    let emitting = false;
    this._tokenizationRegistryListener = TokenizationRegistry.onDidChange((e) => {
      if (emitting) {
        return;
      }
      let isOneOfMyEmbeddedModes = false;
      for (let i = 0, len = e.changedLanguages.length; i < len; i++) {
        const language2 = e.changedLanguages[i];
        if (this._embeddedLanguages[language2]) {
          isOneOfMyEmbeddedModes = true;
          break;
        }
      }
      if (isOneOfMyEmbeddedModes) {
        emitting = true;
        TokenizationRegistry.handleChange([this._languageId]);
        emitting = false;
      }
    });
    this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: this._languageId
    });
    this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("editor.maxTokenizationLineLength")) {
        this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
          overrideIdentifier: this._languageId
        });
      }
    });
  }
  dispose() {
    this._tokenizationRegistryListener.dispose();
  }
  getLoadStatus() {
    const promises = [];
    for (const nestedLanguageId in this._embeddedLanguages) {
      const tokenizationSupport = TokenizationRegistry.get(nestedLanguageId);
      if (tokenizationSupport) {
        if (tokenizationSupport instanceof MonarchTokenizer_1) {
          const nestedModeStatus = tokenizationSupport.getLoadStatus();
          if (nestedModeStatus.loaded === false) {
            promises.push(nestedModeStatus.promise);
          }
        }
        continue;
      }
      if (!TokenizationRegistry.isResolved(nestedLanguageId)) {
        promises.push(TokenizationRegistry.getOrCreate(nestedLanguageId));
      }
    }
    if (promises.length === 0) {
      return {
        loaded: true
      };
    }
    return {
      loaded: false,
      promise: Promise.all(promises).then((_) => void 0)
    };
  }
  getInitialState() {
    const rootState = MonarchStackElementFactory.create(null, this._lexer.start);
    return MonarchLineStateFactory.create(rootState, null);
  }
  tokenize(line, hasEOL, lineState) {
    if (line.length >= this._maxTokenizationLineLength) {
      return nullTokenize(this._languageId, lineState);
    }
    const tokensCollector = new MonarchClassicTokensCollector();
    const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);
    return tokensCollector.finalize(endLineState);
  }
  tokenizeEncoded(line, hasEOL, lineState) {
    if (line.length >= this._maxTokenizationLineLength) {
      return nullTokenizeEncoded(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), lineState);
    }
    const tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);
    const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);
    return tokensCollector.finalize(endLineState);
  }
  _tokenize(line, hasEOL, lineState, collector) {
    if (lineState.embeddedLanguageData) {
      return this._nestedTokenize(line, hasEOL, lineState, 0, collector);
    } else {
      return this._myTokenize(line, hasEOL, lineState, 0, collector);
    }
  }
  _findLeavingNestedLanguageOffset(line, state) {
    let rules = this._lexer.tokenizer[state.stack.state];
    if (!rules) {
      rules = findRules(this._lexer, state.stack.state);
      if (!rules) {
        throw createError(this._lexer, "tokenizer state is not defined: " + state.stack.state);
      }
    }
    let popOffset = -1;
    let hasEmbeddedPopRule = false;
    for (const rule of rules) {
      if (!isIAction(rule.action) || rule.action.nextEmbedded !== "@pop") {
        continue;
      }
      hasEmbeddedPopRule = true;
      let regex = rule.regex;
      const regexSource = rule.regex.source;
      if (regexSource.substr(0, 4) === "^(?:" && regexSource.substr(regexSource.length - 1, 1) === ")") {
        const flags = (regex.ignoreCase ? "i" : "") + (regex.unicode ? "u" : "");
        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);
      }
      const result = line.search(regex);
      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {
        continue;
      }
      if (popOffset === -1 || result < popOffset) {
        popOffset = result;
      }
    }
    if (!hasEmbeddedPopRule) {
      throw createError(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + state.stack.state);
    }
    return popOffset;
  }
  _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {
    const popOffset = this._findLeavingNestedLanguageOffset(line, lineState);
    if (popOffset === -1) {
      const nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);
      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));
    }
    const nestedLanguageLine = line.substring(0, popOffset);
    if (nestedLanguageLine.length > 0) {
      tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);
    }
    const restOfTheLine = line.substring(popOffset);
    return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);
  }
  _safeRuleName(rule) {
    if (rule) {
      return rule.name;
    }
    return "(unknown)";
  }
  _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {
    tokensCollector.enterLanguage(this._languageId);
    const lineWithoutLFLength = lineWithoutLF.length;
    const line = hasEOL && this._lexer.includeLF ? lineWithoutLF + "\n" : lineWithoutLF;
    const lineLength = line.length;
    let embeddedLanguageData = lineState.embeddedLanguageData;
    let stack = lineState.stack;
    let pos = 0;
    let groupMatching = null;
    let forceEvaluation = true;
    while (forceEvaluation || pos < lineLength) {
      const pos0 = pos;
      const stackLen0 = stack.depth;
      const groupLen0 = groupMatching ? groupMatching.groups.length : 0;
      const state = stack.state;
      let matches = null;
      let matched = null;
      let action = null;
      let rule = null;
      let enteringEmbeddedLanguage = null;
      if (groupMatching) {
        matches = groupMatching.matches;
        const groupEntry = groupMatching.groups.shift();
        matched = groupEntry.matched;
        action = groupEntry.action;
        rule = groupMatching.rule;
        if (groupMatching.groups.length === 0) {
          groupMatching = null;
        }
      } else {
        if (!forceEvaluation && pos >= lineLength) {
          break;
        }
        forceEvaluation = false;
        let rules = this._lexer.tokenizer[state];
        if (!rules) {
          rules = findRules(this._lexer, state);
          if (!rules) {
            throw createError(this._lexer, "tokenizer state is not defined: " + state);
          }
        }
        const restOfLine = line.substr(pos);
        for (const rule2 of rules) {
          if (pos === 0 || !rule2.matchOnlyAtLineStart) {
            matches = restOfLine.match(rule2.regex);
            if (matches) {
              matched = matches[0];
              action = rule2.action;
              break;
            }
          }
        }
      }
      if (!matches) {
        matches = [""];
        matched = "";
      }
      if (!action) {
        if (pos < lineLength) {
          matches = [line.charAt(pos)];
          matched = matches[0];
        }
        action = this._lexer.defaultToken;
      }
      if (matched === null) {
        break;
      }
      pos += matched.length;
      while (isFuzzyAction(action) && isIAction(action) && action.test) {
        action = action.test(matched, matches, state, pos === lineLength);
      }
      let result = null;
      if (typeof action === "string" || Array.isArray(action)) {
        result = action;
      } else if (action.group) {
        result = action.group;
      } else if (action.token !== null && action.token !== void 0) {
        if (action.tokenSubst) {
          result = substituteMatches(this._lexer, action.token, matched, matches, state);
        } else {
          result = action.token;
        }
        if (action.nextEmbedded) {
          if (action.nextEmbedded === "@pop") {
            if (!embeddedLanguageData) {
              throw createError(this._lexer, "cannot pop embedded language if not inside one");
            }
            embeddedLanguageData = null;
          } else if (embeddedLanguageData) {
            throw createError(this._lexer, "cannot enter embedded language from within an embedded language");
          } else {
            enteringEmbeddedLanguage = substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);
          }
        }
        if (action.goBack) {
          pos = Math.max(0, pos - action.goBack);
        }
        if (action.switchTo && typeof action.switchTo === "string") {
          let nextState = substituteMatches(this._lexer, action.switchTo, matched, matches, state);
          if (nextState[0] === "@") {
            nextState = nextState.substr(1);
          }
          if (!findRules(this._lexer, nextState)) {
            throw createError(this._lexer, "trying to switch to a state '" + nextState + "' that is undefined in rule: " + this._safeRuleName(rule));
          } else {
            stack = stack.switchTo(nextState);
          }
        } else if (action.transform && typeof action.transform === "function") {
          throw createError(this._lexer, "action.transform not supported");
        } else if (action.next) {
          if (action.next === "@push") {
            if (stack.depth >= this._lexer.maxStack) {
              throw createError(this._lexer, "maximum tokenizer stack size reached: [" + stack.state + "," + stack.parent.state + ",...]");
            } else {
              stack = stack.push(state);
            }
          } else if (action.next === "@pop") {
            if (stack.depth <= 1) {
              throw createError(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(rule));
            } else {
              stack = stack.pop();
            }
          } else if (action.next === "@popall") {
            stack = stack.popall();
          } else {
            let nextState = substituteMatches(this._lexer, action.next, matched, matches, state);
            if (nextState[0] === "@") {
              nextState = nextState.substr(1);
            }
            if (!findRules(this._lexer, nextState)) {
              throw createError(this._lexer, "trying to set a next state '" + nextState + "' that is undefined in rule: " + this._safeRuleName(rule));
            } else {
              stack = stack.push(nextState);
            }
          }
        }
        if (action.log && typeof action.log === "string") {
          log(this._lexer, this._lexer.languageId + ": " + substituteMatches(this._lexer, action.log, matched, matches, state));
        }
      }
      if (result === null) {
        throw createError(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(rule));
      }
      const computeNewStateForEmbeddedLanguage = (enteringEmbeddedLanguage2) => {
        const languageId = this._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage2) || this._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage2) || enteringEmbeddedLanguage2;
        const embeddedLanguageData2 = this._getNestedEmbeddedLanguageData(languageId);
        if (pos < lineLength) {
          const restOfLine = lineWithoutLF.substr(pos);
          return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData2), offsetDelta + pos, tokensCollector);
        } else {
          return MonarchLineStateFactory.create(stack, embeddedLanguageData2);
        }
      };
      if (Array.isArray(result)) {
        if (groupMatching && groupMatching.groups.length > 0) {
          throw createError(this._lexer, "groups cannot be nested: " + this._safeRuleName(rule));
        }
        if (matches.length !== result.length + 1) {
          throw createError(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(rule));
        }
        let totalLen = 0;
        for (let i = 1; i < matches.length; i++) {
          totalLen += matches[i].length;
        }
        if (totalLen !== matched.length) {
          throw createError(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(rule));
        }
        groupMatching = {
          rule,
          matches,
          groups: []
        };
        for (let i = 0; i < result.length; i++) {
          groupMatching.groups[i] = {
            action: result[i],
            matched: matches[i + 1]
          };
        }
        pos -= matched.length;
        continue;
      } else {
        if (result === "@rematch") {
          pos -= matched.length;
          matched = "";
          matches = null;
          result = "";
          if (enteringEmbeddedLanguage !== null) {
            return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);
          }
        }
        if (matched.length === 0) {
          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {
            continue;
          } else {
            throw createError(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(rule));
          }
        }
        let tokenType = null;
        if (isString(result) && result.indexOf("@brackets") === 0) {
          const rest = result.substr("@brackets".length);
          const bracket = findBracket(this._lexer, matched);
          if (!bracket) {
            throw createError(this._lexer, "@brackets token returned but no bracket defined as: " + matched);
          }
          tokenType = sanitize(bracket.token + rest);
        } else {
          const token = result === "" ? "" : result + this._lexer.tokenPostfix;
          tokenType = sanitize(token);
        }
        if (pos0 < lineWithoutLFLength) {
          tokensCollector.emit(pos0 + offsetDelta, tokenType);
        }
      }
      if (enteringEmbeddedLanguage !== null) {
        return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);
      }
    }
    return MonarchLineStateFactory.create(stack, embeddedLanguageData);
  }
  _getNestedEmbeddedLanguageData(languageId) {
    if (!this._languageService.isRegisteredLanguageId(languageId)) {
      return new EmbeddedLanguageData(languageId, NullState);
    }
    if (languageId !== this._languageId) {
      this._languageService.requestBasicLanguageFeatures(languageId);
      TokenizationRegistry.getOrCreate(languageId);
      this._embeddedLanguages[languageId] = true;
    }
    const tokenizationSupport = TokenizationRegistry.get(languageId);
    if (tokenizationSupport) {
      return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());
    }
    return new EmbeddedLanguageData(languageId, NullState);
  }
};
MonarchTokenizer = MonarchTokenizer_1 = __decorate44([
  __param44(4, IConfigurationService)
], MonarchTokenizer);
function findBracket(lexer, matched) {
  if (!matched) {
    return null;
  }
  matched = fixCase(lexer, matched);
  const brackets = lexer.brackets;
  for (const bracket of brackets) {
    if (bracket.open === matched) {
      return {
        token: bracket.token,
        bracketType: 1
        /* monarchCommon.MonarchBracket.Open */
      };
    } else if (bracket.close === matched) {
      return {
        token: bracket.token,
        bracketType: -1
        /* monarchCommon.MonarchBracket.Close */
      };
    }
  }
  return null;
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/colorizer.js
var __awaiter40 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ttPolicy = createTrustedTypesPolicy("standaloneColorizer", { createHTML: (value) => value });
var Colorizer = class {
  static colorizeElement(themeService, languageService, domNode, options) {
    options = options || {};
    const theme = options.theme || "vs";
    const mimeType = options.mimeType || domNode.getAttribute("lang") || domNode.getAttribute("data-lang");
    if (!mimeType) {
      console.error("Mode not detected");
      return Promise.resolve();
    }
    const languageId = languageService.getLanguageIdByMimeType(mimeType) || mimeType;
    themeService.setTheme(theme);
    const text = domNode.firstChild ? domNode.firstChild.nodeValue : "";
    domNode.className += " " + theme;
    const render = (str) => {
      var _a;
      const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str)) !== null && _a !== void 0 ? _a : str;
      domNode.innerHTML = trustedhtml;
    };
    return this.colorize(languageService, text || "", languageId, options).then(render, (err) => console.error(err));
  }
  static colorize(languageService, text, languageId, options) {
    return __awaiter40(this, void 0, void 0, function* () {
      const languageIdCodec = languageService.languageIdCodec;
      let tabSize = 4;
      if (options && typeof options.tabSize === "number") {
        tabSize = options.tabSize;
      }
      if (startsWithUTF8BOM(text)) {
        text = text.substr(1);
      }
      const lines = splitLines(text);
      if (!languageService.isRegisteredLanguageId(languageId)) {
        return _fakeColorize(lines, tabSize, languageIdCodec);
      }
      const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);
      if (tokenizationSupport) {
        return _colorize(lines, tabSize, tokenizationSupport, languageIdCodec);
      }
      return _fakeColorize(lines, tabSize, languageIdCodec);
    });
  }
  static colorizeLine(line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize = 4) {
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);
    const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII2, mightContainRTL);
    const renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII2, containsRTL, 0, tokens, [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    return renderResult.html;
  }
  static colorizeModelLine(model, lineNumber, tabSize = 4) {
    const content = model.getLineContent(lineNumber);
    model.tokenization.forceTokenization(lineNumber);
    const tokens = model.tokenization.getLineTokens(lineNumber);
    const inflatedTokens = tokens.inflate();
    return this.colorizeLine(content, model.mightContainNonBasicASCII(), model.mightContainRTL(), inflatedTokens, tabSize);
  }
};
function _colorize(lines, tabSize, tokenizationSupport, languageIdCodec) {
  return new Promise((c, e) => {
    const execute = () => {
      const result = _actualColorize(lines, tabSize, tokenizationSupport, languageIdCodec);
      if (tokenizationSupport instanceof MonarchTokenizer) {
        const status2 = tokenizationSupport.getLoadStatus();
        if (status2.loaded === false) {
          status2.promise.then(execute, e);
          return;
        }
      }
      c(result);
    };
    execute();
  });
}
function _fakeColorize(lines, tabSize, languageIdCodec) {
  let html = [];
  const defaultMetadata = (0 << 11 | 1 << 15 | 2 << 24) >>> 0;
  const tokens = new Uint32Array(2);
  tokens[0] = 0;
  tokens[1] = defaultMetadata;
  for (let i = 0, length = lines.length; i < length; i++) {
    const line = lines[i];
    tokens[0] = line.length;
    const lineTokens = new LineTokens(tokens, line, languageIdCodec);
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(
      line,
      /* check for basic ASCII */
      true
    );
    const containsRTL = ViewLineRenderingData.containsRTL(
      line,
      isBasicASCII2,
      /* check for RTL */
      true
    );
    const renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII2, containsRTL, 0, lineTokens, [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    html = html.concat(renderResult.html);
    html.push("<br/>");
  }
  return html.join("");
}
function _actualColorize(lines, tabSize, tokenizationSupport, languageIdCodec) {
  let html = [];
  let state = tokenizationSupport.getInitialState();
  for (let i = 0, length = lines.length; i < length; i++) {
    const line = lines[i];
    const tokenizeResult = tokenizationSupport.tokenizeEncoded(line, true, state);
    LineTokens.convertToEndOffset(tokenizeResult.tokens, line.length);
    const lineTokens = new LineTokens(tokenizeResult.tokens, line, languageIdCodec);
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(
      line,
      /* check for basic ASCII */
      true
    );
    const containsRTL = ViewLineRenderingData.containsRTL(
      line,
      isBasicASCII2,
      /* check for RTL */
      true
    );
    const renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII2, containsRTL, 0, lineTokens.inflate(), [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    html = html.concat(renderResult.html);
    html.push("<br/>");
    state = tokenizeResult.endState;
  }
  return html.join("");
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneEditor.js
init_commands();
init_editorExtensions();
init_actions2();
init_contextkey();
init_modesRegistry();
init_lineRange();
init_opener();
var __awaiter41 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function create(domElement, options, override) {
  const instantiationService = StandaloneServices.initialize(override || {});
  return instantiationService.createInstance(StandaloneEditor, domElement, options);
}
function onDidCreateEditor(listener) {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.onCodeEditorAdd((editor2) => {
    listener(editor2);
  });
}
function onDidCreateDiffEditor(listener) {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.onDiffEditorAdd((editor2) => {
    listener(editor2);
  });
}
function getEditors() {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.listCodeEditors();
}
function getDiffEditors() {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.listDiffEditors();
}
function createDiffEditor(domElement, options, override) {
  var _a;
  const instantiationService = StandaloneServices.initialize(override || {});
  if ((_a = options === null || options === void 0 ? void 0 : options.experimental) === null || _a === void 0 ? void 0 : _a.useVersion2) {
    return instantiationService.createInstance(StandaloneDiffEditor2, domElement, options);
  }
  return instantiationService.createInstance(StandaloneDiffEditor, domElement, options);
}
function createDiffNavigator(diffEditor, opts) {
  const instantiationService = StandaloneServices.initialize({});
  return instantiationService.createInstance(DiffNavigator, diffEditor, opts);
}
function addCommand(descriptor) {
  if (typeof descriptor.id !== "string" || typeof descriptor.run !== "function") {
    throw new Error("Invalid command descriptor, `id` and `run` are required properties!");
  }
  return CommandsRegistry.registerCommand(descriptor.id, descriptor.run);
}
function addEditorAction(descriptor) {
  if (typeof descriptor.id !== "string" || typeof descriptor.label !== "string" || typeof descriptor.run !== "function") {
    throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
  }
  const precondition = ContextKeyExpr.deserialize(descriptor.precondition);
  const run = (accessor, ...args) => {
    return EditorCommand.runEditorCommand(accessor, args, precondition, (accessor2, editor2, args2) => Promise.resolve(descriptor.run(editor2, ...args2)));
  };
  const toDispose = new DisposableStore();
  toDispose.add(CommandsRegistry.registerCommand(descriptor.id, run));
  if (descriptor.contextMenuGroupId) {
    const menuItem = {
      command: {
        id: descriptor.id,
        title: descriptor.label
      },
      when: precondition,
      group: descriptor.contextMenuGroupId,
      order: descriptor.contextMenuOrder || 0
    };
    toDispose.add(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));
  }
  if (Array.isArray(descriptor.keybindings)) {
    const keybindingService = StandaloneServices.get(IKeybindingService);
    if (!(keybindingService instanceof StandaloneKeybindingService)) {
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
    } else {
      const keybindingsWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(descriptor.keybindingContext));
      toDispose.add(keybindingService.addDynamicKeybindings(descriptor.keybindings.map((keybinding) => {
        return {
          keybinding,
          command: descriptor.id,
          when: keybindingsWhen
        };
      })));
    }
  }
  return toDispose;
}
function addKeybindingRule(rule) {
  return addKeybindingRules([rule]);
}
function addKeybindingRules(rules) {
  const keybindingService = StandaloneServices.get(IKeybindingService);
  if (!(keybindingService instanceof StandaloneKeybindingService)) {
    console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
    return Disposable.None;
  }
  return keybindingService.addDynamicKeybindings(rules.map((rule) => {
    return {
      keybinding: rule.keybinding,
      command: rule.command,
      commandArgs: rule.commandArgs,
      when: ContextKeyExpr.deserialize(rule.when)
    };
  }));
}
function createModel(value, language2, uri) {
  const languageService = StandaloneServices.get(ILanguageService);
  const languageId = languageService.getLanguageIdByMimeType(language2) || language2;
  return createTextModel(StandaloneServices.get(IModelService), languageService, value, languageId, uri);
}
function setModelLanguage(model, mimeTypeOrLanguageId) {
  const languageService = StandaloneServices.get(ILanguageService);
  const languageId = languageService.getLanguageIdByMimeType(mimeTypeOrLanguageId) || mimeTypeOrLanguageId || PLAINTEXT_LANGUAGE_ID;
  model.setLanguage(languageService.createById(languageId));
}
function setModelMarkers(model, owner, markers) {
  if (model) {
    const markerService = StandaloneServices.get(IMarkerService);
    markerService.changeOne(owner, model.uri, markers);
  }
}
function removeAllMarkers(owner) {
  const markerService = StandaloneServices.get(IMarkerService);
  markerService.changeAll(owner, []);
}
function getModelMarkers(filter) {
  const markerService = StandaloneServices.get(IMarkerService);
  return markerService.read(filter);
}
function onDidChangeMarkers(listener) {
  const markerService = StandaloneServices.get(IMarkerService);
  return markerService.onMarkerChanged(listener);
}
function getModel(uri) {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.getModel(uri);
}
function getModels() {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.getModels();
}
function onDidCreateModel(listener) {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.onModelAdded(listener);
}
function onWillDisposeModel(listener) {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.onModelRemoved(listener);
}
function onDidChangeModelLanguage(listener) {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.onModelLanguageChanged((e) => {
    listener({
      model: e.model,
      oldLanguage: e.oldLanguageId
    });
  });
}
function createWebWorker2(opts) {
  return createWebWorker(StandaloneServices.get(IModelService), StandaloneServices.get(ILanguageConfigurationService), opts);
}
function colorizeElement(domNode, options) {
  const languageService = StandaloneServices.get(ILanguageService);
  const themeService = StandaloneServices.get(IStandaloneThemeService);
  return Colorizer.colorizeElement(themeService, languageService, domNode, options).then(() => {
    themeService.registerEditorContainer(domNode);
  });
}
function colorize(text, languageId, options) {
  const languageService = StandaloneServices.get(ILanguageService);
  const themeService = StandaloneServices.get(IStandaloneThemeService);
  themeService.registerEditorContainer(document.body);
  return Colorizer.colorize(languageService, text, languageId, options);
}
function colorizeModelLine(model, lineNumber, tabSize = 4) {
  const themeService = StandaloneServices.get(IStandaloneThemeService);
  themeService.registerEditorContainer(document.body);
  return Colorizer.colorizeModelLine(model, lineNumber, tabSize);
}
function getSafeTokenizationSupport(language2) {
  const tokenizationSupport = TokenizationRegistry.get(language2);
  if (tokenizationSupport) {
    return tokenizationSupport;
  }
  return {
    getInitialState: () => NullState,
    tokenize: (line, hasEOL, state) => nullTokenize(language2, state)
  };
}
function tokenize(text, languageId) {
  TokenizationRegistry.getOrCreate(languageId);
  const tokenizationSupport = getSafeTokenizationSupport(languageId);
  const lines = splitLines(text);
  const result = [];
  let state = tokenizationSupport.getInitialState();
  for (let i = 0, len = lines.length; i < len; i++) {
    const line = lines[i];
    const tokenizationResult = tokenizationSupport.tokenize(line, true, state);
    result[i] = tokenizationResult.tokens;
    state = tokenizationResult.endState;
  }
  return result;
}
function defineTheme(themeName, themeData) {
  const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
  standaloneThemeService.defineTheme(themeName, themeData);
}
function setTheme(themeName) {
  const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
  standaloneThemeService.setTheme(themeName);
}
function remeasureFonts() {
  FontMeasurements.clearAllFontInfos();
}
function registerCommand2(id, handler) {
  return CommandsRegistry.registerCommand({ id, handler });
}
function registerLinkOpener(opener) {
  const openerService = StandaloneServices.get(IOpenerService);
  return openerService.registerOpener({
    open(resource) {
      return __awaiter41(this, void 0, void 0, function* () {
        if (typeof resource === "string") {
          resource = URI.parse(resource);
        }
        return opener.open(resource);
      });
    }
  });
}
function registerEditorOpener(opener) {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.registerCodeEditorOpenHandler((input, source, sideBySide) => __awaiter41(this, void 0, void 0, function* () {
    var _a;
    if (!source) {
      return null;
    }
    const selection = (_a = input.options) === null || _a === void 0 ? void 0 : _a.selection;
    let selectionOrPosition;
    if (selection && typeof selection.endLineNumber === "number" && typeof selection.endColumn === "number") {
      selectionOrPosition = selection;
    } else if (selection) {
      selectionOrPosition = { lineNumber: selection.startLineNumber, column: selection.startColumn };
    }
    if (yield opener.openCodeEditor(source, input.resource, selectionOrPosition)) {
      return source;
    }
    return null;
  }));
}
function createMonacoEditorAPI() {
  return {
    // methods
    create,
    getEditors,
    getDiffEditors,
    onDidCreateEditor,
    onDidCreateDiffEditor,
    createDiffEditor,
    createDiffNavigator,
    addCommand,
    addEditorAction,
    addKeybindingRule,
    addKeybindingRules,
    createModel,
    setModelLanguage,
    setModelMarkers,
    getModelMarkers,
    removeAllMarkers,
    onDidChangeMarkers,
    getModels,
    getModel,
    onDidCreateModel,
    onWillDisposeModel,
    onDidChangeModelLanguage,
    createWebWorker: createWebWorker2,
    colorizeElement,
    colorize,
    colorizeModelLine,
    tokenize,
    defineTheme,
    setTheme,
    remeasureFonts,
    registerCommand: registerCommand2,
    registerLinkOpener,
    registerEditorOpener,
    // enums
    AccessibilitySupport,
    ContentWidgetPositionPreference,
    CursorChangeReason,
    DefaultEndOfLine,
    EditorAutoIndentStrategy,
    EditorOption,
    EndOfLinePreference,
    EndOfLineSequence,
    MinimapPosition: MinimapPosition2,
    MouseTargetType,
    OverlayWidgetPositionPreference,
    OverviewRulerLane: OverviewRulerLane2,
    GlyphMarginLane,
    RenderLineNumbersType,
    RenderMinimap,
    ScrollbarVisibility,
    ScrollType,
    TextEditorCursorBlinkingStyle,
    TextEditorCursorStyle,
    TrackedRangeStickiness,
    WrappingIndent,
    InjectedTextCursorStops,
    PositionAffinity,
    // classes
    ConfigurationChangedEvent,
    BareFontInfo,
    FontInfo,
    TextModelResolvedOptions,
    FindMatch,
    ApplyUpdateResult,
    LineRange,
    LineRangeMapping,
    RangeMapping,
    EditorZoom,
    MovedText,
    SimpleLineRangeMapping,
    // vars
    EditorType,
    EditorOptions
  };
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneLanguages.js
init_color();
init_range();
init_languages();
init_languageConfigurationRegistry();
init_modesRegistry();
init_language();

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js
function isArrayOf(elemType, obj) {
  if (!obj) {
    return false;
  }
  if (!Array.isArray(obj)) {
    return false;
  }
  for (const el of obj) {
    if (!elemType(el)) {
      return false;
    }
  }
  return true;
}
function bool(prop, defValue) {
  if (typeof prop === "boolean") {
    return prop;
  }
  return defValue;
}
function string(prop, defValue) {
  if (typeof prop === "string") {
    return prop;
  }
  return defValue;
}
function arrayToHash(array) {
  const result = {};
  for (const e of array) {
    result[e] = true;
  }
  return result;
}
function createKeywordMatcher(arr, caseInsensitive = false) {
  if (caseInsensitive) {
    arr = arr.map(function(x) {
      return x.toLowerCase();
    });
  }
  const hash = arrayToHash(arr);
  if (caseInsensitive) {
    return function(word) {
      return hash[word.toLowerCase()] !== void 0 && hash.hasOwnProperty(word.toLowerCase());
    };
  } else {
    return function(word) {
      return hash[word] !== void 0 && hash.hasOwnProperty(word);
    };
  }
}
function compileRegExp(lexer, str) {
  str = str.replace(/@@/g, ``);
  let n = 0;
  let hadExpansion;
  do {
    hadExpansion = false;
    str = str.replace(/@(\w+)/g, function(s, attr) {
      hadExpansion = true;
      let sub = "";
      if (typeof lexer[attr] === "string") {
        sub = lexer[attr];
      } else if (lexer[attr] && lexer[attr] instanceof RegExp) {
        sub = lexer[attr].source;
      } else {
        if (lexer[attr] === void 0) {
          throw createError(lexer, "language definition does not contain attribute '" + attr + "', used at: " + str);
        } else {
          throw createError(lexer, "attribute reference '" + attr + "' must be a string, used at: " + str);
        }
      }
      return empty(sub) ? "" : "(?:" + sub + ")";
    });
    n++;
  } while (hadExpansion && n < 5);
  str = str.replace(/\x01/g, "@");
  const flags = (lexer.ignoreCase ? "i" : "") + (lexer.unicode ? "u" : "");
  return new RegExp(str, flags);
}
function selectScrutinee(id, matches, state, num) {
  if (num < 0) {
    return id;
  }
  if (num < matches.length) {
    return matches[num];
  }
  if (num >= 100) {
    num = num - 100;
    const parts = state.split(".");
    parts.unshift(state);
    if (num < parts.length) {
      return parts[num];
    }
  }
  return null;
}
function createGuard(lexer, ruleName, tkey, val) {
  let scrut = -1;
  let oppat = tkey;
  let matches = tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  if (matches) {
    if (matches[3]) {
      scrut = parseInt(matches[3]);
      if (matches[2]) {
        scrut = scrut + 100;
      }
    }
    oppat = matches[4];
  }
  let op = "~";
  let pat = oppat;
  if (!oppat || oppat.length === 0) {
    op = "!=";
    pat = "";
  } else if (/^\w*$/.test(pat)) {
    op = "==";
  } else {
    matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);
    if (matches) {
      op = matches[1];
      pat = matches[2];
    }
  }
  let tester;
  if ((op === "~" || op === "!~") && /^(\w|\|)*$/.test(pat)) {
    const inWords = createKeywordMatcher(pat.split("|"), lexer.ignoreCase);
    tester = function(s) {
      return op === "~" ? inWords(s) : !inWords(s);
    };
  } else if (op === "@" || op === "!@") {
    const words = lexer[pat];
    if (!words) {
      throw createError(lexer, "the @ match target '" + pat + "' is not defined, in rule: " + ruleName);
    }
    if (!isArrayOf(function(elem) {
      return typeof elem === "string";
    }, words)) {
      throw createError(lexer, "the @ match target '" + pat + "' must be an array of strings, in rule: " + ruleName);
    }
    const inWords = createKeywordMatcher(words, lexer.ignoreCase);
    tester = function(s) {
      return op === "@" ? inWords(s) : !inWords(s);
    };
  } else if (op === "~" || op === "!~") {
    if (pat.indexOf("$") < 0) {
      const re = compileRegExp(lexer, "^" + pat + "$");
      tester = function(s) {
        return op === "~" ? re.test(s) : !re.test(s);
      };
    } else {
      tester = function(s, id, matches2, state) {
        const re = compileRegExp(lexer, "^" + substituteMatches(lexer, pat, id, matches2, state) + "$");
        return re.test(s);
      };
    }
  } else {
    if (pat.indexOf("$") < 0) {
      const patx = fixCase(lexer, pat);
      tester = function(s) {
        return op === "==" ? s === patx : s !== patx;
      };
    } else {
      const patx = fixCase(lexer, pat);
      tester = function(s, id, matches2, state, eos) {
        const patexp = substituteMatches(lexer, patx, id, matches2, state);
        return op === "==" ? s === patexp : s !== patexp;
      };
    }
  }
  if (scrut === -1) {
    return {
      name: tkey,
      value: val,
      test: function(id, matches2, state, eos) {
        return tester(id, id, matches2, state, eos);
      }
    };
  } else {
    return {
      name: tkey,
      value: val,
      test: function(id, matches2, state, eos) {
        const scrutinee = selectScrutinee(id, matches2, state, scrut);
        return tester(!scrutinee ? "" : scrutinee, id, matches2, state, eos);
      }
    };
  }
}
function compileAction(lexer, ruleName, action) {
  if (!action) {
    return { token: "" };
  } else if (typeof action === "string") {
    return action;
  } else if (action.token || action.token === "") {
    if (typeof action.token !== "string") {
      throw createError(lexer, "a 'token' attribute must be of type string, in rule: " + ruleName);
    } else {
      const newAction = { token: action.token };
      if (action.token.indexOf("$") >= 0) {
        newAction.tokenSubst = true;
      }
      if (typeof action.bracket === "string") {
        if (action.bracket === "@open") {
          newAction.bracket = 1;
        } else if (action.bracket === "@close") {
          newAction.bracket = -1;
        } else {
          throw createError(lexer, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + ruleName);
        }
      }
      if (action.next) {
        if (typeof action.next !== "string") {
          throw createError(lexer, "the next state must be a string value in rule: " + ruleName);
        } else {
          let next = action.next;
          if (!/^(@pop|@push|@popall)$/.test(next)) {
            if (next[0] === "@") {
              next = next.substr(1);
            }
            if (next.indexOf("$") < 0) {
              if (!stateExists(lexer, substituteMatches(lexer, next, "", [], ""))) {
                throw createError(lexer, "the next state '" + action.next + "' is not defined in rule: " + ruleName);
              }
            }
          }
          newAction.next = next;
        }
      }
      if (typeof action.goBack === "number") {
        newAction.goBack = action.goBack;
      }
      if (typeof action.switchTo === "string") {
        newAction.switchTo = action.switchTo;
      }
      if (typeof action.log === "string") {
        newAction.log = action.log;
      }
      if (typeof action.nextEmbedded === "string") {
        newAction.nextEmbedded = action.nextEmbedded;
        lexer.usesEmbedded = true;
      }
      return newAction;
    }
  } else if (Array.isArray(action)) {
    const results = [];
    for (let i = 0, len = action.length; i < len; i++) {
      results[i] = compileAction(lexer, ruleName, action[i]);
    }
    return { group: results };
  } else if (action.cases) {
    const cases = [];
    for (const tkey in action.cases) {
      if (action.cases.hasOwnProperty(tkey)) {
        const val = compileAction(lexer, ruleName, action.cases[tkey]);
        if (tkey === "@default" || tkey === "@" || tkey === "") {
          cases.push({ test: void 0, value: val, name: tkey });
        } else if (tkey === "@eos") {
          cases.push({ test: function(id, matches, state, eos) {
            return eos;
          }, value: val, name: tkey });
        } else {
          cases.push(createGuard(lexer, ruleName, tkey, val));
        }
      }
    }
    const def = lexer.defaultToken;
    return {
      test: function(id, matches, state, eos) {
        for (const _case of cases) {
          const didmatch = !_case.test || _case.test(id, matches, state, eos);
          if (didmatch) {
            return _case.value;
          }
        }
        return def;
      }
    };
  } else {
    throw createError(lexer, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + ruleName);
  }
}
var Rule = class {
  constructor(name) {
    this.regex = new RegExp("");
    this.action = { token: "" };
    this.matchOnlyAtLineStart = false;
    this.name = "";
    this.name = name;
  }
  setRegex(lexer, re) {
    let sregex;
    if (typeof re === "string") {
      sregex = re;
    } else if (re instanceof RegExp) {
      sregex = re.source;
    } else {
      throw createError(lexer, "rules must start with a match string or regular expression: " + this.name);
    }
    this.matchOnlyAtLineStart = sregex.length > 0 && sregex[0] === "^";
    this.name = this.name + ": " + sregex;
    this.regex = compileRegExp(lexer, "^(?:" + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ")");
  }
  setAction(lexer, act) {
    this.action = compileAction(lexer, this.name, act);
  }
};
function compile(languageId, json) {
  if (!json || typeof json !== "object") {
    throw new Error("Monarch: expecting a language definition object");
  }
  const lexer = {};
  lexer.languageId = languageId;
  lexer.includeLF = bool(json.includeLF, false);
  lexer.noThrow = false;
  lexer.maxStack = 100;
  lexer.start = typeof json.start === "string" ? json.start : null;
  lexer.ignoreCase = bool(json.ignoreCase, false);
  lexer.unicode = bool(json.unicode, false);
  lexer.tokenPostfix = string(json.tokenPostfix, "." + lexer.languageId);
  lexer.defaultToken = string(json.defaultToken, "source");
  lexer.usesEmbedded = false;
  const lexerMin = json;
  lexerMin.languageId = languageId;
  lexerMin.includeLF = lexer.includeLF;
  lexerMin.ignoreCase = lexer.ignoreCase;
  lexerMin.unicode = lexer.unicode;
  lexerMin.noThrow = lexer.noThrow;
  lexerMin.usesEmbedded = lexer.usesEmbedded;
  lexerMin.stateNames = json.tokenizer;
  lexerMin.defaultToken = lexer.defaultToken;
  function addRules(state, newrules, rules) {
    for (const rule of rules) {
      let include = rule.include;
      if (include) {
        if (typeof include !== "string") {
          throw createError(lexer, "an 'include' attribute must be a string at: " + state);
        }
        if (include[0] === "@") {
          include = include.substr(1);
        }
        if (!json.tokenizer[include]) {
          throw createError(lexer, "include target '" + include + "' is not defined at: " + state);
        }
        addRules(state + "." + include, newrules, json.tokenizer[include]);
      } else {
        const newrule = new Rule(state);
        if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {
          newrule.setRegex(lexerMin, rule[0]);
          if (rule.length >= 3) {
            if (typeof rule[1] === "string") {
              newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });
            } else if (typeof rule[1] === "object") {
              const rule1 = rule[1];
              rule1.next = rule[2];
              newrule.setAction(lexerMin, rule1);
            } else {
              throw createError(lexer, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + state);
            }
          } else {
            newrule.setAction(lexerMin, rule[1]);
          }
        } else {
          if (!rule.regex) {
            throw createError(lexer, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + state);
          }
          if (rule.name) {
            if (typeof rule.name === "string") {
              newrule.name = rule.name;
            }
          }
          if (rule.matchOnlyAtStart) {
            newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);
          }
          newrule.setRegex(lexerMin, rule.regex);
          newrule.setAction(lexerMin, rule.action);
        }
        newrules.push(newrule);
      }
    }
  }
  if (!json.tokenizer || typeof json.tokenizer !== "object") {
    throw createError(lexer, "a language definition must define the 'tokenizer' attribute as an object");
  }
  lexer.tokenizer = [];
  for (const key in json.tokenizer) {
    if (json.tokenizer.hasOwnProperty(key)) {
      if (!lexer.start) {
        lexer.start = key;
      }
      const rules = json.tokenizer[key];
      lexer.tokenizer[key] = new Array();
      addRules("tokenizer." + key, lexer.tokenizer[key], rules);
    }
  }
  lexer.usesEmbedded = lexerMin.usesEmbedded;
  if (json.brackets) {
    if (!Array.isArray(json.brackets)) {
      throw createError(lexer, "the 'brackets' attribute must be defined as an array");
    }
  } else {
    json.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  }
  const brackets = [];
  for (const el of json.brackets) {
    let desc = el;
    if (desc && Array.isArray(desc) && desc.length === 3) {
      desc = { token: desc[2], open: desc[0], close: desc[1] };
    }
    if (desc.open === desc.close) {
      throw createError(lexer, "open and close brackets in a 'brackets' attribute must be different: " + desc.open + "\n hint: use the 'bracket' attribute if matching on equal brackets is required.");
    }
    if (typeof desc.open === "string" && typeof desc.token === "string" && typeof desc.close === "string") {
      brackets.push({
        token: desc.token + lexer.tokenPostfix,
        open: fixCase(lexer, desc.open),
        close: fixCase(lexer, desc.close)
      });
    } else {
      throw createError(lexer, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
    }
  }
  lexer.brackets = brackets;
  lexer.noThrow = true;
  return lexer;
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneLanguages.js
init_languageFeatures();
init_configuration();
var __awaiter42 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function register(language2) {
  ModesRegistry.registerLanguage(language2);
}
function getLanguages() {
  let result = [];
  result = result.concat(ModesRegistry.getLanguages());
  return result;
}
function getEncodedLanguageId(languageId) {
  const languageService = StandaloneServices.get(ILanguageService);
  return languageService.languageIdCodec.encodeLanguageId(languageId);
}
function onLanguage(languageId, callback) {
  return StandaloneServices.withServices(() => {
    const languageService = StandaloneServices.get(ILanguageService);
    const disposable = languageService.onDidRequestRichLanguageFeatures((encounteredLanguageId) => {
      if (encounteredLanguageId === languageId) {
        disposable.dispose();
        callback();
      }
    });
    return disposable;
  });
}
function onLanguageEncountered(languageId, callback) {
  return StandaloneServices.withServices(() => {
    const languageService = StandaloneServices.get(ILanguageService);
    const disposable = languageService.onDidRequestBasicLanguageFeatures((encounteredLanguageId) => {
      if (encounteredLanguageId === languageId) {
        disposable.dispose();
        callback();
      }
    });
    return disposable;
  });
}
function setLanguageConfiguration(languageId, configuration) {
  const languageService = StandaloneServices.get(ILanguageService);
  if (!languageService.isRegisteredLanguageId(languageId)) {
    throw new Error(`Cannot set configuration for unknown language ${languageId}`);
  }
  const languageConfigurationService = StandaloneServices.get(ILanguageConfigurationService);
  return languageConfigurationService.register(languageId, configuration, 100);
}
var EncodedTokenizationSupportAdapter = class {
  constructor(languageId, actual) {
    this._languageId = languageId;
    this._actual = actual;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(line, hasEOL, state) {
    if (typeof this._actual.tokenize === "function") {
      return TokenizationSupportAdapter.adaptTokenize(this._languageId, this._actual, line, state);
    }
    throw new Error("Not supported!");
  }
  tokenizeEncoded(line, hasEOL, state) {
    const result = this._actual.tokenizeEncoded(line, state);
    return new EncodedTokenizationResult(result.tokens, result.endState);
  }
};
var TokenizationSupportAdapter = class _TokenizationSupportAdapter {
  constructor(_languageId, _actual, _languageService, _standaloneThemeService) {
    this._languageId = _languageId;
    this._actual = _actual;
    this._languageService = _languageService;
    this._standaloneThemeService = _standaloneThemeService;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(tokens, language2) {
    const result = [];
    let previousStartIndex = 0;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const t = tokens[i];
      let startIndex = t.startIndex;
      if (i === 0) {
        startIndex = 0;
      } else if (startIndex < previousStartIndex) {
        startIndex = previousStartIndex;
      }
      result[i] = new Token(startIndex, t.scopes, language2);
      previousStartIndex = startIndex;
    }
    return result;
  }
  static adaptTokenize(language2, actual, line, state) {
    const actualResult = actual.tokenize(line, state);
    const tokens = _TokenizationSupportAdapter._toClassicTokens(actualResult.tokens, language2);
    let endState;
    if (actualResult.endState.equals(state)) {
      endState = state;
    } else {
      endState = actualResult.endState;
    }
    return new TokenizationResult(tokens, endState);
  }
  tokenize(line, hasEOL, state) {
    return _TokenizationSupportAdapter.adaptTokenize(this._languageId, this._actual, line, state);
  }
  _toBinaryTokens(languageIdCodec, tokens) {
    const languageId = languageIdCodec.encodeLanguageId(this._languageId);
    const tokenTheme = this._standaloneThemeService.getColorTheme().tokenTheme;
    const result = [];
    let resultLen = 0;
    let previousStartIndex = 0;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const t = tokens[i];
      const metadata = tokenTheme.match(languageId, t.scopes) | 1024;
      if (resultLen > 0 && result[resultLen - 1] === metadata) {
        continue;
      }
      let startIndex = t.startIndex;
      if (i === 0) {
        startIndex = 0;
      } else if (startIndex < previousStartIndex) {
        startIndex = previousStartIndex;
      }
      result[resultLen++] = startIndex;
      result[resultLen++] = metadata;
      previousStartIndex = startIndex;
    }
    const actualResult = new Uint32Array(resultLen);
    for (let i = 0; i < resultLen; i++) {
      actualResult[i] = result[i];
    }
    return actualResult;
  }
  tokenizeEncoded(line, hasEOL, state) {
    const actualResult = this._actual.tokenize(line, state);
    const tokens = this._toBinaryTokens(this._languageService.languageIdCodec, actualResult.tokens);
    let endState;
    if (actualResult.endState.equals(state)) {
      endState = state;
    } else {
      endState = actualResult.endState;
    }
    return new EncodedTokenizationResult(tokens, endState);
  }
};
function isATokensProvider(provider) {
  return typeof provider.getInitialState === "function";
}
function isEncodedTokensProvider(provider) {
  return "tokenizeEncoded" in provider;
}
function isThenable(obj) {
  return obj && typeof obj.then === "function";
}
function setColorMap(colorMap) {
  const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
  if (colorMap) {
    const result = [null];
    for (let i = 1, len = colorMap.length; i < len; i++) {
      result[i] = Color.fromHex(colorMap[i]);
    }
    standaloneThemeService.setColorMapOverride(result);
  } else {
    standaloneThemeService.setColorMapOverride(null);
  }
}
function createTokenizationSupportAdapter(languageId, provider) {
  if (isEncodedTokensProvider(provider)) {
    return new EncodedTokenizationSupportAdapter(languageId, provider);
  } else {
    return new TokenizationSupportAdapter(languageId, provider, StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService));
  }
}
function registerTokensProviderFactory(languageId, factory) {
  const adaptedFactory = new LazyTokenizationSupport(() => __awaiter42(this, void 0, void 0, function* () {
    const result = yield Promise.resolve(factory.create());
    if (!result) {
      return null;
    }
    if (isATokensProvider(result)) {
      return createTokenizationSupportAdapter(languageId, result);
    }
    return new MonarchTokenizer(StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService), languageId, compile(languageId, result), StandaloneServices.get(IConfigurationService));
  }));
  return TokenizationRegistry.registerFactory(languageId, adaptedFactory);
}
function setTokensProvider(languageId, provider) {
  const languageService = StandaloneServices.get(ILanguageService);
  if (!languageService.isRegisteredLanguageId(languageId)) {
    throw new Error(`Cannot set tokens provider for unknown language ${languageId}`);
  }
  if (isThenable(provider)) {
    return registerTokensProviderFactory(languageId, { create: () => provider });
  }
  return TokenizationRegistry.register(languageId, createTokenizationSupportAdapter(languageId, provider));
}
function setMonarchTokensProvider(languageId, languageDef) {
  const create2 = (languageDef2) => {
    return new MonarchTokenizer(StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService), languageId, compile(languageId, languageDef2), StandaloneServices.get(IConfigurationService));
  };
  if (isThenable(languageDef)) {
    return registerTokensProviderFactory(languageId, { create: () => languageDef });
  }
  return TokenizationRegistry.register(languageId, create2(languageDef));
}
function registerReferenceProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.referenceProvider.register(languageSelector, provider);
}
function registerRenameProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.renameProvider.register(languageSelector, provider);
}
function registerSignatureHelpProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.signatureHelpProvider.register(languageSelector, provider);
}
function registerHoverProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.hoverProvider.register(languageSelector, {
    provideHover: (model, position, token) => {
      const word = model.getWordAtPosition(position);
      return Promise.resolve(provider.provideHover(model, position, token)).then((value) => {
        if (!value) {
          return void 0;
        }
        if (!value.range && word) {
          value.range = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
        }
        if (!value.range) {
          value.range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
        }
        return value;
      });
    }
  });
}
function registerDocumentSymbolProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentSymbolProvider.register(languageSelector, provider);
}
function registerDocumentHighlightProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentHighlightProvider.register(languageSelector, provider);
}
function registerLinkedEditingRangeProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.linkedEditingRangeProvider.register(languageSelector, provider);
}
function registerDefinitionProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.definitionProvider.register(languageSelector, provider);
}
function registerImplementationProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.implementationProvider.register(languageSelector, provider);
}
function registerTypeDefinitionProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.typeDefinitionProvider.register(languageSelector, provider);
}
function registerCodeLensProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.codeLensProvider.register(languageSelector, provider);
}
function registerCodeActionProvider(languageSelector, provider, metadata) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.codeActionProvider.register(languageSelector, {
    providedCodeActionKinds: metadata === null || metadata === void 0 ? void 0 : metadata.providedCodeActionKinds,
    documentation: metadata === null || metadata === void 0 ? void 0 : metadata.documentation,
    provideCodeActions: (model, range, context, token) => {
      const markerService = StandaloneServices.get(IMarkerService);
      const markers = markerService.read({ resource: model.uri }).filter((m) => {
        return Range.areIntersectingOrTouching(m, range);
      });
      return provider.provideCodeActions(model, range, { markers, only: context.only, trigger: context.trigger }, token);
    },
    resolveCodeAction: provider.resolveCodeAction
  });
}
function registerDocumentFormattingEditProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentFormattingEditProvider.register(languageSelector, provider);
}
function registerDocumentRangeFormattingEditProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentRangeFormattingEditProvider.register(languageSelector, provider);
}
function registerOnTypeFormattingEditProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.onTypeFormattingEditProvider.register(languageSelector, provider);
}
function registerLinkProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.linkProvider.register(languageSelector, provider);
}
function registerCompletionItemProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.completionProvider.register(languageSelector, provider);
}
function registerColorProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.colorProvider.register(languageSelector, provider);
}
function registerFoldingRangeProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.foldingRangeProvider.register(languageSelector, provider);
}
function registerDeclarationProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.declarationProvider.register(languageSelector, provider);
}
function registerSelectionRangeProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.selectionRangeProvider.register(languageSelector, provider);
}
function registerDocumentSemanticTokensProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentSemanticTokensProvider.register(languageSelector, provider);
}
function registerDocumentRangeSemanticTokensProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentRangeSemanticTokensProvider.register(languageSelector, provider);
}
function registerInlineCompletionsProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.inlineCompletionsProvider.register(languageSelector, provider);
}
function registerInlayHintsProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.inlayHintsProvider.register(languageSelector, provider);
}
function createMonacoLanguagesAPI() {
  return {
    register,
    getLanguages,
    onLanguage,
    onLanguageEncountered,
    getEncodedLanguageId,
    // provider methods
    setLanguageConfiguration,
    setColorMap,
    registerTokensProviderFactory,
    setTokensProvider,
    setMonarchTokensProvider,
    registerReferenceProvider,
    registerRenameProvider,
    registerCompletionItemProvider,
    registerSignatureHelpProvider,
    registerHoverProvider,
    registerDocumentSymbolProvider,
    registerDocumentHighlightProvider,
    registerLinkedEditingRangeProvider,
    registerDefinitionProvider,
    registerImplementationProvider,
    registerTypeDefinitionProvider,
    registerCodeLensProvider,
    registerCodeActionProvider,
    registerDocumentFormattingEditProvider,
    registerDocumentRangeFormattingEditProvider,
    registerOnTypeFormattingEditProvider,
    registerLinkProvider,
    registerColorProvider,
    registerFoldingRangeProvider,
    registerDeclarationProvider,
    registerSelectionRangeProvider,
    registerDocumentSemanticTokensProvider,
    registerDocumentRangeSemanticTokensProvider,
    registerInlineCompletionsProvider,
    registerInlayHintsProvider,
    // enums
    DocumentHighlightKind: DocumentHighlightKind2,
    CompletionItemKind,
    CompletionItemTag,
    CompletionItemInsertTextRule,
    SymbolKind,
    SymbolTag,
    IndentAction: IndentAction2,
    CompletionTriggerKind,
    SignatureHelpTriggerKind: SignatureHelpTriggerKind2,
    InlayHintKind,
    InlineCompletionTriggerKind,
    CodeActionTriggerType,
    // classes
    FoldingRangeKind,
    SelectedSuggestionInfo
  };
}

// node_modules/monaco-editor/esm/vs/editor/editor.api.js
init_format();
EditorOptions.wrappingIndent.defaultValue = 0;
EditorOptions.glyphMargin.defaultValue = false;
EditorOptions.autoIndent.defaultValue = 3;
EditorOptions.overviewRulerLanes.defaultValue = 2;
FormattingConflicts.setFormatterSelector((formatter, document2, mode) => Promise.resolve(formatter[0]));
var api = createMonacoBaseAPI();
api.editor = createMonacoEditorAPI();
api.languages = createMonacoLanguagesAPI();
var CancellationTokenSource2 = api.CancellationTokenSource;
var Emitter2 = api.Emitter;
var KeyCode = api.KeyCode;
var KeyMod = api.KeyMod;
var Position2 = api.Position;
var Range2 = api.Range;
var Selection2 = api.Selection;
var SelectionDirection = api.SelectionDirection;
var MarkerSeverity2 = api.MarkerSeverity;
var MarkerTag = api.MarkerTag;
var Uri = api.Uri;
var Token2 = api.Token;
var editor = api.editor;
var languages = api.languages;
var monacoEnvironment = globalThis.MonacoEnvironment;
if ((monacoEnvironment === null || monacoEnvironment === void 0 ? void 0 : monacoEnvironment.globalAPI) || typeof define === "function" && define.amd) {
  globalThis.monaco = api;
}
if (typeof globalThis.require !== "undefined" && typeof globalThis.require.config === "function") {
  globalThis.require.config({
    ignoreDuplicateModules: [
      "vscode-languageserver-types",
      "vscode-languageserver-types/main",
      "vscode-languageserver-textdocument",
      "vscode-languageserver-textdocument/main",
      "vscode-nls",
      "vscode-nls/vscode-nls",
      "jsonc-parser",
      "jsonc-parser/main",
      "vscode-uri",
      "vscode-uri/index",
      "vs/basic-languages/typescript/typescript"
    ]
  });
}
export {
  CancellationTokenSource2 as CancellationTokenSource,
  Emitter2 as Emitter,
  KeyCode,
  KeyMod,
  MarkerSeverity2 as MarkerSeverity,
  MarkerTag,
  Position2 as Position,
  Range2 as Range,
  Selection2 as Selection,
  SelectionDirection,
  Token2 as Token,
  Uri,
  editor,
  languages
};
//# sourceMappingURL=monaco-editor.js.map
