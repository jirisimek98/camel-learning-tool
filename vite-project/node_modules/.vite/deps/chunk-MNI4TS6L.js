import {
  getLocalExtHostExtensionService,
  getServiceOverride,
  getServiceOverride2 as getServiceOverride3,
  getServiceOverride3 as getServiceOverride4,
  getServiceOverride4 as getServiceOverride5
} from "./chunk-HTQTW6ZX.js";
import {
  init_api,
  setDefaultApi
} from "./chunk-FXNOABVO.js";
import {
  serviceInitializedBarrier,
  startup
} from "./chunk-YG4SQHIW.js";
import {
  IWorkbenchEnvironmentService,
  getServiceOverride as getServiceOverride2,
  registerExtensionFile
} from "./chunk-HX5C5RYF.js";
import {
  init_debug,
  init_remoteAuthorityResolver
} from "./chunk-E2764U5K.js";
import {
  IExtensionService,
  getExtensionId
} from "./chunk-UI7MTZPM.js";
import {
  Barrier,
  Promises,
  RunOnceScheduler,
  StandaloneServices,
  init_async,
  init_codeEditorService,
  init_commands,
  init_configuration,
  init_descriptors,
  init_editorWorker,
  init_language,
  init_languageConfigurationRegistry,
  init_languageFeatures,
  init_model,
  init_opener,
  init_resolverService,
  init_themeService,
  isUserDataProfile,
  mark,
  runWhenIdle
} from "./chunk-Z3Z4BZM7.js";
import {
  Disposable,
  DisposableStore,
  Emitter,
  Event,
  FileAccess,
  MutableDisposable,
  PauseableEmitter,
  Schemas,
  URI,
  dispose,
  init_contextkey,
  init_event,
  init_files,
  init_instantiation,
  init_lifecycle,
  init_log,
  init_network,
  init_nls,
  init_resources,
  init_telemetry,
  init_types,
  init_uri,
  isObject,
  isString,
  isUndefinedOrNull,
  joinPath,
  localize
} from "./chunk-N5MAMNNV.js";

// node_modules/vscode/extensions.js
init_uri();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/platform/extensionManagement/common/extensionNls.js
init_types();
init_nls();
function localizeManifest(extensionManifest, translations, fallbackTranslations) {
  try {
    replaceNLStrings(extensionManifest, translations, fallbackTranslations);
  } catch (error) {
    console.error((error == null ? void 0 : error.message) ?? error);
  }
  return extensionManifest;
}
function replaceNLStrings(extensionManifest, messages, originalMessages) {
  const processEntry = (obj, key, command) => {
    const value = obj[key];
    if (isString(value)) {
      const str = value;
      const length = str.length;
      if (length > 1 && str[0] === "%" && str[length - 1] === "%") {
        const messageKey = str.substr(1, length - 2);
        let translated = messages[messageKey];
        if (translated === void 0 && originalMessages) {
          translated = originalMessages[messageKey];
        }
        const message = typeof translated === "string" ? translated : translated == null ? void 0 : translated.message;
        const original = originalMessages == null ? void 0 : originalMessages[messageKey];
        const originalMessage = typeof original === "string" ? original : original == null ? void 0 : original.message;
        if (!message) {
          if (!originalMessage) {
            console.warn(`[${extensionManifest.name}]: ${localize("missingNLSKey", "Couldn't find message for key {0}.", messageKey)}`);
          }
          return;
        }
        if (command && (key === "title" || key === "category") && originalMessage && originalMessage !== message) {
          const localizedString = {
            value: message,
            original: originalMessage
          };
          obj[key] = localizedString;
        } else {
          obj[key] = message;
        }
      }
    } else if (isObject(value)) {
      for (const k in value) {
        if (value.hasOwnProperty(k)) {
          k === "commands" ? processEntry(value, k, true) : processEntry(value, k, command);
        }
      }
    } else if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        processEntry(value, i, command);
      }
    }
  };
  for (const key in extensionManifest) {
    if (extensionManifest.hasOwnProperty(key)) {
      processEntry(extensionManifest, key);
    }
  }
}

// node_modules/vscode/extensions.js
init_resources();
init_network();
init_async();
init_api();

// node_modules/vscode/vscode/src/vs/platform/storage/common/storage.js
init_async();
init_event();
init_lifecycle();
init_types();
var IS_NEW_KEY = "__$__isNewStorageMarker";
var TARGET_KEY = "__$__targetStorageMarker";
var WillSaveStateReason;
(function(WillSaveStateReason2) {
  WillSaveStateReason2[WillSaveStateReason2["NONE"] = 0] = "NONE";
  WillSaveStateReason2[WillSaveStateReason2["SHUTDOWN"] = 1] = "SHUTDOWN";
})(WillSaveStateReason || (WillSaveStateReason = {}));
var StorageScope;
(function(StorageScope2) {
  StorageScope2[StorageScope2["APPLICATION"] = -1] = "APPLICATION";
  StorageScope2[StorageScope2["PROFILE"] = 0] = "PROFILE";
  StorageScope2[StorageScope2["WORKSPACE"] = 1] = "WORKSPACE";
})(StorageScope || (StorageScope = {}));
var StorageTarget;
(function(StorageTarget2) {
  StorageTarget2[StorageTarget2["USER"] = 0] = "USER";
  StorageTarget2[StorageTarget2["MACHINE"] = 1] = "MACHINE";
})(StorageTarget || (StorageTarget = {}));
function loadKeyTargets(storage) {
  const keysRaw = storage.get(TARGET_KEY);
  if (keysRaw) {
    try {
      return JSON.parse(keysRaw);
    } catch (error) {
    }
  }
  return /* @__PURE__ */ Object.create(null);
}
var _AbstractStorageService = class _AbstractStorageService extends Disposable {
  constructor(options = { flushInterval: _AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {
    super();
    this.options = options;
    this._onDidChangeValue = this._register(new PauseableEmitter());
    this._onDidChangeTarget = this._register(new PauseableEmitter());
    this.onDidChangeTarget = this._onDidChangeTarget.event;
    this._onWillSaveState = this._register(new Emitter());
    this.onWillSaveState = this._onWillSaveState.event;
    this.flushWhenIdleScheduler = this._register(new RunOnceScheduler(() => this.doFlushWhenIdle(), this.options.flushInterval));
    this.runFlushWhenIdle = this._register(new MutableDisposable());
    this._workspaceKeyTargets = void 0;
    this._profileKeyTargets = void 0;
    this._applicationKeyTargets = void 0;
  }
  onDidChangeValue(scope, key, disposable) {
    return Event.filter(this._onDidChangeValue.event, (e) => e.scope === scope && (key === void 0 || e.key === key), disposable);
  }
  doFlushWhenIdle() {
    this.runFlushWhenIdle.value = runWhenIdle(() => {
      if (this.shouldFlushWhenIdle()) {
        this.flush();
      }
      this.flushWhenIdleScheduler.schedule();
    });
  }
  shouldFlushWhenIdle() {
    return true;
  }
  stopFlushWhenIdle() {
    dispose([this.runFlushWhenIdle, this.flushWhenIdleScheduler]);
  }
  initialize() {
    if (!this.initializationPromise) {
      this.initializationPromise = (async () => {
        mark("code/willInitStorage");
        try {
          await this.doInitialize();
        } finally {
          mark("code/didInitStorage");
        }
        this.flushWhenIdleScheduler.schedule();
      })();
    }
    return this.initializationPromise;
  }
  emitDidChangeValue(scope, event) {
    const { key, external } = event;
    if (key === TARGET_KEY) {
      switch (scope) {
        case -1:
          this._applicationKeyTargets = void 0;
          break;
        case 0:
          this._profileKeyTargets = void 0;
          break;
        case 1:
          this._workspaceKeyTargets = void 0;
          break;
      }
      this._onDidChangeTarget.fire({ scope });
    } else {
      this._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key], external });
    }
  }
  emitWillSaveState(reason) {
    this._onWillSaveState.fire({ reason });
  }
  get(key, scope, fallbackValue) {
    var _a;
    return (_a = this.getStorage(scope)) == null ? void 0 : _a.get(key, fallbackValue);
  }
  getBoolean(key, scope, fallbackValue) {
    var _a;
    return (_a = this.getStorage(scope)) == null ? void 0 : _a.getBoolean(key, fallbackValue);
  }
  getNumber(key, scope, fallbackValue) {
    var _a;
    return (_a = this.getStorage(scope)) == null ? void 0 : _a.getNumber(key, fallbackValue);
  }
  getObject(key, scope, fallbackValue) {
    var _a;
    return (_a = this.getStorage(scope)) == null ? void 0 : _a.getObject(key, fallbackValue);
  }
  storeAll(entries, external) {
    this.withPausedEmitters(() => {
      for (const entry of entries) {
        this.store(entry.key, entry.value, entry.scope, entry.target, external);
      }
    });
  }
  store(key, value, scope, target, external = false) {
    if (isUndefinedOrNull(value)) {
      this.remove(key, scope, external);
      return;
    }
    this.withPausedEmitters(() => {
      var _a;
      this.updateKeyTarget(key, scope, target);
      (_a = this.getStorage(scope)) == null ? void 0 : _a.set(key, value, external);
    });
  }
  remove(key, scope, external = false) {
    this.withPausedEmitters(() => {
      var _a;
      this.updateKeyTarget(key, scope, void 0);
      (_a = this.getStorage(scope)) == null ? void 0 : _a.delete(key, external);
    });
  }
  withPausedEmitters(fn) {
    this._onDidChangeValue.pause();
    this._onDidChangeTarget.pause();
    try {
      fn();
    } finally {
      this._onDidChangeValue.resume();
      this._onDidChangeTarget.resume();
    }
  }
  keys(scope, target) {
    const keys = [];
    const keyTargets = this.getKeyTargets(scope);
    for (const key of Object.keys(keyTargets)) {
      const keyTarget = keyTargets[key];
      if (keyTarget === target) {
        keys.push(key);
      }
    }
    return keys;
  }
  updateKeyTarget(key, scope, target, external = false) {
    var _a, _b;
    const keyTargets = this.getKeyTargets(scope);
    if (typeof target === "number") {
      if (keyTargets[key] !== target) {
        keyTargets[key] = target;
        (_a = this.getStorage(scope)) == null ? void 0 : _a.set(TARGET_KEY, JSON.stringify(keyTargets), external);
      }
    } else {
      if (typeof keyTargets[key] === "number") {
        delete keyTargets[key];
        (_b = this.getStorage(scope)) == null ? void 0 : _b.set(TARGET_KEY, JSON.stringify(keyTargets), external);
      }
    }
  }
  get workspaceKeyTargets() {
    if (!this._workspaceKeyTargets) {
      this._workspaceKeyTargets = this.loadKeyTargets(1);
    }
    return this._workspaceKeyTargets;
  }
  get profileKeyTargets() {
    if (!this._profileKeyTargets) {
      this._profileKeyTargets = this.loadKeyTargets(0);
    }
    return this._profileKeyTargets;
  }
  get applicationKeyTargets() {
    if (!this._applicationKeyTargets) {
      this._applicationKeyTargets = this.loadKeyTargets(-1);
    }
    return this._applicationKeyTargets;
  }
  getKeyTargets(scope) {
    switch (scope) {
      case -1:
        return this.applicationKeyTargets;
      case 0:
        return this.profileKeyTargets;
      default:
        return this.workspaceKeyTargets;
    }
  }
  loadKeyTargets(scope) {
    const storage = this.getStorage(scope);
    return storage ? loadKeyTargets(storage) : /* @__PURE__ */ Object.create(null);
  }
  isNew(scope) {
    return this.getBoolean(IS_NEW_KEY, scope) === true;
  }
  async flush(reason = WillSaveStateReason.NONE) {
    this._onWillSaveState.fire({ reason });
    const applicationStorage = this.getStorage(-1);
    const profileStorage = this.getStorage(0);
    const workspaceStorage = this.getStorage(1);
    switch (reason) {
      case WillSaveStateReason.NONE:
        await Promises.settled([
          (applicationStorage == null ? void 0 : applicationStorage.whenFlushed()) ?? Promise.resolve(),
          (profileStorage == null ? void 0 : profileStorage.whenFlushed()) ?? Promise.resolve(),
          (workspaceStorage == null ? void 0 : workspaceStorage.whenFlushed()) ?? Promise.resolve()
        ]);
        break;
      case WillSaveStateReason.SHUTDOWN:
        await Promises.settled([
          (applicationStorage == null ? void 0 : applicationStorage.flush(0)) ?? Promise.resolve(),
          (profileStorage == null ? void 0 : profileStorage.flush(0)) ?? Promise.resolve(),
          (workspaceStorage == null ? void 0 : workspaceStorage.flush(0)) ?? Promise.resolve()
        ]);
        break;
    }
  }
  async log() {
    var _a, _b, _c;
    const applicationItems = ((_a = this.getStorage(-1)) == null ? void 0 : _a.items) ?? /* @__PURE__ */ new Map();
    const profileItems = ((_b = this.getStorage(0)) == null ? void 0 : _b.items) ?? /* @__PURE__ */ new Map();
    const workspaceItems = ((_c = this.getStorage(1)) == null ? void 0 : _c.items) ?? /* @__PURE__ */ new Map();
    return logStorage(applicationItems, profileItems, workspaceItems, this.getLogDetails(-1) ?? "", this.getLogDetails(0) ?? "", this.getLogDetails(1) ?? "");
  }
  async switch(to, preserveData) {
    this.emitWillSaveState(WillSaveStateReason.NONE);
    if (isUserDataProfile(to)) {
      return this.switchToProfile(to, preserveData);
    }
    return this.switchToWorkspace(to, preserveData);
  }
  canSwitchProfile(from, to) {
    if (from.id === to.id) {
      return false;
    }
    if (isProfileUsingDefaultStorage(to) && isProfileUsingDefaultStorage(from)) {
      return false;
    }
    return true;
  }
  switchData(oldStorage, newStorage, scope) {
    this.withPausedEmitters(() => {
      const handledkeys = /* @__PURE__ */ new Set();
      for (const [key, oldValue] of oldStorage) {
        handledkeys.add(key);
        const newValue = newStorage.get(key);
        if (newValue !== oldValue) {
          this.emitDidChangeValue(scope, { key, external: true });
        }
      }
      for (const [key] of newStorage.items) {
        if (!handledkeys.has(key)) {
          this.emitDidChangeValue(scope, { key, external: true });
        }
      }
    });
  }
};
_AbstractStorageService.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
var AbstractStorageService = _AbstractStorageService;
function isProfileUsingDefaultStorage(profile) {
  var _a;
  return profile.isDefault || !!((_a = profile.useDefaultFlags) == null ? void 0 : _a.globalState);
}
async function logStorage(application, profile, workspace, applicationPath, profilePath, workspacePath) {
  const safeParse = (value) => {
    try {
      return JSON.parse(value);
    } catch (error) {
      return value;
    }
  };
  const applicationItems = /* @__PURE__ */ new Map();
  const applicationItemsParsed = /* @__PURE__ */ new Map();
  application.forEach((value, key) => {
    applicationItems.set(key, value);
    applicationItemsParsed.set(key, safeParse(value));
  });
  const profileItems = /* @__PURE__ */ new Map();
  const profileItemsParsed = /* @__PURE__ */ new Map();
  profile.forEach((value, key) => {
    profileItems.set(key, value);
    profileItemsParsed.set(key, safeParse(value));
  });
  const workspaceItems = /* @__PURE__ */ new Map();
  const workspaceItemsParsed = /* @__PURE__ */ new Map();
  workspace.forEach((value, key) => {
    workspaceItems.set(key, value);
    workspaceItemsParsed.set(key, safeParse(value));
  });
  if (applicationPath !== profilePath) {
    console.group(`Storage: Application (path: ${applicationPath})`);
  } else {
    console.group(`Storage: Application & Profile (path: ${applicationPath}, default profile)`);
  }
  const applicationValues = [];
  applicationItems.forEach((value, key) => {
    applicationValues.push({ key, value });
  });
  console.table(applicationValues);
  console.groupEnd();
  console.log(applicationItemsParsed);
  if (applicationPath !== profilePath) {
    console.group(`Storage: Profile (path: ${profilePath}, profile specific)`);
    const profileValues = [];
    profileItems.forEach((value, key) => {
      profileValues.push({ key, value });
    });
    console.table(profileValues);
    console.groupEnd();
    console.log(profileItemsParsed);
  }
  console.group(`Storage: Workspace (path: ${workspacePath})`);
  const workspaceValues = [];
  workspaceItems.forEach((value, key) => {
    workspaceValues.push({ key, value });
  });
  console.table(workspaceValues);
  console.groupEnd();
  console.log(workspaceItemsParsed);
}

// node_modules/vscode/services.js
init_descriptors();
init_commands();
init_codeEditorService();
init_language();
init_languageConfigurationRegistry();
init_editorWorker();
init_languageFeatures();
init_model();
init_resolverService();
init_files();
init_instantiation();
init_opener();
init_telemetry();
init_configuration();
init_contextkey();
init_themeService();
init_debug();
init_log();
init_remoteAuthorityResolver();
async function initialize(overrides, container) {
  const instantiationService = StandaloneServices.initialize({
    ...getServiceOverride3(container),
    ...getServiceOverride4(),
    ...getServiceOverride(),
    ...getServiceOverride2(),
    ...getServiceOverride5(),
    ...overrides
  });
  await startup(instantiationService);
}
async function getService(identifier) {
  await serviceInitializedBarrier.wait();
  return StandaloneServices.get(identifier);
}

// node_modules/vscode/extensions.js
var defaultApiInitializeBarrier = new Barrier();
async function initialize2() {
  await getLocalExtHostExtensionService().then(async (extHostExtensionService) => {
    setDefaultApi(await extHostExtensionService.getApi());
    defaultApiInitializeBarrier.open();
  });
}
function registerExtensionFileUrl(extensionLocation, filePath, url, mimeType) {
  const fileDisposable = new DisposableStore();
  fileDisposable.add(FileAccess.registerStaticBrowserUri(joinPath(extensionLocation, filePath), URI.parse(url)));
  fileDisposable.add(registerExtensionFile(extensionLocation, filePath, async () => {
    const response = await fetch(url, {
      headers: mimeType != null ? {
        Accept: mimeType
      } : {}
    });
    if (response.status !== 200) {
      throw new Error(response.statusText);
    }
    return new Uint8Array(await response.arrayBuffer());
  }));
  return fileDisposable;
}
var _toAdd = [];
var _toRemove = [];
var lastPromise;
async function deltaExtensions(toAdd, toRemove) {
  _toAdd.push(...toAdd);
  _toRemove.push(...toRemove);
  if (lastPromise == null) {
    lastPromise = new Promise((resolve) => setTimeout(resolve)).then(async () => {
      const extensionService = await getService(IExtensionService);
      await extensionService.deltaExtensions(_toAdd, _toRemove);
      _toAdd = [];
      _toRemove = [];
      lastPromise = void 0;
    });
  }
  await lastPromise;
}
function registerExtension(manifest, extHostKind, { defaultNLS, builtin = manifest.publisher === "vscode", path = "/" } = {}) {
  const disposableStore = new DisposableStore();
  const localizedManifest = defaultNLS != null ? localizeManifest(manifest, defaultNLS) : manifest;
  const id = getExtensionId(localizedManifest.publisher, localizedManifest.name);
  let extension = {
    manifest: localizedManifest,
    type: builtin ? 0 : 1,
    isBuiltin: builtin,
    identifier: { id },
    location: URI.from({ scheme: "extension", authority: id, path }),
    targetPlatform: "web",
    isValid: true,
    validations: [],
    extHostKind
  };
  const addExtensionPromise = (async () => {
    if (extHostKind === 3) {
      const remoteAuthority = (await getService(IWorkbenchEnvironmentService)).remoteAuthority;
      extension = {
        ...extension,
        location: URI.from({ scheme: Schemas.vscodeRemote, authority: remoteAuthority, path })
      };
    }
    await deltaExtensions([extension], []);
    return extension;
  })();
  let api = {
    id,
    async whenReady() {
      await addExtensionPromise;
    },
    async dispose() {
      const extension2 = await addExtensionPromise;
      await deltaExtensions([], [extension2]);
      disposableStore.dispose();
    }
  };
  if (extHostKind !== 3) {
    let registerFileUrl = function(path2, url, mimeType) {
      return registerExtensionFileUrl(extension.location, path2, url, mimeType);
    };
    api = {
      ...api,
      registerFileUrl
    };
  }
  if (extHostKind === 1) {
    async function getApi() {
      await addExtensionPromise;
      return (await getLocalExtHostExtensionService()).getApi(id);
    }
    api = {
      ...api,
      getApi,
      async setAsDefaultApi() {
        setDefaultApi(await getApi());
      }
    };
  }
  return api;
}
function onExtHostInitialized(fct) {
  void defaultApiInitializeBarrier.wait().then(fct);
}

export {
  initialize,
  initialize2,
  registerExtension,
  onExtHostInitialized
};
//# sourceMappingURL=chunk-MNI4TS6L.js.map
