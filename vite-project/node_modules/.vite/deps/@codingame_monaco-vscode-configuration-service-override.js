import {
  registerServiceInitializePreParticipant
} from "./chunk-ZVOC25HY.js";
import {
  IDialogService,
  IFileDialogService,
  IHostService,
  IJSONEditingService,
  IPathService,
  IPreferencesService,
  IWorkbenchAssignmentService,
  IWorkbenchEnvironmentService,
  IWorkspaceEditingService,
  IWorkspacesService,
  Memento,
  getServiceOverride,
  getStoredWorkspaceFolder,
  getWorkspaceIdentifier,
  isRecentFile,
  isRecentFolder,
  isRecentWorkspace,
  isStoredWorkspaceFolder,
  memoizedConstructor,
  restoreRecentlyOpened,
  rewriteWorkspaceFileForNewLocation,
  setProperty,
  toStoreData,
  toWorkspaceFolders,
  unsupported
} from "./chunk-AR3QIQFF.js";
import "./chunk-E2764U5K.js";
import "./chunk-MEAKYGIF.js";
import {
  Extensions as Extensions2,
  ExtensionsRegistry,
  IEditorService,
  IExtensionService,
  ILifecycleService,
  IRemoteAgentService,
  ITextFileService,
  IUserDataProfileService,
  isProposedApiEnabled,
  workbenchConfigurationNodeBase
} from "./chunk-ETI4KOTI.js";
import {
  __decorate,
  __param,
  init_tslib_es6
} from "./chunk-GJDIUAXO.js";
import {
  Barrier,
  Configuration,
  ConfigurationChangeEvent,
  ConfigurationModel,
  ConfigurationModelParser,
  ConfigurationTargetToString,
  DefaultConfiguration,
  Delayer,
  EditOperation,
  Extensions,
  Extensions2 as Extensions3,
  ICommandService,
  IConfigurationService,
  ILabelService,
  ILanguageService,
  IModelService,
  INotificationService,
  IPolicyService,
  IStorageService,
  ITextModelService,
  ITextResourceConfigurationService,
  IUriIdentityService,
  IUserDataProfilesService,
  IWorkspaceContextService,
  IWorkspaceTrustManagementService,
  NullPolicyConfiguration,
  NullPolicyService,
  OVERRIDE_PROPERTY_PATTERN,
  OVERRIDE_PROPERTY_REGEX,
  PolicyConfiguration,
  Position,
  Promises,
  Queue,
  Range,
  Registry,
  RunOnceScheduler,
  Selection,
  Severity,
  StandaloneServices,
  SyncDescriptor,
  UserSettings,
  WORKSPACE_EXTENSION,
  WORKSPACE_FILTER,
  Workspace,
  allSettings,
  applicationSettings,
  configurationDefaultsSchemaId,
  getPathLabel,
  hasWorkspaceFileExtension,
  init_async,
  init_commands,
  init_configuration,
  init_configurationRegistry,
  init_descriptors,
  init_editOperation,
  init_jsonContributionRegistry,
  init_language,
  init_model,
  init_platform as init_platform2,
  init_position,
  init_range,
  init_resolverService,
  init_selection,
  isConfigurationOverrides,
  isConfigurationUpdateOverrides,
  isSavedWorkspace,
  isSingleFolderWorkspaceIdentifier,
  isTemporaryWorkspace,
  isUntitledWorkspace,
  isWorkspace,
  isWorkspaceFolder,
  isWorkspaceIdentifier,
  keyFromOverrideIdentifiers,
  machineOverridableSettings,
  machineSettings,
  mark,
  match,
  mergeChanges,
  mnemonicButtonLabel,
  parse3 as parse,
  resourceLanguageSettingsSchemaId,
  resourceSettings,
  runWhenIdle,
  tildify,
  toValuesTree,
  toWorkspaceFolder,
  toWorkspaceIdentifier,
  validateProperty,
  windowSettings
} from "./chunk-O3SOEW3V.js";
import {
  Disposable,
  DisposableStore,
  Emitter,
  ErrorNoTelemetry,
  Event,
  ExtensionIdentifierMap,
  IFileService,
  IInstantiationService,
  ILogService,
  MutableDisposable,
  OS,
  ResourceMap,
  Schemas,
  URI,
  VSBuffer,
  basename2 as basename,
  basenameOrAuthority,
  combinedDisposable,
  deepClone,
  delta,
  dirname2 as dirname,
  dispose,
  distinct,
  equals2 as equals,
  firstOrDefault,
  generateUuid,
  getErrorMessage,
  hash,
  init_arrays,
  init_buffer,
  init_errorMessage,
  init_errors,
  init_event,
  init_extensions,
  init_files,
  init_hash,
  init_instantiation,
  init_lifecycle,
  init_log,
  init_map,
  init_network,
  init_nls,
  init_objects,
  init_path,
  init_platform,
  init_resources,
  init_types,
  init_uri,
  init_uuid,
  isBoolean,
  isEmptyObject,
  isEqual2 as isEqual,
  isObject,
  isUndefined,
  joinPath,
  localize,
  posix,
  refineServiceDecorator,
  removeTrailingPathSeparator,
  sep,
  toDisposable,
  toErrorMessage,
  whenProviderRegistered,
  win32
} from "./chunk-N5MAMNNV.js";
import "./chunk-PGWBAY6J.js";

// node_modules/vscode/service-override/configuration.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/browser/configurationService.js
init_tslib_es6();
init_uri();
init_event();
init_map();
init_objects();
init_lifecycle();
init_async();
init_jsonContributionRegistry();
init_configuration();

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/common/configurationModels.js
init_objects();
init_configuration();
init_types();
init_arrays();
var WorkspaceConfigurationModelParser = class extends ConfigurationModelParser {
  constructor(name) {
    super(name);
    this._folders = [];
    this._transient = false;
    this._settingsModelParser = new ConfigurationModelParser(name);
    this._launchModel = new ConfigurationModel();
    this._tasksModel = new ConfigurationModel();
  }
  get folders() {
    return this._folders;
  }
  get transient() {
    return this._transient;
  }
  get settingsModel() {
    return this._settingsModelParser.configurationModel;
  }
  get launchModel() {
    return this._launchModel;
  }
  get tasksModel() {
    return this._tasksModel;
  }
  reparseWorkspaceSettings(configurationParseOptions) {
    this._settingsModelParser.reparse(configurationParseOptions);
  }
  getRestrictedWorkspaceSettings() {
    return this._settingsModelParser.restrictedConfigurations;
  }
  doParseRaw(raw, configurationParseOptions) {
    this._folders = raw["folders"] || [];
    this._transient = isBoolean(raw["transient"]) && raw["transient"];
    this._settingsModelParser.parseRaw(raw["settings"], configurationParseOptions);
    this._launchModel = this.createConfigurationModelFrom(raw, "launch");
    this._tasksModel = this.createConfigurationModelFrom(raw, "tasks");
    return super.doParseRaw(raw, configurationParseOptions);
  }
  createConfigurationModelFrom(raw, key) {
    const data = raw[key];
    if (data) {
      const contents = toValuesTree(data, (message) => console.error(`Conflict in settings file ${this._name}: ${message}`));
      const scopedContents = /* @__PURE__ */ Object.create(null);
      scopedContents[key] = contents;
      const keys = Object.keys(data).map((k) => `${key}.${k}`);
      return new ConfigurationModel(scopedContents, keys, []);
    }
    return new ConfigurationModel();
  }
};
var StandaloneConfigurationModelParser = class extends ConfigurationModelParser {
  constructor(name, scope) {
    super(name);
    this.scope = scope;
  }
  doParseRaw(raw, configurationParseOptions) {
    const contents = toValuesTree(raw, (message) => console.error(`Conflict in settings file ${this._name}: ${message}`));
    const scopedContents = /* @__PURE__ */ Object.create(null);
    scopedContents[this.scope] = contents;
    const keys = Object.keys(raw).map((key) => `${this.scope}.${key}`);
    return { contents: scopedContents, keys, overrides: [] };
  }
};
var Configuration2 = class extends Configuration {
  constructor(defaults, policy, application, localUser, remoteUser, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource, _workspace) {
    super(defaults, policy, application, localUser, remoteUser, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource);
    this._workspace = _workspace;
  }
  getValue(key, overrides = {}) {
    return super.getValue(key, overrides, this._workspace);
  }
  inspect(key, overrides = {}) {
    return super.inspect(key, overrides, this._workspace);
  }
  keys() {
    return super.keys(this._workspace);
  }
  compareAndDeleteFolderConfiguration(folder) {
    if (this._workspace && this._workspace.folders.length > 0 && this._workspace.folders[0].uri.toString() === folder.toString()) {
      return { keys: [], overrides: [] };
    }
    return super.compareAndDeleteFolderConfiguration(folder);
  }
  compare(other) {
    const compare = (fromKeys, toKeys, overrideIdentifier) => {
      const keys2 = [];
      keys2.push(...toKeys.filter((key) => fromKeys.indexOf(key) === -1));
      keys2.push(...fromKeys.filter((key) => toKeys.indexOf(key) === -1));
      keys2.push(...fromKeys.filter((key) => {
        if (toKeys.indexOf(key) === -1) {
          return false;
        }
        if (!equals(this.getValue(key, { overrideIdentifier }), other.getValue(key, { overrideIdentifier }))) {
          return true;
        }
        return this._workspace && this._workspace.folders.some(
          (folder) => !equals(this.getValue(key, { resource: folder.uri, overrideIdentifier }), other.getValue(key, { resource: folder.uri, overrideIdentifier }))
        );
      }));
      return keys2;
    };
    const keys = compare(this.allKeys(), other.allKeys());
    const overrides = [];
    const allOverrideIdentifiers = distinct([...this.allOverrideIdentifiers(), ...other.allOverrideIdentifiers()]);
    for (const overrideIdentifier of allOverrideIdentifiers) {
      const keys2 = compare(this.getAllKeysForOverrideIdentifier(overrideIdentifier), other.getAllKeysForOverrideIdentifier(overrideIdentifier), overrideIdentifier);
      if (keys2.length) {
        overrides.push([overrideIdentifier, keys2]);
      }
    }
    return { keys, overrides };
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/common/configuration.js
init_configuration();
init_instantiation();
var FOLDER_CONFIG_FOLDER_NAME = ".vscode";
var FOLDER_SETTINGS_NAME = "settings";
var FOLDER_SETTINGS_PATH = `${FOLDER_CONFIG_FOLDER_NAME}/${FOLDER_SETTINGS_NAME}.json`;
var defaultSettingsSchemaId = "vscode://schemas/settings/default";
var userSettingsSchemaId = "vscode://schemas/settings/user";
var profileSettingsSchemaId = "vscode://schemas/settings/profile";
var machineSettingsSchemaId = "vscode://schemas/settings/machine";
var workspaceSettingsSchemaId = "vscode://schemas/settings/workspace";
var folderSettingsSchemaId = "vscode://schemas/settings/folder";
var launchSchemaId = "vscode://schemas/launch";
var tasksSchemaId = "vscode://schemas/tasks";
var PROFILE_SCOPES = [2, 3, 4, 5, 6];
var LOCAL_MACHINE_PROFILE_SCOPES = [3, 4, 5];
var LOCAL_MACHINE_SCOPES = [1, ...LOCAL_MACHINE_PROFILE_SCOPES];
var REMOTE_MACHINE_SCOPES = [2, 3, 4, 5, 6];
var WORKSPACE_SCOPES = [3, 4, 5, 6];
var FOLDER_SCOPES = [4, 5, 6];
var TASKS_CONFIGURATION_KEY = "tasks";
var LAUNCH_CONFIGURATION_KEY = "launch";
var WORKSPACE_STANDALONE_CONFIGURATIONS = /* @__PURE__ */ Object.create(null);
WORKSPACE_STANDALONE_CONFIGURATIONS[TASKS_CONFIGURATION_KEY] = `${FOLDER_CONFIG_FOLDER_NAME}/${TASKS_CONFIGURATION_KEY}.json`;
WORKSPACE_STANDALONE_CONFIGURATIONS[LAUNCH_CONFIGURATION_KEY] = `${FOLDER_CONFIG_FOLDER_NAME}/${LAUNCH_CONFIGURATION_KEY}.json`;
var USER_STANDALONE_CONFIGURATIONS = /* @__PURE__ */ Object.create(null);
USER_STANDALONE_CONFIGURATIONS[TASKS_CONFIGURATION_KEY] = `${TASKS_CONFIGURATION_KEY}.json`;
var IWorkbenchConfigurationService = refineServiceDecorator(IConfigurationService);
var TASKS_DEFAULT = '{\n	"version": "2.0.0",\n	"tasks": []\n}';
var APPLY_ALL_PROFILES_SETTING = "workbench.settings.applyToAllProfiles";

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/browser/configurationService.js
init_platform2();
init_configurationRegistry();

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/common/configurationEditing.js
init_tslib_es6();
init_nls();
init_async();
init_platform2();
init_files();
init_resolverService();
init_configurationRegistry();
init_range();
init_editOperation();
init_selection();
init_errors();
var ConfigurationEditingError = class extends ErrorNoTelemetry {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};
var ConfigurationEditing = class ConfigurationEditing2 {
  constructor(remoteSettingsResource, configurationService, contextService, userDataProfileService, userDataProfilesService, fileService, textModelResolverService, textFileService, notificationService, preferencesService, editorService, uriIdentityService) {
    this.remoteSettingsResource = remoteSettingsResource;
    this.configurationService = configurationService;
    this.contextService = contextService;
    this.userDataProfileService = userDataProfileService;
    this.userDataProfilesService = userDataProfilesService;
    this.fileService = fileService;
    this.textModelResolverService = textModelResolverService;
    this.textFileService = textFileService;
    this.notificationService = notificationService;
    this.preferencesService = preferencesService;
    this.editorService = editorService;
    this.uriIdentityService = uriIdentityService;
    this.queue = new Queue();
  }
  async writeConfiguration(target, value, options = {}) {
    const operation = this.getConfigurationEditOperation(target, value, options.scopes || {});
    return this.queue.queue(async () => {
      try {
        await this.doWriteConfiguration(operation, options);
      } catch (error) {
        if (options.donotNotifyError) {
          throw error;
        }
        await this.onError(error, operation, options.scopes);
      }
    });
  }
  async doWriteConfiguration(operation, options) {
    await this.validate(operation.target, operation, !options.handleDirtyFile, options.scopes || {});
    const resource = operation.resource;
    const reference = await this.resolveModelReference(resource);
    try {
      const formattingOptions = this.getFormattingOptions(reference.object.textEditorModel);
      await this.updateConfiguration(operation, reference.object.textEditorModel, formattingOptions, options);
    } finally {
      reference.dispose();
    }
  }
  async updateConfiguration(operation, model, formattingOptions, options) {
    if (this.hasParseErrors(model.getValue(), operation)) {
      throw this.toConfigurationEditingError(11, operation.target, operation);
    }
    if (this.textFileService.isDirty(model.uri) && options.handleDirtyFile) {
      switch (options.handleDirtyFile) {
        case "save":
          await this.save(model, operation);
          break;
        case "revert":
          await this.textFileService.revert(model.uri);
          break;
      }
    }
    const edit = this.getEdits(operation, model.getValue(), formattingOptions)[0];
    if (edit && this.applyEditsToBuffer(edit, model)) {
      await this.save(model, operation);
    }
  }
  async save(model, operation) {
    try {
      await this.textFileService.save(model.uri, { ignoreErrorHandler: true });
    } catch (error) {
      if (error.fileOperationResult === 3) {
        throw this.toConfigurationEditingError(10, operation.target, operation);
      }
      throw new ConfigurationEditingError(localize("fsError", "Error while writing to {0}. {1}", this.stringifyTarget(operation.target), error.message), 13);
    }
  }
  applyEditsToBuffer(edit, model) {
    const startPosition = model.getPositionAt(edit.offset);
    const endPosition = model.getPositionAt(edit.offset + edit.length);
    const range = new Range(
      startPosition.lineNumber,
      startPosition.column,
      endPosition.lineNumber,
      endPosition.column
    );
    const currentText = model.getValueInRange(range);
    if (edit.content !== currentText) {
      const editOperation = currentText ? EditOperation.replace(range, edit.content) : EditOperation.insert(startPosition, edit.content);
      model.pushEditOperations([new Selection(
        startPosition.lineNumber,
        startPosition.column,
        startPosition.lineNumber,
        startPosition.column
      )], [editOperation], () => []);
      return true;
    }
    return false;
  }
  getEdits({ value, jsonPath }, modelContent, formattingOptions) {
    if (jsonPath.length) {
      return setProperty(modelContent, jsonPath, value, formattingOptions);
    }
    const content = JSON.stringify(value, null, formattingOptions.insertSpaces && formattingOptions.tabSize ? " ".repeat(formattingOptions.tabSize) : "	");
    return [{
      content,
      length: modelContent.length,
      offset: 0
    }];
  }
  getFormattingOptions(model) {
    const { insertSpaces, tabSize } = model.getOptions();
    const eol = model.getEOL();
    return { insertSpaces, tabSize, eol };
  }
  async onError(error, operation, scopes) {
    switch (error.code) {
      case 11:
        this.onInvalidConfigurationError(error, operation);
        break;
      case 9:
        this.onConfigurationFileDirtyError(error, operation, scopes);
        break;
      case 10:
        return this.doWriteConfiguration(operation, { scopes, handleDirtyFile: "revert" });
      default:
        this.notificationService.error(error.message);
    }
  }
  onInvalidConfigurationError(error, operation) {
    const openStandAloneConfigurationActionLabel = operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY ? localize("openTasksConfiguration", "Open Tasks Configuration") : operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY ? localize("openLaunchConfiguration", "Open Launch Configuration") : null;
    if (openStandAloneConfigurationActionLabel) {
      this.notificationService.prompt(Severity.Error, error.message, [{
        label: openStandAloneConfigurationActionLabel,
        run: () => this.openFile(operation.resource)
      }]);
    } else {
      this.notificationService.prompt(Severity.Error, error.message, [{
        label: localize("open", "Open Settings"),
        run: () => this.openSettings(operation)
      }]);
    }
  }
  onConfigurationFileDirtyError(error, operation, scopes) {
    const openStandAloneConfigurationActionLabel = operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY ? localize("openTasksConfiguration", "Open Tasks Configuration") : operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY ? localize("openLaunchConfiguration", "Open Launch Configuration") : null;
    if (openStandAloneConfigurationActionLabel) {
      this.notificationService.prompt(Severity.Error, error.message, [
        {
          label: localize("saveAndRetry", "Save and Retry"),
          run: () => {
            const key = operation.key ? `${operation.workspaceStandAloneConfigurationKey}.${operation.key}` : operation.workspaceStandAloneConfigurationKey;
            this.writeConfiguration(operation.target, { key, value: operation.value }, { handleDirtyFile: "save", scopes });
          }
        },
        {
          label: openStandAloneConfigurationActionLabel,
          run: () => this.openFile(operation.resource)
        }
      ]);
    } else {
      this.notificationService.prompt(Severity.Error, error.message, [
        {
          label: localize("saveAndRetry", "Save and Retry"),
          run: () => this.writeConfiguration(operation.target, { key: operation.key, value: operation.value }, { handleDirtyFile: "save", scopes })
        },
        {
          label: localize("open", "Open Settings"),
          run: () => this.openSettings(operation)
        }
      ]);
    }
  }
  openSettings(operation) {
    const options = { jsonEditor: true };
    switch (operation.target) {
      case 1:
        this.preferencesService.openUserSettings(options);
        break;
      case 2:
        this.preferencesService.openRemoteSettings(options);
        break;
      case 3:
        this.preferencesService.openWorkspaceSettings(options);
        break;
      case 4:
        if (operation.resource) {
          const workspaceFolder = this.contextService.getWorkspaceFolder(operation.resource);
          if (workspaceFolder) {
            this.preferencesService.openFolderSettings({ folderUri: workspaceFolder.uri, jsonEditor: true });
          }
        }
        break;
    }
  }
  openFile(resource) {
    this.editorService.openEditor({ resource, options: { pinned: true } });
  }
  toConfigurationEditingError(code, target, operation) {
    const message = this.toErrorMessage(code, target, operation);
    return new ConfigurationEditingError(message, code);
  }
  toErrorMessage(error, target, operation) {
    switch (error) {
      case 12:
        return localize(
          "errorPolicyConfiguration",
          "Unable to write {0} because it is configured in system policy.",
          operation.key
        );
      case 0:
        return localize(
          "errorUnknownKey",
          "Unable to write to {0} because {1} is not a registered configuration.",
          this.stringifyTarget(target),
          operation.key
        );
      case 1:
        return localize(
          "errorInvalidWorkspaceConfigurationApplication",
          "Unable to write {0} to Workspace Settings. This setting can be written only into User settings.",
          operation.key
        );
      case 2:
        return localize(
          "errorInvalidWorkspaceConfigurationMachine",
          "Unable to write {0} to Workspace Settings. This setting can be written only into User settings.",
          operation.key
        );
      case 3:
        return localize(
          "errorInvalidFolderConfiguration",
          "Unable to write to Folder Settings because {0} does not support the folder resource scope.",
          operation.key
        );
      case 4:
        return localize(
          "errorInvalidUserTarget",
          "Unable to write to User Settings because {0} does not support for global scope.",
          operation.key
        );
      case 5:
        return localize(
          "errorInvalidWorkspaceTarget",
          "Unable to write to Workspace Settings because {0} does not support for workspace scope in a multi folder workspace.",
          operation.key
        );
      case 6:
        return localize(
          "errorInvalidFolderTarget",
          "Unable to write to Folder Settings because no resource is provided."
        );
      case 7:
        return localize(
          "errorInvalidResourceLanguageConfiguration",
          "Unable to write to Language Settings because {0} is not a resource language setting.",
          operation.key
        );
      case 8:
        return localize(
          "errorNoWorkspaceOpened",
          "Unable to write to {0} because no workspace is opened. Please open a workspace first and try again.",
          this.stringifyTarget(target)
        );
      case 11: {
        if (operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY) {
          return localize(
            "errorInvalidTaskConfiguration",
            "Unable to write into the tasks configuration file. Please open it to correct errors/warnings in it and try again."
          );
        }
        if (operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY) {
          return localize(
            "errorInvalidLaunchConfiguration",
            "Unable to write into the launch configuration file. Please open it to correct errors/warnings in it and try again."
          );
        }
        switch (target) {
          case 1:
            return localize(
              "errorInvalidConfiguration",
              "Unable to write into user settings. Please open the user settings to correct errors/warnings in it and try again."
            );
          case 2:
            return localize(
              "errorInvalidRemoteConfiguration",
              "Unable to write into remote user settings. Please open the remote user settings to correct errors/warnings in it and try again."
            );
          case 3:
            return localize(
              "errorInvalidConfigurationWorkspace",
              "Unable to write into workspace settings. Please open the workspace settings to correct errors/warnings in the file and try again."
            );
          case 4: {
            let workspaceFolderName = "<<unknown>>";
            if (operation.resource) {
              const folder = this.contextService.getWorkspaceFolder(operation.resource);
              if (folder) {
                workspaceFolderName = folder.name;
              }
            }
            return localize(
              "errorInvalidConfigurationFolder",
              "Unable to write into folder settings. Please open the '{0}' folder settings to correct errors/warnings in it and try again.",
              workspaceFolderName
            );
          }
          default:
            return "";
        }
      }
      case 9: {
        if (operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY) {
          return localize(
            "errorTasksConfigurationFileDirty",
            "Unable to write into tasks configuration file because the file has unsaved changes. Please save it first and then try again."
          );
        }
        if (operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY) {
          return localize(
            "errorLaunchConfigurationFileDirty",
            "Unable to write into launch configuration file because the file has unsaved changes. Please save it first and then try again."
          );
        }
        switch (target) {
          case 1:
            return localize(
              "errorConfigurationFileDirty",
              "Unable to write into user settings because the file has unsaved changes. Please save the user settings file first and then try again."
            );
          case 2:
            return localize(
              "errorRemoteConfigurationFileDirty",
              "Unable to write into remote user settings because the file has unsaved changes. Please save the remote user settings file first and then try again."
            );
          case 3:
            return localize(
              "errorConfigurationFileDirtyWorkspace",
              "Unable to write into workspace settings because the file has unsaved changes. Please save the workspace settings file first and then try again."
            );
          case 4: {
            let workspaceFolderName = "<<unknown>>";
            if (operation.resource) {
              const folder = this.contextService.getWorkspaceFolder(operation.resource);
              if (folder) {
                workspaceFolderName = folder.name;
              }
            }
            return localize(
              "errorConfigurationFileDirtyFolder",
              "Unable to write into folder settings because the file has unsaved changes. Please save the '{0}' folder settings file first and then try again.",
              workspaceFolderName
            );
          }
          default:
            return "";
        }
      }
      case 10:
        if (operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY) {
          return localize(
            "errorTasksConfigurationFileModifiedSince",
            "Unable to write into tasks configuration file because the content of the file is newer."
          );
        }
        if (operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY) {
          return localize(
            "errorLaunchConfigurationFileModifiedSince",
            "Unable to write into launch configuration file because the content of the file is newer."
          );
        }
        switch (target) {
          case 1:
            return localize(
              "errorConfigurationFileModifiedSince",
              "Unable to write into user settings because the content of the file is newer."
            );
          case 2:
            return localize(
              "errorRemoteConfigurationFileModifiedSince",
              "Unable to write into remote user settings because the content of the file is newer."
            );
          case 3:
            return localize(
              "errorConfigurationFileModifiedSinceWorkspace",
              "Unable to write into workspace settings because the content of the file is newer."
            );
          case 4:
            return localize(
              "errorConfigurationFileModifiedSinceFolder",
              "Unable to write into folder settings because the content of the file is newer."
            );
        }
      case 13:
        return localize(
          "errorUnknown",
          "Unable to write to {0} because of an internal error.",
          this.stringifyTarget(target)
        );
    }
  }
  stringifyTarget(target) {
    switch (target) {
      case 1:
        return localize("userTarget", "User Settings");
      case 2:
        return localize("remoteUserTarget", "Remote User Settings");
      case 3:
        return localize("workspaceTarget", "Workspace Settings");
      case 4:
        return localize("folderTarget", "Folder Settings");
      default:
        return "";
    }
  }
  defaultResourceValue(resource) {
    const basename2 = this.uriIdentityService.extUri.basename(resource);
    const configurationValue = basename2.substr(0, basename2.length - this.uriIdentityService.extUri.extname(resource).length);
    switch (configurationValue) {
      case TASKS_CONFIGURATION_KEY:
        return TASKS_DEFAULT;
      default:
        return "{}";
    }
  }
  async resolveModelReference(resource) {
    const exists = await this.fileService.exists(resource);
    if (!exists) {
      await this.textFileService.write(resource, this.defaultResourceValue(resource), { encoding: "utf8" });
    }
    return this.textModelResolverService.createModelReference(resource);
  }
  hasParseErrors(content, operation) {
    if (operation.workspaceStandAloneConfigurationKey && !operation.key) {
      return false;
    }
    const parseErrors = [];
    parse(content, parseErrors, { allowTrailingComma: true, allowEmptyContent: true });
    return parseErrors.length > 0;
  }
  async validate(target, operation, checkDirty, overrides) {
    var _a2, _b;
    if (this.configurationService.inspect(operation.key).policyValue !== void 0) {
      throw this.toConfigurationEditingError(12, target, operation);
    }
    const configurationProperties = Registry.as(Extensions3.Configuration).getConfigurationProperties();
    const configurationScope = (_a2 = configurationProperties[operation.key]) == null ? void 0 : _a2.scope;
    if (!operation.workspaceStandAloneConfigurationKey) {
      const validKeys = this.configurationService.keys().default;
      if (validKeys.indexOf(operation.key) < 0 && !OVERRIDE_PROPERTY_REGEX.test(operation.key) && operation.value !== void 0) {
        throw this.toConfigurationEditingError(0, target, operation);
      }
    }
    if (operation.workspaceStandAloneConfigurationKey) {
      if (operation.workspaceStandAloneConfigurationKey !== TASKS_CONFIGURATION_KEY && (target === 1 || target === 2)) {
        throw this.toConfigurationEditingError(4, target, operation);
      }
    }
    if ((target === 3 || target === 4) && this.contextService.getWorkbenchState() === 1) {
      throw this.toConfigurationEditingError(8, target, operation);
    }
    if (target === 3) {
      if (!operation.workspaceStandAloneConfigurationKey && !OVERRIDE_PROPERTY_REGEX.test(operation.key)) {
        if (configurationScope === 1) {
          throw this.toConfigurationEditingError(1, target, operation);
        }
        if (configurationScope === 2) {
          throw this.toConfigurationEditingError(2, target, operation);
        }
      }
    }
    if (target === 4) {
      if (!operation.resource) {
        throw this.toConfigurationEditingError(6, target, operation);
      }
      if (!operation.workspaceStandAloneConfigurationKey && !OVERRIDE_PROPERTY_REGEX.test(operation.key)) {
        if (configurationScope !== void 0 && !FOLDER_SCOPES.includes(configurationScope)) {
          throw this.toConfigurationEditingError(3, target, operation);
        }
      }
    }
    if ((_b = overrides.overrideIdentifiers) == null ? void 0 : _b.length) {
      if (configurationScope !== 5) {
        throw this.toConfigurationEditingError(7, target, operation);
      }
    }
    if (!operation.resource) {
      throw this.toConfigurationEditingError(6, target, operation);
    }
    if (checkDirty && this.textFileService.isDirty(operation.resource)) {
      throw this.toConfigurationEditingError(9, target, operation);
    }
  }
  getConfigurationEditOperation(target, config, overrides) {
    var _a2, _b;
    if (config.key) {
      const standaloneConfigurationMap = target === 1 ? USER_STANDALONE_CONFIGURATIONS : WORKSPACE_STANDALONE_CONFIGURATIONS;
      const standaloneConfigurationKeys = Object.keys(standaloneConfigurationMap);
      for (const key2 of standaloneConfigurationKeys) {
        const resource2 = this.getConfigurationFileResource(target, key2, standaloneConfigurationMap[key2], overrides.resource, void 0);
        if (config.key === key2) {
          const jsonPath2 = this.isWorkspaceConfigurationResource(resource2) ? [key2] : [];
          return { key: jsonPath2[jsonPath2.length - 1], jsonPath: jsonPath2, value: config.value, resource: resource2 ?? void 0, workspaceStandAloneConfigurationKey: key2, target };
        }
        const keyPrefix = `${key2}.`;
        if (config.key.indexOf(keyPrefix) === 0) {
          const jsonPath2 = this.isWorkspaceConfigurationResource(resource2) ? [key2, config.key.substr(keyPrefix.length)] : [config.key.substr(keyPrefix.length)];
          return { key: jsonPath2[jsonPath2.length - 1], jsonPath: jsonPath2, value: config.value, resource: resource2 ?? void 0, workspaceStandAloneConfigurationKey: key2, target };
        }
      }
    }
    const key = config.key;
    const configurationProperties = Registry.as(Extensions3.Configuration).getConfigurationProperties();
    const configurationScope = (_a2 = configurationProperties[key]) == null ? void 0 : _a2.scope;
    let jsonPath = ((_b = overrides.overrideIdentifiers) == null ? void 0 : _b.length) ? [keyFromOverrideIdentifiers(overrides.overrideIdentifiers), key] : [key];
    if (target === 1 || target === 2) {
      return { key, jsonPath, value: config.value, resource: this.getConfigurationFileResource(target, key, "", null, configurationScope) ?? void 0, target };
    }
    const resource = this.getConfigurationFileResource(target, key, FOLDER_SETTINGS_PATH, overrides.resource, configurationScope);
    if (this.isWorkspaceConfigurationResource(resource)) {
      jsonPath = ["settings", ...jsonPath];
    }
    return { key, jsonPath, value: config.value, resource: resource ?? void 0, target };
  }
  isWorkspaceConfigurationResource(resource) {
    const workspace = this.contextService.getWorkspace();
    return !!(workspace.configuration && resource && workspace.configuration.fsPath === resource.fsPath);
  }
  getConfigurationFileResource(target, key, relativePath, resource, scope) {
    if (target === 1) {
      if (key === TASKS_CONFIGURATION_KEY) {
        return this.userDataProfileService.currentProfile.tasksResource;
      } else {
        if (!this.userDataProfileService.currentProfile.isDefault && this.configurationService.isSettingAppliedForAllProfiles(key)) {
          return this.userDataProfilesService.defaultProfile.settingsResource;
        }
        return this.userDataProfileService.currentProfile.settingsResource;
      }
    }
    if (target === 2) {
      return this.remoteSettingsResource;
    }
    const workbenchState = this.contextService.getWorkbenchState();
    if (workbenchState !== 1) {
      const workspace = this.contextService.getWorkspace();
      if (target === 3) {
        if (workbenchState === 3) {
          return workspace.configuration ?? null;
        }
        if (workbenchState === 2) {
          return workspace.folders[0].toResource(relativePath);
        }
      }
      if (target === 4) {
        if (resource) {
          const folder = this.contextService.getWorkspaceFolder(resource);
          if (folder) {
            return folder.toResource(relativePath);
          }
        }
      }
    }
    return null;
  }
};
ConfigurationEditing = __decorate([
  __param(1, IWorkbenchConfigurationService),
  __param(2, IWorkspaceContextService),
  __param(3, IUserDataProfileService),
  __param(4, IUserDataProfilesService),
  __param(5, IFileService),
  __param(6, ITextModelService),
  __param(7, ITextFileService),
  __param(8, INotificationService),
  __param(9, IPreferencesService),
  __param(10, IEditorService),
  __param(11, IUriIdentityService)
], ConfigurationEditing);

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/browser/configuration.js
init_event();
init_errors();
init_lifecycle();
init_async();
init_files();
init_configurationRegistry();
init_objects();
init_hash();
init_resources();
init_platform2();
init_types();
var _DefaultConfiguration = class _DefaultConfiguration extends DefaultConfiguration {
  constructor(configurationCache, environmentService) {
    var _a2;
    super();
    this.configurationCache = configurationCache;
    this.configurationRegistry = Registry.as(Extensions3.Configuration);
    this.cachedConfigurationDefaultsOverrides = {};
    this.cacheKey = { type: "defaults", key: "configurationDefaultsOverrides" };
    this.updateCache = false;
    if ((_a2 = environmentService.options) == null ? void 0 : _a2.configurationDefaults) {
      this.configurationRegistry.registerDefaultConfigurations([{ overrides: environmentService.options.configurationDefaults }]);
    }
  }
  getConfigurationDefaultOverrides() {
    return this.cachedConfigurationDefaultsOverrides;
  }
  async initialize() {
    await this.initializeCachedConfigurationDefaultsOverrides();
    return super.initialize();
  }
  reload() {
    this.updateCache = true;
    this.cachedConfigurationDefaultsOverrides = {};
    this.updateCachedConfigurationDefaultsOverrides();
    return super.reload();
  }
  hasCachedConfigurationDefaultsOverrides() {
    return !isEmptyObject(this.cachedConfigurationDefaultsOverrides);
  }
  initializeCachedConfigurationDefaultsOverrides() {
    if (!this.initiaizeCachedConfigurationDefaultsOverridesPromise) {
      this.initiaizeCachedConfigurationDefaultsOverridesPromise = (async () => {
        try {
          if (window.localStorage.getItem(_DefaultConfiguration.DEFAULT_OVERRIDES_CACHE_EXISTS_KEY)) {
            const content = await this.configurationCache.read(this.cacheKey);
            if (content) {
              this.cachedConfigurationDefaultsOverrides = JSON.parse(content);
            }
          }
        } catch (error) {
        }
        this.cachedConfigurationDefaultsOverrides = isObject(this.cachedConfigurationDefaultsOverrides) ? this.cachedConfigurationDefaultsOverrides : {};
      })();
    }
    return this.initiaizeCachedConfigurationDefaultsOverridesPromise;
  }
  onDidUpdateConfiguration(properties, defaultsOverrides) {
    super.onDidUpdateConfiguration(properties, defaultsOverrides);
    if (defaultsOverrides) {
      this.updateCachedConfigurationDefaultsOverrides();
    }
  }
  async updateCachedConfigurationDefaultsOverrides() {
    if (!this.updateCache) {
      return;
    }
    const cachedConfigurationDefaultsOverrides = {};
    const configurationDefaultsOverrides = this.configurationRegistry.getConfigurationDefaultsOverrides();
    for (const [key, value] of configurationDefaultsOverrides) {
      if (!OVERRIDE_PROPERTY_REGEX.test(key) && value.value !== void 0) {
        cachedConfigurationDefaultsOverrides[key] = value.value;
      }
    }
    try {
      if (Object.keys(cachedConfigurationDefaultsOverrides).length) {
        window.localStorage.setItem(_DefaultConfiguration.DEFAULT_OVERRIDES_CACHE_EXISTS_KEY, "yes");
        await this.configurationCache.write(this.cacheKey, JSON.stringify(cachedConfigurationDefaultsOverrides));
      } else {
        window.localStorage.removeItem(_DefaultConfiguration.DEFAULT_OVERRIDES_CACHE_EXISTS_KEY);
        await this.configurationCache.remove(this.cacheKey);
      }
    } catch (error) {
    }
  }
};
_DefaultConfiguration.DEFAULT_OVERRIDES_CACHE_EXISTS_KEY = "DefaultOverridesCacheExists";
var DefaultConfiguration2 = _DefaultConfiguration;
var ApplicationConfiguration = class extends UserSettings {
  constructor(userDataProfilesService, fileService, uriIdentityService) {
    super(userDataProfilesService.defaultProfile.settingsResource, { scopes: [1] }, uriIdentityService.extUri, fileService);
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._register(this.onDidChange(() => this.reloadConfigurationScheduler.schedule()));
    this.reloadConfigurationScheduler = this._register(new RunOnceScheduler(
      () => this.loadConfiguration().then((configurationModel) => this._onDidChangeConfiguration.fire(configurationModel)),
      50
    ));
  }
  async initialize() {
    return this.loadConfiguration();
  }
  async loadConfiguration() {
    const model = await super.loadConfiguration();
    const value = model.getValue(APPLY_ALL_PROFILES_SETTING);
    const allProfilesSettings = Array.isArray(value) ? value : [];
    return this.parseOptions.include || allProfilesSettings.length ? this.reparse({ ...this.parseOptions, include: allProfilesSettings }) : model;
  }
};
var UserConfiguration = class extends Disposable {
  get hasTasksLoaded() {
    return this.userConfiguration.value instanceof FileServiceBasedConfiguration;
  }
  constructor(settingsResource, tasksResource, configurationParseOptions, fileService, uriIdentityService, logService) {
    super();
    this.settingsResource = settingsResource;
    this.tasksResource = tasksResource;
    this.configurationParseOptions = configurationParseOptions;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this.userConfiguration = this._register(new MutableDisposable());
    this.userConfigurationChangeDisposable = this._register(new MutableDisposable());
    this.userConfiguration.value = new UserSettings(
      settingsResource,
      this.configurationParseOptions,
      uriIdentityService.extUri,
      this.fileService
    );
    this.userConfigurationChangeDisposable.value = this.userConfiguration.value.onDidChange(() => this.reloadConfigurationScheduler.schedule());
    this.reloadConfigurationScheduler = this._register(new RunOnceScheduler(
      () => this.userConfiguration.value.loadConfiguration().then((configurationModel) => this._onDidChangeConfiguration.fire(configurationModel)),
      50
    ));
  }
  async reset(settingsResource, tasksResource, configurationParseOptions) {
    this.settingsResource = settingsResource;
    this.tasksResource = tasksResource;
    this.configurationParseOptions = configurationParseOptions;
    const folder = this.uriIdentityService.extUri.dirname(this.settingsResource);
    const standAloneConfigurationResources = this.tasksResource ? [[TASKS_CONFIGURATION_KEY, this.tasksResource]] : [];
    const fileServiceBasedConfiguration = new FileServiceBasedConfiguration(
      folder.toString(),
      this.settingsResource,
      standAloneConfigurationResources,
      this.configurationParseOptions,
      this.fileService,
      this.uriIdentityService,
      this.logService
    );
    const configurationModel = await fileServiceBasedConfiguration.loadConfiguration();
    this.userConfiguration.value = fileServiceBasedConfiguration;
    if (this.userConfigurationChangeDisposable.value) {
      this.userConfigurationChangeDisposable.value = this.userConfiguration.value.onDidChange(() => this.reloadConfigurationScheduler.schedule());
    }
    return configurationModel;
  }
  async initialize() {
    return this.userConfiguration.value.loadConfiguration();
  }
  async reload() {
    if (this.hasTasksLoaded) {
      return this.userConfiguration.value.loadConfiguration();
    }
    return this.reset(this.settingsResource, this.tasksResource, this.configurationParseOptions);
  }
  reparse(parseOptions) {
    this.configurationParseOptions = { ...this.configurationParseOptions, ...parseOptions };
    return this.userConfiguration.value.reparse(this.configurationParseOptions);
  }
  getRestrictedSettings() {
    return this.userConfiguration.value.getRestrictedSettings();
  }
};
var FileServiceBasedConfiguration = class extends Disposable {
  constructor(name, settingsResource, standAloneConfigurationResources, configurationParseOptions, fileService, uriIdentityService, logService) {
    super();
    this.settingsResource = settingsResource;
    this.standAloneConfigurationResources = standAloneConfigurationResources;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.allResources = [this.settingsResource, ...this.standAloneConfigurationResources.map(([, resource]) => resource)];
    this._register(combinedDisposable(...this.allResources.map(
      (resource) => combinedDisposable(
        this.fileService.watch(uriIdentityService.extUri.dirname(resource)),
        this.fileService.watch(resource)
      )
    )));
    this._folderSettingsModelParser = new ConfigurationModelParser(name);
    this._folderSettingsParseOptions = configurationParseOptions;
    this._standAloneConfigurations = [];
    this._cache = new ConfigurationModel();
    this._register(Event.debounce(Event.any(Event.filter(this.fileService.onDidFilesChange, (e) => this.handleFileChangesEvent(e)), Event.filter(this.fileService.onDidRunOperation, (e) => this.handleFileOperationEvent(e))), () => void 0, 100)(() => this._onDidChange.fire()));
  }
  async resolveContents() {
    const resolveContents = async (resources) => {
      return Promise.all(resources.map(async (resource) => {
        try {
          const content = await this.fileService.readFile(resource, { atomic: true });
          return content.value.toString();
        } catch (error) {
          this.logService.trace(`Error while resolving configuration file '${resource.toString()}': ${getErrorMessage(error)}`);
          if (error.fileOperationResult !== 1 && error.fileOperationResult !== 9) {
            this.logService.error(error);
          }
        }
        return "{}";
      }));
    };
    const [[settingsContent], standAloneConfigurationContents] = await Promise.all([
      resolveContents([this.settingsResource]),
      resolveContents(this.standAloneConfigurationResources.map(([, resource]) => resource))
    ]);
    return [settingsContent, standAloneConfigurationContents.map(
      (content, index) => [this.standAloneConfigurationResources[index][0], content]
    )];
  }
  async loadConfiguration() {
    const [settingsContent, standAloneConfigurationContents] = await this.resolveContents();
    this._standAloneConfigurations = [];
    this._folderSettingsModelParser.parse("", this._folderSettingsParseOptions);
    if (settingsContent !== void 0) {
      this._folderSettingsModelParser.parse(settingsContent, this._folderSettingsParseOptions);
    }
    for (let index = 0; index < standAloneConfigurationContents.length; index++) {
      const contents = standAloneConfigurationContents[index][1];
      if (contents !== void 0) {
        const standAloneConfigurationModelParser = new StandaloneConfigurationModelParser(
          this.standAloneConfigurationResources[index][1].toString(),
          this.standAloneConfigurationResources[index][0]
        );
        standAloneConfigurationModelParser.parse(contents);
        this._standAloneConfigurations.push(standAloneConfigurationModelParser.configurationModel);
      }
    }
    this.consolidate();
    return this._cache;
  }
  getRestrictedSettings() {
    return this._folderSettingsModelParser.restrictedConfigurations;
  }
  reparse(configurationParseOptions) {
    const oldContents = this._folderSettingsModelParser.configurationModel.contents;
    this._folderSettingsParseOptions = configurationParseOptions;
    this._folderSettingsModelParser.reparse(this._folderSettingsParseOptions);
    if (!equals(oldContents, this._folderSettingsModelParser.configurationModel.contents)) {
      this.consolidate();
    }
    return this._cache;
  }
  consolidate() {
    this._cache = this._folderSettingsModelParser.configurationModel.merge(...this._standAloneConfigurations);
  }
  handleFileChangesEvent(event) {
    if (this.allResources.some((resource) => event.contains(resource))) {
      return true;
    }
    if (this.allResources.some(
      (resource) => event.contains(this.uriIdentityService.extUri.dirname(resource), 2)
    )) {
      return true;
    }
    return false;
  }
  handleFileOperationEvent(event) {
    if ((event.isOperation(0) || event.isOperation(3) || event.isOperation(1) || event.isOperation(4)) && this.allResources.some(
      (resource) => this.uriIdentityService.extUri.isEqual(event.resource, resource)
    )) {
      return true;
    }
    if (event.isOperation(1) && this.allResources.some(
      (resource) => this.uriIdentityService.extUri.isEqual(event.resource, this.uriIdentityService.extUri.dirname(resource))
    )) {
      return true;
    }
    return false;
  }
};
var RemoteUserConfiguration = class extends Disposable {
  constructor(remoteAuthority, configurationCache, fileService, uriIdentityService, remoteAgentService) {
    super();
    this._userConfigurationInitializationPromise = null;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._onDidInitialize = this._register(new Emitter());
    this.onDidInitialize = this._onDidInitialize.event;
    this._fileService = fileService;
    this._userConfiguration = this._cachedConfiguration = new CachedRemoteUserConfiguration(remoteAuthority, configurationCache, { scopes: REMOTE_MACHINE_SCOPES });
    remoteAgentService.getEnvironment().then(async (environment) => {
      if (environment) {
        const userConfiguration = this._register(new FileServiceBasedRemoteUserConfiguration(
          environment.settingsPath,
          { scopes: REMOTE_MACHINE_SCOPES },
          this._fileService,
          uriIdentityService
        ));
        this._register(userConfiguration.onDidChangeConfiguration((configurationModel2) => this.onDidUserConfigurationChange(configurationModel2)));
        this._userConfigurationInitializationPromise = userConfiguration.initialize();
        const configurationModel = await this._userConfigurationInitializationPromise;
        this._userConfiguration.dispose();
        this._userConfiguration = userConfiguration;
        this.onDidUserConfigurationChange(configurationModel);
        this._onDidInitialize.fire(configurationModel);
      }
    });
  }
  async initialize() {
    if (this._userConfiguration instanceof FileServiceBasedRemoteUserConfiguration) {
      return this._userConfiguration.initialize();
    }
    let configurationModel = await this._userConfiguration.initialize();
    if (this._userConfigurationInitializationPromise) {
      configurationModel = await this._userConfigurationInitializationPromise;
      this._userConfigurationInitializationPromise = null;
    }
    return configurationModel;
  }
  reload() {
    return this._userConfiguration.reload();
  }
  reparse() {
    return this._userConfiguration.reparse({ scopes: REMOTE_MACHINE_SCOPES });
  }
  getRestrictedSettings() {
    return this._userConfiguration.getRestrictedSettings();
  }
  onDidUserConfigurationChange(configurationModel) {
    this.updateCache();
    this._onDidChangeConfiguration.fire(configurationModel);
  }
  async updateCache() {
    if (this._userConfiguration instanceof FileServiceBasedRemoteUserConfiguration) {
      let content;
      try {
        content = await this._userConfiguration.resolveContent();
      } catch (error) {
        if (error.fileOperationResult !== 1) {
          return;
        }
      }
      await this._cachedConfiguration.updateConfiguration(content);
    }
  }
};
var FileServiceBasedRemoteUserConfiguration = class extends Disposable {
  constructor(configurationResource, configurationParseOptions, fileService, uriIdentityService) {
    super();
    this.configurationResource = configurationResource;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this.fileWatcherDisposable = Disposable.None;
    this.directoryWatcherDisposable = Disposable.None;
    this.parser = new ConfigurationModelParser(this.configurationResource.toString());
    this.parseOptions = configurationParseOptions;
    this._register(fileService.onDidFilesChange((e) => this.handleFileChangesEvent(e)));
    this._register(fileService.onDidRunOperation((e) => this.handleFileOperationEvent(e)));
    this.reloadConfigurationScheduler = this._register(new RunOnceScheduler(
      () => this.reload().then((configurationModel) => this._onDidChangeConfiguration.fire(configurationModel)),
      50
    ));
    this._register(toDisposable(() => {
      this.stopWatchingResource();
      this.stopWatchingDirectory();
    }));
  }
  watchResource() {
    this.fileWatcherDisposable = this.fileService.watch(this.configurationResource);
  }
  stopWatchingResource() {
    this.fileWatcherDisposable.dispose();
    this.fileWatcherDisposable = Disposable.None;
  }
  watchDirectory() {
    const directory = this.uriIdentityService.extUri.dirname(this.configurationResource);
    this.directoryWatcherDisposable = this.fileService.watch(directory);
  }
  stopWatchingDirectory() {
    this.directoryWatcherDisposable.dispose();
    this.directoryWatcherDisposable = Disposable.None;
  }
  async initialize() {
    const exists = await this.fileService.exists(this.configurationResource);
    this.onResourceExists(exists);
    return this.reload();
  }
  async resolveContent() {
    const content = await this.fileService.readFile(this.configurationResource, { atomic: true });
    return content.value.toString();
  }
  async reload() {
    try {
      const content = await this.resolveContent();
      this.parser.parse(content, this.parseOptions);
      return this.parser.configurationModel;
    } catch (e) {
      return new ConfigurationModel();
    }
  }
  reparse(configurationParseOptions) {
    this.parseOptions = configurationParseOptions;
    this.parser.reparse(this.parseOptions);
    return this.parser.configurationModel;
  }
  getRestrictedSettings() {
    return this.parser.restrictedConfigurations;
  }
  handleFileChangesEvent(event) {
    let affectedByChanges = event.contains(this.configurationResource, 0);
    if (event.contains(this.configurationResource, 1)) {
      affectedByChanges = true;
      this.onResourceExists(true);
    } else if (event.contains(this.configurationResource, 2)) {
      affectedByChanges = true;
      this.onResourceExists(false);
    }
    if (affectedByChanges) {
      this.reloadConfigurationScheduler.schedule();
    }
  }
  handleFileOperationEvent(event) {
    if ((event.isOperation(0) || event.isOperation(3) || event.isOperation(1) || event.isOperation(4)) && this.uriIdentityService.extUri.isEqual(event.resource, this.configurationResource)) {
      this.reloadConfigurationScheduler.schedule();
    }
  }
  onResourceExists(exists) {
    if (exists) {
      this.stopWatchingDirectory();
      this.watchResource();
    } else {
      this.stopWatchingResource();
      this.watchDirectory();
    }
  }
};
var CachedRemoteUserConfiguration = class extends Disposable {
  constructor(remoteAuthority, configurationCache, configurationParseOptions) {
    super();
    this.configurationCache = configurationCache;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.key = { type: "user", key: remoteAuthority };
    this.parser = new ConfigurationModelParser("CachedRemoteUserConfiguration");
    this.parseOptions = configurationParseOptions;
    this.configurationModel = new ConfigurationModel();
  }
  getConfigurationModel() {
    return this.configurationModel;
  }
  initialize() {
    return this.reload();
  }
  reparse(configurationParseOptions) {
    this.parseOptions = configurationParseOptions;
    this.parser.reparse(this.parseOptions);
    this.configurationModel = this.parser.configurationModel;
    return this.configurationModel;
  }
  getRestrictedSettings() {
    return this.parser.restrictedConfigurations;
  }
  async reload() {
    try {
      const content = await this.configurationCache.read(this.key);
      const parsed = JSON.parse(content);
      if (parsed.content) {
        this.parser.parse(parsed.content, this.parseOptions);
        this.configurationModel = this.parser.configurationModel;
      }
    } catch (e) {
    }
    return this.configurationModel;
  }
  async updateConfiguration(content) {
    if (content) {
      return this.configurationCache.write(this.key, JSON.stringify({ content }));
    } else {
      return this.configurationCache.remove(this.key);
    }
  }
};
var WorkspaceConfiguration = class extends Disposable {
  get initialized() {
    return this._initialized;
  }
  constructor(configurationCache, fileService, uriIdentityService, logService) {
    super();
    this.configurationCache = configurationCache;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this._workspaceConfigurationDisposables = this._register(new DisposableStore());
    this._workspaceIdentifier = null;
    this._isWorkspaceTrusted = false;
    this._onDidUpdateConfiguration = this._register(new Emitter());
    this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;
    this._initialized = false;
    this.fileService = fileService;
    this._workspaceConfiguration = this._cachedConfiguration = new CachedWorkspaceConfiguration(configurationCache);
  }
  async initialize(workspaceIdentifier, workspaceTrusted) {
    this._workspaceIdentifier = workspaceIdentifier;
    this._isWorkspaceTrusted = workspaceTrusted;
    if (!this._initialized) {
      if (this.configurationCache.needsCaching(this._workspaceIdentifier.configPath)) {
        this._workspaceConfiguration = this._cachedConfiguration;
        this.waitAndInitialize(this._workspaceIdentifier);
      } else {
        this.doInitialize(new FileServiceBasedWorkspaceConfiguration(this.fileService, this.uriIdentityService, this.logService));
      }
    }
    await this.reload();
  }
  async reload() {
    if (this._workspaceIdentifier) {
      await this._workspaceConfiguration.load(this._workspaceIdentifier, { scopes: WORKSPACE_SCOPES, skipRestricted: this.isUntrusted() });
    }
  }
  getFolders() {
    return this._workspaceConfiguration.getFolders();
  }
  setFolders(folders, jsonEditingService) {
    if (this._workspaceIdentifier) {
      return jsonEditingService.write(this._workspaceIdentifier.configPath, [{ path: ["folders"], value: folders }], true).then(() => this.reload());
    }
    return Promise.resolve();
  }
  isTransient() {
    return this._workspaceConfiguration.isTransient();
  }
  getConfiguration() {
    return this._workspaceConfiguration.getWorkspaceSettings();
  }
  updateWorkspaceTrust(trusted) {
    this._isWorkspaceTrusted = trusted;
    return this.reparseWorkspaceSettings();
  }
  reparseWorkspaceSettings() {
    this._workspaceConfiguration.reparseWorkspaceSettings({ scopes: WORKSPACE_SCOPES, skipRestricted: this.isUntrusted() });
    return this.getConfiguration();
  }
  getRestrictedSettings() {
    return this._workspaceConfiguration.getRestrictedSettings();
  }
  async waitAndInitialize(workspaceIdentifier) {
    await whenProviderRegistered(workspaceIdentifier.configPath, this.fileService);
    if (!(this._workspaceConfiguration instanceof FileServiceBasedWorkspaceConfiguration)) {
      const fileServiceBasedWorkspaceConfiguration = this._register(new FileServiceBasedWorkspaceConfiguration(this.fileService, this.uriIdentityService, this.logService));
      await fileServiceBasedWorkspaceConfiguration.load(workspaceIdentifier, { scopes: WORKSPACE_SCOPES, skipRestricted: this.isUntrusted() });
      this.doInitialize(fileServiceBasedWorkspaceConfiguration);
      this.onDidWorkspaceConfigurationChange(false, true);
    }
  }
  doInitialize(fileServiceBasedWorkspaceConfiguration) {
    this._workspaceConfigurationDisposables.clear();
    this._workspaceConfiguration = this._workspaceConfigurationDisposables.add(fileServiceBasedWorkspaceConfiguration);
    this._workspaceConfigurationDisposables.add(this._workspaceConfiguration.onDidChange((e) => this.onDidWorkspaceConfigurationChange(true, false)));
    this._initialized = true;
  }
  isUntrusted() {
    return !this._isWorkspaceTrusted;
  }
  async onDidWorkspaceConfigurationChange(reload, fromCache) {
    if (reload) {
      await this.reload();
    }
    this.updateCache();
    this._onDidUpdateConfiguration.fire(fromCache);
  }
  async updateCache() {
    if (this._workspaceIdentifier && this.configurationCache.needsCaching(this._workspaceIdentifier.configPath) && this._workspaceConfiguration instanceof FileServiceBasedWorkspaceConfiguration) {
      const content = await this._workspaceConfiguration.resolveContent(this._workspaceIdentifier);
      await this._cachedConfiguration.updateWorkspace(this._workspaceIdentifier, content);
    }
  }
};
var FileServiceBasedWorkspaceConfiguration = class extends Disposable {
  constructor(fileService, uriIdentityService, logService) {
    super();
    this.fileService = fileService;
    this.logService = logService;
    this._workspaceIdentifier = null;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.workspaceConfigurationModelParser = new WorkspaceConfigurationModelParser("");
    this.workspaceSettings = new ConfigurationModel();
    this._register(Event.any(Event.filter(this.fileService.onDidFilesChange, (e) => !!this._workspaceIdentifier && e.contains(this._workspaceIdentifier.configPath)), Event.filter(this.fileService.onDidRunOperation, (e) => !!this._workspaceIdentifier && (e.isOperation(0) || e.isOperation(3) || e.isOperation(1) || e.isOperation(4)) && uriIdentityService.extUri.isEqual(e.resource, this._workspaceIdentifier.configPath)))(() => this.reloadConfigurationScheduler.schedule()));
    this.reloadConfigurationScheduler = this._register(new RunOnceScheduler(() => this._onDidChange.fire(), 50));
    this.workspaceConfigWatcher = this._register(this.watchWorkspaceConfigurationFile());
  }
  get workspaceIdentifier() {
    return this._workspaceIdentifier;
  }
  async resolveContent(workspaceIdentifier) {
    const content = await this.fileService.readFile(workspaceIdentifier.configPath, { atomic: true });
    return content.value.toString();
  }
  async load(workspaceIdentifier, configurationParseOptions) {
    if (!this._workspaceIdentifier || this._workspaceIdentifier.id !== workspaceIdentifier.id) {
      this._workspaceIdentifier = workspaceIdentifier;
      this.workspaceConfigurationModelParser = new WorkspaceConfigurationModelParser(this._workspaceIdentifier.id);
      dispose(this.workspaceConfigWatcher);
      this.workspaceConfigWatcher = this._register(this.watchWorkspaceConfigurationFile());
    }
    let contents = "";
    try {
      contents = await this.resolveContent(this._workspaceIdentifier);
    } catch (error) {
      const exists = await this.fileService.exists(this._workspaceIdentifier.configPath);
      if (exists) {
        this.logService.error(error);
      }
    }
    this.workspaceConfigurationModelParser.parse(contents, configurationParseOptions);
    this.consolidate();
  }
  getConfigurationModel() {
    return this.workspaceConfigurationModelParser.configurationModel;
  }
  getFolders() {
    return this.workspaceConfigurationModelParser.folders;
  }
  isTransient() {
    return this.workspaceConfigurationModelParser.transient;
  }
  getWorkspaceSettings() {
    return this.workspaceSettings;
  }
  reparseWorkspaceSettings(configurationParseOptions) {
    this.workspaceConfigurationModelParser.reparseWorkspaceSettings(configurationParseOptions);
    this.consolidate();
    return this.getWorkspaceSettings();
  }
  getRestrictedSettings() {
    return this.workspaceConfigurationModelParser.getRestrictedWorkspaceSettings();
  }
  consolidate() {
    this.workspaceSettings = this.workspaceConfigurationModelParser.settingsModel.merge(this.workspaceConfigurationModelParser.launchModel, this.workspaceConfigurationModelParser.tasksModel);
  }
  watchWorkspaceConfigurationFile() {
    return this._workspaceIdentifier ? this.fileService.watch(this._workspaceIdentifier.configPath) : Disposable.None;
  }
};
var CachedWorkspaceConfiguration = class {
  constructor(configurationCache) {
    this.configurationCache = configurationCache;
    this.onDidChange = Event.None;
    this.workspaceConfigurationModelParser = new WorkspaceConfigurationModelParser("");
    this.workspaceSettings = new ConfigurationModel();
  }
  async load(workspaceIdentifier, configurationParseOptions) {
    try {
      const key = this.getKey(workspaceIdentifier);
      const contents = await this.configurationCache.read(key);
      const parsed = JSON.parse(contents);
      if (parsed.content) {
        this.workspaceConfigurationModelParser = new WorkspaceConfigurationModelParser(key.key);
        this.workspaceConfigurationModelParser.parse(parsed.content, configurationParseOptions);
        this.consolidate();
      }
    } catch (e) {
    }
  }
  get workspaceIdentifier() {
    return null;
  }
  getConfigurationModel() {
    return this.workspaceConfigurationModelParser.configurationModel;
  }
  getFolders() {
    return this.workspaceConfigurationModelParser.folders;
  }
  isTransient() {
    return this.workspaceConfigurationModelParser.transient;
  }
  getWorkspaceSettings() {
    return this.workspaceSettings;
  }
  reparseWorkspaceSettings(configurationParseOptions) {
    this.workspaceConfigurationModelParser.reparseWorkspaceSettings(configurationParseOptions);
    this.consolidate();
    return this.getWorkspaceSettings();
  }
  getRestrictedSettings() {
    return this.workspaceConfigurationModelParser.getRestrictedWorkspaceSettings();
  }
  consolidate() {
    this.workspaceSettings = this.workspaceConfigurationModelParser.settingsModel.merge(this.workspaceConfigurationModelParser.launchModel, this.workspaceConfigurationModelParser.tasksModel);
  }
  async updateWorkspace(workspaceIdentifier, content) {
    try {
      const key = this.getKey(workspaceIdentifier);
      if (content) {
        await this.configurationCache.write(key, JSON.stringify({ content }));
      } else {
        await this.configurationCache.remove(key);
      }
    } catch (error) {
    }
  }
  getKey(workspaceIdentifier) {
    return {
      type: "workspaces",
      key: workspaceIdentifier.id
    };
  }
};
var CachedFolderConfiguration = class {
  constructor(folder, configFolderRelativePath, configurationParseOptions, configurationCache) {
    this.configurationCache = configurationCache;
    this.onDidChange = Event.None;
    this.key = { type: "folder", key: hash(joinPath(folder, configFolderRelativePath).toString()).toString(16) };
    this._folderSettingsModelParser = new ConfigurationModelParser("CachedFolderConfiguration");
    this._folderSettingsParseOptions = configurationParseOptions;
    this._standAloneConfigurations = [];
    this.configurationModel = new ConfigurationModel();
  }
  async loadConfiguration() {
    try {
      const contents = await this.configurationCache.read(this.key);
      const { content: configurationContents } = JSON.parse(contents.toString());
      if (configurationContents) {
        for (const key of Object.keys(configurationContents)) {
          if (key === FOLDER_SETTINGS_NAME) {
            this._folderSettingsModelParser.parse(configurationContents[key], this._folderSettingsParseOptions);
          } else {
            const standAloneConfigurationModelParser = new StandaloneConfigurationModelParser(key, key);
            standAloneConfigurationModelParser.parse(configurationContents[key]);
            this._standAloneConfigurations.push(standAloneConfigurationModelParser.configurationModel);
          }
        }
      }
      this.consolidate();
    } catch (e) {
    }
    return this.configurationModel;
  }
  async updateConfiguration(settingsContent, standAloneConfigurationContents) {
    const content = {};
    if (settingsContent) {
      content[FOLDER_SETTINGS_NAME] = settingsContent;
    }
    standAloneConfigurationContents.forEach(([key, contents]) => {
      if (contents) {
        content[key] = contents;
      }
    });
    if (Object.keys(content).length) {
      await this.configurationCache.write(this.key, JSON.stringify({ content }));
    } else {
      await this.configurationCache.remove(this.key);
    }
  }
  getRestrictedSettings() {
    return this._folderSettingsModelParser.restrictedConfigurations;
  }
  reparse(configurationParseOptions) {
    this._folderSettingsParseOptions = configurationParseOptions;
    this._folderSettingsModelParser.reparse(this._folderSettingsParseOptions);
    this.consolidate();
    return this.configurationModel;
  }
  consolidate() {
    this.configurationModel = this._folderSettingsModelParser.configurationModel.merge(...this._standAloneConfigurations);
  }
  getUnsupportedKeys() {
    return [];
  }
};
var FolderConfiguration = class extends Disposable {
  constructor(useCache, workspaceFolder, configFolderRelativePath, workbenchState, workspaceTrusted, fileService, uriIdentityService, logService, configurationCache) {
    super();
    this.workspaceFolder = workspaceFolder;
    this.workbenchState = workbenchState;
    this.workspaceTrusted = workspaceTrusted;
    this.configurationCache = configurationCache;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.scopes = 3 === this.workbenchState ? FOLDER_SCOPES : WORKSPACE_SCOPES;
    this.configurationFolder = uriIdentityService.extUri.joinPath(workspaceFolder.uri, configFolderRelativePath);
    this.cachedFolderConfiguration = new CachedFolderConfiguration(
      workspaceFolder.uri,
      configFolderRelativePath,
      { scopes: this.scopes, skipRestricted: this.isUntrusted() },
      configurationCache
    );
    if (useCache && this.configurationCache.needsCaching(workspaceFolder.uri)) {
      this.folderConfiguration = this.cachedFolderConfiguration;
      whenProviderRegistered(workspaceFolder.uri, fileService).then(() => {
        this.folderConfiguration = this._register(this.createFileServiceBasedConfiguration(fileService, uriIdentityService, logService));
        this._register(this.folderConfiguration.onDidChange((e) => this.onDidFolderConfigurationChange()));
        this.onDidFolderConfigurationChange();
      });
    } else {
      this.folderConfiguration = this._register(this.createFileServiceBasedConfiguration(fileService, uriIdentityService, logService));
      this._register(this.folderConfiguration.onDidChange((e) => this.onDidFolderConfigurationChange()));
    }
  }
  loadConfiguration() {
    return this.folderConfiguration.loadConfiguration();
  }
  updateWorkspaceTrust(trusted) {
    this.workspaceTrusted = trusted;
    return this.reparse();
  }
  reparse() {
    const configurationModel = this.folderConfiguration.reparse({ scopes: this.scopes, skipRestricted: this.isUntrusted() });
    this.updateCache();
    return configurationModel;
  }
  getRestrictedSettings() {
    return this.folderConfiguration.getRestrictedSettings();
  }
  isUntrusted() {
    return !this.workspaceTrusted;
  }
  onDidFolderConfigurationChange() {
    this.updateCache();
    this._onDidChange.fire();
  }
  createFileServiceBasedConfiguration(fileService, uriIdentityService, logService) {
    const settingsResource = uriIdentityService.extUri.joinPath(this.configurationFolder, `${FOLDER_SETTINGS_NAME}.json`);
    const standAloneConfigurationResources = [TASKS_CONFIGURATION_KEY, LAUNCH_CONFIGURATION_KEY].map(
      (name) => [name, uriIdentityService.extUri.joinPath(this.configurationFolder, `${name}.json`)]
    );
    return new FileServiceBasedConfiguration(
      this.configurationFolder.toString(),
      settingsResource,
      standAloneConfigurationResources,
      { scopes: this.scopes, skipRestricted: this.isUntrusted() },
      fileService,
      uriIdentityService,
      logService
    );
  }
  async updateCache() {
    if (this.configurationCache.needsCaching(this.configurationFolder) && this.folderConfiguration instanceof FileServiceBasedConfiguration) {
      const [settingsContent, standAloneConfigurationContents] = await this.folderConfiguration.resolveContents();
      this.cachedFolderConfiguration.updateConfiguration(settingsContent, standAloneConfigurationContents);
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/browser/configurationService.js
init_errorMessage();
init_arrays();
init_types();
init_nls();
function getLocalUserConfigurationScopes(userDataProfile, hasRemote) {
  var _a2;
  return userDataProfile.isDefault || ((_a2 = userDataProfile.useDefaultFlags) == null ? void 0 : _a2.settings) ? hasRemote ? LOCAL_MACHINE_SCOPES : void 0 : hasRemote ? LOCAL_MACHINE_PROFILE_SCOPES : PROFILE_SCOPES;
}
var Workspace2 = class extends Workspace {
  constructor() {
    super(...arguments);
    this.initialized = false;
  }
};
var WorkspaceService = class extends Disposable {
  get restrictedSettings() {
    return this._restrictedSettings;
  }
  constructor({ remoteAuthority, configurationCache }, environmentService, userDataProfileService, userDataProfilesService, fileService, remoteAgentService, uriIdentityService, logService, policyService) {
    super();
    this.userDataProfileService = userDataProfileService;
    this.userDataProfilesService = userDataProfilesService;
    this.fileService = fileService;
    this.remoteAgentService = remoteAgentService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this.initialized = false;
    this.applicationConfiguration = null;
    this.remoteUserConfiguration = null;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._onWillChangeWorkspaceFolders = this._register(new Emitter());
    this.onWillChangeWorkspaceFolders = this._onWillChangeWorkspaceFolders.event;
    this._onDidChangeWorkspaceFolders = this._register(new Emitter());
    this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
    this._onDidChangeWorkspaceName = this._register(new Emitter());
    this.onDidChangeWorkspaceName = this._onDidChangeWorkspaceName.event;
    this._onDidChangeWorkbenchState = this._register(new Emitter());
    this.onDidChangeWorkbenchState = this._onDidChangeWorkbenchState.event;
    this.isWorkspaceTrusted = true;
    this._restrictedSettings = { default: [] };
    this._onDidChangeRestrictedSettings = this._register(new Emitter());
    this.onDidChangeRestrictedSettings = this._onDidChangeRestrictedSettings.event;
    this.configurationRegistry = Registry.as(Extensions3.Configuration);
    this.initRemoteUserConfigurationBarrier = new Barrier();
    this.completeWorkspaceBarrier = new Barrier();
    this.defaultConfiguration = this._register(new DefaultConfiguration2(configurationCache, environmentService));
    this.policyConfiguration = policyService instanceof NullPolicyService ? new NullPolicyConfiguration() : this._register(new PolicyConfiguration(this.defaultConfiguration, policyService, logService));
    this.configurationCache = configurationCache;
    this._configuration = new Configuration2(
      this.defaultConfiguration.configurationModel,
      this.policyConfiguration.configurationModel,
      new ConfigurationModel(),
      new ConfigurationModel(),
      new ConfigurationModel(),
      new ConfigurationModel(),
      new ResourceMap(),
      new ConfigurationModel(),
      new ResourceMap(),
      this.workspace
    );
    this.applicationConfigurationDisposables = this._register(new DisposableStore());
    this.createApplicationConfiguration();
    this.localUserConfiguration = this._register(new UserConfiguration(
      userDataProfileService.currentProfile.settingsResource,
      userDataProfileService.currentProfile.tasksResource,
      { scopes: getLocalUserConfigurationScopes(userDataProfileService.currentProfile, !!remoteAuthority) },
      fileService,
      uriIdentityService,
      logService
    ));
    this.cachedFolderConfigs = new ResourceMap();
    this._register(this.localUserConfiguration.onDidChangeConfiguration((userConfiguration) => this.onLocalUserConfigurationChanged(userConfiguration)));
    if (remoteAuthority) {
      const remoteUserConfiguration = this.remoteUserConfiguration = this._register(new RemoteUserConfiguration(
        remoteAuthority,
        configurationCache,
        fileService,
        uriIdentityService,
        remoteAgentService
      ));
      this._register(remoteUserConfiguration.onDidInitialize((remoteUserConfigurationModel) => {
        this._register(remoteUserConfiguration.onDidChangeConfiguration((remoteUserConfigurationModel2) => this.onRemoteUserConfigurationChanged(remoteUserConfigurationModel2)));
        this.onRemoteUserConfigurationChanged(remoteUserConfigurationModel);
        this.initRemoteUserConfigurationBarrier.open();
      }));
    } else {
      this.initRemoteUserConfigurationBarrier.open();
    }
    this.workspaceConfiguration = this._register(new WorkspaceConfiguration(configurationCache, fileService, uriIdentityService, logService));
    this._register(this.workspaceConfiguration.onDidUpdateConfiguration((fromCache) => {
      this.onWorkspaceConfigurationChanged(fromCache).then(() => {
        this.workspace.initialized = this.workspaceConfiguration.initialized;
        this.checkAndMarkWorkspaceComplete(fromCache);
      });
    }));
    this._register(this.defaultConfiguration.onDidChangeConfiguration(({ properties, defaults }) => this.onDefaultConfigurationChanged(defaults, properties)));
    this._register(this.policyConfiguration.onDidChangeConfiguration((configurationModel) => this.onPolicyConfigurationChanged(configurationModel)));
    this._register(userDataProfileService.onDidChangeCurrentProfile((e) => this.onUserDataProfileChanged(e)));
    this.workspaceEditingQueue = new Queue();
  }
  createApplicationConfiguration() {
    var _a2;
    this.applicationConfigurationDisposables.clear();
    if (this.userDataProfileService.currentProfile.isDefault || ((_a2 = this.userDataProfileService.currentProfile.useDefaultFlags) == null ? void 0 : _a2.settings)) {
      this.applicationConfiguration = null;
    } else {
      this.applicationConfiguration = this.applicationConfigurationDisposables.add(this._register(new ApplicationConfiguration(this.userDataProfilesService, this.fileService, this.uriIdentityService)));
      this.applicationConfigurationDisposables.add(this.applicationConfiguration.onDidChangeConfiguration((configurationModel) => this.onApplicationConfigurationChanged(configurationModel)));
    }
  }
  async getCompleteWorkspace() {
    await this.completeWorkspaceBarrier.wait();
    return this.getWorkspace();
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkbenchState() {
    if (this.workspace.configuration) {
      return 3;
    }
    if (this.workspace.folders.length === 1) {
      return 2;
    }
    return 1;
  }
  getWorkspaceFolder(resource) {
    return this.workspace.getFolder(resource);
  }
  addFolders(foldersToAdd, index) {
    return this.updateFolders(foldersToAdd, [], index);
  }
  removeFolders(foldersToRemove) {
    return this.updateFolders([], foldersToRemove);
  }
  async updateFolders(foldersToAdd, foldersToRemove, index) {
    return this.workspaceEditingQueue.queue(() => this.doUpdateFolders(foldersToAdd, foldersToRemove, index));
  }
  isInsideWorkspace(resource) {
    return !!this.getWorkspaceFolder(resource);
  }
  isCurrentWorkspace(workspaceIdOrFolder) {
    switch (this.getWorkbenchState()) {
      case 2: {
        let folderUri = void 0;
        if (URI.isUri(workspaceIdOrFolder)) {
          folderUri = workspaceIdOrFolder;
        } else if (isSingleFolderWorkspaceIdentifier(workspaceIdOrFolder)) {
          folderUri = workspaceIdOrFolder.uri;
        }
        return URI.isUri(folderUri) && this.uriIdentityService.extUri.isEqual(folderUri, this.workspace.folders[0].uri);
      }
      case 3:
        return isWorkspaceIdentifier(workspaceIdOrFolder) && this.workspace.id === workspaceIdOrFolder.id;
    }
    return false;
  }
  async doUpdateFolders(foldersToAdd, foldersToRemove, index) {
    if (this.getWorkbenchState() !== 3) {
      return Promise.resolve(void 0);
    }
    if (foldersToAdd.length + foldersToRemove.length === 0) {
      return Promise.resolve(void 0);
    }
    let foldersHaveChanged = false;
    let currentWorkspaceFolders = this.getWorkspace().folders;
    let newStoredFolders = currentWorkspaceFolders.map((f) => f.raw).filter((folder, index2) => {
      if (!isStoredWorkspaceFolder(folder)) {
        return true;
      }
      return !this.contains(foldersToRemove, currentWorkspaceFolders[index2].uri);
    });
    foldersHaveChanged = currentWorkspaceFolders.length !== newStoredFolders.length;
    if (foldersToAdd.length) {
      const workspaceConfigPath = this.getWorkspace().configuration;
      const workspaceConfigFolder = this.uriIdentityService.extUri.dirname(workspaceConfigPath);
      currentWorkspaceFolders = toWorkspaceFolders(newStoredFolders, workspaceConfigPath, this.uriIdentityService.extUri);
      const currentWorkspaceFolderUris = currentWorkspaceFolders.map((folder) => folder.uri);
      const storedFoldersToAdd = [];
      for (const folderToAdd of foldersToAdd) {
        const folderURI = folderToAdd.uri;
        if (this.contains(currentWorkspaceFolderUris, folderURI)) {
          continue;
        }
        try {
          const result = await this.fileService.stat(folderURI);
          if (!result.isDirectory) {
            continue;
          }
        } catch (e) {
        }
        storedFoldersToAdd.push(getStoredWorkspaceFolder(folderURI, false, folderToAdd.name, workspaceConfigFolder, this.uriIdentityService.extUri));
      }
      if (storedFoldersToAdd.length > 0) {
        foldersHaveChanged = true;
        if (typeof index === "number" && index >= 0 && index < newStoredFolders.length) {
          newStoredFolders = newStoredFolders.slice(0);
          newStoredFolders.splice(index, 0, ...storedFoldersToAdd);
        } else {
          newStoredFolders = [...newStoredFolders, ...storedFoldersToAdd];
        }
      }
    }
    if (foldersHaveChanged) {
      return this.setFolders(newStoredFolders);
    }
    return Promise.resolve(void 0);
  }
  async setFolders(folders) {
    if (!this.instantiationService) {
      throw new Error("Cannot update workspace folders because workspace service is not yet ready to accept writes.");
    }
    await this.instantiationService.invokeFunction((accessor) => this.workspaceConfiguration.setFolders(folders, accessor.get(IJSONEditingService)));
    return this.onWorkspaceConfigurationChanged(false);
  }
  contains(resources, toCheck) {
    return resources.some((resource) => this.uriIdentityService.extUri.isEqual(resource, toCheck));
  }
  getConfigurationData() {
    return this._configuration.toData();
  }
  getValue(arg1, arg2) {
    const section = typeof arg1 === "string" ? arg1 : void 0;
    const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : void 0;
    return this._configuration.getValue(section, overrides);
  }
  async updateValue(key, value, arg3, arg4, options) {
    const overrides = isConfigurationUpdateOverrides(arg3) ? arg3 : isConfigurationOverrides(arg3) ? { resource: arg3.resource, overrideIdentifiers: arg3.overrideIdentifier ? [arg3.overrideIdentifier] : void 0 } : void 0;
    const target = overrides ? arg4 : arg3;
    const targets = target ? [target] : [];
    if (overrides == null ? void 0 : overrides.overrideIdentifiers) {
      overrides.overrideIdentifiers = distinct(overrides.overrideIdentifiers);
      overrides.overrideIdentifiers = overrides.overrideIdentifiers.length ? overrides.overrideIdentifiers : void 0;
    }
    if (!targets.length) {
      if ((overrides == null ? void 0 : overrides.overrideIdentifiers) && overrides.overrideIdentifiers.length > 1) {
        throw new Error("Configuration Target is required while updating the value for multiple override identifiers");
      }
      const inspect = this.inspect(key, { resource: overrides == null ? void 0 : overrides.resource, overrideIdentifier: (overrides == null ? void 0 : overrides.overrideIdentifiers) ? overrides.overrideIdentifiers[0] : void 0 });
      targets.push(...this.deriveConfigurationTargets(key, value, inspect));
      if (equals(value, inspect.defaultValue) && targets.length === 1 && (targets[0] === 2 || targets[0] === 3)) {
        value = void 0;
      }
    }
    await Promises.settled(targets.map(
      (target2) => this.writeConfigurationValue(key, value, target2, overrides, options)
    ));
  }
  async reloadConfiguration(target) {
    if (target === void 0) {
      this.reloadDefaultConfiguration();
      const application = await this.reloadApplicationConfiguration(true);
      const { local, remote } = await this.reloadUserConfiguration();
      await this.reloadWorkspaceConfiguration();
      await this.loadConfiguration(application, local, remote, true);
      return;
    }
    if (isWorkspaceFolder(target)) {
      await this.reloadWorkspaceFolderConfiguration(target);
      return;
    }
    switch (target) {
      case 7:
        this.reloadDefaultConfiguration();
        return;
      case 2: {
        const { local, remote } = await this.reloadUserConfiguration();
        await this.loadConfiguration(this._configuration.applicationConfiguration, local, remote, true);
        return;
      }
      case 3:
        await this.reloadLocalUserConfiguration();
        return;
      case 4:
        await this.reloadRemoteUserConfiguration();
        return;
      case 5:
      case 6:
        await this.reloadWorkspaceConfiguration();
        return;
    }
  }
  hasCachedConfigurationDefaultsOverrides() {
    return this.defaultConfiguration.hasCachedConfigurationDefaultsOverrides();
  }
  inspect(key, overrides) {
    return this._configuration.inspect(key, overrides);
  }
  keys() {
    return this._configuration.keys();
  }
  async whenRemoteConfigurationLoaded() {
    await this.initRemoteUserConfigurationBarrier.wait();
  }
  async initialize(arg) {
    mark("code/willInitWorkspaceService");
    const trigger = this.initialized;
    this.initialized = false;
    const workspace = await this.createWorkspace(arg);
    await this.updateWorkspaceAndInitializeConfiguration(workspace, trigger);
    this.checkAndMarkWorkspaceComplete(false);
    mark("code/didInitWorkspaceService");
  }
  updateWorkspaceTrust(trusted) {
    var _a2;
    if (this.isWorkspaceTrusted !== trusted) {
      this.isWorkspaceTrusted = trusted;
      const data = this._configuration.toData();
      const folderConfigurationModels = [];
      for (const folder of this.workspace.folders) {
        const folderConfiguration = this.cachedFolderConfigs.get(folder.uri);
        let configurationModel;
        if (folderConfiguration) {
          configurationModel = folderConfiguration.updateWorkspaceTrust(this.isWorkspaceTrusted);
          this._configuration.updateFolderConfiguration(folder.uri, configurationModel);
        }
        folderConfigurationModels.push(configurationModel);
      }
      if (this.getWorkbenchState() === 2) {
        if (folderConfigurationModels[0]) {
          this._configuration.updateWorkspaceConfiguration(folderConfigurationModels[0]);
        }
      } else {
        this._configuration.updateWorkspaceConfiguration(this.workspaceConfiguration.updateWorkspaceTrust(this.isWorkspaceTrusted));
      }
      this.updateRestrictedSettings();
      let keys = [];
      if (this.restrictedSettings.userLocal) {
        keys.push(...this.restrictedSettings.userLocal);
      }
      if (this.restrictedSettings.userRemote) {
        keys.push(...this.restrictedSettings.userRemote);
      }
      if (this.restrictedSettings.workspace) {
        keys.push(...this.restrictedSettings.workspace);
      }
      (_a2 = this.restrictedSettings.workspaceFolder) == null ? void 0 : _a2.forEach((value) => keys.push(...value));
      keys = distinct(keys);
      if (keys.length) {
        this.triggerConfigurationChange({ keys, overrides: [] }, { data, workspace: this.workspace }, 5);
      }
    }
  }
  acquireInstantiationService(instantiationService) {
    this.instantiationService = instantiationService;
  }
  isSettingAppliedForAllProfiles(key) {
    var _a2;
    if (((_a2 = this.configurationRegistry.getConfigurationProperties()[key]) == null ? void 0 : _a2.scope) === 1) {
      return true;
    }
    const allProfilesSettings = this.getValue(APPLY_ALL_PROFILES_SETTING) ?? [];
    return Array.isArray(allProfilesSettings) && allProfilesSettings.includes(key);
  }
  async createWorkspace(arg) {
    if (isWorkspaceIdentifier(arg)) {
      return this.createMultiFolderWorkspace(arg);
    }
    if (isSingleFolderWorkspaceIdentifier(arg)) {
      return this.createSingleFolderWorkspace(arg);
    }
    return this.createEmptyWorkspace(arg);
  }
  async createMultiFolderWorkspace(workspaceIdentifier) {
    await this.workspaceConfiguration.initialize({ id: workspaceIdentifier.id, configPath: workspaceIdentifier.configPath }, this.isWorkspaceTrusted);
    const workspaceConfigPath = workspaceIdentifier.configPath;
    const workspaceFolders = toWorkspaceFolders(this.workspaceConfiguration.getFolders(), workspaceConfigPath, this.uriIdentityService.extUri);
    const workspaceId = workspaceIdentifier.id;
    const workspace = new Workspace2(
      workspaceId,
      workspaceFolders,
      this.workspaceConfiguration.isTransient(),
      workspaceConfigPath,
      (uri) => this.uriIdentityService.extUri.ignorePathCasing(uri)
    );
    workspace.initialized = this.workspaceConfiguration.initialized;
    return workspace;
  }
  createSingleFolderWorkspace(singleFolderWorkspaceIdentifier) {
    const workspace = new Workspace2(
      singleFolderWorkspaceIdentifier.id,
      [toWorkspaceFolder(singleFolderWorkspaceIdentifier.uri)],
      false,
      null,
      (uri) => this.uriIdentityService.extUri.ignorePathCasing(uri)
    );
    workspace.initialized = true;
    return workspace;
  }
  createEmptyWorkspace(emptyWorkspaceIdentifier) {
    const workspace = new Workspace2(
      emptyWorkspaceIdentifier.id,
      [],
      false,
      null,
      (uri) => this.uriIdentityService.extUri.ignorePathCasing(uri)
    );
    workspace.initialized = true;
    return Promise.resolve(workspace);
  }
  checkAndMarkWorkspaceComplete(fromCache) {
    if (!this.completeWorkspaceBarrier.isOpen() && this.workspace.initialized) {
      this.completeWorkspaceBarrier.open();
      this.validateWorkspaceFoldersAndReload(fromCache);
    }
  }
  async updateWorkspaceAndInitializeConfiguration(workspace, trigger) {
    const hasWorkspaceBefore = !!this.workspace;
    let previousState;
    let previousWorkspacePath;
    let previousFolders = [];
    if (hasWorkspaceBefore) {
      previousState = this.getWorkbenchState();
      previousWorkspacePath = this.workspace.configuration ? this.workspace.configuration.fsPath : void 0;
      previousFolders = this.workspace.folders;
      this.workspace.update(workspace);
    } else {
      this.workspace = workspace;
    }
    await this.initializeConfiguration(trigger);
    if (hasWorkspaceBefore) {
      const newState = this.getWorkbenchState();
      if (previousState && newState !== previousState) {
        this._onDidChangeWorkbenchState.fire(newState);
      }
      const newWorkspacePath = this.workspace.configuration ? this.workspace.configuration.fsPath : void 0;
      if (previousWorkspacePath && newWorkspacePath !== previousWorkspacePath || newState !== previousState) {
        this._onDidChangeWorkspaceName.fire();
      }
      const folderChanges = this.compareFolders(previousFolders, this.workspace.folders);
      if (folderChanges && (folderChanges.added.length || folderChanges.removed.length || folderChanges.changed.length)) {
        await this.handleWillChangeWorkspaceFolders(folderChanges, false);
        this._onDidChangeWorkspaceFolders.fire(folderChanges);
      }
    }
    if (!this.localUserConfiguration.hasTasksLoaded) {
      this._register(runWhenIdle(() => this.reloadLocalUserConfiguration()));
    }
  }
  compareFolders(currentFolders, newFolders) {
    const result = { added: [], removed: [], changed: [] };
    result.added = newFolders.filter((newFolder) => !currentFolders.some(
      (currentFolder) => newFolder.uri.toString() === currentFolder.uri.toString()
    ));
    for (let currentIndex = 0; currentIndex < currentFolders.length; currentIndex++) {
      const currentFolder = currentFolders[currentIndex];
      let newIndex = 0;
      for (newIndex = 0; newIndex < newFolders.length && currentFolder.uri.toString() !== newFolders[newIndex].uri.toString(); newIndex++) {
      }
      if (newIndex < newFolders.length) {
        if (currentIndex !== newIndex || currentFolder.name !== newFolders[newIndex].name) {
          result.changed.push(currentFolder);
        }
      } else {
        result.removed.push(currentFolder);
      }
    }
    return result;
  }
  async initializeConfiguration(trigger) {
    await this.defaultConfiguration.initialize();
    const initPolicyConfigurationPromise = this.policyConfiguration.initialize();
    const initApplicationConfigurationPromise = this.applicationConfiguration ? this.applicationConfiguration.initialize() : Promise.resolve(new ConfigurationModel());
    const initUserConfiguration = async () => {
      mark("code/willInitUserConfiguration");
      const result = await Promise.all([this.localUserConfiguration.initialize(), this.remoteUserConfiguration ? this.remoteUserConfiguration.initialize() : Promise.resolve(new ConfigurationModel())]);
      if (this.applicationConfiguration) {
        const applicationConfigurationModel = await initApplicationConfigurationPromise;
        result[0] = this.localUserConfiguration.reparse({ exclude: applicationConfigurationModel.getValue(APPLY_ALL_PROFILES_SETTING) });
      }
      mark("code/didInitUserConfiguration");
      return result;
    };
    const [, application, [local, remote]] = await Promise.all([
      initPolicyConfigurationPromise,
      initApplicationConfigurationPromise,
      initUserConfiguration()
    ]);
    mark("code/willInitWorkspaceConfiguration");
    await this.loadConfiguration(application, local, remote, trigger);
    mark("code/didInitWorkspaceConfiguration");
  }
  reloadDefaultConfiguration() {
    this.onDefaultConfigurationChanged(this.defaultConfiguration.reload());
  }
  async reloadApplicationConfiguration(donotTrigger) {
    if (!this.applicationConfiguration) {
      return new ConfigurationModel();
    }
    const model = await this.applicationConfiguration.loadConfiguration();
    if (!donotTrigger) {
      this.onApplicationConfigurationChanged(model);
    }
    return model;
  }
  async reloadUserConfiguration() {
    const [local, remote] = await Promise.all([this.reloadLocalUserConfiguration(true), this.reloadRemoteUserConfiguration(true)]);
    return { local, remote };
  }
  async reloadLocalUserConfiguration(donotTrigger) {
    const model = await this.localUserConfiguration.reload();
    if (!donotTrigger) {
      this.onLocalUserConfigurationChanged(model);
    }
    return model;
  }
  async reloadRemoteUserConfiguration(donotTrigger) {
    if (this.remoteUserConfiguration) {
      const model = await this.remoteUserConfiguration.reload();
      if (!donotTrigger) {
        this.onRemoteUserConfigurationChanged(model);
      }
      return model;
    }
    return new ConfigurationModel();
  }
  async reloadWorkspaceConfiguration() {
    const workbenchState = this.getWorkbenchState();
    if (workbenchState === 2) {
      return this.onWorkspaceFolderConfigurationChanged(this.workspace.folders[0]);
    }
    if (workbenchState === 3) {
      return this.workspaceConfiguration.reload().then(() => this.onWorkspaceConfigurationChanged(false));
    }
  }
  reloadWorkspaceFolderConfiguration(folder) {
    return this.onWorkspaceFolderConfigurationChanged(folder);
  }
  async loadConfiguration(applicationConfigurationModel, userConfigurationModel, remoteUserConfigurationModel, trigger) {
    this.cachedFolderConfigs = new ResourceMap();
    const folders = this.workspace.folders;
    const folderConfigurations = await this.loadFolderConfigurations(folders);
    const workspaceConfiguration = this.getWorkspaceConfigurationModel(folderConfigurations);
    const folderConfigurationModels = new ResourceMap();
    folderConfigurations.forEach((folderConfiguration, index) => folderConfigurationModels.set(folders[index].uri, folderConfiguration));
    const currentConfiguration = this._configuration;
    this._configuration = new Configuration2(
      this.defaultConfiguration.configurationModel,
      this.policyConfiguration.configurationModel,
      applicationConfigurationModel,
      userConfigurationModel,
      remoteUserConfigurationModel,
      workspaceConfiguration,
      folderConfigurationModels,
      new ConfigurationModel(),
      new ResourceMap(),
      this.workspace
    );
    this.initialized = true;
    if (trigger) {
      const change = this._configuration.compare(currentConfiguration);
      this.triggerConfigurationChange(change, { data: currentConfiguration.toData(), workspace: this.workspace }, 5);
    }
    this.updateRestrictedSettings();
  }
  getWorkspaceConfigurationModel(folderConfigurations) {
    switch (this.getWorkbenchState()) {
      case 2:
        return folderConfigurations[0];
      case 3:
        return this.workspaceConfiguration.getConfiguration();
      default:
        return new ConfigurationModel();
    }
  }
  onUserDataProfileChanged(e) {
    e.join((async () => {
      var _a2, _b;
      const promises = [];
      promises.push(this.localUserConfiguration.reset(e.profile.settingsResource, e.profile.tasksResource, { scopes: getLocalUserConfigurationScopes(e.profile, !!this.remoteUserConfiguration) }));
      if (e.previous.isDefault !== e.profile.isDefault || !!((_a2 = e.previous.useDefaultFlags) == null ? void 0 : _a2.settings) !== !!((_b = e.profile.useDefaultFlags) == null ? void 0 : _b.settings)) {
        this.createApplicationConfiguration();
        if (this.applicationConfiguration) {
          promises.push(this.reloadApplicationConfiguration(true));
        }
      }
      let [localUser, application] = await Promise.all(promises);
      application = application ?? this._configuration.applicationConfiguration;
      if (this.applicationConfiguration) {
        localUser = this.localUserConfiguration.reparse({ exclude: application.getValue(APPLY_ALL_PROFILES_SETTING) });
      }
      await this.loadConfiguration(application, localUser, this._configuration.remoteUserConfiguration, true);
    })());
  }
  onDefaultConfigurationChanged(configurationModel, properties) {
    if (this.workspace) {
      const previousData = this._configuration.toData();
      const change = this._configuration.compareAndUpdateDefaultConfiguration(configurationModel, properties);
      if (this.applicationConfiguration) {
        this._configuration.updateApplicationConfiguration(this.applicationConfiguration.reparse());
      }
      if (this.remoteUserConfiguration) {
        this._configuration.updateLocalUserConfiguration(this.localUserConfiguration.reparse());
        this._configuration.updateRemoteUserConfiguration(this.remoteUserConfiguration.reparse());
      }
      if (this.getWorkbenchState() === 2) {
        const folderConfiguration = this.cachedFolderConfigs.get(this.workspace.folders[0].uri);
        if (folderConfiguration) {
          this._configuration.updateWorkspaceConfiguration(folderConfiguration.reparse());
          this._configuration.updateFolderConfiguration(this.workspace.folders[0].uri, folderConfiguration.reparse());
        }
      } else {
        this._configuration.updateWorkspaceConfiguration(this.workspaceConfiguration.reparseWorkspaceSettings());
        for (const folder of this.workspace.folders) {
          const folderConfiguration = this.cachedFolderConfigs.get(folder.uri);
          if (folderConfiguration) {
            this._configuration.updateFolderConfiguration(folder.uri, folderConfiguration.reparse());
          }
        }
      }
      this.triggerConfigurationChange(change, { data: previousData, workspace: this.workspace }, 7);
      this.updateRestrictedSettings();
    }
  }
  onPolicyConfigurationChanged(policyConfiguration) {
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const change = this._configuration.compareAndUpdatePolicyConfiguration(policyConfiguration);
    this.triggerConfigurationChange(change, previous, 7);
  }
  onApplicationConfigurationChanged(applicationConfiguration) {
    var _a2;
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const previousAllProfilesSettings = this._configuration.applicationConfiguration.getValue(APPLY_ALL_PROFILES_SETTING) ?? [];
    const change = this._configuration.compareAndUpdateApplicationConfiguration(applicationConfiguration);
    const currentAllProfilesSettings = this.getValue(APPLY_ALL_PROFILES_SETTING) ?? [];
    const configurationProperties = this.configurationRegistry.getConfigurationProperties();
    const changedKeys = [];
    for (const changedKey of change.keys) {
      if (((_a2 = configurationProperties[changedKey]) == null ? void 0 : _a2.scope) === 1) {
        changedKeys.push(changedKey);
        if (changedKey === APPLY_ALL_PROFILES_SETTING) {
          for (const previousAllProfileSetting of previousAllProfilesSettings) {
            if (!currentAllProfilesSettings.includes(previousAllProfileSetting)) {
              changedKeys.push(previousAllProfileSetting);
            }
          }
          for (const currentAllProfileSetting of currentAllProfilesSettings) {
            if (!previousAllProfilesSettings.includes(currentAllProfileSetting)) {
              changedKeys.push(currentAllProfileSetting);
            }
          }
        }
      } else if (currentAllProfilesSettings.includes(changedKey)) {
        changedKeys.push(changedKey);
      }
    }
    change.keys = changedKeys;
    if (change.keys.includes(APPLY_ALL_PROFILES_SETTING)) {
      this._configuration.updateLocalUserConfiguration(this.localUserConfiguration.reparse({ exclude: currentAllProfilesSettings }));
    }
    this.triggerConfigurationChange(change, previous, 2);
  }
  onLocalUserConfigurationChanged(userConfiguration) {
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const change = this._configuration.compareAndUpdateLocalUserConfiguration(userConfiguration);
    this.triggerConfigurationChange(change, previous, 2);
  }
  onRemoteUserConfigurationChanged(userConfiguration) {
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const change = this._configuration.compareAndUpdateRemoteUserConfiguration(userConfiguration);
    this.triggerConfigurationChange(change, previous, 2);
  }
  async onWorkspaceConfigurationChanged(fromCache) {
    if (this.workspace && this.workspace.configuration) {
      let newFolders = toWorkspaceFolders(this.workspaceConfiguration.getFolders(), this.workspace.configuration, this.uriIdentityService.extUri);
      if (this.workspace.initialized) {
        const { added, removed, changed } = this.compareFolders(this.workspace.folders, newFolders);
        if (added.length || removed.length || changed.length) {
          newFolders = await this.toValidWorkspaceFolders(newFolders);
        } else {
          newFolders = this.workspace.folders;
        }
      }
      await this.updateWorkspaceConfiguration(newFolders, this.workspaceConfiguration.getConfiguration(), fromCache);
    }
  }
  updateRestrictedSettings() {
    var _a2, _b, _c;
    const changed = [];
    const allProperties = this.configurationRegistry.getConfigurationProperties();
    const defaultRestrictedSettings = Object.keys(allProperties).filter((key) => allProperties[key].restricted).sort((a, b) => a.localeCompare(b));
    const defaultDelta = delta(defaultRestrictedSettings, this._restrictedSettings.default, (a, b) => a.localeCompare(b));
    changed.push(...defaultDelta.added, ...defaultDelta.removed);
    const application = (((_a2 = this.applicationConfiguration) == null ? void 0 : _a2.getRestrictedSettings()) || []).sort((a, b) => a.localeCompare(b));
    const applicationDelta = delta(application, this._restrictedSettings.application || [], (a, b) => a.localeCompare(b));
    changed.push(...applicationDelta.added, ...applicationDelta.removed);
    const userLocal = this.localUserConfiguration.getRestrictedSettings().sort((a, b) => a.localeCompare(b));
    const userLocalDelta = delta(userLocal, this._restrictedSettings.userLocal || [], (a, b) => a.localeCompare(b));
    changed.push(...userLocalDelta.added, ...userLocalDelta.removed);
    const userRemote = (((_b = this.remoteUserConfiguration) == null ? void 0 : _b.getRestrictedSettings()) || []).sort((a, b) => a.localeCompare(b));
    const userRemoteDelta = delta(userRemote, this._restrictedSettings.userRemote || [], (a, b) => a.localeCompare(b));
    changed.push(...userRemoteDelta.added, ...userRemoteDelta.removed);
    const workspaceFolderMap = new ResourceMap();
    for (const workspaceFolder of this.workspace.folders) {
      const cachedFolderConfig = this.cachedFolderConfigs.get(workspaceFolder.uri);
      const folderRestrictedSettings = ((cachedFolderConfig == null ? void 0 : cachedFolderConfig.getRestrictedSettings()) || []).sort((a, b) => a.localeCompare(b));
      if (folderRestrictedSettings.length) {
        workspaceFolderMap.set(workspaceFolder.uri, folderRestrictedSettings);
      }
      const previous = ((_c = this._restrictedSettings.workspaceFolder) == null ? void 0 : _c.get(workspaceFolder.uri)) || [];
      const workspaceFolderDelta = delta(folderRestrictedSettings, previous, (a, b) => a.localeCompare(b));
      changed.push(...workspaceFolderDelta.added, ...workspaceFolderDelta.removed);
    }
    const workspace = this.getWorkbenchState() === 3 ? this.workspaceConfiguration.getRestrictedSettings().sort((a, b) => a.localeCompare(b)) : this.workspace.folders[0] ? workspaceFolderMap.get(this.workspace.folders[0].uri) || [] : [];
    const workspaceDelta = delta(workspace, this._restrictedSettings.workspace || [], (a, b) => a.localeCompare(b));
    changed.push(...workspaceDelta.added, ...workspaceDelta.removed);
    if (changed.length) {
      this._restrictedSettings = {
        default: defaultRestrictedSettings,
        application: application.length ? application : void 0,
        userLocal: userLocal.length ? userLocal : void 0,
        userRemote: userRemote.length ? userRemote : void 0,
        workspace: workspace.length ? workspace : void 0,
        workspaceFolder: workspaceFolderMap.size ? workspaceFolderMap : void 0
      };
      this._onDidChangeRestrictedSettings.fire(this.restrictedSettings);
    }
  }
  async updateWorkspaceConfiguration(workspaceFolders, configuration, fromCache) {
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const change = this._configuration.compareAndUpdateWorkspaceConfiguration(configuration);
    const changes = this.compareFolders(this.workspace.folders, workspaceFolders);
    if (changes.added.length || changes.removed.length || changes.changed.length) {
      this.workspace.folders = workspaceFolders;
      const change2 = await this.onFoldersChanged();
      await this.handleWillChangeWorkspaceFolders(changes, fromCache);
      this.triggerConfigurationChange(change2, previous, 6);
      this._onDidChangeWorkspaceFolders.fire(changes);
    } else {
      this.triggerConfigurationChange(change, previous, 5);
    }
    this.updateRestrictedSettings();
  }
  async handleWillChangeWorkspaceFolders(changes, fromCache) {
    const joiners = [];
    this._onWillChangeWorkspaceFolders.fire({
      join(updateWorkspaceTrustStatePromise) {
        joiners.push(updateWorkspaceTrustStatePromise);
      },
      changes,
      fromCache
    });
    try {
      await Promises.settled(joiners);
    } catch (error) {
    }
  }
  async onWorkspaceFolderConfigurationChanged(folder) {
    const [folderConfiguration] = await this.loadFolderConfigurations([folder]);
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const folderConfigurationChange = this._configuration.compareAndUpdateFolderConfiguration(folder.uri, folderConfiguration);
    if (this.getWorkbenchState() === 2) {
      const workspaceConfigurationChange = this._configuration.compareAndUpdateWorkspaceConfiguration(folderConfiguration);
      this.triggerConfigurationChange(mergeChanges(folderConfigurationChange, workspaceConfigurationChange), previous, 5);
    } else {
      this.triggerConfigurationChange(folderConfigurationChange, previous, 6);
    }
    this.updateRestrictedSettings();
  }
  async onFoldersChanged() {
    const changes = [];
    for (const key of this.cachedFolderConfigs.keys()) {
      if (!this.workspace.folders.filter((folder) => folder.uri.toString() === key.toString())[0]) {
        const folderConfiguration = this.cachedFolderConfigs.get(key);
        folderConfiguration.dispose();
        this.cachedFolderConfigs.delete(key);
        changes.push(this._configuration.compareAndDeleteFolderConfiguration(key));
      }
    }
    const toInitialize = this.workspace.folders.filter((folder) => !this.cachedFolderConfigs.has(folder.uri));
    if (toInitialize.length) {
      const folderConfigurations = await this.loadFolderConfigurations(toInitialize);
      folderConfigurations.forEach((folderConfiguration, index) => {
        changes.push(this._configuration.compareAndUpdateFolderConfiguration(toInitialize[index].uri, folderConfiguration));
      });
    }
    return mergeChanges(...changes);
  }
  loadFolderConfigurations(folders) {
    return Promise.all([...folders.map((folder) => {
      let folderConfiguration = this.cachedFolderConfigs.get(folder.uri);
      if (!folderConfiguration) {
        folderConfiguration = new FolderConfiguration(
          !this.initialized,
          folder,
          FOLDER_CONFIG_FOLDER_NAME,
          this.getWorkbenchState(),
          this.isWorkspaceTrusted,
          this.fileService,
          this.uriIdentityService,
          this.logService,
          this.configurationCache
        );
        this._register(folderConfiguration.onDidChange(() => this.onWorkspaceFolderConfigurationChanged(folder)));
        this.cachedFolderConfigs.set(folder.uri, this._register(folderConfiguration));
      }
      return folderConfiguration.loadConfiguration();
    })]);
  }
  async validateWorkspaceFoldersAndReload(fromCache) {
    const validWorkspaceFolders = await this.toValidWorkspaceFolders(this.workspace.folders);
    const { removed } = this.compareFolders(this.workspace.folders, validWorkspaceFolders);
    if (removed.length) {
      await this.updateWorkspaceConfiguration(validWorkspaceFolders, this.workspaceConfiguration.getConfiguration(), fromCache);
    }
  }
  async toValidWorkspaceFolders(workspaceFolders) {
    const validWorkspaceFolders = [];
    for (const workspaceFolder of workspaceFolders) {
      try {
        const result = await this.fileService.stat(workspaceFolder.uri);
        if (!result.isDirectory) {
          continue;
        }
      } catch (e) {
        this.logService.warn(`Ignoring the error while validating workspace folder ${workspaceFolder.uri.toString()} - ${toErrorMessage(e)}`);
      }
      validWorkspaceFolders.push(workspaceFolder);
    }
    return validWorkspaceFolders;
  }
  async writeConfigurationValue(key, value, target, overrides, options) {
    var _a2, _b, _c;
    if (!this.instantiationService) {
      throw new Error("Cannot write configuration because the configuration service is not yet ready to accept writes.");
    }
    if (target === 7) {
      throw new Error("Invalid configuration target");
    }
    if (target === 8) {
      const previous = { data: this._configuration.toData(), workspace: this.workspace };
      this._configuration.updateValue(key, value, overrides);
      this.triggerConfigurationChange({ keys: ((_a2 = overrides == null ? void 0 : overrides.overrideIdentifiers) == null ? void 0 : _a2.length) ? [keyFromOverrideIdentifiers(overrides.overrideIdentifiers), key] : [key], overrides: ((_b = overrides == null ? void 0 : overrides.overrideIdentifiers) == null ? void 0 : _b.length) ? overrides.overrideIdentifiers.map((overrideIdentifier) => [overrideIdentifier, [key]]) : [] }, previous, target);
      return;
    }
    const editableConfigurationTarget = this.toEditableConfigurationTarget(target, key);
    if (!editableConfigurationTarget) {
      throw new Error("Invalid configuration target");
    }
    if (editableConfigurationTarget === 2 && !this.remoteUserConfiguration) {
      throw new Error("Invalid configuration target");
    }
    this.configurationEditing = this.configurationEditing ?? this.instantiationService.createInstance(ConfigurationEditing, ((_c = await this.remoteAgentService.getEnvironment()) == null ? void 0 : _c.settingsPath) ?? null);
    await this.configurationEditing.writeConfiguration(editableConfigurationTarget, { key, value }, { scopes: overrides, ...options });
    switch (editableConfigurationTarget) {
      case 1:
        if (this.applicationConfiguration && this.isSettingAppliedForAllProfiles(key)) {
          await this.reloadApplicationConfiguration();
        } else {
          await this.reloadLocalUserConfiguration();
        }
        return;
      case 2:
        return this.reloadRemoteUserConfiguration().then(() => void 0);
      case 3:
        return this.reloadWorkspaceConfiguration();
      case 4: {
        const workspaceFolder = overrides && overrides.resource ? this.workspace.getFolder(overrides.resource) : null;
        if (workspaceFolder) {
          return this.reloadWorkspaceFolderConfiguration(workspaceFolder);
        }
      }
    }
  }
  deriveConfigurationTargets(key, value, inspect) {
    if (equals(value, inspect.value)) {
      return [];
    }
    const definedTargets = [];
    if (inspect.workspaceFolderValue !== void 0) {
      definedTargets.push(6);
    }
    if (inspect.workspaceValue !== void 0) {
      definedTargets.push(5);
    }
    if (inspect.userRemoteValue !== void 0) {
      definedTargets.push(4);
    }
    if (inspect.userLocalValue !== void 0) {
      definedTargets.push(3);
    }
    if (value === void 0) {
      return definedTargets;
    }
    return [definedTargets[0] || 2];
  }
  triggerConfigurationChange(change, previous, target) {
    if (change.keys.length) {
      if (target !== 7) {
        this.logService.debug(`Configuration keys changed in ${ConfigurationTargetToString(target)} target`, ...change.keys);
      }
      const configurationChangeEvent = new ConfigurationChangeEvent(change, previous, this._configuration, this.workspace);
      configurationChangeEvent.source = target;
      configurationChangeEvent.sourceConfig = this.getTargetConfiguration(target);
      this._onDidChangeConfiguration.fire(configurationChangeEvent);
    }
  }
  getTargetConfiguration(target) {
    switch (target) {
      case 7:
        return this._configuration.defaults.contents;
      case 2:
        return this._configuration.userConfiguration.contents;
      case 5:
        return this._configuration.workspaceConfiguration.contents;
    }
    return {};
  }
  toEditableConfigurationTarget(target, key) {
    var _a2;
    if (target === 2) {
      if (this.remoteUserConfiguration) {
        const scope = (_a2 = this.configurationRegistry.getConfigurationProperties()[key]) == null ? void 0 : _a2.scope;
        if (scope === 2 || scope === 6) {
          return 2;
        }
        if (this.inspect(key).userRemoteValue !== void 0) {
          return 2;
        }
      }
      return 1;
    }
    if (target === 3) {
      return 1;
    }
    if (target === 4) {
      return 2;
    }
    if (target === 5) {
      return 3;
    }
    if (target === 6) {
      return 4;
    }
    return null;
  }
};
var RegisterConfigurationSchemasContribution = class RegisterConfigurationSchemasContribution2 extends Disposable {
  constructor(workspaceContextService, environmentService, workspaceTrustManagementService, extensionService, lifecycleService) {
    super();
    this.workspaceContextService = workspaceContextService;
    this.environmentService = environmentService;
    this.workspaceTrustManagementService = workspaceTrustManagementService;
    extensionService.whenInstalledExtensionsRegistered().then(() => {
      this.registerConfigurationSchemas();
      const configurationRegistry4 = Registry.as(Extensions3.Configuration);
      const delayer = this._register(new Delayer(50));
      this._register(Event.any(configurationRegistry4.onDidUpdateConfiguration, configurationRegistry4.onDidSchemaChange, workspaceTrustManagementService.onDidChangeTrust)(() => delayer.trigger(() => this.registerConfigurationSchemas(), lifecycleService.phase === 4 ? void 0 : 2500)));
    });
  }
  registerConfigurationSchemas() {
    const allSettingsSchema = {
      properties: allSettings.properties,
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const userSettingsSchema = this.environmentService.remoteAuthority ? {
      properties: Object.assign({}, applicationSettings.properties, windowSettings.properties, resourceSettings.properties),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    } : allSettingsSchema;
    const profileSettingsSchema = {
      properties: Object.assign({}, machineSettings.properties, machineOverridableSettings.properties, windowSettings.properties, resourceSettings.properties),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const machineSettingsSchema = {
      properties: Object.assign({}, machineSettings.properties, machineOverridableSettings.properties, windowSettings.properties, resourceSettings.properties),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const workspaceSettingsSchema = {
      properties: Object.assign({}, this.checkAndFilterPropertiesRequiringTrust(machineOverridableSettings.properties), this.checkAndFilterPropertiesRequiringTrust(windowSettings.properties), this.checkAndFilterPropertiesRequiringTrust(resourceSettings.properties)),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const defaultSettingsSchema = {
      properties: Object.keys(allSettings.properties).reduce((result, key) => {
        result[key] = Object.assign({ deprecationMessage: void 0 }, allSettings.properties[key]);
        return result;
      }, {}),
      patternProperties: Object.keys(allSettings.patternProperties).reduce((result, key) => {
        result[key] = Object.assign({ deprecationMessage: void 0 }, allSettings.patternProperties[key]);
        return result;
      }, {}),
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const folderSettingsSchema = 3 === this.workspaceContextService.getWorkbenchState() ? {
      properties: Object.assign({}, this.checkAndFilterPropertiesRequiringTrust(machineOverridableSettings.properties), this.checkAndFilterPropertiesRequiringTrust(resourceSettings.properties)),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    } : workspaceSettingsSchema;
    const configDefaultsSchema = {
      type: "object",
      description: localize(
        "configurationDefaults.description",
        "Contribute defaults for configurations"
      ),
      properties: Object.assign({}, machineOverridableSettings.properties, windowSettings.properties, resourceSettings.properties),
      patternProperties: {
        [OVERRIDE_PROPERTY_PATTERN]: {
          type: "object",
          default: {},
          $ref: resourceLanguageSettingsSchemaId
        }
      },
      additionalProperties: false
    };
    this.registerSchemas({
      defaultSettingsSchema,
      userSettingsSchema,
      profileSettingsSchema,
      machineSettingsSchema,
      workspaceSettingsSchema,
      folderSettingsSchema,
      configDefaultsSchema
    });
  }
  registerSchemas(schemas) {
    const jsonRegistry2 = Registry.as(Extensions.JSONContribution);
    jsonRegistry2.registerSchema(defaultSettingsSchemaId, schemas.defaultSettingsSchema);
    jsonRegistry2.registerSchema(userSettingsSchemaId, schemas.userSettingsSchema);
    jsonRegistry2.registerSchema(profileSettingsSchemaId, schemas.profileSettingsSchema);
    jsonRegistry2.registerSchema(machineSettingsSchemaId, schemas.machineSettingsSchema);
    jsonRegistry2.registerSchema(workspaceSettingsSchemaId, schemas.workspaceSettingsSchema);
    jsonRegistry2.registerSchema(folderSettingsSchemaId, schemas.folderSettingsSchema);
    jsonRegistry2.registerSchema(configurationDefaultsSchemaId, schemas.configDefaultsSchema);
  }
  checkAndFilterPropertiesRequiringTrust(properties) {
    if (this.workspaceTrustManagementService.isWorkspaceTrusted()) {
      return properties;
    }
    const result = {};
    Object.entries(properties).forEach(([key, value]) => {
      if (!value.restricted) {
        result[key] = value;
      }
    });
    return result;
  }
};
RegisterConfigurationSchemasContribution = __decorate([
  __param(0, IWorkspaceContextService),
  __param(1, IWorkbenchEnvironmentService),
  __param(2, IWorkspaceTrustManagementService),
  __param(3, IExtensionService),
  __param(4, ILifecycleService)
], RegisterConfigurationSchemasContribution);
var UpdateExperimentalSettingsDefaults = class UpdateExperimentalSettingsDefaults2 extends Disposable {
  constructor(workbenchAssignmentService) {
    super();
    this.workbenchAssignmentService = workbenchAssignmentService;
    this.processedExperimentalSettings = /* @__PURE__ */ new Set();
    this.configurationRegistry = Registry.as(Extensions3.Configuration);
    this.processExperimentalSettings(Object.keys(this.configurationRegistry.getConfigurationProperties()));
    this._register(this.configurationRegistry.onDidUpdateConfiguration(({ properties }) => this.processExperimentalSettings(properties)));
  }
  async processExperimentalSettings(properties) {
    var _a2;
    const overrides = {};
    const allProperties = this.configurationRegistry.getConfigurationProperties();
    for (const property of properties) {
      const schema = allProperties[property];
      if (!((_a2 = schema == null ? void 0 : schema.tags) == null ? void 0 : _a2.includes("experimental"))) {
        continue;
      }
      if (this.processedExperimentalSettings.has(property)) {
        continue;
      }
      this.processedExperimentalSettings.add(property);
      try {
        const value = await this.workbenchAssignmentService.getTreatment(`config.${property}`);
        if (!isUndefined(value) && !equals(value, schema.default)) {
          overrides[property] = value;
        }
      } catch (error) {
      }
    }
    if (Object.keys(overrides).length) {
      this.configurationRegistry.registerDefaultConfigurations([{ overrides, source: localize("experimental", "Experiments") }]);
    }
  }
};
UpdateExperimentalSettingsDefaults = __decorate([
  __param(0, IWorkbenchAssignmentService)
], UpdateExperimentalSettingsDefaults);
var workbenchContributionsRegistry = Registry.as(Extensions2.Workbench);
workbenchContributionsRegistry.registerWorkbenchContribution(RegisterConfigurationSchemasContribution, 3);
workbenchContributionsRegistry.registerWorkbenchContribution(UpdateExperimentalSettingsDefaults, 3);
var configurationRegistry = Registry.as(Extensions3.Configuration);
configurationRegistry.registerConfiguration({
  ...workbenchConfigurationNodeBase,
  properties: {
    [APPLY_ALL_PROFILES_SETTING]: {
      "type": "array",
      description: localize(
        "setting description",
        "Configure settings to be applied for all profiles."
      ),
      "default": [],
      "scope": 1,
      additionalProperties: true,
      uniqueItems: true
    }
  }
});

// node_modules/vscode/service-override/configuration.js
init_configuration();

// node_modules/vscode/vscode/src/vs/editor/common/services/textResourceConfigurationService.js
init_tslib_es6();
init_event();
init_lifecycle();
init_position();
init_language();
init_model();
init_configuration();
var TextResourceConfigurationService = class TextResourceConfigurationService2 extends Disposable {
  constructor(configurationService, modelService, languageService) {
    super();
    this.configurationService = configurationService;
    this.modelService = modelService;
    this.languageService = languageService;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._register(this.configurationService.onDidChangeConfiguration((e) => this._onDidChangeConfiguration.fire(this.toResourceConfigurationChangeEvent(e))));
  }
  getValue(resource, arg2, arg3) {
    if (typeof arg3 === "string") {
      return this._getValue(resource, Position.isIPosition(arg2) ? arg2 : null, arg3);
    }
    return this._getValue(resource, null, typeof arg2 === "string" ? arg2 : void 0);
  }
  updateValue(resource, key, value, configurationTarget) {
    var _a2, _b, _c, _d, _e;
    const language = this.getLanguage(resource, null);
    const configurationValue = this.configurationService.inspect(key, { resource, overrideIdentifier: language });
    if (configurationTarget === void 0) {
      configurationTarget = this.deriveConfigurationTarget(configurationValue, language);
    }
    switch (configurationTarget) {
      case 8:
        return this._updateValue(key, value, configurationTarget, (_a2 = configurationValue.memory) == null ? void 0 : _a2.override, resource, language);
      case 6:
        return this._updateValue(key, value, configurationTarget, (_b = configurationValue.workspaceFolder) == null ? void 0 : _b.override, resource, language);
      case 5:
        return this._updateValue(key, value, configurationTarget, (_c = configurationValue.workspace) == null ? void 0 : _c.override, resource, language);
      case 4:
        return this._updateValue(key, value, configurationTarget, (_d = configurationValue.userRemote) == null ? void 0 : _d.override, resource, language);
      default:
        return this._updateValue(key, value, configurationTarget, (_e = configurationValue.userLocal) == null ? void 0 : _e.override, resource, language);
    }
  }
  _updateValue(key, value, configurationTarget, overriddenValue, resource, language) {
    if (language && overriddenValue !== void 0) {
      return this.configurationService.updateValue(key, value, { resource, overrideIdentifier: language }, configurationTarget);
    } else {
      return this.configurationService.updateValue(key, value, { resource }, configurationTarget);
    }
  }
  deriveConfigurationTarget(configurationValue, language) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
    if (language) {
      if (((_a2 = configurationValue.memory) == null ? void 0 : _a2.override) !== void 0) {
        return 8;
      }
      if (((_b = configurationValue.workspaceFolder) == null ? void 0 : _b.override) !== void 0) {
        return 6;
      }
      if (((_c = configurationValue.workspace) == null ? void 0 : _c.override) !== void 0) {
        return 5;
      }
      if (((_d = configurationValue.userRemote) == null ? void 0 : _d.override) !== void 0) {
        return 4;
      }
      if (((_e = configurationValue.userLocal) == null ? void 0 : _e.override) !== void 0) {
        return 3;
      }
    }
    if (((_f = configurationValue.memory) == null ? void 0 : _f.value) !== void 0) {
      return 8;
    }
    if (((_g = configurationValue.workspaceFolder) == null ? void 0 : _g.value) !== void 0) {
      return 6;
    }
    if (((_h = configurationValue.workspace) == null ? void 0 : _h.value) !== void 0) {
      return 5;
    }
    if (((_i = configurationValue.userRemote) == null ? void 0 : _i.value) !== void 0) {
      return 4;
    }
    return 3;
  }
  _getValue(resource, position, section) {
    const language = resource ? this.getLanguage(resource, position) : void 0;
    if (typeof section === "undefined") {
      return this.configurationService.getValue({ resource, overrideIdentifier: language });
    }
    return this.configurationService.getValue(section, { resource, overrideIdentifier: language });
  }
  inspect(resource, position, section) {
    const language = resource ? this.getLanguage(resource, position) : void 0;
    return this.configurationService.inspect(section, { resource, overrideIdentifier: language });
  }
  getLanguage(resource, position) {
    const model = this.modelService.getModel(resource);
    if (model) {
      return position ? model.getLanguageIdAtPosition(position.lineNumber, position.column) : model.getLanguageId();
    }
    return this.languageService.guessLanguageIdByFilepathOrFirstLine(resource);
  }
  toResourceConfigurationChangeEvent(configurationChangeEvent) {
    return {
      affectedKeys: configurationChangeEvent.affectedKeys,
      affectsConfiguration: (resource, configuration) => {
        const overrideIdentifier = resource ? this.getLanguage(resource, null) : void 0;
        return configurationChangeEvent.affectsConfiguration(configuration, { resource, overrideIdentifier });
      }
    };
  }
};
TextResourceConfigurationService = __decorate([
  __param(0, IConfigurationService),
  __param(1, IModelService),
  __param(2, ILanguageService)
], TextResourceConfigurationService);

// node_modules/vscode/service-override/configuration.js
init_descriptors();

// node_modules/vscode/vscode/src/vs/platform/configuration/common/configurationRegistry.js
var ConfigurationScope;
(function(ConfigurationScope2) {
  ConfigurationScope2[ConfigurationScope2["APPLICATION"] = 1] = "APPLICATION";
  ConfigurationScope2[ConfigurationScope2["MACHINE"] = 2] = "MACHINE";
  ConfigurationScope2[ConfigurationScope2["WINDOW"] = 3] = "WINDOW";
  ConfigurationScope2[ConfigurationScope2["RESOURCE"] = 4] = "RESOURCE";
  ConfigurationScope2[ConfigurationScope2["LANGUAGE_OVERRIDABLE"] = 5] = "LANGUAGE_OVERRIDABLE";
  ConfigurationScope2[ConfigurationScope2["MACHINE_OVERRIDABLE"] = 6] = "MACHINE_OVERRIDABLE";
})(ConfigurationScope || (ConfigurationScope = {}));

// node_modules/vscode/service-override/configuration.js
init_configurationRegistry();
init_platform2();
init_buffer();
init_files();
init_log();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/common/configurationCache.js
init_resources();
init_buffer();
init_async();
var ConfigurationCache = class {
  constructor(donotCacheResourcesWithSchemes, environmentService, fileService) {
    this.donotCacheResourcesWithSchemes = donotCacheResourcesWithSchemes;
    this.fileService = fileService;
    this.cachedConfigurations = /* @__PURE__ */ new Map();
    this.cacheHome = environmentService.cacheHome;
  }
  needsCaching(resource) {
    return !this.donotCacheResourcesWithSchemes.includes(resource.scheme);
  }
  read(key) {
    return this.getCachedConfiguration(key).read();
  }
  write(key, content) {
    return this.getCachedConfiguration(key).save(content);
  }
  remove(key) {
    return this.getCachedConfiguration(key).remove();
  }
  getCachedConfiguration({ type, key }) {
    const k = `${type}:${key}`;
    let cachedConfiguration = this.cachedConfigurations.get(k);
    if (!cachedConfiguration) {
      cachedConfiguration = new CachedConfiguration({ type, key }, this.cacheHome, this.fileService);
      this.cachedConfigurations.set(k, cachedConfiguration);
    }
    return cachedConfiguration;
  }
};
var CachedConfiguration = class {
  constructor({ type, key }, cacheHome, fileService) {
    this.fileService = fileService;
    this.cachedConfigurationFolderResource = joinPath(cacheHome, "CachedConfigurations", type, key);
    this.cachedConfigurationFileResource = joinPath(this.cachedConfigurationFolderResource, type === "workspaces" ? "workspace.json" : "configuration.json");
    this.queue = new Queue();
  }
  async read() {
    try {
      const content = await this.fileService.readFile(this.cachedConfigurationFileResource);
      return content.value.toString();
    } catch (e) {
      return "";
    }
  }
  async save(content) {
    const created = await this.createCachedFolder();
    if (created) {
      await this.queue.queue(async () => {
        await this.fileService.writeFile(this.cachedConfigurationFileResource, VSBuffer.fromString(content));
      });
    }
  }
  async remove() {
    try {
      await this.queue.queue(() => this.fileService.del(this.cachedConfigurationFolderResource, { recursive: true, useTrash: false }));
    } catch (error) {
      if (error.fileOperationResult !== 1) {
        throw error;
      }
    }
  }
  async createCachedFolder() {
    if (await this.fileService.exists(this.cachedConfigurationFolderResource)) {
      return true;
    }
    try {
      await this.fileService.createFolder(this.cachedConfigurationFolderResource);
      return true;
    } catch (error) {
      return false;
    }
  }
};

// node_modules/vscode/service-override/configuration.js
init_network();

// node_modules/vscode/vscode/src/vs/workbench/services/label/common/labelService.js
init_tslib_es6();
init_nls();
init_uri();
init_lifecycle();
init_path();
init_event();
init_platform2();
init_resources();
init_platform();
init_network();
init_arrays();
var resourceLabelFormattersExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "resourceLabelFormatters",
  jsonSchema: {
    description: localize(
      "vscode.extension.contributes.resourceLabelFormatters",
      "Contributes resource label formatting rules."
    ),
    type: "array",
    items: {
      type: "object",
      required: ["scheme", "formatting"],
      properties: {
        scheme: {
          type: "string",
          description: localize(
            "vscode.extension.contributes.resourceLabelFormatters.scheme",
            'URI scheme on which to match the formatter on. For example "file". Simple glob patterns are supported.'
          )
        },
        authority: {
          type: "string",
          description: localize(
            "vscode.extension.contributes.resourceLabelFormatters.authority",
            "URI authority on which to match the formatter on. Simple glob patterns are supported."
          )
        },
        formatting: {
          description: localize(
            "vscode.extension.contributes.resourceLabelFormatters.formatting",
            "Rules for formatting uri resource labels."
          ),
          type: "object",
          properties: {
            label: {
              type: "string",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.label",
                "Label rules to display. For example: myLabel:/${path}. ${path}, ${scheme}, ${authority} and ${authoritySuffix} are supported as variables."
              )
            },
            separator: {
              type: "string",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.separator",
                "Separator to be used in the uri label display. '/' or '' as an example."
              )
            },
            stripPathStartingSeparator: {
              type: "boolean",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.stripPathStartingSeparator",
                "Controls whether `${path}` substitutions should have starting separator characters stripped."
              )
            },
            tildify: {
              type: "boolean",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.tildify",
                "Controls if the start of the uri label should be tildified when possible."
              )
            },
            workspaceSuffix: {
              type: "string",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.formatting.workspaceSuffix",
                "Suffix appended to the workspace label."
              )
            }
          }
        }
      }
    }
  }
});
var sepRegexp = /\//g;
var labelMatchingRegexp = /\$\{(scheme|authoritySuffix|authority|path|(query)\.(.+?))\}/g;
function hasDriveLetterIgnorePlatform(path) {
  return !!(path && path[2] === ":");
}
var ResourceLabelFormattersHandler = class ResourceLabelFormattersHandler2 {
  constructor(labelService) {
    this.formattersDisposables = /* @__PURE__ */ new Map();
    resourceLabelFormattersExtPoint.setHandler((extensions, delta2) => {
      for (const added of delta2.added) {
        for (const untrustedFormatter of added.value) {
          const formatter = { ...untrustedFormatter };
          if (typeof formatter.formatting.label !== "string") {
            formatter.formatting.label = "${authority}${path}";
          }
          if (typeof formatter.formatting.separator !== `string`) {
            formatter.formatting.separator = sep;
          }
          if (!isProposedApiEnabled(added.description, "contribLabelFormatterWorkspaceTooltip") && formatter.formatting.workspaceTooltip) {
            formatter.formatting.workspaceTooltip = void 0;
          }
          this.formattersDisposables.set(formatter, labelService.registerFormatter(formatter));
        }
      }
      for (const removed of delta2.removed) {
        for (const formatter of removed.value) {
          dispose(this.formattersDisposables.get(formatter));
        }
      }
    });
  }
};
ResourceLabelFormattersHandler = __decorate([
  __param(0, ILabelService)
], ResourceLabelFormattersHandler);
Registry.as(Extensions2.Workbench).registerWorkbenchContribution(ResourceLabelFormattersHandler, 3);
var FORMATTER_CACHE_SIZE = 50;
var LabelService = class LabelService2 extends Disposable {
  constructor(environmentService, contextService, pathService, remoteAgentService, storageService, lifecycleService) {
    var _a2, _b;
    super();
    this.environmentService = environmentService;
    this.contextService = contextService;
    this.pathService = pathService;
    this.remoteAgentService = remoteAgentService;
    this._onDidChangeFormatters = this._register(new Emitter({ leakWarningThreshold: 400 }));
    this.onDidChangeFormatters = this._onDidChangeFormatters.event;
    this.os = OS;
    this.userHome = pathService.defaultUriScheme === Schemas.file ? this.pathService.userHome({ preferLocal: true }) : void 0;
    const memento = this.storedFormattersMemento = new Memento("cachedResourceLabelFormatters2", storageService);
    this.storedFormatters = memento.getMemento(0, 1);
    this.formatters = ((_b = (_a2 = this.storedFormatters) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.slice()) || [];
    this.resolveRemoteEnvironment();
  }
  async resolveRemoteEnvironment() {
    const env = await this.remoteAgentService.getEnvironment();
    this.os = (env == null ? void 0 : env.os) ?? OS;
    this.userHome = await this.pathService.userHome();
  }
  findFormatting(resource) {
    let bestResult;
    for (const formatter of this.formatters) {
      if (formatter.scheme === resource.scheme) {
        if (!formatter.authority && (!bestResult || formatter.priority)) {
          bestResult = formatter;
          continue;
        }
        if (!formatter.authority) {
          continue;
        }
        if (match(formatter.authority.toLowerCase(), resource.authority.toLowerCase()) && (!bestResult || !bestResult.authority || formatter.authority.length > bestResult.authority.length || formatter.authority.length === bestResult.authority.length && formatter.priority)) {
          bestResult = formatter;
        }
      }
    }
    return bestResult ? bestResult.formatting : void 0;
  }
  getUriLabel(resource, options = {}) {
    let formatting = this.findFormatting(resource);
    if (formatting && options.separator) {
      formatting = { ...formatting, separator: options.separator };
    }
    const label = this.doGetUriLabel(resource, formatting, options);
    if (!formatting && options.separator) {
      return label.replace(sepRegexp, options.separator);
    }
    return label;
  }
  doGetUriLabel(resource, formatting, options = {}) {
    if (!formatting) {
      return getPathLabel(resource, {
        os: this.os,
        tildify: this.userHome ? { userHome: this.userHome } : void 0,
        relative: options.relative ? {
          noPrefix: options.noPrefix,
          getWorkspace: () => this.contextService.getWorkspace(),
          getWorkspaceFolder: (resource2) => this.contextService.getWorkspaceFolder(resource2)
        } : void 0
      });
    }
    if (options.relative && this.contextService) {
      let folder = this.contextService.getWorkspaceFolder(resource);
      if (!folder) {
        const workspace = this.contextService.getWorkspace();
        const firstFolder = firstOrDefault(workspace.folders);
        if (firstFolder && resource.scheme !== firstFolder.uri.scheme && resource.path.startsWith(posix.sep)) {
          folder = this.contextService.getWorkspaceFolder(firstFolder.uri.with({ path: resource.path }));
        }
      }
      if (folder) {
        const folderLabel = this.formatUri(folder.uri, formatting, options.noPrefix);
        let relativeLabel = this.formatUri(resource, formatting, options.noPrefix);
        let overlap = 0;
        while (relativeLabel[overlap] && relativeLabel[overlap] === folderLabel[overlap]) {
          overlap++;
        }
        if (!relativeLabel[overlap] || relativeLabel[overlap] === formatting.separator) {
          relativeLabel = relativeLabel.substring(1 + overlap);
        } else if (overlap === folderLabel.length && folder.uri.path === posix.sep) {
          relativeLabel = relativeLabel.substring(overlap);
        }
        const hasMultipleRoots = this.contextService.getWorkspace().folders.length > 1;
        if (hasMultipleRoots && !options.noPrefix) {
          const rootName = (folder == null ? void 0 : folder.name) ?? basenameOrAuthority(folder.uri);
          relativeLabel = relativeLabel ? `${rootName}  ${relativeLabel}` : rootName;
        }
        return relativeLabel;
      }
    }
    return this.formatUri(resource, formatting, options.noPrefix);
  }
  getUriBasenameLabel(resource) {
    const formatting = this.findFormatting(resource);
    const label = this.doGetUriLabel(resource, formatting);
    let pathLib;
    if ((formatting == null ? void 0 : formatting.separator) === win32.sep) {
      pathLib = win32;
    } else if ((formatting == null ? void 0 : formatting.separator) === posix.sep) {
      pathLib = posix;
    } else {
      pathLib = this.os === 1 ? win32 : posix;
    }
    return pathLib.basename(label);
  }
  getWorkspaceLabel(workspace, options) {
    if (isWorkspace(workspace)) {
      const identifier = toWorkspaceIdentifier(workspace);
      if (isSingleFolderWorkspaceIdentifier(identifier) || isWorkspaceIdentifier(identifier)) {
        return this.getWorkspaceLabel(identifier, options);
      }
      return "";
    }
    if (URI.isUri(workspace)) {
      return this.doGetSingleFolderWorkspaceLabel(workspace, options);
    }
    if (isSingleFolderWorkspaceIdentifier(workspace)) {
      return this.doGetSingleFolderWorkspaceLabel(workspace.uri, options);
    }
    if (isWorkspaceIdentifier(workspace)) {
      return this.doGetWorkspaceLabel(workspace.configPath, options);
    }
    return "";
  }
  doGetWorkspaceLabel(workspaceUri, options) {
    if (isUntitledWorkspace(workspaceUri, this.environmentService)) {
      return localize("untitledWorkspace", "Untitled (Workspace)");
    }
    if (isTemporaryWorkspace(workspaceUri)) {
      return localize("temporaryWorkspace", "Workspace");
    }
    let filename = basename(workspaceUri);
    if (filename.endsWith(WORKSPACE_EXTENSION)) {
      filename = filename.substr(0, filename.length - WORKSPACE_EXTENSION.length - 1);
    }
    let label;
    switch (options == null ? void 0 : options.verbose) {
      case 0:
        label = filename;
        break;
      case 2:
        label = localize(
          "workspaceNameVerbose",
          "{0} (Workspace)",
          this.getUriLabel(joinPath(dirname(workspaceUri), filename))
        );
        break;
      case 1:
      default:
        label = localize("workspaceName", "{0} (Workspace)", filename);
        break;
    }
    if ((options == null ? void 0 : options.verbose) === 0) {
      return label;
    }
    return this.appendWorkspaceSuffix(label, workspaceUri);
  }
  doGetSingleFolderWorkspaceLabel(folderUri, options) {
    let label;
    switch (options == null ? void 0 : options.verbose) {
      case 2:
        label = this.getUriLabel(folderUri);
        break;
      case 0:
      case 1:
      default:
        label = basename(folderUri) || posix.sep;
        break;
    }
    if ((options == null ? void 0 : options.verbose) === 0) {
      return label;
    }
    return this.appendWorkspaceSuffix(label, folderUri);
  }
  getSeparator(scheme, authority) {
    const formatter = this.findFormatting(URI.from({ scheme, authority }));
    return (formatter == null ? void 0 : formatter.separator) || posix.sep;
  }
  getHostLabel(scheme, authority) {
    const formatter = this.findFormatting(URI.from({ scheme, authority }));
    return (formatter == null ? void 0 : formatter.workspaceSuffix) || authority || "";
  }
  getHostTooltip(scheme, authority) {
    const formatter = this.findFormatting(URI.from({ scheme, authority }));
    return formatter == null ? void 0 : formatter.workspaceTooltip;
  }
  registerCachedFormatter(formatter) {
    var _a2;
    const list = (_a2 = this.storedFormatters).formatters ?? (_a2.formatters = []);
    let replace = list.findIndex((f) => f.scheme === formatter.scheme && f.authority === formatter.authority);
    if (replace === -1 && list.length >= FORMATTER_CACHE_SIZE) {
      replace = FORMATTER_CACHE_SIZE - 1;
    }
    if (replace === -1) {
      list.unshift(formatter);
    } else {
      for (let i = replace; i > 0; i--) {
        list[i] = list[i - 1];
      }
      list[0] = formatter;
    }
    this.storedFormattersMemento.saveMemento();
    return this.registerFormatter(formatter);
  }
  registerFormatter(formatter) {
    this.formatters.push(formatter);
    this._onDidChangeFormatters.fire({ scheme: formatter.scheme });
    return {
      dispose: () => {
        this.formatters = this.formatters.filter((f) => f !== formatter);
        this._onDidChangeFormatters.fire({ scheme: formatter.scheme });
      }
    };
  }
  formatUri(resource, formatting, forceNoTildify) {
    let label = formatting.label.replace(labelMatchingRegexp, (match2, token, qsToken, qsValue) => {
      switch (token) {
        case "scheme":
          return resource.scheme;
        case "authority":
          return resource.authority;
        case "authoritySuffix": {
          const i = resource.authority.indexOf("+");
          return i === -1 ? resource.authority : resource.authority.slice(i + 1);
        }
        case "path":
          return formatting.stripPathStartingSeparator ? resource.path.slice(resource.path[0] === formatting.separator ? 1 : 0) : resource.path;
        default: {
          if (qsToken === "query") {
            const { query } = resource;
            if (query && query[0] === "{" && query[query.length - 1] === "}") {
              try {
                return JSON.parse(query)[qsValue] || "";
              } catch {
              }
            }
          }
          return "";
        }
      }
    });
    if (formatting.normalizeDriveLetter && hasDriveLetterIgnorePlatform(label)) {
      label = label.charAt(1).toUpperCase() + label.substr(2);
    }
    if (formatting.tildify && !forceNoTildify) {
      if (this.userHome) {
        label = tildify(label, this.userHome.fsPath, this.os);
      }
    }
    if (formatting.authorityPrefix && resource.authority) {
      label = formatting.authorityPrefix + label;
    }
    return label.replace(sepRegexp, formatting.separator);
  }
  appendWorkspaceSuffix(label, uri) {
    const formatting = this.findFormatting(uri);
    const suffix = formatting && typeof formatting.workspaceSuffix === "string" ? formatting.workspaceSuffix : void 0;
    return suffix ? `${label} [${suffix}]` : label;
  }
};
LabelService = __decorate([
  __param(0, IWorkbenchEnvironmentService),
  __param(1, IWorkspaceContextService),
  __param(2, IPathService),
  __param(3, IRemoteAgentService),
  __param(4, IStorageService),
  __param(5, ILifecycleService)
], LabelService);

// node_modules/vscode/service-override/configuration.js
init_uuid();

// node_modules/vscode/vscode/src/vs/workbench/services/workspaces/browser/workspacesService.js
init_tslib_es6();
init_event();
init_log();
init_lifecycle();
init_files();
init_resources();
init_buffer();
init_network();
var BrowserWorkspacesService_1;
var _a;
var BrowserWorkspacesService = (_a = class extends Disposable {
  constructor(storageService, contextService, logService, fileService, environmentService, uriIdentityService) {
    super();
    this.storageService = storageService;
    this.contextService = contextService;
    this.logService = logService;
    this.fileService = fileService;
    this.environmentService = environmentService;
    this.uriIdentityService = uriIdentityService;
    this._onRecentlyOpenedChange = this._register(new Emitter());
    this.onDidChangeRecentlyOpened = this._onRecentlyOpenedChange.event;
    this.addWorkspaceToRecentlyOpened();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.storageService.onDidChangeValue(-1, BrowserWorkspacesService_1.RECENTLY_OPENED_KEY, this._register(new DisposableStore()))(() => this._onRecentlyOpenedChange.fire()));
    this._register(this.contextService.onDidChangeWorkspaceFolders((e) => this.onDidChangeWorkspaceFolders(e)));
  }
  onDidChangeWorkspaceFolders(e) {
    if (!isTemporaryWorkspace(this.contextService.getWorkspace())) {
      return;
    }
    for (const folder of e.added) {
      this.addRecentlyOpened([{ folderUri: folder.uri }]);
    }
  }
  addWorkspaceToRecentlyOpened() {
    const workspace = this.contextService.getWorkspace();
    const remoteAuthority = this.environmentService.remoteAuthority;
    switch (this.contextService.getWorkbenchState()) {
      case 2:
        this.addRecentlyOpened([{ folderUri: workspace.folders[0].uri, remoteAuthority }]);
        break;
      case 3:
        this.addRecentlyOpened([{ workspace: { id: workspace.id, configPath: workspace.configuration }, remoteAuthority }]);
        break;
    }
  }
  async getRecentlyOpened() {
    const recentlyOpenedRaw = this.storageService.get(BrowserWorkspacesService_1.RECENTLY_OPENED_KEY, -1);
    if (recentlyOpenedRaw) {
      const recentlyOpened = restoreRecentlyOpened(JSON.parse(recentlyOpenedRaw), this.logService);
      recentlyOpened.workspaces = recentlyOpened.workspaces.filter((recent) => {
        if (isRecentFolder(recent) && recent.folderUri.scheme === Schemas.file && !isTemporaryWorkspace(this.contextService.getWorkspace())) {
          return false;
        }
        if (isRecentWorkspace(recent) && isTemporaryWorkspace(recent.workspace.configPath)) {
          return false;
        }
        return true;
      });
      return recentlyOpened;
    }
    return { workspaces: [], files: [] };
  }
  async addRecentlyOpened(recents) {
    const recentlyOpened = await this.getRecentlyOpened();
    for (const recent of recents) {
      if (isRecentFile(recent)) {
        this.doRemoveRecentlyOpened(recentlyOpened, [recent.fileUri]);
        recentlyOpened.files.unshift(recent);
      } else if (isRecentFolder(recent)) {
        this.doRemoveRecentlyOpened(recentlyOpened, [recent.folderUri]);
        recentlyOpened.workspaces.unshift(recent);
      } else {
        this.doRemoveRecentlyOpened(recentlyOpened, [recent.workspace.configPath]);
        recentlyOpened.workspaces.unshift(recent);
      }
    }
    return this.saveRecentlyOpened(recentlyOpened);
  }
  async removeRecentlyOpened(paths) {
    const recentlyOpened = await this.getRecentlyOpened();
    this.doRemoveRecentlyOpened(recentlyOpened, paths);
    return this.saveRecentlyOpened(recentlyOpened);
  }
  doRemoveRecentlyOpened(recentlyOpened, paths) {
    recentlyOpened.files = recentlyOpened.files.filter((file) => {
      return !paths.some((path) => path.toString() === file.fileUri.toString());
    });
    recentlyOpened.workspaces = recentlyOpened.workspaces.filter((workspace) => {
      return !paths.some((path) => path.toString() === (isRecentFolder(workspace) ? workspace.folderUri.toString() : workspace.workspace.configPath.toString()));
    });
  }
  async saveRecentlyOpened(data) {
    return this.storageService.store(BrowserWorkspacesService_1.RECENTLY_OPENED_KEY, JSON.stringify(toStoreData(data)), -1, 0);
  }
  async clearRecentlyOpened() {
    this.storageService.remove(BrowserWorkspacesService_1.RECENTLY_OPENED_KEY, -1);
  }
  async enterWorkspace(workspaceUri) {
    return { workspace: await this.getWorkspaceIdentifier(workspaceUri) };
  }
  async createUntitledWorkspace(folders, remoteAuthority) {
    const randomId = (Date.now() + Math.round(Math.random() * 1e3)).toString();
    const newUntitledWorkspacePath = joinPath(this.environmentService.untitledWorkspacesHome, `Untitled-${randomId}.${WORKSPACE_EXTENSION}`);
    const storedWorkspaceFolder = [];
    if (folders) {
      for (const folder of folders) {
        storedWorkspaceFolder.push(getStoredWorkspaceFolder(folder.uri, true, folder.name, this.environmentService.untitledWorkspacesHome, this.uriIdentityService.extUri));
      }
    }
    const storedWorkspace = { folders: storedWorkspaceFolder, remoteAuthority };
    await this.fileService.writeFile(newUntitledWorkspacePath, VSBuffer.fromString(JSON.stringify(storedWorkspace, null, "	")));
    return this.getWorkspaceIdentifier(newUntitledWorkspacePath);
  }
  async deleteUntitledWorkspace(workspace) {
    try {
      await this.fileService.del(workspace.configPath);
    } catch (error) {
      if (error.fileOperationResult !== 1) {
        throw error;
      }
    }
  }
  async getWorkspaceIdentifier(workspaceUri) {
    return getWorkspaceIdentifier(workspaceUri);
  }
  async getDirtyWorkspaces() {
    return [];
  }
}, BrowserWorkspacesService_1 = _a, _a.RECENTLY_OPENED_KEY = "recently.opened", _a);
BrowserWorkspacesService = BrowserWorkspacesService_1 = __decorate([
  __param(0, IStorageService),
  __param(1, IWorkspaceContextService),
  __param(2, ILogService),
  __param(3, IFileService),
  __param(4, IWorkbenchEnvironmentService),
  __param(5, IUriIdentityService)
], BrowserWorkspacesService);

// node_modules/vscode/vscode/src/vs/workbench/services/workspaces/browser/abstractWorkspaceEditingService.js
init_tslib_es6();
init_nls();
init_configurationRegistry();
init_platform2();
init_commands();
init_arrays();
init_resources();
init_files();
init_network();
var AbstractWorkspaceEditingService = class AbstractWorkspaceEditingService2 {
  constructor(jsonEditingService, contextService, configurationService, notificationService, commandService, fileService, textFileService, workspacesService, environmentService, fileDialogService, dialogService, hostService, uriIdentityService, workspaceTrustManagementService, userDataProfilesService, userDataProfileService) {
    this.jsonEditingService = jsonEditingService;
    this.contextService = contextService;
    this.configurationService = configurationService;
    this.notificationService = notificationService;
    this.commandService = commandService;
    this.fileService = fileService;
    this.textFileService = textFileService;
    this.workspacesService = workspacesService;
    this.environmentService = environmentService;
    this.fileDialogService = fileDialogService;
    this.dialogService = dialogService;
    this.hostService = hostService;
    this.uriIdentityService = uriIdentityService;
    this.workspaceTrustManagementService = workspaceTrustManagementService;
    this.userDataProfilesService = userDataProfilesService;
    this.userDataProfileService = userDataProfileService;
  }
  async pickNewWorkspacePath() {
    const availableFileSystems = [Schemas.file];
    if (this.environmentService.remoteAuthority) {
      availableFileSystems.unshift(Schemas.vscodeRemote);
    }
    let workspacePath = await this.fileDialogService.showSaveDialog({
      saveLabel: mnemonicButtonLabel(localize("save", "Save")),
      title: localize("saveWorkspace", "Save Workspace"),
      filters: WORKSPACE_FILTER,
      defaultUri: joinPath(await this.fileDialogService.defaultWorkspacePath(), this.getNewWorkspaceName()),
      availableFileSystems
    });
    if (!workspacePath) {
      return;
    }
    if (!hasWorkspaceFileExtension(workspacePath)) {
      workspacePath = workspacePath.with({ path: `${workspacePath.path}.${WORKSPACE_EXTENSION}` });
    }
    return workspacePath;
  }
  getNewWorkspaceName() {
    var _a2;
    const configPathURI = (_a2 = this.getCurrentWorkspaceIdentifier()) == null ? void 0 : _a2.configPath;
    if (configPathURI && isSavedWorkspace(configPathURI, this.environmentService)) {
      return basename(configPathURI);
    }
    const folder = firstOrDefault(this.contextService.getWorkspace().folders);
    if (folder) {
      return `${basename(folder.uri)}.${WORKSPACE_EXTENSION}`;
    }
    return `workspace.${WORKSPACE_EXTENSION}`;
  }
  async updateFolders(index, deleteCount, foldersToAddCandidates, donotNotifyError) {
    const folders = this.contextService.getWorkspace().folders;
    let foldersToDelete = [];
    if (typeof deleteCount === "number") {
      foldersToDelete = folders.slice(index, index + deleteCount).map((folder) => folder.uri);
    }
    let foldersToAdd = [];
    if (Array.isArray(foldersToAddCandidates)) {
      foldersToAdd = foldersToAddCandidates.map(
        (folderToAdd) => ({ uri: removeTrailingPathSeparator(folderToAdd.uri), name: folderToAdd.name })
      );
    }
    const wantsToDelete = foldersToDelete.length > 0;
    const wantsToAdd = foldersToAdd.length > 0;
    if (!wantsToAdd && !wantsToDelete) {
      return;
    }
    if (wantsToAdd && !wantsToDelete) {
      return this.doAddFolders(foldersToAdd, index, donotNotifyError);
    }
    if (wantsToDelete && !wantsToAdd) {
      return this.removeFolders(foldersToDelete);
    } else {
      if (this.includesSingleFolderWorkspace(foldersToDelete)) {
        return this.createAndEnterWorkspace(foldersToAdd);
      }
      if (this.contextService.getWorkbenchState() !== 3) {
        return this.doAddFolders(foldersToAdd, index, donotNotifyError);
      }
      return this.doUpdateFolders(foldersToAdd, foldersToDelete, index, donotNotifyError);
    }
  }
  async doUpdateFolders(foldersToAdd, foldersToDelete, index, donotNotifyError = false) {
    try {
      await this.contextService.updateFolders(foldersToAdd, foldersToDelete, index);
    } catch (error) {
      if (donotNotifyError) {
        throw error;
      }
      this.handleWorkspaceConfigurationEditingError(error);
    }
  }
  addFolders(foldersToAddCandidates, donotNotifyError = false) {
    const foldersToAdd = foldersToAddCandidates.map(
      (folderToAdd) => ({ uri: removeTrailingPathSeparator(folderToAdd.uri), name: folderToAdd.name })
    );
    return this.doAddFolders(foldersToAdd, void 0, donotNotifyError);
  }
  async doAddFolders(foldersToAdd, index, donotNotifyError = false) {
    const state = this.contextService.getWorkbenchState();
    if (state !== 3) {
      let newWorkspaceFolders = this.contextService.getWorkspace().folders.map((folder) => ({ uri: folder.uri }));
      newWorkspaceFolders.splice(typeof index === "number" ? index : newWorkspaceFolders.length, 0, ...foldersToAdd);
      newWorkspaceFolders = distinct(newWorkspaceFolders, (folder) => this.uriIdentityService.extUri.getComparisonKey(folder.uri));
      if (state === 1 && newWorkspaceFolders.length === 0 || state === 2 && newWorkspaceFolders.length === 1) {
        return;
      }
      return this.createAndEnterWorkspace(newWorkspaceFolders);
    }
    try {
      await this.contextService.addFolders(foldersToAdd, index);
    } catch (error) {
      if (donotNotifyError) {
        throw error;
      }
      this.handleWorkspaceConfigurationEditingError(error);
    }
  }
  async removeFolders(foldersToRemove, donotNotifyError = false) {
    if (this.includesSingleFolderWorkspace(foldersToRemove)) {
      return this.createAndEnterWorkspace([]);
    }
    try {
      await this.contextService.removeFolders(foldersToRemove);
    } catch (error) {
      if (donotNotifyError) {
        throw error;
      }
      this.handleWorkspaceConfigurationEditingError(error);
    }
  }
  includesSingleFolderWorkspace(folders) {
    if (this.contextService.getWorkbenchState() === 2) {
      const workspaceFolder = this.contextService.getWorkspace().folders[0];
      return folders.some(
        (folder) => this.uriIdentityService.extUri.isEqual(folder, workspaceFolder.uri)
      );
    }
    return false;
  }
  async createAndEnterWorkspace(folders, path) {
    if (path && !await this.isValidTargetWorkspacePath(path)) {
      return;
    }
    const remoteAuthority = this.environmentService.remoteAuthority;
    const untitledWorkspace = await this.workspacesService.createUntitledWorkspace(folders, remoteAuthority);
    if (path) {
      try {
        await this.saveWorkspaceAs(untitledWorkspace, path);
      } finally {
        await this.workspacesService.deleteUntitledWorkspace(untitledWorkspace);
      }
    } else {
      path = untitledWorkspace.configPath;
      if (!this.userDataProfileService.currentProfile.isDefault) {
        await this.userDataProfilesService.setProfileForWorkspace(untitledWorkspace, this.userDataProfileService.currentProfile);
      }
    }
    return this.enterWorkspace(path);
  }
  async saveAndEnterWorkspace(workspaceUri) {
    const workspaceIdentifier = this.getCurrentWorkspaceIdentifier();
    if (!workspaceIdentifier) {
      return;
    }
    if (isEqual(workspaceIdentifier.configPath, workspaceUri)) {
      return this.saveWorkspace(workspaceIdentifier);
    }
    if (!await this.isValidTargetWorkspacePath(workspaceUri)) {
      return;
    }
    await this.saveWorkspaceAs(workspaceIdentifier, workspaceUri);
    return this.enterWorkspace(workspaceUri);
  }
  async isValidTargetWorkspacePath(workspaceUri) {
    return true;
  }
  async saveWorkspaceAs(workspace, targetConfigPathURI) {
    const configPathURI = workspace.configPath;
    const isNotUntitledWorkspace = !isUntitledWorkspace(targetConfigPathURI, this.environmentService);
    if (isNotUntitledWorkspace && !this.userDataProfileService.currentProfile.isDefault) {
      const newWorkspace = await this.workspacesService.getWorkspaceIdentifier(targetConfigPathURI);
      await this.userDataProfilesService.setProfileForWorkspace(newWorkspace, this.userDataProfileService.currentProfile);
    }
    if (this.uriIdentityService.extUri.isEqual(configPathURI, targetConfigPathURI)) {
      return;
    }
    const isFromUntitledWorkspace = isUntitledWorkspace(configPathURI, this.environmentService);
    const raw = await this.fileService.readFile(configPathURI);
    const newRawWorkspaceContents = rewriteWorkspaceFileForNewLocation(raw.value.toString(), configPathURI, isFromUntitledWorkspace, targetConfigPathURI, this.uriIdentityService.extUri);
    await this.textFileService.create([{ resource: targetConfigPathURI, value: newRawWorkspaceContents, options: { overwrite: true } }]);
    await this.trustWorkspaceConfiguration(targetConfigPathURI);
  }
  async saveWorkspace(workspace) {
    const configPathURI = workspace.configPath;
    const existingModel = this.textFileService.files.get(configPathURI);
    if (existingModel) {
      await existingModel.save({ force: true, reason: 1 });
      return;
    }
    const workspaceFileExists = await this.fileService.exists(configPathURI);
    if (workspaceFileExists) {
      return;
    }
    const newWorkspace = { folders: [] };
    const newRawWorkspaceContents = rewriteWorkspaceFileForNewLocation(JSON.stringify(newWorkspace, null, "	"), configPathURI, false, configPathURI, this.uriIdentityService.extUri);
    await this.textFileService.create([{ resource: configPathURI, value: newRawWorkspaceContents }]);
  }
  handleWorkspaceConfigurationEditingError(error) {
    switch (error.code) {
      case 0:
        this.onInvalidWorkspaceConfigurationFileError();
        break;
      default:
        this.notificationService.error(error.message);
    }
  }
  onInvalidWorkspaceConfigurationFileError() {
    const message = localize(
      "errorInvalidTaskConfiguration",
      "Unable to write into workspace configuration file. Please open the file to correct errors/warnings in it and try again."
    );
    this.askToOpenWorkspaceConfigurationFile(message);
  }
  askToOpenWorkspaceConfigurationFile(message) {
    this.notificationService.prompt(Severity.Error, message, [{
      label: localize("openWorkspaceConfigurationFile", "Open Workspace Configuration"),
      run: () => this.commandService.executeCommand("workbench.action.openWorkspaceConfigFile")
    }]);
  }
  async doEnterWorkspace(workspaceUri) {
    if (!!this.environmentService.extensionTestsLocationURI) {
      throw new Error("Entering a new workspace is not possible in tests.");
    }
    const workspace = await this.workspacesService.getWorkspaceIdentifier(workspaceUri);
    if (this.contextService.getWorkbenchState() === 2) {
      await this.migrateWorkspaceSettings(workspace);
    }
    await this.configurationService.initialize(workspace);
    return this.workspacesService.enterWorkspace(workspaceUri);
  }
  migrateWorkspaceSettings(toWorkspace) {
    return this.doCopyWorkspaceSettings(toWorkspace, (setting) => setting.scope === 3);
  }
  copyWorkspaceSettings(toWorkspace) {
    return this.doCopyWorkspaceSettings(toWorkspace);
  }
  doCopyWorkspaceSettings(toWorkspace, filter) {
    const configurationProperties = Registry.as(Extensions3.Configuration).getConfigurationProperties();
    const targetWorkspaceConfiguration = {};
    for (const key of this.configurationService.keys().workspace) {
      if (configurationProperties[key]) {
        if (filter && !filter(configurationProperties[key])) {
          continue;
        }
        targetWorkspaceConfiguration[key] = this.configurationService.inspect(key).workspaceValue;
      }
    }
    return this.jsonEditingService.write(toWorkspace.configPath, [{ path: ["settings"], value: targetWorkspaceConfiguration }], true);
  }
  async trustWorkspaceConfiguration(configPathURI) {
    if (this.contextService.getWorkbenchState() !== 1 && this.workspaceTrustManagementService.isWorkspaceTrusted()) {
      await this.workspaceTrustManagementService.setUrisTrust([configPathURI], true);
    }
  }
  getCurrentWorkspaceIdentifier() {
    const identifier = toWorkspaceIdentifier(this.contextService.getWorkspace());
    if (isWorkspaceIdentifier(identifier)) {
      return identifier;
    }
    return void 0;
  }
};
AbstractWorkspaceEditingService = __decorate([
  __param(0, IJSONEditingService),
  __param(1, IWorkspaceContextService),
  __param(2, IWorkbenchConfigurationService),
  __param(3, INotificationService),
  __param(4, ICommandService),
  __param(5, IFileService),
  __param(6, ITextFileService),
  __param(7, IWorkspacesService),
  __param(8, IWorkbenchEnvironmentService),
  __param(9, IFileDialogService),
  __param(10, IDialogService),
  __param(11, IHostService),
  __param(12, IUriIdentityService),
  __param(13, IWorkspaceTrustManagementService),
  __param(14, IUserDataProfilesService),
  __param(15, IUserDataProfileService)
], AbstractWorkspaceEditingService);

// node_modules/vscode/service-override/configuration.js
init_uri();

// node_modules/vscode/vscode/src/vs/workbench/api/common/configurationExtensionPoint.js
init_nls();
init_objects();
init_platform2();
init_configurationRegistry();
init_jsonContributionRegistry();
init_types();
init_extensions();
var jsonRegistry = Registry.as(Extensions.JSONContribution);
var configurationRegistry2 = Registry.as(Extensions3.Configuration);
var configurationEntrySchema = {
  type: "object",
  defaultSnippets: [{ body: { title: "", properties: {} } }],
  properties: {
    title: {
      description: localize(
        "vscode.extension.contributes.configuration.title",
        "A title for the current category of settings. This label will be rendered in the Settings editor as a subheading. If the title is the same as the extension display name, then the category will be grouped under the main extension heading."
      ),
      type: "string"
    },
    order: {
      description: localize(
        "vscode.extension.contributes.configuration.order",
        "When specified, gives the order of this category of settings relative to other categories."
      ),
      type: "integer"
    },
    properties: {
      description: localize(
        "vscode.extension.contributes.configuration.properties",
        "Description of the configuration properties."
      ),
      type: "object",
      propertyNames: {
        pattern: "\\S+",
        patternErrorMessage: localize(
          "vscode.extension.contributes.configuration.property.empty",
          "Property should not be empty."
        )
      },
      additionalProperties: {
        anyOf: [
          {
            title: localize(
              "vscode.extension.contributes.configuration.properties.schema",
              "Schema of the configuration property."
            ),
            $ref: "http://json-schema.org/draft-07/schema#"
          },
          {
            type: "object",
            properties: {
              scope: {
                type: "string",
                enum: ["application", "machine", "window", "resource", "language-overridable", "machine-overridable"],
                default: "window",
                enumDescriptions: [
                  localize(
                    "scope.application.description",
                    "Configuration that can be configured only in the user settings."
                  ),
                  localize(
                    "scope.machine.description",
                    "Configuration that can be configured only in the user settings or only in the remote settings."
                  ),
                  localize(
                    "scope.window.description",
                    "Configuration that can be configured in the user, remote or workspace settings."
                  ),
                  localize(
                    "scope.resource.description",
                    "Configuration that can be configured in the user, remote, workspace or folder settings."
                  ),
                  localize(
                    "scope.language-overridable.description",
                    "Resource configuration that can be configured in language specific settings."
                  ),
                  localize(
                    "scope.machine-overridable.description",
                    "Machine configuration that can be configured also in workspace or folder settings."
                  )
                ],
                markdownDescription: localize(
                  "scope.description",
                  "Scope in which the configuration is applicable. Available scopes are `application`, `machine`, `window`, `resource`, and `machine-overridable`."
                )
              },
              enumDescriptions: {
                type: "array",
                items: {
                  type: "string"
                },
                description: localize("scope.enumDescriptions", "Descriptions for enum values")
              },
              markdownEnumDescriptions: {
                type: "array",
                items: {
                  type: "string"
                },
                description: localize(
                  "scope.markdownEnumDescriptions",
                  "Descriptions for enum values in the markdown format."
                )
              },
              enumItemLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                markdownDescription: localize(
                  "scope.enumItemLabels",
                  "Labels for enum values to be displayed in the Settings editor. When specified, the {0} values still show after the labels, but less prominently.",
                  "`enum`"
                )
              },
              markdownDescription: {
                type: "string",
                description: localize("scope.markdownDescription", "The description in the markdown format.")
              },
              deprecationMessage: {
                type: "string",
                description: localize(
                  "scope.deprecationMessage",
                  "If set, the property is marked as deprecated and the given message is shown as an explanation."
                )
              },
              markdownDeprecationMessage: {
                type: "string",
                description: localize(
                  "scope.markdownDeprecationMessage",
                  "If set, the property is marked as deprecated and the given message is shown as an explanation in the markdown format."
                )
              },
              editPresentation: {
                type: "string",
                enum: ["singlelineText", "multilineText"],
                enumDescriptions: [
                  localize(
                    "scope.singlelineText.description",
                    "The value will be shown in an inputbox."
                  ),
                  localize(
                    "scope.multilineText.description",
                    "The value will be shown in a textarea."
                  )
                ],
                default: "singlelineText",
                description: localize(
                  "scope.editPresentation",
                  "When specified, controls the presentation format of the string setting."
                )
              },
              order: {
                type: "integer",
                description: localize(
                  "scope.order",
                  "When specified, gives the order of this setting relative to other settings within the same category. Settings with an order property will be placed before settings without this property set."
                )
              },
              ignoreSync: {
                type: "boolean",
                description: localize(
                  "scope.ignoreSync",
                  "When enabled, Settings Sync will not sync the user value of this configuration by default."
                )
              }
            }
          }
        ]
      }
    }
  }
};
var _configDelta;
var defaultConfigurationExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "configurationDefaults",
  jsonSchema: {
    $ref: configurationDefaultsSchemaId
  }
});
defaultConfigurationExtPoint.setHandler((extensions, { added, removed }) => {
  if (_configDelta) {
    configurationRegistry2.deltaConfiguration(_configDelta);
  }
  const configNow = _configDelta = {};
  queueMicrotask(() => {
    if (_configDelta === configNow) {
      configurationRegistry2.deltaConfiguration(_configDelta);
      _configDelta = void 0;
    }
  });
  if (removed.length) {
    const removedDefaultConfigurations = removed.map(
      (extension) => ({ overrides: deepClone(extension.value), source: { id: extension.description.identifier.value, displayName: extension.description.displayName } })
    );
    _configDelta.removedDefaults = removedDefaultConfigurations;
  }
  if (added.length) {
    const registeredProperties = configurationRegistry2.getConfigurationProperties();
    const allowedScopes = [6, 3, 4, 5];
    const addedDefaultConfigurations = added.map((extension) => {
      const overrides = deepClone(extension.value);
      for (const key of Object.keys(overrides)) {
        if (!OVERRIDE_PROPERTY_REGEX.test(key)) {
          const registeredPropertyScheme = registeredProperties[key];
          if ((registeredPropertyScheme == null ? void 0 : registeredPropertyScheme.scope) && !allowedScopes.includes(registeredPropertyScheme.scope)) {
            extension.collector.warn(localize(
              "config.property.defaultConfiguration.warning",
              "Cannot register configuration defaults for '{0}'. Only defaults for machine-overridable, window, resource and language overridable scoped settings are supported.",
              key
            ));
            delete overrides[key];
          }
        }
      }
      return { overrides, source: { id: extension.description.identifier.value, displayName: extension.description.displayName } };
    });
    _configDelta.addedDefaults = addedDefaultConfigurations;
  }
});
var configurationExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "configuration",
  deps: [defaultConfigurationExtPoint],
  jsonSchema: {
    description: localize(
      "vscode.extension.contributes.configuration",
      "Contributes configuration settings."
    ),
    oneOf: [
      configurationEntrySchema,
      {
        type: "array",
        items: configurationEntrySchema
      }
    ]
  }
});
var extensionConfigurations = new ExtensionIdentifierMap();
configurationExtPoint.setHandler((extensions, { added, removed }) => {
  _configDelta ?? (_configDelta = {});
  if (removed.length) {
    const removedConfigurations = [];
    for (const extension of removed) {
      removedConfigurations.push(...extensionConfigurations.get(extension.description.identifier) || []);
      extensionConfigurations.delete(extension.description.identifier);
    }
    _configDelta.removedConfigurations = removedConfigurations;
  }
  const seenProperties = /* @__PURE__ */ new Set();
  function handleConfiguration(node, extension) {
    var _a2, _b, _c;
    const configurations = [];
    const configuration = deepClone(node);
    if (configuration.title && typeof configuration.title !== "string") {
      extension.collector.error(localize("invalid.title", "'configuration.title' must be a string"));
    }
    validateProperties(configuration, extension);
    configuration.id = node.id || extension.description.identifier.value;
    configuration.extensionInfo = { id: extension.description.identifier.value, displayName: extension.description.displayName };
    configuration.restrictedProperties = ((_b = (_a2 = extension.description.capabilities) == null ? void 0 : _a2.untrustedWorkspaces) == null ? void 0 : _b.supported) === "limited" ? (_c = extension.description.capabilities) == null ? void 0 : _c.untrustedWorkspaces.restrictedConfigurations : void 0;
    configuration.title = configuration.title || extension.description.displayName || extension.description.identifier.value;
    configurations.push(configuration);
    return configurations;
  }
  function validateProperties(configuration, extension) {
    const properties = configuration.properties;
    if (properties) {
      if (typeof properties !== "object") {
        extension.collector.error(localize("invalid.properties", "'configuration.properties' must be an object"));
        configuration.properties = {};
      }
      for (const key in properties) {
        const propertyConfiguration = properties[key];
        const message = validateProperty(key, propertyConfiguration);
        if (message) {
          delete properties[key];
          extension.collector.warn(message);
          continue;
        }
        if (seenProperties.has(key)) {
          delete properties[key];
          extension.collector.warn(localize(
            "config.property.duplicate",
            "Cannot register '{0}'. This property is already registered.",
            key
          ));
          continue;
        }
        if (!isObject(propertyConfiguration)) {
          delete properties[key];
          extension.collector.error(localize(
            "invalid.property",
            "configuration.properties property '{0}' must be an object",
            key
          ));
          continue;
        }
        seenProperties.add(key);
        if (propertyConfiguration.scope) {
          if (propertyConfiguration.scope.toString() === "application") {
            propertyConfiguration.scope = 1;
          } else if (propertyConfiguration.scope.toString() === "machine") {
            propertyConfiguration.scope = 2;
          } else if (propertyConfiguration.scope.toString() === "resource") {
            propertyConfiguration.scope = 4;
          } else if (propertyConfiguration.scope.toString() === "machine-overridable") {
            propertyConfiguration.scope = 6;
          } else if (propertyConfiguration.scope.toString() === "language-overridable") {
            propertyConfiguration.scope = 5;
          } else {
            propertyConfiguration.scope = 3;
          }
        } else {
          propertyConfiguration.scope = 3;
        }
      }
    }
    const subNodes = configuration.allOf;
    if (subNodes) {
      extension.collector.error(localize(
        "invalid.allOf",
        "'configuration.allOf' is deprecated and should no longer be used. Instead, pass multiple configuration sections as an array to the 'configuration' contribution point."
      ));
      for (const node of subNodes) {
        validateProperties(node, extension);
      }
    }
  }
  if (added.length) {
    const addedConfigurations = [];
    for (const extension of added) {
      const configurations = [];
      const value = extension.value;
      if (Array.isArray(value)) {
        value.forEach((v) => configurations.push(...handleConfiguration(v, extension)));
      } else {
        configurations.push(...handleConfiguration(value, extension));
      }
      extensionConfigurations.set(extension.description.identifier, configurations);
      addedConfigurations.push(...configurations);
    }
    _configDelta.addedConfigurations = addedConfigurations;
  }
  configurationRegistry2.deltaConfiguration(_configDelta);
  _configDelta = void 0;
});
jsonRegistry.registerSchema("vscode://schemas/workspaceConfig", {
  allowComments: true,
  allowTrailingCommas: true,
  default: {
    folders: [
      {
        path: ""
      }
    ],
    settings: {}
  },
  required: ["folders"],
  properties: {
    "folders": {
      minItems: 0,
      uniqueItems: true,
      description: localize(
        "workspaceConfig.folders.description",
        "List of folders to be loaded in the workspace."
      ),
      items: {
        type: "object",
        defaultSnippets: [{ body: { path: "$1" } }],
        oneOf: [{
          properties: {
            path: {
              type: "string",
              description: localize(
                "workspaceConfig.path.description",
                "A file path. e.g. `/root/folderA` or `./folderA` for a relative path that will be resolved against the location of the workspace file."
              )
            },
            name: {
              type: "string",
              description: localize("workspaceConfig.name.description", "An optional name for the folder. ")
            }
          },
          required: ["path"]
        }, {
          properties: {
            uri: {
              type: "string",
              description: localize("workspaceConfig.uri.description", "URI of the folder")
            },
            name: {
              type: "string",
              description: localize("workspaceConfig.name.description", "An optional name for the folder. ")
            }
          },
          required: ["uri"]
        }]
      }
    },
    "settings": {
      type: "object",
      default: {},
      description: localize("workspaceConfig.settings.description", "Workspace settings"),
      $ref: workspaceSettingsSchemaId
    },
    "launch": {
      type: "object",
      default: { configurations: [], compounds: [] },
      description: localize("workspaceConfig.launch.description", "Workspace launch configurations"),
      $ref: launchSchemaId
    },
    "tasks": {
      type: "object",
      default: { version: "2.0.0", tasks: [] },
      description: localize("workspaceConfig.tasks.description", "Workspace task configurations"),
      $ref: tasksSchemaId
    },
    "extensions": {
      type: "object",
      default: {},
      description: localize("workspaceConfig.extensions.description", "Workspace extensions"),
      $ref: "vscode://schemas/extensions"
    },
    "remoteAuthority": {
      type: "string",
      doNotSuggest: true,
      description: localize(
        "workspaceConfig.remoteAuthority",
        "The remote server where the workspace is located."
      )
    },
    "transient": {
      type: "boolean",
      doNotSuggest: true,
      description: localize(
        "workspaceConfig.transient",
        "A transient workspace will disappear when restarting or reloading."
      )
    }
  },
  errorMessage: localize("unknownWorkspaceProperty", "Unknown workspace configuration property")
});

// node_modules/vscode/service-override/configuration.js
async function updateUserConfiguration(configurationJson) {
  const userDataProfilesService = StandaloneServices.get(IUserDataProfilesService);
  await StandaloneServices.get(IFileService).writeFile(userDataProfilesService.defaultProfile.settingsResource, VSBuffer.fromString(configurationJson));
}
async function getUserConfiguration() {
  const userDataProfilesService = StandaloneServices.get(IUserDataProfilesService);
  return (await StandaloneServices.get(IFileService).readFile(userDataProfilesService.defaultProfile.settingsResource)).value.toString();
}
function onUserConfigurationChange(callback) {
  const userDataProfilesService = StandaloneServices.get(IUserDataProfilesService);
  return StandaloneServices.get(IFileService).onDidFilesChange((e) => {
    if (e.affects(userDataProfilesService.defaultProfile.settingsResource)) {
      callback();
    }
  });
}
var configurationRegistry3 = Registry.as(Extensions3.Configuration);
var InjectedConfigurationService = class InjectedConfigurationService2 extends WorkspaceService {
  constructor(workbenchEnvironmentService, userDataProfileService, userDataProfilesService, fileService, remoteAgentService, uriIdentityService, logService, policyService) {
    const configurationCache = new ConfigurationCache([Schemas.file, Schemas.vscodeUserData, Schemas.tmp], workbenchEnvironmentService, fileService);
    super({ configurationCache }, workbenchEnvironmentService, userDataProfileService, userDataProfilesService, fileService, remoteAgentService, uriIdentityService, logService, policyService);
  }
};
InjectedConfigurationService = __decorate([
  __param(0, IWorkbenchEnvironmentService),
  __param(1, IUserDataProfileService),
  __param(2, IUserDataProfilesService),
  __param(3, IFileService),
  __param(4, IRemoteAgentService),
  __param(5, IUriIdentityService),
  __param(6, ILogService),
  __param(7, IPolicyService)
], InjectedConfigurationService);
var MonacoWorkspaceEditingService = class extends AbstractWorkspaceEditingService {
  constructor() {
    super(...arguments);
    this.enterWorkspace = unsupported;
  }
};
var _defaultWorkspace = URI.file("/workspace");
registerServiceInitializePreParticipant(async (accessor) => {
  const workspaceService = accessor.get(IWorkspaceContextService);
  workspaceService.acquireInstantiationService(accessor.get(IInstantiationService));
  if (URI.isUri(_defaultWorkspace)) {
    const configPath = _defaultWorkspace.with({ path: "/workspace.code-workspace" });
    try {
      const fileService = accessor.get(IFileService);
      await fileService.createFolder(_defaultWorkspace);
      await fileService.writeFile(configPath, VSBuffer.fromString(JSON.stringify({
        folders: [
          {
            path: _defaultWorkspace.path
          }
        ]
      })));
    } catch (err) {
    }
    await workspaceService.initialize({
      id: generateUuid(),
      configPath
    });
  } else {
    await workspaceService.initialize(_defaultWorkspace);
  }
});
var MemoizedInjectedConfigurationService = memoizedConstructor(InjectedConfigurationService);
function getServiceOverride2(defaultWorkspace) {
  _defaultWorkspace = defaultWorkspace;
  return {
    ...getServiceOverride(),
    [ILabelService.toString()]: new SyncDescriptor(LabelService, void 0, true),
    [IConfigurationService.toString()]: new SyncDescriptor(MemoizedInjectedConfigurationService, [], true),
    [IWorkspaceContextService.toString()]: new SyncDescriptor(MemoizedInjectedConfigurationService, [], true),
    [ITextResourceConfigurationService.toString()]: new SyncDescriptor(TextResourceConfigurationService, [], true),
    [IWorkspaceEditingService.toString()]: new SyncDescriptor(MonacoWorkspaceEditingService, [], true),
    [IWorkspacesService.toString()]: new SyncDescriptor(BrowserWorkspacesService, void 0, true)
  };
}
export {
  ConfigurationScope,
  configurationRegistry3 as configurationRegistry,
  getServiceOverride2 as default,
  getUserConfiguration,
  onUserConfigurationChange,
  updateUserConfiguration
};
//# sourceMappingURL=@codingame_monaco-vscode-configuration-service-override.js.map
