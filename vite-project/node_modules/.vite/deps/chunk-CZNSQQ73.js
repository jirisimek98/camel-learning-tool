import {
  registerAssets
} from "./chunk-KKMJ3VMB.js";
import {
  onRenderWorkbench
} from "./chunk-ZVOC25HY.js";
import {
  ACTIVE_OUTPUT_CHANNEL_CONTEXT,
  ALL_INTERFACES_ADDRESSES,
  AbstractTextEditor,
  AbstractTextResourceEditorInput,
  BaseTextEditorModel,
  BrowserWorkbenchEnvironmentService,
  CONTEXT_ACTIVE_LOG_OUTPUT,
  CONTEXT_IN_OUTPUT,
  CONTEXT_OUTPUT_SCROLL_LOCK,
  DiffEditorInput,
  DisposableTunnel,
  EDITOR_DRAG_AND_DROP_BACKGROUND,
  EditorInput,
  EditorModel,
  EditorPaneDescriptor,
  ExtensionKeyedWebviewOriginStore,
  ExtensionManifestPropertiesService,
  Extensions as Extensions3,
  Extensions2 as Extensions5,
  FakeAbstractTextEditor,
  FilterViewPane,
  IActivityService,
  IAiEmbeddingVectorService,
  IAiRelatedInformationService,
  IAuthenticationService,
  IBrowserWorkbenchEnvironmentService,
  ICanonicalUriService,
  IChatContributionService,
  IChatProviderService,
  IChatService,
  IChatSlashCommandService,
  IChatVariablesService,
  IChatWidgetService,
  ICommentService,
  IConfigurationResolverService,
  ICredentialsService,
  ICustomEditorService,
  IDecorationsService,
  IDialogService,
  IDownloadService,
  IEncryptionService,
  IEnvironmentVariableService,
  IExtensionHostDebugService,
  IExtensionManifestPropertiesService,
  IExtensionStatusBarItemService,
  IExtensionStorageService,
  IExtensionUrlHandler,
  IExtensionsWorkbenchService,
  IExternalUriOpenerService,
  IFileDialogService,
  IFilesConfigurationService,
  IHostService,
  IHoverService,
  IInlineChatService,
  IInteractiveDocumentService,
  ILanguagePackService,
  ILanguageStatusService,
  INotebookCellStatusBarService,
  INotebookEditorModelResolverService,
  INotebookEditorService,
  INotebookExecutionStateService,
  INotebookKernelService,
  INotebookRendererMessagingService,
  INotebookService,
  IOutlineService,
  IOutputService,
  IPaneCompositePartService,
  IPathService,
  IPreferencesService,
  IRemoteExplorerService,
  IRemoteExtensionsScannerService,
  IRemoteSocketFactoryService,
  IRequestService,
  ISCMService,
  ISCMViewService,
  ISearchService,
  ISecretStorageService,
  IShareService,
  ISignService,
  IStatusbarService,
  ITaskService,
  ITerminalEditorService,
  ITerminalGroupService,
  ITerminalInstanceService,
  ITerminalLinkProviderService,
  ITerminalProfileResolverService,
  ITerminalProfileService,
  ITerminalQuickFixService,
  ITerminalService,
  ITestProfileService,
  ITestResultService,
  ITestService,
  ITimelineService,
  ITimerService,
  ITunnelService,
  IURLService,
  IUntitledTextEditorService,
  IUserActivityService,
  IUserDataInitializationService,
  IViewDescriptorService,
  IViewsService,
  IWebviewService,
  IWebviewViewService,
  IWebviewWorkbenchService,
  IWorkbenchEnvironmentService,
  IWorkbenchExtensionEnablementService,
  IWorkbenchExtensionManagementService,
  IWorkbenchIssueService,
  IWorkbenchLayoutService,
  IWorkingCopyFileService,
  IWorkingCopyService,
  IWorkspaceEditingService,
  LOCALHOST_ADDRESSES,
  LOG_MIME,
  LOG_MODE_ID,
  LOG_SCHEME,
  LazilyResolvedWebviewEditorInput,
  LogContentProvider,
  Memento,
  NO_TYPE_ID,
  NoTreeViewError,
  NotebookExecutionType,
  NumberBadge,
  OUTPUT_MIME,
  OUTPUT_MODE_ID,
  OUTPUT_VIEW_ID,
  OutputChannelUpdateMode,
  PANEL_BORDER,
  PORT_AUTO_FORWARD_SETTING,
  PORT_AUTO_SOURCE_SETTING,
  PORT_AUTO_SOURCE_SETTING_OUTPUT,
  PickerQuickAccessProvider,
  ProvidedOnAutoForward,
  QueryGlobTester,
  RelatedInformationType as RelatedInformationType2,
  ResolvableTreeItem,
  ResourceLabels,
  SIDE_BAR_BACKGROUND,
  SideBySideEditorInput,
  SimpleNotebookProviderInfo,
  TAB_ACTIVE_BORDER,
  TerminalExitReason as TerminalExitReason2,
  TerminalLocation as TerminalLocation2,
  TerminalQuickFixType,
  TextResourceEditorInput,
  TriggerAction,
  TunnelPrivacyId,
  TunnelProtocol,
  UntitledTextEditorInput,
  VariableError,
  VariableKind,
  ViewAction,
  ViewPane,
  ViewPaneContainer,
  WebviewInput,
  applyTextEditorOptions,
  columnToEditorGroup,
  defaultExternalUriOpenerId,
  editorGroupToColumn,
  fromNow,
  getExcludes,
  hasSiblingFn,
  hasSiblingPromiseFn,
  isAllInterfaces,
  isLocalhost,
  pathIncludedInQuery,
  pieceToQuery,
  prepareQuery,
  resolvePatternsForProvider,
  resultIsMatch,
  scoreFuzzy2,
  terminalEditorId,
  toLocalISOString,
  unsupported,
  updateContributedOpeners,
  viewFilterSubmenu
} from "./chunk-AR3QIQFF.js";
import {
  BranchCoverage,
  Breakpoint,
  CallHierarchyIncomingCall,
  CallHierarchyItem,
  CallHierarchyOutgoingCall,
  CandidatePortSource,
  ChatMessage,
  ChatMessageRole,
  ChatVariableLevel,
  CodeAction,
  CodeActionKind,
  CodeActionTriggerKind,
  CodeLens,
  Color,
  ColorInformation,
  ColorPresentation,
  ColorTheme,
  ColorThemeKind,
  CommentMode as CommentMode2,
  CommentState,
  CommentThreadCollapsibleState as CommentThreadCollapsibleState2,
  CommentThreadState as CommentThreadState2,
  CompletionItem,
  CompletionItemKind,
  CompletionItemTag,
  CompletionList,
  CompletionTriggerKind,
  ConfigurationTarget,
  CoveredCount,
  CustomEditorTabInput,
  CustomExecution,
  DataBreakpoint,
  DataTransfer,
  DataTransferFile,
  DataTransferItem,
  DebugAdapterExecutable,
  DebugAdapterInlineImplementation,
  DebugAdapterNamedPipeServer,
  DebugAdapterServer,
  DebugConsoleMode,
  DecorationRangeBehavior,
  Diagnostic,
  DiagnosticRelatedInformation,
  DiagnosticSeverity,
  DiagnosticTag,
  Disposable as Disposable2,
  DocumentDropEdit,
  DocumentHighlight,
  DocumentHighlightKind,
  DocumentLink,
  DocumentPasteEdit,
  DocumentSymbol,
  EndOfLine,
  EnvironmentVariableMutatorType,
  EvaluatableExpression,
  ExtHostContext,
  ExtensionKind,
  ExtensionMode,
  ExtensionRuntime,
  ExternalUriOpenerPriority,
  FileChangeType,
  FileCoverage,
  FileDecoration,
  FileSystemError,
  FoldingRange,
  FoldingRangeKind as FoldingRangeKind2,
  FunctionBreakpoint,
  FunctionCoverage,
  Hover,
  InlayHint,
  InlayHintKind,
  InlayHintLabelPart,
  InlineCompletionTriggerKind as InlineCompletionTriggerKind2,
  InlineSuggestion,
  InlineSuggestionList,
  InlineValueContext,
  InlineValueEvaluatableExpression,
  InlineValueText,
  InlineValueVariableLookup,
  InputBoxValidationSeverity,
  InteractiveEditorResponseFeedbackKind,
  InteractiveSessionCopyKind,
  InteractiveSessionVoteDirection,
  InteractiveWindowInput,
  InternalDataTransferItem,
  InternalFileDataTransferItem,
  LanguageStatusSeverity,
  LinkedEditingRanges,
  Location,
  MainContext,
  ManagedResolvedAuthority,
  MarkdownString as MarkdownString2,
  NotebookCellData,
  NotebookCellExecutionState as NotebookCellExecutionState2,
  NotebookCellKind,
  NotebookCellOutput,
  NotebookCellOutputItem,
  NotebookCellStatusBarAlignment,
  NotebookCellStatusBarItem,
  NotebookCodeActionKind,
  NotebookControllerAffinity,
  NotebookControllerAffinity2,
  NotebookData,
  NotebookDiffEditorTabInput,
  NotebookEdit,
  NotebookEditorRevealType,
  NotebookEditorRevealType2,
  NotebookEditorTabInput,
  NotebookKernelSourceAction,
  NotebookRange,
  NotebookRendererScript,
  ParameterInformation,
  PortAttributes,
  PortAutoForwardAction,
  Position as Position2,
  ProcessExecution,
  ProgressLocation,
  ProxyIdentifier,
  QuickInputButtons,
  QuickPickItemKind,
  Range as Range2,
  RelatedInformationType,
  RelativePattern,
  RemoteAuthorityResolverError as RemoteAuthorityResolverError2,
  ResolvedAuthority,
  Selection,
  SelectionRange,
  SemanticTokens,
  SemanticTokensBuilder,
  SemanticTokensEdit,
  SemanticTokensEdits,
  SemanticTokensLegend,
  SerializableObjectWithBuffers,
  ShellExecution,
  ShellQuoting,
  SignatureHelp,
  SignatureHelpTriggerKind,
  SignatureInformation,
  SnippetString,
  SnippetTextEdit,
  SourceBreakpoint,
  SourceControlInputBoxValidationType,
  StackFrameFocus,
  StandardTokenType,
  StatementCoverage,
  StatusBarAlignment,
  SymbolInformation,
  SymbolKind,
  SymbolTag,
  Task,
  TaskGroup,
  TaskPanelKind,
  TaskRevealKind,
  TaskScope,
  TerminalEditorTabInput,
  TerminalExitReason,
  TerminalLink,
  TerminalLocation,
  TerminalOutputAnchor,
  TerminalProfile,
  TerminalQuickFixCommand,
  TerminalQuickFixOpener,
  TestMessage,
  TestResultState,
  TestRunProfileKind,
  TestRunRequest,
  TestTag,
  TextDiffTabInput,
  TextDocumentChangeReason,
  TextDocumentSaveReason,
  TextEdit,
  TextEditorLineNumbersStyle,
  TextEditorRevealType,
  TextEditorRevealType2,
  TextEditorSelectionChangeKind,
  TextMergeTabInput,
  TextSearchCompleteMessageType,
  TextTabInput,
  ThemeColor as ThemeColor2,
  ThemeIcon as ThemeIcon2,
  ThreadFocus,
  TimelineItem,
  TreeItem,
  TreeItemCheckboxState,
  TreeItemCollapsibleState,
  TypeHierarchyItem,
  UIKind,
  ViewBadge,
  ViewColumn,
  WebviewEditorTabInput,
  WorkspaceEdit,
  WorkspaceTrustState,
  asStatusBarItemIdentifier,
  createMessageOfType,
  getStringIdentifierForProxy,
  init_extHostTypes,
  init_extHost_protocol,
  init_extensionHostProtocol,
  init_proxyIdentifier,
  init_searchExtTypes,
  isMessageOfType,
  setBreakpointId
} from "./chunk-YDWP2D7X.js";
import {
  CellKind,
  CellUri,
  DebugConfigurationProviderTriggerKind,
  EditSessionIdentityMatch,
  IDebugService,
  IEditSessionIdentityService,
  IRemoteAuthorityResolverService,
  ManagedRemoteConnection,
  NOTEBOOK_EDITOR_ID,
  NotebookCellExecutionState,
  NotebookCellsChangeType,
  NotebookSetting,
  REPL_VIEW_ID,
  RemoteAuthorityResolverError,
  RemoteAuthorityResolverErrorCode,
  SelectionStateType,
  WebSocketRemoteConnection,
  compressOutputItemStreams,
  getRemoteAuthorityPrefix,
  init_debug,
  init_editSessions,
  init_notebookCommon,
  init_remoteAuthorityResolver,
  isTextStreamMime
} from "./chunk-E2764U5K.js";
import {
  IOutlineModelService,
  decodeSemanticTokensDto,
  encodeSemanticTokensDto,
  init_outlineModel
} from "./chunk-KYTAC6SG.js";
import {
  TreeViewsDnDService,
  UriList,
  VSDataTransfer,
  createStringDataTransferItem
} from "./chunk-MEAKYGIF.js";
import {
  ACTIVE_GROUP,
  ActivationTimes,
  DEFAULT_EDITOR_ASSOCIATION,
  EditorCloseContext,
  EditorExtensions,
  EditorResourceAccessor,
  ExtensionHostExtensions,
  ExtensionMessageCollector,
  ExtensionPointContribution,
  Extensions,
  ExtensionsRegistry,
  FocusedViewContext,
  IEditorGroupsService,
  IEditorService,
  IExtensionService,
  ILifecycleService,
  IProductService,
  IQuickDiffService,
  IRemoteAgentService,
  ITextFileService,
  IUserDataProfileImportExportService,
  ImplicitActivationEvents,
  MenuPreventer,
  MissingExtensionDependency,
  ResourceContextKey,
  SIDE_GROUP,
  SaveSourceRegistry,
  SideBySideEditor,
  TabCompletionController,
  allApiProposals,
  areSameExtensions,
  checkProposedApiEnabled,
  isProposedApiEnabled,
  isResourceMergeEditorInput,
  isTextEditorViewState,
  n,
  nullExtensionDescription,
  preferredSideBySideGroupDirection,
  toExtension,
  toExtensionDescription
} from "./chunk-ETI4KOTI.js";
import {
  TelemetryTrustedValue,
  __decorate,
  __param,
  cleanData,
  cleanRemoteAuthority,
  extensionTelemetryLogChannelId,
  init_telemetryUtils,
  init_tslib_es6,
  isLoggingOnly,
  supportsTelemetry
} from "./chunk-GJDIUAXO.js";
import {
  StandaloneCodeEditor,
  ZoneWidget,
  peekViewBorder
} from "./chunk-XHQJEB2N.js";
import {
  $,
  Action,
  Action2,
  ActionBar,
  ActionRunner,
  ActionViewItem,
  Barrier,
  Button,
  Categories,
  CodeEditorWidget,
  Color as Color2,
  ColorScheme,
  Command,
  CommandsRegistry,
  CommentMode,
  CommentThreadCollapsibleState,
  CommentThreadState,
  Configuration,
  ConfigurationChangeEvent,
  ContextMenuController,
  Counter,
  DefaultQuickAccessFilterValue,
  DeferredPromise,
  Delayer,
  Dimension,
  DomEmitter,
  DropdownMenuActionViewItem,
  EditOperation,
  EditorActivation,
  EditorContextKeys,
  EditorExtensionsRegistry,
  EditorResolution,
  EditorState,
  EditorType,
  EmbeddedCodeEditorWidget,
  EventType,
  Extensions2,
  Extensions3 as Extensions4,
  Extensions6,
  FoldingRangeKind,
  GLOBSTAR,
  GLOB_SPLIT,
  IAccessibilityService,
  IBulkEditService,
  IClipboardService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextMenuService,
  IDialogService as IDialogService2,
  IEditorWorkerService,
  IEnvironmentService,
  IKeybindingService,
  ILabelService,
  ILanguageConfigurationService,
  ILanguageFeaturesService,
  ILanguageService,
  ILayoutService,
  IListService,
  IMarkerService,
  IMenuService,
  IModelService,
  INotificationService,
  IOpenerService,
  IProgressService,
  IQuickInputService,
  IStorageService,
  ITextModelService,
  ITextResourceConfigurationService,
  IThemeService,
  IUndoRedoService,
  IUriIdentityService,
  IUserDataProfilesService,
  IWorkspaceContextService,
  IWorkspaceTrustManagementService,
  IWorkspaceTrustRequestService,
  IdGenerator,
  InlineCompletionTriggerKind,
  InstantiationService,
  IntervalTimer,
  ItemActivation,
  KeyChord,
  KeybindingsRegistry,
  LanguageFeatureRegistry,
  LengthObj,
  LinkComputer,
  LogService,
  MOUSE_CURSOR_TEXT_CSS_CLASS_NAME,
  MarkdownRenderer,
  MarkerSeverity,
  MenuEntryActionViewItem,
  MenuId,
  MenuItemAction,
  MenuRegistry,
  MirrorTextModel,
  ModelDecorationOptions,
  ModesRegistry,
  OVERRIDE_PROPERTY_REGEX,
  PLAINTEXT_LANGUAGE_ID,
  Position,
  Progress,
  Promises,
  QuickInputService,
  Range,
  Registry,
  ResourceEdit,
  ResourceFileEdit,
  ResourceQueue,
  ResourceTextEdit,
  RunOnceScheduler,
  Scrollable,
  Selection as Selection2,
  Separator,
  SequencerByKey,
  ServiceCollection,
  Severity,
  SmoothScrollableElement,
  SnippetController2,
  SnippetParser,
  StandaloneQuickInputService,
  StandaloneServices,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StateMachine,
  SubmenuEntryActionViewItem,
  SubmenuItemAction,
  SuggestController,
  SymbolKinds,
  SyncDescriptor,
  TextModel,
  ThrottledDelayer,
  ToolBar,
  UndoRedoGroup,
  WorkbenchListFocusContextKey,
  WorkbenchListScrollAtBottomContextKey,
  WorkbenchListScrollAtTopContextKey,
  WorkbenchObjectTree,
  Workspace,
  WorkspaceFolder,
  addDisposableListener,
  append,
  asCSSUrl,
  asPromise,
  assertFn,
  assertNever,
  autorun,
  autorunHandleChanges,
  checkAdjacentItems,
  comparePaths,
  contrastBorder,
  createActionViewItem,
  createCancelablePromise,
  createStyleSheet,
  darken,
  debounce,
  defaultButtonStyles,
  derived,
  diffMaps,
  diffSets,
  disabledForeground,
  disposableTimeout,
  editorBackground,
  editorFindMatch,
  editorFindMatchHighlight,
  editorForeground,
  editorHoverHighlight,
  editorSelectionBackground,
  focusBorder,
  getAriaLabelForSymbol,
  getClientArea,
  getCodeEditor,
  getContentHeight,
  getContentWidth,
  getDomNodePagePosition,
  getIconRegistry,
  getMarks,
  getScopes,
  getSingletonServiceDescriptors,
  groupBy as groupBy2,
  init_actions,
  init_actions2,
  init_aria,
  init_assert,
  init_async,
  init_browser,
  init_codeEditorService,
  init_color,
  init_colorRegistry,
  init_commands,
  init_configuration,
  init_configurationRegistry,
  init_descriptors,
  init_dom,
  init_editOperation,
  init_editorBrowser,
  init_editorColorRegistry,
  init_editorCommon,
  init_editorContextKeys,
  init_editorExtensions,
  init_editorState,
  init_editorWorker,
  init_environment,
  init_extensions as init_extensions2,
  init_keyCodes,
  init_keybindingsRegistry,
  init_keyboardEvent,
  init_language,
  init_languageConfigurationRegistry,
  init_languageFeatures,
  init_languages,
  init_length,
  init_model as init_model2,
  init_modesRegistry,
  init_mouseEvent,
  init_numbers,
  init_opener,
  init_platform as init_platform2,
  init_position,
  init_progress,
  init_range,
  init_resolverService,
  init_selection,
  init_textModel,
  init_textModelSearch,
  init_theme,
  init_themeService,
  init_undoRedo,
  inputValidationErrorBackground,
  inputValidationErrorBorder,
  inputValidationErrorForeground,
  isAncestorUsingFlowTo,
  isCodeEditor,
  isCompositeEditor,
  isDiffEditor,
  isFirefox as isFirefox2,
  isLocationLink,
  isMultilineRegexSource,
  isThenable,
  isUntitledWorkspace,
  keepAlive,
  listFocusOutline,
  listInactiveSelectionBackground,
  mark,
  marked,
  matchesScheme,
  matchesSomeScheme,
  memoize,
  multibyteAwareBtoa,
  normalizeDriveLetter,
  observableFromEvent,
  observableSignal,
  observableValue,
  ok,
  opaque,
  openLinkFromMarkdown,
  overviewRulerFindMatchForeground,
  overviewRulerRangeHighlight,
  parse,
  parse2,
  raceCancellation,
  raceCancellationError,
  raceTimeout,
  registerAction2,
  registerColor,
  registerIcon,
  registerSingleton,
  registerThemingParticipant,
  renderMarkdown,
  resolveColorValue,
  revive,
  scheduleAtNextAnimationFrame,
  score,
  severity_default,
  splitGlobAware,
  status,
  textBlockQuoteBackground,
  textBlockQuoteBorder,
  textLinkActiveForeground,
  textLinkForeground,
  textPreformatForeground,
  themeColorFromId,
  throttle,
  timeout,
  toAction,
  toWorkspaceFolder,
  trackFocus,
  transaction,
  transparent,
  untildify,
  waitForState
} from "./chunk-O3SOEW3V.js";
import {
  AbstractLoggerService,
  AbstractMessageLogger,
  ArrayQueue,
  AsyncEmitter,
  BugIndicatingError,
  ByteSize,
  COI,
  CancellationError,
  CancellationToken,
  CancellationTokenSource,
  Codicon,
  CompareResult,
  ContextKeyExpr,
  DEFAULT_LOG_LEVEL,
  DebounceEmitter,
  Disposable,
  DisposableMap,
  DisposableStore,
  EDITOR_FONT_DEFAULTS,
  ETAG_DISABLED,
  Emitter,
  ErrorNoTelemetry,
  Event,
  ExtUri,
  ExtensionIdentifier,
  ExtensionIdentifierMap,
  ExtensionIdentifierSet,
  FileAccess,
  FileOperationError,
  FilePermission,
  FileSystemProviderError,
  FileSystemProviderErrorCode,
  FileType,
  IContextKeyService,
  IFileService,
  IInstantiationService,
  ILogService,
  ILoggerService,
  ITelemetryService,
  IndentAction,
  Iterable,
  LANGUAGE_DEFAULT,
  LRUCache,
  Language,
  Lazy,
  LinkedList,
  LogLevel,
  LogLevelToString,
  MarkdownString,
  Mimes,
  MutableDisposable,
  NotImplementedError,
  NotSupportedError,
  OS,
  OverviewRulerLane,
  PauseableEmitter,
  PlatformToString,
  RawContextKey,
  RefCountedDisposable,
  ResourceMap,
  ResourceSet,
  Schemas,
  StopWatch,
  TELEMETRY_OLD_SETTING_ID,
  TELEMETRY_SETTING_ID,
  TernarySearchTree,
  TextEditorCursorStyle,
  ThemeColor,
  ThemeIcon,
  URI,
  VSBuffer,
  asArray,
  assertIsDefined,
  assertType,
  basename,
  basename2,
  basenameOrAuthority,
  bufferToStream,
  canceled,
  cloneAndChange,
  coalesce,
  combinedDisposable,
  commonPrefixLength,
  compare,
  compareBy,
  containsUppercaseCharacter,
  count,
  createDecorator,
  createFileSystemProviderError,
  createMatches,
  cursorStyleToString,
  cwd,
  decodeBase64,
  deepClone,
  deepFreeze,
  delta,
  dirname,
  dirname2,
  dispose,
  disposed,
  distinct,
  encodeBase64,
  ensureValidWordDefinition,
  env,
  equals,
  equals2,
  equalsIgnoreCase,
  escape,
  escapeRegExpCharacters,
  etag,
  extUri,
  extUriBiasedIgnorePathCase,
  extUriIgnorePathCase,
  extname,
  filter,
  findFirstInSorted,
  findLast,
  firstOrDefault,
  flatten,
  format,
  format2,
  fuzzyContains,
  fuzzyScore,
  generateUuid,
  getErrorMessage,
  getRemoteName,
  getRemoteServerRootPath,
  getWordAtText,
  groupBy,
  hash,
  illegalArgument,
  illegalState,
  init_arrays,
  init_buffer,
  init_cancellation,
  init_codicons,
  init_contextkey,
  init_editorOptions,
  init_errorMessage,
  init_errors,
  init_event,
  init_extensions,
  init_files,
  init_filters,
  init_functional,
  init_hash,
  init_htmlContent,
  init_iconLabels,
  init_instantiation,
  init_iterator,
  init_languageConfiguration,
  init_lazy,
  init_lifecycle,
  init_linkedList,
  init_log,
  init_map,
  init_mime,
  init_model,
  init_network,
  init_nls,
  init_objects,
  init_path,
  init_platform,
  init_process,
  init_remoteHosts,
  init_resources,
  init_stopwatch,
  init_strings,
  init_telemetry,
  init_ternarySearchTree,
  init_themables,
  init_types,
  init_uri,
  init_uuid,
  init_wordHelper,
  isAbsolute,
  isAbsolutePath,
  isCancellationError,
  isChrome,
  isDefined,
  isEmptyObject,
  isEqual2 as isEqual,
  isEqualOrParent2 as isEqualOrParent,
  isFalsyOrEmpty,
  isFalsyOrWhitespace,
  isFirefox,
  isLinux,
  isLogLevel,
  isMacintosh,
  isMarkdownString,
  isNative,
  isNonEmptyArray,
  isNumber,
  isObject,
  isSafari,
  isString,
  isUndefinedOrNull,
  isWeb,
  isWebWorker,
  isWindows,
  join,
  joinPath,
  language,
  lastOrDefault,
  localize,
  log,
  ltrim,
  mapArrayOrNot,
  mapFind,
  matchesContiguousSubString,
  matchesFuzzy,
  matchesFuzzy2,
  matchesPrefix,
  matchesWords,
  mixin,
  normalize,
  numberComparator,
  onUnexpectedError,
  onUnexpectedExternalError,
  once,
  or,
  originalFSPath,
  parseHrefAndDimensions,
  parseLogLevel,
  platform,
  platform2,
  posix,
  readonly,
  refineServiceDecorator,
  regExpLeadsToEndlessLoop,
  relative,
  relativePath,
  removeAnsiEscapeCodes,
  replaceAsync,
  rtrim,
  safeStringify,
  sep,
  setTimeout0,
  setUnexpectedErrorHandler,
  shouldSynchronizeModel,
  sortedDiff,
  splitLines,
  streamToBuffer,
  stripIcons,
  tieBreakComparators,
  toDisposable,
  toErrorMessage,
  toFileSystemProviderErrorCode,
  toLocalResource,
  transformErrorForSerialization,
  trim,
  validateConstraint,
  validateWhenClauses,
  whenProviderRegistered
} from "./chunk-N5MAMNNV.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-PGWBAY6J.js";

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionHostKind.js
init_extensions();
var ExtensionHostKind;
(function(ExtensionHostKind2) {
  ExtensionHostKind2[ExtensionHostKind2["LocalProcess"] = 1] = "LocalProcess";
  ExtensionHostKind2[ExtensionHostKind2["LocalWebWorker"] = 2] = "LocalWebWorker";
  ExtensionHostKind2[ExtensionHostKind2["Remote"] = 3] = "Remote";
})(ExtensionHostKind || (ExtensionHostKind = {}));
function extensionHostKindToString(kind) {
  if (kind === null) {
    return "None";
  }
  switch (kind) {
    case 1:
      return "LocalProcess";
    case 2:
      return "LocalWebWorker";
    case 3:
      return "Remote";
  }
}
function extensionRunningPreferenceToString(preference) {
  switch (preference) {
    case 0:
      return "None";
    case 1:
      return "Local";
    case 2:
      return "Remote";
  }
}
function determineExtensionHostKinds(_localExtensions, _remoteExtensions, getExtensionKind, pickExtensionHostKind) {
  const localExtensions = toExtensionWithKind(_localExtensions, getExtensionKind);
  const remoteExtensions = toExtensionWithKind(_remoteExtensions, getExtensionKind);
  const allExtensions = /* @__PURE__ */ new Map();
  const collectExtension = (ext) => {
    if (allExtensions.has(ext.key)) {
      return;
    }
    const local = localExtensions.get(ext.key) || null;
    const remote = remoteExtensions.get(ext.key) || null;
    const info = new ExtensionInfo(local, remote);
    allExtensions.set(info.key, info);
  };
  localExtensions.forEach((ext) => collectExtension(ext));
  remoteExtensions.forEach((ext) => collectExtension(ext));
  const extensionHostKinds = /* @__PURE__ */ new Map();
  allExtensions.forEach((ext) => {
    const isInstalledLocally = Boolean(ext.local);
    const isInstalledRemotely = Boolean(ext.remote);
    const isLocallyUnderDevelopment = Boolean(ext.local && ext.local.isUnderDevelopment);
    const isRemotelyUnderDevelopment = Boolean(ext.remote && ext.remote.isUnderDevelopment);
    let preference = 0;
    if (isLocallyUnderDevelopment && !isRemotelyUnderDevelopment) {
      preference = 1;
    } else if (isRemotelyUnderDevelopment && !isLocallyUnderDevelopment) {
      preference = 2;
    }
    extensionHostKinds.set(ext.key, pickExtensionHostKind(ext.identifier, ext.kind, isInstalledLocally, isInstalledRemotely, preference));
  });
  return extensionHostKinds;
}
function toExtensionWithKind(extensions, getExtensionKind) {
  const result = /* @__PURE__ */ new Map();
  extensions.forEach((desc) => {
    const ext = new ExtensionWithKind(desc, getExtensionKind(desc));
    result.set(ext.key, ext);
  });
  return result;
}
var ExtensionWithKind = class {
  constructor(desc, kind) {
    this.desc = desc;
    this.kind = kind;
  }
  get key() {
    return ExtensionIdentifier.toKey(this.desc.identifier);
  }
  get isUnderDevelopment() {
    return this.desc.isUnderDevelopment;
  }
};
var ExtensionInfo = class {
  constructor(local, remote) {
    this.local = local;
    this.remote = remote;
  }
  get key() {
    if (this.local) {
      return this.local.key;
    }
    return this.remote.key;
  }
  get identifier() {
    if (this.local) {
      return this.local.desc.identifier;
    }
    return this.remote.desc.identifier;
  }
  get kind() {
    if (this.local) {
      return this.local.kind;
    }
    return this.remote.kind;
  }
};

// node_modules/vscode/service-override/extensions.js
init_tslib_es6();
init_files();
init_log();
init_extensions();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/abstractExtensionService.js
init_tslib_es6();
init_async();
init_errorMessage();
init_event();
init_lifecycle();
init_network();
init_resources();
init_stopwatch();
init_nls();
init_configuration();
init_extensions();
init_files();
init_instantiation();

// node_modules/vscode/vscode/src/vs/platform/lifecycle/common/lifecycle.js
init_async();
function handleVetos(vetos, onError) {
  if (vetos.length === 0) {
    return Promise.resolve(false);
  }
  const promises = [];
  let lazyValue = false;
  for (const valueOrPromise of vetos) {
    if (valueOrPromise === true) {
      return Promise.resolve(true);
    }
    if (isThenable(valueOrPromise)) {
      promises.push(valueOrPromise.then((value) => {
        if (value) {
          lazyValue = true;
        }
      }, (err) => {
        onError(err);
        lazyValue = true;
      }));
    }
  }
  return Promises.settled(promises).then(() => lazyValue);
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/abstractExtensionService.js
init_log();
init_remoteAuthorityResolver();
init_telemetry();

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionDescriptionRegistry.js
init_extensions();
init_event();
init_path();
init_lifecycle();
var DeltaExtensionsResult = class {
  constructor(removedDueToLooping) {
    this.removedDueToLooping = removedDueToLooping;
  }
};
var ExtensionDescriptionRegistry = class _ExtensionDescriptionRegistry {
  static isHostExtension(extensionId, myRegistry, globalRegistry) {
    if (myRegistry.getExtensionDescription(extensionId)) {
      return false;
    }
    const extensionDescription = globalRegistry.getExtensionDescription(extensionId);
    if (!extensionDescription) {
      return false;
    }
    if ((extensionDescription.main || extensionDescription.browser) && extensionDescription.api === "none") {
      return true;
    }
    return false;
  }
  constructor(_activationEventsReader, extensionDescriptions) {
    this._activationEventsReader = _activationEventsReader;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._extensionDescriptions = extensionDescriptions;
    this._initialize();
  }
  _initialize() {
    this._extensionDescriptions.sort(extensionCmp);
    this._extensionsMap = new ExtensionIdentifierMap();
    this._extensionsArr = [];
    this._activationMap = /* @__PURE__ */ new Map();
    for (const extensionDescription of this._extensionDescriptions) {
      if (this._extensionsMap.has(extensionDescription.identifier)) {
        console.error("Extension `" + extensionDescription.identifier.value + "` is already registered");
        continue;
      }
      this._extensionsMap.set(extensionDescription.identifier, extensionDescription);
      this._extensionsArr.push(extensionDescription);
      const activationEvents = this._activationEventsReader.readActivationEvents(extensionDescription);
      if (Array.isArray(activationEvents)) {
        for (let activationEvent of activationEvents) {
          if (activationEvent === "onUri") {
            activationEvent = `onUri:${ExtensionIdentifier.toKey(extensionDescription.identifier)}`;
          }
          if (!this._activationMap.has(activationEvent)) {
            this._activationMap.set(activationEvent, []);
          }
          this._activationMap.get(activationEvent).push(extensionDescription);
        }
      }
    }
  }
  set(extensionDescriptions) {
    this._extensionDescriptions = extensionDescriptions;
    this._initialize();
    this._onDidChange.fire(void 0);
  }
  deltaExtensions(toAdd, toRemove) {
    this._extensionDescriptions = removeExtensions(this._extensionDescriptions, toRemove);
    this._extensionDescriptions = this._extensionDescriptions.concat(toAdd);
    const looping = _ExtensionDescriptionRegistry._findLoopingExtensions(this._extensionDescriptions);
    this._extensionDescriptions = removeExtensions(this._extensionDescriptions, looping.map((ext) => ext.identifier));
    this._initialize();
    this._onDidChange.fire(void 0);
    return new DeltaExtensionsResult(looping);
  }
  static _findLoopingExtensions(extensionDescriptions) {
    const G = new class {
      constructor() {
        this._arcs = /* @__PURE__ */ new Map();
        this._nodesSet = /* @__PURE__ */ new Set();
        this._nodesArr = [];
      }
      addNode(id) {
        if (!this._nodesSet.has(id)) {
          this._nodesSet.add(id);
          this._nodesArr.push(id);
        }
      }
      addArc(from, to) {
        this.addNode(from);
        this.addNode(to);
        if (this._arcs.has(from)) {
          this._arcs.get(from).push(to);
        } else {
          this._arcs.set(from, [to]);
        }
      }
      getArcs(id) {
        if (this._arcs.has(id)) {
          return this._arcs.get(id);
        }
        return [];
      }
      hasOnlyGoodArcs(id, good2) {
        const dependencies = G.getArcs(id);
        for (let i = 0; i < dependencies.length; i++) {
          if (!good2.has(dependencies[i])) {
            return false;
          }
        }
        return true;
      }
      getNodes() {
        return this._nodesArr;
      }
    }();
    const descs = new ExtensionIdentifierMap();
    for (const extensionDescription of extensionDescriptions) {
      descs.set(extensionDescription.identifier, extensionDescription);
      if (extensionDescription.extensionDependencies) {
        for (const depId of extensionDescription.extensionDependencies) {
          G.addArc(ExtensionIdentifier.toKey(extensionDescription.identifier), ExtensionIdentifier.toKey(depId));
        }
      }
    }
    const good = /* @__PURE__ */ new Set();
    G.getNodes().filter((id) => G.getArcs(id).length === 0).forEach((id) => good.add(id));
    const nodes = G.getNodes().filter((id) => !good.has(id));
    let madeProgress;
    do {
      madeProgress = false;
      for (let i = 0; i < nodes.length; i++) {
        const id = nodes[i];
        if (G.hasOnlyGoodArcs(id, good)) {
          nodes.splice(i, 1);
          i--;
          good.add(id);
          madeProgress = true;
        }
      }
    } while (madeProgress);
    return nodes.map((id) => descs.get(id));
  }
  containsActivationEvent(activationEvent) {
    return this._activationMap.has(activationEvent);
  }
  containsExtension(extensionId) {
    return this._extensionsMap.has(extensionId);
  }
  getExtensionDescriptionsForActivationEvent(activationEvent) {
    const extensions = this._activationMap.get(activationEvent);
    return extensions ? extensions.slice(0) : [];
  }
  getAllExtensionDescriptions() {
    return this._extensionsArr.slice(0);
  }
  getExtensionDescription(extensionId) {
    const extension = this._extensionsMap.get(extensionId);
    return extension ? extension : void 0;
  }
  getExtensionDescriptionByUUID(uuid) {
    for (const extensionDescription of this._extensionsArr) {
      if (extensionDescription.uuid === uuid) {
        return extensionDescription;
      }
    }
    return void 0;
  }
  getExtensionDescriptionByIdOrUUID(extensionId, uuid) {
    return this.getExtensionDescription(extensionId) ?? (uuid ? this.getExtensionDescriptionByUUID(uuid) : void 0);
  }
};
var LockableExtensionDescriptionRegistry = class {
  constructor(activationEventsReader) {
    this._lock = new Lock();
    this._actual = new ExtensionDescriptionRegistry(activationEventsReader, []);
  }
  async acquireLock(customerName) {
    const lock = await this._lock.acquire(customerName);
    return new ExtensionDescriptionRegistryLock(this, lock);
  }
  deltaExtensions(acquiredLock, toAdd, toRemove) {
    if (!acquiredLock.isAcquiredFor(this)) {
      throw new Error("Lock is not held");
    }
    return this._actual.deltaExtensions(toAdd, toRemove);
  }
  containsActivationEvent(activationEvent) {
    return this._actual.containsActivationEvent(activationEvent);
  }
  containsExtension(extensionId) {
    return this._actual.containsExtension(extensionId);
  }
  getExtensionDescriptionsForActivationEvent(activationEvent) {
    return this._actual.getExtensionDescriptionsForActivationEvent(activationEvent);
  }
  getAllExtensionDescriptions() {
    return this._actual.getAllExtensionDescriptions();
  }
  getExtensionDescription(extensionId) {
    return this._actual.getExtensionDescription(extensionId);
  }
  getExtensionDescriptionByUUID(uuid) {
    return this._actual.getExtensionDescriptionByUUID(uuid);
  }
  getExtensionDescriptionByIdOrUUID(extensionId, uuid) {
    return this._actual.getExtensionDescriptionByIdOrUUID(extensionId, uuid);
  }
};
var ExtensionDescriptionRegistryLock = class extends Disposable {
  constructor(_registry, lock) {
    super();
    this._registry = _registry;
    this._isDisposed = false;
    this._register(lock);
  }
  isAcquiredFor(registry) {
    return !this._isDisposed && this._registry === registry;
  }
};
var LockCustomer = class {
  constructor(name) {
    this.name = name;
    this.promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
    });
  }
  resolve(value) {
    this._resolve(value);
  }
};
var Lock = class {
  constructor() {
    this._pendingCustomers = [];
    this._isLocked = false;
  }
  async acquire(customerName) {
    const customer = new LockCustomer(customerName);
    this._pendingCustomers.push(customer);
    this._advance();
    return customer.promise;
  }
  _advance() {
    if (this._isLocked) {
      return;
    }
    if (this._pendingCustomers.length === 0) {
      return;
    }
    const customer = this._pendingCustomers.shift();
    this._isLocked = true;
    let customerHoldsLock = true;
    const logLongRunningCustomerTimeout = setTimeout(() => {
      if (customerHoldsLock) {
        console.warn(`The customer named ${customer.name} has been holding on to the lock for 30s. This might be a problem.`);
      }
    }, 30 * 1e3);
    const releaseLock = () => {
      if (!customerHoldsLock) {
        return;
      }
      clearTimeout(logLongRunningCustomerTimeout);
      customerHoldsLock = false;
      this._isLocked = false;
      this._advance();
    };
    customer.resolve(toDisposable(releaseLock));
  }
};
function extensionCmp(a, b) {
  const aSortBucket = a.isBuiltin ? 0 : a.isUnderDevelopment ? 2 : 1;
  const bSortBucket = b.isBuiltin ? 0 : b.isUnderDevelopment ? 2 : 1;
  if (aSortBucket !== bSortBucket) {
    return aSortBucket - bSortBucket;
  }
  const aLastSegment = posix.basename(a.extensionLocation.path);
  const bLastSegment = posix.basename(b.extensionLocation.path);
  if (aLastSegment < bLastSegment) {
    return -1;
  }
  if (aLastSegment > bLastSegment) {
    return 1;
  }
  return 0;
}
function removeExtensions(arr, toRemove) {
  const toRemoveSet = new ExtensionIdentifierSet(toRemove);
  return arr.filter((extension) => !toRemoveSet.has(extension.identifier));
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionDevOptions.js
init_network();
function parseExtensionDevOptions(environmentService) {
  const isExtensionDevHost = environmentService.isExtensionDevelopment;
  let debugOk = true;
  const extDevLocs = environmentService.extensionDevelopmentLocationURI;
  if (extDevLocs) {
    for (const x of extDevLocs) {
      if (x.scheme !== Schemas.file) {
        debugOk = false;
      }
    }
  }
  const isExtensionDevDebug = debugOk && typeof environmentService.debugExtensionHost.port === "number";
  const isExtensionDevDebugBrk = debugOk && !!environmentService.debugExtensionHost.break;
  const isExtensionDevTestFromCli = isExtensionDevHost && !!environmentService.extensionTestsLocationURI && !environmentService.debugExtensionHost.debugId;
  return {
    isExtensionDevHost,
    isExtensionDevDebug,
    isExtensionDevDebugBrk,
    isExtensionDevTestFromCli
  };
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionHostManager.js
init_tslib_es6();
init_async();
init_buffer();
init_errors();
init_event();
init_lifecycle();
init_stopwatch();
init_nls();
init_actions2();
init_instantiation();
init_log();
init_remoteAuthorityResolver();
init_telemetry();

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extHostCustomers.js
function extHostNamedCustomer(id) {
  return function(ctor) {
    ExtHostCustomersRegistryImpl.INSTANCE.registerNamedCustomer(id, ctor);
  };
}
function extHostCustomer(ctor) {
  ExtHostCustomersRegistryImpl.INSTANCE.registerCustomer(ctor);
}
var ExtHostCustomersRegistry;
(function(ExtHostCustomersRegistry2) {
  function getNamedCustomers() {
    return ExtHostCustomersRegistryImpl.INSTANCE.getNamedCustomers();
  }
  ExtHostCustomersRegistry2.getNamedCustomers = getNamedCustomers;
  function getCustomers() {
    return ExtHostCustomersRegistryImpl.INSTANCE.getCustomers();
  }
  ExtHostCustomersRegistry2.getCustomers = getCustomers;
})(ExtHostCustomersRegistry || (ExtHostCustomersRegistry = {}));
var _ExtHostCustomersRegistryImpl = class _ExtHostCustomersRegistryImpl {
  constructor() {
    this._namedCustomers = [];
    this._customers = [];
  }
  registerNamedCustomer(id, ctor) {
    const entry = [id, ctor];
    this._namedCustomers.push(entry);
  }
  getNamedCustomers() {
    return this._namedCustomers;
  }
  registerCustomer(ctor) {
    this._customers.push(ctor);
  }
  getCustomers() {
    return this._customers;
  }
};
_ExtHostCustomersRegistryImpl.INSTANCE = new _ExtHostCustomersRegistryImpl();
var ExtHostCustomersRegistryImpl = _ExtHostCustomersRegistryImpl;

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/rpcProtocol.js
init_async();
init_buffer();
init_cancellation();
init_errors();
init_event();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/base/common/uriIpc.js
init_buffer();
init_uri();
function _transformIncomingURIs(obj, transformer, revive2, depth) {
  if (!obj || depth > 200) {
    return null;
  }
  if (typeof obj === "object") {
    if (obj.$mid === 1) {
      return revive2 ? URI.revive(transformer.transformIncoming(obj)) : transformer.transformIncoming(obj);
    }
    if (obj instanceof VSBuffer) {
      return null;
    }
    for (const key in obj) {
      if (Object.hasOwnProperty.call(obj, key)) {
        const r = _transformIncomingURIs(obj[key], transformer, revive2, depth + 1);
        if (r !== null) {
          obj[key] = r;
        }
      }
    }
  }
  return null;
}
function transformIncomingURIs(obj, transformer) {
  const result = _transformIncomingURIs(obj, transformer, false, 0);
  if (result === null) {
    return obj;
  }
  return result;
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/lazyPromise.js
init_errors();
var LazyPromise = class {
  constructor() {
    this._actual = null;
    this._actualOk = null;
    this._actualErr = null;
    this._hasValue = false;
    this._value = null;
    this._hasErr = false;
    this._err = null;
  }
  get [Symbol.toStringTag]() {
    return this.toString();
  }
  _ensureActual() {
    if (!this._actual) {
      this._actual = new Promise((c, e) => {
        this._actualOk = c;
        this._actualErr = e;
        if (this._hasValue) {
          this._actualOk(this._value);
        }
        if (this._hasErr) {
          this._actualErr(this._err);
        }
      });
    }
    return this._actual;
  }
  resolveOk(value) {
    if (this._hasValue || this._hasErr) {
      return;
    }
    this._hasValue = true;
    this._value = value;
    if (this._actual) {
      this._actualOk(value);
    }
  }
  resolveErr(err) {
    if (this._hasValue || this._hasErr) {
      return;
    }
    this._hasErr = true;
    this._err = err;
    if (this._actual) {
      this._actualErr(err);
    } else {
      onUnexpectedError(err);
    }
  }
  then(success, error) {
    return this._ensureActual().then(success, error);
  }
  catch(error) {
    return this._ensureActual().then(void 0, error);
  }
  finally(callback) {
    return this._ensureActual().finally(callback);
  }
};
var CanceledLazyPromise = class extends LazyPromise {
  constructor() {
    super();
    this._hasErr = true;
    this._err = new CancellationError();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/rpcProtocol.js
init_proxyIdentifier();
var _a;
function safeStringify2(obj, replacer) {
  try {
    return JSON.stringify(obj, replacer);
  } catch (err) {
    return "null";
  }
}
var refSymbolName = "$$ref$$";
var undefinedRef = { [refSymbolName]: -1 };
function stringifyJsonWithBufferRefs(obj, replacer = null, useSafeStringify = false) {
  const foundBuffers = [];
  const serialized = (useSafeStringify ? safeStringify2 : JSON.stringify)(obj, (key, value) => {
    if (typeof value === "undefined") {
      return undefinedRef;
    } else if (typeof value === "object") {
      if (value instanceof VSBuffer) {
        const bufferIndex = foundBuffers.push(value) - 1;
        return { [refSymbolName]: bufferIndex };
      }
      if (replacer) {
        return replacer(key, value);
      }
    }
    return value;
  });
  return {
    jsonString: serialized,
    referencedBuffers: foundBuffers
  };
}
function parseJsonAndRestoreBufferRefs(jsonString, buffers, uriTransformer) {
  return JSON.parse(jsonString, (_key, value) => {
    if (value) {
      const ref = value[refSymbolName];
      if (typeof ref === "number") {
        return buffers[ref];
      }
      if (uriTransformer && value.$mid === 1) {
        return uriTransformer.transformIncoming(value);
      }
    }
    return value;
  });
}
function stringify(obj, replacer) {
  return JSON.stringify(obj, replacer);
}
function createURIReplacer(transformer) {
  if (!transformer) {
    return null;
  }
  return (key, value) => {
    if (value && value.$mid === 1) {
      return transformer.transformOutgoing(value);
    }
    return value;
  };
}
var noop = () => {
};
var _RPCProtocolSymbol = Symbol.for("rpcProtocol");
var _RPCProxySymbol = Symbol.for("rpcProxy");
var _RPCProtocol = class _RPCProtocol extends Disposable {
  constructor(protocol, logger = null, transformer = null) {
    super();
    this[_a] = true;
    this._onDidChangeResponsiveState = this._register(new Emitter());
    this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event;
    this._protocol = protocol;
    this._logger = logger;
    this._uriTransformer = transformer;
    this._uriReplacer = createURIReplacer(this._uriTransformer);
    this._isDisposed = false;
    this._locals = [];
    this._proxies = [];
    for (let i = 0, len = ProxyIdentifier.count; i < len; i++) {
      this._locals[i] = null;
      this._proxies[i] = null;
    }
    this._lastMessageId = 0;
    this._cancelInvokedHandlers = /* @__PURE__ */ Object.create(null);
    this._pendingRPCReplies = {};
    this._responsiveState = 0;
    this._unacknowledgedCount = 0;
    this._unresponsiveTime = 0;
    this._asyncCheckUresponsive = this._register(new RunOnceScheduler(() => this._checkUnresponsive(), 1e3));
    this._protocol.onMessage((msg) => this._receiveOneMessage(msg));
  }
  dispose() {
    this._isDisposed = true;
    Object.keys(this._pendingRPCReplies).forEach((msgId) => {
      const pending = this._pendingRPCReplies[msgId];
      pending.resolveErr(canceled());
    });
  }
  drain() {
    if (typeof this._protocol.drain === "function") {
      return this._protocol.drain();
    }
    return Promise.resolve();
  }
  _onWillSendRequest(req) {
    if (this._unacknowledgedCount === 0) {
      this._unresponsiveTime = Date.now() + _RPCProtocol.UNRESPONSIVE_TIME;
    }
    this._unacknowledgedCount++;
    if (!this._asyncCheckUresponsive.isScheduled()) {
      this._asyncCheckUresponsive.schedule();
    }
  }
  _onDidReceiveAcknowledge(req) {
    this._unresponsiveTime = Date.now() + _RPCProtocol.UNRESPONSIVE_TIME;
    this._unacknowledgedCount--;
    if (this._unacknowledgedCount === 0) {
      this._asyncCheckUresponsive.cancel();
    }
    this._setResponsiveState(0);
  }
  _checkUnresponsive() {
    if (this._unacknowledgedCount === 0) {
      return;
    }
    if (Date.now() > this._unresponsiveTime) {
      this._setResponsiveState(1);
    } else {
      this._asyncCheckUresponsive.schedule();
    }
  }
  _setResponsiveState(newResponsiveState) {
    if (this._responsiveState === newResponsiveState) {
      return;
    }
    this._responsiveState = newResponsiveState;
    this._onDidChangeResponsiveState.fire(this._responsiveState);
  }
  get responsiveState() {
    return this._responsiveState;
  }
  transformIncomingURIs(obj) {
    if (!this._uriTransformer) {
      return obj;
    }
    return transformIncomingURIs(obj, this._uriTransformer);
  }
  getProxy(identifier) {
    const { nid: rpcId, sid } = identifier;
    if (!this._proxies[rpcId]) {
      this._proxies[rpcId] = this._createProxy(rpcId, sid);
    }
    return this._proxies[rpcId];
  }
  _createProxy(rpcId, debugName) {
    const handler = {
      get: (target, name) => {
        if (typeof name === "string" && !target[name] && name.charCodeAt(0) === 36) {
          target[name] = (...myArgs) => {
            return this._remoteCall(rpcId, name, myArgs);
          };
        }
        if (name === _RPCProxySymbol) {
          return debugName;
        }
        return target[name];
      }
    };
    return new Proxy(/* @__PURE__ */ Object.create(null), handler);
  }
  set(identifier, value) {
    this._locals[identifier.nid] = value;
    return value;
  }
  assertRegistered(identifiers) {
    for (let i = 0, len = identifiers.length; i < len; i++) {
      const identifier = identifiers[i];
      if (!this._locals[identifier.nid]) {
        throw new Error(`Missing proxy instance ${identifier.sid}`);
      }
    }
  }
  _receiveOneMessage(rawmsg) {
    var _a30;
    if (this._isDisposed) {
      return;
    }
    const msgLength = rawmsg.byteLength;
    const buff = MessageBuffer.read(rawmsg, 0);
    const messageType = buff.readUInt8();
    const req = buff.readUInt32();
    switch (messageType) {
      case 1:
      case 2: {
        let { rpcId, method, args } = MessageIO.deserializeRequestJSONArgs(buff);
        if (this._uriTransformer) {
          args = transformIncomingURIs(args, this._uriTransformer);
        }
        this._receiveRequest(msgLength, req, rpcId, method, args, messageType === 2);
        break;
      }
      case 3:
      case 4: {
        let { rpcId, method, args } = MessageIO.deserializeRequestMixedArgs(buff);
        if (this._uriTransformer) {
          args = transformIncomingURIs(args, this._uriTransformer);
        }
        this._receiveRequest(msgLength, req, rpcId, method, args, messageType === 4);
        break;
      }
      case 5: {
        (_a30 = this._logger) == null ? void 0 : _a30.logIncoming(msgLength, req, 0, `ack`);
        this._onDidReceiveAcknowledge(req);
        break;
      }
      case 6: {
        this._receiveCancel(msgLength, req);
        break;
      }
      case 7: {
        this._receiveReply(msgLength, req, void 0);
        break;
      }
      case 9: {
        let value = MessageIO.deserializeReplyOKJSON(buff);
        if (this._uriTransformer) {
          value = transformIncomingURIs(value, this._uriTransformer);
        }
        this._receiveReply(msgLength, req, value);
        break;
      }
      case 10: {
        const value = MessageIO.deserializeReplyOKJSONWithBuffers(buff, this._uriTransformer);
        this._receiveReply(msgLength, req, value);
        break;
      }
      case 8: {
        const value = MessageIO.deserializeReplyOKVSBuffer(buff);
        this._receiveReply(msgLength, req, value);
        break;
      }
      case 11: {
        let err = MessageIO.deserializeReplyErrError(buff);
        if (this._uriTransformer) {
          err = transformIncomingURIs(err, this._uriTransformer);
        }
        this._receiveReplyErr(msgLength, req, err);
        break;
      }
      case 12: {
        this._receiveReplyErr(msgLength, req, void 0);
        break;
      }
      default:
        console.error(`received unexpected message`);
        console.error(rawmsg);
    }
  }
  _receiveRequest(msgLength, req, rpcId, method, args, usesCancellationToken) {
    var _a30, _b;
    (_a30 = this._logger) == null ? void 0 : _a30.logIncoming(msgLength, req, 1, `receiveRequest ${getStringIdentifierForProxy(rpcId)}.${method}(`, args);
    const callId = String(req);
    let promise;
    let cancel;
    if (usesCancellationToken) {
      const cancellationTokenSource = new CancellationTokenSource();
      args.push(cancellationTokenSource.token);
      promise = this._invokeHandler(rpcId, method, args);
      cancel = () => cancellationTokenSource.cancel();
    } else {
      promise = this._invokeHandler(rpcId, method, args);
      cancel = noop;
    }
    this._cancelInvokedHandlers[callId] = cancel;
    const msg = MessageIO.serializeAcknowledged(req);
    (_b = this._logger) == null ? void 0 : _b.logOutgoing(msg.byteLength, req, 1, `ack`);
    this._protocol.send(msg);
    promise.then((r) => {
      var _a31;
      delete this._cancelInvokedHandlers[callId];
      const msg2 = MessageIO.serializeReplyOK(req, r, this._uriReplacer);
      (_a31 = this._logger) == null ? void 0 : _a31.logOutgoing(msg2.byteLength, req, 1, `reply:`, r);
      this._protocol.send(msg2);
    }, (err) => {
      var _a31;
      delete this._cancelInvokedHandlers[callId];
      const msg2 = MessageIO.serializeReplyErr(req, err);
      (_a31 = this._logger) == null ? void 0 : _a31.logOutgoing(msg2.byteLength, req, 1, `replyErr:`, err);
      this._protocol.send(msg2);
    });
  }
  _receiveCancel(msgLength, req) {
    var _a30, _b, _c;
    (_a30 = this._logger) == null ? void 0 : _a30.logIncoming(msgLength, req, 1, `receiveCancel`);
    const callId = String(req);
    (_c = (_b = this._cancelInvokedHandlers)[callId]) == null ? void 0 : _c.call(_b);
  }
  _receiveReply(msgLength, req, value) {
    var _a30;
    (_a30 = this._logger) == null ? void 0 : _a30.logIncoming(msgLength, req, 0, `receiveReply:`, value);
    const callId = String(req);
    if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
      return;
    }
    const pendingReply = this._pendingRPCReplies[callId];
    delete this._pendingRPCReplies[callId];
    pendingReply.resolveOk(value);
  }
  _receiveReplyErr(msgLength, req, value) {
    var _a30;
    (_a30 = this._logger) == null ? void 0 : _a30.logIncoming(msgLength, req, 0, `receiveReplyErr:`, value);
    const callId = String(req);
    if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
      return;
    }
    const pendingReply = this._pendingRPCReplies[callId];
    delete this._pendingRPCReplies[callId];
    let err = void 0;
    if (value) {
      if (value.$isError) {
        err = new Error();
        err.name = value.name;
        err.message = value.message;
        err.stack = value.stack;
      } else {
        err = value;
      }
    }
    pendingReply.resolveErr(err);
  }
  _invokeHandler(rpcId, methodName, args) {
    try {
      return Promise.resolve(this._doInvokeHandler(rpcId, methodName, args));
    } catch (err) {
      return Promise.reject(err);
    }
  }
  _doInvokeHandler(rpcId, methodName, args) {
    const actor = this._locals[rpcId];
    if (!actor) {
      throw new Error("Unknown actor " + getStringIdentifierForProxy(rpcId));
    }
    const method = actor[methodName];
    if (typeof method !== "function") {
      throw new Error("Unknown method " + methodName + " on actor " + getStringIdentifierForProxy(rpcId));
    }
    return method.apply(actor, args);
  }
  _remoteCall(rpcId, methodName, args) {
    var _a30;
    if (this._isDisposed) {
      return new CanceledLazyPromise();
    }
    let cancellationToken = null;
    if (args.length > 0 && CancellationToken.isCancellationToken(args[args.length - 1])) {
      cancellationToken = args.pop();
    }
    if (cancellationToken && cancellationToken.isCancellationRequested) {
      return Promise.reject(canceled());
    }
    const serializedRequestArguments = MessageIO.serializeRequestArguments(args, this._uriReplacer);
    const req = ++this._lastMessageId;
    const callId = String(req);
    const result = new LazyPromise();
    if (cancellationToken) {
      cancellationToken.onCancellationRequested(() => {
        var _a31;
        const msg2 = MessageIO.serializeCancel(req);
        (_a31 = this._logger) == null ? void 0 : _a31.logOutgoing(msg2.byteLength, req, 0, `cancel`);
        this._protocol.send(MessageIO.serializeCancel(req));
      });
    }
    this._pendingRPCReplies[callId] = result;
    this._onWillSendRequest(req);
    const msg = MessageIO.serializeRequest(req, rpcId, methodName, serializedRequestArguments, !!cancellationToken);
    (_a30 = this._logger) == null ? void 0 : _a30.logOutgoing(msg.byteLength, req, 0, `request: ${getStringIdentifierForProxy(rpcId)}.${methodName}(`, args);
    this._protocol.send(msg);
    return result;
  }
};
_a = _RPCProtocolSymbol;
_RPCProtocol.UNRESPONSIVE_TIME = 3 * 1e3;
var RPCProtocol = _RPCProtocol;
var _MessageBuffer = class _MessageBuffer {
  static alloc(type, req, messageSize) {
    const result = new _MessageBuffer(VSBuffer.alloc(messageSize + 1 + 4), 0);
    result.writeUInt8(type);
    result.writeUInt32(req);
    return result;
  }
  static read(buff, offset) {
    return new _MessageBuffer(buff, offset);
  }
  get buffer() {
    return this._buff;
  }
  constructor(buff, offset) {
    this._buff = buff;
    this._offset = offset;
  }
  static sizeUInt8() {
    return 1;
  }
  writeUInt8(n2) {
    this._buff.writeUInt8(n2, this._offset);
    this._offset += 1;
  }
  readUInt8() {
    const n2 = this._buff.readUInt8(this._offset);
    this._offset += 1;
    return n2;
  }
  writeUInt32(n2) {
    this._buff.writeUInt32BE(n2, this._offset);
    this._offset += 4;
  }
  readUInt32() {
    const n2 = this._buff.readUInt32BE(this._offset);
    this._offset += 4;
    return n2;
  }
  static sizeShortString(str) {
    return 1 + str.byteLength;
  }
  writeShortString(str) {
    this._buff.writeUInt8(str.byteLength, this._offset);
    this._offset += 1;
    this._buff.set(str, this._offset);
    this._offset += str.byteLength;
  }
  readShortString() {
    const strByteLength = this._buff.readUInt8(this._offset);
    this._offset += 1;
    const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);
    const str = strBuff.toString();
    this._offset += strByteLength;
    return str;
  }
  static sizeLongString(str) {
    return 4 + str.byteLength;
  }
  writeLongString(str) {
    this._buff.writeUInt32BE(str.byteLength, this._offset);
    this._offset += 4;
    this._buff.set(str, this._offset);
    this._offset += str.byteLength;
  }
  readLongString() {
    const strByteLength = this._buff.readUInt32BE(this._offset);
    this._offset += 4;
    const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);
    const str = strBuff.toString();
    this._offset += strByteLength;
    return str;
  }
  writeBuffer(buff) {
    this._buff.writeUInt32BE(buff.byteLength, this._offset);
    this._offset += 4;
    this._buff.set(buff, this._offset);
    this._offset += buff.byteLength;
  }
  static sizeVSBuffer(buff) {
    return 4 + buff.byteLength;
  }
  writeVSBuffer(buff) {
    this._buff.writeUInt32BE(buff.byteLength, this._offset);
    this._offset += 4;
    this._buff.set(buff, this._offset);
    this._offset += buff.byteLength;
  }
  readVSBuffer() {
    const buffLength = this._buff.readUInt32BE(this._offset);
    this._offset += 4;
    const buff = this._buff.slice(this._offset, this._offset + buffLength);
    this._offset += buffLength;
    return buff;
  }
  static sizeMixedArray(arr) {
    let size = 0;
    size += 1;
    for (let i = 0, len = arr.length; i < len; i++) {
      const el = arr[i];
      size += 1;
      switch (el.type) {
        case 1:
          size += this.sizeLongString(el.value);
          break;
        case 2:
          size += this.sizeVSBuffer(el.value);
          break;
        case 3:
          size += this.sizeUInt32;
          size += this.sizeLongString(el.value);
          for (let i2 = 0; i2 < el.buffers.length; ++i2) {
            size += this.sizeVSBuffer(el.buffers[i2]);
          }
          break;
      }
    }
    return size;
  }
  writeMixedArray(arr) {
    this._buff.writeUInt8(arr.length, this._offset);
    this._offset += 1;
    for (let i = 0, len = arr.length; i < len; i++) {
      const el = arr[i];
      switch (el.type) {
        case 1:
          this.writeUInt8(1);
          this.writeLongString(el.value);
          break;
        case 2:
          this.writeUInt8(2);
          this.writeVSBuffer(el.value);
          break;
        case 3:
          this.writeUInt8(3);
          this.writeUInt32(el.buffers.length);
          this.writeLongString(el.value);
          for (let i2 = 0; i2 < el.buffers.length; ++i2) {
            this.writeBuffer(el.buffers[i2]);
          }
          break;
        case 4:
          this.writeUInt8(4);
          break;
      }
    }
  }
  readMixedArray() {
    const arrLen = this._buff.readUInt8(this._offset);
    this._offset += 1;
    const arr = new Array(arrLen);
    for (let i = 0; i < arrLen; i++) {
      const argType = this.readUInt8();
      switch (argType) {
        case 1:
          arr[i] = this.readLongString();
          break;
        case 2:
          arr[i] = this.readVSBuffer();
          break;
        case 3: {
          const bufferCount = this.readUInt32();
          const jsonString = this.readLongString();
          const buffers = [];
          for (let i2 = 0; i2 < bufferCount; ++i2) {
            buffers.push(this.readVSBuffer());
          }
          arr[i] = new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(jsonString, buffers, null));
          break;
        }
        case 4:
          arr[i] = void 0;
          break;
      }
    }
    return arr;
  }
};
_MessageBuffer.sizeUInt32 = 4;
var MessageBuffer = _MessageBuffer;
var MessageIO = class {
  static _useMixedArgSerialization(arr) {
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i] instanceof VSBuffer) {
        return true;
      }
      if (arr[i] instanceof SerializableObjectWithBuffers) {
        return true;
      }
      if (typeof arr[i] === "undefined") {
        return true;
      }
    }
    return false;
  }
  static serializeRequestArguments(args, replacer) {
    if (this._useMixedArgSerialization(args)) {
      const massagedArgs = [];
      for (let i = 0, len = args.length; i < len; i++) {
        const arg = args[i];
        if (arg instanceof VSBuffer) {
          massagedArgs[i] = { type: 2, value: arg };
        } else if (typeof arg === "undefined") {
          massagedArgs[i] = { type: 4 };
        } else if (arg instanceof SerializableObjectWithBuffers) {
          const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(arg.value, replacer);
          massagedArgs[i] = { type: 3, value: VSBuffer.fromString(jsonString), buffers: referencedBuffers };
        } else {
          massagedArgs[i] = { type: 1, value: VSBuffer.fromString(stringify(arg, replacer)) };
        }
      }
      return {
        type: 1,
        args: massagedArgs
      };
    }
    return {
      type: 0,
      args: stringify(args, replacer)
    };
  }
  static serializeRequest(req, rpcId, method, serializedArgs, usesCancellationToken) {
    switch (serializedArgs.type) {
      case 0:
        return this._requestJSONArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);
      case 1:
        return this._requestMixedArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);
    }
  }
  static _requestJSONArgs(req, rpcId, method, args, usesCancellationToken) {
    const methodBuff = VSBuffer.fromString(method);
    const argsBuff = VSBuffer.fromString(args);
    let len = 0;
    len += MessageBuffer.sizeUInt8();
    len += MessageBuffer.sizeShortString(methodBuff);
    len += MessageBuffer.sizeLongString(argsBuff);
    const result = MessageBuffer.alloc(usesCancellationToken ? 2 : 1, req, len);
    result.writeUInt8(rpcId);
    result.writeShortString(methodBuff);
    result.writeLongString(argsBuff);
    return result.buffer;
  }
  static deserializeRequestJSONArgs(buff) {
    const rpcId = buff.readUInt8();
    const method = buff.readShortString();
    const args = buff.readLongString();
    return {
      rpcId,
      method,
      args: JSON.parse(args)
    };
  }
  static _requestMixedArgs(req, rpcId, method, args, usesCancellationToken) {
    const methodBuff = VSBuffer.fromString(method);
    let len = 0;
    len += MessageBuffer.sizeUInt8();
    len += MessageBuffer.sizeShortString(methodBuff);
    len += MessageBuffer.sizeMixedArray(args);
    const result = MessageBuffer.alloc(usesCancellationToken ? 4 : 3, req, len);
    result.writeUInt8(rpcId);
    result.writeShortString(methodBuff);
    result.writeMixedArray(args);
    return result.buffer;
  }
  static deserializeRequestMixedArgs(buff) {
    const rpcId = buff.readUInt8();
    const method = buff.readShortString();
    const rawargs = buff.readMixedArray();
    const args = new Array(rawargs.length);
    for (let i = 0, len = rawargs.length; i < len; i++) {
      const rawarg = rawargs[i];
      if (typeof rawarg === "string") {
        args[i] = JSON.parse(rawarg);
      } else {
        args[i] = rawarg;
      }
    }
    return {
      rpcId,
      method,
      args
    };
  }
  static serializeAcknowledged(req) {
    return MessageBuffer.alloc(5, req, 0).buffer;
  }
  static serializeCancel(req) {
    return MessageBuffer.alloc(6, req, 0).buffer;
  }
  static serializeReplyOK(req, res, replacer) {
    if (typeof res === "undefined") {
      return this._serializeReplyOKEmpty(req);
    } else if (res instanceof VSBuffer) {
      return this._serializeReplyOKVSBuffer(req, res);
    } else if (res instanceof SerializableObjectWithBuffers) {
      const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(res.value, replacer, true);
      return this._serializeReplyOKJSONWithBuffers(req, jsonString, referencedBuffers);
    } else {
      return this._serializeReplyOKJSON(req, safeStringify2(res, replacer));
    }
  }
  static _serializeReplyOKEmpty(req) {
    return MessageBuffer.alloc(7, req, 0).buffer;
  }
  static _serializeReplyOKVSBuffer(req, res) {
    let len = 0;
    len += MessageBuffer.sizeVSBuffer(res);
    const result = MessageBuffer.alloc(8, req, len);
    result.writeVSBuffer(res);
    return result.buffer;
  }
  static deserializeReplyOKVSBuffer(buff) {
    return buff.readVSBuffer();
  }
  static _serializeReplyOKJSON(req, res) {
    const resBuff = VSBuffer.fromString(res);
    let len = 0;
    len += MessageBuffer.sizeLongString(resBuff);
    const result = MessageBuffer.alloc(9, req, len);
    result.writeLongString(resBuff);
    return result.buffer;
  }
  static _serializeReplyOKJSONWithBuffers(req, res, buffers) {
    const resBuff = VSBuffer.fromString(res);
    let len = 0;
    len += MessageBuffer.sizeUInt32;
    len += MessageBuffer.sizeLongString(resBuff);
    for (const buffer of buffers) {
      len += MessageBuffer.sizeVSBuffer(buffer);
    }
    const result = MessageBuffer.alloc(10, req, len);
    result.writeUInt32(buffers.length);
    result.writeLongString(resBuff);
    for (const buffer of buffers) {
      result.writeBuffer(buffer);
    }
    return result.buffer;
  }
  static deserializeReplyOKJSON(buff) {
    const res = buff.readLongString();
    return JSON.parse(res);
  }
  static deserializeReplyOKJSONWithBuffers(buff, uriTransformer) {
    const bufferCount = buff.readUInt32();
    const res = buff.readLongString();
    const buffers = [];
    for (let i = 0; i < bufferCount; ++i) {
      buffers.push(buff.readVSBuffer());
    }
    return new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(res, buffers, uriTransformer));
  }
  static serializeReplyErr(req, err) {
    const errStr = err ? safeStringify2(transformErrorForSerialization(err), null) : void 0;
    if (typeof errStr !== "string") {
      return this._serializeReplyErrEmpty(req);
    }
    const errBuff = VSBuffer.fromString(errStr);
    let len = 0;
    len += MessageBuffer.sizeLongString(errBuff);
    const result = MessageBuffer.alloc(11, req, len);
    result.writeLongString(errBuff);
    return result.buffer;
  }
  static deserializeReplyErrError(buff) {
    const err = buff.readLongString();
    return JSON.parse(err);
  }
  static _serializeReplyErrEmpty(req) {
    return MessageBuffer.alloc(12, req, 0).buffer;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionHostManager.js
var ExtensionHostManager_1;
function createExtensionHostManager(instantiationService, extensionHost, initialActivationEvents, internalExtensionService) {
  if (extensionHost.startup === 3 && initialActivationEvents.length === 0) {
    return instantiationService.createInstance(LazyCreateExtensionHostManager, extensionHost, internalExtensionService);
  }
  return instantiationService.createInstance(ExtensionHostManager, extensionHost, initialActivationEvents, internalExtensionService);
}
var ExtensionHostManager = ExtensionHostManager_1 = class ExtensionHostManager2 extends Disposable {
  get kind() {
    return this._extensionHost.runningLocation.kind;
  }
  get startup() {
    return this._extensionHost.startup;
  }
  constructor(extensionHost, initialActivationEvents, _internalExtensionService, _instantiationService, _environmentService, _telemetryService, _logService) {
    super();
    this._internalExtensionService = _internalExtensionService;
    this._instantiationService = _instantiationService;
    this._environmentService = _environmentService;
    this._telemetryService = _telemetryService;
    this._logService = _logService;
    this._onDidChangeResponsiveState = this._register(new Emitter());
    this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event;
    this._hasStarted = false;
    this._cachedActivationEvents = /* @__PURE__ */ new Map();
    this._resolvedActivationEvents = /* @__PURE__ */ new Set();
    this._rpcProtocol = null;
    this._customers = [];
    this._extensionHost = extensionHost;
    this.onDidExit = this._extensionHost.onExit;
    const startingTelemetryEvent = {
      time: Date.now(),
      action: "starting",
      kind: extensionHostKindToString(this.kind)
    };
    this._telemetryService.publicLog2("extensionHostStartup", startingTelemetryEvent);
    this._proxy = this._extensionHost.start().then((protocol) => {
      this._hasStarted = true;
      const successTelemetryEvent = {
        time: Date.now(),
        action: "success",
        kind: extensionHostKindToString(this.kind)
      };
      this._telemetryService.publicLog2("extensionHostStartup", successTelemetryEvent);
      return this._createExtensionHostCustomers(this.kind, protocol);
    }, (err) => {
      this._logService.error(`Error received from starting extension host (kind: ${extensionHostKindToString(this.kind)})`);
      this._logService.error(err);
      const failureTelemetryEvent = {
        time: Date.now(),
        action: "error",
        kind: extensionHostKindToString(this.kind)
      };
      if (err && err.name) {
        failureTelemetryEvent.errorName = err.name;
      }
      if (err && err.message) {
        failureTelemetryEvent.errorMessage = err.message;
      }
      if (err && err.stack) {
        failureTelemetryEvent.errorStack = err.stack;
      }
      this._telemetryService.publicLog2("extensionHostStartup", failureTelemetryEvent);
      return null;
    });
    this._proxy.then(() => {
      initialActivationEvents.forEach((activationEvent) => this.activateByEvent(activationEvent, 0));
      this._register(registerLatencyTestProvider({
        measure: () => this.measure()
      }));
    });
  }
  dispose() {
    if (this._extensionHost) {
      this._extensionHost.dispose();
    }
    if (this._rpcProtocol) {
      this._rpcProtocol.dispose();
    }
    for (let i = 0, len = this._customers.length; i < len; i++) {
      const customer = this._customers[i];
      try {
        customer.dispose();
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    this._proxy = null;
    super.dispose();
  }
  async measure() {
    const proxy = await this._proxy;
    if (!proxy) {
      return null;
    }
    const latency = await this._measureLatency(proxy);
    const down = await this._measureDown(proxy);
    const up = await this._measureUp(proxy);
    return {
      remoteAuthority: this._extensionHost.remoteAuthority,
      latency,
      down,
      up
    };
  }
  async ready() {
    await this._proxy;
  }
  async _measureLatency(proxy) {
    const COUNT = 10;
    let sum = 0;
    for (let i = 0; i < COUNT; i++) {
      const sw = StopWatch.create();
      await proxy.test_latency(i);
      sw.stop();
      sum += sw.elapsed();
    }
    return sum / COUNT;
  }
  static _convert(byteCount, elapsedMillis) {
    return byteCount * 1e3 * 8 / elapsedMillis;
  }
  async _measureUp(proxy) {
    const SIZE = 10 * 1024 * 1024;
    const buff = VSBuffer.alloc(SIZE);
    const value = Math.ceil(Math.random() * 256);
    for (let i = 0; i < buff.byteLength; i++) {
      buff.writeUInt8(i, value);
    }
    const sw = StopWatch.create();
    await proxy.test_up(buff);
    sw.stop();
    return ExtensionHostManager_1._convert(SIZE, sw.elapsed());
  }
  async _measureDown(proxy) {
    const SIZE = 10 * 1024 * 1024;
    const sw = StopWatch.create();
    await proxy.test_down(SIZE);
    sw.stop();
    return ExtensionHostManager_1._convert(SIZE, sw.elapsed());
  }
  _createExtensionHostCustomers(kind, protocol) {
    let logger = null;
    if (this._environmentService.logExtensionHostCommunication) {
      logger = new RPCLogger(kind);
    } else if (TelemetryRPCLogger.isEnabled()) {
      logger = new TelemetryRPCLogger(this._telemetryService);
    }
    this._rpcProtocol = new RPCProtocol(protocol, logger);
    this._register(this._rpcProtocol.onDidChangeResponsiveState((responsiveState) => this._onDidChangeResponsiveState.fire(responsiveState)));
    let extensionHostProxy = null;
    const extHostContext = {
      remoteAuthority: this._extensionHost.remoteAuthority,
      extensionHostKind: this.kind,
      getProxy: (identifier) => this._rpcProtocol.getProxy(identifier),
      set: (identifier, instance) => this._rpcProtocol.set(identifier, instance),
      dispose: () => this._rpcProtocol.dispose(),
      assertRegistered: (identifiers) => this._rpcProtocol.assertRegistered(identifiers),
      drain: () => this._rpcProtocol.drain(),
      internalExtensionService: this._internalExtensionService,
      _setExtensionHostProxy: (value) => {
        extensionHostProxy = value;
      },
      _setAllMainProxyIdentifiers: (value) => {
      }
    };
    const namedCustomers = ExtHostCustomersRegistry.getNamedCustomers();
    for (let i = 0, len = namedCustomers.length; i < len; i++) {
      const [id, ctor] = namedCustomers[i];
      try {
        const instance = this._instantiationService.createInstance(ctor, extHostContext);
        this._customers.push(instance);
        this._rpcProtocol.set(id, instance);
      } catch (err) {
        this._logService.error(`Cannot instantiate named customer: '${id.sid}'`);
        this._logService.error(err);
        onUnexpectedError(err);
      }
    }
    const customers = ExtHostCustomersRegistry.getCustomers();
    for (const ctor of customers) {
      try {
        const instance = this._instantiationService.createInstance(ctor, extHostContext);
        this._customers.push(instance);
      } catch (err) {
        this._logService.error(err);
        onUnexpectedError(err);
      }
    }
    if (!extensionHostProxy) {
      throw new Error(`Missing IExtensionHostProxy!`);
    }
    return extensionHostProxy;
  }
  async activate(extension, reason) {
    const proxy = await this._proxy;
    if (!proxy) {
      return false;
    }
    return proxy.activate(extension, reason);
  }
  activateByEvent(activationEvent, activationKind) {
    if (activationKind === 1 && !this._hasStarted) {
      return Promise.resolve();
    }
    if (!this._cachedActivationEvents.has(activationEvent)) {
      this._cachedActivationEvents.set(activationEvent, this._activateByEvent(activationEvent, activationKind));
    }
    return this._cachedActivationEvents.get(activationEvent);
  }
  activationEventIsDone(activationEvent) {
    return this._resolvedActivationEvents.has(activationEvent);
  }
  async _activateByEvent(activationEvent, activationKind) {
    if (!this._proxy) {
      return;
    }
    const proxy = await this._proxy;
    if (!proxy) {
      return;
    }
    await proxy.activateByEvent(activationEvent, activationKind);
    this._resolvedActivationEvents.add(activationEvent);
  }
  async getInspectPort(tryEnableInspector) {
    if (this._extensionHost) {
      if (tryEnableInspector) {
        await this._extensionHost.enableInspectPort();
      }
      const port = this._extensionHost.getInspectPort();
      if (port) {
        return port;
      }
    }
    return 0;
  }
  async resolveAuthority(remoteAuthority, resolveAttempt) {
    const sw = StopWatch.create(false);
    const prefix = () => `[${extensionHostKindToString(this._extensionHost.runningLocation.kind)}${this._extensionHost.runningLocation.affinity}][resolveAuthority(${getRemoteAuthorityPrefix(remoteAuthority)},${resolveAttempt})][${sw.elapsed()}ms] `;
    const logInfo = (msg) => this._logService.info(`${prefix()}${msg}`);
    const logError = (msg, err = void 0) => this._logService.error(`${prefix()}${msg}`, err);
    logInfo(`obtaining proxy...`);
    const proxy = await this._proxy;
    if (!proxy) {
      logError(`no proxy`);
      return {
        type: "error",
        error: {
          message: `Cannot resolve authority`,
          code: RemoteAuthorityResolverErrorCode.Unknown,
          detail: void 0
        }
      };
    }
    logInfo(`invoking...`);
    const intervalLogger = new IntervalTimer();
    try {
      intervalLogger.cancelAndSet(() => logInfo("waiting..."), 1e3);
      const resolverResult = await proxy.resolveAuthority(remoteAuthority, resolveAttempt);
      intervalLogger.dispose();
      if (resolverResult.type === "ok") {
        logInfo(`returned ${resolverResult.value.authority.connectTo}`);
      } else {
        logError(`returned an error`, resolverResult.error);
      }
      return resolverResult;
    } catch (err) {
      intervalLogger.dispose();
      logError(`returned an error`, err);
      return {
        type: "error",
        error: {
          message: err.message,
          code: RemoteAuthorityResolverErrorCode.Unknown,
          detail: err
        }
      };
    }
  }
  async getCanonicalURI(remoteAuthority, uri) {
    const proxy = await this._proxy;
    if (!proxy) {
      throw new Error(`Cannot resolve canonical URI`);
    }
    return proxy.getCanonicalURI(remoteAuthority, uri);
  }
  async start(allExtensions, myExtensions) {
    const proxy = await this._proxy;
    if (!proxy) {
      return;
    }
    const deltaExtensions = this._extensionHost.extensions.set(allExtensions, myExtensions);
    return proxy.startExtensionHost(deltaExtensions);
  }
  async extensionTestsExecute() {
    const proxy = await this._proxy;
    if (!proxy) {
      throw new Error("Could not obtain Extension Host Proxy");
    }
    return proxy.extensionTestsExecute();
  }
  representsRunningLocation(runningLocation) {
    return this._extensionHost.runningLocation.equals(runningLocation);
  }
  async deltaExtensions(extensionsDelta) {
    const proxy = await this._proxy;
    if (!proxy) {
      return;
    }
    this._extensionHost.extensions.delta(extensionsDelta);
    return proxy.deltaExtensions(extensionsDelta);
  }
  containsExtension(extensionId) {
    return this._extensionHost.extensions.containsExtension(extensionId);
  }
  async setRemoteEnvironment(env2) {
    const proxy = await this._proxy;
    if (!proxy) {
      return;
    }
    return proxy.setRemoteEnvironment(env2);
  }
};
ExtensionHostManager = ExtensionHostManager_1 = __decorate([
  __param(3, IInstantiationService),
  __param(4, IWorkbenchEnvironmentService),
  __param(5, ITelemetryService),
  __param(6, ILogService)
], ExtensionHostManager);
var LazyCreateExtensionHostManager = class LazyCreateExtensionHostManager2 extends Disposable {
  get kind() {
    return this._extensionHost.runningLocation.kind;
  }
  get startup() {
    return this._extensionHost.startup;
  }
  constructor(extensionHost, _internalExtensionService, _instantiationService, _logService) {
    super();
    this._internalExtensionService = _internalExtensionService;
    this._instantiationService = _instantiationService;
    this._logService = _logService;
    this._onDidChangeResponsiveState = this._register(new Emitter());
    this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event;
    this._extensionHost = extensionHost;
    this.onDidExit = extensionHost.onExit;
    this._startCalled = new Barrier();
    this._actual = null;
    this._lazyStartExtensions = null;
  }
  _createActual(reason) {
    this._logService.info(`Creating lazy extension host: ${reason}`);
    this._actual = this._register(this._instantiationService.createInstance(ExtensionHostManager, this._extensionHost, [], this._internalExtensionService));
    this._register(this._actual.onDidChangeResponsiveState((e) => this._onDidChangeResponsiveState.fire(e)));
    return this._actual;
  }
  async _getOrCreateActualAndStart(reason) {
    if (this._actual) {
      return this._actual;
    }
    const actual = this._createActual(reason);
    await actual.start([], []);
    return actual;
  }
  async ready() {
    await this._startCalled.wait();
    if (this._actual) {
      await this._actual.ready();
    }
  }
  representsRunningLocation(runningLocation) {
    return this._extensionHost.runningLocation.equals(runningLocation);
  }
  async deltaExtensions(extensionsDelta) {
    await this._startCalled.wait();
    if (this._actual) {
      return this._actual.deltaExtensions(extensionsDelta);
    }
    this._lazyStartExtensions.delta(extensionsDelta);
    if (extensionsDelta.myToAdd.length > 0) {
      const actual = this._createActual(`contains ${extensionsDelta.myToAdd.length} new extension(s) (installed or enabled): ${extensionsDelta.myToAdd.map((extId) => extId.value)}`);
      const { toAdd, myToAdd } = this._lazyStartExtensions.toDelta();
      actual.start(toAdd, myToAdd);
      return;
    }
  }
  containsExtension(extensionId) {
    return this._extensionHost.extensions.containsExtension(extensionId);
  }
  async activate(extension, reason) {
    await this._startCalled.wait();
    if (this._actual) {
      return this._actual.activate(extension, reason);
    }
    return false;
  }
  async activateByEvent(activationEvent, activationKind) {
    if (activationKind === 1) {
      if (this._actual) {
        return this._actual.activateByEvent(activationEvent, activationKind);
      }
      return;
    }
    await this._startCalled.wait();
    if (this._actual) {
      return this._actual.activateByEvent(activationEvent, activationKind);
    }
  }
  activationEventIsDone(activationEvent) {
    if (!this._startCalled.isOpen()) {
      return false;
    }
    if (this._actual) {
      return this._actual.activationEventIsDone(activationEvent);
    }
    return true;
  }
  async getInspectPort(tryEnableInspector) {
    await this._startCalled.wait();
    if (this._actual) {
      return this._actual.getInspectPort(tryEnableInspector);
    }
    return 0;
  }
  async resolveAuthority(remoteAuthority, resolveAttempt) {
    await this._startCalled.wait();
    if (this._actual) {
      return this._actual.resolveAuthority(remoteAuthority, resolveAttempt);
    }
    return {
      type: "error",
      error: {
        message: `Cannot resolve authority`,
        code: RemoteAuthorityResolverErrorCode.Unknown,
        detail: void 0
      }
    };
  }
  async getCanonicalURI(remoteAuthority, uri) {
    await this._startCalled.wait();
    if (this._actual) {
      return this._actual.getCanonicalURI(remoteAuthority, uri);
    }
    throw new Error(`Cannot resolve canonical URI`);
  }
  async start(allExtensions, myExtensions) {
    if (myExtensions.length > 0) {
      const actual = this._createActual(`contains ${myExtensions.length} extension(s): ${myExtensions.map((extId) => extId.value)}.`);
      const result = actual.start(allExtensions, myExtensions);
      this._startCalled.open();
      return result;
    }
    this._lazyStartExtensions = new ExtensionHostExtensions();
    this._lazyStartExtensions.set(allExtensions, myExtensions);
    this._startCalled.open();
  }
  async extensionTestsExecute() {
    await this._startCalled.wait();
    const actual = await this._getOrCreateActualAndStart(`execute tests.`);
    return actual.extensionTestsExecute();
  }
  async setRemoteEnvironment(env2) {
    await this._startCalled.wait();
    if (this._actual) {
      return this._actual.setRemoteEnvironment(env2);
    }
  }
};
LazyCreateExtensionHostManager = __decorate([
  __param(2, IInstantiationService),
  __param(3, ILogService)
], LazyCreateExtensionHostManager);
var colorTables = [
  ["#2977B1", "#FC802D", "#34A13A", "#D3282F", "#9366BA"],
  ["#8B564C", "#E177C0", "#7F7F7F", "#BBBE3D", "#2EBECD"]
];
function prettyWithoutArrays(data) {
  if (Array.isArray(data)) {
    return data;
  }
  if (data && typeof data === "object" && typeof data.toString === "function") {
    const result = data.toString();
    if (result !== "[object Object]") {
      return result;
    }
  }
  return data;
}
function pretty(data) {
  if (Array.isArray(data)) {
    return data.map(prettyWithoutArrays);
  }
  return prettyWithoutArrays(data);
}
var RPCLogger = class {
  constructor(_kind) {
    this._kind = _kind;
    this._totalIncoming = 0;
    this._totalOutgoing = 0;
  }
  _log(direction, totalLength, msgLength, req, initiator, str, data) {
    data = pretty(data);
    const colorTable = colorTables[initiator];
    const color2 = colorTable[req % colorTable.length];
    let args = [`%c[${extensionHostKindToString(this._kind)}][${direction}]%c[${String(totalLength).padStart(7)}]%c[len: ${String(msgLength).padStart(5)}]%c${String(req).padStart(5)} - ${str}`, "color: darkgreen", "color: grey", "color: grey", `color: ${color2}`];
    if (/\($/.test(str)) {
      args = args.concat(data);
      args.push(")");
    } else {
      args.push(data);
    }
    console.log.apply(console, args);
  }
  logIncoming(msgLength, req, initiator, str, data) {
    this._totalIncoming += msgLength;
    this._log("Ext → Win", this._totalIncoming, msgLength, req, initiator, str, data);
  }
  logOutgoing(msgLength, req, initiator, str, data) {
    this._totalOutgoing += msgLength;
    this._log("Win → Ext", this._totalOutgoing, msgLength, req, initiator, str, data);
  }
};
var TelemetryRPCLogger = class TelemetryRPCLogger2 {
  static isEnabled() {
    return Math.trunc(Math.random() * 1e3) < 0.5;
  }
  constructor(_telemetryService) {
    this._telemetryService = _telemetryService;
    this._pendingRequests = /* @__PURE__ */ new Map();
  }
  logIncoming(msgLength, req, initiator, str) {
    if (initiator === 0 && /^receiveReply(Err)?:/.test(str)) {
      const requestStr = this._pendingRequests.get(req) ?? "unknown_reply";
      this._pendingRequests.delete(req);
      this._telemetryService.publicLog2("extensionhost.incoming", {
        type: `${str} ${requestStr}`,
        length: msgLength
      });
    }
    if (initiator === 1 && /^receiveRequest /.test(str)) {
      this._telemetryService.publicLog2("extensionhost.incoming", {
        type: `${str}`,
        length: msgLength
      });
    }
  }
  logOutgoing(msgLength, req, initiator, str) {
    if (initiator === 0 && str.startsWith("request: ")) {
      this._pendingRequests.set(req, str);
      this._telemetryService.publicLog2("extensionhost.outgoing", {
        type: str,
        length: msgLength
      });
    }
  }
};
TelemetryRPCLogger = __decorate([
  __param(0, ITelemetryService)
], TelemetryRPCLogger);
var providers = [];
function registerLatencyTestProvider(provider) {
  providers.push(provider);
  return {
    dispose: () => {
      for (let i = 0; i < providers.length; i++) {
        if (providers[i] === provider) {
          providers.splice(i, 1);
          return;
        }
      }
    }
  };
}
function getLatencyTestProviders() {
  return providers.slice(0);
}
registerAction2(class MeasureExtHostLatencyAction extends Action2 {
  constructor() {
    super({
      id: "editor.action.measureExtHostLatency",
      title: {
        value: localize("measureExtHostLatency", "Measure Extension Host Latency"),
        original: "Measure Extension Host Latency"
      },
      category: Categories.Developer,
      f1: true
    });
  }
  async run(accessor) {
    const editorService = accessor.get(IEditorService);
    const measurements = await Promise.all(getLatencyTestProviders().map((provider) => provider.measure()));
    editorService.openEditor({ resource: void 0, contents: measurements.map(MeasureExtHostLatencyAction._print).join("\n\n"), options: { pinned: true } });
  }
  static _print(m) {
    if (!m) {
      return "";
    }
    return `${m.remoteAuthority ? `Authority: ${m.remoteAuthority}
` : ``}Roundtrip latency: ${m.latency.toFixed(3)}ms
Up: ${MeasureExtHostLatencyAction._printSpeed(m.up)}
Down: ${MeasureExtHostLatencyAction._printSpeed(m.down)}
`;
  }
  static _printSpeed(n2) {
    if (n2 <= 1024) {
      return `${n2} bps`;
    }
    if (n2 < 1024 * 1024) {
      return `${(n2 / 1024).toFixed(1)} kbps`;
    }
    return `${(n2 / 1024 / 1024).toFixed(1)} Mbps`;
  }
});

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionRunningLocation.js
var LocalProcessRunningLocation = class {
  constructor(affinity) {
    this.affinity = affinity;
    this.kind = 1;
  }
  equals(other) {
    return this.kind === other.kind && this.affinity === other.affinity;
  }
  asString() {
    if (this.affinity === 0) {
      return "LocalProcess";
    }
    return `LocalProcess${this.affinity}`;
  }
};
var LocalWebWorkerRunningLocation = class {
  constructor(affinity) {
    this.affinity = affinity;
    this.kind = 2;
  }
  equals(other) {
    return this.kind === other.kind && this.affinity === other.affinity;
  }
  asString() {
    if (this.affinity === 0) {
      return "LocalWebWorker";
    }
    return `LocalWebWorker${this.affinity}`;
  }
};
var RemoteRunningLocation = class {
  constructor() {
    this.kind = 3;
    this.affinity = 0;
  }
  equals(other) {
    return this.kind === other.kind;
  }
  asString() {
    return "Remote";
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionRunningLocationTracker.js
init_tslib_es6();
init_network();
init_configuration();
init_extensions();
init_log();
var ExtensionRunningLocationTracker = class ExtensionRunningLocationTracker2 {
  get maxLocalProcessAffinity() {
    return this._maxLocalProcessAffinity;
  }
  get maxLocalWebWorkerAffinity() {
    return this._maxLocalWebWorkerAffinity;
  }
  constructor(_registry, _extensionHostKindPicker, _environmentService, _configurationService, _logService, _extensionManifestPropertiesService) {
    this._registry = _registry;
    this._extensionHostKindPicker = _extensionHostKindPicker;
    this._environmentService = _environmentService;
    this._configurationService = _configurationService;
    this._logService = _logService;
    this._extensionManifestPropertiesService = _extensionManifestPropertiesService;
    this._runningLocation = new ExtensionIdentifierMap();
    this._maxLocalProcessAffinity = 0;
    this._maxLocalWebWorkerAffinity = 0;
  }
  set(extensionId, runningLocation) {
    this._runningLocation.set(extensionId, runningLocation);
  }
  readExtensionKinds(extensionDescription) {
    if (extensionDescription.isUnderDevelopment && this._environmentService.extensionDevelopmentKind) {
      return this._environmentService.extensionDevelopmentKind;
    }
    return this._extensionManifestPropertiesService.getExtensionKind(extensionDescription);
  }
  getRunningLocation(extensionId) {
    return this._runningLocation.get(extensionId) || null;
  }
  filterByRunningLocation(extensions, desiredRunningLocation) {
    return filterExtensionDescriptions(extensions, this._runningLocation, (extRunningLocation) => desiredRunningLocation.equals(extRunningLocation));
  }
  filterByExtensionHostKind(extensions, desiredExtensionHostKind) {
    return filterExtensionDescriptions(extensions, this._runningLocation, (extRunningLocation) => extRunningLocation.kind === desiredExtensionHostKind);
  }
  filterByExtensionHostManager(extensions, extensionHostManager) {
    return filterExtensionDescriptions(extensions, this._runningLocation, (extRunningLocation) => extensionHostManager.representsRunningLocation(extRunningLocation));
  }
  _computeAffinity(inputExtensions, extensionHostKind, isInitialAllocation) {
    const extensions = new ExtensionIdentifierMap();
    for (const extension of inputExtensions) {
      if (extension.main || extension.browser) {
        extensions.set(extension.identifier, extension);
      }
    }
    for (const extension of this._registry.getAllExtensionDescriptions()) {
      if (extension.main || extension.browser) {
        const runningLocation = this._runningLocation.get(extension.identifier);
        if (runningLocation && runningLocation.kind === extensionHostKind) {
          extensions.set(extension.identifier, extension);
        }
      }
    }
    const groups = new ExtensionIdentifierMap();
    let groupNumber = 0;
    for (const [_, extension] of extensions) {
      groups.set(extension.identifier, ++groupNumber);
    }
    const changeGroup = (from, to) => {
      for (const [key, group] of groups) {
        if (group === from) {
          groups.set(key, to);
        }
      }
    };
    for (const [_, extension] of extensions) {
      if (!extension.extensionDependencies) {
        continue;
      }
      const myGroup = groups.get(extension.identifier);
      for (const depId of extension.extensionDependencies) {
        const depGroup = groups.get(depId);
        if (!depGroup) {
          continue;
        }
        if (depGroup === myGroup) {
          continue;
        }
        changeGroup(depGroup, myGroup);
      }
    }
    const resultingAffinities = /* @__PURE__ */ new Map();
    let lastAffinity = 0;
    for (const [_, extension] of extensions) {
      const runningLocation = this._runningLocation.get(extension.identifier);
      if (runningLocation) {
        const group = groups.get(extension.identifier);
        resultingAffinities.set(group, runningLocation.affinity);
        lastAffinity = Math.max(lastAffinity, runningLocation.affinity);
      }
    }
    if (!this._environmentService.isExtensionDevelopment) {
      const configuredAffinities = this._configurationService.getValue("extensions.experimental.affinity") || {};
      const configuredExtensionIds = Object.keys(configuredAffinities);
      const configuredAffinityToResultingAffinity = /* @__PURE__ */ new Map();
      for (const extensionId of configuredExtensionIds) {
        const configuredAffinity = configuredAffinities[extensionId];
        if (typeof configuredAffinity !== "number" || configuredAffinity <= 0 || Math.floor(configuredAffinity) !== configuredAffinity) {
          this._logService.info(`Ignoring configured affinity for '${extensionId}' because the value is not a positive integer.`);
          continue;
        }
        const group = groups.get(extensionId);
        if (!group) {
          continue;
        }
        const affinity1 = resultingAffinities.get(group);
        if (affinity1) {
          configuredAffinityToResultingAffinity.set(configuredAffinity, affinity1);
          continue;
        }
        const affinity2 = configuredAffinityToResultingAffinity.get(configuredAffinity);
        if (affinity2) {
          resultingAffinities.set(group, affinity2);
          continue;
        }
        if (!isInitialAllocation) {
          this._logService.info(`Ignoring configured affinity for '${extensionId}' because extension host(s) are already running. Reload window.`);
          continue;
        }
        const affinity3 = ++lastAffinity;
        configuredAffinityToResultingAffinity.set(configuredAffinity, affinity3);
        resultingAffinities.set(group, affinity3);
      }
    }
    const result = new ExtensionIdentifierMap();
    for (const extension of inputExtensions) {
      const group = groups.get(extension.identifier) || 0;
      const affinity = resultingAffinities.get(group) || 0;
      result.set(extension.identifier, affinity);
    }
    if (lastAffinity > 0 && isInitialAllocation) {
      for (let affinity = 1; affinity <= lastAffinity; affinity++) {
        const extensionIds = [];
        for (const extension of inputExtensions) {
          if (result.get(extension.identifier) === affinity) {
            extensionIds.push(extension.identifier);
          }
        }
        this._logService.info(`Placing extension(s) ${extensionIds.map((e) => e.value).join(", ")} on a separate extension host.`);
      }
    }
    return { affinities: result, maxAffinity: lastAffinity };
  }
  computeRunningLocation(localExtensions, remoteExtensions, isInitialAllocation) {
    return this._doComputeRunningLocation(this._runningLocation, localExtensions, remoteExtensions, isInitialAllocation).runningLocation;
  }
  _doComputeRunningLocation(existingRunningLocation, localExtensions, remoteExtensions, isInitialAllocation) {
    localExtensions = localExtensions.filter((extension) => !existingRunningLocation.has(extension.identifier));
    remoteExtensions = remoteExtensions.filter((extension) => !existingRunningLocation.has(extension.identifier));
    const extensionHostKinds = determineExtensionHostKinds(localExtensions, remoteExtensions, (extension) => this.readExtensionKinds(extension), (extensionId, extensionKinds, isInstalledLocally, isInstalledRemotely, preference) => this._extensionHostKindPicker.pickExtensionHostKind(extensionId, extensionKinds, isInstalledLocally, isInstalledRemotely, preference));
    const extensions = new ExtensionIdentifierMap();
    for (const extension of localExtensions) {
      extensions.set(extension.identifier, extension);
    }
    for (const extension of remoteExtensions) {
      extensions.set(extension.identifier, extension);
    }
    const result = new ExtensionIdentifierMap();
    const localProcessExtensions = [];
    const localWebWorkerExtensions = [];
    for (const [extensionIdKey, extensionHostKind] of extensionHostKinds) {
      let runningLocation = null;
      if (extensionHostKind === 1) {
        const extensionDescription = extensions.get(extensionIdKey);
        if (extensionDescription) {
          localProcessExtensions.push(extensionDescription);
        }
      } else if (extensionHostKind === 2) {
        const extensionDescription = extensions.get(extensionIdKey);
        if (extensionDescription) {
          localWebWorkerExtensions.push(extensionDescription);
        }
      } else if (extensionHostKind === 3) {
        runningLocation = new RemoteRunningLocation();
      }
      result.set(extensionIdKey, runningLocation);
    }
    const { affinities, maxAffinity } = this._computeAffinity(localProcessExtensions, 1, isInitialAllocation);
    for (const extension of localProcessExtensions) {
      const affinity = affinities.get(extension.identifier) || 0;
      result.set(extension.identifier, new LocalProcessRunningLocation(affinity));
    }
    const { affinities: localWebWorkerAffinities, maxAffinity: maxLocalWebWorkerAffinity } = this._computeAffinity(localWebWorkerExtensions, 2, isInitialAllocation);
    for (const extension of localWebWorkerExtensions) {
      const affinity = localWebWorkerAffinities.get(extension.identifier) || 0;
      result.set(extension.identifier, new LocalWebWorkerRunningLocation(affinity));
    }
    for (const [extensionIdKey, runningLocation] of existingRunningLocation) {
      if (runningLocation) {
        result.set(extensionIdKey, runningLocation);
      }
    }
    return { runningLocation: result, maxLocalProcessAffinity: maxAffinity, maxLocalWebWorkerAffinity };
  }
  initializeRunningLocation(localExtensions, remoteExtensions) {
    const { runningLocation, maxLocalProcessAffinity, maxLocalWebWorkerAffinity } = this._doComputeRunningLocation(this._runningLocation, localExtensions, remoteExtensions, true);
    this._runningLocation = runningLocation;
    this._maxLocalProcessAffinity = maxLocalProcessAffinity;
    this._maxLocalWebWorkerAffinity = maxLocalWebWorkerAffinity;
  }
  deltaExtensions(toAdd, toRemove) {
    const removedRunningLocation = new ExtensionIdentifierMap();
    for (const extensionId of toRemove) {
      const extensionKey = extensionId;
      removedRunningLocation.set(extensionKey, this._runningLocation.get(extensionKey) || null);
      this._runningLocation.delete(extensionKey);
    }
    this._updateRunningLocationForAddedExtensions(toAdd);
    return removedRunningLocation;
  }
  _updateRunningLocationForAddedExtensions(toAdd) {
    const localProcessExtensions = [];
    const localWebWorkerExtensions = [];
    for (const extension of toAdd) {
      const extensionKind = this.readExtensionKinds(extension);
      const isRemote = extension.extensionLocation.scheme === Schemas.vscodeRemote;
      const extensionHostKind = this._extensionHostKindPicker.pickExtensionHostKind(extension.identifier, extensionKind, !isRemote, isRemote, 0);
      let runningLocation = null;
      if (extensionHostKind === 1) {
        localProcessExtensions.push(extension);
      } else if (extensionHostKind === 2) {
        localWebWorkerExtensions.push(extension);
      } else if (extensionHostKind === 3) {
        runningLocation = new RemoteRunningLocation();
      }
      this._runningLocation.set(extension.identifier, runningLocation);
    }
    const { affinities } = this._computeAffinity(localProcessExtensions, 1, false);
    for (const extension of localProcessExtensions) {
      const affinity = affinities.get(extension.identifier) || 0;
      this._runningLocation.set(extension.identifier, new LocalProcessRunningLocation(affinity));
    }
    const { affinities: webWorkerExtensionsAffinities } = this._computeAffinity(localWebWorkerExtensions, 2, false);
    for (const extension of localWebWorkerExtensions) {
      const affinity = webWorkerExtensionsAffinities.get(extension.identifier) || 0;
      this._runningLocation.set(extension.identifier, new LocalWebWorkerRunningLocation(affinity));
    }
  }
};
ExtensionRunningLocationTracker = __decorate([
  __param(2, IWorkbenchEnvironmentService),
  __param(3, IConfigurationService),
  __param(4, ILogService),
  __param(5, IExtensionManifestPropertiesService)
], ExtensionRunningLocationTracker);
function filterExtensionDescriptions(extensions, runningLocation, predicate) {
  return extensions.filter((ext) => {
    const extRunningLocation = runningLocation.get(ext.identifier);
    return extRunningLocation && predicate(extRunningLocation);
  });
}
function filterExtensionIdentifiers(extensions, runningLocation, predicate) {
  return extensions.filter((ext) => {
    const extRunningLocation = runningLocation.get(ext);
    return extRunningLocation && predicate(extRunningLocation);
  });
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/workspaceContains.js
init_resources();
init_uri();
init_cancellation();
init_errors();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/services/search/common/queryBuilder.js
init_tslib_es6();
init_arrays();
init_map();
init_network();
init_path();
init_resources();
init_strings();
init_types();
init_uri();
init_textModelSearch();
init_nls();
init_configuration();
init_log();
var QueryBuilder = class QueryBuilder2 {
  constructor(configurationService, workspaceContextService, editorGroupsService, logService, pathService) {
    this.configurationService = configurationService;
    this.workspaceContextService = workspaceContextService;
    this.editorGroupsService = editorGroupsService;
    this.logService = logService;
    this.pathService = pathService;
  }
  text(contentPattern, folderResources, options = {}) {
    contentPattern = this.getContentPattern(contentPattern, options);
    const searchConfig = this.configurationService.getValue();
    const fallbackToPCRE = folderResources && folderResources.some((folder) => {
      const folderConfig = this.configurationService.getValue({ resource: folder });
      return !folderConfig.search.useRipgrep;
    });
    const commonQuery = this.commonQuery(folderResources == null ? void 0 : folderResources.map(toWorkspaceFolder), options);
    return {
      ...commonQuery,
      type: 2,
      contentPattern,
      previewOptions: options.previewOptions,
      maxFileSize: options.maxFileSize,
      usePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false,
      beforeContext: options.beforeContext,
      afterContext: options.afterContext,
      userDisabledExcludesAndIgnoreFiles: options.disregardExcludeSettings && options.disregardIgnoreFiles
    };
  }
  getContentPattern(inputPattern, options) {
    var _a30, _b, _c, _d;
    const searchConfig = this.configurationService.getValue();
    if (inputPattern.isRegExp) {
      inputPattern.pattern = inputPattern.pattern.replace(/\r?\n/g, "\\n");
    }
    const newPattern = {
      ...inputPattern,
      wordSeparators: searchConfig.editor.wordSeparators
    };
    if (this.isCaseSensitive(inputPattern, options)) {
      newPattern.isCaseSensitive = true;
    }
    if (this.isMultiline(inputPattern)) {
      newPattern.isMultiline = true;
    }
    if ((_a30 = options.notebookSearchConfig) == null ? void 0 : _a30.includeMarkupInput) {
      if (!newPattern.notebookInfo) {
        newPattern.notebookInfo = {};
      }
      newPattern.notebookInfo.isInNotebookMarkdownInput = options.notebookSearchConfig.includeMarkupInput;
    }
    if ((_b = options.notebookSearchConfig) == null ? void 0 : _b.includeMarkupPreview) {
      if (!newPattern.notebookInfo) {
        newPattern.notebookInfo = {};
      }
      newPattern.notebookInfo.isInNotebookMarkdownPreview = options.notebookSearchConfig.includeMarkupPreview;
    }
    if ((_c = options.notebookSearchConfig) == null ? void 0 : _c.includeCodeInput) {
      if (!newPattern.notebookInfo) {
        newPattern.notebookInfo = {};
      }
      newPattern.notebookInfo.isInNotebookCellInput = options.notebookSearchConfig.includeCodeInput;
    }
    if ((_d = options.notebookSearchConfig) == null ? void 0 : _d.includeOutput) {
      if (!newPattern.notebookInfo) {
        newPattern.notebookInfo = {};
      }
      newPattern.notebookInfo.isInNotebookCellOutput = options.notebookSearchConfig.includeOutput;
    }
    return newPattern;
  }
  file(folders, options = {}) {
    const commonQuery = this.commonQuery(folders, options);
    return {
      ...commonQuery,
      type: 1,
      filePattern: options.filePattern ? options.filePattern.trim() : options.filePattern,
      exists: options.exists,
      sortByScore: options.sortByScore,
      cacheKey: options.cacheKey
    };
  }
  handleIncludeExclude(pattern, expandPatterns) {
    if (!pattern) {
      return {};
    }
    pattern = Array.isArray(pattern) ? pattern.map(normalizeSlashes) : normalizeSlashes(pattern);
    return expandPatterns ? this.parseSearchPaths(pattern) : { pattern: patternListToIExpression(...Array.isArray(pattern) ? pattern : [pattern]) };
  }
  commonQuery(folderResources = [], options = {}) {
    const includeSearchPathsInfo = this.handleIncludeExclude(options.includePattern, options.expandPatterns);
    const excludeSearchPathsInfo = this.handleIncludeExclude(options.excludePattern, options.expandPatterns);
    const includeFolderName = folderResources.length > 1;
    const folderQueries = (includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length ? includeSearchPathsInfo.searchPaths.map(
      (searchPath) => this.getFolderQueryForSearchPath(searchPath, options, excludeSearchPathsInfo)
    ) : folderResources.map(
      (folder) => this.getFolderQueryForRoot(folder, options, excludeSearchPathsInfo, includeFolderName)
    )).filter((query) => !!query);
    const queryProps = {
      _reason: options._reason,
      folderQueries,
      usingSearchPaths: !!(includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length),
      extraFileResources: options.extraFileResources,
      excludePattern: excludeSearchPathsInfo.pattern,
      includePattern: includeSearchPathsInfo.pattern,
      onlyOpenEditors: options.onlyOpenEditors,
      maxResults: options.maxResults
    };
    if (options.onlyOpenEditors) {
      const openEditors = coalesce(flatten(this.editorGroupsService.groups.map((group) => group.editors.map((editor) => editor.resource))));
      this.logService.trace("QueryBuilder#commonQuery - openEditor URIs", JSON.stringify(openEditors));
      const openEditorsInQuery = openEditors.filter((editor) => pathIncludedInQuery(queryProps, editor.fsPath));
      const openEditorsQueryProps = this.commonQueryFromFileList(openEditorsInQuery);
      this.logService.trace("QueryBuilder#commonQuery - openEditor Query", JSON.stringify(openEditorsQueryProps));
      return { ...queryProps, ...openEditorsQueryProps };
    }
    const extraFileResources = options.extraFileResources && options.extraFileResources.filter((extraFile) => pathIncludedInQuery(queryProps, extraFile.fsPath));
    queryProps.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : void 0;
    return queryProps;
  }
  commonQueryFromFileList(files) {
    const folderQueries = [];
    const foldersToSearch = new ResourceMap();
    const includePattern = {};
    let hasIncludedFile = false;
    files.forEach((file) => {
      var _a30;
      if (file.scheme === Schemas.walkThrough) {
        return;
      }
      const providerExists = isAbsolutePath(file);
      if (providerExists) {
        const searchRoot = ((_a30 = this.workspaceContextService.getWorkspaceFolder(file)) == null ? void 0 : _a30.uri) ?? file.with({ path: dirname(file.fsPath) });
        let folderQuery = foldersToSearch.get(searchRoot);
        if (!folderQuery) {
          hasIncludedFile = true;
          folderQuery = { folder: searchRoot, includePattern: {} };
          folderQueries.push(folderQuery);
          foldersToSearch.set(searchRoot, folderQuery);
        }
        const relPath = relative(searchRoot.fsPath, file.fsPath);
        assertIsDefined(folderQuery.includePattern)[relPath.replace(/\\/g, "/")] = true;
      } else {
        if (file.fsPath) {
          hasIncludedFile = true;
          includePattern[file.fsPath] = true;
        }
      }
    });
    return {
      folderQueries,
      includePattern,
      usingSearchPaths: true,
      excludePattern: hasIncludedFile ? void 0 : { "**/*": true }
    };
  }
  isCaseSensitive(contentPattern, options) {
    if (options.isSmartCase) {
      if (contentPattern.isRegExp) {
        if (containsUppercaseCharacter(contentPattern.pattern, true)) {
          return true;
        }
      } else if (containsUppercaseCharacter(contentPattern.pattern)) {
        return true;
      }
    }
    return !!contentPattern.isCaseSensitive;
  }
  isMultiline(contentPattern) {
    if (contentPattern.isMultiline) {
      return true;
    }
    if (contentPattern.isRegExp && isMultilineRegexSource(contentPattern.pattern)) {
      return true;
    }
    if (contentPattern.pattern.indexOf("\n") >= 0) {
      return true;
    }
    return !!contentPattern.isMultiline;
  }
  parseSearchPaths(pattern) {
    const isSearchPath = (segment) => {
      return isAbsolute(segment) || /^\.\.?([\/\\]|$)/.test(segment);
    };
    const patterns = Array.isArray(pattern) ? pattern : splitGlobPattern(pattern);
    const segments = patterns.map((segment) => {
      const userHome = this.pathService.resolvedUserHome;
      if (userHome) {
        return untildify(segment, userHome.scheme === Schemas.file ? userHome.fsPath : userHome.path);
      }
      return segment;
    });
    const groups = groupBy2(segments, (segment) => isSearchPath(segment) ? "searchPaths" : "exprSegments");
    const expandedExprSegments = (groups.exprSegments || []).map((s) => rtrim(s, "/")).map((s) => rtrim(s, "\\")).map((p) => {
      if (p[0] === ".") {
        p = "*" + p;
      }
      return expandGlobalGlob(p);
    });
    const result = {};
    const searchPaths = this.expandSearchPathPatterns(groups.searchPaths || []);
    if (searchPaths && searchPaths.length) {
      result.searchPaths = searchPaths;
    }
    const exprSegments = flatten(expandedExprSegments);
    const includePattern = patternListToIExpression(...exprSegments);
    if (includePattern) {
      result.pattern = includePattern;
    }
    return result;
  }
  getExcludesForFolder(folderConfig, options) {
    return options.disregardExcludeSettings ? void 0 : getExcludes(folderConfig, !options.disregardSearchExcludeSettings);
  }
  expandSearchPathPatterns(searchPaths) {
    if (!searchPaths || !searchPaths.length) {
      return [];
    }
    const expandedSearchPaths = searchPaths.flatMap((searchPath) => {
      let { pathPortion, globPortion } = splitGlobFromPath(searchPath);
      if (globPortion) {
        globPortion = normalizeGlobPattern(globPortion);
      }
      const oneExpanded = this.expandOneSearchPath(pathPortion);
      return oneExpanded.flatMap((oneExpandedResult) => this.resolveOneSearchPathPattern(oneExpandedResult, globPortion));
    });
    const searchPathPatternMap = /* @__PURE__ */ new Map();
    expandedSearchPaths.forEach((oneSearchPathPattern) => {
      const key = oneSearchPathPattern.searchPath.toString();
      const existing = searchPathPatternMap.get(key);
      if (existing) {
        if (oneSearchPathPattern.pattern) {
          existing.pattern = existing.pattern || {};
          existing.pattern[oneSearchPathPattern.pattern] = true;
        }
      } else {
        searchPathPatternMap.set(key, {
          searchPath: oneSearchPathPattern.searchPath,
          pattern: oneSearchPathPattern.pattern ? patternListToIExpression(oneSearchPathPattern.pattern) : void 0
        });
      }
    });
    return Array.from(searchPathPatternMap.values());
  }
  expandOneSearchPath(searchPath) {
    if (isAbsolute(searchPath)) {
      const workspaceFolders = this.workspaceContextService.getWorkspace().folders;
      if (workspaceFolders[0] && workspaceFolders[0].uri.scheme !== Schemas.file) {
        return [{
          searchPath: workspaceFolders[0].uri.with({ path: searchPath })
        }];
      }
      return [{
        searchPath: URI.file(normalize(searchPath))
      }];
    }
    if (this.workspaceContextService.getWorkbenchState() === 2) {
      const workspaceUri = this.workspaceContextService.getWorkspace().folders[0].uri;
      searchPath = normalizeSlashes(searchPath);
      if (searchPath.startsWith("../") || searchPath === "..") {
        const resolvedPath = posix.resolve(workspaceUri.path, searchPath);
        return [{
          searchPath: workspaceUri.with({ path: resolvedPath })
        }];
      }
      const cleanedPattern = normalizeGlobPattern(searchPath);
      return [{
        searchPath: workspaceUri,
        pattern: cleanedPattern
      }];
    } else if (searchPath === "./" || searchPath === ".\\") {
      return [];
    } else {
      const searchPathWithoutDotSlash = searchPath.replace(/^\.[\/\\]/, "");
      const folders = this.workspaceContextService.getWorkspace().folders;
      const folderMatches = folders.map((folder) => {
        const match = searchPathWithoutDotSlash.match(new RegExp(`^${escapeRegExpCharacters(folder.name)}(?:/(.*)|$)`));
        return match ? {
          match,
          folder
        } : null;
      }).filter(isDefined);
      if (folderMatches.length) {
        return folderMatches.map((match) => {
          const patternMatch = match.match[1];
          return {
            searchPath: match.folder.uri,
            pattern: patternMatch && normalizeGlobPattern(patternMatch)
          };
        });
      } else {
        const probableWorkspaceFolderNameMatch = searchPath.match(/\.[\/\\](.+)[\/\\]?/);
        const probableWorkspaceFolderName = probableWorkspaceFolderNameMatch ? probableWorkspaceFolderNameMatch[1] : searchPath;
        const searchPathNotFoundError = localize(
          "search.noWorkspaceWithName",
          "Workspace folder does not exist: {0}",
          probableWorkspaceFolderName
        );
        throw new Error(searchPathNotFoundError);
      }
    }
  }
  resolveOneSearchPathPattern(oneExpandedResult, globPortion) {
    const pattern = oneExpandedResult.pattern && globPortion ? `${oneExpandedResult.pattern}/${globPortion}` : oneExpandedResult.pattern || globPortion;
    const results = [
      {
        searchPath: oneExpandedResult.searchPath,
        pattern
      }
    ];
    if (pattern && !pattern.endsWith("**")) {
      results.push({
        searchPath: oneExpandedResult.searchPath,
        pattern: pattern + "/**"
      });
    }
    return results;
  }
  getFolderQueryForSearchPath(searchPath, options, searchPathExcludes) {
    const rootConfig = this.getFolderQueryForRoot(toWorkspaceFolder(searchPath.searchPath), options, searchPathExcludes, false);
    if (!rootConfig) {
      return null;
    }
    return {
      ...rootConfig,
      ...{
        includePattern: searchPath.pattern
      }
    };
  }
  getFolderQueryForRoot(folder, options, searchPathExcludes, includeFolderName) {
    let thisFolderExcludeSearchPathPattern;
    const folderUri = URI.isUri(folder) ? folder : folder.uri;
    if (searchPathExcludes.searchPaths) {
      const thisFolderExcludeSearchPath = searchPathExcludes.searchPaths.filter((sp) => isEqual(sp.searchPath, folderUri))[0];
      if (thisFolderExcludeSearchPath && !thisFolderExcludeSearchPath.pattern) {
        return null;
      } else if (thisFolderExcludeSearchPath) {
        thisFolderExcludeSearchPathPattern = thisFolderExcludeSearchPath.pattern;
      }
    }
    const folderConfig = this.configurationService.getValue({ resource: folderUri });
    const settingExcludes = this.getExcludesForFolder(folderConfig, options);
    const excludePattern = {
      ...settingExcludes || {},
      ...thisFolderExcludeSearchPathPattern || {}
    };
    const folderName = URI.isUri(folder) ? basename2(folder) : folder.name;
    return {
      folder: folderUri,
      folderName: includeFolderName ? folderName : void 0,
      excludePattern: Object.keys(excludePattern).length > 0 ? excludePattern : void 0,
      fileEncoding: folderConfig.files && folderConfig.files.encoding,
      disregardIgnoreFiles: typeof options.disregardIgnoreFiles === "boolean" ? options.disregardIgnoreFiles : !folderConfig.search.useIgnoreFiles,
      disregardGlobalIgnoreFiles: typeof options.disregardGlobalIgnoreFiles === "boolean" ? options.disregardGlobalIgnoreFiles : !folderConfig.search.useGlobalIgnoreFiles,
      disregardParentIgnoreFiles: typeof options.disregardParentIgnoreFiles === "boolean" ? options.disregardParentIgnoreFiles : !folderConfig.search.useParentIgnoreFiles,
      ignoreSymlinks: typeof options.ignoreSymlinks === "boolean" ? options.ignoreSymlinks : !folderConfig.search.followSymlinks
    };
  }
};
QueryBuilder = __decorate([
  __param(0, IConfigurationService),
  __param(1, IWorkspaceContextService),
  __param(2, IEditorGroupsService),
  __param(3, ILogService),
  __param(4, IPathService)
], QueryBuilder);
function splitGlobFromPath(searchPath) {
  const globCharMatch = searchPath.match(/[\*\{\}\(\)\[\]\?]/);
  if (globCharMatch) {
    const globCharIdx = globCharMatch.index;
    const lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\][^/\\]*$/);
    if (lastSlashMatch) {
      let pathPortion = searchPath.substr(0, lastSlashMatch.index);
      if (!pathPortion.match(/[/\\]/)) {
        pathPortion += "/";
      }
      return {
        pathPortion,
        globPortion: searchPath.substr((lastSlashMatch.index || 0) + 1)
      };
    }
  }
  return {
    pathPortion: searchPath
  };
}
function patternListToIExpression(...patterns) {
  return patterns.length ? patterns.reduce((glob, cur) => {
    glob[cur] = true;
    return glob;
  }, /* @__PURE__ */ Object.create(null)) : void 0;
}
function splitGlobPattern(pattern) {
  return splitGlobAware(pattern, ",").map((s) => s.trim()).filter((s) => !!s.length);
}
function expandGlobalGlob(pattern) {
  const patterns = [
    `**/${pattern}/**`,
    `**/${pattern}`
  ];
  return patterns.map((p) => p.replace(/\*\*\/\*\*/g, "**"));
}
function normalizeSlashes(pattern) {
  return pattern.replace(/\\/g, "/");
}
function normalizeGlobPattern(pattern) {
  return normalizeSlashes(pattern).replace(/^\.\//, "").replace(/\/+$/g, "");
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/workspaceContains.js
var WORKSPACE_CONTAINS_TIMEOUT = 7e3;
function checkActivateWorkspaceContainsExtension(host, desc) {
  const activationEvents = desc.activationEvents;
  if (!activationEvents) {
    return Promise.resolve(void 0);
  }
  const fileNames = [];
  const globPatterns = [];
  for (const activationEvent of activationEvents) {
    if (/^workspaceContains:/.test(activationEvent)) {
      const fileNameOrGlob = activationEvent.substr("workspaceContains:".length);
      if (fileNameOrGlob.indexOf("*") >= 0 || fileNameOrGlob.indexOf("?") >= 0 || host.forceUsingSearch) {
        globPatterns.push(fileNameOrGlob);
      } else {
        fileNames.push(fileNameOrGlob);
      }
    }
  }
  if (fileNames.length === 0 && globPatterns.length === 0) {
    return Promise.resolve(void 0);
  }
  let resolveResult;
  const result = new Promise((resolve, reject) => {
    resolveResult = resolve;
  });
  const activate = (activationEvent) => resolveResult({ activationEvent });
  const fileNamePromise = Promise.all(fileNames.map((fileName) => _activateIfFileName(host, fileName, activate))).then(() => {
  });
  const globPatternPromise = _activateIfGlobPatterns(host, desc.identifier, globPatterns, activate);
  Promise.all([fileNamePromise, globPatternPromise]).then(() => {
    resolveResult(void 0);
  });
  return result;
}
async function _activateIfFileName(host, fileName, activate) {
  for (const uri of host.folders) {
    if (await host.exists(joinPath(URI.revive(uri), fileName))) {
      activate(`workspaceContains:${fileName}`);
      return;
    }
  }
}
async function _activateIfGlobPatterns(host, extensionId, globPatterns, activate) {
  if (globPatterns.length === 0) {
    return Promise.resolve(void 0);
  }
  const tokenSource = new CancellationTokenSource();
  const searchP = host.checkExists(host.folders, globPatterns, tokenSource.token);
  const timer = setTimeout(async () => {
    tokenSource.cancel();
    host.logService.info(`Not activating extension '${extensionId.value}': Timed out while searching for 'workspaceContains' pattern ${globPatterns.join(",")}`);
  }, WORKSPACE_CONTAINS_TIMEOUT);
  let exists = false;
  try {
    exists = await searchP;
  } catch (err) {
    if (!isCancellationError(err)) {
      onUnexpectedError(err);
    }
  }
  tokenSource.dispose();
  clearTimeout(timer);
  if (exists) {
    activate(`workspaceContains:${globPatterns.join(",")}`);
  }
}
function checkGlobFileExists(accessor, folders, includes2, token) {
  const instantiationService = accessor.get(IInstantiationService);
  const searchService = accessor.get(ISearchService);
  const queryBuilder = instantiationService.createInstance(QueryBuilder);
  const query = queryBuilder.file(folders.map((folder) => toWorkspaceFolder(URI.revive(folder))), {
    _reason: "checkExists",
    includePattern: includes2,
    exists: true
  });
  return searchService.fileSearch(query, token).then((result) => {
    return !!result.limitHit;
  }, (err) => {
    if (!isCancellationError(err)) {
      return Promise.reject(err);
    }
    return false;
  });
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/abstractExtensionService.js
var AbstractExtensionService_1;
var hasOwnProperty = Object.hasOwnProperty;
var NO_OP_VOID_PROMISE = Promise.resolve(void 0);
var AbstractExtensionService = AbstractExtensionService_1 = class AbstractExtensionService2 extends Disposable {
  constructor(_extensionsProposedApi, _extensionHostFactory, _extensionHostKindPicker, _instantiationService, _notificationService, _environmentService, _telemetryService, _extensionEnablementService, _fileService, _productService, _extensionManagementService, _contextService, _configurationService, _extensionManifestPropertiesService, _logService, _remoteAgentService, _remoteExtensionsScannerService, _lifecycleService, _remoteAuthorityResolverService, _dialogService) {
    super();
    this._extensionsProposedApi = _extensionsProposedApi;
    this._extensionHostFactory = _extensionHostFactory;
    this._extensionHostKindPicker = _extensionHostKindPicker;
    this._instantiationService = _instantiationService;
    this._notificationService = _notificationService;
    this._environmentService = _environmentService;
    this._telemetryService = _telemetryService;
    this._extensionEnablementService = _extensionEnablementService;
    this._fileService = _fileService;
    this._productService = _productService;
    this._extensionManagementService = _extensionManagementService;
    this._contextService = _contextService;
    this._configurationService = _configurationService;
    this._extensionManifestPropertiesService = _extensionManifestPropertiesService;
    this._logService = _logService;
    this._remoteAgentService = _remoteAgentService;
    this._remoteExtensionsScannerService = _remoteExtensionsScannerService;
    this._lifecycleService = _lifecycleService;
    this._remoteAuthorityResolverService = _remoteAuthorityResolverService;
    this._dialogService = _dialogService;
    this._onDidRegisterExtensions = this._register(new Emitter());
    this.onDidRegisterExtensions = this._onDidRegisterExtensions.event;
    this._onDidChangeExtensionsStatus = this._register(new Emitter());
    this.onDidChangeExtensionsStatus = this._onDidChangeExtensionsStatus.event;
    this._onDidChangeExtensions = this._register(new Emitter({ leakWarningThreshold: 400 }));
    this.onDidChangeExtensions = this._onDidChangeExtensions.event;
    this._onWillActivateByEvent = this._register(new Emitter());
    this.onWillActivateByEvent = this._onWillActivateByEvent.event;
    this._onDidChangeResponsiveChange = this._register(new Emitter());
    this.onDidChangeResponsiveChange = this._onDidChangeResponsiveChange.event;
    this._onWillStop = this._register(new Emitter());
    this.onWillStop = this._onWillStop.event;
    this._activationEventReader = new ImplicitActivationAwareReader();
    this._registry = new LockableExtensionDescriptionRegistry(this._activationEventReader);
    this._installedExtensionsReady = new Barrier();
    this._extensionStatus = new ExtensionIdentifierMap();
    this._allRequestedActivateEvents = /* @__PURE__ */ new Set();
    this._remoteCrashTracker = new ExtensionHostCrashTracker();
    this._deltaExtensionsQueue = [];
    this._inHandleDeltaExtensions = false;
    this._extensionHostManagers = [];
    this._resolveAuthorityAttempt = 0;
    this._register(this._fileService.onWillActivateFileSystemProvider((e) => {
      if (e.scheme !== Schemas.vscodeRemote) {
        e.join(this.activateByEvent(`onFileSystem:${e.scheme}`));
      }
    }));
    this._runningLocations = new ExtensionRunningLocationTracker(
      this._registry,
      this._extensionHostKindPicker,
      this._environmentService,
      this._configurationService,
      this._logService,
      this._extensionManifestPropertiesService
    );
    this._register(this._extensionEnablementService.onEnablementChanged((extensions) => {
      const toAdd = [];
      const toRemove = [];
      for (const extension of extensions) {
        if (this._safeInvokeIsEnabled(extension)) {
          toAdd.push(extension);
        } else {
          toRemove.push(extension);
        }
      }
      this._handleDeltaExtensions(new DeltaExtensionsQueueItem(toAdd, toRemove));
    }));
    this._register(this._extensionManagementService.onDidChangeProfile(({ added, removed }) => {
      if (added.length || removed.length) {
        this._handleDeltaExtensions(new DeltaExtensionsQueueItem(added, removed));
      }
    }));
    this._register(this._extensionManagementService.onDidInstallExtensions((result) => {
      const extensions = [];
      for (const { local, operation } of result) {
        if (local && operation !== 4 && this._safeInvokeIsEnabled(local)) {
          extensions.push(local);
        }
      }
      if (extensions.length) {
        this._handleDeltaExtensions(new DeltaExtensionsQueueItem(extensions, []));
      }
    }));
    this._register(this._extensionManagementService.onDidUninstallExtension((event) => {
      if (!event.error) {
        this._handleDeltaExtensions(new DeltaExtensionsQueueItem([], [event.identifier.id]));
      }
    }));
    this._register(this._lifecycleService.onDidShutdown(() => {
      const connection = this._remoteAgentService.getConnection();
      connection == null ? void 0 : connection.dispose();
      this._doStopExtensionHosts();
    }));
  }
  _getExtensionHostManagers(kind) {
    return this._extensionHostManagers.filter((extHostManager) => extHostManager.kind === kind);
  }
  _getExtensionHostManagerByRunningLocation(runningLocation) {
    for (const extensionHostManager of this._extensionHostManagers) {
      if (extensionHostManager.representsRunningLocation(runningLocation)) {
        return extensionHostManager;
      }
    }
    return null;
  }
  async _handleDeltaExtensions(item) {
    this._deltaExtensionsQueue.push(item);
    if (this._inHandleDeltaExtensions) {
      return;
    }
    let lock = null;
    try {
      this._inHandleDeltaExtensions = true;
      await this._installedExtensionsReady.wait();
      lock = await this._registry.acquireLock("handleDeltaExtensions");
      while (this._deltaExtensionsQueue.length > 0) {
        const item2 = this._deltaExtensionsQueue.shift();
        await this._deltaExtensions(lock, item2.toAdd, item2.toRemove);
      }
    } finally {
      this._inHandleDeltaExtensions = false;
      lock == null ? void 0 : lock.dispose();
    }
  }
  async _deltaExtensions(lock, _toAdd, _toRemove) {
    let toRemove = [];
    for (let i = 0, len = _toRemove.length; i < len; i++) {
      const extensionOrId = _toRemove[i];
      const extensionId = typeof extensionOrId === "string" ? extensionOrId : extensionOrId.identifier.id;
      const extension = typeof extensionOrId === "string" ? null : extensionOrId;
      const extensionDescription = this._registry.getExtensionDescription(extensionId);
      if (!extensionDescription) {
        continue;
      }
      if (extension && extensionDescription.extensionLocation.scheme !== extension.location.scheme) {
        continue;
      }
      if (!this.canRemoveExtension(extensionDescription)) {
        continue;
      }
      toRemove.push(extensionDescription);
    }
    const toAdd = [];
    for (let i = 0, len = _toAdd.length; i < len; i++) {
      const extension = _toAdd[i];
      const extensionDescription = await this._scanSingleExtension(extension);
      if (!extensionDescription) {
        continue;
      }
      if (!this._canAddExtension(extensionDescription, toRemove)) {
        continue;
      }
      toAdd.push(extensionDescription);
    }
    if (toAdd.length === 0 && toRemove.length === 0) {
      return;
    }
    const result = this._registry.deltaExtensions(lock, toAdd, toRemove.map((e) => e.identifier));
    this._onDidChangeExtensions.fire({ added: toAdd, removed: toRemove });
    toRemove = toRemove.concat(result.removedDueToLooping);
    if (result.removedDueToLooping.length > 0) {
      this._notificationService.notify({
        severity: Severity.Error,
        message: localize(
          "looping",
          "The following extensions contain dependency loops and have been disabled: {0}",
          result.removedDueToLooping.map((e) => `'${e.identifier.value}'`).join(", ")
        )
      });
    }
    this._doHandleExtensionPoints([].concat(toAdd).concat(toRemove));
    await this._updateExtensionsOnExtHosts(toAdd, toRemove.map((e) => e.identifier));
    for (let i = 0; i < toAdd.length; i++) {
      this._activateAddedExtensionIfNeeded(toAdd[i]);
    }
  }
  async _updateExtensionsOnExtHosts(toAdd, toRemove) {
    const removedRunningLocation = this._runningLocations.deltaExtensions(toAdd, toRemove);
    const promises = this._extensionHostManagers.map(
      (extHostManager) => this._updateExtensionsOnExtHost(extHostManager, toAdd, toRemove, removedRunningLocation)
    );
    await Promise.all(promises);
  }
  async _updateExtensionsOnExtHost(extensionHostManager, toAdd, toRemove, removedRunningLocation) {
    const myToAdd = this._runningLocations.filterByExtensionHostManager(toAdd, extensionHostManager);
    const myToRemove = filterExtensionIdentifiers(toRemove, removedRunningLocation, (extRunningLocation) => extensionHostManager.representsRunningLocation(extRunningLocation));
    const addActivationEvents = ImplicitActivationEvents.createActivationEventsMap(toAdd);
    await extensionHostManager.deltaExtensions({ toRemove, toAdd, addActivationEvents, myToRemove, myToAdd: myToAdd.map((extension) => extension.identifier) });
  }
  canAddExtension(extension) {
    return this._canAddExtension(extension, []);
  }
  _canAddExtension(extension, extensionsBeingRemoved) {
    const existing = this._registry.getExtensionDescriptionByIdOrUUID(extension.identifier, extension.id);
    if (existing) {
      const isBeingRemoved = extensionsBeingRemoved.some(
        (extensionDescription) => ExtensionIdentifier.equals(extension.identifier, extensionDescription.identifier)
      );
      if (!isBeingRemoved) {
        return false;
      }
    }
    const extensionKinds = this._runningLocations.readExtensionKinds(extension);
    const isRemote = extension.extensionLocation.scheme === Schemas.vscodeRemote;
    const extensionHostKind = this._extensionHostKindPicker.pickExtensionHostKind(extension.identifier, extensionKinds, !isRemote, isRemote, 0);
    if (extensionHostKind === null) {
      return false;
    }
    return true;
  }
  canRemoveExtension(extension) {
    var _a30;
    const extensionDescription = this._registry.getExtensionDescription(extension.identifier);
    if (!extensionDescription) {
      return false;
    }
    if ((_a30 = this._extensionStatus.get(extensionDescription.identifier)) == null ? void 0 : _a30.activationStarted) {
      return false;
    }
    return true;
  }
  async _activateAddedExtensionIfNeeded(extensionDescription) {
    let shouldActivate = false;
    let shouldActivateReason = null;
    let hasWorkspaceContains = false;
    const activationEvents = this._activationEventReader.readActivationEvents(extensionDescription);
    for (let activationEvent of activationEvents) {
      if (activationEvent === "onUri") {
        activationEvent = `onUri:${ExtensionIdentifier.toKey(extensionDescription.identifier)}`;
      }
      if (this._allRequestedActivateEvents.has(activationEvent)) {
        shouldActivate = true;
        shouldActivateReason = activationEvent;
        break;
      }
      if (activationEvent === "*") {
        shouldActivate = true;
        shouldActivateReason = activationEvent;
        break;
      }
      if (/^workspaceContains/.test(activationEvent)) {
        hasWorkspaceContains = true;
      }
      if (activationEvent === "onStartupFinished") {
        shouldActivate = true;
        shouldActivateReason = activationEvent;
        break;
      }
    }
    if (shouldActivate) {
      await Promise.all(this._extensionHostManagers.map(
        (extHostManager) => extHostManager.activate(extensionDescription.identifier, { startup: false, extensionId: extensionDescription.identifier, activationEvent: shouldActivateReason })
      )).then(() => {
      });
    } else if (hasWorkspaceContains) {
      const workspace = await this._contextService.getCompleteWorkspace();
      const forceUsingSearch = !!this._environmentService.remoteAuthority;
      const host = {
        logService: this._logService,
        folders: workspace.folders.map((folder) => folder.uri),
        forceUsingSearch,
        exists: (uri) => this._fileService.exists(uri),
        checkExists: (folders, includes2, token) => this._instantiationService.invokeFunction((accessor) => checkGlobFileExists(accessor, folders, includes2, token))
      };
      const result = await checkActivateWorkspaceContainsExtension(host, extensionDescription);
      if (!result) {
        return;
      }
      await Promise.all(this._extensionHostManagers.map(
        (extHostManager) => extHostManager.activate(extensionDescription.identifier, { startup: false, extensionId: extensionDescription.identifier, activationEvent: result.activationEvent })
      )).then(() => {
      });
    }
  }
  async _initialize() {
    mark("code/willLoadExtensions");
    this._startExtensionHostsIfNecessary(true, []);
    const lock = await this._registry.acquireLock("_initialize");
    try {
      const resolvedExtensions = await this._resolveExtensions();
      this._processExtensions(lock, resolvedExtensions);
      const allExtensions = this._registry.getAllExtensionDescriptions();
      for (const extHostManager of this._extensionHostManagers) {
        if (extHostManager.startup !== 1) {
          const extensions = this._runningLocations.filterByExtensionHostManager(allExtensions, extHostManager);
          extHostManager.start(allExtensions, extensions.map((extension) => extension.identifier));
        }
      }
    } finally {
      lock.dispose();
    }
    this._releaseBarrier();
    mark("code/didLoadExtensions");
    await this._handleExtensionTests();
  }
  _processExtensions(lock, resolvedExtensions) {
    const { allowRemoteExtensionsInLocalWebWorker, hasLocalProcess } = resolvedExtensions;
    const localExtensions = checkEnabledAndProposedAPI(this._extensionEnablementService, this._extensionsProposedApi, resolvedExtensions.local, false);
    let remoteExtensions = checkEnabledAndProposedAPI(this._extensionEnablementService, this._extensionsProposedApi, resolvedExtensions.remote, false);
    this._runningLocations.initializeRunningLocation(localExtensions, remoteExtensions);
    this._startExtensionHostsIfNecessary(true, []);
    const remoteExtensionsThatNeedToRunLocally = allowRemoteExtensionsInLocalWebWorker ? this._runningLocations.filterByExtensionHostKind(remoteExtensions, 2) : [];
    const localProcessExtensions = hasLocalProcess ? this._runningLocations.filterByExtensionHostKind(localExtensions, 1) : [];
    const localWebWorkerExtensions = this._runningLocations.filterByExtensionHostKind(localExtensions, 2);
    remoteExtensions = this._runningLocations.filterByExtensionHostKind(remoteExtensions, 3);
    for (const ext of remoteExtensionsThatNeedToRunLocally) {
      if (!includes(localWebWorkerExtensions, ext.identifier)) {
        localWebWorkerExtensions.push(ext);
      }
    }
    const allExtensions = remoteExtensions.concat(localProcessExtensions).concat(localWebWorkerExtensions);
    const result = this._registry.deltaExtensions(lock, allExtensions, []);
    if (result.removedDueToLooping.length > 0) {
      this._notificationService.notify({
        severity: Severity.Error,
        message: localize(
          "looping",
          "The following extensions contain dependency loops and have been disabled: {0}",
          result.removedDueToLooping.map((e) => `'${e.identifier.value}'`).join(", ")
        )
      });
    }
    this._doHandleExtensionPoints(this._registry.getAllExtensionDescriptions());
  }
  async _handleExtensionTests() {
    if (!this._environmentService.isExtensionDevelopment || !this._environmentService.extensionTestsLocationURI) {
      return;
    }
    const extensionHostManager = this.findTestExtensionHost(this._environmentService.extensionTestsLocationURI);
    if (!extensionHostManager) {
      const msg = localize(
        "extensionTestError",
        "No extension host found that can launch the test runner at {0}.",
        this._environmentService.extensionTestsLocationURI.toString()
      );
      console.error(msg);
      this._notificationService.error(msg);
      return;
    }
    let exitCode;
    try {
      exitCode = await extensionHostManager.extensionTestsExecute();
    } catch (err) {
      console.error(err);
      exitCode = 1;
    }
    this._onExtensionHostExit(exitCode);
  }
  findTestExtensionHost(testLocation) {
    let runningLocation = null;
    for (const extension of this._registry.getAllExtensionDescriptions()) {
      if (isEqualOrParent(testLocation, extension.extensionLocation)) {
        runningLocation = this._runningLocations.getRunningLocation(extension.identifier);
        break;
      }
    }
    if (runningLocation === null) {
      if (testLocation.scheme === Schemas.vscodeRemote) {
        runningLocation = new RemoteRunningLocation();
      } else {
        runningLocation = new LocalProcessRunningLocation(0);
      }
    }
    if (runningLocation !== null) {
      return this._getExtensionHostManagerByRunningLocation(runningLocation);
    }
    return null;
  }
  _releaseBarrier() {
    this._installedExtensionsReady.open();
    this._onDidRegisterExtensions.fire(void 0);
    this._onDidChangeExtensionsStatus.fire(this._registry.getAllExtensionDescriptions().map((e) => e.identifier));
  }
  async _resolveAuthorityInitial(remoteAuthority) {
    const MAX_ATTEMPTS = 5;
    for (let attempt = 1; ; attempt++) {
      try {
        return this._resolveAuthorityWithLogging(remoteAuthority);
      } catch (err) {
        if (RemoteAuthorityResolverError.isNoResolverFound(err)) {
          throw err;
        }
        if (RemoteAuthorityResolverError.isNotAvailable(err)) {
          throw err;
        }
        if (attempt >= MAX_ATTEMPTS) {
          throw err;
        }
      }
    }
  }
  async _resolveAuthorityAgain() {
    const remoteAuthority = this._environmentService.remoteAuthority;
    if (!remoteAuthority) {
      return;
    }
    this._remoteAuthorityResolverService._clearResolvedAuthority(remoteAuthority);
    try {
      const result = await this._resolveAuthorityWithLogging(remoteAuthority);
      this._remoteAuthorityResolverService._setResolvedAuthority(result.authority, result.options);
    } catch (err) {
      this._remoteAuthorityResolverService._setResolvedAuthorityError(remoteAuthority, err);
    }
  }
  async _resolveAuthorityWithLogging(remoteAuthority) {
    const authorityPrefix = getRemoteAuthorityPrefix(remoteAuthority);
    const sw = StopWatch.create(false);
    this._logService.info(`Invoking resolveAuthority(${authorityPrefix})...`);
    try {
      mark(`code/willResolveAuthority/${authorityPrefix}`);
      const result = await this._resolveAuthority(remoteAuthority);
      mark(`code/didResolveAuthorityOK/${authorityPrefix}`);
      this._logService.info(`resolveAuthority(${authorityPrefix}) returned '${result.authority.connectTo}' after ${sw.elapsed()} ms`);
      return result;
    } catch (err) {
      mark(`code/didResolveAuthorityError/${authorityPrefix}`);
      this._logService.error(`resolveAuthority(${authorityPrefix}) returned an error after ${sw.elapsed()} ms`, err);
      throw err;
    }
  }
  async _resolveAuthorityOnExtensionHosts(kind, remoteAuthority) {
    const extensionHosts = this._getExtensionHostManagers(kind);
    if (extensionHosts.length === 0) {
      throw new Error(`Cannot resolve authority`);
    }
    this._resolveAuthorityAttempt++;
    const results = await Promise.all(extensionHosts.map(
      (extHost) => extHost.resolveAuthority(remoteAuthority, this._resolveAuthorityAttempt)
    ));
    let bestErrorResult = null;
    for (const result of results) {
      if (result.type === "ok") {
        return result.value;
      }
      if (!bestErrorResult) {
        bestErrorResult = result;
        continue;
      }
      const bestErrorIsUnknown = bestErrorResult.error.code === RemoteAuthorityResolverErrorCode.Unknown;
      const errorIsUnknown = result.error.code === RemoteAuthorityResolverErrorCode.Unknown;
      if (bestErrorIsUnknown && !errorIsUnknown) {
        bestErrorResult = result;
      }
    }
    throw new RemoteAuthorityResolverError(bestErrorResult.error.message, bestErrorResult.error.code, bestErrorResult.error.detail);
  }
  stopExtensionHosts(reason) {
    return this._doStopExtensionHostsWithVeto(reason);
  }
  _doStopExtensionHosts() {
    const previouslyActivatedExtensionIds = [];
    for (const extensionStatus of this._extensionStatus.values()) {
      if (extensionStatus.activationStarted) {
        previouslyActivatedExtensionIds.push(extensionStatus.id);
      }
    }
    for (let i = this._extensionHostManagers.length - 1; i >= 0; i--) {
      this._extensionHostManagers[i].dispose();
    }
    this._extensionHostManagers = [];
    for (const extensionStatus of this._extensionStatus.values()) {
      extensionStatus.clearRuntimeStatus();
    }
    if (previouslyActivatedExtensionIds.length > 0) {
      this._onDidChangeExtensionsStatus.fire(previouslyActivatedExtensionIds);
    }
  }
  async _doStopExtensionHostsWithVeto(reason) {
    const vetos = [];
    const vetoReasons = /* @__PURE__ */ new Set();
    this._onWillStop.fire({
      reason,
      veto(value, reason2) {
        vetos.push(value);
        if (typeof value === "boolean") {
          if (value === true) {
            vetoReasons.add(reason2);
          }
        } else {
          value.then((value2) => {
            if (value2) {
              vetoReasons.add(reason2);
            }
          }).catch((error) => {
            vetoReasons.add(localize(
              "extensionStopVetoError",
              "{0} (Error: {1})",
              reason2,
              toErrorMessage(error)
            ));
          });
        }
      }
    });
    const veto = await handleVetos(vetos, (error) => this._logService.error(error));
    if (!veto) {
      this._doStopExtensionHosts();
    } else {
      const vetoReasonsArray = Array.from(vetoReasons);
      this._logService.warn(`Extension host was not stopped because of veto (stop reason: ${reason}, veto reason: ${vetoReasonsArray.join(", ")})`);
      await this._dialogService.warn(localize(
        "extensionStopVetoMessage",
        "The following operation was blocked: {0}",
        reason
      ), vetoReasonsArray.length === 1 ? localize(
        "extensionStopVetoDetailsOne",
        "The reason for blocking the operation: {0}",
        vetoReasonsArray[0]
      ) : localize(
        "extensionStopVetoDetailsMany",
        "The reasons for blocking the operation:\n- {0}",
        vetoReasonsArray.join("\n -")
      ));
    }
    return !veto;
  }
  _startExtensionHostsIfNecessary(isInitialStart, initialActivationEvents) {
    const locations = [];
    for (let affinity = 0; affinity <= this._runningLocations.maxLocalProcessAffinity; affinity++) {
      locations.push(new LocalProcessRunningLocation(affinity));
    }
    for (let affinity = 0; affinity <= this._runningLocations.maxLocalWebWorkerAffinity; affinity++) {
      locations.push(new LocalWebWorkerRunningLocation(affinity));
    }
    locations.push(new RemoteRunningLocation());
    for (const location2 of locations) {
      if (this._getExtensionHostManagerByRunningLocation(location2)) {
        continue;
      }
      const extHostManager = this._createExtensionHostManager(location2, isInitialStart, initialActivationEvents);
      if (extHostManager) {
        this._extensionHostManagers.push(extHostManager);
      }
    }
  }
  _createExtensionHostManager(runningLocation, isInitialStart, initialActivationEvents) {
    const extensionHost = this._extensionHostFactory.createExtensionHost(this._runningLocations, runningLocation, isInitialStart);
    if (!extensionHost) {
      return null;
    }
    const processManager = this._doCreateExtensionHostManager(extensionHost, initialActivationEvents);
    processManager.onDidExit(([code, signal]) => this._onExtensionHostCrashOrExit(processManager, code, signal));
    processManager.onDidChangeResponsiveState((responsiveState) => {
      this._onDidChangeResponsiveChange.fire({
        extensionHostKind: processManager.kind,
        isResponsive: responsiveState === 0,
        getInspectPort: (tryEnableInspector) => {
          return processManager.getInspectPort(tryEnableInspector);
        }
      });
    });
    return processManager;
  }
  _doCreateExtensionHostManager(extensionHost, initialActivationEvents) {
    return createExtensionHostManager(this._instantiationService, extensionHost, initialActivationEvents, this._acquireInternalAPI(extensionHost));
  }
  _onExtensionHostCrashOrExit(extensionHost, code, signal) {
    const isExtensionDevHost = parseExtensionDevOptions(this._environmentService).isExtensionDevHost;
    if (!isExtensionDevHost) {
      this._onExtensionHostCrashed(extensionHost, code, signal);
      return;
    }
    this._onExtensionHostExit(code);
  }
  _onExtensionHostCrashed(extensionHost, code, signal) {
    console.error(`Extension host (${extensionHostKindToString(extensionHost.kind)}) terminated unexpectedly. Code: ${code}, Signal: ${signal}`);
    if (extensionHost.kind === 1) {
      this._doStopExtensionHosts();
    } else if (extensionHost.kind === 3) {
      if (signal) {
        this._onRemoteExtensionHostCrashed(extensionHost, signal);
      }
      for (let i = 0; i < this._extensionHostManagers.length; i++) {
        if (this._extensionHostManagers[i] === extensionHost) {
          this._extensionHostManagers[i].dispose();
          this._extensionHostManagers.splice(i, 1);
          break;
        }
      }
    }
  }
  _getExtensionHostExitInfoWithTimeout(reconnectionToken) {
    return new Promise((resolve, reject) => {
      const timeoutHandle = setTimeout(() => {
        reject(new Error("getExtensionHostExitInfo timed out"));
      }, 2e3);
      this._remoteAgentService.getExtensionHostExitInfo(reconnectionToken).then((r) => {
        clearTimeout(timeoutHandle);
        resolve(r);
      }, reject);
    });
  }
  async _onRemoteExtensionHostCrashed(extensionHost, reconnectionToken) {
    try {
      const info = await this._getExtensionHostExitInfoWithTimeout(reconnectionToken);
      if (info) {
        this._logService.error(`Extension host (${extensionHostKindToString(extensionHost.kind)}) terminated unexpectedly with code ${info.code}.`);
      }
      this._logExtensionHostCrash(extensionHost);
      this._remoteCrashTracker.registerCrash();
      if (this._remoteCrashTracker.shouldAutomaticallyRestart()) {
        this._logService.info(`Automatically restarting the remote extension host.`);
        this._notificationService.status(localize(
          "extensionService.autoRestart",
          "The remote extension host terminated unexpectedly. Restarting..."
        ), { hideAfter: 5e3 });
        this._startExtensionHostsIfNecessary(false, Array.from(this._allRequestedActivateEvents.keys()));
      } else {
        this._notificationService.prompt(Severity.Error, localize(
          "extensionService.crash",
          "Remote Extension host terminated unexpectedly 3 times within the last 5 minutes."
        ), [{
          label: localize("restart", "Restart Remote Extension Host"),
          run: () => {
            this._startExtensionHostsIfNecessary(false, Array.from(this._allRequestedActivateEvents.keys()));
          }
        }]);
      }
    } catch (err) {
    }
  }
  _logExtensionHostCrash(extensionHost) {
    const activatedExtensions = [];
    for (const extensionStatus of this._extensionStatus.values()) {
      if (extensionStatus.activationStarted && extensionHost.containsExtension(extensionStatus.id)) {
        activatedExtensions.push(extensionStatus.id);
      }
    }
    if (activatedExtensions.length > 0) {
      this._logService.error(`Extension host (${extensionHostKindToString(extensionHost.kind)}) terminated unexpectedly. The following extensions were running: ${activatedExtensions.map((id) => id.value).join(", ")}`);
    } else {
      this._logService.error(`Extension host (${extensionHostKindToString(extensionHost.kind)}) terminated unexpectedly. No extensions were activated.`);
    }
  }
  async startExtensionHosts() {
    this._doStopExtensionHosts();
    const lock = await this._registry.acquireLock("startExtensionHosts");
    try {
      this._startExtensionHostsIfNecessary(false, Array.from(this._allRequestedActivateEvents.keys()));
      const localProcessExtensionHosts = this._getExtensionHostManagers(1);
      await Promise.all(localProcessExtensionHosts.map((extHost) => extHost.ready()));
    } finally {
      lock.dispose();
    }
  }
  activateByEvent(activationEvent, activationKind = 0) {
    if (this._installedExtensionsReady.isOpen()) {
      this._allRequestedActivateEvents.add(activationEvent);
      if (!this._registry.containsActivationEvent(activationEvent)) {
        return NO_OP_VOID_PROMISE;
      }
      return this._activateByEvent(activationEvent, activationKind);
    } else {
      this._allRequestedActivateEvents.add(activationEvent);
      if (activationKind === 1) {
        return this._activateByEvent(activationEvent, activationKind);
      }
      return this._installedExtensionsReady.wait().then(() => this._activateByEvent(activationEvent, activationKind));
    }
  }
  _activateByEvent(activationEvent, activationKind) {
    const result = Promise.all(this._extensionHostManagers.map(
      (extHostManager) => extHostManager.activateByEvent(activationEvent, activationKind)
    )).then(() => {
    });
    this._onWillActivateByEvent.fire({
      event: activationEvent,
      activation: result
    });
    return result;
  }
  activationEventIsDone(activationEvent) {
    if (!this._installedExtensionsReady.isOpen()) {
      return false;
    }
    if (!this._registry.containsActivationEvent(activationEvent)) {
      return true;
    }
    return this._extensionHostManagers.every((manager) => manager.activationEventIsDone(activationEvent));
  }
  whenInstalledExtensionsRegistered() {
    return this._installedExtensionsReady.wait();
  }
  get extensions() {
    return this._registry.getAllExtensionDescriptions();
  }
  _getExtensions() {
    return this._installedExtensionsReady.wait().then(() => this.extensions);
  }
  getExtension(id) {
    return this._installedExtensionsReady.wait().then(() => {
      return this._registry.getExtensionDescription(id);
    });
  }
  readExtensionPointContributions(extPoint) {
    return this._installedExtensionsReady.wait().then(() => {
      const availableExtensions = this._registry.getAllExtensionDescriptions();
      const result = [];
      for (const desc of availableExtensions) {
        if (desc.contributes && hasOwnProperty.call(desc.contributes, extPoint.name)) {
          result.push(new ExtensionPointContribution(desc, desc.contributes[extPoint.name]));
        }
      }
      return result;
    });
  }
  getExtensionsStatus() {
    const result = /* @__PURE__ */ Object.create(null);
    if (this._registry) {
      const extensions = this._registry.getAllExtensionDescriptions();
      for (const extension of extensions) {
        const extensionStatus = this._extensionStatus.get(extension.identifier);
        result[extension.identifier.value] = {
          id: extension.identifier,
          messages: (extensionStatus == null ? void 0 : extensionStatus.messages) ?? [],
          activationStarted: (extensionStatus == null ? void 0 : extensionStatus.activationStarted) ?? false,
          activationTimes: (extensionStatus == null ? void 0 : extensionStatus.activationTimes) ?? void 0,
          runtimeErrors: (extensionStatus == null ? void 0 : extensionStatus.runtimeErrors) ?? [],
          runningLocation: this._runningLocations.getRunningLocation(extension.identifier)
        };
      }
    }
    return result;
  }
  async getInspectPorts(extensionHostKind, tryEnableInspector) {
    const result = await Promise.all(this._getExtensionHostManagers(extensionHostKind).map((extHost) => extHost.getInspectPort(tryEnableInspector)));
    return result.filter((element) => Boolean(element));
  }
  async setRemoteEnvironment(env2) {
    await this._extensionHostManagers.map((manager) => manager.setRemoteEnvironment(env2));
  }
  _safeInvokeIsEnabled(extension) {
    try {
      return this._extensionEnablementService.isEnabled(extension);
    } catch (err) {
      return false;
    }
  }
  _doHandleExtensionPoints(affectedExtensions) {
    const affectedExtensionPoints = /* @__PURE__ */ Object.create(null);
    for (const extensionDescription of affectedExtensions) {
      if (extensionDescription.contributes) {
        for (const extPointName in extensionDescription.contributes) {
          if (hasOwnProperty.call(extensionDescription.contributes, extPointName)) {
            affectedExtensionPoints[extPointName] = true;
          }
        }
      }
    }
    const messageHandler = (msg) => this._handleExtensionPointMessage(msg);
    const availableExtensions = this._registry.getAllExtensionDescriptions();
    const extensionPoints = ExtensionsRegistry.getExtensionPoints();
    mark("code/willHandleExtensionPoints");
    for (const extensionPoint of extensionPoints) {
      if (affectedExtensionPoints[extensionPoint.name]) {
        mark(`code/willHandleExtensionPoint/${extensionPoint.name}`);
        AbstractExtensionService_1._handleExtensionPoint(extensionPoint, availableExtensions, messageHandler);
        mark(`code/didHandleExtensionPoint/${extensionPoint.name}`);
      }
    }
    mark("code/didHandleExtensionPoints");
  }
  _getOrCreateExtensionStatus(extensionId) {
    if (!this._extensionStatus.has(extensionId)) {
      this._extensionStatus.set(extensionId, new ExtensionStatus(extensionId));
    }
    return this._extensionStatus.get(extensionId);
  }
  _handleExtensionPointMessage(msg) {
    const extensionStatus = this._getOrCreateExtensionStatus(msg.extensionId);
    extensionStatus.addMessage(msg);
    const extension = this._registry.getExtensionDescription(msg.extensionId);
    const strMsg = `[${msg.extensionId.value}]: ${msg.message}`;
    if (msg.type === Severity.Error) {
      if (extension && extension.isUnderDevelopment) {
        this._notificationService.notify({ severity: Severity.Error, message: strMsg });
      }
      this._logService.error(strMsg);
    } else if (msg.type === Severity.Warning) {
      if (extension && extension.isUnderDevelopment) {
        this._notificationService.notify({ severity: Severity.Warning, message: strMsg });
      }
      this._logService.warn(strMsg);
    } else {
      this._logService.info(strMsg);
    }
    if (msg.extensionId && this._environmentService.isBuilt && !this._environmentService.isExtensionDevelopment) {
      const { type, extensionId, extensionPointId, message } = msg;
      this._telemetryService.publicLog2("extensionsMessage", {
        type,
        extensionId: extensionId.value,
        extensionPointId,
        message
      });
    }
  }
  static _handleExtensionPoint(extensionPoint, availableExtensions, messageHandler) {
    const users = [];
    for (const desc of availableExtensions) {
      if (desc.contributes && hasOwnProperty.call(desc.contributes, extensionPoint.name)) {
        users.push({
          description: desc,
          value: desc.contributes[extensionPoint.name],
          collector: new ExtensionMessageCollector(messageHandler, desc, extensionPoint.name)
        });
      }
    }
    extensionPoint.acceptUsers(users);
  }
  _acquireInternalAPI(extensionHost) {
    return {
      _activateById: (extensionId, reason) => {
        return this._activateById(extensionId, reason);
      },
      _onWillActivateExtension: (extensionId) => {
        return this._onWillActivateExtension(extensionId, extensionHost.runningLocation);
      },
      _onDidActivateExtension: (extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) => {
        return this._onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason);
      },
      _onDidActivateExtensionError: (extensionId, error) => {
        return this._onDidActivateExtensionError(extensionId, error);
      },
      _onExtensionRuntimeError: (extensionId, err) => {
        return this._onExtensionRuntimeError(extensionId, err);
      }
    };
  }
  async _activateById(extensionId, reason) {
    const results = await Promise.all(this._extensionHostManagers.map((manager) => manager.activate(extensionId, reason)));
    const activated = results.some((e) => e);
    if (!activated) {
      throw new Error(`Unknown extension ${extensionId.value}`);
    }
  }
  _onWillActivateExtension(extensionId, runningLocation) {
    this._runningLocations.set(extensionId, runningLocation);
    const extensionStatus = this._getOrCreateExtensionStatus(extensionId);
    extensionStatus.onWillActivate();
  }
  _onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) {
    const extensionStatus = this._getOrCreateExtensionStatus(extensionId);
    extensionStatus.setActivationTimes(new ActivationTimes(codeLoadingTime, activateCallTime, activateResolvedTime, activationReason));
    this._onDidChangeExtensionsStatus.fire([extensionId]);
  }
  _onDidActivateExtensionError(extensionId, error) {
    this._telemetryService.publicLog2("extensionActivationError", {
      extensionId: extensionId.value,
      error: error.message
    });
  }
  _onExtensionRuntimeError(extensionId, err) {
    const extensionStatus = this._getOrCreateExtensionStatus(extensionId);
    extensionStatus.addRuntimeError(err);
    this._onDidChangeExtensionsStatus.fire([extensionId]);
  }
};
AbstractExtensionService = AbstractExtensionService_1 = __decorate([
  __param(3, IInstantiationService),
  __param(4, INotificationService),
  __param(5, IWorkbenchEnvironmentService),
  __param(6, ITelemetryService),
  __param(7, IWorkbenchExtensionEnablementService),
  __param(8, IFileService),
  __param(9, IProductService),
  __param(10, IWorkbenchExtensionManagementService),
  __param(11, IWorkspaceContextService),
  __param(12, IConfigurationService),
  __param(13, IExtensionManifestPropertiesService),
  __param(14, ILogService),
  __param(15, IRemoteAgentService),
  __param(16, IRemoteExtensionsScannerService),
  __param(17, ILifecycleService),
  __param(18, IRemoteAuthorityResolverService),
  __param(19, IDialogService)
], AbstractExtensionService);
var ResolvedExtensions = class {
  constructor(local, remote, hasLocalProcess, allowRemoteExtensionsInLocalWebWorker) {
    this.local = local;
    this.remote = remote;
    this.hasLocalProcess = hasLocalProcess;
    this.allowRemoteExtensionsInLocalWebWorker = allowRemoteExtensionsInLocalWebWorker;
  }
};
var DeltaExtensionsQueueItem = class {
  constructor(toAdd, toRemove) {
    this.toAdd = toAdd;
    this.toRemove = toRemove;
  }
};
function checkEnabledAndProposedAPI(extensionEnablementService, extensionsProposedApi, extensions, ignoreWorkspaceTrust) {
  return filterEnabledExtensions(extensionEnablementService, extensions, ignoreWorkspaceTrust);
}
function filterEnabledExtensions(extensionEnablementService, extensions, ignoreWorkspaceTrust) {
  const enabledExtensions = [], extensionsToCheck = [], mappedExtensions = [];
  for (const extension of extensions) {
    if (extension.isUnderDevelopment) {
      enabledExtensions.push(extension);
    } else {
      extensionsToCheck.push(extension);
      mappedExtensions.push(toExtension(extension));
    }
  }
  const enablementStates = extensionEnablementService.getEnablementStates(mappedExtensions, ignoreWorkspaceTrust ? { trusted: true } : void 0);
  for (let index = 0; index < enablementStates.length; index++) {
    if (extensionEnablementService.isEnabledEnablementState(enablementStates[index])) {
      enabledExtensions.push(extensionsToCheck[index]);
    }
  }
  return enabledExtensions;
}
function includes(extensions, identifier) {
  for (const extension of extensions) {
    if (ExtensionIdentifier.equals(extension.identifier, identifier)) {
      return true;
    }
  }
  return false;
}
var ExtensionStatus = class {
  get messages() {
    return this._messages;
  }
  get activationTimes() {
    return this._activationTimes;
  }
  get runtimeErrors() {
    return this._runtimeErrors;
  }
  get activationStarted() {
    return this._activationStarted;
  }
  constructor(id) {
    this.id = id;
    this._messages = [];
    this._activationTimes = null;
    this._runtimeErrors = [];
    this._activationStarted = false;
  }
  clearRuntimeStatus() {
    this._activationStarted = false;
    this._activationTimes = null;
    this._runtimeErrors = [];
  }
  addMessage(msg) {
    this._messages.push(msg);
  }
  setActivationTimes(activationTimes) {
    this._activationTimes = activationTimes;
  }
  addRuntimeError(err) {
    this._runtimeErrors.push(err);
  }
  onWillActivate() {
    this._activationStarted = true;
  }
};
var _ExtensionHostCrashTracker = class _ExtensionHostCrashTracker {
  constructor() {
    this._recentCrashes = [];
  }
  _removeOldCrashes() {
    const limit = Date.now() - _ExtensionHostCrashTracker._TIME_LIMIT;
    while (this._recentCrashes.length > 0 && this._recentCrashes[0].timestamp < limit) {
      this._recentCrashes.shift();
    }
  }
  registerCrash() {
    this._removeOldCrashes();
    this._recentCrashes.push({ timestamp: Date.now() });
  }
  shouldAutomaticallyRestart() {
    this._removeOldCrashes();
    return this._recentCrashes.length < _ExtensionHostCrashTracker._CRASH_LIMIT;
  }
};
_ExtensionHostCrashTracker._TIME_LIMIT = 5 * 60 * 1e3;
_ExtensionHostCrashTracker._CRASH_LIMIT = 3;
var ExtensionHostCrashTracker = _ExtensionHostCrashTracker;
var ImplicitActivationAwareReader = class {
  readActivationEvents(extensionDescription) {
    return ImplicitActivationEvents.readActivationEvents(extensionDescription);
  }
};

// node_modules/vscode/service-override/extensions.js
init_telemetry();
init_event();
init_remoteAuthorityResolver();
init_configuration();
init_descriptors();

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionsProposedApi.js
init_tslib_es6();
init_arrays();
init_extensions();
init_log();
var ExtensionsProposedApi = class ExtensionsProposedApi2 {
  constructor(_logService, _environmentService, productService) {
    this._logService = _logService;
    this._environmentService = _environmentService;
    this._envEnabledExtensions = new Set((_environmentService.extensionEnabledProposedApi ?? []).map((id) => ExtensionIdentifier.toKey(id)));
    this._envEnablesProposedApiForAll = !_environmentService.isBuilt || _environmentService.isExtensionDevelopment && productService.quality !== "stable" || this._envEnabledExtensions.size === 0 && Array.isArray(_environmentService.extensionEnabledProposedApi);
    this._productEnabledExtensions = /* @__PURE__ */ new Map();
    if (productService.extensionEnabledApiProposals) {
      for (const [k, value] of Object.entries(productService.extensionEnabledApiProposals)) {
        const key = ExtensionIdentifier.toKey(k);
        const proposalNames = value.filter((name) => {
          if (!allApiProposals[name]) {
            _logService.warn(`Via 'product.json#extensionEnabledApiProposals' extension '${key}' wants API proposal '${name}' but that proposal DOES NOT EXIST. Likely, the proposal has been finalized (check 'vscode.d.ts') or was abandoned.`);
            return false;
          }
          return true;
        });
        this._productEnabledExtensions.set(key, proposalNames);
      }
    }
  }
  updateEnabledApiProposals(extensions) {
    for (const extension of extensions) {
      this.doUpdateEnabledApiProposals(extension);
    }
  }
  doUpdateEnabledApiProposals(_extension2) {
    var _a30;
    const extension = _extension2;
    const key = ExtensionIdentifier.toKey(_extension2.identifier);
    if (isNonEmptyArray(extension.enabledApiProposals)) {
      extension.enabledApiProposals = extension.enabledApiProposals.filter((name) => {
        const result = Boolean(allApiProposals[name]);
        if (!result) {
          this._logService.error(`Extension '${key}' wants API proposal '${name}' but that proposal DOES NOT EXIST. Likely, the proposal has been finalized (check 'vscode.d.ts') or was abandoned.`);
        }
        return result;
      });
    }
    if (this._productEnabledExtensions.has(key)) {
      const productEnabledProposals = this._productEnabledExtensions.get(key);
      const productSet = new Set(productEnabledProposals);
      const extensionSet = new Set(extension.enabledApiProposals);
      const diff = new Set([...extensionSet].filter((a) => !productSet.has(a)));
      if (diff.size > 0) {
        this._logService.error(`Extension '${key}' appears in product.json but enables LESS API proposals than the extension wants.
package.json (LOSES): ${[...extensionSet].join(", ")}
product.json (WINS): ${[...productSet].join(", ")}`);
        if (this._environmentService.isExtensionDevelopment) {
          this._logService.error(`Proceeding with EXTRA proposals (${[...diff].join(", ")}) because extension is in development mode. Still, this EXTENSION WILL BE BROKEN unless product.json is updated.`);
          productEnabledProposals.push(...diff);
        }
      }
      extension.enabledApiProposals = productEnabledProposals;
      return;
    }
    if (this._envEnablesProposedApiForAll || this._envEnabledExtensions.has(key)) {
      return;
    }
    if (!extension.isBuiltin && isNonEmptyArray(extension.enabledApiProposals)) {
      this._logService.error(`Extension '${extension.identifier.value} CANNOT USE these API proposals '${((_a30 = extension.enabledApiProposals) == null ? void 0 : _a30.join(", ")) || "*"}'. You MUST start in extension development mode or use the --enable-proposed-api command line flag`);
      extension.enabledApiProposals = [];
    }
  }
};
ExtensionsProposedApi = __decorate([
  __param(0, ILogService),
  __param(1, IWorkbenchEnvironmentService),
  __param(2, IProductService)
], ExtensionsProposedApi);

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/browser/extensionService.js
init_tslib_es6();
init_instantiation();
init_log();
init_remoteAuthorityResolver();

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/browser/webWorkerExtensionHost.js
init_tslib_es6();
init_dom();
init_async();
init_buffer();
init_errors();
init_event();
init_lifecycle();
init_network();
init_platform();
init_resources();
init_uri();
init_uuid();
init_log();
init_telemetry();
init_telemetryUtils();

// node_modules/vscode/vscode/src/vs/workbench/browser/iframe.js
async function parentOriginHash(parentOrigin, salt) {
  if (!crypto.subtle) {
    throw new Error(`'crypto.subtle' is not available so webviews will not work. This is likely because the editor is not running in a secure context (https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts).`);
  }
  const strData = JSON.stringify({ parentOrigin, salt });
  const encoder = new TextEncoder();
  const arrData = encoder.encode(strData);
  const hash2 = await crypto.subtle.digest("sha-256", arrData);
  return sha256AsBase32(hash2);
}
function sha256AsBase32(bytes) {
  const array = Array.from(new Uint8Array(bytes));
  const hexArray = array.map((b) => b.toString(16).padStart(2, "0")).join("");
  return BigInt(`0x${hexArray}`).toString(32).padStart(52, "0");
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/browser/webWorkerExtensionHost.js
init_extensionHostProtocol();
var WebWorkerExtensionHost = class WebWorkerExtensionHost2 extends Disposable {
  constructor(runningLocation, startup, _initDataProvider, _telemetryService, _contextService, _labelService, _logService, _loggerService, _environmentService, _userDataProfilesService, _productService, _layoutService, _storageService) {
    super();
    this.runningLocation = runningLocation;
    this.startup = startup;
    this._initDataProvider = _initDataProvider;
    this._telemetryService = _telemetryService;
    this._contextService = _contextService;
    this._labelService = _labelService;
    this._logService = _logService;
    this._loggerService = _loggerService;
    this._environmentService = _environmentService;
    this._userDataProfilesService = _userDataProfilesService;
    this._productService = _productService;
    this._layoutService = _layoutService;
    this._storageService = _storageService;
    this.remoteAuthority = null;
    this.extensions = new ExtensionHostExtensions();
    this._onDidExit = this._register(new Emitter());
    this.onExit = this._onDidExit.event;
    this._isTerminating = false;
    this._protocolPromise = null;
    this._protocol = null;
    this._extensionHostLogsLocation = joinPath(this._environmentService.extHostLogsPath, "webWorker");
  }
  async _getWebWorkerExtensionHostIframeSrc() {
    const suffixSearchParams = new URLSearchParams();
    if (this._environmentService.debugExtensionHost && this._environmentService.debugRenderer) {
      suffixSearchParams.set("debugged", "1");
    }
    COI.addSearchParam(suffixSearchParams, true, true);
    const suffix = `?${suffixSearchParams.toString()}`;
    const iframeModulePath = "vs/workbench/services/extensions/worker/webWorkerExtensionHostIframe.html";
    if (isWeb) {
      const webEndpointUrlTemplate = this._productService.webEndpointUrlTemplate;
      const commit = this._productService.commit;
      const quality = this._productService.quality;
      if (webEndpointUrlTemplate && commit && quality) {
        const key = "webWorkerExtensionHostIframeStableOriginUUID";
        let stableOriginUUID = this._storageService.get(key, 1);
        if (typeof stableOriginUUID === "undefined") {
          stableOriginUUID = generateUuid();
          this._storageService.store(key, stableOriginUUID, 1, 1);
        }
        const hash2 = await parentOriginHash(window.origin, stableOriginUUID);
        const baseUrl = webEndpointUrlTemplate.replace("{{uuid}}", `v--${hash2}`).replace("{{commit}}", commit).replace("{{quality}}", quality);
        const res = new URL(`${baseUrl}/out/${iframeModulePath}${suffix}`);
        res.searchParams.set("parentOrigin", window.origin);
        res.searchParams.set("salt", stableOriginUUID);
        return res.toString();
      }
    }
    const relativeExtensionHostIframeSrc = FileAccess.asBrowserUri(iframeModulePath);
    return `${relativeExtensionHostIframeSrc.toString(true)}${suffix}`;
  }
  async start() {
    if (!this._protocolPromise) {
      this._protocolPromise = this._startInsideIframe();
      this._protocolPromise.then((protocol) => this._protocol = protocol);
    }
    return this._protocolPromise;
  }
  async _startInsideIframe() {
    var _a30;
    const initDataPromise = this._initDataProvider.getInitData();
    const webWorkerExtensionHostIframeSrc = await this._getWebWorkerExtensionHostIframeSrc();
    const emitter = this._register(new Emitter());
    const iframe = document.createElement("iframe");
    iframe.setAttribute("class", "web-worker-ext-host-iframe");
    iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
    iframe.setAttribute("allow", "usb; serial; hid; cross-origin-isolated;");
    iframe.setAttribute("aria-hidden", "true");
    iframe.style.display = "none";
    const vscodeWebWorkerExtHostId = generateUuid();
    iframe.setAttribute("src", `${webWorkerExtensionHostIframeSrc}&vscodeWebWorkerExtHostId=${vscodeWebWorkerExtHostId}`);
    const barrier = new Barrier();
    let port;
    let barrierError = null;
    let barrierHasError = false;
    let startTimeout = null;
    const rejectBarrier = (exitCode, error) => {
      barrierError = error;
      barrierHasError = true;
      onUnexpectedError(barrierError);
      clearTimeout(startTimeout);
      this._onDidExit.fire([81, barrierError.message]);
      barrier.open();
    };
    const resolveBarrier = (messagePort) => {
      port = messagePort;
      clearTimeout(startTimeout);
      barrier.open();
    };
    startTimeout = setTimeout(() => {
      console.warn(`The Web Worker Extension Host did not start in 60s, that might be a problem.`);
    }, 6e4);
    this._register(addDisposableListener(window, "message", (event) => {
      if (event.source !== iframe.contentWindow) {
        return;
      }
      if (event.data.vscodeWebWorkerExtHostId !== vscodeWebWorkerExtHostId) {
        return;
      }
      if (event.data.error) {
        const { name, message, stack } = event.data.error;
        const err = new Error();
        err.message = message;
        err.name = name;
        err.stack = stack;
        return rejectBarrier(81, err);
      }
      const { data } = event.data;
      if (barrier.isOpen() || !(data instanceof MessagePort)) {
        console.warn("UNEXPECTED message", event);
        const err = new Error("UNEXPECTED message");
        return rejectBarrier(81, err);
      }
      resolveBarrier(data);
    }));
    this._layoutService.container.appendChild(iframe);
    this._register(toDisposable(() => iframe.remove()));
    await barrier.wait();
    if (barrierHasError) {
      throw barrierError;
    }
    const messagePorts = ((_a30 = this._environmentService.options) == null ? void 0 : _a30.messagePorts) ?? /* @__PURE__ */ new Map();
    iframe.contentWindow.postMessage({ type: "vscode.init", data: messagePorts }, "*", [...messagePorts.values()]);
    port.onmessage = (event) => {
      const { data } = event;
      if (!(data instanceof ArrayBuffer)) {
        console.warn("UNKNOWN data received", data);
        this._onDidExit.fire([77, "UNKNOWN data received"]);
        return;
      }
      emitter.fire(VSBuffer.wrap(new Uint8Array(data, 0, data.byteLength)));
    };
    const protocol = {
      onMessage: emitter.event,
      send: (vsbuf) => {
        const data = vsbuf.buffer.buffer.slice(vsbuf.buffer.byteOffset, vsbuf.buffer.byteOffset + vsbuf.buffer.byteLength);
        port.postMessage(data, [data]);
      }
    };
    return this._performHandshake(protocol, initDataPromise);
  }
  async _performHandshake(protocol, initDataPromise) {
    await Event.toPromise(Event.filter(protocol.onMessage, (msg) => isMessageOfType(msg, 1)));
    if (this._isTerminating) {
      throw canceled();
    }
    protocol.send(VSBuffer.fromString(JSON.stringify(await this._createExtHostInitData(initDataPromise))));
    if (this._isTerminating) {
      throw canceled();
    }
    await Event.toPromise(Event.filter(protocol.onMessage, (msg) => isMessageOfType(msg, 0)));
    if (this._isTerminating) {
      throw canceled();
    }
    return protocol;
  }
  dispose() {
    var _a30;
    if (this._isTerminating) {
      return;
    }
    this._isTerminating = true;
    (_a30 = this._protocol) == null ? void 0 : _a30.send(createMessageOfType(2));
    super.dispose();
  }
  getInspectPort() {
    return void 0;
  }
  enableInspectPort() {
    return Promise.resolve(false);
  }
  async _createExtHostInitData(initDataPromise) {
    var _a30;
    const initData = await initDataPromise;
    const workspace = this._contextService.getWorkspace();
    const deltaExtensions = this.extensions.set(initData.allExtensions, initData.myExtensions);
    const nlsBaseUrl = (_a30 = this._productService.extensionsGallery) == null ? void 0 : _a30.nlsBaseUrl;
    let nlsUrlWithDetails = void 0;
    if (nlsBaseUrl && this._productService.commit && !Language.isDefaultVariant()) {
      nlsUrlWithDetails = URI.joinPath(URI.parse(nlsBaseUrl), this._productService.commit, this._productService.version, Language.value());
    }
    return {
      commit: this._productService.commit,
      version: this._productService.version,
      quality: this._productService.quality,
      parentPid: 0,
      environment: {
        isExtensionDevelopmentDebug: this._environmentService.debugRenderer,
        appName: this._productService.nameLong,
        appHost: this._productService.embedderIdentifier ?? (isWeb ? "web" : "desktop"),
        appUriScheme: this._productService.urlProtocol,
        appLanguage: language,
        extensionTelemetryLogResource: this._environmentService.extHostTelemetryLogFile,
        isExtensionTelemetryLoggingOnly: isLoggingOnly(this._productService, this._environmentService),
        extensionDevelopmentLocationURI: this._environmentService.extensionDevelopmentLocationURI,
        extensionTestsLocationURI: this._environmentService.extensionTestsLocationURI,
        globalStorageHome: this._userDataProfilesService.defaultProfile.globalStorageHome,
        workspaceStorageHome: this._environmentService.workspaceStorageHome,
        extensionLogLevel: this._environmentService.extensionLogLevel
      },
      workspace: this._contextService.getWorkbenchState() === 1 ? void 0 : {
        configuration: workspace.configuration || void 0,
        id: workspace.id,
        name: this._labelService.getWorkspaceLabel(workspace),
        transient: workspace.transient
      },
      consoleForward: {
        includeStack: false,
        logNative: this._environmentService.debugRenderer
      },
      allExtensions: deltaExtensions.toAdd,
      activationEvents: deltaExtensions.addActivationEvents,
      myExtensions: deltaExtensions.myToAdd,
      nlsBaseUrl: nlsUrlWithDetails,
      telemetryInfo: {
        sessionId: this._telemetryService.sessionId,
        machineId: this._telemetryService.machineId,
        firstSessionDate: this._telemetryService.firstSessionDate,
        msftInternal: this._telemetryService.msftInternal
      },
      logLevel: this._logService.getLevel(),
      loggers: [...this._loggerService.getRegisteredLoggers()],
      logsLocation: this._extensionHostLogsLocation,
      autoStart: this.startup === 1,
      remote: {
        authority: this._environmentService.remoteAuthority,
        connectionData: null,
        isRemote: false
      },
      uiKind: isWeb ? UIKind.Web : UIKind.Desktop
    };
  }
};
WebWorkerExtensionHost = __decorate([
  __param(3, ITelemetryService),
  __param(4, IWorkspaceContextService),
  __param(5, ILabelService),
  __param(6, ILogService),
  __param(7, ILoggerService),
  __param(8, IBrowserWorkbenchEnvironmentService),
  __param(9, IUserDataProfilesService),
  __param(10, IProductService),
  __param(11, ILayoutService),
  __param(12, IStorageService)
], WebWorkerExtensionHost);

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/remoteExtensionHost.js
init_tslib_es6();
init_buffer();
init_event();
init_lifecycle();
init_network();
init_platform();
init_log();

// node_modules/vscode/vscode/src/vs/platform/remote/common/remoteAgentConnection.js
init_async();
init_buffer();
init_cancellation();
init_errors();
init_event();
init_lifecycle();
init_stopwatch();
init_uuid();

// node_modules/vscode/vscode/src/vs/base/parts/ipc/common/ipc.net.js
init_buffer();
init_event();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/base/parts/ipc/common/ipc.js
init_tslib_es6();
init_async();
init_buffer();
init_cancellation();
init_errors();
init_event();
init_lifecycle();
function requestTypeToStr(type) {
  switch (type) {
    case 100:
      return "req";
    case 101:
      return "cancel";
    case 102:
      return "subscribe";
    case 103:
      return "unsubscribe";
  }
}
function responseTypeToStr(type) {
  switch (type) {
    case 200:
      return `init`;
    case 201:
      return `reply:`;
    case 202:
    case 203:
      return `replyErr:`;
    case 204:
      return `event:`;
  }
}
var State;
(function(State2) {
  State2[State2["Uninitialized"] = 0] = "Uninitialized";
  State2[State2["Idle"] = 1] = "Idle";
})(State || (State = {}));
function readIntVQL(reader) {
  let value = 0;
  for (let n2 = 0; ; n2 += 7) {
    const next = reader.read(1);
    value |= (next.buffer[0] & 127) << n2;
    if (!(next.buffer[0] & 128)) {
      return value;
    }
  }
}
var vqlZero = createOneByteBuffer(0);
function writeInt32VQL(writer, value) {
  if (value === 0) {
    writer.write(vqlZero);
    return;
  }
  let len = 0;
  for (let v2 = value; v2 !== 0; v2 = v2 >>> 7) {
    len++;
  }
  const scratch = VSBuffer.alloc(len);
  for (let i = 0; value !== 0; i++) {
    scratch.buffer[i] = value & 127;
    value = value >>> 7;
    if (value > 0) {
      scratch.buffer[i] |= 128;
    }
  }
  writer.write(scratch);
}
var BufferReader = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.pos = 0;
  }
  read(bytes) {
    const result = this.buffer.slice(this.pos, this.pos + bytes);
    this.pos += result.byteLength;
    return result;
  }
};
var BufferWriter = class {
  constructor() {
    this.buffers = [];
  }
  get buffer() {
    return VSBuffer.concat(this.buffers);
  }
  write(buffer) {
    this.buffers.push(buffer);
  }
};
var DataType;
(function(DataType2) {
  DataType2[DataType2["Undefined"] = 0] = "Undefined";
  DataType2[DataType2["String"] = 1] = "String";
  DataType2[DataType2["Buffer"] = 2] = "Buffer";
  DataType2[DataType2["VSBuffer"] = 3] = "VSBuffer";
  DataType2[DataType2["Array"] = 4] = "Array";
  DataType2[DataType2["Object"] = 5] = "Object";
  DataType2[DataType2["Int"] = 6] = "Int";
})(DataType || (DataType = {}));
function createOneByteBuffer(value) {
  const result = VSBuffer.alloc(1);
  result.writeUInt8(value, 0);
  return result;
}
var BufferPresets = {
  Undefined: createOneByteBuffer(DataType.Undefined),
  String: createOneByteBuffer(DataType.String),
  Buffer: createOneByteBuffer(DataType.Buffer),
  VSBuffer: createOneByteBuffer(DataType.VSBuffer),
  Array: createOneByteBuffer(DataType.Array),
  Object: createOneByteBuffer(DataType.Object),
  Uint: createOneByteBuffer(DataType.Int)
};
var hasBuffer = typeof Buffer !== "undefined";
function serialize(writer, data) {
  if (typeof data === "undefined") {
    writer.write(BufferPresets.Undefined);
  } else if (typeof data === "string") {
    const buffer = VSBuffer.fromString(data);
    writer.write(BufferPresets.String);
    writeInt32VQL(writer, buffer.byteLength);
    writer.write(buffer);
  } else if (hasBuffer && Buffer.isBuffer(data)) {
    const buffer = VSBuffer.wrap(data);
    writer.write(BufferPresets.Buffer);
    writeInt32VQL(writer, buffer.byteLength);
    writer.write(buffer);
  } else if (data instanceof VSBuffer) {
    writer.write(BufferPresets.VSBuffer);
    writeInt32VQL(writer, data.byteLength);
    writer.write(data);
  } else if (Array.isArray(data)) {
    writer.write(BufferPresets.Array);
    writeInt32VQL(writer, data.length);
    for (const el of data) {
      serialize(writer, el);
    }
  } else if (typeof data === "number" && (data | 0) === data) {
    writer.write(BufferPresets.Uint);
    writeInt32VQL(writer, data);
  } else {
    const buffer = VSBuffer.fromString(JSON.stringify(data));
    writer.write(BufferPresets.Object);
    writeInt32VQL(writer, buffer.byteLength);
    writer.write(buffer);
  }
}
function deserialize(reader) {
  const type = reader.read(1).readUInt8(0);
  switch (type) {
    case DataType.Undefined:
      return void 0;
    case DataType.String:
      return reader.read(readIntVQL(reader)).toString();
    case DataType.Buffer:
      return reader.read(readIntVQL(reader)).buffer;
    case DataType.VSBuffer:
      return reader.read(readIntVQL(reader));
    case DataType.Array: {
      const length = readIntVQL(reader);
      const result = [];
      for (let i = 0; i < length; i++) {
        result.push(deserialize(reader));
      }
      return result;
    }
    case DataType.Object:
      return JSON.parse(reader.read(readIntVQL(reader)).toString());
    case DataType.Int:
      return readIntVQL(reader);
  }
}
var ChannelClient = class {
  constructor(protocol, logger = null) {
    this.protocol = protocol;
    this.isDisposed = false;
    this.state = State.Uninitialized;
    this.activeRequests = /* @__PURE__ */ new Set();
    this.handlers = /* @__PURE__ */ new Map();
    this.lastRequestId = 0;
    this._onDidInitialize = new Emitter();
    this.onDidInitialize = this._onDidInitialize.event;
    this.protocolListener = this.protocol.onMessage((msg) => this.onBuffer(msg));
    this.logger = logger;
  }
  getChannel(channelName) {
    const that = this;
    return {
      call(command, arg, cancellationToken) {
        if (that.isDisposed) {
          return Promise.reject(new CancellationError());
        }
        return that.requestPromise(channelName, command, arg, cancellationToken);
      },
      listen(event, arg) {
        if (that.isDisposed) {
          return Event.None;
        }
        return that.requestEvent(channelName, event, arg);
      }
    };
  }
  requestPromise(channelName, name, arg, cancellationToken = CancellationToken.None) {
    const id = this.lastRequestId++;
    const type = 100;
    const request = { id, type, channelName, name, arg };
    if (cancellationToken.isCancellationRequested) {
      return Promise.reject(new CancellationError());
    }
    let disposable;
    const result = new Promise((c, e) => {
      if (cancellationToken.isCancellationRequested) {
        return e(new CancellationError());
      }
      const doRequest = () => {
        const handler = (response) => {
          switch (response.type) {
            case 201:
              this.handlers.delete(id);
              c(response.data);
              break;
            case 202: {
              this.handlers.delete(id);
              const error = new Error(response.data.message);
              error.stack = Array.isArray(response.data.stack) ? response.data.stack.join("\n") : response.data.stack;
              error.name = response.data.name;
              e(error);
              break;
            }
            case 203:
              this.handlers.delete(id);
              e(response.data);
              break;
          }
        };
        this.handlers.set(id, handler);
        this.sendRequest(request);
      };
      let uninitializedPromise = null;
      if (this.state === State.Idle) {
        doRequest();
      } else {
        uninitializedPromise = createCancelablePromise((_) => this.whenInitialized());
        uninitializedPromise.then(() => {
          uninitializedPromise = null;
          doRequest();
        });
      }
      const cancel = () => {
        if (uninitializedPromise) {
          uninitializedPromise.cancel();
          uninitializedPromise = null;
        } else {
          this.sendRequest({ id, type: 101 });
        }
        e(new CancellationError());
      };
      const cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);
      disposable = combinedDisposable(toDisposable(cancel), cancellationTokenListener);
      this.activeRequests.add(disposable);
    });
    return result.finally(() => {
      this.activeRequests.delete(disposable);
    });
  }
  requestEvent(channelName, name, arg) {
    const id = this.lastRequestId++;
    const type = 102;
    const request = { id, type, channelName, name, arg };
    let uninitializedPromise = null;
    const emitter = new Emitter({
      onWillAddFirstListener: () => {
        uninitializedPromise = createCancelablePromise((_) => this.whenInitialized());
        uninitializedPromise.then(() => {
          uninitializedPromise = null;
          this.activeRequests.add(emitter);
          this.sendRequest(request);
        });
      },
      onDidRemoveLastListener: () => {
        if (uninitializedPromise) {
          uninitializedPromise.cancel();
          uninitializedPromise = null;
        } else {
          this.activeRequests.delete(emitter);
          this.sendRequest({ id, type: 103 });
        }
      }
    });
    const handler = (res) => emitter.fire(res.data);
    this.handlers.set(id, handler);
    return emitter.event;
  }
  sendRequest(request) {
    var _a30, _b;
    switch (request.type) {
      case 100:
      case 102: {
        const msgLength = this.send([request.type, request.id, request.channelName, request.name], request.arg);
        (_a30 = this.logger) == null ? void 0 : _a30.logOutgoing(msgLength, request.id, 0, `${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`, request.arg);
        return;
      }
      case 101:
      case 103: {
        const msgLength = this.send([request.type, request.id]);
        (_b = this.logger) == null ? void 0 : _b.logOutgoing(msgLength, request.id, 0, requestTypeToStr(request.type));
        return;
      }
    }
  }
  send(header, body = void 0) {
    const writer = new BufferWriter();
    serialize(writer, header);
    serialize(writer, body);
    return this.sendBuffer(writer.buffer);
  }
  sendBuffer(message) {
    try {
      this.protocol.send(message);
      return message.byteLength;
    } catch (err) {
      return 0;
    }
  }
  onBuffer(message) {
    var _a30, _b;
    const reader = new BufferReader(message);
    const header = deserialize(reader);
    const body = deserialize(reader);
    const type = header[0];
    switch (type) {
      case 200:
        (_a30 = this.logger) == null ? void 0 : _a30.logIncoming(message.byteLength, 0, 0, responseTypeToStr(type));
        return this.onResponse({ type: header[0] });
      case 201:
      case 202:
      case 204:
      case 203:
        (_b = this.logger) == null ? void 0 : _b.logIncoming(message.byteLength, header[1], 0, responseTypeToStr(type), body);
        return this.onResponse({ type: header[0], id: header[1], data: body });
    }
  }
  onResponse(response) {
    if (response.type === 200) {
      this.state = State.Idle;
      this._onDidInitialize.fire();
      return;
    }
    const handler = this.handlers.get(response.id);
    handler == null ? void 0 : handler(response);
  }
  get onDidInitializePromise() {
    return Event.toPromise(this.onDidInitialize);
  }
  whenInitialized() {
    if (this.state === State.Idle) {
      return Promise.resolve();
    } else {
      return this.onDidInitializePromise;
    }
  }
  dispose() {
    this.isDisposed = true;
    if (this.protocolListener) {
      this.protocolListener.dispose();
      this.protocolListener = null;
    }
    dispose(this.activeRequests.values());
    this.activeRequests.clear();
  }
};
ChannelClient.__decorator = __decorate([
  memoize
], ChannelClient.prototype, "onDidInitializePromise", null);

// node_modules/vscode/vscode/src/vs/base/parts/ipc/common/ipc.net.js
var SocketDiagnostics;
(function(SocketDiagnostics2) {
  SocketDiagnostics2.enableDiagnostics = false;
  SocketDiagnostics2.records = [];
  const socketIds = /* @__PURE__ */ new WeakMap();
  let lastUsedSocketId = 0;
  function getSocketId(nativeObject, label) {
    if (!socketIds.has(nativeObject)) {
      const id = String(++lastUsedSocketId);
      socketIds.set(nativeObject, id);
    }
    return socketIds.get(nativeObject);
  }
  function traceSocketEvent(nativeObject, socketDebugLabel, type, data) {
    if (!SocketDiagnostics2.enableDiagnostics) {
      return;
    }
    const id = getSocketId(nativeObject);
    if (data instanceof VSBuffer || data instanceof Uint8Array || data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
      const copiedData = VSBuffer.alloc(data.byteLength);
      copiedData.set(data);
      SocketDiagnostics2.records.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, buff: copiedData });
    } else {
      SocketDiagnostics2.records.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, data });
    }
  }
  SocketDiagnostics2.traceSocketEvent = traceSocketEvent;
})(SocketDiagnostics || (SocketDiagnostics = {}));
var emptyBuffer = null;
function getEmptyBuffer() {
  if (!emptyBuffer) {
    emptyBuffer = VSBuffer.alloc(0);
  }
  return emptyBuffer;
}
var ChunkStream = class {
  get byteLength() {
    return this._totalLength;
  }
  constructor() {
    this._chunks = [];
    this._totalLength = 0;
  }
  acceptChunk(buff) {
    this._chunks.push(buff);
    this._totalLength += buff.byteLength;
  }
  read(byteCount) {
    return this._read(byteCount, true);
  }
  peek(byteCount) {
    return this._read(byteCount, false);
  }
  _read(byteCount, advance) {
    if (byteCount === 0) {
      return getEmptyBuffer();
    }
    if (byteCount > this._totalLength) {
      throw new Error(`Cannot read so many bytes!`);
    }
    if (this._chunks[0].byteLength === byteCount) {
      const result2 = this._chunks[0];
      if (advance) {
        this._chunks.shift();
        this._totalLength -= byteCount;
      }
      return result2;
    }
    if (this._chunks[0].byteLength > byteCount) {
      const result2 = this._chunks[0].slice(0, byteCount);
      if (advance) {
        this._chunks[0] = this._chunks[0].slice(byteCount);
        this._totalLength -= byteCount;
      }
      return result2;
    }
    const result = VSBuffer.alloc(byteCount);
    let resultOffset = 0;
    let chunkIndex = 0;
    while (byteCount > 0) {
      const chunk = this._chunks[chunkIndex];
      if (chunk.byteLength > byteCount) {
        const chunkPart = chunk.slice(0, byteCount);
        result.set(chunkPart, resultOffset);
        resultOffset += byteCount;
        if (advance) {
          this._chunks[chunkIndex] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
        }
        byteCount -= byteCount;
      } else {
        result.set(chunk, resultOffset);
        resultOffset += chunk.byteLength;
        if (advance) {
          this._chunks.shift();
          this._totalLength -= chunk.byteLength;
        } else {
          chunkIndex++;
        }
        byteCount -= chunk.byteLength;
      }
    }
    return result;
  }
};
function protocolMessageTypeToString(messageType) {
  switch (messageType) {
    case 0:
      return "None";
    case 1:
      return "Regular";
    case 2:
      return "Control";
    case 3:
      return "Ack";
    case 5:
      return "Disconnect";
    case 6:
      return "ReplayRequest";
    case 7:
      return "PauseWriting";
    case 8:
      return "ResumeWriting";
    case 9:
      return "KeepAlive";
  }
}
var ProtocolMessage = class {
  constructor(type, id, ack, data) {
    this.type = type;
    this.id = id;
    this.ack = ack;
    this.data = data;
    this.writtenTime = 0;
  }
  get size() {
    return this.data.byteLength;
  }
};
var ProtocolReader = class extends Disposable {
  constructor(socket) {
    super();
    this._onMessage = this._register(new Emitter());
    this.onMessage = this._onMessage.event;
    this._state = {
      readHead: true,
      readLen: 13,
      messageType: 0,
      id: 0,
      ack: 0
    };
    this._socket = socket;
    this._isDisposed = false;
    this._incomingData = new ChunkStream();
    this._register(this._socket.onData((data) => this.acceptChunk(data)));
    this.lastReadTime = Date.now();
  }
  acceptChunk(data) {
    if (!data || data.byteLength === 0) {
      return;
    }
    this.lastReadTime = Date.now();
    this._incomingData.acceptChunk(data);
    while (this._incomingData.byteLength >= this._state.readLen) {
      const buff = this._incomingData.read(this._state.readLen);
      if (this._state.readHead) {
        this._state.readHead = false;
        this._state.readLen = buff.readUInt32BE(9);
        this._state.messageType = buff.readUInt8(0);
        this._state.id = buff.readUInt32BE(1);
        this._state.ack = buff.readUInt32BE(5);
        this._socket.traceSocketEvent("protocolHeaderRead", { messageType: protocolMessageTypeToString(this._state.messageType), id: this._state.id, ack: this._state.ack, messageSize: this._state.readLen });
      } else {
        const messageType = this._state.messageType;
        const id = this._state.id;
        const ack = this._state.ack;
        this._state.readHead = true;
        this._state.readLen = 13;
        this._state.messageType = 0;
        this._state.id = 0;
        this._state.ack = 0;
        this._socket.traceSocketEvent("protocolMessageRead", buff);
        this._onMessage.fire(new ProtocolMessage(messageType, id, ack, buff));
        if (this._isDisposed) {
          break;
        }
      }
    }
  }
  readEntireBuffer() {
    return this._incomingData.read(this._incomingData.byteLength);
  }
  dispose() {
    this._isDisposed = true;
    super.dispose();
  }
};
var ProtocolWriter = class {
  constructor(socket) {
    this._writeNowTimeout = null;
    this._isDisposed = false;
    this._isPaused = false;
    this._socket = socket;
    this._data = [];
    this._totalLength = 0;
    this.lastWriteTime = 0;
  }
  dispose() {
    try {
      this.flush();
    } catch (err) {
    }
    this._isDisposed = true;
  }
  drain() {
    this.flush();
    return this._socket.drain();
  }
  flush() {
    this._writeNow();
  }
  pause() {
    this._isPaused = true;
  }
  resume() {
    this._isPaused = false;
    this._scheduleWriting();
  }
  write(msg) {
    if (this._isDisposed) {
      return;
    }
    msg.writtenTime = Date.now();
    this.lastWriteTime = Date.now();
    const header = VSBuffer.alloc(13);
    header.writeUInt8(msg.type, 0);
    header.writeUInt32BE(msg.id, 1);
    header.writeUInt32BE(msg.ack, 5);
    header.writeUInt32BE(msg.data.byteLength, 9);
    this._socket.traceSocketEvent("protocolHeaderWrite", { messageType: protocolMessageTypeToString(msg.type), id: msg.id, ack: msg.ack, messageSize: msg.data.byteLength });
    this._socket.traceSocketEvent("protocolMessageWrite", msg.data);
    this._writeSoon(header, msg.data);
  }
  _bufferAdd(head, body) {
    const wasEmpty = this._totalLength === 0;
    this._data.push(head, body);
    this._totalLength += head.byteLength + body.byteLength;
    return wasEmpty;
  }
  _bufferTake() {
    const ret = VSBuffer.concat(this._data, this._totalLength);
    this._data.length = 0;
    this._totalLength = 0;
    return ret;
  }
  _writeSoon(header, data) {
    if (this._bufferAdd(header, data)) {
      this._scheduleWriting();
    }
  }
  _scheduleWriting() {
    if (this._writeNowTimeout) {
      return;
    }
    this._writeNowTimeout = setTimeout(() => {
      this._writeNowTimeout = null;
      this._writeNow();
    });
  }
  _writeNow() {
    if (this._totalLength === 0) {
      return;
    }
    if (this._isPaused) {
      return;
    }
    const data = this._bufferTake();
    this._socket.traceSocketEvent("protocolWrite", { byteLength: data.byteLength });
    this._socket.write(data);
  }
};
var BufferedEmitter = class {
  constructor() {
    this._hasListeners = false;
    this._isDeliveringMessages = false;
    this._bufferedMessages = [];
    this._emitter = new Emitter({
      onWillAddFirstListener: () => {
        this._hasListeners = true;
        queueMicrotask(() => this._deliverMessages());
      },
      onDidRemoveLastListener: () => {
        this._hasListeners = false;
      }
    });
    this.event = this._emitter.event;
  }
  _deliverMessages() {
    if (this._isDeliveringMessages) {
      return;
    }
    this._isDeliveringMessages = true;
    while (this._hasListeners && this._bufferedMessages.length > 0) {
      this._emitter.fire(this._bufferedMessages.shift());
    }
    this._isDeliveringMessages = false;
  }
  fire(event) {
    if (this._hasListeners) {
      if (this._bufferedMessages.length > 0) {
        this._bufferedMessages.push(event);
      } else {
        this._emitter.fire(event);
      }
    } else {
      this._bufferedMessages.push(event);
    }
  }
  flushBuffer() {
    this._bufferedMessages = [];
  }
};
var QueueElement = class {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
};
var Queue = class {
  constructor() {
    this._first = null;
    this._last = null;
  }
  length() {
    let result = 0;
    let current = this._first;
    while (current) {
      current = current.next;
      result++;
    }
    return result;
  }
  peek() {
    if (!this._first) {
      return null;
    }
    return this._first.data;
  }
  toArray() {
    const result = [];
    let resultLen = 0;
    let it = this._first;
    while (it) {
      result[resultLen++] = it.data;
      it = it.next;
    }
    return result;
  }
  pop() {
    if (!this._first) {
      return;
    }
    if (this._first === this._last) {
      this._first = null;
      this._last = null;
      return;
    }
    this._first = this._first.next;
  }
  push(item) {
    const element = new QueueElement(item);
    if (!this._first) {
      this._first = element;
      this._last = element;
      return;
    }
    this._last.next = element;
    this._last = element;
  }
};
var _LoadEstimator = class _LoadEstimator {
  static getInstance() {
    if (!_LoadEstimator._INSTANCE) {
      _LoadEstimator._INSTANCE = new _LoadEstimator();
    }
    return _LoadEstimator._INSTANCE;
  }
  constructor() {
    this.lastRuns = [];
    const now = Date.now();
    for (let i = 0; i < _LoadEstimator._HISTORY_LENGTH; i++) {
      this.lastRuns[i] = now - 1e3 * i;
    }
    setInterval(() => {
      for (let i = _LoadEstimator._HISTORY_LENGTH; i >= 1; i--) {
        this.lastRuns[i] = this.lastRuns[i - 1];
      }
      this.lastRuns[0] = Date.now();
    }, 1e3);
  }
  load() {
    const now = Date.now();
    const historyLimit = (1 + _LoadEstimator._HISTORY_LENGTH) * 1e3;
    let score2 = 0;
    for (let i = 0; i < _LoadEstimator._HISTORY_LENGTH; i++) {
      if (now - this.lastRuns[i] <= historyLimit) {
        score2++;
      }
    }
    return 1 - score2 / _LoadEstimator._HISTORY_LENGTH;
  }
  hasHighLoad() {
    return this.load() >= 0.5;
  }
};
_LoadEstimator._HISTORY_LENGTH = 10;
_LoadEstimator._INSTANCE = null;
var LoadEstimator = _LoadEstimator;
var PersistentProtocol = class {
  get unacknowledgedCount() {
    return this._outgoingMsgId - this._outgoingAckId;
  }
  constructor(opts) {
    this._onControlMessage = new BufferedEmitter();
    this.onControlMessage = this._onControlMessage.event;
    this._onMessage = new BufferedEmitter();
    this.onMessage = this._onMessage.event;
    this._onDidDispose = new BufferedEmitter();
    this.onDidDispose = this._onDidDispose.event;
    this._onSocketClose = new BufferedEmitter();
    this.onSocketClose = this._onSocketClose.event;
    this._onSocketTimeout = new BufferedEmitter();
    this.onSocketTimeout = this._onSocketTimeout.event;
    this._loadEstimator = opts.loadEstimator ?? LoadEstimator.getInstance();
    this._shouldSendKeepAlive = opts.sendKeepAlive ?? true;
    this._isReconnecting = false;
    this._outgoingUnackMsg = new Queue();
    this._outgoingMsgId = 0;
    this._outgoingAckId = 0;
    this._outgoingAckTimeout = null;
    this._incomingMsgId = 0;
    this._incomingAckId = 0;
    this._incomingMsgLastTime = 0;
    this._incomingAckTimeout = null;
    this._lastReplayRequestTime = 0;
    this._lastSocketTimeoutTime = Date.now();
    this._socketDisposables = new DisposableStore();
    this._socket = opts.socket;
    this._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));
    this._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));
    this._socketDisposables.add(this._socketReader.onMessage((msg) => this._receiveMessage(msg)));
    this._socketDisposables.add(this._socket.onClose((e) => this._onSocketClose.fire(e)));
    if (opts.initialChunk) {
      this._socketReader.acceptChunk(opts.initialChunk);
    }
    if (this._shouldSendKeepAlive) {
      this._keepAliveInterval = setInterval(() => {
        this._sendKeepAlive();
      }, 5e3);
    } else {
      this._keepAliveInterval = null;
    }
  }
  dispose() {
    if (this._outgoingAckTimeout) {
      clearTimeout(this._outgoingAckTimeout);
      this._outgoingAckTimeout = null;
    }
    if (this._incomingAckTimeout) {
      clearTimeout(this._incomingAckTimeout);
      this._incomingAckTimeout = null;
    }
    if (this._keepAliveInterval) {
      clearInterval(this._keepAliveInterval);
      this._keepAliveInterval = null;
    }
    this._socketDisposables.dispose();
  }
  drain() {
    return this._socketWriter.drain();
  }
  sendDisconnect() {
    const msg = new ProtocolMessage(5, 0, 0, getEmptyBuffer());
    this._socketWriter.write(msg);
    this._socketWriter.flush();
  }
  sendPause() {
    const msg = new ProtocolMessage(7, 0, 0, getEmptyBuffer());
    this._socketWriter.write(msg);
  }
  sendResume() {
    const msg = new ProtocolMessage(8, 0, 0, getEmptyBuffer());
    this._socketWriter.write(msg);
  }
  pauseSocketWriting() {
    this._socketWriter.pause();
  }
  getSocket() {
    return this._socket;
  }
  getMillisSinceLastIncomingData() {
    return Date.now() - this._socketReader.lastReadTime;
  }
  beginAcceptReconnection(socket, initialDataChunk) {
    this._isReconnecting = true;
    this._socketDisposables.dispose();
    this._socketDisposables = new DisposableStore();
    this._onControlMessage.flushBuffer();
    this._onSocketClose.flushBuffer();
    this._onSocketTimeout.flushBuffer();
    this._socket.dispose();
    this._lastReplayRequestTime = 0;
    this._lastSocketTimeoutTime = Date.now();
    this._socket = socket;
    this._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));
    this._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));
    this._socketDisposables.add(this._socketReader.onMessage((msg) => this._receiveMessage(msg)));
    this._socketDisposables.add(this._socket.onClose((e) => this._onSocketClose.fire(e)));
    this._socketReader.acceptChunk(initialDataChunk);
  }
  endAcceptReconnection() {
    this._isReconnecting = false;
    this._incomingAckId = this._incomingMsgId;
    const msg = new ProtocolMessage(3, 0, this._incomingAckId, getEmptyBuffer());
    this._socketWriter.write(msg);
    const toSend = this._outgoingUnackMsg.toArray();
    for (let i = 0, len = toSend.length; i < len; i++) {
      this._socketWriter.write(toSend[i]);
    }
    this._recvAckCheck();
  }
  acceptDisconnect() {
    this._onDidDispose.fire();
  }
  _receiveMessage(msg) {
    if (msg.ack > this._outgoingAckId) {
      this._outgoingAckId = msg.ack;
      do {
        const first = this._outgoingUnackMsg.peek();
        if (first && first.id <= msg.ack) {
          this._outgoingUnackMsg.pop();
        } else {
          break;
        }
      } while (true);
    }
    switch (msg.type) {
      case 0: {
        break;
      }
      case 1: {
        if (msg.id > this._incomingMsgId) {
          if (msg.id !== this._incomingMsgId + 1) {
            const now = Date.now();
            if (now - this._lastReplayRequestTime > 1e4) {
              this._lastReplayRequestTime = now;
              this._socketWriter.write(new ProtocolMessage(6, 0, 0, getEmptyBuffer()));
            }
          } else {
            this._incomingMsgId = msg.id;
            this._incomingMsgLastTime = Date.now();
            this._sendAckCheck();
            this._onMessage.fire(msg.data);
          }
        }
        break;
      }
      case 2: {
        this._onControlMessage.fire(msg.data);
        break;
      }
      case 3: {
        break;
      }
      case 5: {
        this._onDidDispose.fire();
        break;
      }
      case 6: {
        const toSend = this._outgoingUnackMsg.toArray();
        for (let i = 0, len = toSend.length; i < len; i++) {
          this._socketWriter.write(toSend[i]);
        }
        this._recvAckCheck();
        break;
      }
      case 7: {
        this._socketWriter.pause();
        break;
      }
      case 8: {
        this._socketWriter.resume();
        break;
      }
    }
  }
  readEntireBuffer() {
    return this._socketReader.readEntireBuffer();
  }
  flush() {
    this._socketWriter.flush();
  }
  send(buffer) {
    const myId = ++this._outgoingMsgId;
    this._incomingAckId = this._incomingMsgId;
    const msg = new ProtocolMessage(1, myId, this._incomingAckId, buffer);
    this._outgoingUnackMsg.push(msg);
    if (!this._isReconnecting) {
      this._socketWriter.write(msg);
      this._recvAckCheck();
    }
  }
  sendControl(buffer) {
    const msg = new ProtocolMessage(2, 0, 0, buffer);
    this._socketWriter.write(msg);
  }
  _sendAckCheck() {
    if (this._incomingMsgId <= this._incomingAckId) {
      return;
    }
    if (this._incomingAckTimeout) {
      return;
    }
    const timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;
    if (timeSinceLastIncomingMsg >= 2e3) {
      this._sendAck();
      return;
    }
    this._incomingAckTimeout = setTimeout(() => {
      this._incomingAckTimeout = null;
      this._sendAckCheck();
    }, 2e3 - timeSinceLastIncomingMsg + 5);
  }
  _recvAckCheck() {
    if (this._outgoingMsgId <= this._outgoingAckId) {
      return;
    }
    if (this._outgoingAckTimeout) {
      return;
    }
    if (this._isReconnecting) {
      return;
    }
    const oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek();
    const timeSinceOldestUnacknowledgedMsg = Date.now() - oldestUnacknowledgedMsg.writtenTime;
    const timeSinceLastReceivedSomeData = Date.now() - this._socketReader.lastReadTime;
    const timeSinceLastTimeout = Date.now() - this._lastSocketTimeoutTime;
    if (timeSinceOldestUnacknowledgedMsg >= 2e4 && timeSinceLastReceivedSomeData >= 2e4 && timeSinceLastTimeout >= 2e4) {
      if (!this._loadEstimator.hasHighLoad()) {
        this._lastSocketTimeoutTime = Date.now();
        this._onSocketTimeout.fire({
          unacknowledgedMsgCount: this._outgoingUnackMsg.length(),
          timeSinceOldestUnacknowledgedMsg,
          timeSinceLastReceivedSomeData
        });
        return;
      }
    }
    const minimumTimeUntilTimeout = Math.max(2e4 - timeSinceOldestUnacknowledgedMsg, 2e4 - timeSinceLastReceivedSomeData, 2e4 - timeSinceLastTimeout, 500);
    this._outgoingAckTimeout = setTimeout(() => {
      this._outgoingAckTimeout = null;
      this._recvAckCheck();
    }, minimumTimeUntilTimeout);
  }
  _sendAck() {
    if (this._incomingMsgId <= this._incomingAckId) {
      return;
    }
    this._incomingAckId = this._incomingMsgId;
    const msg = new ProtocolMessage(3, 0, this._incomingAckId, getEmptyBuffer());
    this._socketWriter.write(msg);
  }
  _sendKeepAlive() {
    this._incomingAckId = this._incomingMsgId;
    const msg = new ProtocolMessage(
      9,
      0,
      this._incomingAckId,
      getEmptyBuffer()
    );
    this._socketWriter.write(msg);
  }
};

// node_modules/vscode/vscode/src/vs/platform/remote/common/remoteAgentConnection.js
init_remoteAuthorityResolver();
init_remoteHosts();
var RECONNECT_TIMEOUT = 30 * 1e3;
function connectionTypeToString(connectionType) {
  switch (connectionType) {
    case 1:
      return "Management";
    case 2:
      return "ExtensionHost";
    case 3:
      return "Tunnel";
  }
}
function createTimeoutCancellation(millis) {
  const source = new CancellationTokenSource();
  setTimeout(() => source.cancel(), millis);
  return source.token;
}
function combineTimeoutCancellation(a, b) {
  if (a.isCancellationRequested || b.isCancellationRequested) {
    return CancellationToken.Cancelled;
  }
  const source = new CancellationTokenSource();
  a.onCancellationRequested(() => source.cancel());
  b.onCancellationRequested(() => source.cancel());
  return source.token;
}
var PromiseWithTimeout = class {
  get didTimeout() {
    return this._state === "timedout";
  }
  constructor(timeoutCancellationToken) {
    this._state = "pending";
    this._disposables = new DisposableStore();
    this.promise = new Promise((resolve, reject) => {
      this._resolvePromise = resolve;
      this._rejectPromise = reject;
    });
    if (timeoutCancellationToken.isCancellationRequested) {
      this._timeout();
    } else {
      this._disposables.add(timeoutCancellationToken.onCancellationRequested(() => this._timeout()));
    }
  }
  registerDisposable(disposable) {
    if (this._state === "pending") {
      this._disposables.add(disposable);
    } else {
      disposable.dispose();
    }
  }
  _timeout() {
    if (this._state !== "pending") {
      return;
    }
    this._disposables.dispose();
    this._state = "timedout";
    this._rejectPromise(this._createTimeoutError());
  }
  _createTimeoutError() {
    const err = new Error("Time limit reached");
    err.code = "ETIMEDOUT";
    err.syscall = "connect";
    return err;
  }
  resolve(value) {
    if (this._state !== "pending") {
      return;
    }
    this._disposables.dispose();
    this._state = "resolved";
    this._resolvePromise(value);
  }
  reject(err) {
    if (this._state !== "pending") {
      return;
    }
    this._disposables.dispose();
    this._state = "rejected";
    this._rejectPromise(err);
  }
};
function readOneControlMessage(protocol, timeoutCancellationToken) {
  const result = new PromiseWithTimeout(timeoutCancellationToken);
  result.registerDisposable(protocol.onControlMessage((raw) => {
    const msg = JSON.parse(raw.toString());
    const error = getErrorFromMessage(msg);
    if (error) {
      result.reject(error);
    } else {
      result.resolve(msg);
    }
  }));
  return result.promise;
}
function createSocket(logService, remoteSocketFactoryService, connectTo, path, query, debugConnectionType, debugLabel, timeoutCancellationToken) {
  const result = new PromiseWithTimeout(timeoutCancellationToken);
  const sw = StopWatch.create(false);
  logService.info(`Creating a socket (${debugLabel})...`);
  mark(`code/willCreateSocket/${debugConnectionType}`);
  remoteSocketFactoryService.connect(connectTo, path, query, debugLabel).then((socket) => {
    if (result.didTimeout) {
      mark(`code/didCreateSocketError/${debugConnectionType}`);
      logService.info(`Creating a socket (${debugLabel}) finished after ${sw.elapsed()} ms, but this is too late and has timed out already.`);
      socket == null ? void 0 : socket.dispose();
    } else {
      mark(`code/didCreateSocketOK/${debugConnectionType}`);
      logService.info(`Creating a socket (${debugLabel}) was successful after ${sw.elapsed()} ms.`);
      result.resolve(socket);
    }
  }, (err) => {
    mark(`code/didCreateSocketError/${debugConnectionType}`);
    logService.info(`Creating a socket (${debugLabel}) returned an error after ${sw.elapsed()} ms.`);
    logService.error(err);
    result.reject(err);
  });
  return result.promise;
}
function raceWithTimeoutCancellation(promise, timeoutCancellationToken) {
  const result = new PromiseWithTimeout(timeoutCancellationToken);
  promise.then((res) => {
    if (!result.didTimeout) {
      result.resolve(res);
    }
  }, (err) => {
    if (!result.didTimeout) {
      result.reject(err);
    }
  });
  return result.promise;
}
async function connectToRemoteExtensionHostAgent(options, connectionType, args, timeoutCancellationToken) {
  const logPrefix = connectLogPrefix(options, connectionType);
  options.logService.trace(`${logPrefix} 1/6. invoking socketFactory.connect().`);
  let socket;
  try {
    socket = await createSocket(options.logService, options.remoteSocketFactoryService, options.connectTo, getRemoteServerRootPath(options), `reconnectionToken=${options.reconnectionToken}&reconnection=${options.reconnectionProtocol ? "true" : "false"}`, connectionTypeToString(connectionType), `renderer-${connectionTypeToString(connectionType)}-${options.reconnectionToken}`, timeoutCancellationToken);
  } catch (error) {
    options.logService.error(`${logPrefix} socketFactory.connect() failed or timed out. Error:`);
    options.logService.error(error);
    throw error;
  }
  options.logService.trace(`${logPrefix} 2/6. socketFactory.connect() was successful.`);
  let protocol;
  let ownsProtocol;
  if (options.reconnectionProtocol) {
    options.reconnectionProtocol.beginAcceptReconnection(socket, null);
    protocol = options.reconnectionProtocol;
    ownsProtocol = false;
  } else {
    protocol = new PersistentProtocol({ socket });
    ownsProtocol = true;
  }
  options.logService.trace(`${logPrefix} 3/6. sending AuthRequest control message.`);
  const message = await raceWithTimeoutCancellation(options.signService.createNewMessage(generateUuid()), timeoutCancellationToken);
  const authRequest = {
    type: "auth",
    auth: options.connectionToken || "00000000000000000000",
    data: message.data
  };
  protocol.sendControl(VSBuffer.fromString(JSON.stringify(authRequest)));
  try {
    const msg = await readOneControlMessage(protocol, combineTimeoutCancellation(timeoutCancellationToken, createTimeoutCancellation(1e4)));
    if (msg.type !== "sign" || typeof msg.data !== "string") {
      const error = new Error("Unexpected handshake message");
      error.code = "VSCODE_CONNECTION_ERROR";
      throw error;
    }
    options.logService.trace(`${logPrefix} 4/6. received SignRequest control message.`);
    const isValid = await raceWithTimeoutCancellation(options.signService.validate(message, msg.signedData), timeoutCancellationToken);
    if (!isValid) {
      const error = new Error("Refused to connect to unsupported server");
      error.code = "VSCODE_CONNECTION_ERROR";
      throw error;
    }
    const signed = await raceWithTimeoutCancellation(options.signService.sign(msg.data), timeoutCancellationToken);
    const connTypeRequest = {
      type: "connectionType",
      commit: options.commit,
      signedData: signed,
      desiredConnectionType: connectionType
    };
    if (args) {
      connTypeRequest.args = args;
    }
    options.logService.trace(`${logPrefix} 5/6. sending ConnectionTypeRequest control message.`);
    protocol.sendControl(VSBuffer.fromString(JSON.stringify(connTypeRequest)));
    return { protocol, ownsProtocol };
  } catch (error) {
    if (error && error.code === "ETIMEDOUT") {
      options.logService.error(`${logPrefix} the handshake timed out. Error:`);
      options.logService.error(error);
    }
    if (error && error.code === "VSCODE_CONNECTION_ERROR") {
      options.logService.error(`${logPrefix} received error control message when negotiating connection. Error:`);
      options.logService.error(error);
    }
    if (ownsProtocol) {
      safeDisposeProtocolAndSocket(protocol);
    }
    throw error;
  }
}
async function connectToRemoteExtensionHostAgentAndReadOneMessage(options, connectionType, args, timeoutCancellationToken) {
  const startTime = Date.now();
  const logPrefix = connectLogPrefix(options, connectionType);
  const { protocol, ownsProtocol } = await connectToRemoteExtensionHostAgent(options, connectionType, args, timeoutCancellationToken);
  const result = new PromiseWithTimeout(timeoutCancellationToken);
  result.registerDisposable(protocol.onControlMessage((raw) => {
    var _a30;
    const msg = JSON.parse(raw.toString());
    const error = getErrorFromMessage(msg);
    if (error) {
      options.logService.error(`${logPrefix} received error control message when negotiating connection. Error:`);
      options.logService.error(error);
      if (ownsProtocol) {
        safeDisposeProtocolAndSocket(protocol);
      }
      result.reject(error);
    } else {
      (_a30 = options.reconnectionProtocol) == null ? void 0 : _a30.endAcceptReconnection();
      options.logService.trace(`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`);
      result.resolve({ protocol, firstMessage: msg });
    }
  }));
  return result.promise;
}
async function doConnectRemoteAgentExtensionHost(options, startArguments, timeoutCancellationToken) {
  const { protocol, firstMessage } = await connectToRemoteExtensionHostAgentAndReadOneMessage(options, 2, startArguments, timeoutCancellationToken);
  const debugPort = firstMessage && firstMessage.debugPort;
  return { protocol, debugPort };
}
async function resolveConnectionOptions(options, reconnectionToken, reconnectionProtocol) {
  const { connectTo, connectionToken } = await options.addressProvider.getAddress();
  return {
    commit: options.commit,
    quality: options.quality,
    connectTo,
    connectionToken,
    reconnectionToken,
    reconnectionProtocol,
    remoteSocketFactoryService: options.remoteSocketFactoryService,
    signService: options.signService,
    logService: options.logService
  };
}
async function connectRemoteAgentExtensionHost(options, startArguments) {
  return createInitialConnection(options, async (simpleOptions) => {
    const { protocol, debugPort } = await doConnectRemoteAgentExtensionHost(simpleOptions, startArguments, CancellationToken.None);
    return new ExtensionHostPersistentConnection(
      options,
      startArguments,
      simpleOptions.reconnectionToken,
      protocol,
      debugPort
    );
  });
}
async function createInitialConnection(options, connectionFactory) {
  const MAX_ATTEMPTS = 5;
  for (let attempt = 1; ; attempt++) {
    try {
      const reconnectionToken = generateUuid();
      const simpleOptions = await resolveConnectionOptions(options, reconnectionToken, null);
      const result = await connectionFactory(simpleOptions);
      return result;
    } catch (err) {
      if (attempt < MAX_ATTEMPTS) {
        options.logService.error(`[remote-connection][attempt ${attempt}] An error occurred in initial connection! Will retry... Error:`);
        options.logService.error(err);
      } else {
        options.logService.error(`[remote-connection][attempt ${attempt}]  An error occurred in initial connection! It will be treated as a permanent error. Error:`);
        options.logService.error(err);
        PersistentConnection.triggerPermanentFailure(0, 0, RemoteAuthorityResolverError.isHandled(err));
        throw err;
      }
    }
  }
}
function sleep(seconds) {
  return createCancelablePromise((token) => {
    return new Promise((resolve, reject) => {
      const timeout2 = setTimeout(resolve, seconds * 1e3);
      token.onCancellationRequested(() => {
        clearTimeout(timeout2);
        resolve();
      });
    });
  });
}
var ConnectionLostEvent = class {
  constructor(reconnectionToken, millisSinceLastIncomingData) {
    this.reconnectionToken = reconnectionToken;
    this.millisSinceLastIncomingData = millisSinceLastIncomingData;
    this.type = 0;
  }
};
var ReconnectionWaitEvent = class {
  constructor(reconnectionToken, millisSinceLastIncomingData, durationSeconds, cancellableTimer) {
    this.reconnectionToken = reconnectionToken;
    this.millisSinceLastIncomingData = millisSinceLastIncomingData;
    this.durationSeconds = durationSeconds;
    this.cancellableTimer = cancellableTimer;
    this.type = 1;
  }
  skipWait() {
    this.cancellableTimer.cancel();
  }
};
var ReconnectionRunningEvent = class {
  constructor(reconnectionToken, millisSinceLastIncomingData, attempt) {
    this.reconnectionToken = reconnectionToken;
    this.millisSinceLastIncomingData = millisSinceLastIncomingData;
    this.attempt = attempt;
    this.type = 2;
  }
};
var ConnectionGainEvent = class {
  constructor(reconnectionToken, millisSinceLastIncomingData, attempt) {
    this.reconnectionToken = reconnectionToken;
    this.millisSinceLastIncomingData = millisSinceLastIncomingData;
    this.attempt = attempt;
    this.type = 4;
  }
};
var ReconnectionPermanentFailureEvent = class {
  constructor(reconnectionToken, millisSinceLastIncomingData, attempt, handled) {
    this.reconnectionToken = reconnectionToken;
    this.millisSinceLastIncomingData = millisSinceLastIncomingData;
    this.attempt = attempt;
    this.handled = handled;
    this.type = 3;
  }
};
var _PersistentConnection = class _PersistentConnection extends Disposable {
  static triggerPermanentFailure(millisSinceLastIncomingData, attempt, handled) {
    this._permanentFailure = true;
    this._permanentFailureMillisSinceLastIncomingData = millisSinceLastIncomingData;
    this._permanentFailureAttempt = attempt;
    this._permanentFailureHandled = handled;
    this._instances.forEach((instance) => instance._gotoPermanentFailure(this._permanentFailureMillisSinceLastIncomingData, this._permanentFailureAttempt, this._permanentFailureHandled));
  }
  static debugTriggerReconnection() {
    this._instances.forEach((instance) => instance._beginReconnecting());
  }
  static debugPauseSocketWriting() {
    this._instances.forEach((instance) => instance._pauseSocketWriting());
  }
  get _isPermanentFailure() {
    return this._permanentFailure || _PersistentConnection._permanentFailure;
  }
  constructor(_connectionType, _options3, reconnectionToken, protocol, _reconnectionFailureIsFatal) {
    super();
    this._connectionType = _connectionType;
    this._options = _options3;
    this.reconnectionToken = reconnectionToken;
    this.protocol = protocol;
    this._reconnectionFailureIsFatal = _reconnectionFailureIsFatal;
    this._onDidStateChange = this._register(new Emitter());
    this.onDidStateChange = this._onDidStateChange.event;
    this._permanentFailure = false;
    this._isReconnecting = false;
    this._isDisposed = false;
    this._onDidStateChange.fire(new ConnectionGainEvent(this.reconnectionToken, 0, 0));
    this._register(protocol.onSocketClose((e) => {
      const logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);
      if (!e) {
        this._options.logService.info(`${logPrefix} received socket close event.`);
      } else if (e.type === 0) {
        this._options.logService.info(`${logPrefix} received socket close event (hadError: ${e.hadError}).`);
        if (e.error) {
          this._options.logService.error(e.error);
        }
      } else {
        this._options.logService.info(`${logPrefix} received socket close event (wasClean: ${e.wasClean}, code: ${e.code}, reason: ${e.reason}).`);
        if (e.event) {
          this._options.logService.error(e.event);
        }
      }
      this._beginReconnecting();
    }));
    this._register(protocol.onSocketTimeout((e) => {
      const logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);
      this._options.logService.info(`${logPrefix} received socket timeout event (unacknowledgedMsgCount: ${e.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${e.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${e.timeSinceLastReceivedSomeData}).`);
      this._beginReconnecting();
    }));
    _PersistentConnection._instances.push(this);
    this._register(toDisposable(() => {
      const myIndex = _PersistentConnection._instances.indexOf(this);
      if (myIndex >= 0) {
        _PersistentConnection._instances.splice(myIndex, 1);
      }
    }));
    if (this._isPermanentFailure) {
      this._gotoPermanentFailure(_PersistentConnection._permanentFailureMillisSinceLastIncomingData, _PersistentConnection._permanentFailureAttempt, _PersistentConnection._permanentFailureHandled);
    }
  }
  dispose() {
    super.dispose();
    this._isDisposed = true;
  }
  async _beginReconnecting() {
    if (this._isReconnecting) {
      return;
    }
    try {
      this._isReconnecting = true;
      await this._runReconnectingLoop();
    } finally {
      this._isReconnecting = false;
    }
  }
  async _runReconnectingLoop() {
    if (this._isPermanentFailure || this._isDisposed) {
      return;
    }
    const logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);
    this._options.logService.info(`${logPrefix} starting reconnecting loop. You can get more information with the trace log level.`);
    this._onDidStateChange.fire(new ConnectionLostEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData()));
    const TIMES = [0, 5, 5, 10, 10, 10, 10, 10, 30];
    let attempt = -1;
    do {
      attempt++;
      const waitTime = attempt < TIMES.length ? TIMES[attempt] : TIMES[TIMES.length - 1];
      try {
        if (waitTime > 0) {
          const sleepPromise = sleep(waitTime);
          this._onDidStateChange.fire(new ReconnectionWaitEvent(
            this.reconnectionToken,
            this.protocol.getMillisSinceLastIncomingData(),
            waitTime,
            sleepPromise
          ));
          this._options.logService.info(`${logPrefix} waiting for ${waitTime} seconds before reconnecting...`);
          try {
            await sleepPromise;
          } catch {
          }
        }
        if (this._isPermanentFailure) {
          this._options.logService.error(`${logPrefix} permanent failure occurred while running the reconnecting loop.`);
          break;
        }
        this._onDidStateChange.fire(new ReconnectionRunningEvent(
          this.reconnectionToken,
          this.protocol.getMillisSinceLastIncomingData(),
          attempt + 1
        ));
        this._options.logService.info(`${logPrefix} resolving connection...`);
        const simpleOptions = await resolveConnectionOptions(this._options, this.reconnectionToken, this.protocol);
        this._options.logService.info(`${logPrefix} connecting to ${simpleOptions.connectTo}...`);
        await this._reconnect(simpleOptions, createTimeoutCancellation(RECONNECT_TIMEOUT));
        this._options.logService.info(`${logPrefix} reconnected!`);
        this._onDidStateChange.fire(new ConnectionGainEvent(
          this.reconnectionToken,
          this.protocol.getMillisSinceLastIncomingData(),
          attempt + 1
        ));
        break;
      } catch (err) {
        if (err.code === "VSCODE_CONNECTION_ERROR") {
          this._options.logService.error(`${logPrefix} A permanent error occurred in the reconnecting loop! Will give up now! Error:`);
          this._options.logService.error(err);
          this._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);
          break;
        }
        if (attempt > 360) {
          this._options.logService.error(`${logPrefix} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time has expired! Will give up now! Error:`);
          this._options.logService.error(err);
          this._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);
          break;
        }
        if (RemoteAuthorityResolverError.isTemporarilyNotAvailable(err)) {
          this._options.logService.info(`${logPrefix} A temporarily not available error occurred while trying to reconnect, will try again...`);
          this._options.logService.trace(err);
          continue;
        }
        if ((err.code === "ETIMEDOUT" || err.code === "ENETUNREACH" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET") && err.syscall === "connect") {
          this._options.logService.info(`${logPrefix} A network error occurred while trying to reconnect, will try again...`);
          this._options.logService.trace(err);
          continue;
        }
        if (isCancellationError(err)) {
          this._options.logService.info(`${logPrefix} A promise cancelation error occurred while trying to reconnect, will try again...`);
          this._options.logService.trace(err);
          continue;
        }
        if (err instanceof RemoteAuthorityResolverError) {
          this._options.logService.error(`${logPrefix} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`);
          this._options.logService.error(err);
          this._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, RemoteAuthorityResolverError.isHandled(err));
          break;
        }
        this._options.logService.error(`${logPrefix} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`);
        this._options.logService.error(err);
        this._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);
        break;
      }
    } while (!this._isPermanentFailure && !this._isDisposed);
  }
  _onReconnectionPermanentFailure(millisSinceLastIncomingData, attempt, handled) {
    if (this._reconnectionFailureIsFatal) {
      _PersistentConnection.triggerPermanentFailure(millisSinceLastIncomingData, attempt, handled);
    } else {
      this._gotoPermanentFailure(millisSinceLastIncomingData, attempt, handled);
    }
  }
  _gotoPermanentFailure(millisSinceLastIncomingData, attempt, handled) {
    this._onDidStateChange.fire(new ReconnectionPermanentFailureEvent(this.reconnectionToken, millisSinceLastIncomingData, attempt, handled));
    safeDisposeProtocolAndSocket(this.protocol);
  }
  _pauseSocketWriting() {
    this.protocol.pauseSocketWriting();
  }
};
_PersistentConnection._permanentFailure = false;
_PersistentConnection._permanentFailureMillisSinceLastIncomingData = 0;
_PersistentConnection._permanentFailureAttempt = 0;
_PersistentConnection._permanentFailureHandled = false;
_PersistentConnection._instances = [];
var PersistentConnection = _PersistentConnection;
var ExtensionHostPersistentConnection = class extends PersistentConnection {
  constructor(options, startArguments, reconnectionToken, protocol, debugPort) {
    super(2, options, reconnectionToken, protocol, false);
    this._startArguments = startArguments;
    this.debugPort = debugPort;
  }
  async _reconnect(options, timeoutCancellationToken) {
    await doConnectRemoteAgentExtensionHost(options, this._startArguments, timeoutCancellationToken);
  }
};
function safeDisposeProtocolAndSocket(protocol) {
  try {
    protocol.acceptDisconnect();
    const socket = protocol.getSocket();
    protocol.dispose();
    socket.dispose();
  } catch (err) {
    onUnexpectedError(err);
  }
}
function getErrorFromMessage(msg) {
  if (msg && msg.type === "error") {
    const error = new Error(`Connection error: ${msg.reason}`);
    error.code = "VSCODE_CONNECTION_ERROR";
    return error;
  }
  return null;
}
function stringRightPad(str, len) {
  while (str.length < len) {
    str += " ";
  }
  return str;
}
function _commonLogPrefix(connectionType, reconnectionToken) {
  return `[remote-connection][${stringRightPad(connectionTypeToString(connectionType), 13)}][${reconnectionToken.substr(0, 5)}…]`;
}
function commonLogPrefix(connectionType, reconnectionToken, isReconnect) {
  return `${_commonLogPrefix(connectionType, reconnectionToken)}[${isReconnect ? "reconnect" : "initial"}]`;
}
function connectLogPrefix(options, connectionType) {
  return `${commonLogPrefix(connectionType, options.reconnectionToken, !!options.reconnectionProtocol)}[${options.connectTo}]`;
}
function logElapsed(startTime) {
  return `${Date.now() - startTime} ms`;
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/remoteExtensionHost.js
init_remoteAuthorityResolver();
init_telemetry();
init_telemetryUtils();
init_extensionHostProtocol();
var RemoteExtensionHost = class RemoteExtensionHost2 extends Disposable {
  constructor(runningLocation, _initDataProvider, remoteSocketFactoryService, _contextService, _environmentService, _telemetryService, _logService, _loggerService, _labelService, remoteAuthorityResolverService, _extensionHostDebugService, _productService, _signService) {
    super();
    this.runningLocation = runningLocation;
    this._initDataProvider = _initDataProvider;
    this.remoteSocketFactoryService = remoteSocketFactoryService;
    this._contextService = _contextService;
    this._environmentService = _environmentService;
    this._telemetryService = _telemetryService;
    this._logService = _logService;
    this._loggerService = _loggerService;
    this._labelService = _labelService;
    this.remoteAuthorityResolverService = remoteAuthorityResolverService;
    this._extensionHostDebugService = _extensionHostDebugService;
    this._productService = _productService;
    this._signService = _signService;
    this.startup = 1;
    this.extensions = new ExtensionHostExtensions();
    this._onExit = this._register(new Emitter());
    this.onExit = this._onExit.event;
    this.remoteAuthority = this._initDataProvider.remoteAuthority;
    this._protocol = null;
    this._hasLostConnection = false;
    this._terminating = false;
    const devOpts = parseExtensionDevOptions(this._environmentService);
    this._isExtensionDevHost = devOpts.isExtensionDevHost;
  }
  async start() {
    const options = {
      commit: this._productService.commit,
      quality: this._productService.quality,
      addressProvider: {
        getAddress: async () => {
          const { authority } = await this.remoteAuthorityResolverService.resolveAuthority(this._initDataProvider.remoteAuthority);
          return { connectTo: authority.connectTo, connectionToken: authority.connectionToken };
        }
      },
      remoteSocketFactoryService: this.remoteSocketFactoryService,
      signService: this._signService,
      logService: this._logService,
      ipcLogger: null
    };
    const initDataPromise = this._initDataProvider.getInitData();
    return this.remoteAuthorityResolverService.resolveAuthority(this._initDataProvider.remoteAuthority).then((resolverResult) => {
      var _a30;
      const startParams = {
        language,
        debugId: this._environmentService.debugExtensionHost.debugId,
        break: this._environmentService.debugExtensionHost.break,
        port: this._environmentService.debugExtensionHost.port,
        env: { ...this._environmentService.debugExtensionHost.env, ...(_a30 = resolverResult.options) == null ? void 0 : _a30.extensionHostEnv }
      };
      const extDevLocs = this._environmentService.extensionDevelopmentLocationURI;
      let debugOk = true;
      if (extDevLocs && extDevLocs.length > 0) {
        if (extDevLocs[0].scheme === Schemas.file) {
          debugOk = false;
        }
      }
      if (!debugOk) {
        startParams.break = false;
      }
      return connectRemoteAgentExtensionHost(options, startParams).then((result) => {
        this._register(result);
        const { protocol, debugPort, reconnectionToken } = result;
        const isExtensionDevelopmentDebug = typeof debugPort === "number";
        if (debugOk && this._environmentService.isExtensionDevelopment && this._environmentService.debugExtensionHost.debugId && debugPort) {
          this._extensionHostDebugService.attachSession(this._environmentService.debugExtensionHost.debugId, debugPort, this._initDataProvider.remoteAuthority);
        }
        protocol.onDidDispose(() => {
          this._onExtHostConnectionLost(reconnectionToken);
        });
        protocol.onSocketClose(() => {
          if (this._isExtensionDevHost) {
            this._onExtHostConnectionLost(reconnectionToken);
          }
        });
        return new Promise((resolve, reject) => {
          const handle = setTimeout(() => {
            reject("The remote extension host took longer than 60s to send its ready message.");
          }, 60 * 1e3);
          const disposable = protocol.onMessage((msg) => {
            if (isMessageOfType(msg, 1)) {
              this._createExtHostInitData(initDataPromise, isExtensionDevelopmentDebug).then((data) => {
                protocol.send(VSBuffer.fromString(JSON.stringify(data)));
              });
              return;
            }
            if (isMessageOfType(msg, 0)) {
              clearTimeout(handle);
              disposable.dispose();
              this._protocol = protocol;
              resolve(protocol);
              return;
            }
            console.error(`received unexpected message during handshake phase from the extension host: `, msg);
          });
        });
      });
    });
  }
  _onExtHostConnectionLost(reconnectionToken) {
    if (this._hasLostConnection) {
      return;
    }
    this._hasLostConnection = true;
    if (this._isExtensionDevHost && this._environmentService.debugExtensionHost.debugId) {
      this._extensionHostDebugService.close(this._environmentService.debugExtensionHost.debugId);
    }
    if (this._terminating) {
      return;
    }
    this._onExit.fire([0, reconnectionToken]);
  }
  async _createExtHostInitData(initDataPromise, isExtensionDevelopmentDebug) {
    const remoteInitData = await initDataPromise;
    const workspace = this._contextService.getWorkspace();
    const deltaExtensions = this.extensions.set(remoteInitData.allExtensions, remoteInitData.myExtensions);
    return {
      commit: this._productService.commit,
      version: this._productService.version,
      quality: this._productService.quality,
      parentPid: remoteInitData.pid,
      environment: {
        isExtensionDevelopmentDebug,
        appRoot: remoteInitData.appRoot,
        appName: this._productService.nameLong,
        appHost: this._productService.embedderIdentifier || "desktop",
        appUriScheme: this._productService.urlProtocol,
        extensionTelemetryLogResource: this._environmentService.extHostTelemetryLogFile,
        isExtensionTelemetryLoggingOnly: isLoggingOnly(this._productService, this._environmentService),
        appLanguage: language,
        extensionDevelopmentLocationURI: this._environmentService.extensionDevelopmentLocationURI,
        extensionTestsLocationURI: this._environmentService.extensionTestsLocationURI,
        globalStorageHome: remoteInitData.globalStorageHome,
        workspaceStorageHome: remoteInitData.workspaceStorageHome,
        extensionLogLevel: this._environmentService.extensionLogLevel
      },
      workspace: this._contextService.getWorkbenchState() === 1 ? null : {
        configuration: workspace.configuration,
        id: workspace.id,
        name: this._labelService.getWorkspaceLabel(workspace),
        transient: workspace.transient
      },
      remote: {
        isRemote: true,
        authority: this._initDataProvider.remoteAuthority,
        connectionData: remoteInitData.connectionData
      },
      consoleForward: {
        includeStack: false,
        logNative: Boolean(this._environmentService.debugExtensionHost.debugId)
      },
      allExtensions: deltaExtensions.toAdd,
      activationEvents: deltaExtensions.addActivationEvents,
      myExtensions: deltaExtensions.myToAdd,
      telemetryInfo: {
        sessionId: this._telemetryService.sessionId,
        machineId: this._telemetryService.machineId,
        firstSessionDate: this._telemetryService.firstSessionDate,
        msftInternal: this._telemetryService.msftInternal
      },
      logLevel: this._logService.getLevel(),
      loggers: [...this._loggerService.getRegisteredLoggers()],
      logsLocation: remoteInitData.extensionHostLogsPath,
      autoStart: this.startup === 1,
      uiKind: isWeb ? UIKind.Web : UIKind.Desktop
    };
  }
  getInspectPort() {
    return void 0;
  }
  enableInspectPort() {
    return Promise.resolve(false);
  }
  dispose() {
    super.dispose();
    this._terminating = true;
    if (this._protocol) {
      const socket = this._protocol.getSocket();
      this._protocol.send(createMessageOfType(2));
      this._protocol.sendDisconnect();
      this._protocol.dispose();
      socket.end();
      this._protocol = null;
    }
  }
};
RemoteExtensionHost = __decorate([
  __param(2, IRemoteSocketFactoryService),
  __param(3, IWorkspaceContextService),
  __param(4, IWorkbenchEnvironmentService),
  __param(5, ITelemetryService),
  __param(6, ILogService),
  __param(7, ILoggerService),
  __param(8, ILabelService),
  __param(9, IRemoteAuthorityResolverService),
  __param(10, IExtensionHostDebugService),
  __param(11, IProductService),
  __param(12, ISignService)
], RemoteExtensionHost);

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/browser/extensionService.js
var BrowserExtensionHostKindPicker_1;
var BrowserExtensionHostFactory = class BrowserExtensionHostFactory2 {
  constructor(_extensionsProposedApi, _scanWebExtensions, _getExtensions, _instantiationService, _remoteAgentService, _remoteAuthorityResolverService, _extensionEnablementService) {
    this._extensionsProposedApi = _extensionsProposedApi;
    this._scanWebExtensions = _scanWebExtensions;
    this._getExtensions = _getExtensions;
    this._instantiationService = _instantiationService;
    this._remoteAgentService = _remoteAgentService;
    this._remoteAuthorityResolverService = _remoteAuthorityResolverService;
    this._extensionEnablementService = _extensionEnablementService;
  }
  createExtensionHost(runningLocations, runningLocation, isInitialStart) {
    switch (runningLocation.kind) {
      case 1: {
        return null;
      }
      case 2: {
        const startup = isInitialStart ? 2 : 1;
        return this._instantiationService.createInstance(WebWorkerExtensionHost, runningLocation, startup, this._createLocalExtensionHostDataProvider(runningLocations, runningLocation, isInitialStart));
      }
      case 3: {
        const remoteAgentConnection = this._remoteAgentService.getConnection();
        if (remoteAgentConnection) {
          return this._instantiationService.createInstance(RemoteExtensionHost, runningLocation, this._createRemoteExtensionHostDataProvider(runningLocations, remoteAgentConnection.remoteAuthority));
        }
        return null;
      }
    }
  }
  _createLocalExtensionHostDataProvider(runningLocations, desiredRunningLocation, isInitialStart) {
    return {
      getInitData: async () => {
        if (isInitialStart) {
          const localExtensions = checkEnabledAndProposedAPI(this._extensionEnablementService, this._extensionsProposedApi, await this._scanWebExtensions(), true);
          const runningLocation = runningLocations.computeRunningLocation(localExtensions, [], false);
          const myExtensions = filterExtensionDescriptions(localExtensions, runningLocation, (extRunningLocation) => desiredRunningLocation.equals(extRunningLocation));
          return {
            allExtensions: localExtensions,
            myExtensions: myExtensions.map((extension) => extension.identifier)
          };
        } else {
          const allExtensions = await this._getExtensions();
          const myExtensions = runningLocations.filterByRunningLocation(allExtensions, desiredRunningLocation);
          return {
            allExtensions,
            myExtensions: myExtensions.map((extension) => extension.identifier)
          };
        }
      }
    };
  }
  _createRemoteExtensionHostDataProvider(runningLocations, remoteAuthority) {
    return {
      remoteAuthority,
      getInitData: async () => {
        const allExtensions = await this._getExtensions();
        const remoteEnv = await this._remoteAgentService.getEnvironment();
        if (!remoteEnv) {
          throw new Error("Cannot provide init data for remote extension host!");
        }
        const myExtensions = runningLocations.filterByExtensionHostKind(allExtensions, 3);
        const initData = {
          connectionData: this._remoteAuthorityResolverService.getConnectionData(remoteAuthority),
          pid: remoteEnv.pid,
          appRoot: remoteEnv.appRoot,
          extensionHostLogsPath: remoteEnv.extensionHostLogsPath,
          globalStorageHome: remoteEnv.globalStorageHome,
          workspaceStorageHome: remoteEnv.workspaceStorageHome,
          allExtensions,
          myExtensions: myExtensions.map((extension) => extension.identifier)
        };
        return initData;
      }
    };
  }
};
BrowserExtensionHostFactory = __decorate([
  __param(3, IInstantiationService),
  __param(4, IRemoteAgentService),
  __param(5, IRemoteAuthorityResolverService),
  __param(6, IWorkbenchExtensionEnablementService)
], BrowserExtensionHostFactory);
var BrowserExtensionHostKindPicker = BrowserExtensionHostKindPicker_1 = class BrowserExtensionHostKindPicker2 {
  constructor(_logService) {
    this._logService = _logService;
  }
  pickExtensionHostKind(extensionId, extensionKinds, isInstalledLocally, isInstalledRemotely, preference) {
    const result = BrowserExtensionHostKindPicker_1.pickRunningLocation(extensionKinds, isInstalledLocally, isInstalledRemotely, preference);
    this._logService.trace(`pickRunningLocation for ${extensionId.value}, extension kinds: [${extensionKinds.join(", ")}], isInstalledLocally: ${isInstalledLocally}, isInstalledRemotely: ${isInstalledRemotely}, preference: ${extensionRunningPreferenceToString(preference)} => ${extensionHostKindToString(result)}`);
    return result;
  }
  static pickRunningLocation(extensionKinds, isInstalledLocally, isInstalledRemotely, preference) {
    const result = [];
    let canRunRemotely = false;
    for (const extensionKind of extensionKinds) {
      if (extensionKind === "ui" && isInstalledRemotely) {
        if (preference === 2) {
          return 3;
        } else {
          canRunRemotely = true;
        }
      }
      if (extensionKind === "workspace" && isInstalledRemotely) {
        if (preference === 0 || preference === 2) {
          return 3;
        } else {
          result.push(3);
        }
      }
      if (extensionKind === "web" && (isInstalledLocally || isInstalledRemotely)) {
        if (preference === 0 || preference === 1) {
          return 2;
        } else {
          result.push(2);
        }
      }
    }
    if (canRunRemotely) {
      result.push(3);
    }
    return result.length > 0 ? result[0] : null;
  }
};
BrowserExtensionHostKindPicker = BrowserExtensionHostKindPicker_1 = __decorate([
  __param(0, ILogService)
], BrowserExtensionHostKindPicker);

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/browser/webWorkerFileSystemProvider.js
init_files();
init_event();
init_lifecycle();
init_errors();
var FetchFileSystemProvider = class {
  constructor() {
    this.capabilities = 2048 + 2 + 1024;
    this.onDidChangeCapabilities = Event.None;
    this.onDidChangeFile = Event.None;
  }
  async readFile(resource) {
    try {
      const res = await fetch(resource.toString(true));
      if (res.status === 200) {
        return new Uint8Array(await res.arrayBuffer());
      }
      throw createFileSystemProviderError(res.statusText, FileSystemProviderErrorCode.Unknown);
    } catch (err) {
      throw createFileSystemProviderError(err, FileSystemProviderErrorCode.Unknown);
    }
  }
  async stat(_resource) {
    return {
      type: FileType.File,
      size: 0,
      mtime: 0,
      ctime: 0
    };
  }
  watch() {
    return Disposable.None;
  }
  writeFile(_resource, _content, _opts) {
    throw new NotSupportedError();
  }
  readdir(_resource) {
    throw new NotSupportedError();
  }
  mkdir(_resource) {
    throw new NotSupportedError();
  }
  delete(_resource, _opts) {
    throw new NotSupportedError();
  }
  rename(_from, _to, _opts) {
    throw new NotSupportedError();
  }
};

// node_modules/vscode/service-override/extensions.js
init_network();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionService.js
init_tslib_es6();
init_nls();
init_path();
init_resources();
init_async();
init_lifecycle();
init_ternarySearchTree();
init_uri();
init_log();
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostConfiguration.js
init_tslib_es6();
init_objects();
init_event();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWorkspace.js
init_tslib_es6();
init_arrays();
init_async();
init_cancellation();
init_event();
init_lifecycle();
init_ternarySearchTree();
init_network();
init_numbers();
init_resources();
init_strings();
init_uri();
init_nls();
init_instantiation();
init_log();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostFileSystemInfo.js
init_network();
init_resources();
init_instantiation();
var ExtHostFileSystemInfo = class {
  constructor() {
    this._systemSchemes = new Set(Object.keys(Schemas));
    this._providerInfo = /* @__PURE__ */ new Map();
    this.extUri = new ExtUri((uri) => {
      const capabilities = this._providerInfo.get(uri.scheme);
      if (capabilities === void 0) {
        return false;
      }
      if (capabilities & 1024) {
        return false;
      }
      return true;
    });
  }
  $acceptProviderInfos(uri, capabilities) {
    if (capabilities === null) {
      this._providerInfo.delete(uri.scheme);
    } else {
      this._providerInfo.set(uri.scheme, capabilities);
    }
  }
  isFreeScheme(scheme) {
    return !this._providerInfo.has(scheme) && !this._systemSchemes.has(scheme);
  }
  getCapabilities(scheme) {
    return this._providerInfo.get(scheme);
  }
};
var IExtHostFileSystemInfo = createDecorator("IExtHostFileSystemInfo");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostInitDataService.js
init_instantiation();
var IExtHostInitDataService = createDecorator("IExtHostInitDataService");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostRpcService.js
init_instantiation();
var IExtHostRpcService = createDecorator("IExtHostRpcService");
var ExtHostRpcService = class {
  constructor(rpcProtocol) {
    this.getProxy = rpcProtocol.getProxy.bind(rpcProtocol);
    this.set = rpcProtocol.set.bind(rpcProtocol);
    this.dispose = rpcProtocol.dispose.bind(rpcProtocol);
    this.assertRegistered = rpcProtocol.assertRegistered.bind(rpcProtocol);
    this.drain = rpcProtocol.drain.bind(rpcProtocol);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTypeConverters.js
init_arrays();
init_buffer();
init_functional();
init_htmlContent();
init_map();
init_mime();
init_objects();
init_types();
init_uri();
init_range();
init_languages();

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testItemCollection.js
init_async();
init_event();
init_lifecycle();
init_assert();

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testTypes.js
init_uri();
init_range();

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testId.js
var TestId = class _TestId {
  static fromExtHostTestItem(item, rootId, parent = item.parent) {
    if (item._isRoot) {
      return new _TestId([rootId]);
    }
    const path = [item.id];
    for (let i = parent; i && i.id !== rootId; i = i.parent) {
      path.push(i.id);
    }
    path.push(rootId);
    return new _TestId(path.reverse());
  }
  static isRoot(idString) {
    return !idString.includes("\0");
  }
  static root(idString) {
    const idx = idString.indexOf("\0");
    return idx === -1 ? idString : idString.slice(0, idx);
  }
  static fromString(idString) {
    return new _TestId(idString.split("\0"));
  }
  static join(base, b) {
    return new _TestId([...base.path, b]);
  }
  static joinToString(base, b) {
    return base.toString() + "\0" + b;
  }
  static parentId(idString) {
    const idx = idString.lastIndexOf("\0");
    return idx === -1 ? void 0 : idString.slice(0, idx);
  }
  static localId(idString) {
    const idx = idString.lastIndexOf("\0");
    return idx === -1 ? idString : idString.slice(idx + "\0".length);
  }
  static isChild(maybeParent, maybeChild) {
    return maybeChild.startsWith(maybeParent) && maybeChild[maybeParent.length] === "\0";
  }
  static compare(a, b) {
    if (a === b) {
      return 0;
    }
    if (_TestId.isChild(a, b)) {
      return 2;
    }
    if (_TestId.isChild(b, a)) {
      return 3;
    }
    return 1;
  }
  constructor(path, viewEnd = path.length) {
    this.path = path;
    this.viewEnd = viewEnd;
    if (path.length === 0 || viewEnd < 1) {
      throw new Error("cannot create test with empty path");
    }
  }
  get rootId() {
    return new _TestId(this.path, 1);
  }
  get parentId() {
    return this.viewEnd > 1 ? new _TestId(this.path, this.viewEnd - 1) : void 0;
  }
  get localId() {
    return this.path[this.viewEnd - 1];
  }
  get controllerId() {
    return this.path[0];
  }
  get isRoot() {
    return this.viewEnd === 1;
  }
  *idsFromRoot() {
    for (let i = 1; i <= this.viewEnd; i++) {
      yield new _TestId(this.path, i);
    }
  }
  *idsToRoot() {
    for (let i = this.viewEnd; i > 0; i--) {
      yield new _TestId(this.path, i);
    }
  }
  compare(other) {
    if (typeof other === "string") {
      return _TestId.compare(this.toString(), other);
    }
    for (let i = 0; i < other.viewEnd && i < this.viewEnd; i++) {
      if (other.path[i] !== this.path[i]) {
        return 1;
      }
    }
    if (other.viewEnd > this.viewEnd) {
      return 2;
    }
    if (other.viewEnd < this.viewEnd) {
      return 3;
    }
    return 0;
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    if (!this.stringifed) {
      this.stringifed = this.path[0];
      for (let i = 1; i < this.viewEnd; i++) {
        this.stringifed += "\0";
        this.stringifed += this.path[i];
      }
    }
    return this.stringifed;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testTypes.js
var isStartControllerTests = (t) => "runId" in t;
var IRichLocation;
(function(IRichLocation2) {
  IRichLocation2.serialize = (location2) => ({
    range: location2.range.toJSON(),
    uri: location2.uri.toJSON()
  });
  IRichLocation2.deserialize = (location2) => ({
    range: Range.lift(location2.range),
    uri: URI.revive(location2.uri)
  });
})(IRichLocation || (IRichLocation = {}));
var ITestErrorMessage;
(function(ITestErrorMessage2) {
  ITestErrorMessage2.serialize = (message) => ({
    message: message.message,
    type: 0,
    expected: message.expected,
    actual: message.actual,
    contextValue: message.contextValue,
    location: message.location && IRichLocation.serialize(message.location)
  });
  ITestErrorMessage2.deserialize = (message) => ({
    message: message.message,
    type: 0,
    expected: message.expected,
    actual: message.actual,
    contextValue: message.contextValue,
    location: message.location && IRichLocation.deserialize(message.location)
  });
})(ITestErrorMessage || (ITestErrorMessage = {}));
var getMarkId = (marker, start) => `${start ? "s" : "e"}${marker}`;
var ITestOutputMessage;
(function(ITestOutputMessage2) {
  ITestOutputMessage2.serialize = (message) => ({
    message: message.message,
    type: 1,
    offset: message.offset,
    length: message.length,
    location: message.location && IRichLocation.serialize(message.location)
  });
  ITestOutputMessage2.deserialize = (message) => ({
    message: message.message,
    type: 1,
    offset: message.offset,
    length: message.length,
    location: message.location && IRichLocation.deserialize(message.location)
  });
})(ITestOutputMessage || (ITestOutputMessage = {}));
var ITestMessage;
(function(ITestMessage2) {
  ITestMessage2.serialize = (message) => message.type === 0 ? ITestErrorMessage.serialize(message) : ITestOutputMessage.serialize(message);
  ITestMessage2.deserialize = (message) => message.type === 0 ? ITestErrorMessage.deserialize(message) : ITestOutputMessage.deserialize(message);
})(ITestMessage || (ITestMessage = {}));
var ITestTaskState;
(function(ITestTaskState2) {
  ITestTaskState2.serializeWithoutMessages = (state) => ({
    state: state.state,
    duration: state.duration,
    messages: []
  });
  ITestTaskState2.serialize = (state) => ({
    state: state.state,
    duration: state.duration,
    messages: state.messages.map(ITestMessage.serialize)
  });
  ITestTaskState2.deserialize = (state) => ({
    state: state.state,
    duration: state.duration,
    messages: state.messages.map(ITestMessage.deserialize)
  });
})(ITestTaskState || (ITestTaskState = {}));
var testTagDelimiter = "\0";
var namespaceTestTag = (ctrlId, tagId) => ctrlId + testTagDelimiter + tagId;
var denamespaceTestTag = (namespaced) => {
  const index = namespaced.indexOf(testTagDelimiter);
  return { ctrlId: namespaced.slice(0, index), tagId: namespaced.slice(index + 1) };
};
var ITestItem;
(function(ITestItem2) {
  ITestItem2.serialize = (item) => {
    var _a30, _b;
    return {
      extId: item.extId,
      label: item.label,
      tags: item.tags,
      busy: item.busy,
      children: void 0,
      uri: (_a30 = item.uri) == null ? void 0 : _a30.toJSON(),
      range: ((_b = item.range) == null ? void 0 : _b.toJSON()) || null,
      description: item.description,
      error: item.error,
      sortText: item.sortText
    };
  };
  ITestItem2.deserialize = (serialized) => ({
    extId: serialized.extId,
    label: serialized.label,
    tags: serialized.tags,
    busy: serialized.busy,
    children: void 0,
    uri: serialized.uri ? URI.revive(serialized.uri) : void 0,
    range: serialized.range ? Range.lift(serialized.range) : null,
    description: serialized.description,
    error: serialized.error,
    sortText: serialized.sortText
  });
})(ITestItem || (ITestItem = {}));
var InternalTestItem;
(function(InternalTestItem2) {
  InternalTestItem2.serialize = (item) => ({
    expand: item.expand,
    item: ITestItem.serialize(item.item)
  });
  InternalTestItem2.deserialize = (serialized) => ({
    controllerId: TestId.root(serialized.item.extId),
    expand: serialized.expand,
    item: ITestItem.deserialize(serialized.item)
  });
})(InternalTestItem || (InternalTestItem = {}));
var ITestItemUpdate;
(function(ITestItemUpdate2) {
  ITestItemUpdate2.serialize = (u) => {
    var _a30, _b;
    let item;
    if (u.item) {
      item = {};
      if (u.item.label !== void 0) {
        item.label = u.item.label;
      }
      if (u.item.tags !== void 0) {
        item.tags = u.item.tags;
      }
      if (u.item.busy !== void 0) {
        item.busy = u.item.busy;
      }
      if (u.item.uri !== void 0) {
        item.uri = (_a30 = u.item.uri) == null ? void 0 : _a30.toJSON();
      }
      if (u.item.range !== void 0) {
        item.range = (_b = u.item.range) == null ? void 0 : _b.toJSON();
      }
      if (u.item.description !== void 0) {
        item.description = u.item.description;
      }
      if (u.item.error !== void 0) {
        item.error = u.item.error;
      }
      if (u.item.sortText !== void 0) {
        item.sortText = u.item.sortText;
      }
    }
    return { extId: u.extId, expand: u.expand, item };
  };
  ITestItemUpdate2.deserialize = (u) => {
    let item;
    if (u.item) {
      item = {};
      if (u.item.label !== void 0) {
        item.label = u.item.label;
      }
      if (u.item.tags !== void 0) {
        item.tags = u.item.tags;
      }
      if (u.item.busy !== void 0) {
        item.busy = u.item.busy;
      }
      if (u.item.range !== void 0) {
        item.range = u.item.range ? Range.lift(u.item.range) : null;
      }
      if (u.item.description !== void 0) {
        item.description = u.item.description;
      }
      if (u.item.error !== void 0) {
        item.error = u.item.error;
      }
      if (u.item.sortText !== void 0) {
        item.sortText = u.item.sortText;
      }
    }
    return { extId: u.extId, expand: u.expand, item };
  };
})(ITestItemUpdate || (ITestItemUpdate = {}));
var applyTestItemUpdate = (internal, patch) => {
  if (patch.expand !== void 0) {
    internal.expand = patch.expand;
  }
  if (patch.item !== void 0) {
    internal.item = internal.item ? Object.assign(internal.item, patch.item) : patch.item;
  }
};
var TestResultItem;
(function(TestResultItem2) {
  TestResultItem2.serializeWithoutMessages = (original2) => ({
    ...InternalTestItem.serialize(original2),
    ownComputedState: original2.ownComputedState,
    computedState: original2.computedState,
    tasks: original2.tasks.map(ITestTaskState.serializeWithoutMessages)
  });
  TestResultItem2.serialize = (original2) => ({
    ...InternalTestItem.serialize(original2),
    ownComputedState: original2.ownComputedState,
    computedState: original2.computedState,
    tasks: original2.tasks.map(ITestTaskState.serialize)
  });
  TestResultItem2.deserialize = (serialized) => ({
    ...InternalTestItem.deserialize(serialized),
    ownComputedState: serialized.ownComputedState,
    computedState: serialized.computedState,
    tasks: serialized.tasks.map(ITestTaskState.deserialize),
    retired: true
  });
})(TestResultItem || (TestResultItem = {}));
var TestsDiffOp;
(function(TestsDiffOp2) {
  TestsDiffOp2.deserialize = (u) => {
    if (u.op === 0) {
      return { op: u.op, item: InternalTestItem.deserialize(u.item) };
    } else if (u.op === 1) {
      return { op: u.op, item: ITestItemUpdate.deserialize(u.item) };
    } else if (u.op === 2) {
      return { op: u.op, uri: URI.revive(u.uri), docv: u.docv };
    } else {
      return u;
    }
  };
  TestsDiffOp2.serialize = (u) => {
    if (u.op === 0) {
      return { op: u.op, item: InternalTestItem.serialize(u.item) };
    } else if (u.op === 1) {
      return { op: u.op, item: ITestItemUpdate.serialize(u.item) };
    } else {
      return u;
    }
  };
})(TestsDiffOp || (TestsDiffOp = {}));
var AbstractIncrementalTestCollection = class {
  constructor() {
    this._tags = /* @__PURE__ */ new Map();
    this.items = /* @__PURE__ */ new Map();
    this.roots = /* @__PURE__ */ new Set();
    this.busyControllerCount = 0;
    this.pendingRootCount = 0;
    this.tags = this._tags;
  }
  apply(diff) {
    var _a30;
    const changes = this.createChangeCollector();
    for (const op of diff) {
      switch (op.op) {
        case 0:
          this.add(InternalTestItem.deserialize(op.item), changes);
          break;
        case 1:
          this.update(ITestItemUpdate.deserialize(op.item), changes);
          break;
        case 3:
          this.remove(op.itemId, changes);
          break;
        case 5:
          this.retireTest(op.itemId);
          break;
        case 4:
          this.updatePendingRoots(op.amount);
          break;
        case 6:
          this._tags.set(op.tag.id, op.tag);
          break;
        case 7:
          this._tags.delete(op.id);
          break;
      }
    }
    (_a30 = changes.complete) == null ? void 0 : _a30.call(changes);
  }
  add(item, changes) {
    var _a30, _b;
    const parentId = (_a30 = TestId.parentId(item.item.extId)) == null ? void 0 : _a30.toString();
    let created;
    if (!parentId) {
      created = this.createItem(item);
      this.roots.add(created);
      this.items.set(item.item.extId, created);
    } else if (this.items.has(parentId)) {
      const parent = this.items.get(parentId);
      parent.children.add(item.item.extId);
      created = this.createItem(item, parent);
      this.items.set(item.item.extId, created);
    } else {
      console.error(`Test with unknown parent ID: ${JSON.stringify(item)}`);
      return;
    }
    (_b = changes.add) == null ? void 0 : _b.call(changes, created);
    if (item.expand === 2) {
      this.busyControllerCount++;
    }
    return created;
  }
  update(patch, changes) {
    var _a30;
    const existing = this.items.get(patch.extId);
    if (!existing) {
      return;
    }
    if (patch.expand !== void 0) {
      if (existing.expand === 2) {
        this.busyControllerCount--;
      }
      if (patch.expand === 2) {
        this.busyControllerCount++;
      }
    }
    applyTestItemUpdate(existing, patch);
    (_a30 = changes.update) == null ? void 0 : _a30.call(changes, existing);
    return existing;
  }
  remove(itemId, changes) {
    var _a30, _b;
    const toRemove = this.items.get(itemId);
    if (!toRemove) {
      return;
    }
    const parentId = (_a30 = TestId.parentId(toRemove.item.extId)) == null ? void 0 : _a30.toString();
    if (parentId) {
      const parent = this.items.get(parentId);
      parent.children.delete(toRemove.item.extId);
    } else {
      this.roots.delete(toRemove);
    }
    const queue = [[itemId]];
    while (queue.length) {
      for (const itemId2 of queue.pop()) {
        const existing = this.items.get(itemId2);
        if (existing) {
          queue.push(existing.children);
          this.items.delete(itemId2);
          (_b = changes.remove) == null ? void 0 : _b.call(changes, existing, existing !== toRemove);
          if (existing.expand === 2) {
            this.busyControllerCount--;
          }
        }
      }
    }
  }
  retireTest(testId) {
  }
  updatePendingRoots(delta3) {
    this.pendingRootCount += delta3;
  }
  createChangeCollector() {
    return {};
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testItemCollection.js
var strictEqualComparator = (a, b) => a === b;
var diffableProps = {
  range: (a, b) => {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.equalsRange(b);
  },
  busy: strictEqualComparator,
  label: strictEqualComparator,
  description: strictEqualComparator,
  error: strictEqualComparator,
  sortText: strictEqualComparator,
  tags: (a, b) => {
    if (a.length !== b.length) {
      return false;
    }
    if (a.some((t1) => !b.includes(t1))) {
      return false;
    }
    return true;
  }
};
var diffableEntries = Object.entries(diffableProps);
var diffTestItems = (a, b) => {
  let output;
  for (const [key, cmp] of diffableEntries) {
    if (!cmp(a[key], b[key])) {
      if (output) {
        output[key] = b[key];
      } else {
        output = { [key]: b[key] };
      }
    }
  }
  return output;
};
var TestItemCollection = class extends Disposable {
  get root() {
    return this.options.root;
  }
  constructor(options) {
    super();
    this.options = options;
    this.debounceSendDiff = this._register(new RunOnceScheduler(() => this.flushDiff(), 200));
    this.diffOpEmitter = this._register(new Emitter());
    this.tree = /* @__PURE__ */ new Map();
    this.tags = /* @__PURE__ */ new Map();
    this.diff = [];
    this.onDidGenerateDiff = this.diffOpEmitter.event;
    this.root.canResolveChildren = true;
    this.upsertItem(this.root, void 0);
  }
  set resolveHandler(handler) {
    this._resolveHandler = handler;
    for (const test of this.tree.values()) {
      this.updateExpandability(test);
    }
  }
  get resolveHandler() {
    return this._resolveHandler;
  }
  collectDiff() {
    const diff = this.diff;
    this.diff = [];
    return diff;
  }
  pushDiff(diff) {
    switch (diff.op) {
      case 2: {
        for (const existing of this.diff) {
          if (existing.op === 2 && existing.uri === diff.uri) {
            existing.docv = diff.docv;
            return;
          }
        }
        break;
      }
      case 1: {
        const last = this.diff[this.diff.length - 1];
        if (last) {
          if (last.op === 1 && last.item.extId === diff.item.extId) {
            applyTestItemUpdate(last.item, diff.item);
            return;
          }
          if (last.op === 0 && last.item.item.extId === diff.item.extId) {
            applyTestItemUpdate(last.item, diff.item);
            return;
          }
        }
        break;
      }
    }
    this.diff.push(diff);
    if (!this.debounceSendDiff.isScheduled()) {
      this.debounceSendDiff.schedule();
    }
  }
  expand(testId, levels) {
    var _a30;
    const internal = this.tree.get(testId);
    if (!internal) {
      return;
    }
    if (internal.expandLevels === void 0 || levels > internal.expandLevels) {
      internal.expandLevels = levels;
    }
    if (internal.expand === 1) {
      const r = this.resolveChildren(internal);
      return !r.isOpen() ? r.wait().then(() => this.expandChildren(internal, levels - 1)) : this.expandChildren(internal, levels - 1);
    } else if (internal.expand === 3) {
      return ((_a30 = internal.resolveBarrier) == null ? void 0 : _a30.isOpen()) === false ? internal.resolveBarrier.wait().then(() => this.expandChildren(internal, levels - 1)) : this.expandChildren(internal, levels - 1);
    }
  }
  dispose() {
    for (const item of this.tree.values()) {
      this.options.getApiFor(item.actual).listener = void 0;
    }
    this.tree.clear();
    this.diff = [];
    super.dispose();
  }
  onTestItemEvent(internal, evt) {
    switch (evt.op) {
      case 3:
        this.removeItem(TestId.joinToString(internal.fullId, evt.id));
        break;
      case 0:
        this.upsertItem(evt.item, internal);
        break;
      case 5:
        for (const op of evt.ops) {
          this.onTestItemEvent(internal, op);
        }
        break;
      case 1:
        this.diffTagRefs(evt.new, evt.old, internal.fullId.toString());
        break;
      case 2:
        this.updateExpandability(internal);
        break;
      case 4:
        this.pushDiff({
          op: 1,
          item: {
            extId: internal.fullId.toString(),
            item: evt.update
          }
        });
        break;
      case 6:
        this.documentSynced(internal.actual.uri);
        break;
      default:
        assertNever(evt);
    }
  }
  documentSynced(uri) {
    if (uri) {
      this.pushDiff({
        op: 2,
        uri,
        docv: this.options.getDocumentVersion(uri)
      });
    }
  }
  upsertItem(actual, parent) {
    var _a30, _b;
    const fullId = TestId.fromExtHostTestItem(actual, this.root.id, parent == null ? void 0 : parent.actual);
    const privateApi = this.options.getApiFor(actual);
    if (privateApi.parent && privateApi.parent !== (parent == null ? void 0 : parent.actual)) {
      this.options.getChildren(privateApi.parent).delete(actual.id);
    }
    let internal = this.tree.get(fullId.toString());
    if (!internal) {
      internal = {
        fullId,
        actual,
        expandLevels: (parent == null ? void 0 : parent.expandLevels) ? parent.expandLevels - 1 : void 0,
        expand: 0
      };
      actual.tags.forEach(this.incrementTagRefs, this);
      this.tree.set(internal.fullId.toString(), internal);
      this.setItemParent(actual, parent);
      this.pushDiff({
        op: 0,
        item: {
          controllerId: this.options.controllerId,
          expand: internal.expand,
          item: this.options.toITestItem(actual)
        }
      });
      this.connectItemAndChildren(actual, internal, parent);
      return;
    }
    if (internal.actual === actual) {
      this.connectItem(actual, internal, parent);
      return;
    }
    if (((_a30 = internal.actual.uri) == null ? void 0 : _a30.toString()) !== ((_b = actual.uri) == null ? void 0 : _b.toString())) {
      this.removeItem(fullId.toString());
      return this.upsertItem(actual, parent);
    }
    const oldChildren = this.options.getChildren(internal.actual);
    const oldActual = internal.actual;
    const update = diffTestItems(this.options.toITestItem(oldActual), this.options.toITestItem(actual));
    this.options.getApiFor(oldActual).listener = void 0;
    internal.actual = actual;
    internal.expand = 0;
    if (update) {
      if (update.hasOwnProperty("tags")) {
        this.diffTagRefs(actual.tags, oldActual.tags, fullId.toString());
        delete update.tags;
      }
      this.onTestItemEvent(internal, { op: 4, update });
    }
    this.connectItemAndChildren(actual, internal, parent);
    for (const [_, child] of oldChildren) {
      if (!this.options.getChildren(actual).get(child.id)) {
        this.removeItem(TestId.joinToString(fullId, child.id));
      }
    }
    this.documentSynced(internal.actual.uri);
  }
  diffTagRefs(newTags, oldTags, extId) {
    const toDelete = new Set(oldTags.map((t) => t.id));
    for (const tag of newTags) {
      if (!toDelete.delete(tag.id)) {
        this.incrementTagRefs(tag);
      }
    }
    this.pushDiff({
      op: 1,
      item: { extId, item: { tags: newTags.map((v) => namespaceTestTag(this.options.controllerId, v.id)) } }
    });
    toDelete.forEach(this.decrementTagRefs, this);
  }
  incrementTagRefs(tag) {
    const existing = this.tags.get(tag.id);
    if (existing) {
      existing.refCount++;
    } else {
      this.tags.set(tag.id, { refCount: 1 });
      this.pushDiff({
        op: 6,
        tag: {
          id: namespaceTestTag(this.options.controllerId, tag.id)
        }
      });
    }
  }
  decrementTagRefs(tagId) {
    const existing = this.tags.get(tagId);
    if (existing && !--existing.refCount) {
      this.tags.delete(tagId);
      this.pushDiff({ op: 7, id: namespaceTestTag(this.options.controllerId, tagId) });
    }
  }
  setItemParent(actual, parent) {
    this.options.getApiFor(actual).parent = parent && parent.actual !== this.root ? parent.actual : void 0;
  }
  connectItem(actual, internal, parent) {
    this.setItemParent(actual, parent);
    const api = this.options.getApiFor(actual);
    api.parent = parent == null ? void 0 : parent.actual;
    api.listener = (evt) => this.onTestItemEvent(internal, evt);
    this.updateExpandability(internal);
  }
  connectItemAndChildren(actual, internal, parent) {
    this.connectItem(actual, internal, parent);
    for (const [_, child] of this.options.getChildren(actual)) {
      this.upsertItem(child, internal);
    }
  }
  updateExpandability(internal) {
    let newState;
    if (!this._resolveHandler) {
      newState = 0;
    } else if (internal.resolveBarrier) {
      newState = internal.resolveBarrier.isOpen() ? 3 : 2;
    } else {
      newState = internal.actual.canResolveChildren ? 1 : 0;
    }
    if (newState === internal.expand) {
      return;
    }
    internal.expand = newState;
    this.pushDiff({ op: 1, item: { extId: internal.fullId.toString(), expand: newState } });
    if (newState === 1 && internal.expandLevels !== void 0) {
      this.resolveChildren(internal);
    }
  }
  expandChildren(internal, levels) {
    if (levels < 0) {
      return;
    }
    const expandRequests = [];
    for (const [_, child] of this.options.getChildren(internal.actual)) {
      const promise = this.expand(TestId.joinToString(internal.fullId, child.id), levels);
      if (isThenable(promise)) {
        expandRequests.push(promise);
      }
    }
    if (expandRequests.length) {
      return Promise.all(expandRequests).then(() => {
      });
    }
  }
  resolveChildren(internal) {
    if (internal.resolveBarrier) {
      return internal.resolveBarrier;
    }
    if (!this._resolveHandler) {
      const b = new Barrier();
      b.open();
      return b;
    }
    internal.expand = 2;
    this.pushExpandStateUpdate(internal);
    const barrier = internal.resolveBarrier = new Barrier();
    const applyError = (err) => {
      console.error(`Unhandled error in resolveHandler of test controller "${this.options.controllerId}"`, err);
    };
    let r;
    try {
      r = this._resolveHandler(internal.actual === this.root ? void 0 : internal.actual);
    } catch (err) {
      applyError(err);
    }
    if (isThenable(r)) {
      r.catch(applyError).then(() => {
        barrier.open();
        this.updateExpandability(internal);
      });
    } else {
      barrier.open();
      this.updateExpandability(internal);
    }
    return internal.resolveBarrier;
  }
  pushExpandStateUpdate(internal) {
    this.pushDiff({ op: 1, item: { extId: internal.fullId.toString(), expand: internal.expand } });
  }
  removeItem(childId) {
    const childItem = this.tree.get(childId);
    if (!childItem) {
      throw new Error("attempting to remove non-existent child");
    }
    this.pushDiff({ op: 3, itemId: childId });
    const queue = [childItem];
    while (queue.length) {
      const item = queue.pop();
      if (!item) {
        continue;
      }
      this.options.getApiFor(item.actual).listener = void 0;
      for (const tag of item.actual.tags) {
        this.decrementTagRefs(tag.id);
      }
      this.tree.delete(item.fullId.toString());
      for (const [_, child] of this.options.getChildren(item.actual)) {
        queue.push(this.tree.get(TestId.joinToString(item.fullId, child.id)));
      }
    }
  }
  flushDiff() {
    const diff = this.collectDiff();
    if (diff.length) {
      this.diffOpEmitter.fire(diff);
    }
  }
};
var DuplicateTestItemError = class extends Error {
  constructor(id) {
    super(`Attempted to insert a duplicate test item ID ${id}`);
  }
};
var InvalidTestItemError = class extends Error {
  constructor(id) {
    super(`TestItem with ID "${id}" is invalid. Make sure to create it from the createTestItem method.`);
  }
};
var MixedTestItemController = class extends Error {
  constructor(id, ctrlA, ctrlB) {
    super(`TestItem with ID "${id}" is from controller "${ctrlA}" and cannot be added as a child of an item from controller "${ctrlB}".`);
  }
};
var createTestItemChildren = (api, getApi, checkCtor) => {
  let mapped = /* @__PURE__ */ new Map();
  return {
    get size() {
      return mapped.size;
    },
    forEach(callback, thisArg) {
      for (const item of mapped.values()) {
        callback.call(thisArg, item, this);
      }
    },
    [Symbol.iterator]() {
      return mapped.entries();
    },
    replace(items) {
      var _a30;
      const newMapped = /* @__PURE__ */ new Map();
      const toDelete = new Set(mapped.keys());
      const bulk = { op: 5, ops: [] };
      for (const item of items) {
        if (!(item instanceof checkCtor)) {
          throw new InvalidTestItemError(item.id);
        }
        const itemController = getApi(item).controllerId;
        if (itemController !== api.controllerId) {
          throw new MixedTestItemController(item.id, itemController, api.controllerId);
        }
        if (newMapped.has(item.id)) {
          throw new DuplicateTestItemError(item.id);
        }
        newMapped.set(item.id, item);
        toDelete.delete(item.id);
        bulk.ops.push({ op: 0, item });
      }
      for (const id of toDelete.keys()) {
        bulk.ops.push({ op: 3, id });
      }
      (_a30 = api.listener) == null ? void 0 : _a30.call(api, bulk);
      mapped = newMapped;
    },
    add(item) {
      var _a30;
      if (!(item instanceof checkCtor)) {
        throw new InvalidTestItemError(item.id);
      }
      mapped.set(item.id, item);
      (_a30 = api.listener) == null ? void 0 : _a30.call(api, { op: 0, item });
    },
    delete(id) {
      var _a30;
      if (mapped.delete(id)) {
        (_a30 = api.listener) == null ? void 0 : _a30.call(api, { op: 3, id });
      }
    },
    get(itemId) {
      return mapped.get(itemId);
    },
    toJSON() {
      return Array.from(mapped.values());
    }
  };
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTestingPrivateApi.js
var eventPrivateApis = /* @__PURE__ */ new WeakMap();
var createPrivateApiFor = (impl, controllerId) => {
  const api = { controllerId };
  eventPrivateApis.set(impl, api);
  return api;
};
var getPrivateApiFor = (impl) => {
  const api = eventPrivateApis.get(impl);
  if (!api) {
    throw new InvalidTestItemError((impl == null ? void 0 : impl.id) || "<unknown>");
  }
  return api;
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTypeConverters.js
init_notebookCommon();
init_extHostTypes();
var Selection3;
(function(Selection4) {
  function to(selection) {
    const { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;
    const start = new Position2(selectionStartLineNumber - 1, selectionStartColumn - 1);
    const end = new Position2(positionLineNumber - 1, positionColumn - 1);
    return new Selection(start, end);
  }
  Selection4.to = to;
  function from(selection) {
    const { anchor, active } = selection;
    return {
      selectionStartLineNumber: anchor.line + 1,
      selectionStartColumn: anchor.character + 1,
      positionLineNumber: active.line + 1,
      positionColumn: active.character + 1
    };
  }
  Selection4.from = from;
})(Selection3 || (Selection3 = {}));
var Range3;
(function(Range4) {
  function from(range) {
    if (!range) {
      return void 0;
    }
    const { start, end } = range;
    return {
      startLineNumber: start.line + 1,
      startColumn: start.character + 1,
      endLineNumber: end.line + 1,
      endColumn: end.character + 1
    };
  }
  Range4.from = from;
  function to(range) {
    if (!range) {
      return void 0;
    }
    const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
    return new Range2(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
  }
  Range4.to = to;
})(Range3 || (Range3 = {}));
var TokenType;
(function(TokenType2) {
  function to(type) {
    switch (type) {
      case 1:
        return StandardTokenType.Comment;
      case 0:
        return StandardTokenType.Other;
      case 3:
        return StandardTokenType.RegEx;
      case 2:
        return StandardTokenType.String;
    }
  }
  TokenType2.to = to;
})(TokenType || (TokenType = {}));
var Position3;
(function(Position4) {
  function to(position) {
    return new Position2(position.lineNumber - 1, position.column - 1);
  }
  Position4.to = to;
  function from(position) {
    return { lineNumber: position.line + 1, column: position.character + 1 };
  }
  Position4.from = from;
})(Position3 || (Position3 = {}));
var DocumentSelector;
(function(DocumentSelector2) {
  function from(value, uriTransformer, extension) {
    return coalesce(asArray(value).map((sel) => _doTransformDocumentSelector(sel, uriTransformer, extension)));
  }
  DocumentSelector2.from = from;
  function _doTransformDocumentSelector(selector, uriTransformer, extension) {
    if (typeof selector === "string") {
      return {
        $serialized: true,
        language: selector,
        isBuiltin: extension == null ? void 0 : extension.isBuiltin
      };
    }
    if (selector) {
      return {
        $serialized: true,
        language: selector.language,
        scheme: _transformScheme(selector.scheme, uriTransformer),
        pattern: GlobPattern.from(selector.pattern) ?? void 0,
        exclusive: selector.exclusive,
        notebookType: selector.notebookType,
        isBuiltin: extension == null ? void 0 : extension.isBuiltin
      };
    }
    return void 0;
  }
  function _transformScheme(scheme, uriTransformer) {
    if (uriTransformer && typeof scheme === "string") {
      return uriTransformer.transformOutgoingScheme(scheme);
    }
    return scheme;
  }
})(DocumentSelector || (DocumentSelector = {}));
var DiagnosticTag2;
(function(DiagnosticTag3) {
  function from(value) {
    switch (value) {
      case DiagnosticTag.Unnecessary:
        return 1;
      case DiagnosticTag.Deprecated:
        return 2;
    }
    return void 0;
  }
  DiagnosticTag3.from = from;
  function to(value) {
    switch (value) {
      case 1:
        return DiagnosticTag.Unnecessary;
      case 2:
        return DiagnosticTag.Deprecated;
      default:
        return void 0;
    }
  }
  DiagnosticTag3.to = to;
})(DiagnosticTag2 || (DiagnosticTag2 = {}));
var Diagnostic2;
(function(Diagnostic3) {
  function from(value) {
    let code;
    if (value.code) {
      if (isString(value.code) || isNumber(value.code)) {
        code = String(value.code);
      } else {
        code = {
          value: String(value.code.value),
          target: value.code.target
        };
      }
    }
    return {
      ...Range3.from(value.range),
      message: value.message,
      source: value.source,
      code,
      severity: DiagnosticSeverity2.from(value.severity),
      relatedInformation: value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation2.from),
      tags: Array.isArray(value.tags) ? coalesce(value.tags.map(DiagnosticTag2.from)) : void 0
    };
  }
  Diagnostic3.from = from;
  function to(value) {
    var _a30;
    const res = new Diagnostic(Range3.to(value), value.message, DiagnosticSeverity2.to(value.severity));
    res.source = value.source;
    res.code = isString(value.code) ? value.code : (_a30 = value.code) == null ? void 0 : _a30.value;
    res.relatedInformation = value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation2.to);
    res.tags = value.tags && coalesce(value.tags.map(DiagnosticTag2.to));
    return res;
  }
  Diagnostic3.to = to;
})(Diagnostic2 || (Diagnostic2 = {}));
var DiagnosticRelatedInformation2;
(function(DiagnosticRelatedInformation3) {
  function from(value) {
    return {
      ...Range3.from(value.location.range),
      message: value.message,
      resource: value.location.uri
    };
  }
  DiagnosticRelatedInformation3.from = from;
  function to(value) {
    return new DiagnosticRelatedInformation(new Location(value.resource, Range3.to(value)), value.message);
  }
  DiagnosticRelatedInformation3.to = to;
})(DiagnosticRelatedInformation2 || (DiagnosticRelatedInformation2 = {}));
var DiagnosticSeverity2;
(function(DiagnosticSeverity3) {
  function from(value) {
    switch (value) {
      case DiagnosticSeverity.Error:
        return MarkerSeverity.Error;
      case DiagnosticSeverity.Warning:
        return MarkerSeverity.Warning;
      case DiagnosticSeverity.Information:
        return MarkerSeverity.Info;
      case DiagnosticSeverity.Hint:
        return MarkerSeverity.Hint;
    }
    return MarkerSeverity.Error;
  }
  DiagnosticSeverity3.from = from;
  function to(value) {
    switch (value) {
      case MarkerSeverity.Info:
        return DiagnosticSeverity.Information;
      case MarkerSeverity.Warning:
        return DiagnosticSeverity.Warning;
      case MarkerSeverity.Error:
        return DiagnosticSeverity.Error;
      case MarkerSeverity.Hint:
        return DiagnosticSeverity.Hint;
      default:
        return DiagnosticSeverity.Error;
    }
  }
  DiagnosticSeverity3.to = to;
})(DiagnosticSeverity2 || (DiagnosticSeverity2 = {}));
var ViewColumn2;
(function(ViewColumn3) {
  function from(column) {
    if (typeof column === "number" && column >= ViewColumn.One) {
      return column - 1;
    }
    if (column === ViewColumn.Beside) {
      return SIDE_GROUP;
    }
    return ACTIVE_GROUP;
  }
  ViewColumn3.from = from;
  function to(position) {
    if (typeof position === "number" && position >= 0) {
      return position + 1;
    }
    throw new Error(`invalid 'EditorGroupColumn'`);
  }
  ViewColumn3.to = to;
})(ViewColumn2 || (ViewColumn2 = {}));
function isDecorationOptions(something) {
  return typeof something.range !== "undefined";
}
function isDecorationOptionsArr(something) {
  if (something.length === 0) {
    return true;
  }
  return isDecorationOptions(something[0]) ? true : false;
}
var MarkdownString3;
(function(MarkdownString4) {
  function fromMany(markup) {
    return markup.map(MarkdownString4.from);
  }
  MarkdownString4.fromMany = fromMany;
  function isCodeblock(thing) {
    return thing && typeof thing === "object" && typeof thing.language === "string" && typeof thing.value === "string";
  }
  function from(markup) {
    let res;
    if (isCodeblock(markup)) {
      const { language: language2, value } = markup;
      res = { value: "```" + language2 + "\n" + value + "\n```\n" };
    } else if (MarkdownString2.isMarkdownString(markup)) {
      res = { value: markup.value, isTrusted: markup.isTrusted, supportThemeIcons: markup.supportThemeIcons, supportHtml: markup.supportHtml, baseUri: markup.baseUri };
    } else if (typeof markup === "string") {
      res = { value: markup };
    } else {
      res = { value: "" };
    }
    const resUris = /* @__PURE__ */ Object.create(null);
    res.uris = resUris;
    const collectUri = (href) => {
      try {
        let uri = URI.parse(href, true);
        uri = uri.with({ query: _uriMassage(uri.query, resUris) });
        resUris[href] = uri;
      } catch (e) {
      }
      return "";
    };
    const renderer = new marked.Renderer();
    renderer.link = collectUri;
    renderer.image = (href) => typeof href === "string" ? collectUri(parseHrefAndDimensions(href).href) : "";
    marked(res.value, { renderer });
    return res;
  }
  MarkdownString4.from = from;
  function _uriMassage(part, bucket) {
    if (!part) {
      return part;
    }
    let data;
    try {
      data = parse(part);
    } catch (e) {
    }
    if (!data) {
      return part;
    }
    let changed = false;
    data = cloneAndChange(data, (value) => {
      if (URI.isUri(value)) {
        const key = `__uri_${Math.random().toString(16).slice(2, 8)}`;
        bucket[key] = value;
        changed = true;
        return key;
      } else {
        return void 0;
      }
    });
    if (!changed) {
      return part;
    }
    return JSON.stringify(data);
  }
  function to(value) {
    const result = new MarkdownString2(value.value, value.supportThemeIcons);
    result.isTrusted = value.isTrusted;
    result.supportHtml = value.supportHtml;
    result.baseUri = value.baseUri ? URI.from(value.baseUri) : void 0;
    return result;
  }
  MarkdownString4.to = to;
  function fromStrict(value) {
    if (!value) {
      return void 0;
    }
    return typeof value === "string" ? value : MarkdownString4.from(value);
  }
  MarkdownString4.fromStrict = fromStrict;
})(MarkdownString3 || (MarkdownString3 = {}));
function fromRangeOrRangeWithMessage(ranges) {
  if (isDecorationOptionsArr(ranges)) {
    return ranges.map((r) => {
      return {
        range: Range3.from(r.range),
        hoverMessage: Array.isArray(r.hoverMessage) ? MarkdownString3.fromMany(r.hoverMessage) : r.hoverMessage ? MarkdownString3.from(r.hoverMessage) : void 0,
        renderOptions: r.renderOptions
      };
    });
  } else {
    return ranges.map((r) => {
      return {
        range: Range3.from(r)
      };
    });
  }
}
function pathOrURIToURI(value) {
  if (typeof value === "undefined") {
    return value;
  }
  if (typeof value === "string") {
    return URI.file(value);
  } else {
    return value;
  }
}
var ThemableDecorationAttachmentRenderOptions;
(function(ThemableDecorationAttachmentRenderOptions2) {
  function from(options) {
    if (typeof options === "undefined") {
      return options;
    }
    return {
      contentText: options.contentText,
      contentIconPath: options.contentIconPath ? pathOrURIToURI(options.contentIconPath) : void 0,
      border: options.border,
      borderColor: options.borderColor,
      fontStyle: options.fontStyle,
      fontWeight: options.fontWeight,
      textDecoration: options.textDecoration,
      color: options.color,
      backgroundColor: options.backgroundColor,
      margin: options.margin,
      width: options.width,
      height: options.height
    };
  }
  ThemableDecorationAttachmentRenderOptions2.from = from;
})(
  ThemableDecorationAttachmentRenderOptions || (ThemableDecorationAttachmentRenderOptions = {})
);
var ThemableDecorationRenderOptions;
(function(ThemableDecorationRenderOptions2) {
  function from(options) {
    if (typeof options === "undefined") {
      return options;
    }
    return {
      backgroundColor: options.backgroundColor,
      outline: options.outline,
      outlineColor: options.outlineColor,
      outlineStyle: options.outlineStyle,
      outlineWidth: options.outlineWidth,
      border: options.border,
      borderColor: options.borderColor,
      borderRadius: options.borderRadius,
      borderSpacing: options.borderSpacing,
      borderStyle: options.borderStyle,
      borderWidth: options.borderWidth,
      fontStyle: options.fontStyle,
      fontWeight: options.fontWeight,
      textDecoration: options.textDecoration,
      cursor: options.cursor,
      color: options.color,
      opacity: options.opacity,
      letterSpacing: options.letterSpacing,
      gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : void 0,
      gutterIconSize: options.gutterIconSize,
      overviewRulerColor: options.overviewRulerColor,
      before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : void 0,
      after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : void 0
    };
  }
  ThemableDecorationRenderOptions2.from = from;
})(ThemableDecorationRenderOptions || (ThemableDecorationRenderOptions = {}));
var DecorationRangeBehavior2;
(function(DecorationRangeBehavior3) {
  function from(value) {
    if (typeof value === "undefined") {
      return value;
    }
    switch (value) {
      case DecorationRangeBehavior.OpenOpen:
        return 0;
      case DecorationRangeBehavior.ClosedClosed:
        return 1;
      case DecorationRangeBehavior.OpenClosed:
        return 2;
      case DecorationRangeBehavior.ClosedOpen:
        return 3;
    }
  }
  DecorationRangeBehavior3.from = from;
})(DecorationRangeBehavior2 || (DecorationRangeBehavior2 = {}));
var DecorationRenderOptions;
(function(DecorationRenderOptions2) {
  function from(options) {
    return {
      isWholeLine: options.isWholeLine,
      rangeBehavior: options.rangeBehavior ? DecorationRangeBehavior2.from(options.rangeBehavior) : void 0,
      overviewRulerLane: options.overviewRulerLane,
      light: options.light ? ThemableDecorationRenderOptions.from(options.light) : void 0,
      dark: options.dark ? ThemableDecorationRenderOptions.from(options.dark) : void 0,
      backgroundColor: options.backgroundColor,
      outline: options.outline,
      outlineColor: options.outlineColor,
      outlineStyle: options.outlineStyle,
      outlineWidth: options.outlineWidth,
      border: options.border,
      borderColor: options.borderColor,
      borderRadius: options.borderRadius,
      borderSpacing: options.borderSpacing,
      borderStyle: options.borderStyle,
      borderWidth: options.borderWidth,
      fontStyle: options.fontStyle,
      fontWeight: options.fontWeight,
      textDecoration: options.textDecoration,
      cursor: options.cursor,
      color: options.color,
      opacity: options.opacity,
      letterSpacing: options.letterSpacing,
      gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : void 0,
      gutterIconSize: options.gutterIconSize,
      overviewRulerColor: options.overviewRulerColor,
      before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : void 0,
      after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : void 0
    };
  }
  DecorationRenderOptions2.from = from;
})(DecorationRenderOptions || (DecorationRenderOptions = {}));
var TextEdit2;
(function(TextEdit3) {
  function from(edit) {
    return {
      text: edit.newText,
      eol: edit.newEol && EndOfLine2.from(edit.newEol),
      range: Range3.from(edit.range)
    };
  }
  TextEdit3.from = from;
  function to(edit) {
    const result = new TextEdit(Range3.to(edit.range), edit.text);
    result.newEol = typeof edit.eol === "undefined" ? void 0 : EndOfLine2.to(edit.eol);
    return result;
  }
  TextEdit3.to = to;
})(TextEdit2 || (TextEdit2 = {}));
var WorkspaceEdit2;
(function(WorkspaceEdit3) {
  function from(value, versionInfo) {
    var _a30;
    const result = {
      edits: []
    };
    if (value instanceof WorkspaceEdit) {
      const toCreate = new ResourceSet();
      for (const entry of value._allEntries()) {
        if (entry._type === 1 && URI.isUri(entry.to) && entry.from === void 0) {
          toCreate.add(entry.to);
        }
      }
      for (const entry of value._allEntries()) {
        if (entry._type === 1) {
          let contents;
          if ((_a30 = entry.options) == null ? void 0 : _a30.contents) {
            if (ArrayBuffer.isView(entry.options.contents)) {
              contents = { type: "base64", value: encodeBase64(VSBuffer.wrap(entry.options.contents)) };
            } else {
              contents = { type: "dataTransferItem", id: entry.options.contents._itemId };
            }
          }
          result.edits.push({
            oldResource: entry.from,
            newResource: entry.to,
            options: { ...entry.options, contents },
            metadata: entry.metadata
          });
        } else if (entry._type === 2) {
          result.edits.push({
            resource: entry.uri,
            textEdit: TextEdit2.from(entry.edit),
            versionId: !toCreate.has(entry.uri) ? versionInfo == null ? void 0 : versionInfo.getTextDocumentVersion(entry.uri) : void 0,
            metadata: entry.metadata
          });
        } else if (entry._type === 6) {
          result.edits.push({
            resource: entry.uri,
            textEdit: {
              range: Range3.from(entry.range),
              text: entry.edit.value,
              insertAsSnippet: true
            },
            versionId: !toCreate.has(entry.uri) ? versionInfo == null ? void 0 : versionInfo.getTextDocumentVersion(entry.uri) : void 0,
            metadata: entry.metadata
          });
        } else if (entry._type === 3) {
          result.edits.push({
            metadata: entry.metadata,
            resource: entry.uri,
            cellEdit: entry.edit,
            notebookMetadata: entry.notebookMetadata,
            notebookVersionId: versionInfo == null ? void 0 : versionInfo.getNotebookDocumentVersion(entry.uri)
          });
        } else if (entry._type === 5) {
          result.edits.push({
            metadata: entry.metadata,
            resource: entry.uri,
            notebookVersionId: versionInfo == null ? void 0 : versionInfo.getNotebookDocumentVersion(entry.uri),
            cellEdit: {
              editType: 1,
              index: entry.index,
              count: entry.count,
              cells: entry.cells.map(NotebookCellData2.from)
            }
          });
        }
      }
    }
    return result;
  }
  WorkspaceEdit3.from = from;
  function to(value) {
    const result = new WorkspaceEdit();
    const edits = new ResourceMap();
    for (const edit of value.edits) {
      if (edit.textEdit) {
        const item = edit;
        const uri = URI.revive(item.resource);
        const range = Range3.to(item.textEdit.range);
        const text = item.textEdit.text;
        const isSnippet = item.textEdit.insertAsSnippet;
        let editOrSnippetTest;
        if (isSnippet) {
          editOrSnippetTest = SnippetTextEdit.replace(range, new SnippetString(text));
        } else {
          editOrSnippetTest = TextEdit.replace(range, text);
        }
        const array = edits.get(uri);
        if (!array) {
          edits.set(uri, [editOrSnippetTest]);
        } else {
          array.push(editOrSnippetTest);
        }
      } else {
        result.renameFile(URI.revive(edit.oldResource), URI.revive(edit.newResource), edit.options);
      }
    }
    for (const [uri, array] of edits) {
      result.set(uri, array);
    }
    return result;
  }
  WorkspaceEdit3.to = to;
})(WorkspaceEdit2 || (WorkspaceEdit2 = {}));
var SymbolKind2;
(function(SymbolKind3) {
  const _fromMapping = /* @__PURE__ */ Object.create(null);
  _fromMapping[SymbolKind.File] = 0;
  _fromMapping[SymbolKind.Module] = 1;
  _fromMapping[SymbolKind.Namespace] = 2;
  _fromMapping[SymbolKind.Package] = 3;
  _fromMapping[SymbolKind.Class] = 4;
  _fromMapping[SymbolKind.Method] = 5;
  _fromMapping[SymbolKind.Property] = 6;
  _fromMapping[SymbolKind.Field] = 7;
  _fromMapping[SymbolKind.Constructor] = 8;
  _fromMapping[SymbolKind.Enum] = 9;
  _fromMapping[SymbolKind.Interface] = 10;
  _fromMapping[SymbolKind.Function] = 11;
  _fromMapping[SymbolKind.Variable] = 12;
  _fromMapping[SymbolKind.Constant] = 13;
  _fromMapping[SymbolKind.String] = 14;
  _fromMapping[SymbolKind.Number] = 15;
  _fromMapping[SymbolKind.Boolean] = 16;
  _fromMapping[SymbolKind.Array] = 17;
  _fromMapping[SymbolKind.Object] = 18;
  _fromMapping[SymbolKind.Key] = 19;
  _fromMapping[SymbolKind.Null] = 20;
  _fromMapping[SymbolKind.EnumMember] = 21;
  _fromMapping[SymbolKind.Struct] = 22;
  _fromMapping[SymbolKind.Event] = 23;
  _fromMapping[SymbolKind.Operator] = 24;
  _fromMapping[SymbolKind.TypeParameter] = 25;
  function from(kind) {
    return typeof _fromMapping[kind] === "number" ? _fromMapping[kind] : 6;
  }
  SymbolKind3.from = from;
  function to(kind) {
    for (const k in _fromMapping) {
      if (_fromMapping[k] === kind) {
        return Number(k);
      }
    }
    return SymbolKind.Property;
  }
  SymbolKind3.to = to;
})(SymbolKind2 || (SymbolKind2 = {}));
var SymbolTag2;
(function(SymbolTag3) {
  function from(kind) {
    switch (kind) {
      case SymbolTag.Deprecated:
        return 1;
    }
  }
  SymbolTag3.from = from;
  function to(kind) {
    switch (kind) {
      case 1:
        return SymbolTag.Deprecated;
    }
  }
  SymbolTag3.to = to;
})(SymbolTag2 || (SymbolTag2 = {}));
var WorkspaceSymbol;
(function(WorkspaceSymbol2) {
  function from(info) {
    return {
      name: info.name,
      kind: SymbolKind2.from(info.kind),
      tags: info.tags && info.tags.map(SymbolTag2.from),
      containerName: info.containerName,
      location: location.from(info.location)
    };
  }
  WorkspaceSymbol2.from = from;
  function to(info) {
    const result = new SymbolInformation(info.name, SymbolKind2.to(info.kind), info.containerName, location.to(info.location));
    result.tags = info.tags && info.tags.map(SymbolTag2.to);
    return result;
  }
  WorkspaceSymbol2.to = to;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol2;
(function(DocumentSymbol3) {
  function from(info) {
    var _a30;
    const result = {
      name: info.name || "!!MISSING: name!!",
      detail: info.detail,
      range: Range3.from(info.range),
      selectionRange: Range3.from(info.selectionRange),
      kind: SymbolKind2.from(info.kind),
      tags: ((_a30 = info.tags) == null ? void 0 : _a30.map(SymbolTag2.from)) ?? []
    };
    if (info.children) {
      result.children = info.children.map(from);
    }
    return result;
  }
  DocumentSymbol3.from = from;
  function to(info) {
    const result = new DocumentSymbol(info.name, info.detail, SymbolKind2.to(info.kind), Range3.to(info.range), Range3.to(info.selectionRange));
    if (isNonEmptyArray(info.tags)) {
      result.tags = info.tags.map(SymbolTag2.to);
    }
    if (info.children) {
      result.children = info.children.map(to);
    }
    return result;
  }
  DocumentSymbol3.to = to;
})(DocumentSymbol2 || (DocumentSymbol2 = {}));
var CallHierarchyItem2;
(function(CallHierarchyItem3) {
  function to(item) {
    const result = new CallHierarchyItem(SymbolKind2.to(item.kind), item.name, item.detail || "", URI.revive(item.uri), Range3.to(item.range), Range3.to(item.selectionRange));
    result._sessionId = item._sessionId;
    result._itemId = item._itemId;
    return result;
  }
  CallHierarchyItem3.to = to;
  function from(item, sessionId, itemId) {
    var _a30;
    sessionId = sessionId ?? item._sessionId;
    itemId = itemId ?? item._itemId;
    if (sessionId === void 0 || itemId === void 0) {
      throw new Error("invalid item");
    }
    return {
      _sessionId: sessionId,
      _itemId: itemId,
      name: item.name,
      detail: item.detail,
      kind: SymbolKind2.from(item.kind),
      uri: item.uri,
      range: Range3.from(item.range),
      selectionRange: Range3.from(item.selectionRange),
      tags: (_a30 = item.tags) == null ? void 0 : _a30.map(SymbolTag2.from)
    };
  }
  CallHierarchyItem3.from = from;
})(CallHierarchyItem2 || (CallHierarchyItem2 = {}));
var CallHierarchyIncomingCall2;
(function(CallHierarchyIncomingCall3) {
  function to(item) {
    return new CallHierarchyIncomingCall(CallHierarchyItem2.to(item.from), item.fromRanges.map((r) => Range3.to(r)));
  }
  CallHierarchyIncomingCall3.to = to;
})(CallHierarchyIncomingCall2 || (CallHierarchyIncomingCall2 = {}));
var CallHierarchyOutgoingCall2;
(function(CallHierarchyOutgoingCall3) {
  function to(item) {
    return new CallHierarchyOutgoingCall(CallHierarchyItem2.to(item.to), item.fromRanges.map((r) => Range3.to(r)));
  }
  CallHierarchyOutgoingCall3.to = to;
})(CallHierarchyOutgoingCall2 || (CallHierarchyOutgoingCall2 = {}));
var location;
(function(location2) {
  function from(value) {
    return {
      range: value.range && Range3.from(value.range),
      uri: value.uri
    };
  }
  location2.from = from;
  function to(value) {
    return new Location(URI.revive(value.uri), Range3.to(value.range));
  }
  location2.to = to;
})(location || (location = {}));
var DefinitionLink;
(function(DefinitionLink2) {
  function from(value) {
    const definitionLink = value;
    const location2 = value;
    return {
      originSelectionRange: definitionLink.originSelectionRange ? Range3.from(definitionLink.originSelectionRange) : void 0,
      uri: definitionLink.targetUri ? definitionLink.targetUri : location2.uri,
      range: Range3.from(definitionLink.targetRange ? definitionLink.targetRange : location2.range),
      targetSelectionRange: definitionLink.targetSelectionRange ? Range3.from(definitionLink.targetSelectionRange) : void 0
    };
  }
  DefinitionLink2.from = from;
  function to(value) {
    return {
      targetUri: URI.revive(value.uri),
      targetRange: Range3.to(value.range),
      targetSelectionRange: value.targetSelectionRange ? Range3.to(value.targetSelectionRange) : void 0,
      originSelectionRange: value.originSelectionRange ? Range3.to(value.originSelectionRange) : void 0
    };
  }
  DefinitionLink2.to = to;
})(DefinitionLink || (DefinitionLink = {}));
var Hover2;
(function(Hover3) {
  function from(hover) {
    return {
      range: Range3.from(hover.range),
      contents: MarkdownString3.fromMany(hover.contents)
    };
  }
  Hover3.from = from;
  function to(info) {
    return new Hover(info.contents.map(MarkdownString3.to), Range3.to(info.range));
  }
  Hover3.to = to;
})(Hover2 || (Hover2 = {}));
var EvaluatableExpression2;
(function(EvaluatableExpression3) {
  function from(expression) {
    return {
      range: Range3.from(expression.range),
      expression: expression.expression
    };
  }
  EvaluatableExpression3.from = from;
  function to(info) {
    return new EvaluatableExpression(Range3.to(info.range), info.expression);
  }
  EvaluatableExpression3.to = to;
})(EvaluatableExpression2 || (EvaluatableExpression2 = {}));
var InlineValue;
(function(InlineValue2) {
  function from(inlineValue) {
    if (inlineValue instanceof InlineValueText) {
      return {
        type: "text",
        range: Range3.from(inlineValue.range),
        text: inlineValue.text
      };
    } else if (inlineValue instanceof InlineValueVariableLookup) {
      return {
        type: "variable",
        range: Range3.from(inlineValue.range),
        variableName: inlineValue.variableName,
        caseSensitiveLookup: inlineValue.caseSensitiveLookup
      };
    } else if (inlineValue instanceof InlineValueEvaluatableExpression) {
      return {
        type: "expression",
        range: Range3.from(inlineValue.range),
        expression: inlineValue.expression
      };
    } else {
      throw new Error(`Unknown 'InlineValue' type`);
    }
  }
  InlineValue2.from = from;
  function to(inlineValue) {
    switch (inlineValue.type) {
      case "text":
        return {
          range: Range3.to(inlineValue.range),
          text: inlineValue.text
        };
      case "variable":
        return {
          range: Range3.to(inlineValue.range),
          variableName: inlineValue.variableName,
          caseSensitiveLookup: inlineValue.caseSensitiveLookup
        };
      case "expression":
        return {
          range: Range3.to(inlineValue.range),
          expression: inlineValue.expression
        };
    }
  }
  InlineValue2.to = to;
})(InlineValue || (InlineValue = {}));
var InlineValueContext2;
(function(InlineValueContext3) {
  function from(inlineValueContext) {
    return {
      frameId: inlineValueContext.frameId,
      stoppedLocation: Range3.from(inlineValueContext.stoppedLocation)
    };
  }
  InlineValueContext3.from = from;
  function to(inlineValueContext) {
    return new InlineValueContext(inlineValueContext.frameId, Range3.to(inlineValueContext.stoppedLocation));
  }
  InlineValueContext3.to = to;
})(InlineValueContext2 || (InlineValueContext2 = {}));
var DocumentHighlight2;
(function(DocumentHighlight3) {
  function from(documentHighlight) {
    return {
      range: Range3.from(documentHighlight.range),
      kind: documentHighlight.kind
    };
  }
  DocumentHighlight3.from = from;
  function to(occurrence) {
    return new DocumentHighlight(Range3.to(occurrence.range), occurrence.kind);
  }
  DocumentHighlight3.to = to;
})(DocumentHighlight2 || (DocumentHighlight2 = {}));
var CompletionTriggerKind2;
(function(CompletionTriggerKind3) {
  function to(kind) {
    switch (kind) {
      case 1:
        return CompletionTriggerKind.TriggerCharacter;
      case 2:
        return CompletionTriggerKind.TriggerForIncompleteCompletions;
      case 0:
      default:
        return CompletionTriggerKind.Invoke;
    }
  }
  CompletionTriggerKind3.to = to;
})(CompletionTriggerKind2 || (CompletionTriggerKind2 = {}));
var CompletionContext;
(function(CompletionContext2) {
  function to(context) {
    return {
      triggerKind: CompletionTriggerKind2.to(context.triggerKind),
      triggerCharacter: context.triggerCharacter
    };
  }
  CompletionContext2.to = to;
})(CompletionContext || (CompletionContext = {}));
var CompletionItemTag2;
(function(CompletionItemTag3) {
  function from(kind) {
    switch (kind) {
      case CompletionItemTag.Deprecated:
        return 1;
    }
  }
  CompletionItemTag3.from = from;
  function to(kind) {
    switch (kind) {
      case 1:
        return CompletionItemTag.Deprecated;
    }
  }
  CompletionItemTag3.to = to;
})(CompletionItemTag2 || (CompletionItemTag2 = {}));
var CompletionItemKind2;
(function(CompletionItemKind3) {
  const _from = /* @__PURE__ */ new Map([
    [CompletionItemKind.Method, 0],
    [CompletionItemKind.Function, 1],
    [CompletionItemKind.Constructor, 2],
    [CompletionItemKind.Field, 3],
    [CompletionItemKind.Variable, 4],
    [CompletionItemKind.Class, 5],
    [CompletionItemKind.Interface, 7],
    [CompletionItemKind.Struct, 6],
    [CompletionItemKind.Module, 8],
    [CompletionItemKind.Property, 9],
    [CompletionItemKind.Unit, 12],
    [CompletionItemKind.Value, 13],
    [CompletionItemKind.Constant, 14],
    [CompletionItemKind.Enum, 15],
    [CompletionItemKind.EnumMember, 16],
    [CompletionItemKind.Keyword, 17],
    [CompletionItemKind.Snippet, 27],
    [CompletionItemKind.Text, 18],
    [CompletionItemKind.Color, 19],
    [CompletionItemKind.File, 20],
    [CompletionItemKind.Reference, 21],
    [CompletionItemKind.Folder, 23],
    [CompletionItemKind.Event, 10],
    [CompletionItemKind.Operator, 11],
    [CompletionItemKind.TypeParameter, 24],
    [CompletionItemKind.Issue, 26],
    [CompletionItemKind.User, 25]
  ]);
  function from(kind) {
    return _from.get(kind) ?? 9;
  }
  CompletionItemKind3.from = from;
  const _to = /* @__PURE__ */ new Map([
    [0, CompletionItemKind.Method],
    [1, CompletionItemKind.Function],
    [2, CompletionItemKind.Constructor],
    [3, CompletionItemKind.Field],
    [4, CompletionItemKind.Variable],
    [5, CompletionItemKind.Class],
    [7, CompletionItemKind.Interface],
    [6, CompletionItemKind.Struct],
    [8, CompletionItemKind.Module],
    [9, CompletionItemKind.Property],
    [12, CompletionItemKind.Unit],
    [13, CompletionItemKind.Value],
    [14, CompletionItemKind.Constant],
    [15, CompletionItemKind.Enum],
    [16, CompletionItemKind.EnumMember],
    [17, CompletionItemKind.Keyword],
    [27, CompletionItemKind.Snippet],
    [18, CompletionItemKind.Text],
    [19, CompletionItemKind.Color],
    [20, CompletionItemKind.File],
    [21, CompletionItemKind.Reference],
    [23, CompletionItemKind.Folder],
    [10, CompletionItemKind.Event],
    [11, CompletionItemKind.Operator],
    [24, CompletionItemKind.TypeParameter],
    [25, CompletionItemKind.User],
    [26, CompletionItemKind.Issue]
  ]);
  function to(kind) {
    return _to.get(kind) ?? CompletionItemKind.Property;
  }
  CompletionItemKind3.to = to;
})(CompletionItemKind2 || (CompletionItemKind2 = {}));
var CompletionItem2;
(function(CompletionItem3) {
  function to(suggestion, converter) {
    var _a30;
    const result = new CompletionItem(suggestion.label);
    result.insertText = suggestion.insertText;
    result.kind = CompletionItemKind2.to(suggestion.kind);
    result.tags = (_a30 = suggestion.tags) == null ? void 0 : _a30.map(CompletionItemTag2.to);
    result.detail = suggestion.detail;
    result.documentation = isMarkdownString(suggestion.documentation) ? MarkdownString3.to(suggestion.documentation) : suggestion.documentation;
    result.sortText = suggestion.sortText;
    result.filterText = suggestion.filterText;
    result.preselect = suggestion.preselect;
    result.commitCharacters = suggestion.commitCharacters;
    if (Range.isIRange(suggestion.range)) {
      result.range = Range3.to(suggestion.range);
    } else if (typeof suggestion.range === "object") {
      result.range = { inserting: Range3.to(suggestion.range.insert), replacing: Range3.to(suggestion.range.replace) };
    }
    result.keepWhitespace = typeof suggestion.insertTextRules === "undefined" ? false : Boolean(suggestion.insertTextRules & 1);
    if (typeof suggestion.insertTextRules !== "undefined" && suggestion.insertTextRules & 4) {
      result.insertText = new SnippetString(suggestion.insertText);
    } else {
      result.insertText = suggestion.insertText;
      result.textEdit = result.range instanceof Range2 ? new TextEdit(result.range, result.insertText) : void 0;
    }
    if (suggestion.additionalTextEdits && suggestion.additionalTextEdits.length > 0) {
      result.additionalTextEdits = suggestion.additionalTextEdits.map((e) => TextEdit2.to(e));
    }
    result.command = converter && suggestion.command ? converter.fromInternal(suggestion.command) : void 0;
    return result;
  }
  CompletionItem3.to = to;
})(CompletionItem2 || (CompletionItem2 = {}));
var ParameterInformation2;
(function(ParameterInformation3) {
  function from(info) {
    if (typeof info.label !== "string" && !Array.isArray(info.label)) {
      throw new TypeError("Invalid label");
    }
    return {
      label: info.label,
      documentation: MarkdownString3.fromStrict(info.documentation)
    };
  }
  ParameterInformation3.from = from;
  function to(info) {
    return {
      label: info.label,
      documentation: isMarkdownString(info.documentation) ? MarkdownString3.to(info.documentation) : info.documentation
    };
  }
  ParameterInformation3.to = to;
})(ParameterInformation2 || (ParameterInformation2 = {}));
var SignatureInformation2;
(function(SignatureInformation3) {
  function from(info) {
    return {
      label: info.label,
      documentation: MarkdownString3.fromStrict(info.documentation),
      parameters: Array.isArray(info.parameters) ? info.parameters.map(ParameterInformation2.from) : [],
      activeParameter: info.activeParameter
    };
  }
  SignatureInformation3.from = from;
  function to(info) {
    return {
      label: info.label,
      documentation: isMarkdownString(info.documentation) ? MarkdownString3.to(info.documentation) : info.documentation,
      parameters: Array.isArray(info.parameters) ? info.parameters.map(ParameterInformation2.to) : [],
      activeParameter: info.activeParameter
    };
  }
  SignatureInformation3.to = to;
})(SignatureInformation2 || (SignatureInformation2 = {}));
var SignatureHelp2;
(function(SignatureHelp3) {
  function from(help) {
    return {
      activeSignature: help.activeSignature,
      activeParameter: help.activeParameter,
      signatures: Array.isArray(help.signatures) ? help.signatures.map(SignatureInformation2.from) : []
    };
  }
  SignatureHelp3.from = from;
  function to(help) {
    return {
      activeSignature: help.activeSignature,
      activeParameter: help.activeParameter,
      signatures: Array.isArray(help.signatures) ? help.signatures.map(SignatureInformation2.to) : []
    };
  }
  SignatureHelp3.to = to;
})(SignatureHelp2 || (SignatureHelp2 = {}));
var InlayHint2;
(function(InlayHint3) {
  function to(converter, hint) {
    const res = new InlayHint(Position3.to(hint.position), typeof hint.label === "string" ? hint.label : hint.label.map(InlayHintLabelPart2.to.bind(void 0, converter)), hint.kind && InlayHintKind2.to(hint.kind));
    res.textEdits = hint.textEdits && hint.textEdits.map(TextEdit2.to);
    res.tooltip = isMarkdownString(hint.tooltip) ? MarkdownString3.to(hint.tooltip) : hint.tooltip;
    res.paddingLeft = hint.paddingLeft;
    res.paddingRight = hint.paddingRight;
    return res;
  }
  InlayHint3.to = to;
})(InlayHint2 || (InlayHint2 = {}));
var InlayHintLabelPart2;
(function(InlayHintLabelPart3) {
  function to(converter, part) {
    const result = new InlayHintLabelPart(part.label);
    result.tooltip = isMarkdownString(part.tooltip) ? MarkdownString3.to(part.tooltip) : part.tooltip;
    if (Command.is(part.command)) {
      result.command = converter.fromInternal(part.command);
    }
    if (part.location) {
      result.location = location.to(part.location);
    }
    return result;
  }
  InlayHintLabelPart3.to = to;
})(InlayHintLabelPart2 || (InlayHintLabelPart2 = {}));
var InlayHintKind2;
(function(InlayHintKind3) {
  function from(kind) {
    return kind;
  }
  InlayHintKind3.from = from;
  function to(kind) {
    return kind;
  }
  InlayHintKind3.to = to;
})(InlayHintKind2 || (InlayHintKind2 = {}));
var DocumentLink2;
(function(DocumentLink3) {
  function from(link) {
    return {
      range: Range3.from(link.range),
      url: link.target,
      tooltip: link.tooltip
    };
  }
  DocumentLink3.from = from;
  function to(link) {
    let target = void 0;
    if (link.url) {
      try {
        target = typeof link.url === "string" ? URI.parse(link.url, true) : URI.revive(link.url);
      } catch (err) {
      }
    }
    return new DocumentLink(Range3.to(link.range), target);
  }
  DocumentLink3.to = to;
})(DocumentLink2 || (DocumentLink2 = {}));
var ColorPresentation2;
(function(ColorPresentation3) {
  function to(colorPresentation) {
    const cp = new ColorPresentation(colorPresentation.label);
    if (colorPresentation.textEdit) {
      cp.textEdit = TextEdit2.to(colorPresentation.textEdit);
    }
    if (colorPresentation.additionalTextEdits) {
      cp.additionalTextEdits = colorPresentation.additionalTextEdits.map((value) => TextEdit2.to(value));
    }
    return cp;
  }
  ColorPresentation3.to = to;
  function from(colorPresentation) {
    return {
      label: colorPresentation.label,
      textEdit: colorPresentation.textEdit ? TextEdit2.from(colorPresentation.textEdit) : void 0,
      additionalTextEdits: colorPresentation.additionalTextEdits ? colorPresentation.additionalTextEdits.map((value) => TextEdit2.from(value)) : void 0
    };
  }
  ColorPresentation3.from = from;
})(ColorPresentation2 || (ColorPresentation2 = {}));
var Color3;
(function(Color4) {
  function to(c) {
    return new Color(c[0], c[1], c[2], c[3]);
  }
  Color4.to = to;
  function from(color2) {
    return [color2.red, color2.green, color2.blue, color2.alpha];
  }
  Color4.from = from;
})(Color3 || (Color3 = {}));
var SelectionRange2;
(function(SelectionRange3) {
  function from(obj) {
    return { range: Range3.from(obj.range) };
  }
  SelectionRange3.from = from;
  function to(obj) {
    return new SelectionRange(Range3.to(obj.range));
  }
  SelectionRange3.to = to;
})(SelectionRange2 || (SelectionRange2 = {}));
var TextDocumentSaveReason2;
(function(TextDocumentSaveReason3) {
  function to(reason) {
    switch (reason) {
      case 2:
        return TextDocumentSaveReason.AfterDelay;
      case 1:
        return TextDocumentSaveReason.Manual;
      case 3:
      case 4:
        return TextDocumentSaveReason.FocusOut;
    }
  }
  TextDocumentSaveReason3.to = to;
})(TextDocumentSaveReason2 || (TextDocumentSaveReason2 = {}));
var TextEditorLineNumbersStyle2;
(function(TextEditorLineNumbersStyle3) {
  function from(style) {
    switch (style) {
      case TextEditorLineNumbersStyle.Off:
        return 0;
      case TextEditorLineNumbersStyle.Relative:
        return 2;
      case TextEditorLineNumbersStyle.On:
      default:
        return 1;
    }
  }
  TextEditorLineNumbersStyle3.from = from;
  function to(style) {
    switch (style) {
      case 0:
        return TextEditorLineNumbersStyle.Off;
      case 2:
        return TextEditorLineNumbersStyle.Relative;
      case 1:
      default:
        return TextEditorLineNumbersStyle.On;
    }
  }
  TextEditorLineNumbersStyle3.to = to;
})(TextEditorLineNumbersStyle2 || (TextEditorLineNumbersStyle2 = {}));
var EndOfLine2;
(function(EndOfLine3) {
  function from(eol) {
    if (eol === EndOfLine.CRLF) {
      return 1;
    } else if (eol === EndOfLine.LF) {
      return 0;
    }
    return void 0;
  }
  EndOfLine3.from = from;
  function to(eol) {
    if (eol === 1) {
      return EndOfLine.CRLF;
    } else if (eol === 0) {
      return EndOfLine.LF;
    }
    return void 0;
  }
  EndOfLine3.to = to;
})(EndOfLine2 || (EndOfLine2 = {}));
var ProgressLocation2;
(function(ProgressLocation3) {
  function from(loc) {
    if (typeof loc === "object") {
      return loc.viewId;
    }
    switch (loc) {
      case ProgressLocation.SourceControl:
        return 3;
      case ProgressLocation.Window:
        return 10;
      case ProgressLocation.Notification:
        return 15;
    }
    throw new Error(`Unknown 'ProgressLocation'`);
  }
  ProgressLocation3.from = from;
})(ProgressLocation2 || (ProgressLocation2 = {}));
var FoldingRange2;
(function(FoldingRange3) {
  function from(r) {
    const range = { start: r.start + 1, end: r.end + 1 };
    if (r.kind) {
      range.kind = FoldingRangeKind3.from(r.kind);
    }
    return range;
  }
  FoldingRange3.from = from;
  function to(r) {
    const range = { start: r.start - 1, end: r.end - 1 };
    if (r.kind) {
      range.kind = FoldingRangeKind3.to(r.kind);
    }
    return range;
  }
  FoldingRange3.to = to;
})(FoldingRange2 || (FoldingRange2 = {}));
var FoldingRangeKind3;
(function(FoldingRangeKind4) {
  function from(kind) {
    if (kind) {
      switch (kind) {
        case FoldingRangeKind2.Comment:
          return FoldingRangeKind.Comment;
        case FoldingRangeKind2.Imports:
          return FoldingRangeKind.Imports;
        case FoldingRangeKind2.Region:
          return FoldingRangeKind.Region;
      }
    }
    return void 0;
  }
  FoldingRangeKind4.from = from;
  function to(kind) {
    if (kind) {
      switch (kind.value) {
        case FoldingRangeKind.Comment.value:
          return FoldingRangeKind2.Comment;
        case FoldingRangeKind.Imports.value:
          return FoldingRangeKind2.Imports;
        case FoldingRangeKind.Region.value:
          return FoldingRangeKind2.Region;
      }
    }
    return void 0;
  }
  FoldingRangeKind4.to = to;
})(FoldingRangeKind3 || (FoldingRangeKind3 = {}));
var TextEditorOpenOptions;
(function(TextEditorOpenOptions2) {
  function from(options) {
    if (options) {
      return {
        pinned: typeof options.preview === "boolean" ? !options.preview : void 0,
        inactive: options.background,
        preserveFocus: options.preserveFocus,
        selection: typeof options.selection === "object" ? Range3.from(options.selection) : void 0,
        override: typeof options.override === "boolean" ? DEFAULT_EDITOR_ASSOCIATION.id : void 0
      };
    }
    return void 0;
  }
  TextEditorOpenOptions2.from = from;
})(TextEditorOpenOptions || (TextEditorOpenOptions = {}));
var GlobPattern;
(function(GlobPattern2) {
  function from(pattern) {
    if (pattern instanceof RelativePattern) {
      return pattern.toJSON();
    }
    if (typeof pattern === "string") {
      return pattern;
    }
    if (isRelativePatternShape(pattern) || isLegacyRelativePatternShape(pattern)) {
      return new RelativePattern(pattern.baseUri ?? pattern.base, pattern.pattern).toJSON();
    }
    return pattern;
  }
  GlobPattern2.from = from;
  function isRelativePatternShape(obj) {
    const rp = obj;
    if (!rp) {
      return false;
    }
    return URI.isUri(rp.baseUri) && typeof rp.pattern === "string";
  }
  function isLegacyRelativePatternShape(obj) {
    const rp = obj;
    if (!rp) {
      return false;
    }
    return typeof rp.base === "string" && typeof rp.pattern === "string";
  }
  function to(pattern) {
    if (typeof pattern === "string") {
      return pattern;
    }
    return new RelativePattern(URI.revive(pattern.baseUri), pattern.pattern);
  }
  GlobPattern2.to = to;
})(GlobPattern || (GlobPattern = {}));
var LanguageSelector;
(function(LanguageSelector2) {
  function from(selector) {
    if (!selector) {
      return void 0;
    } else if (Array.isArray(selector)) {
      return selector.map(from);
    } else if (typeof selector === "string") {
      return selector;
    } else {
      const filter2 = selector;
      return {
        language: filter2.language,
        scheme: filter2.scheme,
        pattern: GlobPattern.from(filter2.pattern),
        exclusive: filter2.exclusive,
        notebookType: filter2.notebookType
      };
    }
  }
  LanguageSelector2.from = from;
})(LanguageSelector || (LanguageSelector = {}));
var MappedEditsContext;
(function(MappedEditsContext2) {
  function is(v) {
    return !!v && typeof v === "object" && "selections" in v && Array.isArray(v.selections) && v.selections.every((s) => s instanceof Selection) && "related" in v && Array.isArray(v.related) && v.related.every((e) => e && typeof e === "object" && URI.isUri(e.uri) && e.range instanceof Range2);
  }
  MappedEditsContext2.is = is;
  function from(extContext) {
    return {
      selections: extContext.selections.map((s) => Selection3.from(s)),
      related: extContext.related.map((r) => ({
        uri: URI.from(r.uri),
        range: Range3.from(r.range)
      }))
    };
  }
  MappedEditsContext2.from = from;
})(MappedEditsContext || (MappedEditsContext = {}));
var NotebookRange2;
(function(NotebookRange3) {
  function from(range) {
    return { start: range.start, end: range.end };
  }
  NotebookRange3.from = from;
  function to(range) {
    return new NotebookRange(range.start, range.end);
  }
  NotebookRange3.to = to;
})(NotebookRange2 || (NotebookRange2 = {}));
var NotebookCellExecutionSummary;
(function(NotebookCellExecutionSummary2) {
  function to(data) {
    return {
      timing: typeof data.runStartTime === "number" && typeof data.runEndTime === "number" ? { startTime: data.runStartTime, endTime: data.runEndTime } : void 0,
      executionOrder: data.executionOrder,
      success: data.lastRunSuccess
    };
  }
  NotebookCellExecutionSummary2.to = to;
  function from(data) {
    var _a30, _b;
    return {
      lastRunSuccess: data.success,
      runStartTime: (_a30 = data.timing) == null ? void 0 : _a30.startTime,
      runEndTime: (_b = data.timing) == null ? void 0 : _b.endTime,
      executionOrder: data.executionOrder
    };
  }
  NotebookCellExecutionSummary2.from = from;
})(NotebookCellExecutionSummary || (NotebookCellExecutionSummary = {}));
var NotebookCellExecutionState3;
(function(NotebookCellExecutionState4) {
  function to(state) {
    if (state === NotebookCellExecutionState.Unconfirmed) {
      return NotebookCellExecutionState2.Pending;
    } else if (state === NotebookCellExecutionState.Pending) {
      return void 0;
    } else if (state === NotebookCellExecutionState.Executing) {
      return NotebookCellExecutionState2.Executing;
    } else {
      throw new Error(`Unknown state: ${state}`);
    }
  }
  NotebookCellExecutionState4.to = to;
})(NotebookCellExecutionState3 || (NotebookCellExecutionState3 = {}));
var NotebookCellKind2;
(function(NotebookCellKind3) {
  function from(data) {
    switch (data) {
      case NotebookCellKind.Markup:
        return CellKind.Markup;
      case NotebookCellKind.Code:
      default:
        return CellKind.Code;
    }
  }
  NotebookCellKind3.from = from;
  function to(data) {
    switch (data) {
      case CellKind.Markup:
        return NotebookCellKind.Markup;
      case CellKind.Code:
      default:
        return NotebookCellKind.Code;
    }
  }
  NotebookCellKind3.to = to;
})(NotebookCellKind2 || (NotebookCellKind2 = {}));
var NotebookData2;
(function(NotebookData3) {
  function from(data) {
    const res = {
      metadata: data.metadata ?? /* @__PURE__ */ Object.create(null),
      cells: []
    };
    for (const cell of data.cells) {
      NotebookCellData.validate(cell);
      res.cells.push(NotebookCellData2.from(cell));
    }
    return res;
  }
  NotebookData3.from = from;
  function to(data) {
    const res = new NotebookData(data.cells.map(NotebookCellData2.to));
    if (!isEmptyObject(data.metadata)) {
      res.metadata = data.metadata;
    }
    return res;
  }
  NotebookData3.to = to;
})(NotebookData2 || (NotebookData2 = {}));
var NotebookCellData2;
(function(NotebookCellData3) {
  function from(data) {
    return {
      cellKind: NotebookCellKind2.from(data.kind),
      language: data.languageId,
      mime: data.mime,
      source: data.value,
      metadata: data.metadata,
      internalMetadata: NotebookCellExecutionSummary.from(data.executionSummary ?? {}),
      outputs: data.outputs ? data.outputs.map(NotebookCellOutput2.from) : []
    };
  }
  NotebookCellData3.from = from;
  function to(data) {
    return new NotebookCellData(NotebookCellKind2.to(data.cellKind), data.source, data.language, data.mime, data.outputs ? data.outputs.map(NotebookCellOutput2.to) : void 0, data.metadata, data.internalMetadata ? NotebookCellExecutionSummary.to(data.internalMetadata) : void 0);
  }
  NotebookCellData3.to = to;
})(NotebookCellData2 || (NotebookCellData2 = {}));
var NotebookCellOutputItem2;
(function(NotebookCellOutputItem3) {
  function from(item) {
    return {
      mime: item.mime,
      valueBytes: VSBuffer.wrap(item.data)
    };
  }
  NotebookCellOutputItem3.from = from;
  function to(item) {
    return new NotebookCellOutputItem(item.valueBytes.buffer, item.mime);
  }
  NotebookCellOutputItem3.to = to;
})(NotebookCellOutputItem2 || (NotebookCellOutputItem2 = {}));
var NotebookCellOutput2;
(function(NotebookCellOutput3) {
  function from(output) {
    return {
      outputId: output.id,
      items: output.items.map(NotebookCellOutputItem2.from),
      metadata: output.metadata
    };
  }
  NotebookCellOutput3.from = from;
  function to(output) {
    const items = output.items.map(NotebookCellOutputItem2.to);
    return new NotebookCellOutput(items, output.outputId, output.metadata);
  }
  NotebookCellOutput3.to = to;
})(NotebookCellOutput2 || (NotebookCellOutput2 = {}));
var NotebookExclusiveDocumentPattern;
(function(NotebookExclusiveDocumentPattern2) {
  function from(pattern) {
    if (isExclusivePattern(pattern)) {
      return {
        include: GlobPattern.from(pattern.include) ?? void 0,
        exclude: GlobPattern.from(pattern.exclude) ?? void 0
      };
    }
    return GlobPattern.from(pattern) ?? void 0;
  }
  NotebookExclusiveDocumentPattern2.from = from;
  function to(pattern) {
    if (isExclusivePattern(pattern)) {
      return {
        include: GlobPattern.to(pattern.include),
        exclude: GlobPattern.to(pattern.exclude)
      };
    }
    return GlobPattern.to(pattern);
  }
  NotebookExclusiveDocumentPattern2.to = to;
  function isExclusivePattern(obj) {
    const ep = obj;
    if (!ep) {
      return false;
    }
    return !isUndefinedOrNull(ep.include) && !isUndefinedOrNull(ep.exclude);
  }
})(
  NotebookExclusiveDocumentPattern || (NotebookExclusiveDocumentPattern = {})
);
var NotebookStatusBarItem;
(function(NotebookStatusBarItem2) {
  function from(item, commandsConverter, disposables) {
    const command = typeof item.command === "string" ? { title: "", command: item.command } : item.command;
    return {
      alignment: item.alignment === NotebookCellStatusBarAlignment.Left ? 1 : 2,
      command: commandsConverter.toInternal(command, disposables),
      text: item.text,
      tooltip: item.tooltip,
      accessibilityInformation: item.accessibilityInformation,
      priority: item.priority
    };
  }
  NotebookStatusBarItem2.from = from;
})(NotebookStatusBarItem || (NotebookStatusBarItem = {}));
var NotebookKernelSourceAction2;
(function(NotebookKernelSourceAction3) {
  function from(item, commandsConverter, disposables) {
    const command = typeof item.command === "string" ? { title: "", command: item.command } : item.command;
    return {
      command: commandsConverter.toInternal(command, disposables),
      label: item.label,
      description: item.description,
      detail: item.detail,
      documentation: item.documentation
    };
  }
  NotebookKernelSourceAction3.from = from;
})(NotebookKernelSourceAction2 || (NotebookKernelSourceAction2 = {}));
var NotebookDocumentContentOptions;
(function(NotebookDocumentContentOptions2) {
  function from(options) {
    return {
      transientOutputs: (options == null ? void 0 : options.transientOutputs) ?? false,
      transientCellMetadata: (options == null ? void 0 : options.transientCellMetadata) ?? {},
      transientDocumentMetadata: (options == null ? void 0 : options.transientDocumentMetadata) ?? {},
      cellContentMetadata: (options == null ? void 0 : options.cellContentMetadata) ?? {}
    };
  }
  NotebookDocumentContentOptions2.from = from;
})(NotebookDocumentContentOptions || (NotebookDocumentContentOptions = {}));
var NotebookRendererScript2;
(function(NotebookRendererScript3) {
  function from(preload) {
    return {
      uri: preload.uri,
      provides: preload.provides
    };
  }
  NotebookRendererScript3.from = from;
  function to(preload) {
    return new NotebookRendererScript(URI.revive(preload.uri), preload.provides);
  }
  NotebookRendererScript3.to = to;
})(NotebookRendererScript2 || (NotebookRendererScript2 = {}));
var TestMessage2;
(function(TestMessage3) {
  function from(message) {
    return {
      message: MarkdownString3.fromStrict(message.message) || "",
      type: 0,
      expected: message.expectedOutput,
      actual: message.actualOutput,
      contextValue: message.contextValue,
      location: message.location && { range: Range3.from(message.location.range), uri: message.location.uri }
    };
  }
  TestMessage3.from = from;
  function to(item) {
    const message = new TestMessage(typeof item.message === "string" ? item.message : MarkdownString3.to(item.message));
    message.actualOutput = item.actual;
    message.expectedOutput = item.expected;
    message.contextValue = item.contextValue;
    message.location = item.location ? location.to(item.location) : void 0;
    return message;
  }
  TestMessage3.to = to;
})(TestMessage2 || (TestMessage2 = {}));
var TestTag2;
(function(TestTag3) {
  TestTag3.namespace = namespaceTestTag;
  TestTag3.denamespace = denamespaceTestTag;
})(TestTag2 || (TestTag2 = {}));
var TestItem;
(function(TestItem2) {
  function from(item) {
    const ctrlId = getPrivateApiFor(item).controllerId;
    return {
      extId: TestId.fromExtHostTestItem(item, ctrlId).toString(),
      label: item.label,
      uri: URI.revive(item.uri),
      busy: item.busy,
      tags: item.tags.map((t) => TestTag2.namespace(ctrlId, t.id)),
      range: Range.lift(Range3.from(item.range)),
      description: item.description || null,
      sortText: item.sortText || null,
      error: item.error ? MarkdownString3.fromStrict(item.error) || null : null
    };
  }
  TestItem2.from = from;
  function toPlain(item) {
    return {
      parent: void 0,
      error: void 0,
      id: TestId.fromString(item.extId).localId,
      label: item.label,
      uri: URI.revive(item.uri),
      tags: (item.tags || []).map((t) => {
        const { tagId } = TestTag2.denamespace(t);
        return new TestTag(tagId);
      }),
      children: {
        add: () => {
        },
        delete: () => {
        },
        forEach: () => {
        },
        *[Symbol.iterator]() {
        },
        get: () => void 0,
        replace: () => {
        },
        size: 0
      },
      range: Range3.to(item.range || void 0),
      canResolveChildren: false,
      busy: item.busy,
      description: item.description || void 0,
      sortText: item.sortText || void 0
    };
  }
  TestItem2.toPlain = toPlain;
})(TestItem || (TestItem = {}));
(function(TestTag3) {
  function from(tag) {
    return { id: tag.id };
  }
  TestTag3.from = from;
  function to(tag) {
    return new TestTag(tag.id);
  }
  TestTag3.to = to;
})(TestTag2 || (TestTag2 = {}));
var TestResults;
(function(TestResults2) {
  const convertTestResultItem = (item, byInternalId) => {
    const children = [];
    for (const [id, item2] of byInternalId) {
      if (TestId.compare(item2.item.extId, id) === 2) {
        byInternalId.delete(id);
        children.push(item2);
      }
    }
    const snapshot = {
      ...TestItem.toPlain(item.item),
      parent: void 0,
      taskStates: item.tasks.map((t) => ({
        state: t.state,
        duration: t.duration,
        messages: t.messages.filter((m) => m.type === 0).map(TestMessage2.to)
      })),
      children: children.map((c) => convertTestResultItem(c, byInternalId))
    };
    for (const child of snapshot.children) {
      child.parent = snapshot;
    }
    return snapshot;
  };
  function to(serialized) {
    const roots = [];
    const byInternalId = /* @__PURE__ */ new Map();
    for (const item of serialized.items) {
      byInternalId.set(item.item.extId, item);
      const controllerId = TestId.root(item.item.extId);
      if (serialized.request.targets.some(
        (t) => t.controllerId === controllerId && t.testIds.includes(item.item.extId)
      )) {
        roots.push(item);
      }
    }
    return {
      completedAt: serialized.completedAt,
      results: roots.map((r) => convertTestResultItem(r, byInternalId))
    };
  }
  TestResults2.to = to;
})(TestResults || (TestResults = {}));
var TestCoverage;
(function(TestCoverage3) {
  function fromCoveredCount(count2) {
    return { covered: count2.covered, total: count2.covered };
  }
  function fromLocation(location2) {
    return "line" in location2 ? Position3.from(location2) : Range3.from(location2);
  }
  function fromDetailed(coverage) {
    if ("branches" in coverage) {
      return {
        count: coverage.executionCount,
        location: fromLocation(coverage.location),
        type: 1,
        branches: coverage.branches.length ? coverage.branches.map(
          (b) => ({ count: b.executionCount, location: b.location && fromLocation(b.location) })
        ) : void 0
      };
    } else {
      return {
        type: 0,
        count: coverage.executionCount,
        location: fromLocation(coverage.location)
      };
    }
  }
  TestCoverage3.fromDetailed = fromDetailed;
  function fromFile(coverage) {
    var _a30;
    return {
      uri: coverage.uri,
      statement: fromCoveredCount(coverage.statementCoverage),
      branch: coverage.branchCoverage && fromCoveredCount(coverage.branchCoverage),
      function: coverage.functionCoverage && fromCoveredCount(coverage.functionCoverage),
      details: (_a30 = coverage.detailedCoverage) == null ? void 0 : _a30.map(fromDetailed)
    };
  }
  TestCoverage3.fromFile = fromFile;
})(TestCoverage || (TestCoverage = {}));
var CodeActionTriggerKind2;
(function(CodeActionTriggerKind3) {
  function to(value) {
    switch (value) {
      case 1:
        return CodeActionTriggerKind.Invoke;
      case 2:
        return CodeActionTriggerKind.Automatic;
    }
  }
  CodeActionTriggerKind3.to = to;
})(CodeActionTriggerKind2 || (CodeActionTriggerKind2 = {}));
var TypeHierarchyItem2;
(function(TypeHierarchyItem3) {
  function to(item) {
    const result = new TypeHierarchyItem(SymbolKind2.to(item.kind), item.name, item.detail || "", URI.revive(item.uri), Range3.to(item.range), Range3.to(item.selectionRange));
    result._sessionId = item._sessionId;
    result._itemId = item._itemId;
    return result;
  }
  TypeHierarchyItem3.to = to;
  function from(item, sessionId, itemId) {
    var _a30;
    sessionId = sessionId ?? item._sessionId;
    itemId = itemId ?? item._itemId;
    if (sessionId === void 0 || itemId === void 0) {
      throw new Error("invalid item");
    }
    return {
      _sessionId: sessionId,
      _itemId: itemId,
      kind: SymbolKind2.from(item.kind),
      name: item.name,
      detail: item.detail ?? "",
      uri: item.uri,
      range: Range3.from(item.range),
      selectionRange: Range3.from(item.selectionRange),
      tags: (_a30 = item.tags) == null ? void 0 : _a30.map(SymbolTag2.from)
    };
  }
  TypeHierarchyItem3.from = from;
})(TypeHierarchyItem2 || (TypeHierarchyItem2 = {}));
var ViewBadge2;
(function(ViewBadge3) {
  function from(badge) {
    if (!badge) {
      return void 0;
    }
    return {
      value: badge.value,
      tooltip: badge.tooltip
    };
  }
  ViewBadge3.from = from;
})(ViewBadge2 || (ViewBadge2 = {}));
var DataTransferItem2;
(function(DataTransferItem3) {
  function to(mime, item, resolveFileData) {
    const file = item.fileData;
    if (file) {
      return new InternalFileDataTransferItem(new DataTransferFile(file.name, URI.revive(file.uri), file.id, once(() => resolveFileData(file.id))));
    }
    if (mime === Mimes.uriList && item.uriListData) {
      return new InternalDataTransferItem(reviveUriList(item.uriListData));
    }
    return new InternalDataTransferItem(item.asString);
  }
  DataTransferItem3.to = to;
  async function from(mime, item) {
    const stringValue = await item.asString();
    if (mime === Mimes.uriList) {
      return {
        asString: stringValue,
        fileData: void 0,
        uriListData: serializeUriList(stringValue)
      };
    }
    const fileValue = item.asFile();
    return {
      asString: stringValue,
      fileData: fileValue ? {
        name: fileValue.name,
        uri: fileValue.uri,
        id: fileValue._itemId ?? fileValue.id
      } : void 0
    };
  }
  DataTransferItem3.from = from;
  function serializeUriList(stringValue) {
    return UriList.split(stringValue).map((part) => {
      if (part.startsWith("#")) {
        return part;
      }
      try {
        return URI.parse(part);
      } catch {
      }
      return part;
    });
  }
  function reviveUriList(parts) {
    return UriList.create(parts.map((part) => {
      return typeof part === "string" ? part : URI.revive(part);
    }));
  }
})(DataTransferItem2 || (DataTransferItem2 = {}));
var DataTransfer2;
(function(DataTransfer3) {
  function toDataTransfer(value, resolveFileData) {
    const init = value.items.map(([type, item]) => {
      return [type, DataTransferItem2.to(type, item, resolveFileData)];
    });
    return new DataTransfer(init);
  }
  DataTransfer3.toDataTransfer = toDataTransfer;
  async function from(dataTransfer) {
    const newDTO = { items: [] };
    const promises = [];
    for (const [mime, value] of dataTransfer) {
      promises.push((async () => {
        newDTO.items.push([mime, await DataTransferItem2.from(mime, value)]);
      })());
    }
    await Promise.all(promises);
    return newDTO;
  }
  DataTransfer3.from = from;
})(DataTransfer2 || (DataTransfer2 = {}));
var ChatReplyFollowup;
(function(ChatReplyFollowup2) {
  function to(followup) {
    return {
      message: followup.message,
      metadata: followup.metadata,
      title: followup.title,
      tooltip: followup.tooltip
    };
  }
  ChatReplyFollowup2.to = to;
  function from(followup) {
    return {
      kind: "reply",
      message: followup.message,
      metadata: followup.metadata,
      title: followup.title,
      tooltip: followup.tooltip
    };
  }
  ChatReplyFollowup2.from = from;
})(ChatReplyFollowup || (ChatReplyFollowup = {}));
var ChatFollowup;
(function(ChatFollowup2) {
  function from(followup) {
    if (typeof followup === "string") {
      return { title: followup, message: followup, kind: "reply" };
    } else if ("commandId" in followup) {
      return {
        kind: "command",
        title: followup.title ?? "",
        commandId: followup.commandId ?? "",
        when: followup.when ?? "",
        args: followup.args
      };
    } else {
      return ChatReplyFollowup.from(followup);
    }
  }
  ChatFollowup2.from = from;
})(ChatFollowup || (ChatFollowup = {}));
var ChatMessage2;
(function(ChatMessage3) {
  function to(message) {
    const res = new ChatMessage(ChatMessageRole2.to(message.role), message.content);
    res.name = message.name;
    return res;
  }
  ChatMessage3.to = to;
  function from(message) {
    return {
      role: ChatMessageRole2.from(message.role),
      content: message.content,
      name: message.name
    };
  }
  ChatMessage3.from = from;
})(ChatMessage2 || (ChatMessage2 = {}));
var ChatMessageRole2;
(function(ChatMessageRole3) {
  function to(role) {
    switch (role) {
      case 0:
        return ChatMessageRole.System;
      case 1:
        return ChatMessageRole.User;
      case 2:
        return ChatMessageRole.Assistant;
      case 3:
        return ChatMessageRole.Function;
    }
  }
  ChatMessageRole3.to = to;
  function from(role) {
    switch (role) {
      case ChatMessageRole.System:
        return 0;
      case ChatMessageRole.Assistant:
        return 2;
      case ChatMessageRole.Function:
        return 3;
      case ChatMessageRole.User:
      default:
        return 1;
    }
  }
  ChatMessageRole3.from = from;
})(ChatMessageRole2 || (ChatMessageRole2 = {}));
var ChatVariable;
(function(ChatVariable2) {
  function to(variable) {
    return {
      level: ChatVariableLevel2.to(variable.level),
      value: variable.value,
      description: variable.description
    };
  }
  ChatVariable2.to = to;
  function from(variable) {
    return {
      level: ChatVariableLevel2.from(variable.level),
      value: variable.value,
      description: variable.description
    };
  }
  ChatVariable2.from = from;
})(ChatVariable || (ChatVariable = {}));
var ChatVariableLevel2;
(function(ChatVariableLevel3) {
  function to(level) {
    switch (level) {
      case "short":
        return ChatVariableLevel.Short;
      case "medium":
        return ChatVariableLevel.Medium;
      case "full":
      default:
        return ChatVariableLevel.Full;
    }
  }
  ChatVariableLevel3.to = to;
  function from(level) {
    switch (level) {
      case ChatVariableLevel.Short:
        return "short";
      case ChatVariableLevel.Medium:
        return "medium";
      case ChatVariableLevel.Full:
      default:
        return "full";
    }
  }
  ChatVariableLevel3.from = from;
})(ChatVariableLevel2 || (ChatVariableLevel2 = {}));
var TerminalQuickFix;
(function(TerminalQuickFix2) {
  function from(quickFix, converter, disposables) {
    if ("terminalCommand" in quickFix) {
      return { terminalCommand: quickFix.terminalCommand };
    }
    if ("uri" in quickFix) {
      return { uri: quickFix.uri };
    }
    return converter.toInternal(quickFix, disposables);
  }
  TerminalQuickFix2.from = from;
})(TerminalQuickFix || (TerminalQuickFix = {}));

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWorkspace.js
init_extHostTypes();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostUriTransformerService.js
init_instantiation();
var IURITransformerService = createDecorator("IURITransformerService");
var URITransformerService = class {
  constructor(delegate) {
    if (!delegate) {
      this.transformIncoming = (arg) => arg;
      this.transformOutgoing = (arg) => arg;
      this.transformOutgoingURI = (arg) => arg;
      this.transformOutgoingScheme = (arg) => arg;
    } else {
      this.transformIncoming = delegate.transformIncoming.bind(delegate);
      this.transformOutgoing = delegate.transformOutgoing.bind(delegate);
      this.transformOutgoingURI = delegate.transformOutgoingURI.bind(delegate);
      this.transformOutgoingScheme = delegate.transformOutgoingScheme.bind(delegate);
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWorkspace.js
init_extHost_protocol();
function isFolderEqual(folderA, folderB, extHostFileSystemInfo) {
  return new ExtUri((uri) => ignorePathCasing(uri, extHostFileSystemInfo)).isEqual(folderA, folderB);
}
function compareWorkspaceFolderByUri(a, b, extHostFileSystemInfo) {
  return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? 0 : compare(a.uri.toString(), b.uri.toString());
}
function compareWorkspaceFolderByUriAndNameAndIndex(a, b, extHostFileSystemInfo) {
  if (a.index !== b.index) {
    return a.index < b.index ? -1 : 1;
  }
  return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? compare(a.name, b.name) : compare(a.uri.toString(), b.uri.toString());
}
function delta2(oldFolders, newFolders, compare2, extHostFileSystemInfo) {
  const oldSortedFolders = oldFolders.slice(0).sort((a, b) => compare2(a, b, extHostFileSystemInfo));
  const newSortedFolders = newFolders.slice(0).sort((a, b) => compare2(a, b, extHostFileSystemInfo));
  return delta(oldSortedFolders, newSortedFolders, (a, b) => compare2(a, b, extHostFileSystemInfo));
}
function ignorePathCasing(uri, extHostFileSystemInfo) {
  const capabilities = extHostFileSystemInfo.getCapabilities(uri.scheme);
  return !(capabilities && capabilities & 1024);
}
var ExtHostWorkspaceImpl = class _ExtHostWorkspaceImpl extends Workspace {
  static toExtHostWorkspace(data, previousConfirmedWorkspace, previousUnconfirmedWorkspace, extHostFileSystemInfo) {
    if (!data) {
      return { workspace: null, added: [], removed: [] };
    }
    const { id, name, folders, configuration, transient, isUntitled } = data;
    const newWorkspaceFolders = [];
    const oldWorkspace = previousConfirmedWorkspace;
    if (previousConfirmedWorkspace) {
      folders.forEach((folderData, index) => {
        const folderUri = URI.revive(folderData.uri);
        const existingFolder = _ExtHostWorkspaceImpl._findFolder(previousUnconfirmedWorkspace || previousConfirmedWorkspace, folderUri, extHostFileSystemInfo);
        if (existingFolder) {
          existingFolder.name = folderData.name;
          existingFolder.index = folderData.index;
          newWorkspaceFolders.push(existingFolder);
        } else {
          newWorkspaceFolders.push({ uri: folderUri, name: folderData.name, index });
        }
      });
    } else {
      newWorkspaceFolders.push(...folders.map(({ uri, name: name2, index }) => ({ uri: URI.revive(uri), name: name2, index })));
    }
    newWorkspaceFolders.sort((f1, f2) => f1.index < f2.index ? -1 : 1);
    const workspace = new _ExtHostWorkspaceImpl(
      id,
      name,
      newWorkspaceFolders,
      !!transient,
      configuration ? URI.revive(configuration) : null,
      !!isUntitled,
      (uri) => ignorePathCasing(uri, extHostFileSystemInfo)
    );
    const { added, removed } = delta2(oldWorkspace ? oldWorkspace.workspaceFolders : [], workspace.workspaceFolders, compareWorkspaceFolderByUri, extHostFileSystemInfo);
    return { workspace, added, removed };
  }
  static _findFolder(workspace, folderUriToFind, extHostFileSystemInfo) {
    for (let i = 0; i < workspace.folders.length; i++) {
      const folder = workspace.workspaceFolders[i];
      if (isFolderEqual(folder.uri, folderUriToFind, extHostFileSystemInfo)) {
        return folder;
      }
    }
    return void 0;
  }
  constructor(id, _name, folders, transient, configuration, _isUntitled, ignorePathCasing2) {
    super(id, folders.map((f) => new WorkspaceFolder(f)), transient, configuration, ignorePathCasing2);
    this._name = _name;
    this._isUntitled = _isUntitled;
    this._workspaceFolders = [];
    this._structure = TernarySearchTree.forUris(ignorePathCasing2);
    folders.forEach((folder) => {
      this._workspaceFolders.push(folder);
      this._structure.set(folder.uri, folder);
    });
  }
  get name() {
    return this._name;
  }
  get isUntitled() {
    return this._isUntitled;
  }
  get workspaceFolders() {
    return this._workspaceFolders.slice(0);
  }
  getWorkspaceFolder(uri, resolveParent) {
    if (resolveParent && this._structure.get(uri)) {
      uri = dirname2(uri);
    }
    return this._structure.findSubstr(uri);
  }
  resolveWorkspaceFolder(uri) {
    return this._structure.get(uri);
  }
};
var ExtHostWorkspace = class ExtHostWorkspace2 {
  constructor(extHostRpc, initData, extHostFileSystemInfo, logService, uriTransformerService) {
    this._onDidChangeWorkspace = new Emitter();
    this.onDidChangeWorkspace = this._onDidChangeWorkspace.event;
    this._onDidGrantWorkspaceTrust = new Emitter();
    this.onDidGrantWorkspaceTrust = this._onDidGrantWorkspaceTrust.event;
    this._activeSearchCallbacks = [];
    this._trusted = false;
    this._editSessionIdentityProviders = /* @__PURE__ */ new Map();
    this._providerHandlePool = 0;
    this._onWillCreateEditSessionIdentityEvent = new AsyncEmitter();
    this._canonicalUriProviders = /* @__PURE__ */ new Map();
    this._logService = logService;
    this._extHostFileSystemInfo = extHostFileSystemInfo;
    this._uriTransformerService = uriTransformerService;
    this._requestIdProvider = new Counter();
    this._barrier = new Barrier();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadWorkspace);
    this._messageService = extHostRpc.getProxy(MainContext.MainThreadMessageService);
    const data = initData.workspace;
    this._confirmedWorkspace = data ? new ExtHostWorkspaceImpl(
      data.id,
      data.name,
      [],
      !!data.transient,
      data.configuration ? URI.revive(data.configuration) : null,
      !!data.isUntitled,
      (uri) => ignorePathCasing(uri, extHostFileSystemInfo)
    ) : void 0;
  }
  $initializeWorkspace(data, trusted) {
    this._trusted = trusted;
    this.$acceptWorkspaceData(data);
    this._barrier.open();
  }
  waitForInitializeCall() {
    return this._barrier.wait();
  }
  get workspace() {
    return this._actualWorkspace;
  }
  get name() {
    return this._actualWorkspace ? this._actualWorkspace.name : void 0;
  }
  get workspaceFile() {
    if (this._actualWorkspace) {
      if (this._actualWorkspace.configuration) {
        if (this._actualWorkspace.isUntitled) {
          return URI.from(
            { scheme: Schemas.untitled, path: basename2(dirname2(this._actualWorkspace.configuration)) }
          );
        }
        return this._actualWorkspace.configuration;
      }
    }
    return void 0;
  }
  get _actualWorkspace() {
    return this._unconfirmedWorkspace || this._confirmedWorkspace;
  }
  getWorkspaceFolders() {
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.workspaceFolders.slice(0);
  }
  async getWorkspaceFolders2() {
    await this._barrier.wait();
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.workspaceFolders.slice(0);
  }
  updateWorkspaceFolders(extension, index, deleteCount, ...workspaceFoldersToAdd) {
    const validatedDistinctWorkspaceFoldersToAdd = [];
    if (Array.isArray(workspaceFoldersToAdd)) {
      workspaceFoldersToAdd.forEach((folderToAdd) => {
        if (URI.isUri(folderToAdd.uri) && !validatedDistinctWorkspaceFoldersToAdd.some((f) => isFolderEqual(f.uri, folderToAdd.uri, this._extHostFileSystemInfo))) {
          validatedDistinctWorkspaceFoldersToAdd.push({ uri: folderToAdd.uri, name: folderToAdd.name || basenameOrAuthority(folderToAdd.uri) });
        }
      });
    }
    if (!!this._unconfirmedWorkspace) {
      return false;
    }
    if ([index, deleteCount].some((i) => typeof i !== "number" || i < 0)) {
      return false;
    }
    if (deleteCount === 0 && validatedDistinctWorkspaceFoldersToAdd.length === 0) {
      return false;
    }
    const currentWorkspaceFolders = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : [];
    if (index + deleteCount > currentWorkspaceFolders.length) {
      return false;
    }
    const newWorkspaceFolders = currentWorkspaceFolders.slice(0);
    newWorkspaceFolders.splice(index, deleteCount, ...validatedDistinctWorkspaceFoldersToAdd.map(
      (f) => ({ uri: f.uri, name: f.name || basenameOrAuthority(f.uri), index: void 0 })
    ));
    for (let i = 0; i < newWorkspaceFolders.length; i++) {
      const folder = newWorkspaceFolders[i];
      if (newWorkspaceFolders.some(
        (otherFolder, index2) => index2 !== i && isFolderEqual(folder.uri, otherFolder.uri, this._extHostFileSystemInfo)
      )) {
        return false;
      }
    }
    newWorkspaceFolders.forEach((f, index2) => f.index = index2);
    const { added, removed } = delta2(currentWorkspaceFolders, newWorkspaceFolders, compareWorkspaceFolderByUriAndNameAndIndex, this._extHostFileSystemInfo);
    if (added.length === 0 && removed.length === 0) {
      return false;
    }
    if (this._proxy) {
      const extName = extension.displayName || extension.name;
      this._proxy.$updateWorkspaceFolders(extName, index, deleteCount, validatedDistinctWorkspaceFoldersToAdd).then(void 0, (error) => {
        this._unconfirmedWorkspace = void 0;
        const options = { source: { identifier: extension.identifier, label: extension.displayName || extension.name } };
        this._messageService.$showMessage(Severity.Error, localize(
          "updateerror",
          "Extension '{0}' failed to update workspace folders: {1}",
          extName,
          error.toString()
        ), options, []);
      });
    }
    this.trySetWorkspaceFolders(newWorkspaceFolders);
    return true;
  }
  getWorkspaceFolder(uri, resolveParent) {
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);
  }
  async getWorkspaceFolder2(uri, resolveParent) {
    await this._barrier.wait();
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);
  }
  async resolveWorkspaceFolder(uri) {
    await this._barrier.wait();
    if (!this._actualWorkspace) {
      return void 0;
    }
    return this._actualWorkspace.resolveWorkspaceFolder(uri);
  }
  getPath() {
    if (!this._actualWorkspace) {
      return void 0;
    }
    const { folders } = this._actualWorkspace;
    if (folders.length === 0) {
      return void 0;
    }
    return folders[0].uri.fsPath;
  }
  getRelativePath(pathOrUri, includeWorkspace) {
    let resource;
    let path = "";
    if (typeof pathOrUri === "string") {
      resource = URI.file(pathOrUri);
      path = pathOrUri;
    } else if (typeof pathOrUri !== "undefined") {
      resource = pathOrUri;
      path = pathOrUri.fsPath;
    }
    if (!resource) {
      return path;
    }
    const folder = this.getWorkspaceFolder(resource, true);
    if (!folder) {
      return path;
    }
    if (typeof includeWorkspace === "undefined" && this._actualWorkspace) {
      includeWorkspace = this._actualWorkspace.folders.length > 1;
    }
    let result = relativePath(folder.uri, resource);
    if (includeWorkspace && folder.name) {
      result = `${folder.name}/${result}`;
    }
    return result;
  }
  trySetWorkspaceFolders(folders) {
    if (this._actualWorkspace) {
      this._unconfirmedWorkspace = ExtHostWorkspaceImpl.toExtHostWorkspace({
        id: this._actualWorkspace.id,
        name: this._actualWorkspace.name,
        configuration: this._actualWorkspace.configuration,
        folders,
        isUntitled: this._actualWorkspace.isUntitled
      }, this._actualWorkspace, void 0, this._extHostFileSystemInfo).workspace || void 0;
    }
  }
  $acceptWorkspaceData(data) {
    const { workspace, added, removed } = ExtHostWorkspaceImpl.toExtHostWorkspace(data, this._confirmedWorkspace, this._unconfirmedWorkspace, this._extHostFileSystemInfo);
    this._confirmedWorkspace = workspace || void 0;
    this._unconfirmedWorkspace = void 0;
    this._onDidChangeWorkspace.fire(Object.freeze({
      added,
      removed
    }));
  }
  findFiles(include, exclude, maxResults, extensionId, token = CancellationToken.None) {
    this._logService.trace(`extHostWorkspace#findFiles: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles`);
    let excludePatternOrDisregardExcludes = void 0;
    if (exclude === null) {
      excludePatternOrDisregardExcludes = false;
    } else if (exclude) {
      if (typeof exclude === "string") {
        excludePatternOrDisregardExcludes = exclude;
      } else {
        excludePatternOrDisregardExcludes = exclude.pattern;
      }
    }
    if (token && token.isCancellationRequested) {
      return Promise.resolve([]);
    }
    const { includePattern, folder } = parseSearchInclude(GlobPattern.from(include));
    return this._proxy.$startFileSearch(includePattern ?? null, folder ?? null, excludePatternOrDisregardExcludes ?? null, maxResults ?? null, token).then((data) => Array.isArray(data) ? data.map((d) => URI.revive(d)) : []);
  }
  async findTextInFiles(query, options, callback, extensionId, token = CancellationToken.None) {
    this._logService.trace(`extHostWorkspace#findTextInFiles: textSearch, extension: ${extensionId.value}, entryPoint: findTextInFiles`);
    const requestId = this._requestIdProvider.getNext();
    const previewOptions = typeof options.previewOptions === "undefined" ? {
      matchLines: 100,
      charsPerLine: 1e4
    } : options.previewOptions;
    const { includePattern, folder } = parseSearchInclude(GlobPattern.from(options.include));
    const excludePattern = typeof options.exclude === "string" ? options.exclude : options.exclude ? options.exclude.pattern : void 0;
    const queryOptions = {
      ignoreSymlinks: typeof options.followSymlinks === "boolean" ? !options.followSymlinks : void 0,
      disregardIgnoreFiles: typeof options.useIgnoreFiles === "boolean" ? !options.useIgnoreFiles : void 0,
      disregardGlobalIgnoreFiles: typeof options.useGlobalIgnoreFiles === "boolean" ? !options.useGlobalIgnoreFiles : void 0,
      disregardParentIgnoreFiles: typeof options.useParentIgnoreFiles === "boolean" ? !options.useParentIgnoreFiles : void 0,
      disregardExcludeSettings: typeof options.useDefaultExcludes === "boolean" ? !options.useDefaultExcludes : true,
      fileEncoding: options.encoding,
      maxResults: options.maxResults,
      previewOptions,
      afterContext: options.afterContext,
      beforeContext: options.beforeContext,
      includePattern,
      excludePattern
    };
    this._activeSearchCallbacks[requestId] = (p) => {
      const uri = URI.revive(p.resource);
      p.results.forEach((result) => {
        if (resultIsMatch(result)) {
          callback({
            uri,
            preview: {
              text: result.preview.text,
              matches: mapArrayOrNot(result.preview.matches, (m) => new Range2(m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn))
            },
            ranges: mapArrayOrNot(result.ranges, (r) => new Range2(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn))
          });
        } else {
          callback({
            uri,
            text: result.text,
            lineNumber: result.lineNumber
          });
        }
      });
    };
    if (token.isCancellationRequested) {
      return {};
    }
    try {
      const result = await this._proxy.$startTextSearch(query, folder ?? null, queryOptions, requestId, token);
      delete this._activeSearchCallbacks[requestId];
      return result || {};
    } catch (err) {
      delete this._activeSearchCallbacks[requestId];
      throw err;
    }
  }
  $handleTextSearchResult(result, requestId) {
    var _a30, _b;
    (_b = (_a30 = this._activeSearchCallbacks)[requestId]) == null ? void 0 : _b.call(_a30, result);
  }
  async save(uri) {
    const result = await this._proxy.$save(uri, { saveAs: false });
    return URI.revive(result);
  }
  async saveAs(uri) {
    const result = await this._proxy.$save(uri, { saveAs: true });
    return URI.revive(result);
  }
  saveAll(includeUntitled) {
    return this._proxy.$saveAll(includeUntitled);
  }
  resolveProxy(url) {
    return this._proxy.$resolveProxy(url);
  }
  get trusted() {
    return this._trusted;
  }
  requestWorkspaceTrust(options) {
    return this._proxy.$requestWorkspaceTrust(options);
  }
  $onDidGrantWorkspaceTrust() {
    if (!this._trusted) {
      this._trusted = true;
      this._onDidGrantWorkspaceTrust.fire();
    }
  }
  registerEditSessionIdentityProvider(scheme, provider) {
    if (this._editSessionIdentityProviders.has(scheme)) {
      throw new Error(`A provider has already been registered for scheme ${scheme}`);
    }
    this._editSessionIdentityProviders.set(scheme, provider);
    const outgoingScheme = this._uriTransformerService.transformOutgoingScheme(scheme);
    const handle = this._providerHandlePool++;
    this._proxy.$registerEditSessionIdentityProvider(handle, outgoingScheme);
    return toDisposable(() => {
      this._editSessionIdentityProviders.delete(scheme);
      this._proxy.$unregisterEditSessionIdentityProvider(handle);
    });
  }
  async $getEditSessionIdentifier(workspaceFolder, cancellationToken) {
    this._logService.info("Getting edit session identifier for workspaceFolder", workspaceFolder);
    const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));
    if (!folder) {
      this._logService.warn("Unable to resolve workspace folder");
      return void 0;
    }
    this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", folder);
    const provider = this._editSessionIdentityProviders.get(folder.uri.scheme);
    this._logService.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);
    if (!provider) {
      return void 0;
    }
    const result = await provider.provideEditSessionIdentity(folder, cancellationToken);
    this._logService.info("Provider returned edit session identifier: ", result);
    if (!result) {
      return void 0;
    }
    return result;
  }
  async $provideEditSessionIdentityMatch(workspaceFolder, identity1, identity2, cancellationToken) {
    var _a30;
    this._logService.info("Getting edit session identifier for workspaceFolder", workspaceFolder);
    const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));
    if (!folder) {
      this._logService.warn("Unable to resolve workspace folder");
      return void 0;
    }
    this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", folder);
    const provider = this._editSessionIdentityProviders.get(folder.uri.scheme);
    this._logService.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);
    if (!provider) {
      return void 0;
    }
    const result = await ((_a30 = provider.provideEditSessionIdentityMatch) == null ? void 0 : _a30.call(provider, identity1, identity2, cancellationToken));
    this._logService.info("Provider returned edit session identifier match result: ", result);
    if (!result) {
      return void 0;
    }
    return result;
  }
  getOnWillCreateEditSessionIdentityEvent(extension) {
    return (listener, thisArg, disposables) => {
      const wrappedListener = function wrapped(e) {
        listener.call(thisArg, e);
      };
      wrappedListener.extension = extension;
      return this._onWillCreateEditSessionIdentityEvent.event(wrappedListener, void 0, disposables);
    };
  }
  async $onWillCreateEditSessionIdentity(workspaceFolder, token, timeout2) {
    const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));
    if (folder === void 0) {
      throw new Error("Unable to resolve workspace folder");
    }
    await this._onWillCreateEditSessionIdentityEvent.fireAsync({ workspaceFolder: folder }, token, async (thenable, listener) => {
      const now = Date.now();
      await Promise.resolve(thenable);
      if (Date.now() - now > timeout2) {
        this._logService.warn("SLOW edit session create-participant", listener.extension.identifier);
      }
    });
    if (token.isCancellationRequested) {
      return void 0;
    }
  }
  registerCanonicalUriProvider(scheme, provider) {
    if (this._canonicalUriProviders.has(scheme)) {
      throw new Error(`A provider has already been registered for scheme ${scheme}`);
    }
    this._canonicalUriProviders.set(scheme, provider);
    const outgoingScheme = this._uriTransformerService.transformOutgoingScheme(scheme);
    const handle = this._providerHandlePool++;
    this._proxy.$registerCanonicalUriProvider(handle, outgoingScheme);
    return toDisposable(() => {
      this._canonicalUriProviders.delete(scheme);
      this._proxy.$unregisterCanonicalUriProvider(handle);
    });
  }
  async provideCanonicalUri(uri, options, cancellationToken) {
    var _a30;
    const provider = this._canonicalUriProviders.get(uri.scheme);
    if (!provider) {
      return void 0;
    }
    const result = await ((_a30 = provider.provideCanonicalUri) == null ? void 0 : _a30.call(provider, URI.revive(uri), options, cancellationToken));
    if (!result) {
      return void 0;
    }
    return result;
  }
  async $provideCanonicalUri(uri, targetScheme, cancellationToken) {
    return this.provideCanonicalUri(URI.revive(uri), { targetScheme }, cancellationToken);
  }
};
ExtHostWorkspace = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, IExtHostFileSystemInfo),
  __param(3, ILogService),
  __param(4, IURITransformerService)
], ExtHostWorkspace);
var IExtHostWorkspace = createDecorator("IExtHostWorkspace");
function parseSearchInclude(include) {
  let includePattern;
  let includeFolder;
  if (include) {
    if (typeof include === "string") {
      includePattern = include;
    } else {
      includePattern = include.pattern;
      includeFolder = URI.revive(include.baseUri);
    }
  }
  return {
    includePattern,
    folder: includeFolder
  };
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostConfiguration.js
init_extHost_protocol();
init_extHostTypes();
init_configurationRegistry();
init_types();
init_async();
init_instantiation();
init_log();
init_uri();
function lookUp(tree, key) {
  if (key) {
    const parts = key.split(".");
    let node = tree;
    for (let i = 0; node && i < parts.length; i++) {
      node = node[parts[i]];
    }
    return node;
  }
}
function isUri(thing) {
  return thing instanceof URI;
}
function isResourceLanguage(thing) {
  return thing && thing.uri instanceof URI && (thing.languageId && typeof thing.languageId === "string");
}
function isLanguage(thing) {
  return thing && !thing.uri && (thing.languageId && typeof thing.languageId === "string");
}
function isWorkspaceFolder(thing) {
  return thing && thing.uri instanceof URI && (!thing.name || typeof thing.name === "string") && (!thing.index || typeof thing.index === "number");
}
function scopeToOverrides(scope) {
  if (isUri(scope)) {
    return { resource: scope };
  }
  if (isResourceLanguage(scope)) {
    return { resource: scope.uri, overrideIdentifier: scope.languageId };
  }
  if (isLanguage(scope)) {
    return { overrideIdentifier: scope.languageId };
  }
  if (isWorkspaceFolder(scope)) {
    return { resource: scope.uri };
  }
  if (scope === null) {
    return { resource: null };
  }
  return void 0;
}
var ExtHostConfiguration = class ExtHostConfiguration2 {
  constructor(extHostRpc, extHostWorkspace, logService) {
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadConfiguration);
    this._extHostWorkspace = extHostWorkspace;
    this._logService = logService;
    this._barrier = new Barrier();
    this._actual = null;
  }
  getConfigProvider() {
    return this._barrier.wait().then((_) => this._actual);
  }
  $initializeConfiguration(data) {
    this._actual = new ExtHostConfigProvider(this._proxy, this._extHostWorkspace, data, this._logService);
    this._barrier.open();
  }
  $acceptConfigurationChanged(data, change) {
    this.getConfigProvider().then((provider) => provider.$acceptConfigurationChanged(data, change));
  }
};
ExtHostConfiguration = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostWorkspace),
  __param(2, ILogService)
], ExtHostConfiguration);
var ExtHostConfigProvider = class {
  constructor(proxy, extHostWorkspace, data, logService) {
    this._onDidChangeConfiguration = new Emitter();
    this._proxy = proxy;
    this._logService = logService;
    this._extHostWorkspace = extHostWorkspace;
    this._configuration = Configuration.parse(data);
    this._configurationScopes = this._toMap(data.configurationScopes);
  }
  get onDidChangeConfiguration() {
    return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;
  }
  $acceptConfigurationChanged(data, change) {
    const previous = { data: this._configuration.toData(), workspace: this._extHostWorkspace.workspace };
    this._configuration = Configuration.parse(data);
    this._configurationScopes = this._toMap(data.configurationScopes);
    this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(change, previous));
  }
  getConfiguration(section, scope, extensionDescription) {
    const overrides = scopeToOverrides(scope) || {};
    const config = this._toReadonlyValue(section ? lookUp(this._configuration.getValue(void 0, overrides, this._extHostWorkspace.workspace), section) : this._configuration.getValue(void 0, overrides, this._extHostWorkspace.workspace));
    if (section) {
      this._validateConfigurationAccess(section, overrides, extensionDescription == null ? void 0 : extensionDescription.identifier);
    }
    function parseConfigurationTarget(arg) {
      if (arg === void 0 || arg === null) {
        return null;
      }
      if (typeof arg === "boolean") {
        return arg ? 2 : 5;
      }
      switch (arg) {
        case ConfigurationTarget.Global:
          return 2;
        case ConfigurationTarget.Workspace:
          return 5;
        case ConfigurationTarget.WorkspaceFolder:
          return 6;
      }
    }
    const result = {
      has(key) {
        return typeof lookUp(config, key) !== "undefined";
      },
      get: (key, defaultValue) => {
        this._validateConfigurationAccess(section ? `${section}.${key}` : key, overrides, extensionDescription == null ? void 0 : extensionDescription.identifier);
        let result2 = lookUp(config, key);
        if (typeof result2 === "undefined") {
          result2 = defaultValue;
        } else {
          let clonedConfig = void 0;
          const cloneOnWriteProxy = (target, accessor) => {
            if (isObject(target)) {
              let clonedTarget = void 0;
              const cloneTarget = () => {
                clonedConfig = clonedConfig ? clonedConfig : deepClone(config);
                clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
              };
              return new Proxy(target, {
                get: (target2, property) => {
                  if (typeof property === "string" && property.toLowerCase() === "tojson") {
                    cloneTarget();
                    return () => clonedTarget;
                  }
                  if (clonedConfig) {
                    clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
                    return clonedTarget[property];
                  }
                  const result3 = target2[property];
                  if (typeof property === "string") {
                    return cloneOnWriteProxy(result3, `${accessor}.${property}`);
                  }
                  return result3;
                },
                set: (_target, property, value) => {
                  cloneTarget();
                  if (clonedTarget) {
                    clonedTarget[property] = value;
                  }
                  return true;
                },
                deleteProperty: (_target, property) => {
                  cloneTarget();
                  if (clonedTarget) {
                    delete clonedTarget[property];
                  }
                  return true;
                },
                defineProperty: (_target, property, descriptor) => {
                  cloneTarget();
                  if (clonedTarget) {
                    Object.defineProperty(clonedTarget, property, descriptor);
                  }
                  return true;
                }
              });
            }
            if (Array.isArray(target)) {
              return deepClone(target);
            }
            return target;
          };
          result2 = cloneOnWriteProxy(result2, key);
        }
        return result2;
      },
      update: (key, value, extHostConfigurationTarget, scopeToLanguage) => {
        key = section ? `${section}.${key}` : key;
        const target = parseConfigurationTarget(extHostConfigurationTarget);
        if (value !== void 0) {
          return this._proxy.$updateConfigurationOption(target, key, value, overrides, scopeToLanguage);
        } else {
          return this._proxy.$removeConfigurationOption(target, key, overrides, scopeToLanguage);
        }
      },
      inspect: (key) => {
        var _a30, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        key = section ? `${section}.${key}` : key;
        const config2 = this._configuration.inspect(key, overrides, this._extHostWorkspace.workspace);
        if (config2) {
          return {
            key,
            defaultValue: deepClone(((_a30 = config2.policy) == null ? void 0 : _a30.value) ?? ((_b = config2.default) == null ? void 0 : _b.value)),
            globalValue: deepClone(((_c = config2.user) == null ? void 0 : _c.value) ?? ((_d = config2.application) == null ? void 0 : _d.value)),
            workspaceValue: deepClone((_e = config2.workspace) == null ? void 0 : _e.value),
            workspaceFolderValue: deepClone((_f = config2.workspaceFolder) == null ? void 0 : _f.value),
            defaultLanguageValue: deepClone((_g = config2.default) == null ? void 0 : _g.override),
            globalLanguageValue: deepClone(((_h = config2.user) == null ? void 0 : _h.override) ?? ((_i = config2.application) == null ? void 0 : _i.override)),
            workspaceLanguageValue: deepClone((_j = config2.workspace) == null ? void 0 : _j.override),
            workspaceFolderLanguageValue: deepClone((_k = config2.workspaceFolder) == null ? void 0 : _k.override),
            languageIds: deepClone(config2.overrideIdentifiers)
          };
        }
        return void 0;
      }
    };
    if (typeof config === "object") {
      mixin(result, config, false);
    }
    return Object.freeze(result);
  }
  _toReadonlyValue(result) {
    const readonlyProxy = (target) => {
      return isObject(target) ? new Proxy(target, {
        get: (target2, property) => readonlyProxy(target2[property]),
        set: (_target, property, _value) => {
          throw new Error(`TypeError: Cannot assign to read only property '${String(property)}' of object`);
        },
        deleteProperty: (_target, property) => {
          throw new Error(`TypeError: Cannot delete read only property '${String(property)}' of object`);
        },
        defineProperty: (_target, property) => {
          throw new Error(`TypeError: Cannot define property '${String(property)}' for a readonly object`);
        },
        setPrototypeOf: (_target) => {
          throw new Error(`TypeError: Cannot set prototype for a readonly object`);
        },
        isExtensible: () => false,
        preventExtensions: () => true
      }) : target;
    };
    return readonlyProxy(result);
  }
  _validateConfigurationAccess(key, overrides, extensionId) {
    const scope = OVERRIDE_PROPERTY_REGEX.test(key) ? 4 : this._configurationScopes.get(key);
    const extensionIdText = extensionId ? `[${extensionId.value}] ` : "";
    if (4 === scope) {
      if (typeof (overrides == null ? void 0 : overrides.resource) === "undefined") {
        this._logService.warn(`${extensionIdText}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${key}', provide the URI of a resource or 'null' for any resource.`);
      }
      return;
    }
    if (3 === scope) {
      if (overrides == null ? void 0 : overrides.resource) {
        this._logService.warn(`${extensionIdText}Accessing a window scoped configuration for a resource is not expected. To associate '${key}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`);
      }
      return;
    }
  }
  _toConfigurationChangeEvent(change, previous) {
    const event = new ConfigurationChangeEvent(change, previous, this._configuration, this._extHostWorkspace.workspace);
    return Object.freeze({
      affectsConfiguration: (section, scope) => event.affectsConfiguration(section, scopeToOverrides(scope))
    });
  }
  _toMap(scopes) {
    return scopes.reduce((result, scope) => {
      result.set(scope[0], scope[1]);
      return result;
    }, /* @__PURE__ */ new Map());
  }
};
var IExtHostConfiguration = createDecorator("IExtHostConfiguration");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionActivator.js
init_tslib_es6();
init_errors();
init_extensions();
init_log();
init_async();
var _ExtensionActivationTimes = class _ExtensionActivationTimes {
  constructor(startup, codeLoadingTime, activateCallTime, activateResolvedTime) {
    this.startup = startup;
    this.codeLoadingTime = codeLoadingTime;
    this.activateCallTime = activateCallTime;
    this.activateResolvedTime = activateResolvedTime;
  }
};
_ExtensionActivationTimes.NONE = new _ExtensionActivationTimes(false, -1, -1, -1);
var ExtensionActivationTimes = _ExtensionActivationTimes;
var ExtensionActivationTimesBuilder = class {
  constructor(startup) {
    this._startup = startup;
    this._codeLoadingStart = -1;
    this._codeLoadingStop = -1;
    this._activateCallStart = -1;
    this._activateCallStop = -1;
    this._activateResolveStart = -1;
    this._activateResolveStop = -1;
  }
  _delta(start, stop) {
    if (start === -1 || stop === -1) {
      return -1;
    }
    return stop - start;
  }
  build() {
    return new ExtensionActivationTimes(
      this._startup,
      this._delta(this._codeLoadingStart, this._codeLoadingStop),
      this._delta(this._activateCallStart, this._activateCallStop),
      this._delta(this._activateResolveStart, this._activateResolveStop)
    );
  }
  codeLoadingStart() {
    this._codeLoadingStart = Date.now();
  }
  codeLoadingStop() {
    this._codeLoadingStop = Date.now();
  }
  activateCallStart() {
    this._activateCallStart = Date.now();
  }
  activateCallStop() {
    this._activateCallStop = Date.now();
  }
  activateResolveStart() {
    this._activateResolveStart = Date.now();
  }
  activateResolveStop() {
    this._activateResolveStop = Date.now();
  }
};
var ActivatedExtension = class {
  constructor(activationFailed, activationFailedError, activationTimes, module, exports, subscriptions) {
    this.activationFailed = activationFailed;
    this.activationFailedError = activationFailedError;
    this.activationTimes = activationTimes;
    this.module = module;
    this.exports = exports;
    this.subscriptions = subscriptions;
  }
};
var EmptyExtension = class extends ActivatedExtension {
  constructor(activationTimes) {
    super(false, null, activationTimes, { activate: void 0, deactivate: void 0 }, void 0, []);
  }
};
var HostExtension = class extends ActivatedExtension {
  constructor() {
    super(false, null, ExtensionActivationTimes.NONE, { activate: void 0, deactivate: void 0 }, void 0, []);
  }
};
var FailedExtension = class extends ActivatedExtension {
  constructor(activationError) {
    super(true, activationError, ExtensionActivationTimes.NONE, { activate: void 0, deactivate: void 0 }, void 0, []);
  }
};
var ExtensionsActivator = class ExtensionsActivator2 {
  constructor(registry, globalRegistry, host, _logService) {
    this._logService = _logService;
    this._registry = registry;
    this._globalRegistry = globalRegistry;
    this._host = host;
    this._operations = new ExtensionIdentifierMap();
    this._alreadyActivatedEvents = /* @__PURE__ */ Object.create(null);
  }
  dispose() {
    for (const [_, op] of this._operations) {
      op.dispose();
    }
  }
  async waitForActivatingExtensions() {
    const res = [];
    for (const [_, op] of this._operations) {
      res.push(op.wait());
    }
    await Promise.all(res);
  }
  isActivated(extensionId) {
    const op = this._operations.get(extensionId);
    return Boolean(op && op.value);
  }
  getActivatedExtension(extensionId) {
    const op = this._operations.get(extensionId);
    if (!op || !op.value) {
      throw new Error(`Extension '${extensionId.value}' is not known or not activated`);
    }
    return op.value;
  }
  async activateByEvent(activationEvent, startup) {
    if (this._alreadyActivatedEvents[activationEvent]) {
      return;
    }
    const activateExtensions = this._registry.getExtensionDescriptionsForActivationEvent(activationEvent);
    await this._activateExtensions(activateExtensions.map((e) => ({
      id: e.identifier,
      reason: { startup, extensionId: e.identifier, activationEvent }
    })));
    this._alreadyActivatedEvents[activationEvent] = true;
  }
  activateById(extensionId, reason) {
    const desc = this._registry.getExtensionDescription(extensionId);
    if (!desc) {
      throw new Error(`Extension '${extensionId}' is not known`);
    }
    return this._activateExtensions([{ id: desc.identifier, reason }]);
  }
  async _activateExtensions(extensions) {
    const operations = extensions.filter((p) => !this.isActivated(p.id)).map((ext) => this._handleActivationRequest(ext));
    await Promise.all(operations.map((op) => op.wait()));
  }
  _handleActivationRequest(currentActivation) {
    if (this._operations.has(currentActivation.id)) {
      return this._operations.get(currentActivation.id);
    }
    if (this._isHostExtension(currentActivation.id)) {
      return this._createAndSaveOperation(currentActivation, null, [], null);
    }
    const currentExtension = this._registry.getExtensionDescription(currentActivation.id);
    if (!currentExtension) {
      const error = new Error(`Cannot activate unknown extension '${currentActivation.id.value}'`);
      const result = this._createAndSaveOperation(currentActivation, null, [], new FailedExtension(error));
      this._host.onExtensionActivationError(currentActivation.id, error, new MissingExtensionDependency(currentActivation.id.value));
      return result;
    }
    const deps = [];
    const depIds = typeof currentExtension.extensionDependencies === "undefined" ? [] : currentExtension.extensionDependencies;
    for (const depId of depIds) {
      if (this._isResolvedExtension(depId)) {
        continue;
      }
      const dep = this._operations.get(depId);
      if (dep) {
        deps.push(dep);
        continue;
      }
      if (this._isHostExtension(depId)) {
        deps.push(this._handleActivationRequest({
          id: this._globalRegistry.getExtensionDescription(depId).identifier,
          reason: currentActivation.reason
        }));
        continue;
      }
      const depDesc = this._registry.getExtensionDescription(depId);
      if (depDesc) {
        if (!depDesc.main && !depDesc.browser) {
          continue;
        }
        deps.push(this._handleActivationRequest({
          id: depDesc.identifier,
          reason: currentActivation.reason
        }));
        continue;
      }
      const currentExtensionFriendlyName = currentExtension.displayName || currentExtension.identifier.value;
      const error = new Error(
        `Cannot activate the '${currentExtensionFriendlyName}' extension because it depends on unknown extension '${depId}'`
      );
      const result = this._createAndSaveOperation(currentActivation, currentExtension.displayName, [], new FailedExtension(error));
      this._host.onExtensionActivationError(currentExtension.identifier, error, new MissingExtensionDependency(depId));
      return result;
    }
    return this._createAndSaveOperation(currentActivation, currentExtension.displayName, deps, null);
  }
  _createAndSaveOperation(activation, displayName, deps, value) {
    const operation = new ActivationOperation(
      activation.id,
      displayName,
      activation.reason,
      deps,
      value,
      this._host,
      this._logService
    );
    this._operations.set(activation.id, operation);
    return operation;
  }
  _isHostExtension(extensionId) {
    return ExtensionDescriptionRegistry.isHostExtension(extensionId, this._registry, this._globalRegistry);
  }
  _isResolvedExtension(extensionId) {
    const extensionDescription = this._globalRegistry.getExtensionDescription(extensionId);
    if (!extensionDescription) {
      return false;
    }
    return !extensionDescription.main && !extensionDescription.browser;
  }
};
ExtensionsActivator = __decorate([
  __param(3, ILogService)
], ExtensionsActivator);
var ActivationOperation = class ActivationOperation2 {
  get value() {
    return this._value;
  }
  get friendlyName() {
    return this._displayName || this._id.value;
  }
  constructor(_id, _displayName, _reason, _deps, _value, _host, _logService) {
    this._id = _id;
    this._displayName = _displayName;
    this._reason = _reason;
    this._deps = _deps;
    this._value = _value;
    this._host = _host;
    this._logService = _logService;
    this._barrier = new Barrier();
    this._isDisposed = false;
    this._initialize();
  }
  dispose() {
    this._isDisposed = true;
  }
  wait() {
    return this._barrier.wait();
  }
  async _initialize() {
    await this._waitForDepsThenActivate();
    this._barrier.open();
  }
  async _waitForDepsThenActivate() {
    if (this._value) {
      return;
    }
    while (this._deps.length > 0) {
      for (let i = 0; i < this._deps.length; i++) {
        const dep = this._deps[i];
        if (dep.value && !dep.value.activationFailed) {
          this._deps.splice(i, 1);
          i--;
          continue;
        }
        if (dep.value && dep.value.activationFailed) {
          const error = new Error(
            `Cannot activate the '${this.friendlyName}' extension because its dependency '${dep.friendlyName}' failed to activate`
          );
          error.detail = dep.value.activationFailedError;
          this._value = new FailedExtension(error);
          this._host.onExtensionActivationError(this._id, error, null);
          return;
        }
      }
      if (this._deps.length > 0) {
        await Promise.race(this._deps.map((dep) => dep.wait()));
      }
    }
    await this._activate();
  }
  async _activate() {
    try {
      this._value = await this._host.actualActivateExtension(this._id, this._reason);
    } catch (err) {
      const error = new Error();
      if (err && err.name) {
        error.name = err.name;
      }
      if (err && err.message) {
        error.message = `Activating extension '${this._id.value}' failed: ${err.message}.`;
      } else {
        error.message = `Activating extension '${this._id.value}' failed: ${err}.`;
      }
      if (err && err.stack) {
        error.stack = err.stack;
      }
      this._value = new FailedExtension(error);
      if (this._isDisposed && isCancellationError(err)) {
        return;
      }
      this._host.onExtensionActivationError(this._id, error, null);
      this._logService.error(`Activating extension ${this._id.value} failed due to an error:`);
      this._logService.error(err);
    }
  }
};
ActivationOperation = __decorate([
  __param(6, ILogService)
], ActivationOperation);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostStorage.js
init_extHost_protocol();
init_event();
init_instantiation();
var ExtHostStorage = class {
  constructor(mainContext, _logService) {
    this._logService = _logService;
    this._onDidChangeStorage = new Emitter();
    this.onDidChangeStorage = this._onDidChangeStorage.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadStorage);
  }
  registerExtensionStorageKeysToSync(extension, keys) {
    this._proxy.$registerExtensionStorageKeysToSync(extension, keys);
  }
  async initializeExtensionStorage(shared, key, defaultValue) {
    const value = await this._proxy.$initializeExtensionStorage(shared, key);
    let parsedValue;
    if (value) {
      parsedValue = this.safeParseValue(shared, key, value);
    }
    return parsedValue || defaultValue;
  }
  setValue(shared, key, value) {
    return this._proxy.$setValue(shared, key, value);
  }
  $acceptValue(shared, key, value) {
    const parsedValue = this.safeParseValue(shared, key, value);
    if (parsedValue) {
      this._onDidChangeStorage.fire({ shared, key, value: parsedValue });
    }
  }
  safeParseValue(shared, key, value) {
    try {
      return JSON.parse(value);
    } catch (error) {
      this._logService.error(`[extHostStorage] unexpected error parsing storage contents (extensionId: ${key}, global: ${shared}): ${error}`);
    }
    return void 0;
  }
};
var IExtHostStorage = createDecorator("IExtHostStorage");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionService.js
init_errors();
init_extensions();
init_buffer();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostMemento.js
init_async();
var ExtensionMemento = class {
  constructor(id, global2, storage) {
    this._deferredPromises = /* @__PURE__ */ new Map();
    this._id = id;
    this._shared = global2;
    this._storage = storage;
    this._init = this._storage.initializeExtensionStorage(this._shared, this._id, /* @__PURE__ */ Object.create(null)).then((value) => {
      this._value = value;
      return this;
    });
    this._storageListener = this._storage.onDidChangeStorage((e) => {
      if (e.shared === this._shared && e.key === this._id) {
        this._value = e.value;
      }
    });
    this._scheduler = new RunOnceScheduler(() => {
      const records = this._deferredPromises;
      this._deferredPromises = /* @__PURE__ */ new Map();
      (async () => {
        try {
          await this._storage.setValue(this._shared, this._id, this._value);
          for (const value of records.values()) {
            value.complete();
          }
        } catch (e) {
          for (const value of records.values()) {
            value.error(e);
          }
        }
      })();
    }, 0);
  }
  keys() {
    return Object.entries(this._value ?? {}).filter(([, value]) => value !== void 0).map(([key]) => key);
  }
  get whenReady() {
    return this._init;
  }
  get(key, defaultValue) {
    let value = this._value[key];
    if (typeof value === "undefined") {
      value = defaultValue;
    }
    return value;
  }
  update(key, value) {
    this._value[key] = value;
    const record = this._deferredPromises.get(key);
    if (record !== void 0) {
      return record.p;
    }
    const promise = new DeferredPromise();
    this._deferredPromises.set(key, promise);
    if (!this._scheduler.isScheduled()) {
      this._scheduler.schedule();
    }
    return promise.p;
  }
  dispose() {
    this._storageListener.dispose();
  }
};
var ExtensionGlobalMemento = class extends ExtensionMemento {
  setKeysForSync(keys) {
    this._storage.registerExtensionStorageKeysToSync({ id: this._id, version: this._extension.version }, keys);
  }
  constructor(extensionDescription, storage) {
    super(extensionDescription.identifier.value, true, storage);
    this._extension = extensionDescription;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionService.js
init_extHostTypes();
init_remoteAuthorityResolver();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostStoragePaths.js
init_tslib_es6();
init_instantiation();
init_log();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostFileSystemConsumer.js
init_tslib_es6();
init_extHost_protocol();
init_files();
init_extHostTypes();
init_buffer();
init_instantiation();
init_lifecycle();
init_async();
init_resources();
init_network();
var ExtHostConsumerFileSystem_1;
var ExtHostConsumerFileSystem = ExtHostConsumerFileSystem_1 = class ExtHostConsumerFileSystem2 {
  constructor(extHostRpc, fileSystemInfo) {
    this._fileSystemProvider = /* @__PURE__ */ new Map();
    this._writeQueue = new ResourceQueue();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadFileSystem);
    const that = this;
    this.value = Object.freeze({
      async stat(uri) {
        try {
          let stat;
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider) {
            await that._proxy.$ensureActivation(uri.scheme);
            stat = await provider.impl.stat(uri);
          } else {
            stat = await that._proxy.$stat(uri);
          }
          return {
            type: stat.type,
            ctime: stat.ctime,
            mtime: stat.mtime,
            size: stat.size,
            permissions: stat.permissions === FilePermission.Readonly ? 1 : void 0
          };
        } catch (err) {
          ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async readDirectory(uri) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider) {
            await that._proxy.$ensureActivation(uri.scheme);
            return (await provider.impl.readDirectory(uri)).slice();
          } else {
            return await that._proxy.$readdir(uri);
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async createDirectory(uri) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider && !provider.isReadonly) {
            await that._proxy.$ensureActivation(uri.scheme);
            return await that.mkdirp(provider.impl, provider.extUri, uri);
          } else {
            return await that._proxy.$mkdir(uri);
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async readFile(uri) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider) {
            await that._proxy.$ensureActivation(uri.scheme);
            return (await provider.impl.readFile(uri)).slice();
          } else {
            const buff = await that._proxy.$readFile(uri);
            return buff.buffer;
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async writeFile(uri, content) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider && !provider.isReadonly) {
            await that._proxy.$ensureActivation(uri.scheme);
            await that.mkdirp(provider.impl, provider.extUri, provider.extUri.dirname(uri));
            return await that._writeQueue.queueFor(uri).queue(() => Promise.resolve(provider.impl.writeFile(uri, content, { create: true, overwrite: true })));
          } else {
            return await that._proxy.$writeFile(uri, VSBuffer.wrap(content));
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async delete(uri, options) {
        try {
          const provider = that._fileSystemProvider.get(uri.scheme);
          if (provider && !provider.isReadonly) {
            await that._proxy.$ensureActivation(uri.scheme);
            return await provider.impl.delete(uri, { recursive: false, ...options });
          } else {
            return await that._proxy.$delete(uri, { recursive: false, useTrash: false, atomic: false, ...options });
          }
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async rename(oldUri, newUri, options) {
        try {
          return await that._proxy.$rename(oldUri, newUri, { ...{ overwrite: false }, ...options });
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      async copy(source, destination, options) {
        try {
          return await that._proxy.$copy(source, destination, { ...{ overwrite: false }, ...options });
        } catch (err) {
          return ExtHostConsumerFileSystem_1._handleError(err);
        }
      },
      isWritableFileSystem(scheme) {
        const capabilities = fileSystemInfo.getCapabilities(scheme);
        if (typeof capabilities === "number") {
          return !(capabilities & 2048);
        }
        return void 0;
      }
    });
  }
  async mkdirp(provider, providerExtUri, directory) {
    const directoriesToCreate = [];
    while (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {
      try {
        const stat = await provider.stat(directory);
        if ((stat.type & FileType.Directory) === 0) {
          throw FileSystemError.FileExists(`Unable to create folder '${directory.scheme === Schemas.file ? directory.fsPath : directory.toString(true)}' that already exists but is not a directory`);
        }
        break;
      } catch (error) {
        if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {
          throw error;
        }
        directoriesToCreate.push(providerExtUri.basename(directory));
        directory = providerExtUri.dirname(directory);
      }
    }
    for (let i = directoriesToCreate.length - 1; i >= 0; i--) {
      directory = providerExtUri.joinPath(directory, directoriesToCreate[i]);
      try {
        await provider.createDirectory(directory);
      } catch (error) {
        if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {
          throw error;
        }
      }
    }
  }
  static _handleError(err) {
    if (err instanceof FileSystemError) {
      throw err;
    }
    if (err instanceof FileSystemProviderError) {
      switch (err.code) {
        case FileSystemProviderErrorCode.FileExists:
          throw FileSystemError.FileExists(err.message);
        case FileSystemProviderErrorCode.FileNotFound:
          throw FileSystemError.FileNotFound(err.message);
        case FileSystemProviderErrorCode.FileNotADirectory:
          throw FileSystemError.FileNotADirectory(err.message);
        case FileSystemProviderErrorCode.FileIsADirectory:
          throw FileSystemError.FileIsADirectory(err.message);
        case FileSystemProviderErrorCode.NoPermissions:
          throw FileSystemError.NoPermissions(err.message);
        case FileSystemProviderErrorCode.Unavailable:
          throw FileSystemError.Unavailable(err.message);
        default:
          throw new FileSystemError(err.message, err.name);
      }
    }
    if (!(err instanceof Error)) {
      throw new FileSystemError(String(err));
    }
    if (err.name === "ENOPRO" || err.message.includes("ENOPRO")) {
      throw FileSystemError.Unavailable(err.message);
    }
    switch (err.name) {
      case FileSystemProviderErrorCode.FileExists:
        throw FileSystemError.FileExists(err.message);
      case FileSystemProviderErrorCode.FileNotFound:
        throw FileSystemError.FileNotFound(err.message);
      case FileSystemProviderErrorCode.FileNotADirectory:
        throw FileSystemError.FileNotADirectory(err.message);
      case FileSystemProviderErrorCode.FileIsADirectory:
        throw FileSystemError.FileIsADirectory(err.message);
      case FileSystemProviderErrorCode.NoPermissions:
        throw FileSystemError.NoPermissions(err.message);
      case FileSystemProviderErrorCode.Unavailable:
        throw FileSystemError.Unavailable(err.message);
      default:
        throw new FileSystemError(err.message, err.name);
    }
  }
  addFileSystemProvider(scheme, provider, options) {
    this._fileSystemProvider.set(scheme, { impl: provider, extUri: (options == null ? void 0 : options.isCaseSensitive) ? extUri : extUriIgnorePathCase, isReadonly: !!(options == null ? void 0 : options.isReadonly) });
    return toDisposable(() => this._fileSystemProvider.delete(scheme));
  }
  getFileSystemProviderExtUri(scheme) {
    var _a30;
    return ((_a30 = this._fileSystemProvider.get(scheme)) == null ? void 0 : _a30.extUri) ?? extUri;
  }
};
ExtHostConsumerFileSystem = ExtHostConsumerFileSystem_1 = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostFileSystemInfo)
], ExtHostConsumerFileSystem);
var IExtHostConsumerFileSystem = createDecorator("IExtHostConsumerFileSystem");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostStoragePaths.js
init_uri();
var IExtensionStoragePaths = createDecorator("IExtensionStoragePaths");
var ExtensionStoragePaths = class ExtensionStoragePaths2 {
  constructor(initData, _logService, _extHostFileSystem) {
    this._logService = _logService;
    this._extHostFileSystem = _extHostFileSystem;
    this._workspace = initData.workspace ?? void 0;
    this._environment = initData.environment;
    this.whenReady = this._getOrCreateWorkspaceStoragePath().then((value) => this._value = value);
  }
  async _getWorkspaceStorageURI(storageName) {
    return URI.joinPath(this._environment.workspaceStorageHome, storageName);
  }
  async _getOrCreateWorkspaceStoragePath() {
    var _a30;
    if (!this._workspace) {
      return Promise.resolve(void 0);
    }
    const storageName = this._workspace.id;
    const storageUri = await this._getWorkspaceStorageURI(storageName);
    try {
      await this._extHostFileSystem.value.stat(storageUri);
      this._logService.trace("[ExtHostStorage] storage dir already exists", storageUri);
      return storageUri;
    } catch {
    }
    try {
      this._logService.trace("[ExtHostStorage] creating dir and metadata-file", storageUri);
      await this._extHostFileSystem.value.createDirectory(storageUri);
      await this._extHostFileSystem.value.writeFile(URI.joinPath(storageUri, "meta.json"), new TextEncoder().encode(JSON.stringify({
        id: this._workspace.id,
        configuration: (_a30 = URI.revive(this._workspace.configuration)) == null ? void 0 : _a30.toString(),
        name: this._workspace.name
      }, void 0, 2)));
      return storageUri;
    } catch (e) {
      this._logService.error("[ExtHostStorage]", e);
      return void 0;
    }
  }
  workspaceValue(extension) {
    if (this._value) {
      return URI.joinPath(this._value, extension.identifier.value);
    }
    return void 0;
  }
  globalValue(extension) {
    return URI.joinPath(this._environment.globalStorageHome, extension.identifier.value.toLowerCase());
  }
  onWillDeactivateAll() {
  }
};
ExtensionStoragePaths = __decorate([
  __param(0, IExtHostInitDataService),
  __param(1, ILogService),
  __param(2, IExtHostConsumerFileSystem)
], ExtensionStoragePaths);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTunnelService.js
init_tslib_es6();
init_cancellation();
init_event();
init_lifecycle();
init_nls();
init_instantiation();
init_log();
init_extHost_protocol();
init_extHostTypes();
var ExtensionTunnel = class extends DisposableTunnel {
};
var TunnelDtoConverter;
(function(TunnelDtoConverter2) {
  function fromApiTunnel(tunnel) {
    return {
      remoteAddress: tunnel.remoteAddress,
      localAddress: tunnel.localAddress,
      public: !!tunnel.public,
      privacy: tunnel.privacy ?? (tunnel.public ? TunnelPrivacyId.Public : TunnelPrivacyId.Private),
      protocol: tunnel.protocol
    };
  }
  TunnelDtoConverter2.fromApiTunnel = fromApiTunnel;
  function fromServiceTunnel(tunnel) {
    return {
      remoteAddress: {
        host: tunnel.tunnelRemoteHost,
        port: tunnel.tunnelRemotePort
      },
      localAddress: tunnel.localAddress,
      public: tunnel.privacy !== TunnelPrivacyId.ConstantPrivate && tunnel.privacy !== TunnelPrivacyId.ConstantPrivate,
      privacy: tunnel.privacy,
      protocol: tunnel.protocol
    };
  }
  TunnelDtoConverter2.fromServiceTunnel = fromServiceTunnel;
})(TunnelDtoConverter || (TunnelDtoConverter = {}));
var IExtHostTunnelService = createDecorator("IExtHostTunnelService");
var ExtHostTunnelService = class ExtHostTunnelService2 extends Disposable {
  constructor(extHostRpc, initData, logService) {
    super();
    this.logService = logService;
    this._showCandidatePort = () => {
      return Promise.resolve(true);
    };
    this._extensionTunnels = /* @__PURE__ */ new Map();
    this._onDidChangeTunnels = new Emitter();
    this.onDidChangeTunnels = this._onDidChangeTunnels.event;
    this._providerHandleCounter = 0;
    this._portAttributesProviders = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadTunnelService);
  }
  async openTunnel(extension, forward) {
    this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) ${extension.identifier.value} called openTunnel API for ${forward.remoteAddress.host}:${forward.remoteAddress.port}.`);
    const tunnel = await this._proxy.$openTunnel(forward, extension.displayName);
    if (tunnel) {
      const disposableTunnel = new ExtensionTunnel(tunnel.remoteAddress, tunnel.localAddress, () => {
        return this._proxy.$closeTunnel(tunnel.remoteAddress);
      });
      this._register(disposableTunnel);
      return disposableTunnel;
    }
    return void 0;
  }
  async getTunnels() {
    return this._proxy.$getTunnels();
  }
  nextPortAttributesProviderHandle() {
    return this._providerHandleCounter++;
  }
  registerPortsAttributesProvider(portSelector, provider) {
    const providerHandle = this.nextPortAttributesProviderHandle();
    this._portAttributesProviders.set(providerHandle, { selector: portSelector, provider });
    this._proxy.$registerPortsAttributesProvider(portSelector, providerHandle);
    return new Disposable2(() => {
      this._portAttributesProviders.delete(providerHandle);
      this._proxy.$unregisterPortsAttributesProvider(providerHandle);
    });
  }
  async $providePortAttributes(handles, ports, pid, commandLine, cancellationToken) {
    const providedAttributes = [];
    for (const handle of handles) {
      const provider = this._portAttributesProviders.get(handle);
      if (!provider) {
        return [];
      }
      providedAttributes.push(...await Promise.all(ports.map(async (port) => {
        let providedAttributes2;
        try {
          providedAttributes2 = await provider.provider.providePortAttributes({ port, pid, commandLine }, cancellationToken);
        } catch (e) {
          providedAttributes2 = await provider.provider.providePortAttributes(port, pid, commandLine, cancellationToken);
        }
        return { providedAttributes: providedAttributes2, port };
      })));
    }
    const allAttributes = providedAttributes.filter((attribute) => !!attribute.providedAttributes);
    return allAttributes.length > 0 ? allAttributes.map((attributes) => {
      return {
        autoForwardAction: attributes.providedAttributes.autoForwardAction,
        port: attributes.port
      };
    }) : [];
  }
  async $registerCandidateFinder(_enable) {
  }
  registerTunnelProvider(provider, information) {
    var _a30, _b;
    if (this._forwardPortProvider) {
      throw new Error("A tunnel provider has already been registered. Only the first tunnel provider to be registered will be used.");
    }
    this._forwardPortProvider = async (tunnelOptions, tunnelCreationOptions) => {
      const result = await provider.provideTunnel(tunnelOptions, tunnelCreationOptions, new CancellationTokenSource().token);
      return result ?? void 0;
    };
    const tunnelFeatures = information.tunnelFeatures ? {
      elevation: !!((_a30 = information.tunnelFeatures) == null ? void 0 : _a30.elevation),
      privacyOptions: (_b = information.tunnelFeatures) == null ? void 0 : _b.privacyOptions
    } : void 0;
    this._proxy.$setTunnelProvider(tunnelFeatures);
    return Promise.resolve(toDisposable(() => {
      this._forwardPortProvider = void 0;
      this._proxy.$setTunnelProvider(void 0);
    }));
  }
  async setTunnelFactory(provider, managedRemoteAuthority) {
    var _a30, _b, _c, _d;
    if (provider) {
      if (provider.candidatePortSource !== void 0) {
        this._proxy.$setCandidatePortSource(provider.candidatePortSource);
      }
      if (provider.showCandidatePort) {
        this._showCandidatePort = provider.showCandidatePort;
        this._proxy.$setCandidateFilter();
      }
      const tunnelFactory = provider.tunnelFactory ?? (managedRemoteAuthority ? this.makeManagedTunnelFactory(managedRemoteAuthority) : void 0);
      if (tunnelFactory) {
        this._forwardPortProvider = tunnelFactory;
        let privacyOptions = ((_a30 = provider.tunnelFeatures) == null ? void 0 : _a30.privacyOptions) ?? [];
        if (((_b = provider.tunnelFeatures) == null ? void 0 : _b.public) && privacyOptions.length === 0) {
          privacyOptions = [
            {
              id: "private",
              label: localize("tunnelPrivacy.private", "Private"),
              themeIcon: "lock"
            },
            {
              id: "public",
              label: localize("tunnelPrivacy.public", "Public"),
              themeIcon: "eye"
            }
          ];
        }
        const tunnelFeatures = provider.tunnelFeatures ? {
          elevation: !!((_c = provider.tunnelFeatures) == null ? void 0 : _c.elevation),
          public: !!((_d = provider.tunnelFeatures) == null ? void 0 : _d.public),
          privacyOptions
        } : void 0;
        this._proxy.$setTunnelProvider(tunnelFeatures);
      }
    } else {
      this._forwardPortProvider = void 0;
    }
    return toDisposable(() => {
      this._forwardPortProvider = void 0;
    });
  }
  makeManagedTunnelFactory(_authority) {
    return void 0;
  }
  async $closeTunnel(remote, silent) {
    if (this._extensionTunnels.has(remote.host)) {
      const hostMap = this._extensionTunnels.get(remote.host);
      if (hostMap.has(remote.port)) {
        if (silent) {
          hostMap.get(remote.port).disposeListener.dispose();
        }
        await hostMap.get(remote.port).tunnel.dispose();
        hostMap.delete(remote.port);
      }
    }
  }
  async $onDidTunnelsChange() {
    this._onDidChangeTunnels.fire();
  }
  async $forwardPort(tunnelOptions, tunnelCreationOptions) {
    if (this._forwardPortProvider) {
      try {
        this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Getting tunnel from provider.");
        const providedPort = this._forwardPortProvider(tunnelOptions, tunnelCreationOptions);
        this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Got tunnel promise from provider.");
        if (providedPort !== void 0) {
          const tunnel = await providedPort;
          this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Successfully awaited tunnel from provider.");
          if (tunnel === void 0) {
            this.logService.error("ForwardedPorts: (ExtHostTunnelService) Resolved tunnel is undefined");
            return void 0;
          }
          if (!this._extensionTunnels.has(tunnelOptions.remoteAddress.host)) {
            this._extensionTunnels.set(tunnelOptions.remoteAddress.host, /* @__PURE__ */ new Map());
          }
          const disposeListener = this._register(tunnel.onDidDispose(() => {
            this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Extension fired tunnel's onDidDispose.");
            return this._proxy.$closeTunnel(tunnel.remoteAddress);
          }));
          this._extensionTunnels.get(tunnelOptions.remoteAddress.host).set(tunnelOptions.remoteAddress.port, { tunnel, disposeListener });
          return TunnelDtoConverter.fromApiTunnel(tunnel);
        } else {
          this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Tunnel is undefined");
        }
      } catch (e) {
        this.logService.trace("ForwardedPorts: (ExtHostTunnelService) tunnel provider error");
        if (e instanceof Error) {
          return e.message;
        }
      }
    }
    return void 0;
  }
  async $applyCandidateFilter(candidates) {
    const filter2 = await Promise.all(candidates.map(
      (candidate) => this._showCandidatePort(candidate.host, candidate.port, candidate.detail ?? "")
    ));
    const result = candidates.filter((candidate, index) => filter2[index]);
    this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) filtered from ${candidates.map((port) => port.port).join(", ")} to ${result.map((port) => port.port).join(", ")}`);
    return result;
  }
};
ExtHostTunnelService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, ILogService)
], ExtHostTunnelService);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTerminalService.js
init_tslib_es6();
init_event();
init_extHost_protocol();
init_instantiation();
init_uri();
init_lifecycle();
init_extHostTypes();
init_nls();
init_errors();

// node_modules/vscode/vscode/src/vs/platform/terminal/common/environmentVariableShared.js
function serializeEnvironmentVariableCollection(collection) {
  return [...collection.entries()];
}
function serializeEnvironmentDescriptionMap(descriptionMap) {
  return descriptionMap ? [...descriptionMap.entries()] : [];
}
function deserializeEnvironmentVariableCollection(serializedCollection) {
  return new Map(serializedCollection);
}
function deserializeEnvironmentDescriptionMap(serializableEnvironmentDescription) {
  return new Map(serializableEnvironmentDescription ?? []);
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTerminalService.js
init_cancellation();
init_uuid();

// node_modules/vscode/vscode/src/vs/platform/terminal/common/terminalDataBuffering.js
var TerminalDataBufferer = class {
  constructor(_callback) {
    this._callback = _callback;
    this._terminalBufferMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    for (const buffer of this._terminalBufferMap.values()) {
      buffer.dispose();
    }
  }
  startBuffering(id, event, throttleBy = 5) {
    const disposable = event((e) => {
      const data = typeof e === "string" ? e : e.data;
      let buffer = this._terminalBufferMap.get(id);
      if (buffer) {
        buffer.data.push(data);
        return;
      }
      const timeoutId = setTimeout(() => this.flushBuffer(id), throttleBy);
      buffer = {
        data: [data],
        timeoutId,
        dispose: () => {
          clearTimeout(timeoutId);
          this.flushBuffer(id);
          disposable.dispose();
        }
      };
      this._terminalBufferMap.set(id, buffer);
    });
    return disposable;
  }
  stopBuffering(id) {
    const buffer = this._terminalBufferMap.get(id);
    buffer == null ? void 0 : buffer.dispose();
  }
  flushBuffer(id) {
    const buffer = this._terminalBufferMap.get(id);
    if (buffer) {
      this._terminalBufferMap.delete(id);
      this._callback(id, buffer.data.join(""));
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTerminalService.js
init_themables();
init_async();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostCommands.js
init_tslib_es6();
init_types();
init_extHostTypes();
init_objects();
init_extHost_protocol();
init_arrays();
init_log();
init_range();
init_position();
init_uri();
init_lifecycle();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTestItem.js
init_range();
init_uri();
var testItemPropAccessor = (api, defaultValue, equals3, toUpdate) => {
  let value = defaultValue;
  return {
    enumerable: true,
    configurable: false,
    get() {
      return value;
    },
    set(newValue) {
      var _a30;
      if (!equals3(value, newValue)) {
        const oldValue = value;
        value = newValue;
        (_a30 = api.listener) == null ? void 0 : _a30.call(api, toUpdate(newValue, oldValue));
      }
    }
  };
};
var strictEqualComparator2 = (a, b) => a === b;
var propComparators = {
  range: (a, b) => {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.isEqual(b);
  },
  label: strictEqualComparator2,
  description: strictEqualComparator2,
  sortText: strictEqualComparator2,
  busy: strictEqualComparator2,
  error: strictEqualComparator2,
  canResolveChildren: strictEqualComparator2,
  tags: (a, b) => {
    if (a.length !== b.length) {
      return false;
    }
    if (a.some((t1) => !b.find((t2) => t1.id === t2.id))) {
      return false;
    }
    return true;
  }
};
var evSetProps = (fn) => (v) => ({ op: 4, update: fn(v) });
var makePropDescriptors = (api, label) => ({
  range: (() => {
    let value;
    const updateProps = evSetProps((r) => ({ range: Range.lift(Range3.from(r)) }));
    return {
      enumerable: true,
      configurable: false,
      get() {
        return value;
      },
      set(newValue) {
        var _a30, _b;
        (_a30 = api.listener) == null ? void 0 : _a30.call(api, { op: 6 });
        if (!propComparators.range(value, newValue)) {
          value = newValue;
          (_b = api.listener) == null ? void 0 : _b.call(api, updateProps(newValue));
        }
      }
    };
  })(),
  label: testItemPropAccessor(api, label, propComparators.label, evSetProps((label2) => ({ label: label2 }))),
  description: testItemPropAccessor(api, void 0, propComparators.description, evSetProps((description) => ({ description }))),
  sortText: testItemPropAccessor(api, void 0, propComparators.sortText, evSetProps((sortText) => ({ sortText }))),
  canResolveChildren: testItemPropAccessor(api, false, propComparators.canResolveChildren, (state) => ({
    op: 2,
    state
  })),
  busy: testItemPropAccessor(api, false, propComparators.busy, evSetProps((busy) => ({ busy }))),
  error: testItemPropAccessor(api, void 0, propComparators.error, evSetProps((error) => ({ error: MarkdownString3.fromStrict(error) || null }))),
  tags: testItemPropAccessor(api, [], propComparators.tags, (current, previous) => ({
    op: 1,
    new: current.map(TestTag2.from),
    old: previous.map(TestTag2.from)
  }))
});
var toItemFromPlain = (item) => {
  const testId = TestId.fromString(item.extId);
  const testItem = new TestItemImpl(
    testId.controllerId,
    testId.localId,
    item.label,
    URI.revive(item.uri) || void 0
  );
  testItem.range = Range3.to(item.range || void 0);
  testItem.description = item.description || void 0;
  testItem.sortText = item.sortText || void 0;
  testItem.tags = item.tags.map((t) => TestTag2.to({ id: denamespaceTestTag(t).tagId }));
  return testItem;
};
var toItemFromContext = (context) => {
  let node;
  for (const test of context.tests) {
    const next = toItemFromPlain(test.item);
    getPrivateApiFor(next).parent = node;
    node = next;
  }
  return node;
};
var TestItemImpl = class _TestItemImpl {
  constructor(controllerId, id, label, uri) {
    if (id.includes("\0")) {
      throw new Error(`Test IDs may not include the ${JSON.stringify(id)} symbol`);
    }
    const api = createPrivateApiFor(this, controllerId);
    Object.defineProperties(this, {
      id: {
        value: id,
        enumerable: true,
        writable: false
      },
      uri: {
        value: uri,
        enumerable: true,
        writable: false
      },
      parent: {
        enumerable: false,
        get() {
          return api.parent instanceof TestItemRootImpl ? void 0 : api.parent;
        }
      },
      children: {
        value: createTestItemChildren(api, getPrivateApiFor, _TestItemImpl),
        enumerable: true,
        writable: false
      },
      ...makePropDescriptors(api, label)
    });
  }
};
var TestItemRootImpl = class extends TestItemImpl {
  constructor(controllerId, label) {
    super(controllerId, controllerId, label, void 0);
    this._isRoot = true;
  }
};
var ExtHostTestItemCollection = class extends TestItemCollection {
  constructor(controllerId, controllerLabel, editors) {
    super({
      controllerId,
      getDocumentVersion: (uri) => {
        var _a30;
        return uri && ((_a30 = editors.getDocument(uri)) == null ? void 0 : _a30.version);
      },
      getApiFor: getPrivateApiFor,
      getChildren: (item) => item.children,
      root: new TestItemRootImpl(controllerId, controllerLabel),
      toITestItem: TestItem.from
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostCommands.js
init_buffer();
init_proxyIdentifier();
init_errorMessage();
init_stopwatch();
init_telemetryUtils();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTelemetry.js
init_tslib_es6();
init_instantiation();
init_event();
init_log();
init_extensionHostProtocol();
init_remoteHosts();
init_telemetryUtils();
init_objects();
init_uri();
init_lifecycle();
init_nls();
var ExtHostTelemetry = class ExtHostTelemetry2 extends Disposable {
  constructor(initData, loggerService) {
    super();
    this.initData = initData;
    this.loggerService = loggerService;
    this._onDidChangeTelemetryEnabled = this._register(new Emitter());
    this.onDidChangeTelemetryEnabled = this._onDidChangeTelemetryEnabled.event;
    this._onDidChangeTelemetryConfiguration = this._register(new Emitter());
    this.onDidChangeTelemetryConfiguration = this._onDidChangeTelemetryConfiguration.event;
    this._productConfig = { usage: true, error: true };
    this._level = 0;
    this._telemetryIsSupported = false;
    this._inLoggingOnlyMode = false;
    this._telemetryLoggers = /* @__PURE__ */ new Map();
    this.extHostTelemetryLogFile = URI.revive(this.initData.environment.extensionTelemetryLogResource);
    this._inLoggingOnlyMode = this.initData.environment.isExtensionTelemetryLoggingOnly;
    this._outputLogger = loggerService.createLogger(this.extHostTelemetryLogFile, { id: extensionTelemetryLogChannelId, name: localize(
      "extensionTelemetryLog",
      "Extension Telemetry{0}",
      this._inLoggingOnlyMode ? " (Not Sent)" : ""
    ), hidden: true });
    this._register(loggerService.onDidChangeLogLevel((arg) => {
      if (isLogLevel(arg)) {
        this.updateLoggerVisibility();
      }
    }));
    this._outputLogger.info("Below are logs for extension telemetry events sent to the telemetry output channel API once the log level is set to trace.");
    this._outputLogger.info("===========================================================");
  }
  updateLoggerVisibility() {
    this.loggerService.setVisibility(this.extHostTelemetryLogFile, this._telemetryIsSupported && this.loggerService.getLogLevel() === LogLevel.Trace);
  }
  getTelemetryConfiguration() {
    return this._level === 3;
  }
  getTelemetryDetails() {
    return {
      isCrashEnabled: this._level >= 1,
      isErrorsEnabled: this._productConfig.error ? this._level >= 2 : false,
      isUsageEnabled: this._productConfig.usage ? this._level >= 3 : false
    };
  }
  instantiateLogger(extension, sender, options) {
    const telemetryDetails = this.getTelemetryDetails();
    const logger = new ExtHostTelemetryLogger(
      sender,
      options,
      extension,
      this._outputLogger,
      this._inLoggingOnlyMode,
      this.getBuiltInCommonProperties(extension),
      { isUsageEnabled: telemetryDetails.isUsageEnabled, isErrorsEnabled: telemetryDetails.isErrorsEnabled }
    );
    const loggers = this._telemetryLoggers.get(extension.identifier.value) ?? [];
    this._telemetryLoggers.set(extension.identifier.value, [...loggers, logger]);
    return logger.apiTelemetryLogger;
  }
  $initializeTelemetryLevel(level, supportsTelemetry2, productConfig) {
    this._level = level;
    this._telemetryIsSupported = supportsTelemetry2;
    this._productConfig = productConfig ?? { usage: true, error: true };
    this.updateLoggerVisibility();
  }
  getBuiltInCommonProperties(extension) {
    const commonProperties = /* @__PURE__ */ Object.create(null);
    commonProperties["common.extname"] = `${extension.publisher}.${extension.name}`;
    commonProperties["common.extversion"] = extension.version;
    commonProperties["common.vscodemachineid"] = this.initData.telemetryInfo.machineId;
    commonProperties["common.vscodesessionid"] = this.initData.telemetryInfo.sessionId;
    commonProperties["common.vscodeversion"] = this.initData.version;
    commonProperties["common.isnewappinstall"] = isNewAppInstall(this.initData.telemetryInfo.firstSessionDate);
    commonProperties["common.product"] = this.initData.environment.appHost;
    switch (this.initData.uiKind) {
      case UIKind.Web:
        commonProperties["common.uikind"] = "web";
        break;
      case UIKind.Desktop:
        commonProperties["common.uikind"] = "desktop";
        break;
      default:
        commonProperties["common.uikind"] = "unknown";
    }
    commonProperties["common.remotename"] = getRemoteName(cleanRemoteAuthority(this.initData.remote.authority));
    return commonProperties;
  }
  $onDidChangeTelemetryLevel(level) {
    this._oldTelemetryEnablement = this.getTelemetryConfiguration();
    this._level = level;
    const telemetryDetails = this.getTelemetryDetails();
    this._telemetryLoggers.forEach((loggers, key) => {
      const newLoggers = loggers.filter((l) => !l.isDisposed);
      if (newLoggers.length === 0) {
        this._telemetryLoggers.delete(key);
      } else {
        this._telemetryLoggers.set(key, newLoggers);
      }
    });
    this._telemetryLoggers.forEach((loggers) => {
      for (const logger of loggers) {
        logger.updateTelemetryEnablements(telemetryDetails.isUsageEnabled, telemetryDetails.isErrorsEnabled);
      }
    });
    if (this._oldTelemetryEnablement !== this.getTelemetryConfiguration()) {
      this._onDidChangeTelemetryEnabled.fire(this.getTelemetryConfiguration());
    }
    this._onDidChangeTelemetryConfiguration.fire(this.getTelemetryDetails());
    this.updateLoggerVisibility();
  }
  onExtensionError(extension, error) {
    const loggers = this._telemetryLoggers.get(extension.value);
    const nonDisposedLoggers = loggers == null ? void 0 : loggers.filter((l) => !l.isDisposed);
    if (!nonDisposedLoggers) {
      this._telemetryLoggers.delete(extension.value);
      return false;
    }
    let errorEmitted = false;
    for (const logger of nonDisposedLoggers) {
      if (logger.ignoreUnhandledExtHostErrors) {
        continue;
      }
      logger.logError(error);
      errorEmitted = true;
    }
    return errorEmitted;
  }
};
ExtHostTelemetry = __decorate([
  __param(0, IExtHostInitDataService),
  __param(1, ILoggerService)
], ExtHostTelemetry);
var ExtHostTelemetryLogger = class {
  static validateSender(sender) {
    if (typeof sender !== "object") {
      throw new TypeError("TelemetrySender argument is invalid");
    }
    if (typeof sender.sendEventData !== "function") {
      throw new TypeError("TelemetrySender.sendEventData must be a function");
    }
    if (typeof sender.sendErrorData !== "function") {
      throw new TypeError("TelemetrySender.sendErrorData must be a function");
    }
    if (typeof sender.flush !== "undefined" && typeof sender.flush !== "function") {
      throw new TypeError("TelemetrySender.flush must be a function or undefined");
    }
  }
  constructor(sender, options, _extension2, _logger, _inLoggingOnlyMode, _commonProperties, telemetryEnablements) {
    this._extension = _extension2;
    this._logger = _logger;
    this._inLoggingOnlyMode = _inLoggingOnlyMode;
    this._commonProperties = _commonProperties;
    this._onDidChangeEnableStates = new Emitter();
    this.ignoreUnhandledExtHostErrors = (options == null ? void 0 : options.ignoreUnhandledErrors) ?? false;
    this._ignoreBuiltinCommonProperties = (options == null ? void 0 : options.ignoreBuiltInCommonProperties) ?? false;
    this._additionalCommonProperties = options == null ? void 0 : options.additionalCommonProperties;
    this._sender = sender;
    this._telemetryEnablements = { isUsageEnabled: telemetryEnablements.isUsageEnabled, isErrorsEnabled: telemetryEnablements.isErrorsEnabled };
  }
  updateTelemetryEnablements(isUsageEnabled, isErrorsEnabled) {
    if (this._apiObject) {
      this._telemetryEnablements = { isUsageEnabled, isErrorsEnabled };
      this._onDidChangeEnableStates.fire(this._apiObject);
    }
  }
  mixInCommonPropsAndCleanData(data) {
    let updatedData = "properties" in data ? data.properties ?? {} : data;
    updatedData = cleanData(updatedData, []);
    if (this._additionalCommonProperties) {
      updatedData = mixin(updatedData, this._additionalCommonProperties);
    }
    if (!this._ignoreBuiltinCommonProperties) {
      updatedData = mixin(updatedData, this._commonProperties);
    }
    if ("properties" in data) {
      data.properties = updatedData;
    } else {
      data = updatedData;
    }
    return data;
  }
  logEvent(eventName, data) {
    var _a30;
    if (!this._sender) {
      return;
    }
    if (this._extension.publisher === "vscode") {
      eventName = this._extension.name + "/" + eventName;
    } else {
      eventName = this._extension.identifier.value + "/" + eventName;
    }
    data = this.mixInCommonPropsAndCleanData(data || {});
    if (!this._inLoggingOnlyMode) {
      (_a30 = this._sender) == null ? void 0 : _a30.sendEventData(eventName, data);
    }
    this._logger.trace(eventName, data);
  }
  logUsage(eventName, data) {
    if (!this._telemetryEnablements.isUsageEnabled) {
      return;
    }
    this.logEvent(eventName, data);
  }
  logError(eventNameOrException, data) {
    if (!this._telemetryEnablements.isErrorsEnabled || !this._sender) {
      return;
    }
    if (typeof eventNameOrException === "string") {
      this.logEvent(eventNameOrException, data);
    } else {
      const errorData = {
        name: eventNameOrException.name,
        message: eventNameOrException.message,
        stack: eventNameOrException.stack,
        cause: eventNameOrException.cause
      };
      const cleanedErrorData = cleanData(errorData, []);
      const cleanedError = new Error(cleanedErrorData.message, {
        cause: cleanedErrorData.cause
      });
      cleanedError.stack = cleanedErrorData.stack;
      cleanedError.name = cleanedErrorData.name;
      data = this.mixInCommonPropsAndCleanData(data || {});
      if (!this._inLoggingOnlyMode) {
        this._sender.sendErrorData(cleanedError, data);
      }
      this._logger.trace("exception", data);
    }
  }
  get apiTelemetryLogger() {
    if (!this._apiObject) {
      const that = this;
      const obj = {
        logUsage: that.logUsage.bind(that),
        get isUsageEnabled() {
          return that._telemetryEnablements.isUsageEnabled;
        },
        get isErrorsEnabled() {
          return that._telemetryEnablements.isErrorsEnabled;
        },
        logError: that.logError.bind(that),
        dispose: that.dispose.bind(that),
        onDidChangeEnableStates: that._onDidChangeEnableStates.event.bind(that)
      };
      this._apiObject = Object.freeze(obj);
    }
    return this._apiObject;
  }
  get isDisposed() {
    return !this._sender;
  }
  dispose() {
    var _a30;
    if ((_a30 = this._sender) == null ? void 0 : _a30.flush) {
      let tempSender = this._sender;
      this._sender = void 0;
      Promise.resolve(tempSender.flush()).then(tempSender = void 0);
      this._apiObject = void 0;
    } else {
      this._sender = void 0;
    }
  }
};
function isNewAppInstall(firstSessionDate) {
  const installAge = Date.now() - new Date(firstSessionDate).getTime();
  return isNaN(installAge) ? false : installAge < 1e3 * 60 * 60 * 24;
}
var IExtHostTelemetry = createDecorator("IExtHostTelemetry");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostCommands.js
var _proxy, _telemetry, _extHostTelemetry, _a2;
var ExtHostCommands = (_a2 = class {
  constructor(extHostRpc, logService, extHostTelemetry) {
    __privateAdd(this, _proxy, void 0);
    __privateAdd(this, _telemetry, void 0);
    __privateAdd(this, _extHostTelemetry, void 0);
    this._commands = /* @__PURE__ */ new Map();
    this._apiCommands = /* @__PURE__ */ new Map();
    __privateSet(this, _proxy, extHostRpc.getProxy(MainContext.MainThreadCommands));
    this._logService = logService;
    __privateSet(this, _extHostTelemetry, extHostTelemetry);
    __privateSet(this, _telemetry, extHostRpc.getProxy(MainContext.MainThreadTelemetry));
    this.converter = new CommandsConverter(this, (id) => {
      const candidate = this._apiCommands.get(id);
      return (candidate == null ? void 0 : candidate.result) === ApiCommandResult.Void ? candidate : void 0;
    }, logService);
    this._argumentProcessors = [
      {
        processArgument(a) {
          return revive(a);
        }
      },
      {
        processArgument(arg) {
          return cloneAndChange(arg, function(obj) {
            if (Range.isIRange(obj)) {
              return Range3.to(obj);
            }
            if (Position.isIPosition(obj)) {
              return Position3.to(obj);
            }
            if (Range.isIRange(obj.range) && URI.isUri(obj.uri)) {
              return location.to(obj);
            }
            if (obj instanceof VSBuffer) {
              return obj.buffer.buffer;
            }
            if (!Array.isArray(obj)) {
              return obj;
            }
          });
        }
      }
    ];
  }
  registerArgumentProcessor(processor) {
    this._argumentProcessors.push(processor);
  }
  registerApiCommand(apiCommand) {
    const registration = this.registerCommand(false, apiCommand.id, async (...apiArgs) => {
      const internalArgs = apiCommand.args.map((arg, i) => {
        if (!arg.validate(apiArgs[i])) {
          throw new Error(`Invalid argument '${arg.name}' when running '${apiCommand.id}', received: ${apiArgs[i]}`);
        }
        return arg.convert(apiArgs[i]);
      });
      const internalResult = await this.executeCommand(apiCommand.internalId, ...internalArgs);
      return apiCommand.result.convert(internalResult, apiArgs, this.converter);
    }, void 0, {
      description: apiCommand.description,
      args: apiCommand.args,
      returns: apiCommand.result.description
    });
    this._apiCommands.set(apiCommand.id, apiCommand);
    return new Disposable2(() => {
      registration.dispose();
      this._apiCommands.delete(apiCommand.id);
    });
  }
  registerCommand(global2, id, callback, thisArg, description, extension) {
    this._logService.trace("ExtHostCommands#registerCommand", id);
    if (!id.trim().length) {
      throw new Error("invalid id");
    }
    if (this._commands.has(id)) {
      throw new Error(`command '${id}' already exists`);
    }
    this._commands.set(id, { callback, thisArg, description, extension });
    if (global2) {
      __privateGet(this, _proxy).$registerCommand(id);
    }
    return new Disposable2(() => {
      if (this._commands.delete(id)) {
        if (global2) {
          __privateGet(this, _proxy).$unregisterCommand(id);
        }
      }
    });
  }
  executeCommand(id, ...args) {
    this._logService.trace("ExtHostCommands#executeCommand", id);
    return this._doExecuteCommand(id, args, true);
  }
  async _doExecuteCommand(id, args, retry) {
    if (this._commands.has(id)) {
      __privateGet(this, _proxy).$fireCommandActivationEvent(id);
      return this._executeContributedCommand(id, args, false);
    } else {
      let hasBuffers = false;
      const toArgs = cloneAndChange(args, function(value) {
        if (value instanceof Position2) {
          return Position3.from(value);
        } else if (value instanceof Range2) {
          return Range3.from(value);
        } else if (value instanceof Location) {
          return location.from(value);
        } else if (NotebookRange.isNotebookRange(value)) {
          return NotebookRange2.from(value);
        } else if (value instanceof ArrayBuffer) {
          hasBuffers = true;
          return VSBuffer.wrap(new Uint8Array(value));
        } else if (value instanceof Uint8Array) {
          hasBuffers = true;
          return VSBuffer.wrap(value);
        } else if (value instanceof VSBuffer) {
          hasBuffers = true;
          return value;
        }
        if (!Array.isArray(value)) {
          return value;
        }
      });
      try {
        const result = await __privateGet(this, _proxy).$executeCommand(id, hasBuffers ? new SerializableObjectWithBuffers(toArgs) : toArgs, retry);
        return revive(result);
      } catch (e) {
        if (e instanceof Error && e.message === "$executeCommand:retry") {
          return this._doExecuteCommand(id, args, false);
        } else {
          throw e;
        }
      }
    }
  }
  async _executeContributedCommand(id, args, annotateError) {
    var _a30, _b, _c;
    const command = this._commands.get(id);
    if (!command) {
      throw new Error("Unknown command");
    }
    const { callback, thisArg, description } = command;
    if (description) {
      for (let i = 0; i < description.args.length; i++) {
        try {
          validateConstraint(args[i], description.args[i].constraint);
        } catch (err) {
          throw new Error(`Running the contributed command: '${id}' failed. Illegal argument '${description.args[i].name}' - ${description.args[i].description}`);
        }
      }
    }
    const stopWatch = StopWatch.create();
    try {
      return await callback.apply(thisArg, args);
    } catch (err) {
      if (id === this.converter.delegatingCommandId) {
        const actual = this.converter.getActualCommand(...args);
        if (actual) {
          id = actual.command;
        }
      }
      this._logService.error(err, id, (_a30 = command.extension) == null ? void 0 : _a30.identifier);
      if (!annotateError) {
        throw err;
      }
      if ((_b = command.extension) == null ? void 0 : _b.identifier) {
        const reported = __privateGet(this, _extHostTelemetry).onExtensionError(command.extension.identifier, err);
        this._logService.trace("forwarded error to extension?", reported, (_c = command.extension) == null ? void 0 : _c.identifier);
      }
      throw new class CommandError extends Error {
        constructor() {
          var _a31, _b2;
          super(toErrorMessage(err));
          this.id = id;
          this.source = ((_a31 = command.extension) == null ? void 0 : _a31.displayName) ?? ((_b2 = command.extension) == null ? void 0 : _b2.name);
        }
      }();
    } finally {
      this._reportTelemetry(command, id, stopWatch.elapsed());
    }
  }
  _reportTelemetry(command, id, duration) {
    if (!command.extension) {
      return;
    }
    __privateGet(this, _telemetry).$publicLog2("Extension:ActionExecuted", {
      extensionId: command.extension.identifier.value,
      id: new TelemetryTrustedValue(id),
      duration
    });
  }
  $executeContributedCommand(id, ...args) {
    this._logService.trace("ExtHostCommands#$executeContributedCommand", id);
    const cmdHandler = this._commands.get(id);
    if (!cmdHandler) {
      return Promise.reject(new Error(`Contributed command '${id}' does not exist.`));
    } else {
      args = args.map(
        (arg) => this._argumentProcessors.reduce((r, p) => {
          var _a30;
          return p.processArgument(r, (_a30 = cmdHandler.extension) == null ? void 0 : _a30.identifier);
        }, arg)
      );
      return this._executeContributedCommand(id, args, true);
    }
  }
  getCommands(filterUnderscoreCommands = false) {
    this._logService.trace("ExtHostCommands#getCommands", filterUnderscoreCommands);
    return __privateGet(this, _proxy).$getCommands().then((result) => {
      if (filterUnderscoreCommands) {
        result = result.filter((command) => command[0] !== "_");
      }
      return result;
    });
  }
  $getContributedCommandHandlerDescriptions() {
    const result = /* @__PURE__ */ Object.create(null);
    for (const [id, command] of this._commands) {
      const { description } = command;
      if (description) {
        result[id] = description;
      }
    }
    return Promise.resolve(result);
  }
}, _proxy = new WeakMap(), _telemetry = new WeakMap(), _extHostTelemetry = new WeakMap(), _a2);
ExtHostCommands = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService),
  __param(2, IExtHostTelemetry)
], ExtHostCommands);
var IExtHostCommands = createDecorator("IExtHostCommands");
var CommandsConverter = class {
  constructor(_commands2, _lookupApiCommand, _logService) {
    this._commands = _commands2;
    this._lookupApiCommand = _lookupApiCommand;
    this._logService = _logService;
    this.delegatingCommandId = `__vsc${Date.now().toString(36)}`;
    this._cache = /* @__PURE__ */ new Map();
    this._cachIdPool = 0;
    this._commands.registerCommand(true, this.delegatingCommandId, this._executeConvertedCommand, this);
  }
  toInternal(command, disposables) {
    if (!command) {
      return void 0;
    }
    const result = {
      $ident: void 0,
      id: command.command,
      title: command.title,
      tooltip: command.tooltip
    };
    if (!command.command) {
      return result;
    }
    const apiCommand = this._lookupApiCommand(command.command);
    if (apiCommand) {
      result.id = apiCommand.internalId;
      result.arguments = apiCommand.args.map((arg, i) => arg.convert(command.arguments && command.arguments[i]));
    } else if (isNonEmptyArray(command.arguments)) {
      const id = `${command.command}/${++this._cachIdPool}`;
      this._cache.set(id, command);
      disposables.add(toDisposable(() => {
        this._cache.delete(id);
        this._logService.trace("CommandsConverter#DISPOSE", id);
      }));
      result.$ident = id;
      result.id = this.delegatingCommandId;
      result.arguments = [id];
      this._logService.trace("CommandsConverter#CREATE", command.command, id);
    }
    return result;
  }
  fromInternal(command) {
    if (typeof command.$ident === "string") {
      return this._cache.get(command.$ident);
    } else {
      return {
        command: command.id,
        title: command.title,
        arguments: command.arguments
      };
    }
  }
  getActualCommand(...args) {
    return this._cache.get(args[0]);
  }
  _executeConvertedCommand(...args) {
    const actualCmd = this.getActualCommand(...args);
    this._logService.trace("CommandsConverter#EXECUTE", args[0], actualCmd ? actualCmd.command : "MISSING");
    if (!actualCmd) {
      return Promise.reject(`Actual command not found, wanted to execute ${args[0]}`);
    }
    return this._commands.executeCommand(actualCmd.command, ...actualCmd.arguments || []);
  }
};
var _ApiCommandArgument = class _ApiCommandArgument {
  static Arr(element) {
    return new _ApiCommandArgument(
      `${element.name}_array`,
      `Array of ${element.name}, ${element.description}`,
      (v) => Array.isArray(v) && v.every((e) => element.validate(e)),
      (v) => v.map((e) => element.convert(e))
    );
  }
  constructor(name, description, validate, convert) {
    this.name = name;
    this.description = description;
    this.validate = validate;
    this.convert = convert;
  }
  optional() {
    return new _ApiCommandArgument(
      this.name,
      `(optional) ${this.description}`,
      (value) => value === void 0 || value === null || this.validate(value),
      (value) => value === void 0 ? void 0 : value === null ? null : this.convert(value)
    );
  }
  with(name, description) {
    return new _ApiCommandArgument(
      name ?? this.name,
      description ?? this.description,
      this.validate,
      this.convert
    );
  }
};
_ApiCommandArgument.Uri = new _ApiCommandArgument("uri", "Uri of a text document", (v) => URI.isUri(v), (v) => v);
_ApiCommandArgument.Position = new _ApiCommandArgument(
  "position",
  "A position in a text document",
  (v) => Position2.isPosition(v),
  Position3.from
);
_ApiCommandArgument.Range = new _ApiCommandArgument(
  "range",
  "A range in a text document",
  (v) => Range2.isRange(v),
  Range3.from
);
_ApiCommandArgument.Selection = new _ApiCommandArgument(
  "selection",
  "A selection in a text document",
  (v) => Selection.isSelection(v),
  Selection3.from
);
_ApiCommandArgument.Number = new _ApiCommandArgument("number", "", (v) => typeof v === "number", (v) => v);
_ApiCommandArgument.String = new _ApiCommandArgument("string", "", (v) => typeof v === "string", (v) => v);
_ApiCommandArgument.StringArray = _ApiCommandArgument.Arr(_ApiCommandArgument.String);
_ApiCommandArgument.CallHierarchyItem = new _ApiCommandArgument(
  "item",
  "A call hierarchy item",
  (v) => v instanceof CallHierarchyItem,
  CallHierarchyItem2.from
);
_ApiCommandArgument.TypeHierarchyItem = new _ApiCommandArgument(
  "item",
  "A type hierarchy item",
  (v) => v instanceof TypeHierarchyItem,
  TypeHierarchyItem2.from
);
_ApiCommandArgument.TestItem = new _ApiCommandArgument(
  "testItem",
  "A VS Code TestItem",
  (v) => v instanceof TestItemImpl,
  TestItem.from
);
var ApiCommandArgument = _ApiCommandArgument;
var _ApiCommandResult = class _ApiCommandResult {
  constructor(description, convert) {
    this.description = description;
    this.convert = convert;
  }
};
_ApiCommandResult.Void = new _ApiCommandResult("no result", (v) => v);
var ApiCommandResult = _ApiCommandResult;
var ApiCommand = class {
  constructor(id, internalId, description, args, result) {
    this.id = id;
    this.internalId = internalId;
    this.description = description;
    this.args = args;
    this.result = result;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTerminalService.js
var IExtHostTerminalService = createDecorator("IExtHostTerminalService");
var ExtHostTerminal = class {
  constructor(_proxy10, _id, _creationOptions, _name) {
    this._proxy = _proxy10;
    this._id = _id;
    this._creationOptions = _creationOptions;
    this._name = _name;
    this._disposed = false;
    this._state = { isInteractedWith: false };
    this.isOpen = false;
    this._creationOptions = Object.freeze(this._creationOptions);
    this._pidPromise = new Promise((c) => this._pidPromiseComplete = c);
    const that = this;
    this.value = {
      get name() {
        return that._name || "";
      },
      get processId() {
        return that._pidPromise;
      },
      get creationOptions() {
        return that._creationOptions;
      },
      get exitStatus() {
        return that._exitStatus;
      },
      get state() {
        return that._state;
      },
      get selection() {
        return that._selection;
      },
      sendText(text, addNewLine = true) {
        that._checkDisposed();
        that._proxy.$sendText(that._id, text, addNewLine);
      },
      show(preserveFocus) {
        that._checkDisposed();
        that._proxy.$show(that._id, preserveFocus);
      },
      hide() {
        that._checkDisposed();
        that._proxy.$hide(that._id);
      },
      dispose() {
        if (!that._disposed) {
          that._disposed = true;
          that._proxy.$dispose(that._id);
        }
      },
      get dimensions() {
        if (that._cols === void 0 || that._rows === void 0) {
          return void 0;
        }
        return {
          columns: that._cols,
          rows: that._rows
        };
      }
    };
  }
  async create(options, internalOptions) {
    if (typeof this._id !== "string") {
      throw new Error("Terminal has already been created");
    }
    await this._proxy.$createTerminal(this._id, {
      name: options.name,
      shellPath: options.shellPath ?? void 0,
      shellArgs: options.shellArgs ?? void 0,
      cwd: options.cwd ?? void 0,
      env: options.env ?? void 0,
      icon: asTerminalIcon(options.iconPath) ?? void 0,
      color: ThemeColor.isThemeColor(options.color) ? options.color.id : void 0,
      initialText: options.message ?? void 0,
      strictEnv: options.strictEnv ?? void 0,
      hideFromUser: options.hideFromUser ?? void 0,
      isFeatureTerminal: (internalOptions == null ? void 0 : internalOptions.isFeatureTerminal) ?? void 0,
      isExtensionOwnedTerminal: true,
      useShellEnvironment: (internalOptions == null ? void 0 : internalOptions.useShellEnvironment) ?? void 0,
      location: (internalOptions == null ? void 0 : internalOptions.location) || this._serializeParentTerminal(options.location, internalOptions == null ? void 0 : internalOptions.resolvedExtHostIdentifier),
      isTransient: options.isTransient ?? void 0
    });
  }
  async createExtensionTerminal(location2, parentTerminal, iconPath, color2) {
    if (typeof this._id !== "string") {
      throw new Error("Terminal has already been created");
    }
    await this._proxy.$createTerminal(this._id, {
      name: this._name,
      isExtensionCustomPtyTerminal: true,
      icon: iconPath,
      color: ThemeColor.isThemeColor(color2) ? color2.id : void 0,
      location: this._serializeParentTerminal(location2, parentTerminal),
      isTransient: true
    });
    if (typeof this._id === "string") {
      throw new Error("Terminal creation failed");
    }
    return this._id;
  }
  _serializeParentTerminal(location2, parentTerminal) {
    if (typeof location2 === "object") {
      if ("parentTerminal" in location2 && location2.parentTerminal && parentTerminal) {
        return { parentTerminal };
      }
      if ("viewColumn" in location2) {
        return { viewColumn: ViewColumn2.from(location2.viewColumn), preserveFocus: location2.preserveFocus };
      }
      return void 0;
    }
    return location2;
  }
  _checkDisposed() {
    if (this._disposed) {
      throw new Error("Terminal has already been disposed");
    }
  }
  set name(name) {
    this._name = name;
  }
  setExitStatus(code, reason) {
    this._exitStatus = Object.freeze({ code, reason });
  }
  setDimensions(cols, rows) {
    if (cols === this._cols && rows === this._rows) {
      return false;
    }
    if (cols === 0 || rows === 0) {
      return false;
    }
    this._cols = cols;
    this._rows = rows;
    return true;
  }
  setInteractedWith() {
    if (!this._state.isInteractedWith) {
      this._state = { isInteractedWith: true };
      return true;
    }
    return false;
  }
  setSelection(selection) {
    this._selection = selection;
  }
  _setProcessId(processId) {
    if (this._pidPromiseComplete) {
      this._pidPromiseComplete(processId);
      this._pidPromiseComplete = void 0;
    } else {
      this._pidPromise.then((pid) => {
        if (pid !== processId) {
          this._pidPromise = Promise.resolve(processId);
        }
      });
    }
  }
};
var ExtHostPseudoterminal = class {
  get onProcessReady() {
    return this._onProcessReady.event;
  }
  constructor(_pty) {
    this._pty = _pty;
    this.id = 0;
    this.shouldPersist = false;
    this._onProcessData = new Emitter();
    this.onProcessData = this._onProcessData.event;
    this._onProcessReady = new Emitter();
    this._onDidChangeProperty = new Emitter();
    this.onDidChangeProperty = this._onDidChangeProperty.event;
    this._onProcessExit = new Emitter();
    this.onProcessExit = this._onProcessExit.event;
  }
  refreshProperty(property) {
    throw new Error(`refreshProperty is not suppported in extension owned terminals. property: ${property}`);
  }
  updateProperty(property, value) {
    throw new Error(`updateProperty is not suppported in extension owned terminals. property: ${property}, value: ${value}`);
  }
  async start() {
    return void 0;
  }
  shutdown() {
    this._pty.close();
  }
  input(data) {
    var _a30, _b;
    (_b = (_a30 = this._pty).handleInput) == null ? void 0 : _b.call(_a30, data);
  }
  resize(cols, rows) {
    var _a30, _b;
    (_b = (_a30 = this._pty).setDimensions) == null ? void 0 : _b.call(_a30, { columns: cols, rows });
  }
  clearBuffer() {
  }
  async processBinary(data) {
  }
  acknowledgeDataEvent(charCount) {
  }
  async setUnicodeVersion(version) {
  }
  getInitialCwd() {
    return Promise.resolve("");
  }
  getCwd() {
    return Promise.resolve("");
  }
  startSendingEvents(initialDimensions) {
    var _a30, _b, _c, _d, _e, _f, _g, _h;
    this._pty.onDidWrite((e) => this._onProcessData.fire(e));
    (_b = (_a30 = this._pty).onDidClose) == null ? void 0 : _b.call(_a30, (e = void 0) => {
      this._onProcessExit.fire(e === void 0 ? void 0 : e);
    });
    (_d = (_c = this._pty).onDidOverrideDimensions) == null ? void 0 : _d.call(_c, (e) => {
      if (e) {
        this._onDidChangeProperty.fire({ type: "overrideDimensions", value: { cols: e.columns, rows: e.rows } });
      }
    });
    (_f = (_e = this._pty).onDidChangeName) == null ? void 0 : _f.call(_e, (title) => {
      this._onDidChangeProperty.fire({ type: "title", value: title });
    });
    this._pty.open(initialDimensions ? initialDimensions : void 0);
    if (initialDimensions) {
      (_h = (_g = this._pty).setDimensions) == null ? void 0 : _h.call(_g, initialDimensions);
    }
    this._onProcessReady.fire({ pid: -1, cwd: "", windowsPty: void 0 });
  }
};
var nextLinkId = 1;
var BaseExtHostTerminalService = class BaseExtHostTerminalService2 extends Disposable {
  get activeTerminal() {
    var _a30;
    return (_a30 = this._activeTerminal) == null ? void 0 : _a30.value;
  }
  get terminals() {
    return this._terminals.map((term) => term.value);
  }
  constructor(supportsProcesses, _extHostCommands, extHostRpc) {
    super();
    this._extHostCommands = _extHostCommands;
    this._terminals = [];
    this._terminalProcesses = /* @__PURE__ */ new Map();
    this._terminalProcessDisposables = {};
    this._extensionTerminalAwaitingStart = {};
    this._getTerminalPromises = {};
    this._environmentVariableCollections = /* @__PURE__ */ new Map();
    this._lastQuickFixCommands = this._register(new MutableDisposable());
    this._linkProviders = /* @__PURE__ */ new Set();
    this._profileProviders = /* @__PURE__ */ new Map();
    this._quickFixProviders = /* @__PURE__ */ new Map();
    this._terminalLinkCache = /* @__PURE__ */ new Map();
    this._terminalLinkCancellationSource = /* @__PURE__ */ new Map();
    this._onDidCloseTerminal = new Emitter();
    this.onDidCloseTerminal = this._onDidCloseTerminal.event;
    this._onDidOpenTerminal = new Emitter();
    this.onDidOpenTerminal = this._onDidOpenTerminal.event;
    this._onDidChangeActiveTerminal = new Emitter();
    this.onDidChangeActiveTerminal = this._onDidChangeActiveTerminal.event;
    this._onDidChangeTerminalDimensions = new Emitter();
    this.onDidChangeTerminalDimensions = this._onDidChangeTerminalDimensions.event;
    this._onDidChangeTerminalState = new Emitter();
    this.onDidChangeTerminalState = this._onDidChangeTerminalState.event;
    this._onDidChangeShell = new Emitter();
    this.onDidChangeShell = this._onDidChangeShell.event;
    this._onDidWriteTerminalData = new Emitter({
      onWillAddFirstListener: () => this._proxy.$startSendingDataEvents(),
      onDidRemoveLastListener: () => this._proxy.$stopSendingDataEvents()
    });
    this.onDidWriteTerminalData = this._onDidWriteTerminalData.event;
    this._onDidExecuteCommand = new Emitter({
      onWillAddFirstListener: () => this._proxy.$startSendingCommandEvents(),
      onDidRemoveLastListener: () => this._proxy.$stopSendingCommandEvents()
    });
    this.onDidExecuteTerminalCommand = this._onDidExecuteCommand.event;
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadTerminalService);
    this._bufferer = new TerminalDataBufferer(this._proxy.$sendProcessData);
    this._proxy.$registerProcessSupport(supportsProcesses);
    this._register({
      dispose: () => {
        for (const [_, terminalProcess] of this._terminalProcesses) {
          terminalProcess.shutdown(true);
        }
      }
    });
  }
  getDefaultShell(useAutomationShell) {
    const profile = useAutomationShell ? this._defaultAutomationProfile : this._defaultProfile;
    return (profile == null ? void 0 : profile.path) || "";
  }
  getDefaultShellArgs(useAutomationShell) {
    const profile = useAutomationShell ? this._defaultAutomationProfile : this._defaultProfile;
    return (profile == null ? void 0 : profile.args) || [];
  }
  createExtensionTerminal(options, internalOptions) {
    const terminal = new ExtHostTerminal(this._proxy, generateUuid(), options, options.name);
    const p = new ExtHostPseudoterminal(options.pty);
    terminal.createExtensionTerminal(options.location, this._serializeParentTerminal(options, internalOptions).resolvedExtHostIdentifier, asTerminalIcon(options.iconPath), asTerminalColor(options.color)).then((id) => {
      const disposable = this._setupExtHostProcessListeners(id, p);
      this._terminalProcessDisposables[id] = disposable;
    });
    this._terminals.push(terminal);
    return terminal.value;
  }
  _serializeParentTerminal(options, internalOptions) {
    internalOptions = internalOptions ? internalOptions : {};
    if (options.location && typeof options.location === "object" && "parentTerminal" in options.location) {
      const parentTerminal = options.location.parentTerminal;
      if (parentTerminal) {
        const parentExtHostTerminal = this._terminals.find((t) => t.value === parentTerminal);
        if (parentExtHostTerminal) {
          internalOptions.resolvedExtHostIdentifier = parentExtHostTerminal._id;
        }
      }
    } else if (options.location && typeof options.location !== "object") {
      internalOptions.location = options.location;
    } else if (internalOptions.location && typeof internalOptions.location === "object" && "splitActiveTerminal" in internalOptions.location) {
      internalOptions.location = { splitActiveTerminal: true };
    }
    return internalOptions;
  }
  attachPtyToTerminal(id, pty) {
    const terminal = this._getTerminalById(id);
    if (!terminal) {
      throw new Error(`Cannot resolve terminal with id ${id} for virtual process`);
    }
    const p = new ExtHostPseudoterminal(pty);
    const disposable = this._setupExtHostProcessListeners(id, p);
    this._terminalProcessDisposables[id] = disposable;
  }
  async $acceptActiveTerminalChanged(id) {
    const original2 = this._activeTerminal;
    if (id === null) {
      this._activeTerminal = void 0;
      if (original2 !== this._activeTerminal) {
        this._onDidChangeActiveTerminal.fire(this._activeTerminal);
      }
      return;
    }
    const terminal = this._getTerminalById(id);
    if (terminal) {
      this._activeTerminal = terminal;
      if (original2 !== this._activeTerminal) {
        this._onDidChangeActiveTerminal.fire(this._activeTerminal.value);
      }
    }
  }
  async $acceptTerminalProcessData(id, data) {
    const terminal = this._getTerminalById(id);
    if (terminal) {
      this._onDidWriteTerminalData.fire({ terminal: terminal.value, data });
    }
  }
  async $acceptTerminalDimensions(id, cols, rows) {
    const terminal = this._getTerminalById(id);
    if (terminal) {
      if (terminal.setDimensions(cols, rows)) {
        this._onDidChangeTerminalDimensions.fire({
          terminal: terminal.value,
          dimensions: terminal.value.dimensions
        });
      }
    }
  }
  async $acceptDidExecuteCommand(id, command) {
    const terminal = this._getTerminalById(id);
    if (terminal) {
      this._onDidExecuteCommand.fire({ terminal: terminal.value, ...command });
    }
  }
  async $acceptTerminalMaximumDimensions(id, cols, rows) {
    var _a30;
    (_a30 = this._terminalProcesses.get(id)) == null ? void 0 : _a30.resize(cols, rows);
  }
  async $acceptTerminalTitleChange(id, name) {
    const terminal = this._getTerminalById(id);
    if (terminal) {
      terminal.name = name;
    }
  }
  async $acceptTerminalClosed(id, exitCode, exitReason) {
    const index = this._getTerminalObjectIndexById(this._terminals, id);
    if (index !== null) {
      const terminal = this._terminals.splice(index, 1)[0];
      terminal.setExitStatus(exitCode, exitReason);
      this._onDidCloseTerminal.fire(terminal.value);
    }
  }
  $acceptTerminalOpened(id, extHostTerminalId, name, shellLaunchConfigDto) {
    if (extHostTerminalId) {
      const index = this._getTerminalObjectIndexById(this._terminals, extHostTerminalId);
      if (index !== null) {
        this._terminals[index]._id = id;
        this._onDidOpenTerminal.fire(this.terminals[index]);
        this._terminals[index].isOpen = true;
        return;
      }
    }
    const creationOptions = {
      name: shellLaunchConfigDto.name,
      shellPath: shellLaunchConfigDto.executable,
      shellArgs: shellLaunchConfigDto.args,
      cwd: typeof shellLaunchConfigDto.cwd === "string" ? shellLaunchConfigDto.cwd : URI.revive(shellLaunchConfigDto.cwd),
      env: shellLaunchConfigDto.env,
      hideFromUser: shellLaunchConfigDto.hideFromUser
    };
    const terminal = new ExtHostTerminal(this._proxy, id, creationOptions, name);
    this._terminals.push(terminal);
    this._onDidOpenTerminal.fire(terminal.value);
    terminal.isOpen = true;
  }
  async $acceptTerminalProcessId(id, processId) {
    const terminal = this._getTerminalById(id);
    terminal == null ? void 0 : terminal._setProcessId(processId);
  }
  async $startExtensionTerminal(id, initialDimensions) {
    const terminal = this._getTerminalById(id);
    if (!terminal) {
      return { message: localize(
        "launchFail.idMissingOnExtHost",
        "Could not find the terminal with id {0} on the extension host",
        id
      ) };
    }
    if (!terminal.isOpen) {
      await new Promise((r) => {
        const listener = this.onDidOpenTerminal(async (e) => {
          if (e === terminal.value) {
            listener.dispose();
            r();
          }
        });
      });
    }
    const terminalProcess = this._terminalProcesses.get(id);
    if (terminalProcess) {
      terminalProcess.startSendingEvents(initialDimensions);
    } else {
      this._extensionTerminalAwaitingStart[id] = { initialDimensions };
    }
    return void 0;
  }
  _setupExtHostProcessListeners(id, p) {
    const disposables = new DisposableStore();
    disposables.add(p.onProcessReady((e) => this._proxy.$sendProcessReady(id, e.pid, e.cwd, e.windowsPty)));
    disposables.add(p.onDidChangeProperty((property) => this._proxy.$sendProcessProperty(id, property)));
    this._bufferer.startBuffering(id, p.onProcessData);
    disposables.add(p.onProcessExit((exitCode) => this._onProcessExit(id, exitCode)));
    this._terminalProcesses.set(id, p);
    const awaitingStart = this._extensionTerminalAwaitingStart[id];
    if (awaitingStart && p instanceof ExtHostPseudoterminal) {
      p.startSendingEvents(awaitingStart.initialDimensions);
      delete this._extensionTerminalAwaitingStart[id];
    }
    return disposables;
  }
  $acceptProcessAckDataEvent(id, charCount) {
    var _a30;
    (_a30 = this._terminalProcesses.get(id)) == null ? void 0 : _a30.acknowledgeDataEvent(charCount);
  }
  $acceptProcessInput(id, data) {
    var _a30;
    (_a30 = this._terminalProcesses.get(id)) == null ? void 0 : _a30.input(data);
  }
  $acceptTerminalInteraction(id) {
    const terminal = this._getTerminalById(id);
    if (terminal == null ? void 0 : terminal.setInteractedWith()) {
      this._onDidChangeTerminalState.fire(terminal.value);
    }
  }
  $acceptTerminalSelection(id, selection) {
    var _a30;
    (_a30 = this._getTerminalById(id)) == null ? void 0 : _a30.setSelection(selection);
  }
  $acceptProcessResize(id, cols, rows) {
    var _a30;
    try {
      (_a30 = this._terminalProcesses.get(id)) == null ? void 0 : _a30.resize(cols, rows);
    } catch (error) {
      if (error.code !== "EPIPE" && error.code !== "ERR_IPC_CHANNEL_CLOSED") {
        throw error;
      }
    }
  }
  $acceptProcessShutdown(id, immediate) {
    var _a30;
    (_a30 = this._terminalProcesses.get(id)) == null ? void 0 : _a30.shutdown(immediate);
  }
  $acceptProcessRequestInitialCwd(id) {
    var _a30;
    (_a30 = this._terminalProcesses.get(id)) == null ? void 0 : _a30.getInitialCwd().then((initialCwd) => this._proxy.$sendProcessProperty(id, { type: "initialCwd", value: initialCwd }));
  }
  $acceptProcessRequestCwd(id) {
    var _a30;
    (_a30 = this._terminalProcesses.get(id)) == null ? void 0 : _a30.getCwd().then((cwd2) => this._proxy.$sendProcessProperty(id, { type: "cwd", value: cwd2 }));
  }
  $acceptProcessRequestLatency(id) {
    return Promise.resolve(id);
  }
  registerLinkProvider(provider) {
    this._linkProviders.add(provider);
    if (this._linkProviders.size === 1) {
      this._proxy.$startLinkProvider();
    }
    return new Disposable2(() => {
      this._linkProviders.delete(provider);
      if (this._linkProviders.size === 0) {
        this._proxy.$stopLinkProvider();
      }
    });
  }
  registerProfileProvider(extension, id, provider) {
    if (this._profileProviders.has(id)) {
      throw new Error(`Terminal profile provider "${id}" already registered`);
    }
    this._profileProviders.set(id, provider);
    this._proxy.$registerProfileProvider(id, extension.identifier.value);
    return new Disposable2(() => {
      this._profileProviders.delete(id);
      this._proxy.$unregisterProfileProvider(id);
    });
  }
  registerTerminalQuickFixProvider(id, extensionId, provider) {
    if (this._quickFixProviders.has(id)) {
      throw new Error(`Terminal quick fix provider "${id}" is already registered`);
    }
    this._quickFixProviders.set(id, provider);
    this._proxy.$registerQuickFixProvider(id, extensionId);
    return new Disposable2(() => {
      this._quickFixProviders.delete(id);
      this._proxy.$unregisterQuickFixProvider(id);
    });
  }
  async $provideTerminalQuickFixes(id, matchResult) {
    const token = new CancellationTokenSource().token;
    if (token.isCancellationRequested) {
      return;
    }
    const provider = this._quickFixProviders.get(id);
    if (!provider) {
      return;
    }
    const quickFixes = await provider.provideTerminalQuickFixes(matchResult, token);
    if (quickFixes === null || Array.isArray(quickFixes) && quickFixes.length === 0) {
      return void 0;
    }
    const store = new DisposableStore();
    this._lastQuickFixCommands.value = store;
    if (!Array.isArray(quickFixes)) {
      return quickFixes ? TerminalQuickFix.from(quickFixes, this._extHostCommands.converter, store) : void 0;
    }
    const result = [];
    for (const fix of quickFixes) {
      const converted = TerminalQuickFix.from(fix, this._extHostCommands.converter, store);
      if (converted) {
        result.push(converted);
      }
    }
    return result;
  }
  async $createContributedProfileTerminal(id, options) {
    var _a30;
    const token = new CancellationTokenSource().token;
    let profile = await ((_a30 = this._profileProviders.get(id)) == null ? void 0 : _a30.provideTerminalProfile(token));
    if (token.isCancellationRequested) {
      return;
    }
    if (profile && !("options" in profile)) {
      profile = { options: profile };
    }
    if (!profile || !("options" in profile)) {
      throw new Error(`No terminal profile options provided for id "${id}"`);
    }
    if ("pty" in profile.options) {
      this.createExtensionTerminal(profile.options, options);
      return;
    }
    this.createTerminalFromOptions(profile.options, options);
  }
  async $provideLinks(terminalId, line) {
    const terminal = this._getTerminalById(terminalId);
    if (!terminal) {
      return [];
    }
    this._terminalLinkCache.delete(terminalId);
    const oldToken = this._terminalLinkCancellationSource.get(terminalId);
    oldToken == null ? void 0 : oldToken.dispose(true);
    const cancellationSource = new CancellationTokenSource();
    this._terminalLinkCancellationSource.set(terminalId, cancellationSource);
    const result = [];
    const context = { terminal: terminal.value, line };
    const promises = [];
    for (const provider of this._linkProviders) {
      promises.push(Promises.withAsyncBody(async (r) => {
        cancellationSource.token.onCancellationRequested(() => r({ provider, links: [] }));
        const links = await provider.provideTerminalLinks(context, cancellationSource.token) || [];
        if (!cancellationSource.token.isCancellationRequested) {
          r({ provider, links });
        }
      }));
    }
    const provideResults = await Promise.all(promises);
    if (cancellationSource.token.isCancellationRequested) {
      return [];
    }
    const cacheLinkMap = /* @__PURE__ */ new Map();
    for (const provideResult of provideResults) {
      if (provideResult && provideResult.links.length > 0) {
        result.push(...provideResult.links.map((providerLink) => {
          const link = {
            id: nextLinkId++,
            startIndex: providerLink.startIndex,
            length: providerLink.length,
            label: providerLink.tooltip
          };
          cacheLinkMap.set(link.id, {
            provider: provideResult.provider,
            link: providerLink
          });
          return link;
        }));
      }
    }
    this._terminalLinkCache.set(terminalId, cacheLinkMap);
    return result;
  }
  $activateLink(terminalId, linkId) {
    var _a30;
    const cachedLink = (_a30 = this._terminalLinkCache.get(terminalId)) == null ? void 0 : _a30.get(linkId);
    if (!cachedLink) {
      return;
    }
    cachedLink.provider.handleTerminalLink(cachedLink.link);
  }
  _onProcessExit(id, exitCode) {
    this._bufferer.stopBuffering(id);
    this._terminalProcesses.delete(id);
    delete this._extensionTerminalAwaitingStart[id];
    const processDiposable = this._terminalProcessDisposables[id];
    if (processDiposable) {
      processDiposable.dispose();
      delete this._terminalProcessDisposables[id];
    }
    this._proxy.$sendProcessExit(id, exitCode);
  }
  _getTerminalById(id) {
    return this._getTerminalObjectById(this._terminals, id);
  }
  _getTerminalObjectById(array, id) {
    const index = this._getTerminalObjectIndexById(array, id);
    return index !== null ? array[index] : null;
  }
  _getTerminalObjectIndexById(array, id) {
    const index = array.findIndex((item) => {
      return item._id === id;
    });
    if (index === -1) {
      return null;
    }
    return index;
  }
  getEnvironmentVariableCollection(extension) {
    let collection = this._environmentVariableCollections.get(extension.identifier.value);
    if (!collection) {
      collection = new UnifiedEnvironmentVariableCollection();
      this._setEnvironmentVariableCollection(extension.identifier.value, collection);
    }
    return collection.getScopedEnvironmentVariableCollection(void 0);
  }
  _syncEnvironmentVariableCollection(extensionIdentifier, collection) {
    const serialized = serializeEnvironmentVariableCollection(collection.map);
    const serializedDescription = serializeEnvironmentDescriptionMap(collection.descriptionMap);
    this._proxy.$setEnvironmentVariableCollection(extensionIdentifier, collection.persistent, serialized.length === 0 ? void 0 : serialized, serializedDescription);
  }
  $initEnvironmentVariableCollections(collections) {
    collections.forEach((entry) => {
      const extensionIdentifier = entry[0];
      const collection = new UnifiedEnvironmentVariableCollection(entry[1]);
      this._setEnvironmentVariableCollection(extensionIdentifier, collection);
    });
  }
  $acceptDefaultProfile(profile, automationProfile) {
    const oldProfile = this._defaultProfile;
    this._defaultProfile = profile;
    this._defaultAutomationProfile = automationProfile;
    if ((oldProfile == null ? void 0 : oldProfile.path) !== profile.path) {
      this._onDidChangeShell.fire(profile.path);
    }
  }
  _setEnvironmentVariableCollection(extensionIdentifier, collection) {
    this._environmentVariableCollections.set(extensionIdentifier, collection);
    collection.onDidChangeCollection(() => {
      this._syncEnvironmentVariableCollection(extensionIdentifier, collection);
    });
  }
};
BaseExtHostTerminalService = __decorate([
  __param(1, IExtHostCommands),
  __param(2, IExtHostRpcService)
], BaseExtHostTerminalService);
var UnifiedEnvironmentVariableCollection = class {
  get persistent() {
    return this._persistent;
  }
  set persistent(value) {
    this._persistent = value;
    this._onDidChangeCollection.fire();
  }
  get onDidChangeCollection() {
    return this._onDidChangeCollection && this._onDidChangeCollection.event;
  }
  constructor(serialized) {
    this.map = /* @__PURE__ */ new Map();
    this.scopedCollections = /* @__PURE__ */ new Map();
    this.descriptionMap = /* @__PURE__ */ new Map();
    this._persistent = true;
    this._onDidChangeCollection = new Emitter();
    this.map = new Map(serialized);
  }
  getScopedEnvironmentVariableCollection(scope) {
    const scopedCollectionKey = this.getScopeKey(scope);
    let scopedCollection = this.scopedCollections.get(scopedCollectionKey);
    if (!scopedCollection) {
      scopedCollection = new ScopedEnvironmentVariableCollection(this, scope);
      this.scopedCollections.set(scopedCollectionKey, scopedCollection);
      scopedCollection.onDidChangeCollection(() => this._onDidChangeCollection.fire());
    }
    return scopedCollection;
  }
  replace(variable, value, options, scope) {
    this._setIfDiffers(variable, { value, type: EnvironmentVariableMutatorType.Replace, options: options ?? { applyAtProcessCreation: true }, scope });
  }
  append(variable, value, options, scope) {
    this._setIfDiffers(variable, { value, type: EnvironmentVariableMutatorType.Append, options: options ?? { applyAtProcessCreation: true }, scope });
  }
  prepend(variable, value, options, scope) {
    this._setIfDiffers(variable, { value, type: EnvironmentVariableMutatorType.Prepend, options: options ?? { applyAtProcessCreation: true }, scope });
  }
  _setIfDiffers(variable, mutator) {
    var _a30, _b, _c, _d, _e, _f;
    if (mutator.options && mutator.options.applyAtProcessCreation === false && !mutator.options.applyAtShellIntegration) {
      throw new Error("EnvironmentVariableMutatorOptions must apply at either process creation or shell integration");
    }
    const key = this.getKey(variable, mutator.scope);
    const current = this.map.get(key);
    const newOptions = mutator.options ? {
      applyAtProcessCreation: mutator.options.applyAtProcessCreation ?? false,
      applyAtShellIntegration: mutator.options.applyAtShellIntegration ?? false
    } : {
      applyAtProcessCreation: true
    };
    if (!current || current.value !== mutator.value || current.type !== mutator.type || ((_a30 = current.options) == null ? void 0 : _a30.applyAtProcessCreation) !== newOptions.applyAtProcessCreation || ((_b = current.options) == null ? void 0 : _b.applyAtShellIntegration) !== newOptions.applyAtShellIntegration || ((_d = (_c = current.scope) == null ? void 0 : _c.workspaceFolder) == null ? void 0 : _d.index) !== ((_f = (_e = mutator.scope) == null ? void 0 : _e.workspaceFolder) == null ? void 0 : _f.index)) {
      const key2 = this.getKey(variable, mutator.scope);
      const value = {
        variable,
        ...mutator,
        options: newOptions
      };
      this.map.set(key2, value);
      this._onDidChangeCollection.fire();
    }
  }
  get(variable, scope) {
    const key = this.getKey(variable, scope);
    const value = this.map.get(key);
    return value ? convertMutator(value) : void 0;
  }
  getKey(variable, scope) {
    const scopeKey = this.getScopeKey(scope);
    return scopeKey.length ? `${variable}:::${scopeKey}` : variable;
  }
  getScopeKey(scope) {
    return this.getWorkspaceKey(scope == null ? void 0 : scope.workspaceFolder) ?? "";
  }
  getWorkspaceKey(workspaceFolder) {
    return workspaceFolder ? workspaceFolder.uri.toString() : void 0;
  }
  getVariableMap(scope) {
    const map = /* @__PURE__ */ new Map();
    for (const [_, value] of this.map) {
      if (this.getScopeKey(value.scope) === this.getScopeKey(scope)) {
        map.set(value.variable, convertMutator(value));
      }
    }
    return map;
  }
  delete(variable, scope) {
    const key = this.getKey(variable, scope);
    this.map.delete(key);
    this._onDidChangeCollection.fire();
  }
  clear(scope) {
    var _a30, _b;
    if (scope == null ? void 0 : scope.workspaceFolder) {
      for (const [key, mutator] of this.map) {
        if (((_b = (_a30 = mutator.scope) == null ? void 0 : _a30.workspaceFolder) == null ? void 0 : _b.index) === scope.workspaceFolder.index) {
          this.map.delete(key);
        }
      }
      this.clearDescription(scope);
    } else {
      this.map.clear();
      this.descriptionMap.clear();
    }
    this._onDidChangeCollection.fire();
  }
  setDescription(description, scope) {
    const key = this.getScopeKey(scope);
    const current = this.descriptionMap.get(key);
    if (!current || current.description !== description) {
      let descriptionStr;
      if (typeof description === "string") {
        descriptionStr = description;
      } else {
        descriptionStr = description == null ? void 0 : description.value.split("\n\n")[0];
      }
      const value = { description: descriptionStr, scope };
      this.descriptionMap.set(key, value);
      this._onDidChangeCollection.fire();
    }
  }
  getDescription(scope) {
    var _a30;
    const key = this.getScopeKey(scope);
    return (_a30 = this.descriptionMap.get(key)) == null ? void 0 : _a30.description;
  }
  clearDescription(scope) {
    const key = this.getScopeKey(scope);
    this.descriptionMap.delete(key);
  }
};
var ScopedEnvironmentVariableCollection = class {
  get persistent() {
    return this.collection.persistent;
  }
  set persistent(value) {
    this.collection.persistent = value;
  }
  get onDidChangeCollection() {
    return this._onDidChangeCollection && this._onDidChangeCollection.event;
  }
  constructor(collection, scope) {
    this.collection = collection;
    this.scope = scope;
    this._onDidChangeCollection = new Emitter();
  }
  getScoped(scope) {
    return this.collection.getScopedEnvironmentVariableCollection(scope);
  }
  replace(variable, value, options) {
    this.collection.replace(variable, value, options, this.scope);
  }
  append(variable, value, options) {
    this.collection.append(variable, value, options, this.scope);
  }
  prepend(variable, value, options) {
    this.collection.prepend(variable, value, options, this.scope);
  }
  get(variable) {
    return this.collection.get(variable, this.scope);
  }
  forEach(callback, thisArg) {
    this.collection.getVariableMap(this.scope).forEach((value, variable) => callback.call(thisArg, variable, value, this), this.scope);
  }
  [Symbol.iterator]() {
    return this.collection.getVariableMap(this.scope).entries();
  }
  delete(variable) {
    this.collection.delete(variable, this.scope);
    this._onDidChangeCollection.fire(void 0);
  }
  clear() {
    this.collection.clear(this.scope);
  }
  set description(description) {
    this.collection.setDescription(description, this.scope);
  }
  get description() {
    return this.collection.getDescription(this.scope);
  }
};
var WorkerExtHostTerminalService = class WorkerExtHostTerminalService2 extends BaseExtHostTerminalService {
  constructor(extHostCommands, extHostRpc) {
    super(false, extHostCommands, extHostRpc);
  }
  createTerminal(name, shellPath, shellArgs) {
    throw new NotSupportedError();
  }
  createTerminalFromOptions(options, internalOptions) {
    throw new NotSupportedError();
  }
};
WorkerExtHostTerminalService = __decorate([
  __param(0, IExtHostCommands),
  __param(1, IExtHostRpcService)
], WorkerExtHostTerminalService);
function asTerminalIcon(iconPath) {
  if (!iconPath || typeof iconPath === "string") {
    return void 0;
  }
  if (!("id" in iconPath)) {
    return iconPath;
  }
  return {
    id: iconPath.id,
    color: iconPath.color
  };
}
function asTerminalColor(color2) {
  return ThemeColor.isThemeColor(color2) ? color2 : void 0;
}
function convertMutator(mutator) {
  const newMutator = { ...mutator };
  delete newMutator.scope;
  newMutator.options = newMutator.options ?? void 0;
  delete newMutator.variable;
  return newMutator;
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionService.js
init_event();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSecretState.js
init_extHost_protocol();
init_event();
init_instantiation();
var ExtHostSecretState = class {
  constructor(mainContext) {
    this._onDidChangePassword = new Emitter();
    this.onDidChangePassword = this._onDidChangePassword.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadSecretState);
  }
  async $onDidChangePassword(e) {
    this._onDidChangePassword.fire(e);
  }
  get(extensionId, key) {
    return this._proxy.$getPassword(extensionId, key);
  }
  store(extensionId, key, value) {
    return this._proxy.$setPassword(extensionId, key, value);
  }
  delete(extensionId, key) {
    return this._proxy.$deletePassword(extensionId, key);
  }
};
var IExtHostSecretState = createDecorator("IExtHostSecretState");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSecrets.js
init_extensions();
init_event();
var _secretState;
var ExtensionSecrets = class {
  constructor(extensionDescription, secretState) {
    __privateAdd(this, _secretState, void 0);
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._id = ExtensionIdentifier.toKey(extensionDescription.identifier);
    __privateSet(this, _secretState, secretState);
    __privateGet(this, _secretState).onDidChangePassword((e) => {
      if (e.extensionId === this._id) {
        this._onDidChange.fire({ key: e.key });
      }
    });
  }
  get(key) {
    return __privateGet(this, _secretState).get(this._id, key);
  }
  store(key, value) {
    return __privateGet(this, _secretState).store(this._id, key, value);
  }
  delete(key) {
    return __privateGet(this, _secretState).delete(this._id, key);
  }
};
_secretState = new WeakMap();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionService.js
init_network();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLocalizationService.js
init_tslib_es6();
init_platform();
init_strings();
init_uri();
init_instantiation();
init_log();
init_extHost_protocol();
var ExtHostLocalizationService = class ExtHostLocalizationService2 {
  constructor(initData, rpc, logService) {
    this.logService = logService;
    this.bundleCache = /* @__PURE__ */ new Map();
    this._proxy = rpc.getProxy(MainContext.MainThreadLocalization);
    this.currentLanguage = initData.environment.appLanguage;
    this.isDefaultLanguage = this.currentLanguage === LANGUAGE_DEFAULT;
  }
  getMessage(extensionId, details) {
    var _a30;
    const { message, args, comment } = details;
    if (this.isDefaultLanguage) {
      return format2(message, args ?? {});
    }
    let key = message;
    if (comment && comment.length > 0) {
      key += `/${Array.isArray(comment) ? comment.join("") : comment}`;
    }
    const str = (_a30 = this.bundleCache.get(extensionId)) == null ? void 0 : _a30.contents[key];
    if (!str) {
      this.logService.warn(`Using default string since no string found in i18n bundle that has the key: ${key}`);
    }
    return format2(str ?? message, args ?? {});
  }
  getBundle(extensionId) {
    var _a30;
    return (_a30 = this.bundleCache.get(extensionId)) == null ? void 0 : _a30.contents;
  }
  getBundleUri(extensionId) {
    var _a30;
    return (_a30 = this.bundleCache.get(extensionId)) == null ? void 0 : _a30.uri;
  }
  async initializeLocalizedMessages(extension) {
    var _a30;
    if (this.isDefaultLanguage || !extension.l10n && !extension.isBuiltin) {
      return;
    }
    if (this.bundleCache.has(extension.identifier.value)) {
      return;
    }
    let contents;
    const bundleUri = await this.getBundleLocation(extension);
    if (!bundleUri) {
      this.logService.error(`No bundle location found for extension ${extension.identifier.value}`);
      return;
    }
    try {
      const response = await this._proxy.$fetchBundleContents(bundleUri);
      const result = JSON.parse(response);
      contents = extension.isBuiltin ? (_a30 = result.contents) == null ? void 0 : _a30.bundle : result;
    } catch (e) {
      this.logService.error(`Failed to load translations for ${extension.identifier.value} from ${bundleUri}: ${e.message}`);
      return;
    }
    if (contents) {
      this.bundleCache.set(extension.identifier.value, {
        contents,
        uri: bundleUri
      });
    }
  }
  async getBundleLocation(extension) {
    if (extension.isBuiltin) {
      const uri = await this._proxy.$fetchBuiltInBundleUri(extension.identifier.value, this.currentLanguage);
      return URI.revive(uri);
    }
    return extension.l10n ? URI.joinPath(extension.extensionLocation, extension.l10n, `bundle.l10n.${this.currentLanguage}.json`) : void 0;
  }
};
ExtHostLocalizationService = __decorate([
  __param(0, IExtHostInitDataService),
  __param(1, IExtHostRpcService),
  __param(2, ILogService)
], ExtHostLocalizationService);
var IExtHostLocalizationService = createDecorator("IExtHostLocalizationService");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionService.js
init_stopwatch();
init_platform();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostManagedSockets.js
init_tslib_es6();
init_extHost_protocol();
init_instantiation();
init_lifecycle();
init_buffer();
var IExtHostManagedSockets = createDecorator("IExtHostManagedSockets");
var ExtHostManagedSockets = class ExtHostManagedSockets2 {
  constructor(extHostRpc) {
    this._remoteSocketIdCounter = 0;
    this._factory = null;
    this._managedRemoteSockets = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadManagedSockets);
  }
  setFactory(socketFactoryId, makeConnection) {
    for (const socket of this._managedRemoteSockets.values()) {
      socket.dispose();
    }
    if (this._factory) {
      this._proxy.$unregisterSocketFactory(this._factory.socketFactoryId);
    }
    this._factory = new ManagedSocketFactory(socketFactoryId, makeConnection);
    this._proxy.$registerSocketFactory(this._factory.socketFactoryId);
  }
  async $openRemoteSocket(socketFactoryId) {
    if (!this._factory || this._factory.socketFactoryId !== socketFactoryId) {
      throw new Error(`No socket factory with id ${socketFactoryId}`);
    }
    const id = ++this._remoteSocketIdCounter;
    const socket = await this._factory.makeConnection();
    const disposable = new DisposableStore();
    this._managedRemoteSockets.set(id, new ManagedSocket(id, socket, disposable));
    disposable.add(toDisposable(() => this._managedRemoteSockets.delete(id)));
    disposable.add(socket.onDidEnd(() => {
      this._proxy.$onDidManagedSocketEnd(id);
      disposable.dispose();
    }));
    disposable.add(socket.onDidClose((e) => {
      this._proxy.$onDidManagedSocketClose(id, (e == null ? void 0 : e.stack) ?? (e == null ? void 0 : e.message));
      disposable.dispose();
    }));
    disposable.add(socket.onDidReceiveMessage((e) => this._proxy.$onDidManagedSocketHaveData(id, VSBuffer.wrap(e))));
    return id;
  }
  $remoteSocketWrite(socketId, buffer) {
    var _a30;
    (_a30 = this._managedRemoteSockets.get(socketId)) == null ? void 0 : _a30.actual.send(buffer.buffer);
  }
  $remoteSocketEnd(socketId) {
    const socket = this._managedRemoteSockets.get(socketId);
    if (socket) {
      socket.actual.end();
      socket.dispose();
    }
  }
  async $remoteSocketDrain(socketId) {
    var _a30, _b, _c;
    await ((_c = (_a30 = this._managedRemoteSockets.get(socketId)) == null ? void 0 : (_b = _a30.actual).drain) == null ? void 0 : _c.call(_b));
  }
};
ExtHostManagedSockets = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostManagedSockets);
var ManagedSocketFactory = class {
  constructor(socketFactoryId, makeConnection) {
    this.socketFactoryId = socketFactoryId;
    this.makeConnection = makeConnection;
  }
};
var ManagedSocket = class extends Disposable {
  constructor(socketId, actual, disposer) {
    super();
    this.socketId = socketId;
    this.actual = actual;
    this._register(disposer);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionService.js
var AbstractExtHostExtensionService_1;
var IHostUtils = createDecorator("IHostUtils");
var AbstractExtHostExtensionService = AbstractExtHostExtensionService_1 = class AbstractExtHostExtensionService2 extends Disposable {
  constructor(instaService, hostUtils, extHostContext, extHostWorkspace, extHostConfiguration, logService, initData, storagePath, extHostTunnelService, extHostTerminalService, extHostLocalizationService, _extHostManagedSockets) {
    super();
    this._extHostManagedSockets = _extHostManagedSockets;
    this._onDidChangeRemoteConnectionData = this._register(new Emitter());
    this.onDidChangeRemoteConnectionData = this._onDidChangeRemoteConnectionData.event;
    this._isTerminating = false;
    this._hostUtils = hostUtils;
    this._extHostContext = extHostContext;
    this._initData = initData;
    this._extHostWorkspace = extHostWorkspace;
    this._extHostConfiguration = extHostConfiguration;
    this._logService = logService;
    this._extHostTunnelService = extHostTunnelService;
    this._extHostTerminalService = extHostTerminalService;
    this._extHostLocalizationService = extHostLocalizationService;
    this._mainThreadWorkspaceProxy = this._extHostContext.getProxy(MainContext.MainThreadWorkspace);
    this._mainThreadTelemetryProxy = this._extHostContext.getProxy(MainContext.MainThreadTelemetry);
    this._mainThreadExtensionsProxy = this._extHostContext.getProxy(MainContext.MainThreadExtensionService);
    this._almostReadyToRunExtensions = new Barrier();
    this._readyToStartExtensionHost = new Barrier();
    this._readyToRunExtensions = new Barrier();
    this._eagerExtensionsActivated = new Barrier();
    this._activationEventsReader = new SyncedActivationEventsReader(this._initData.activationEvents);
    this._globalRegistry = new ExtensionDescriptionRegistry(this._activationEventsReader, this._initData.allExtensions);
    const myExtensionsSet = new ExtensionIdentifierSet(this._initData.myExtensions);
    this._myRegistry = new ExtensionDescriptionRegistry(
      this._activationEventsReader,
      filterExtensions(this._globalRegistry, myExtensionsSet)
    );
    this._storage = new ExtHostStorage(this._extHostContext, this._logService);
    this._secretState = new ExtHostSecretState(this._extHostContext);
    this._storagePath = storagePath;
    this._instaService = instaService.createChild(new ServiceCollection([IExtHostStorage, this._storage], [IExtHostSecretState, this._secretState]));
    this._activator = this._register(new ExtensionsActivator(this._myRegistry, this._globalRegistry, {
      onExtensionActivationError: (extensionId, error, missingExtensionDependency) => {
        this._mainThreadExtensionsProxy.$onExtensionActivationError(extensionId, transformErrorForSerialization(error), missingExtensionDependency);
      },
      actualActivateExtension: async (extensionId, reason) => {
        if (ExtensionDescriptionRegistry.isHostExtension(extensionId, this._myRegistry, this._globalRegistry)) {
          await this._mainThreadExtensionsProxy.$activateExtension(extensionId, reason);
          return new HostExtension();
        }
        const extensionDescription = this._myRegistry.getExtensionDescription(extensionId);
        return this._activateExtension(extensionDescription, reason);
      }
    }, this._logService));
    this._extensionPathIndex = null;
    this._resolvers = /* @__PURE__ */ Object.create(null);
    this._started = false;
    this._remoteConnectionData = this._initData.remote.connectionData;
  }
  getRemoteConnectionData() {
    return this._remoteConnectionData;
  }
  async initialize() {
    try {
      await this._beforeAlmostReadyToRunExtensions();
      this._almostReadyToRunExtensions.open();
      await this._extHostWorkspace.waitForInitializeCall();
      mark("code/extHost/ready");
      this._readyToStartExtensionHost.open();
      if (this._initData.autoStart) {
        this._startExtensionHost();
      }
    } catch (err) {
      onUnexpectedError(err);
    }
  }
  async _deactivateAll() {
    this._storagePath.onWillDeactivateAll();
    let allPromises = [];
    try {
      const allExtensions = this._myRegistry.getAllExtensionDescriptions();
      const allExtensionsIds = allExtensions.map((ext) => ext.identifier);
      const activatedExtensions = allExtensionsIds.filter((id) => this.isActivated(id));
      allPromises = activatedExtensions.map((extensionId) => {
        return this._deactivate(extensionId);
      });
    } catch (err) {
    }
    await Promise.all(allPromises);
  }
  terminate(reason, code = 0) {
    if (this._isTerminating) {
      return;
    }
    this._isTerminating = true;
    this._logService.info(`Extension host terminating: ${reason}`);
    this._logService.flush();
    this._extHostTerminalService.dispose();
    this._activator.dispose();
    if (isWebWorker) {
      setUnexpectedErrorHandler((err) => {
        this._logService.error(err);
      });
    }
    this._extHostContext.dispose();
    const extensionsDeactivated = this._deactivateAll();
    Promise.race([timeout(5e3), extensionsDeactivated]).finally(() => {
      if (this._hostUtils.pid) {
        this._logService.info(`Extension host with pid ${this._hostUtils.pid} exiting with code ${code}`);
      } else {
        this._logService.info(`Extension host exiting with code ${code}`);
      }
      this._logService.flush();
      this._logService.dispose();
      this._hostUtils.exit(code);
    });
  }
  isActivated(extensionId) {
    if (this._readyToRunExtensions.isOpen()) {
      return this._activator.isActivated(extensionId);
    }
    return false;
  }
  async getExtension(extensionId) {
    const ext = await this._mainThreadExtensionsProxy.$getExtension(extensionId);
    return ext && {
      ...ext,
      identifier: new ExtensionIdentifier(ext.identifier.value),
      extensionLocation: URI.revive(ext.extensionLocation)
    };
  }
  _activateByEvent(activationEvent, startup) {
    return this._activator.activateByEvent(activationEvent, startup);
  }
  _activateById(extensionId, reason) {
    return this._activator.activateById(extensionId, reason);
  }
  activateByIdWithErrors(extensionId, reason) {
    return this._activateById(extensionId, reason).then(() => {
      const extension = this._activator.getActivatedExtension(extensionId);
      if (extension.activationFailed) {
        return Promise.reject(extension.activationFailedError);
      }
      return void 0;
    });
  }
  getExtensionRegistry() {
    return this._readyToRunExtensions.wait().then((_) => this._myRegistry);
  }
  getExtensionExports(extensionId) {
    if (this._readyToRunExtensions.isOpen()) {
      return this._activator.getActivatedExtension(extensionId).exports;
    } else {
      try {
        return this._activator.getActivatedExtension(extensionId).exports;
      } catch (err) {
        return null;
      }
    }
  }
  async _realPathExtensionUri(uri) {
    if (uri.scheme === Schemas.file && this._hostUtils.fsRealpath) {
      const realpathValue = await this._hostUtils.fsRealpath(uri.fsPath);
      return URI.file(realpathValue);
    }
    return uri;
  }
  async getExtensionPathIndex() {
    if (!this._extensionPathIndex) {
      this._extensionPathIndex = this._createExtensionPathIndex(this._myRegistry.getAllExtensionDescriptions()).then((searchTree) => {
        return new ExtensionPaths(searchTree);
      });
    }
    return this._extensionPathIndex;
  }
  async _createExtensionPathIndex(extensions) {
    const tst = TernarySearchTree.forUris((key) => {
      return extUriBiasedIgnorePathCase.ignorePathCasing(key);
    });
    await Promise.all(extensions.map(async (ext) => {
      if (this._getEntryPoint(ext)) {
        const uri = await this._realPathExtensionUri(ext.extensionLocation);
        tst.set(uri, ext);
      }
    }));
    return tst;
  }
  _deactivate(extensionId) {
    let result = Promise.resolve(void 0);
    if (!this._readyToRunExtensions.isOpen()) {
      return result;
    }
    if (!this._activator.isActivated(extensionId)) {
      return result;
    }
    const extension = this._activator.getActivatedExtension(extensionId);
    if (!extension) {
      return result;
    }
    try {
      if (typeof extension.module.deactivate === "function") {
        result = Promise.resolve(extension.module.deactivate()).then(void 0, (err) => {
          this._logService.error(err);
          return Promise.resolve(void 0);
        });
      }
    } catch (err) {
      this._logService.error(`An error occurred when deactivating the extension '${extensionId.value}':`);
      this._logService.error(err);
    }
    try {
      dispose(extension.subscriptions);
    } catch (err) {
      this._logService.error(`An error occurred when deactivating the subscriptions for extension '${extensionId.value}':`);
      this._logService.error(err);
    }
    return result;
  }
  async _activateExtension(extensionDescription, reason) {
    if (!this._initData.remote.isRemote) {
      await this._mainThreadExtensionsProxy.$onWillActivateExtension(extensionDescription.identifier);
    } else {
      this._mainThreadExtensionsProxy.$onWillActivateExtension(extensionDescription.identifier);
    }
    return this._doActivateExtension(extensionDescription, reason).then((activatedExtension) => {
      const activationTimes = activatedExtension.activationTimes;
      this._mainThreadExtensionsProxy.$onDidActivateExtension(extensionDescription.identifier, activationTimes.codeLoadingTime, activationTimes.activateCallTime, activationTimes.activateResolvedTime, reason);
      this._logExtensionActivationTimes(extensionDescription, reason, "success", activationTimes);
      return activatedExtension;
    }, (err) => {
      this._logExtensionActivationTimes(extensionDescription, reason, "failure");
      throw err;
    });
  }
  _logExtensionActivationTimes(extensionDescription, reason, outcome, activationTimes) {
    const event = getTelemetryActivationEvent(extensionDescription, reason);
    this._mainThreadTelemetryProxy.$publicLog2("extensionActivationTimes", {
      ...event,
      ...activationTimes || {},
      outcome
    });
  }
  _doActivateExtension(extensionDescription, reason) {
    const event = getTelemetryActivationEvent(extensionDescription, reason);
    this._mainThreadTelemetryProxy.$publicLog2("activatePlugin", event);
    const entryPoint = this._getEntryPoint(extensionDescription);
    if (!entryPoint) {
      return Promise.resolve(new EmptyExtension(ExtensionActivationTimes.NONE));
    }
    this._logService.info(`ExtensionService#_doActivateExtension ${extensionDescription.identifier.value}, startup: ${reason.startup}, activationEvent: '${reason.activationEvent}'${extensionDescription.identifier.value !== reason.extensionId.value ? `, root cause: ${reason.extensionId.value}` : ``}`);
    this._logService.flush();
    const activationTimesBuilder = new ExtensionActivationTimesBuilder(reason.startup);
    return Promise.all([
      this._loadCommonJSModule(extensionDescription, joinPath(extensionDescription.extensionLocation, entryPoint), activationTimesBuilder),
      this._loadExtensionContext(extensionDescription)
    ]).then((values) => {
      mark(`code/extHost/willActivateExtension/${extensionDescription.identifier.value}`);
      return AbstractExtHostExtensionService_1._callActivate(this._logService, extensionDescription.identifier, values[0], values[1], activationTimesBuilder);
    }).then((activatedExtension) => {
      mark(`code/extHost/didActivateExtension/${extensionDescription.identifier.value}`);
      return activatedExtension;
    });
  }
  _loadExtensionContext(extensionDescription) {
    const globalState = new ExtensionGlobalMemento(extensionDescription, this._storage);
    const workspaceState = new ExtensionMemento(extensionDescription.identifier.value, false, this._storage);
    const secrets = new ExtensionSecrets(extensionDescription, this._secretState);
    const extensionMode = extensionDescription.isUnderDevelopment ? this._initData.environment.extensionTestsLocationURI ? ExtensionMode.Test : ExtensionMode.Development : ExtensionMode.Production;
    const extensionKind = this._initData.remote.isRemote ? ExtensionKind.Workspace : ExtensionKind.UI;
    this._logService.trace(`ExtensionService#loadExtensionContext ${extensionDescription.identifier.value}`);
    return Promise.all([
      globalState.whenReady,
      workspaceState.whenReady,
      this._storagePath.whenReady
    ]).then(() => {
      var _a30;
      const that = this;
      let extension;
      let messagePassingProtocol;
      const messagePort = isProposedApiEnabled(extensionDescription, "ipc") ? (_a30 = this._initData.messagePorts) == null ? void 0 : _a30.get(ExtensionIdentifier.toKey(extensionDescription.identifier)) : void 0;
      return Object.freeze({
        globalState,
        workspaceState,
        secrets,
        subscriptions: [],
        get extensionUri() {
          return extensionDescription.extensionLocation;
        },
        get extensionPath() {
          return extensionDescription.extensionLocation.fsPath;
        },
        asAbsolutePath(relativePath2) {
          return join(extensionDescription.extensionLocation.fsPath, relativePath2);
        },
        get storagePath() {
          var _a31;
          return (_a31 = that._storagePath.workspaceValue(extensionDescription)) == null ? void 0 : _a31.fsPath;
        },
        get globalStoragePath() {
          return that._storagePath.globalValue(extensionDescription).fsPath;
        },
        get logPath() {
          return join(that._initData.logsLocation.fsPath, extensionDescription.identifier.value);
        },
        get logUri() {
          return URI.joinPath(that._initData.logsLocation, extensionDescription.identifier.value);
        },
        get storageUri() {
          return that._storagePath.workspaceValue(extensionDescription);
        },
        get globalStorageUri() {
          return that._storagePath.globalValue(extensionDescription);
        },
        get extensionMode() {
          return extensionMode;
        },
        get extension() {
          if (extension === void 0) {
            extension = new Extension(
              that,
              extensionDescription.identifier,
              extensionDescription,
              extensionKind,
              false
            );
          }
          return extension;
        },
        get extensionRuntime() {
          checkProposedApiEnabled(extensionDescription, "extensionRuntime");
          return that.extensionRuntime;
        },
        get environmentVariableCollection() {
          return that._extHostTerminalService.getEnvironmentVariableCollection(extensionDescription);
        },
        get messagePassingProtocol() {
          if (!messagePassingProtocol) {
            if (!messagePort) {
              return void 0;
            }
            const onDidReceiveMessage = Event.buffer(Event.fromDOMEventEmitter(messagePort, "message", (e) => e.data));
            messagePort.start();
            messagePassingProtocol = {
              onDidReceiveMessage,
              postMessage: messagePort.postMessage.bind(messagePort)
            };
          }
          return messagePassingProtocol;
        }
      });
    });
  }
  static _callActivate(logService, extensionId, extensionModule, context, activationTimesBuilder) {
    extensionModule = extensionModule || {
      activate: void 0,
      deactivate: void 0
    };
    return this._callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder).then((extensionExports) => {
      return new ActivatedExtension(
        false,
        null,
        activationTimesBuilder.build(),
        extensionModule,
        extensionExports,
        context.subscriptions
      );
    });
  }
  static _callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder) {
    if (typeof extensionModule.activate === "function") {
      try {
        activationTimesBuilder.activateCallStart();
        logService.trace(`ExtensionService#_callActivateOptional ${extensionId.value}`);
        const scope = typeof global === "object" ? global : self;
        const activateResult = extensionModule.activate.apply(scope, [context]);
        activationTimesBuilder.activateCallStop();
        activationTimesBuilder.activateResolveStart();
        return Promise.resolve(activateResult).then((value) => {
          activationTimesBuilder.activateResolveStop();
          return value;
        });
      } catch (err) {
        return Promise.reject(err);
      }
    } else {
      return Promise.resolve(extensionModule);
    }
  }
  _activateOneStartupFinished(desc, activationEvent) {
    this._activateById(desc.identifier, {
      startup: false,
      extensionId: desc.identifier,
      activationEvent
    }).then(void 0, (err) => {
      this._logService.error(err);
    });
  }
  _activateAllStartupFinishedDeferred(extensions, start = 0) {
    const timeBudget = 50;
    const startTime = Date.now();
    setTimeout0(() => {
      for (let i = start; i < extensions.length; i += 1) {
        const desc = extensions[i];
        for (const activationEvent of desc.activationEvents ?? []) {
          if (activationEvent === "onStartupFinished") {
            if (Date.now() - startTime > timeBudget) {
              this._activateAllStartupFinishedDeferred(extensions, i);
              break;
            } else {
              this._activateOneStartupFinished(desc, activationEvent);
            }
          }
        }
      }
    });
  }
  _activateAllStartupFinished() {
    this._mainThreadExtensionsProxy.$setPerformanceMarks(getMarks());
    this._extHostConfiguration.getConfigProvider().then((configProvider) => {
      const shouldDeferActivation = configProvider.getConfiguration("extensions.experimental").get("deferredStartupFinishedActivation");
      const allExtensionDescriptions = this._myRegistry.getAllExtensionDescriptions();
      if (shouldDeferActivation) {
        this._activateAllStartupFinishedDeferred(allExtensionDescriptions);
      } else {
        for (const desc of allExtensionDescriptions) {
          if (desc.activationEvents) {
            for (const activationEvent of desc.activationEvents) {
              if (activationEvent === "onStartupFinished") {
                this._activateOneStartupFinished(desc, activationEvent);
              }
            }
          }
        }
      }
    });
  }
  _handleEagerExtensions() {
    const starActivation = this._activateByEvent("*", true).then(void 0, (err) => {
      this._logService.error(err);
    });
    this._register(this._extHostWorkspace.onDidChangeWorkspace((e) => this._handleWorkspaceContainsEagerExtensions(e.added)));
    const folders = this._extHostWorkspace.workspace ? this._extHostWorkspace.workspace.folders : [];
    const workspaceContainsActivation = this._handleWorkspaceContainsEagerExtensions(folders);
    const remoteResolverActivation = this._handleRemoteResolverEagerExtensions();
    const eagerExtensionsActivation = Promise.all([remoteResolverActivation, starActivation, workspaceContainsActivation]).then(() => {
    });
    Promise.race([eagerExtensionsActivation, timeout(1e4)]).then(() => {
      this._activateAllStartupFinished();
    });
    return eagerExtensionsActivation;
  }
  _handleWorkspaceContainsEagerExtensions(folders) {
    if (folders.length === 0) {
      return Promise.resolve(void 0);
    }
    return Promise.all(this._myRegistry.getAllExtensionDescriptions().map((desc) => {
      return this._handleWorkspaceContainsEagerExtension(folders, desc);
    })).then(() => {
    });
  }
  async _handleWorkspaceContainsEagerExtension(folders, desc) {
    if (this.isActivated(desc.identifier)) {
      return;
    }
    const localWithRemote = !this._initData.remote.isRemote && !!this._initData.remote.authority;
    const host = {
      logService: this._logService,
      folders: folders.map((folder) => folder.uri),
      forceUsingSearch: localWithRemote || !this._hostUtils.fsExists,
      exists: (uri) => this._hostUtils.fsExists(uri.fsPath),
      checkExists: (folders2, includes2, token) => this._mainThreadWorkspaceProxy.$checkExists(folders2, includes2, token)
    };
    const result = await checkActivateWorkspaceContainsExtension(host, desc);
    if (!result) {
      return;
    }
    return this._activateById(desc.identifier, { startup: true, extensionId: desc.identifier, activationEvent: result.activationEvent }).then(void 0, (err) => this._logService.error(err));
  }
  async _handleRemoteResolverEagerExtensions() {
    if (this._initData.remote.authority) {
      return this._activateByEvent(`onResolveRemoteAuthority:${this._initData.remote.authority}`, false);
    }
  }
  async $extensionTestsExecute() {
    await this._eagerExtensionsActivated.wait();
    try {
      return await this._doHandleExtensionTests();
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
  async _doHandleExtensionTests() {
    const { extensionDevelopmentLocationURI, extensionTestsLocationURI } = this._initData.environment;
    if (!extensionDevelopmentLocationURI || !extensionTestsLocationURI) {
      throw new Error(localize("extensionTestError1", "Cannot load test runner."));
    }
    const testRunner = await this._loadCommonJSModule(null, extensionTestsLocationURI, new ExtensionActivationTimesBuilder(false));
    if (!testRunner || typeof testRunner.run !== "function") {
      throw new Error(localize("extensionTestError", "Path {0} does not point to a valid extension test runner.", extensionTestsLocationURI.toString()));
    }
    return new Promise((resolve, reject) => {
      const oldTestRunnerCallback = (error, failures) => {
        if (error) {
          reject(error);
        } else {
          resolve(typeof failures === "number" && failures > 0 ? 1 : 0);
        }
      };
      const extensionTestsPath = originalFSPath(extensionTestsLocationURI);
      const runResult = testRunner.run(extensionTestsPath, oldTestRunnerCallback);
      if (runResult && runResult.then) {
        runResult.then(() => {
          resolve(0);
        }).catch((err) => {
          reject(err instanceof Error && err.stack ? err.stack : String(err));
        });
      }
    });
  }
  _startExtensionHost() {
    if (this._started) {
      throw new Error(`Extension host is already started!`);
    }
    this._started = true;
    return this._readyToStartExtensionHost.wait().then(() => this._readyToRunExtensions.open()).then(() => {
      return Promise.race([this._activator.waitForActivatingExtensions(), timeout(1e3)]);
    }).then(() => this._handleEagerExtensions()).then(() => {
      this._eagerExtensionsActivated.open();
      this._logService.info(`Eager extensions activated`);
    });
  }
  registerRemoteAuthorityResolver(authorityPrefix, resolver) {
    this._resolvers[authorityPrefix] = resolver;
    return toDisposable(() => {
      delete this._resolvers[authorityPrefix];
    });
  }
  async getRemoteExecServer(remoteAuthority) {
    var _a30;
    const { resolver } = await this._activateAndGetResolver(remoteAuthority);
    return (_a30 = resolver == null ? void 0 : resolver.resolveExecServer) == null ? void 0 : _a30.call(resolver, remoteAuthority, { resolveAttempt: 0 });
  }
  async _activateAndGetResolver(remoteAuthority) {
    const authorityPlusIndex = remoteAuthority.indexOf("+");
    if (authorityPlusIndex === -1) {
      throw new RemoteAuthorityResolverError2(`Not an authority that can be resolved!`, RemoteAuthorityResolverErrorCode.InvalidAuthority);
    }
    const authorityPrefix = remoteAuthority.substr(0, authorityPlusIndex);
    await this._almostReadyToRunExtensions.wait();
    await this._activateByEvent(`onResolveRemoteAuthority:${authorityPrefix}`, false);
    return { authorityPrefix, resolver: this._resolvers[authorityPrefix] };
  }
  async $resolveAuthority(remoteAuthorityChain, resolveAttempt) {
    var _a30;
    const sw = StopWatch.create(false);
    const prefix = () => `[resolveAuthority(${getRemoteAuthorityPrefix(remoteAuthorityChain)},${resolveAttempt})][${sw.elapsed()}ms] `;
    const logInfo = (msg) => this._logService.info(`${prefix()}${msg}`);
    const logWarning = (msg) => this._logService.warn(`${prefix()}${msg}`);
    const logError = (msg, err = void 0) => this._logService.error(`${prefix()}${msg}`, err);
    const normalizeError = (err) => {
      if (err instanceof RemoteAuthorityResolverError2) {
        return {
          type: "error",
          error: {
            code: err._code,
            message: err._message,
            detail: err._detail
          }
        };
      }
      throw err;
    };
    const getResolver = async (remoteAuthority) => {
      logInfo(`activating resolver for ${remoteAuthority}...`);
      const { resolver, authorityPrefix } = await this._activateAndGetResolver(remoteAuthority);
      if (!resolver) {
        logError(`no resolver for ${authorityPrefix}`);
        throw new RemoteAuthorityResolverError2(`No remote extension installed to resolve ${authorityPrefix}.`, RemoteAuthorityResolverErrorCode.NoResolverFound);
      }
      return { resolver, authorityPrefix, remoteAuthority };
    };
    const chain = remoteAuthorityChain.split(/@|%40/g).reverse();
    logInfo(`activating remote resolvers ${chain.join(" -> ")}`);
    let resolvers;
    try {
      resolvers = await Promise.all(chain.map(getResolver)).catch(async (e) => {
        if (!(e instanceof RemoteAuthorityResolverError2) || e._code !== RemoteAuthorityResolverErrorCode.InvalidAuthority) {
          throw e;
        }
        logWarning(`resolving nested authorities failed: ${e.message}`);
        return [await getResolver(remoteAuthorityChain)];
      });
    } catch (e) {
      return normalizeError(e);
    }
    const intervalLogger = new IntervalTimer();
    intervalLogger.cancelAndSet(() => logInfo("waiting..."), 1e3);
    let result;
    let execServer;
    for (const [i, { authorityPrefix, resolver, remoteAuthority }] of resolvers.entries()) {
      try {
        if (i === resolvers.length - 1) {
          logInfo(`invoking final resolve()...`);
          mark(`code/extHost/willResolveAuthority/${authorityPrefix}`);
          result = await resolver.resolve(remoteAuthority, { resolveAttempt, execServer });
          mark(`code/extHost/didResolveAuthorityOK/${authorityPrefix}`);
          logInfo(`setting tunnel factory...`);
          this._register(await this._extHostTunnelService.setTunnelFactory(resolver, ManagedResolvedAuthority.isManagedResolvedAuthority(result) ? result : void 0));
        } else {
          logInfo(`invoking resolveExecServer() for ${remoteAuthority}`);
          mark(`code/extHost/willResolveExecServer/${authorityPrefix}`);
          execServer = await ((_a30 = resolver.resolveExecServer) == null ? void 0 : _a30.call(resolver, remoteAuthority, { resolveAttempt, execServer }));
          if (!execServer) {
            throw new RemoteAuthorityResolverError2(`Exec server was not available for ${remoteAuthority}`, RemoteAuthorityResolverErrorCode.NoResolverFound);
          }
          mark(`code/extHost/didResolveExecServerOK/${authorityPrefix}`);
        }
      } catch (e) {
        mark(`code/extHost/didResolveAuthorityError/${authorityPrefix}`);
        logError(`returned an error`, e);
        intervalLogger.dispose();
        return normalizeError(e);
      }
    }
    intervalLogger.dispose();
    const tunnelInformation = {
      environmentTunnels: result.environmentTunnels,
      features: result.tunnelFeatures
    };
    const options = {
      extensionHostEnv: result.extensionHostEnv,
      isTrusted: result.isTrusted,
      authenticationSession: result.authenticationSessionForInitializingExtensions ? { id: result.authenticationSessionForInitializingExtensions.id, providerId: result.authenticationSessionForInitializingExtensions.providerId } : void 0
    };
    logInfo(`returned ${ManagedResolvedAuthority.isManagedResolvedAuthority(result) ? "managed authority" : `${result.host}:${result.port}`}`);
    let authority;
    if (ManagedResolvedAuthority.isManagedResolvedAuthority(result)) {
      const socketFactoryId = resolveAttempt;
      this._extHostManagedSockets.setFactory(socketFactoryId, result.makeConnection);
      authority = {
        authority: remoteAuthorityChain,
        connectTo: new ManagedRemoteConnection(socketFactoryId),
        connectionToken: result.connectionToken
      };
    } else {
      authority = {
        authority: remoteAuthorityChain,
        connectTo: new WebSocketRemoteConnection(result.host, result.port),
        connectionToken: result.connectionToken
      };
    }
    return {
      type: "ok",
      value: {
        authority,
        options,
        tunnelInformation
      }
    };
  }
  async $getCanonicalURI(remoteAuthority, uriComponents) {
    this._logService.info(`$getCanonicalURI invoked for authority (${getRemoteAuthorityPrefix(remoteAuthority)})`);
    const { resolver } = await this._activateAndGetResolver(remoteAuthority);
    if (!resolver) {
      return null;
    }
    const uri = URI.revive(uriComponents);
    if (typeof resolver.getCanonicalURI === "undefined") {
      return uri;
    }
    const result = await asPromise(() => resolver.getCanonicalURI(uri));
    if (!result) {
      return uri;
    }
    return result;
  }
  $startExtensionHost(extensionsDelta) {
    extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = URI.revive(extension.extensionLocation));
    const { globalRegistry, myExtensions } = applyExtensionsDelta(this._activationEventsReader, this._globalRegistry, this._myRegistry, extensionsDelta);
    this._globalRegistry.set(globalRegistry.getAllExtensionDescriptions());
    this._myRegistry.set(myExtensions);
    return this._startExtensionHost();
  }
  $activateByEvent(activationEvent, activationKind) {
    if (activationKind === 1) {
      return this._almostReadyToRunExtensions.wait().then((_) => this._activateByEvent(activationEvent, false));
    }
    return this._readyToRunExtensions.wait().then((_) => this._activateByEvent(activationEvent, false));
  }
  async $activate(extensionId, reason) {
    await this._readyToRunExtensions.wait();
    if (!this._myRegistry.getExtensionDescription(extensionId)) {
      return false;
    }
    await this._activateById(extensionId, reason);
    return true;
  }
  async $deltaExtensions(extensionsDelta) {
    extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = URI.revive(extension.extensionLocation));
    const { globalRegistry, myExtensions } = applyExtensionsDelta(this._activationEventsReader, this._globalRegistry, this._myRegistry, extensionsDelta);
    const newSearchTree = await this._createExtensionPathIndex(myExtensions);
    const extensionsPaths = await this.getExtensionPathIndex();
    extensionsPaths.setSearchTree(newSearchTree);
    this._globalRegistry.set(globalRegistry.getAllExtensionDescriptions());
    this._myRegistry.set(myExtensions);
    return Promise.resolve(void 0);
  }
  async $test_latency(n2) {
    return n2;
  }
  async $test_up(b) {
    return b.byteLength;
  }
  async $test_down(size) {
    const buff = VSBuffer.alloc(size);
    const value = Math.random() % 256;
    for (let i = 0; i < size; i++) {
      buff.writeUInt8(value, i);
    }
    return buff;
  }
  async $updateRemoteConnectionData(connectionData) {
    this._remoteConnectionData = connectionData;
    this._onDidChangeRemoteConnectionData.fire();
  }
};
AbstractExtHostExtensionService = AbstractExtHostExtensionService_1 = __decorate([
  __param(0, IInstantiationService),
  __param(1, IHostUtils),
  __param(2, IExtHostRpcService),
  __param(3, IExtHostWorkspace),
  __param(4, IExtHostConfiguration),
  __param(5, ILogService),
  __param(6, IExtHostInitDataService),
  __param(7, IExtensionStoragePaths),
  __param(8, IExtHostTunnelService),
  __param(9, IExtHostTerminalService),
  __param(10, IExtHostLocalizationService),
  __param(11, IExtHostManagedSockets)
], AbstractExtHostExtensionService);
function applyExtensionsDelta(activationEventsReader, oldGlobalRegistry, oldMyRegistry, extensionsDelta) {
  activationEventsReader.addActivationEvents(extensionsDelta.addActivationEvents);
  const globalRegistry = new ExtensionDescriptionRegistry(activationEventsReader, oldGlobalRegistry.getAllExtensionDescriptions());
  globalRegistry.deltaExtensions(extensionsDelta.toAdd, extensionsDelta.toRemove);
  const myExtensionsSet = new ExtensionIdentifierSet(oldMyRegistry.getAllExtensionDescriptions().map((extension) => extension.identifier));
  for (const extensionId of extensionsDelta.myToRemove) {
    myExtensionsSet.delete(extensionId);
  }
  for (const extensionId of extensionsDelta.myToAdd) {
    myExtensionsSet.add(extensionId);
  }
  const myExtensions = filterExtensions(globalRegistry, myExtensionsSet);
  return { globalRegistry, myExtensions };
}
function getTelemetryActivationEvent(extensionDescription, reason) {
  const event = {
    id: extensionDescription.identifier.value,
    name: extensionDescription.name,
    extensionVersion: extensionDescription.version,
    publisherDisplayName: extensionDescription.publisher,
    activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(",") : null,
    isBuiltin: extensionDescription.isBuiltin,
    reason: reason.activationEvent,
    reasonId: reason.extensionId.value
  };
  return event;
}
var IExtHostExtensionService = createDecorator("IExtHostExtensionService");
var _extensionService, _originExtensionId, _identifier;
var Extension = class {
  constructor(extensionService, originExtensionId, description, kind, isFromDifferentExtensionHost) {
    __privateAdd(this, _extensionService, void 0);
    __privateAdd(this, _originExtensionId, void 0);
    __privateAdd(this, _identifier, void 0);
    __privateSet(this, _extensionService, extensionService);
    __privateSet(this, _originExtensionId, originExtensionId);
    __privateSet(this, _identifier, description.identifier);
    this.id = description.identifier.value;
    this.extensionUri = description.extensionLocation;
    this.extensionPath = normalize(originalFSPath(description.extensionLocation));
    this.packageJSON = description;
    this.extensionKind = kind;
    this.isFromDifferentExtensionHost = isFromDifferentExtensionHost;
  }
  get isActive() {
    return __privateGet(this, _extensionService).isActivated(__privateGet(this, _identifier));
  }
  get exports() {
    if (this.packageJSON.api === "none" || this.isFromDifferentExtensionHost) {
      return void 0;
    }
    return __privateGet(this, _extensionService).getExtensionExports(__privateGet(this, _identifier));
  }
  async activate() {
    if (this.isFromDifferentExtensionHost) {
      throw new Error("Cannot activate foreign extension");
    }
    await __privateGet(this, _extensionService).activateByIdWithErrors(__privateGet(this, _identifier), { startup: false, extensionId: __privateGet(this, _originExtensionId), activationEvent: "api" });
    return this.exports;
  }
};
_extensionService = new WeakMap();
_originExtensionId = new WeakMap();
_identifier = new WeakMap();
function filterExtensions(globalRegistry, desiredExtensions) {
  return globalRegistry.getAllExtensionDescriptions().filter((extension) => desiredExtensions.has(extension.identifier));
}
var ExtensionPaths = class {
  constructor(_searchTree) {
    this._searchTree = _searchTree;
  }
  setSearchTree(searchTree) {
    this._searchTree = searchTree;
  }
  findSubstr(key) {
    return this._searchTree.findSubstr(key);
  }
  forEach(callback) {
    return this._searchTree.forEach(callback);
  }
};
var SyncedActivationEventsReader = class {
  constructor(activationEvents) {
    this._map = new ExtensionIdentifierMap();
    this.addActivationEvents(activationEvents);
  }
  readActivationEvents(extensionDescription) {
    return this._map.get(extensionDescription.identifier);
  }
  addActivationEvents(activationEvents) {
    for (const extensionId of Object.keys(activationEvents)) {
      this._map.set(extensionId, activationEvents[extensionId]);
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js
init_cancellation();
init_errors();
init_event();
init_uri();
init_editorOptions();
init_model();
init_languageConfiguration();
init_files();
init_extHost_protocol();
init_extensionHostProtocol();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostApiCommands.js
init_arrays();
init_network();
init_uri();
init_languages();
init_contextkey();
init_opener();
init_extHostTypes();
var newCommands = [
  new ApiCommand(
    "vscode.executeDocumentHighlights",
    "_executeDocumentHighlights",
    "Execute document highlight provider.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult(
      "A promise that resolves to an array of DocumentHighlight-instances.",
      tryMapWith(DocumentHighlight2.to)
    )
  ),
  new ApiCommand(
    "vscode.executeDocumentSymbolProvider",
    "_executeDocumentSymbolProvider",
    "Execute document symbol provider.",
    [ApiCommandArgument.Uri],
    new ApiCommandResult(
      "A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.",
      (value, apiArgs) => {
        if (isFalsyOrEmpty(value)) {
          return void 0;
        }
        class MergedInfo extends SymbolInformation {
          static to(symbol) {
            const res = new MergedInfo(
              symbol.name,
              SymbolKind2.to(symbol.kind),
              symbol.containerName || "",
              new Location(apiArgs[0], Range3.to(symbol.range))
            );
            res.detail = symbol.detail;
            res.range = res.location.range;
            res.selectionRange = Range3.to(symbol.selectionRange);
            res.children = symbol.children ? symbol.children.map(MergedInfo.to) : [];
            return res;
          }
        }
        return value.map(MergedInfo.to);
      }
    )
  ),
  new ApiCommand(
    "vscode.executeFormatDocumentProvider",
    "_executeFormatDocumentProvider",
    "Execute document format provider.",
    [ApiCommandArgument.Uri, new ApiCommandArgument("options", "Formatting options", (_) => true, (v) => v)],
    new ApiCommandResult(
      "A promise that resolves to an array of TextEdits.",
      tryMapWith(TextEdit2.to)
    )
  ),
  new ApiCommand(
    "vscode.executeFormatRangeProvider",
    "_executeFormatRangeProvider",
    "Execute range format provider.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Range, new ApiCommandArgument("options", "Formatting options", (_) => true, (v) => v)],
    new ApiCommandResult(
      "A promise that resolves to an array of TextEdits.",
      tryMapWith(TextEdit2.to)
    )
  ),
  new ApiCommand(
    "vscode.executeFormatOnTypeProvider",
    "_executeFormatOnTypeProvider",
    "Execute format on type provider.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position, new ApiCommandArgument("ch", "Trigger character", (v) => typeof v === "string", (v) => v), new ApiCommandArgument("options", "Formatting options", (_) => true, (v) => v)],
    new ApiCommandResult(
      "A promise that resolves to an array of TextEdits.",
      tryMapWith(TextEdit2.to)
    )
  ),
  new ApiCommand(
    "vscode.executeDefinitionProvider",
    "_executeDefinitionProvider",
    "Execute all definition providers.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult(
      "A promise that resolves to an array of Location or LocationLink instances.",
      mapLocationOrLocationLink
    )
  ),
  new ApiCommand(
    "vscode.executeTypeDefinitionProvider",
    "_executeTypeDefinitionProvider",
    "Execute all type definition providers.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult(
      "A promise that resolves to an array of Location or LocationLink instances.",
      mapLocationOrLocationLink
    )
  ),
  new ApiCommand(
    "vscode.executeDeclarationProvider",
    "_executeDeclarationProvider",
    "Execute all declaration providers.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult(
      "A promise that resolves to an array of Location or LocationLink instances.",
      mapLocationOrLocationLink
    )
  ),
  new ApiCommand(
    "vscode.executeImplementationProvider",
    "_executeImplementationProvider",
    "Execute all implementation providers.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult(
      "A promise that resolves to an array of Location or LocationLink instances.",
      mapLocationOrLocationLink
    )
  ),
  new ApiCommand(
    "vscode.executeReferenceProvider",
    "_executeReferenceProvider",
    "Execute all reference providers.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult(
      "A promise that resolves to an array of Location-instances.",
      tryMapWith(location.to)
    )
  ),
  new ApiCommand(
    "vscode.executeHoverProvider",
    "_executeHoverProvider",
    "Execute all hover providers.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult(
      "A promise that resolves to an array of Hover-instances.",
      tryMapWith(Hover2.to)
    )
  ),
  new ApiCommand(
    "vscode.executeSelectionRangeProvider",
    "_executeSelectionRangeProvider",
    "Execute selection range provider.",
    [ApiCommandArgument.Uri, new ApiCommandArgument(
      "position",
      "A position in a text document",
      (v) => Array.isArray(v) && v.every((v2) => Position2.isPosition(v2)),
      (v) => v.map(Position3.from)
    )],
    new ApiCommandResult("A promise that resolves to an array of ranges.", (result) => {
      return result.map((ranges) => {
        let node;
        for (const range of ranges.reverse()) {
          node = new SelectionRange(Range3.to(range), node);
        }
        return node;
      });
    })
  ),
  new ApiCommand(
    "vscode.executeWorkspaceSymbolProvider",
    "_executeWorkspaceSymbolProvider",
    "Execute all workspace symbol providers.",
    [ApiCommandArgument.String.with("query", "Search string")],
    new ApiCommandResult(
      "A promise that resolves to an array of SymbolInformation-instances.",
      (value) => {
        return value.map(WorkspaceSymbol.to);
      }
    )
  ),
  new ApiCommand(
    "vscode.prepareCallHierarchy",
    "_executePrepareCallHierarchy",
    "Prepare call hierarchy at a position inside a document",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult(
      "A promise that resolves to an array of CallHierarchyItem-instances",
      (v) => v.map(CallHierarchyItem2.to)
    )
  ),
  new ApiCommand(
    "vscode.provideIncomingCalls",
    "_executeProvideIncomingCalls",
    "Compute incoming calls for an item",
    [ApiCommandArgument.CallHierarchyItem],
    new ApiCommandResult(
      "A promise that resolves to an array of CallHierarchyIncomingCall-instances",
      (v) => v.map(CallHierarchyIncomingCall2.to)
    )
  ),
  new ApiCommand(
    "vscode.provideOutgoingCalls",
    "_executeProvideOutgoingCalls",
    "Compute outgoing calls for an item",
    [ApiCommandArgument.CallHierarchyItem],
    new ApiCommandResult(
      "A promise that resolves to an array of CallHierarchyOutgoingCall-instances",
      (v) => v.map(CallHierarchyOutgoingCall2.to)
    )
  ),
  new ApiCommand(
    "vscode.prepareRename",
    "_executePrepareRename",
    "Execute the prepareRename of rename provider.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult("A promise that resolves to a range and placeholder text.", (value) => {
      if (!value) {
        return void 0;
      }
      return {
        range: Range3.to(value.range),
        placeholder: value.text
      };
    })
  ),
  new ApiCommand(
    "vscode.executeDocumentRenameProvider",
    "_executeDocumentRenameProvider",
    "Execute rename provider.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position, ApiCommandArgument.String.with("newName", "The new symbol name")],
    new ApiCommandResult("A promise that resolves to a WorkspaceEdit.", (value) => {
      if (!value) {
        return void 0;
      }
      if (value.rejectReason) {
        throw new Error(value.rejectReason);
      }
      return WorkspaceEdit2.to(value);
    })
  ),
  new ApiCommand(
    "vscode.executeLinkProvider",
    "_executeLinkProvider",
    "Execute document link provider.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Number.with("linkResolveCount", "Number of links that should be resolved, only when links are unresolved.").optional()],
    new ApiCommandResult(
      "A promise that resolves to an array of DocumentLink-instances.",
      (value) => value.map(DocumentLink2.to)
    )
  ),
  new ApiCommand(
    "vscode.provideDocumentSemanticTokensLegend",
    "_provideDocumentSemanticTokensLegend",
    "Provide semantic tokens legend for a document",
    [ApiCommandArgument.Uri],
    new ApiCommandResult("A promise that resolves to SemanticTokensLegend.", (value) => {
      if (!value) {
        return void 0;
      }
      return new SemanticTokensLegend(value.tokenTypes, value.tokenModifiers);
    })
  ),
  new ApiCommand(
    "vscode.provideDocumentSemanticTokens",
    "_provideDocumentSemanticTokens",
    "Provide semantic tokens for a document",
    [ApiCommandArgument.Uri],
    new ApiCommandResult("A promise that resolves to SemanticTokens.", (value) => {
      if (!value) {
        return void 0;
      }
      const semanticTokensDto = decodeSemanticTokensDto(value);
      if (semanticTokensDto.type !== "full") {
        return void 0;
      }
      return new SemanticTokens(semanticTokensDto.data, void 0);
    })
  ),
  new ApiCommand(
    "vscode.provideDocumentRangeSemanticTokensLegend",
    "_provideDocumentRangeSemanticTokensLegend",
    "Provide semantic tokens legend for a document range",
    [ApiCommandArgument.Uri, ApiCommandArgument.Range.optional()],
    new ApiCommandResult("A promise that resolves to SemanticTokensLegend.", (value) => {
      if (!value) {
        return void 0;
      }
      return new SemanticTokensLegend(value.tokenTypes, value.tokenModifiers);
    })
  ),
  new ApiCommand(
    "vscode.provideDocumentRangeSemanticTokens",
    "_provideDocumentRangeSemanticTokens",
    "Provide semantic tokens for a document range",
    [ApiCommandArgument.Uri, ApiCommandArgument.Range],
    new ApiCommandResult("A promise that resolves to SemanticTokens.", (value) => {
      if (!value) {
        return void 0;
      }
      const semanticTokensDto = decodeSemanticTokensDto(value);
      if (semanticTokensDto.type !== "full") {
        return void 0;
      }
      return new SemanticTokens(semanticTokensDto.data, void 0);
    })
  ),
  new ApiCommand(
    "vscode.executeCompletionItemProvider",
    "_executeCompletionItemProvider",
    "Execute completion item provider.",
    [
      ApiCommandArgument.Uri,
      ApiCommandArgument.Position,
      ApiCommandArgument.String.with("triggerCharacter", "Trigger completion when the user types the character, like `,` or `(`").optional(),
      ApiCommandArgument.Number.with("itemResolveCount", "Number of completions to resolve (too large numbers slow down completions)").optional()
    ],
    new ApiCommandResult(
      "A promise that resolves to a CompletionList-instance.",
      (value, _args, converter) => {
        if (!value) {
          return new CompletionList([]);
        }
        const items = value.suggestions.map((suggestion) => CompletionItem2.to(suggestion, converter));
        return new CompletionList(items, value.incomplete);
      }
    )
  ),
  new ApiCommand(
    "vscode.executeSignatureHelpProvider",
    "_executeSignatureHelpProvider",
    "Execute signature help provider.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position, ApiCommandArgument.String.with("triggerCharacter", "Trigger signature help when the user types the character, like `,` or `(`").optional()],
    new ApiCommandResult("A promise that resolves to SignatureHelp.", (value) => {
      if (value) {
        return SignatureHelp2.to(value);
      }
      return void 0;
    })
  ),
  new ApiCommand(
    "vscode.executeCodeLensProvider",
    "_executeCodeLensProvider",
    "Execute code lens provider.",
    [ApiCommandArgument.Uri, ApiCommandArgument.Number.with("itemResolveCount", "Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)").optional()],
    new ApiCommandResult(
      "A promise that resolves to an array of CodeLens-instances.",
      (value, _args, converter) => {
        return tryMapWith((item) => {
          return new CodeLens(Range3.to(item.range), item.command && converter.fromInternal(item.command));
        })(value);
      }
    )
  ),
  new ApiCommand(
    "vscode.executeCodeActionProvider",
    "_executeCodeActionProvider",
    "Execute code action provider.",
    [
      ApiCommandArgument.Uri,
      new ApiCommandArgument(
        "rangeOrSelection",
        "Range in a text document. Some refactoring provider requires Selection object.",
        (v) => Range2.isRange(v),
        (v) => Selection.isSelection(v) ? Selection3.from(v) : Range3.from(v)
      ),
      ApiCommandArgument.String.with("kind", "Code action kind to return code actions for").optional(),
      ApiCommandArgument.Number.with("itemResolveCount", "Number of code actions to resolve (too large numbers slow down code actions)").optional()
    ],
    new ApiCommandResult(
      "A promise that resolves to an array of Command-instances.",
      (value, _args, converter) => {
        return tryMapWith((codeAction) => {
          if (codeAction._isSynthetic) {
            if (!codeAction.command) {
              throw new Error("Synthetic code actions must have a command");
            }
            return converter.fromInternal(codeAction.command);
          } else {
            const ret = new CodeAction(codeAction.title, codeAction.kind ? new CodeActionKind(codeAction.kind) : void 0);
            if (codeAction.edit) {
              ret.edit = WorkspaceEdit2.to(codeAction.edit);
            }
            if (codeAction.command) {
              ret.command = converter.fromInternal(codeAction.command);
            }
            ret.isPreferred = codeAction.isPreferred;
            return ret;
          }
        })(value);
      }
    )
  ),
  new ApiCommand(
    "vscode.executeDocumentColorProvider",
    "_executeDocumentColorProvider",
    "Execute document color provider.",
    [ApiCommandArgument.Uri],
    new ApiCommandResult(
      "A promise that resolves to an array of ColorInformation objects.",
      (result) => {
        if (result) {
          return result.map(
            (ci) => new ColorInformation(Range3.to(ci.range), Color3.to(ci.color))
          );
        }
        return [];
      }
    )
  ),
  new ApiCommand(
    "vscode.executeColorPresentationProvider",
    "_executeColorPresentationProvider",
    "Execute color presentation provider.",
    [
      new ApiCommandArgument(
        "color",
        "The color to show and insert",
        (v) => v instanceof Color,
        Color3.from
      ),
      new ApiCommandArgument(
        "context",
        "Context object with uri and range",
        (_v) => true,
        (v) => ({ uri: v.uri, range: Range3.from(v.range) })
      )
    ],
    new ApiCommandResult(
      "A promise that resolves to an array of ColorPresentation objects.",
      (result) => {
        if (result) {
          return result.map(ColorPresentation2.to);
        }
        return [];
      }
    )
  ),
  new ApiCommand(
    "vscode.executeInlayHintProvider",
    "_executeInlayHintProvider",
    "Execute inlay hints provider",
    [ApiCommandArgument.Uri, ApiCommandArgument.Range],
    new ApiCommandResult(
      "A promise that resolves to an array of Inlay objects",
      (result, args, converter) => {
        return result.map(InlayHint2.to.bind(void 0, converter));
      }
    )
  ),
  new ApiCommand(
    "vscode.executeFoldingRangeProvider",
    "_executeFoldingRangeProvider",
    "Execute folding range provider",
    [ApiCommandArgument.Uri],
    new ApiCommandResult(
      "A promise that resolves to an array of FoldingRange objects",
      (result, args) => {
        if (result) {
          return result.map(FoldingRange2.to);
        }
        return void 0;
      }
    )
  ),
  new ApiCommand(
    "vscode.resolveNotebookContentProviders",
    "_resolveNotebookContentProvider",
    "Resolve Notebook Content Providers",
    [],
    new ApiCommandResult(
      "A promise that resolves to an array of NotebookContentProvider static info objects.",
      tryMapWith((item) => {
        return {
          viewType: item.viewType,
          displayName: item.displayName,
          options: {
            transientOutputs: item.options.transientOutputs,
            transientCellMetadata: item.options.transientCellMetadata,
            transientDocumentMetadata: item.options.transientDocumentMetadata
          },
          filenamePattern: item.filenamePattern.map((pattern) => NotebookExclusiveDocumentPattern.to(pattern))
        };
      })
    )
  ),
  new ApiCommand(
    "vscode.executeInlineValueProvider",
    "_executeInlineValueProvider",
    "Execute inline value provider",
    [ApiCommandArgument.Uri, ApiCommandArgument.Range],
    new ApiCommandResult("A promise that resolves to an array of InlineValue objects", (result) => {
      return result.map(InlineValue.to);
    })
  ),
  new ApiCommand(
    "vscode.open",
    "_workbench.open",
    "Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.",
    [
      new ApiCommandArgument(
        "uriOrString",
        "Uri-instance or string (only http/https)",
        (v) => URI.isUri(v) || typeof v === "string" && matchesSomeScheme(v, Schemas.http, Schemas.https),
        (v) => v
      ),
      new ApiCommandArgument(
        "columnOrOptions",
        "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
        (v) => v === void 0 || typeof v === "number" || typeof v === "object",
        (v) => !v ? v : typeof v === "number" ? [ViewColumn2.from(v), void 0] : [ViewColumn2.from(v.viewColumn), TextEditorOpenOptions.from(v)]
      ).optional(),
      ApiCommandArgument.String.with("label", "").optional()
    ],
    ApiCommandResult.Void
  ),
  new ApiCommand(
    "vscode.openWith",
    "_workbench.openWith",
    "Opens the provided resource with a specific editor.",
    [
      ApiCommandArgument.Uri.with("resource", "Resource to open"),
      ApiCommandArgument.String.with("viewId", "Custom editor view id or 'default' to use VS Code's default editor"),
      new ApiCommandArgument(
        "columnOrOptions",
        "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
        (v) => v === void 0 || typeof v === "number" || typeof v === "object",
        (v) => !v ? v : typeof v === "number" ? [ViewColumn2.from(v), void 0] : [ViewColumn2.from(v.viewColumn), TextEditorOpenOptions.from(v)]
      ).optional()
    ],
    ApiCommandResult.Void
  ),
  new ApiCommand(
    "vscode.diff",
    "_workbench.diff",
    "Opens the provided resources in the diff editor to compare their contents.",
    [
      ApiCommandArgument.Uri.with("left", "Left-hand side resource of the diff editor"),
      ApiCommandArgument.Uri.with("right", "Right-hand side resource of the diff editor"),
      ApiCommandArgument.String.with("title", "Human readable title for the diff editor").optional(),
      new ApiCommandArgument(
        "columnOrOptions",
        "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
        (v) => v === void 0 || typeof v === "object",
        (v) => v && [ViewColumn2.from(v.viewColumn), TextEditorOpenOptions.from(v)]
      ).optional()
    ],
    ApiCommandResult.Void
  ),
  new ApiCommand(
    "vscode.prepareTypeHierarchy",
    "_executePrepareTypeHierarchy",
    "Prepare type hierarchy at a position inside a document",
    [ApiCommandArgument.Uri, ApiCommandArgument.Position],
    new ApiCommandResult(
      "A promise that resolves to an array of TypeHierarchyItem-instances",
      (v) => v.map(TypeHierarchyItem2.to)
    )
  ),
  new ApiCommand(
    "vscode.provideSupertypes",
    "_executeProvideSupertypes",
    "Compute supertypes for an item",
    [ApiCommandArgument.TypeHierarchyItem],
    new ApiCommandResult(
      "A promise that resolves to an array of TypeHierarchyItem-instances",
      (v) => v.map(TypeHierarchyItem2.to)
    )
  ),
  new ApiCommand(
    "vscode.provideSubtypes",
    "_executeProvideSubtypes",
    "Compute subtypes for an item",
    [ApiCommandArgument.TypeHierarchyItem],
    new ApiCommandResult(
      "A promise that resolves to an array of TypeHierarchyItem-instances",
      (v) => v.map(TypeHierarchyItem2.to)
    )
  ),
  new ApiCommand(
    "vscode.revealTestInExplorer",
    "_revealTestInExplorer",
    "Reveals a test instance in the explorer",
    [ApiCommandArgument.TestItem],
    ApiCommandResult.Void
  ),
  new ApiCommand(
    "vscode.experimental.editSession.continue",
    "_workbench.editSessions.actions.continueEditSession",
    "Continue the current edit session in a different workspace",
    [ApiCommandArgument.Uri.with("workspaceUri", "The target workspace to continue the current edit session in")],
    ApiCommandResult.Void
  ),
  new ApiCommand(
    "setContext",
    "_setContext",
    "Set a custom context key value that can be used in when clauses.",
    [
      ApiCommandArgument.String.with("name", "The context key name"),
      new ApiCommandArgument("value", "The context key value", () => true, (v) => v)
    ],
    ApiCommandResult.Void
  ),
  new ApiCommand(
    "vscode.executeMappedEditsProvider",
    "_executeMappedEditsProvider",
    "Execute Mapped Edits Provider",
    [
      ApiCommandArgument.Uri,
      ApiCommandArgument.StringArray,
      new ApiCommandArgument(
        "MappedEditsContext",
        "Mapped Edits Context",
        (v) => MappedEditsContext.is(v),
        (v) => MappedEditsContext.from(v)
      )
    ],
    new ApiCommandResult("A promise that resolves to a workspace edit or null", (value) => {
      return value ? WorkspaceEdit2.to(value) : null;
    })
  )
];
var ExtHostApiCommands = class {
  static register(commands) {
    newCommands.forEach(commands.registerApiCommand, commands);
    this._registerValidateWhenClausesCommand(commands);
  }
  static _registerValidateWhenClausesCommand(commands) {
    commands.registerCommand(false, "_validateWhenClauses", validateWhenClauses);
  }
};
function tryMapWith(f) {
  return (value) => {
    if (Array.isArray(value)) {
      return value.map(f);
    }
    return void 0;
  };
}
function mapLocationOrLocationLink(values) {
  if (!Array.isArray(values)) {
    return void 0;
  }
  const result = [];
  for (const item of values) {
    if (isLocationLink(item)) {
      result.push(DefinitionLink.to(item));
    } else {
      result.push(location.to(item));
    }
  }
  return result;
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostClipboard.js
init_extHost_protocol();
var ExtHostClipboard = class {
  constructor(mainContext) {
    const proxy = mainContext.getProxy(MainContext.MainThreadClipboard);
    this.value = Object.freeze({
      readText() {
        return proxy.$readText();
      },
      writeText(value) {
        return proxy.$writeText(value);
      }
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostComments.js
init_tslib_es6();
init_async();
init_event();
init_lifecycle();
init_uri();
init_languages();
init_extensions();
init_extHostTypes();
init_extHost_protocol();
function createExtHostComments(mainContext, commands, documents) {
  const proxy = mainContext.getProxy(MainContext.MainThreadComments);
  const _ExtHostCommentsImpl = class _ExtHostCommentsImpl {
    constructor() {
      this._commentControllers = /* @__PURE__ */ new Map();
      this._commentControllersByExtension = new ExtensionIdentifierMap();
      commands.registerArgumentProcessor({
        processArgument: (arg) => {
          if (arg && arg.$mid === 6) {
            const commentController = this._commentControllers.get(arg.handle);
            if (!commentController) {
              return arg;
            }
            return commentController.value;
          } else if (arg && arg.$mid === 7) {
            const commentController = this._commentControllers.get(arg.commentControlHandle);
            if (!commentController) {
              return arg;
            }
            const commentThread = commentController.getCommentThread(arg.commentThreadHandle);
            if (!commentThread) {
              return arg;
            }
            return commentThread.value;
          } else if (arg && (arg.$mid === 9 || arg.$mid === 8)) {
            const commentController = this._commentControllers.get(arg.thread.commentControlHandle);
            if (!commentController) {
              return arg;
            }
            const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);
            if (!commentThread) {
              return arg;
            }
            if (arg.$mid === 8) {
              return commentThread.value;
            }
            return {
              thread: commentThread.value,
              text: arg.text
            };
          } else if (arg && arg.$mid === 10) {
            const commentController = this._commentControllers.get(arg.thread.commentControlHandle);
            if (!commentController) {
              return arg;
            }
            const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);
            if (!commentThread) {
              return arg;
            }
            const commentUniqueId = arg.commentUniqueId;
            const comment = commentThread.getCommentByUniqueId(commentUniqueId);
            if (!comment) {
              return arg;
            }
            return comment;
          } else if (arg && arg.$mid === 11) {
            const commentController = this._commentControllers.get(arg.thread.commentControlHandle);
            if (!commentController) {
              return arg;
            }
            const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);
            if (!commentThread) {
              return arg;
            }
            const body = arg.text;
            const commentUniqueId = arg.commentUniqueId;
            const comment = commentThread.getCommentByUniqueId(commentUniqueId);
            if (!comment) {
              return arg;
            }
            if (typeof comment.body === "string") {
              comment.body = body;
            } else {
              comment.body = new MarkdownString2(body);
            }
            return comment;
          }
          return arg;
        }
      });
    }
    createCommentController(extension, id, label) {
      const handle = _ExtHostCommentsImpl.handlePool++;
      const commentController = new ExtHostCommentController(extension, handle, id, label);
      this._commentControllers.set(commentController.handle, commentController);
      const commentControllers = this._commentControllersByExtension.get(extension.identifier) || [];
      commentControllers.push(commentController);
      this._commentControllersByExtension.set(extension.identifier, commentControllers);
      return commentController.value;
    }
    $createCommentThreadTemplate(commentControllerHandle, uriComponents, range) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      if (!commentController) {
        return;
      }
      commentController.$createCommentThreadTemplate(uriComponents, range);
    }
    async $updateCommentThreadTemplate(commentControllerHandle, threadHandle, range) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      if (!commentController) {
        return;
      }
      commentController.$updateCommentThreadTemplate(threadHandle, range);
    }
    $deleteCommentThread(commentControllerHandle, commentThreadHandle) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      commentController == null ? void 0 : commentController.$deleteCommentThread(commentThreadHandle);
    }
    $provideCommentingRanges(commentControllerHandle, uriComponents, token) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      if (!commentController || !commentController.commentingRangeProvider) {
        return Promise.resolve(void 0);
      }
      const document2 = documents.getDocument(URI.revive(uriComponents));
      return asPromise(async () => {
        const rangesResult = await commentController.commentingRangeProvider.provideCommentingRanges(document2, token);
        let ranges;
        if (Array.isArray(rangesResult)) {
          ranges = {
            ranges: rangesResult,
            fileComments: false
          };
        } else if (rangesResult) {
          ranges = {
            ranges: rangesResult.ranges || [],
            fileComments: rangesResult.fileComments || false
          };
        } else {
          ranges = rangesResult ?? void 0;
        }
        return ranges;
      }).then((ranges) => {
        let convertedResult = void 0;
        if (ranges) {
          convertedResult = {
            ranges: ranges.ranges.map((x) => Range3.from(x)),
            fileComments: ranges.fileComments
          };
        }
        return convertedResult;
      });
    }
    $toggleReaction(commentControllerHandle, threadHandle, uri, comment, reaction) {
      const commentController = this._commentControllers.get(commentControllerHandle);
      if (!commentController || !commentController.reactionHandler) {
        return Promise.resolve(void 0);
      }
      return asPromise(() => {
        const commentThread = commentController.getCommentThread(threadHandle);
        if (commentThread) {
          const vscodeComment = commentThread.getCommentByUniqueId(comment.uniqueIdInThread);
          if (commentController !== void 0 && vscodeComment) {
            if (commentController.reactionHandler) {
              return commentController.reactionHandler(vscodeComment, convertFromReaction(reaction));
            }
          }
        }
        return Promise.resolve(void 0);
      });
    }
  };
  _ExtHostCommentsImpl.handlePool = 0;
  let ExtHostCommentsImpl = _ExtHostCommentsImpl;
  const _ExtHostCommentThread = class _ExtHostCommentThread {
    set threadId(id) {
      this._id = id;
    }
    get threadId() {
      return this._id;
    }
    get id() {
      return this._id;
    }
    get resource() {
      return this._uri;
    }
    get uri() {
      return this._uri;
    }
    set range(range) {
      if (range === void 0 !== (this._range === void 0) || (!range || !this._range || !range.isEqual(this._range))) {
        this._range = range;
        this.modifications.range = range;
        this._onDidUpdateCommentThread.fire();
      }
    }
    get range() {
      return this._range;
    }
    set canReply(state) {
      if (this._canReply !== state) {
        this._canReply = state;
        this.modifications.canReply = state;
        this._onDidUpdateCommentThread.fire();
      }
    }
    get canReply() {
      return this._canReply;
    }
    get label() {
      return this._label;
    }
    set label(label) {
      this._label = label;
      this.modifications.label = label;
      this._onDidUpdateCommentThread.fire();
    }
    get contextValue() {
      return this._contextValue;
    }
    set contextValue(context) {
      this._contextValue = context;
      this.modifications.contextValue = context;
      this._onDidUpdateCommentThread.fire();
    }
    get comments() {
      return this._comments;
    }
    set comments(newComments) {
      this._comments = newComments;
      this.modifications.comments = newComments;
      this._onDidUpdateCommentThread.fire();
    }
    get collapsibleState() {
      return this._collapseState;
    }
    set collapsibleState(newState) {
      this._collapseState = newState;
      this.modifications.collapsibleState = newState;
      this._onDidUpdateCommentThread.fire();
    }
    get state() {
      return this._state;
    }
    set state(newState) {
      this._state = newState;
      this.modifications.state = newState;
      this._onDidUpdateCommentThread.fire();
    }
    get isDisposed() {
      return this._isDiposed;
    }
    constructor(commentControllerId, _commentControllerHandle, _id, _uri, _range, _comments, extensionDescription, _isTemplate) {
      this._commentControllerHandle = _commentControllerHandle;
      this._id = _id;
      this._uri = _uri;
      this._range = _range;
      this._comments = _comments;
      this.extensionDescription = extensionDescription;
      this._isTemplate = _isTemplate;
      this.handle = _ExtHostCommentThread._handlePool++;
      this.commentHandle = 0;
      this.modifications = /* @__PURE__ */ Object.create(null);
      this._onDidUpdateCommentThread = new Emitter();
      this.onDidUpdateCommentThread = this._onDidUpdateCommentThread.event;
      this._canReply = true;
      this._commentsMap = /* @__PURE__ */ new Map();
      this._acceptInputDisposables = new MutableDisposable();
      this._acceptInputDisposables.value = new DisposableStore();
      if (this._id === void 0) {
        this._id = `${commentControllerId}.${this.handle}`;
      }
      proxy.$createCommentThread(_commentControllerHandle, this.handle, this._id, this._uri, Range3.from(this._range), extensionDescription.identifier, this._isTemplate);
      this._localDisposables = [];
      this._isDiposed = false;
      this._localDisposables.push(this.onDidUpdateCommentThread(() => {
        this.eventuallyUpdateCommentThread();
      }));
      this.comments = _comments;
      this._localDisposables.push({
        dispose: () => {
          proxy.$deleteCommentThread(_commentControllerHandle, this.handle);
        }
      });
      const that = this;
      this.value = {
        get uri() {
          return that.uri;
        },
        get range() {
          return that.range;
        },
        set range(value) {
          that.range = value;
        },
        get comments() {
          return that.comments;
        },
        set comments(value) {
          that.comments = value;
        },
        get collapsibleState() {
          return that.collapsibleState;
        },
        set collapsibleState(value) {
          that.collapsibleState = value;
        },
        get canReply() {
          return that.canReply;
        },
        set canReply(state) {
          that.canReply = state;
        },
        get contextValue() {
          return that.contextValue;
        },
        set contextValue(value) {
          that.contextValue = value;
        },
        get label() {
          return that.label;
        },
        set label(value) {
          that.label = value;
        },
        get state() {
          return that.state;
        },
        set state(value) {
          that.state = value;
        },
        dispose: () => {
          that.dispose();
        }
      };
    }
    updateIsTemplate() {
      if (this._isTemplate) {
        this._isTemplate = false;
        this.modifications.isTemplate = false;
      }
    }
    eventuallyUpdateCommentThread() {
      if (this._isDiposed) {
        return;
      }
      this.updateIsTemplate();
      if (!this._acceptInputDisposables.value) {
        this._acceptInputDisposables.value = new DisposableStore();
      }
      const modified = (value) => Object.prototype.hasOwnProperty.call(this.modifications, value);
      const formattedModifications = {};
      if (modified("range")) {
        formattedModifications.range = Range3.from(this._range);
      }
      if (modified("label")) {
        formattedModifications.label = this.label;
      }
      if (modified("contextValue")) {
        formattedModifications.contextValue = this.contextValue ?? null;
      }
      if (modified("comments")) {
        formattedModifications.comments = this._comments.map(
          (cmt) => convertToDTOComment(this, cmt, this._commentsMap, this.extensionDescription)
        );
      }
      if (modified("collapsibleState")) {
        formattedModifications.collapseState = convertToCollapsibleState(this._collapseState);
      }
      if (modified("canReply")) {
        formattedModifications.canReply = this.canReply;
      }
      if (modified("state")) {
        formattedModifications.state = convertToState(this._state);
      }
      if (modified("isTemplate")) {
        formattedModifications.isTemplate = this._isTemplate;
      }
      this.modifications = {};
      proxy.$updateCommentThread(this._commentControllerHandle, this.handle, this._id, this._uri, formattedModifications);
    }
    getCommentByUniqueId(uniqueId) {
      for (const key of this._commentsMap) {
        const comment = key[0];
        const id = key[1];
        if (uniqueId === id) {
          return comment;
        }
      }
      return;
    }
    dispose() {
      this._isDiposed = true;
      this._acceptInputDisposables.dispose();
      this._localDisposables.forEach((disposable) => disposable.dispose());
    }
  };
  _ExtHostCommentThread._handlePool = 0;
  let ExtHostCommentThread = _ExtHostCommentThread;
  __decorate([
    debounce(100)
  ], ExtHostCommentThread.prototype, "eventuallyUpdateCommentThread", null);
  class ExtHostCommentController {
    get id() {
      return this._id;
    }
    get label() {
      return this._label;
    }
    get handle() {
      return this._handle;
    }
    get commentingRangeProvider() {
      return this._commentingRangeProvider;
    }
    set commentingRangeProvider(provider) {
      this._commentingRangeProvider = provider;
      proxy.$updateCommentingRanges(this.handle);
    }
    get reactionHandler() {
      return this._reactionHandler;
    }
    set reactionHandler(handler) {
      this._reactionHandler = handler;
      proxy.$updateCommentControllerFeatures(this.handle, { reactionHandler: !!handler });
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this._options = options;
      proxy.$updateCommentControllerFeatures(this.handle, { options: this._options });
    }
    constructor(_extension2, _handle4, _id, _label) {
      this._extension = _extension2;
      this._handle = _handle4;
      this._id = _id;
      this._label = _label;
      this._threads = /* @__PURE__ */ new Map();
      proxy.$registerCommentController(this.handle, _id, _label);
      const that = this;
      this.value = Object.freeze({
        id: that.id,
        label: that.label,
        get options() {
          return that.options;
        },
        set options(options) {
          that.options = options;
        },
        get commentingRangeProvider() {
          return that.commentingRangeProvider;
        },
        set commentingRangeProvider(commentingRangeProvider) {
          that.commentingRangeProvider = commentingRangeProvider;
        },
        get reactionHandler() {
          return that.reactionHandler;
        },
        set reactionHandler(handler) {
          that.reactionHandler = handler;
        },
        createCommentThread(uri, range, comments) {
          return that.createCommentThread(uri, range, comments).value;
        },
        dispose: () => {
          that.dispose();
        }
      });
      this._localDisposables = [];
      this._localDisposables.push({
        dispose: () => {
          proxy.$unregisterCommentController(this.handle);
        }
      });
    }
    createCommentThread(resource, range, comments) {
      if (range === void 0) {
        checkProposedApiEnabled(this._extension, "fileComments");
      }
      const commentThread = new ExtHostCommentThread(
        this.id,
        this.handle,
        void 0,
        resource,
        range,
        comments,
        this._extension,
        false
      );
      this._threads.set(commentThread.handle, commentThread);
      return commentThread;
    }
    $createCommentThreadTemplate(uriComponents, range) {
      const commentThread = new ExtHostCommentThread(
        this.id,
        this.handle,
        void 0,
        URI.revive(uriComponents),
        Range3.to(range),
        [],
        this._extension,
        true
      );
      commentThread.collapsibleState = CommentThreadCollapsibleState.Expanded;
      this._threads.set(commentThread.handle, commentThread);
      return commentThread;
    }
    $updateCommentThreadTemplate(threadHandle, range) {
      const thread = this._threads.get(threadHandle);
      if (thread) {
        thread.range = Range3.to(range);
      }
    }
    $deleteCommentThread(threadHandle) {
      const thread = this._threads.get(threadHandle);
      thread == null ? void 0 : thread.dispose();
      this._threads.delete(threadHandle);
    }
    getCommentThread(handle) {
      return this._threads.get(handle);
    }
    dispose() {
      this._threads.forEach((value) => {
        value.dispose();
      });
      this._localDisposables.forEach((disposable) => disposable.dispose());
    }
  }
  function convertToDTOComment(thread, vscodeComment, commentsMap, extension) {
    var _a30;
    let commentUniqueId = commentsMap.get(vscodeComment);
    if (!commentUniqueId) {
      commentUniqueId = ++thread.commentHandle;
      commentsMap.set(vscodeComment, commentUniqueId);
    }
    if (vscodeComment.state !== void 0) {
      checkProposedApiEnabled(extension, "commentsDraftState");
    }
    return {
      mode: vscodeComment.mode,
      contextValue: vscodeComment.contextValue,
      uniqueIdInThread: commentUniqueId,
      body: typeof vscodeComment.body === "string" ? vscodeComment.body : MarkdownString3.from(vscodeComment.body),
      userName: vscodeComment.author.name,
      userIconPath: vscodeComment.author.iconPath,
      label: vscodeComment.label,
      commentReactions: vscodeComment.reactions ? vscodeComment.reactions.map((reaction) => convertToReaction(reaction)) : void 0,
      state: vscodeComment.state,
      timestamp: (_a30 = vscodeComment.timestamp) == null ? void 0 : _a30.toJSON()
    };
  }
  function convertToReaction(reaction) {
    return {
      label: reaction.label,
      iconPath: reaction.iconPath ? pathOrURIToURI(reaction.iconPath) : void 0,
      count: reaction.count,
      hasReacted: reaction.authorHasReacted
    };
  }
  function convertFromReaction(reaction) {
    return {
      label: reaction.label || "",
      count: reaction.count || 0,
      iconPath: reaction.iconPath ? URI.revive(reaction.iconPath) : "",
      authorHasReacted: reaction.hasReacted || false
    };
  }
  function convertToCollapsibleState(kind) {
    if (kind !== void 0) {
      switch (kind) {
        case CommentThreadCollapsibleState2.Expanded:
          return CommentThreadCollapsibleState.Expanded;
        case CommentThreadCollapsibleState2.Collapsed:
          return CommentThreadCollapsibleState.Collapsed;
      }
    }
    return CommentThreadCollapsibleState.Collapsed;
  }
  function convertToState(kind) {
    if (kind !== void 0) {
      switch (kind) {
        case CommentThreadState2.Unresolved:
          return CommentThreadState.Unresolved;
        case CommentThreadState2.Resolved:
          return CommentThreadState.Resolved;
      }
    }
    return CommentThreadState.Unresolved;
  }
  return new ExtHostCommentsImpl();
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDiagnostics.js
init_tslib_es6();
init_nls();
init_uri();
init_extHost_protocol();
init_extHostTypes();
init_event();
init_log();
init_map();
var ExtHostDiagnostics_1;
var _proxy2, _onDidChangeDiagnostics, _data;
var _DiagnosticCollection = class _DiagnosticCollection {
  constructor(_name, _owner, _maxDiagnosticsTotal, _maxDiagnosticsPerFile, _modelVersionIdProvider, extUri2, proxy, onDidChangeDiagnostics) {
    __privateAdd(this, _proxy2, void 0);
    __privateAdd(this, _onDidChangeDiagnostics, void 0);
    __privateAdd(this, _data, void 0);
    this._name = _name;
    this._owner = _owner;
    this._maxDiagnosticsTotal = _maxDiagnosticsTotal;
    this._maxDiagnosticsPerFile = _maxDiagnosticsPerFile;
    this._modelVersionIdProvider = _modelVersionIdProvider;
    this._isDisposed = false;
    this._maxDiagnosticsTotal = Math.max(_maxDiagnosticsPerFile, _maxDiagnosticsTotal);
    __privateSet(this, _data, new ResourceMap((uri) => extUri2.getComparisonKey(uri)));
    __privateSet(this, _proxy2, proxy);
    __privateSet(this, _onDidChangeDiagnostics, onDidChangeDiagnostics);
  }
  dispose() {
    var _a30;
    if (!this._isDisposed) {
      __privateGet(this, _onDidChangeDiagnostics).fire([...__privateGet(this, _data).keys()]);
      (_a30 = __privateGet(this, _proxy2)) == null ? void 0 : _a30.$clear(this._owner);
      __privateGet(this, _data).clear();
      this._isDisposed = true;
    }
  }
  get name() {
    this._checkDisposed();
    return this._name;
  }
  set(first, diagnostics) {
    if (!first) {
      this.clear();
      return;
    }
    this._checkDisposed();
    let toSync = [];
    if (URI.isUri(first)) {
      if (!diagnostics) {
        this.delete(first);
        return;
      }
      __privateGet(this, _data).set(first, diagnostics.slice());
      toSync = [first];
    } else if (Array.isArray(first)) {
      toSync = [];
      let lastUri;
      first = [...first].sort(_DiagnosticCollection._compareIndexedTuplesByUri);
      for (const tuple of first) {
        const [uri, diagnostics2] = tuple;
        if (!lastUri || uri.toString() !== lastUri.toString()) {
          if (lastUri && __privateGet(this, _data).get(lastUri).length === 0) {
            __privateGet(this, _data).delete(lastUri);
          }
          lastUri = uri;
          toSync.push(uri);
          __privateGet(this, _data).set(uri, []);
        }
        if (!diagnostics2) {
          const currentDiagnostics = __privateGet(this, _data).get(uri);
          if (currentDiagnostics) {
            currentDiagnostics.length = 0;
          }
        } else {
          const currentDiagnostics = __privateGet(this, _data).get(uri);
          currentDiagnostics == null ? void 0 : currentDiagnostics.push(...diagnostics2);
        }
      }
    }
    __privateGet(this, _onDidChangeDiagnostics).fire(toSync);
    if (!__privateGet(this, _proxy2)) {
      return;
    }
    const entries = [];
    let totalMarkerCount = 0;
    for (const uri of toSync) {
      let marker = [];
      const diagnostics2 = __privateGet(this, _data).get(uri);
      if (diagnostics2) {
        if (diagnostics2.length > this._maxDiagnosticsPerFile) {
          marker = [];
          const order = [DiagnosticSeverity.Error, DiagnosticSeverity.Warning, DiagnosticSeverity.Information, DiagnosticSeverity.Hint];
          orderLoop:
            for (let i = 0; i < 4; i++) {
              for (const diagnostic of diagnostics2) {
                if (diagnostic.severity === order[i]) {
                  const len = marker.push({ ...Diagnostic2.from(diagnostic), modelVersionId: this._modelVersionIdProvider(uri) });
                  if (len === this._maxDiagnosticsPerFile) {
                    break orderLoop;
                  }
                }
              }
            }
          marker.push({
            severity: MarkerSeverity.Info,
            message: localize(
              { key: "limitHit", comment: ["amount of errors/warning skipped due to limits"] },
              "Not showing {0} further errors and warnings.",
              diagnostics2.length - this._maxDiagnosticsPerFile
            ),
            startLineNumber: marker[marker.length - 1].startLineNumber,
            startColumn: marker[marker.length - 1].startColumn,
            endLineNumber: marker[marker.length - 1].endLineNumber,
            endColumn: marker[marker.length - 1].endColumn
          });
        } else {
          marker = diagnostics2.map(
            (diag) => ({ ...Diagnostic2.from(diag), modelVersionId: this._modelVersionIdProvider(uri) })
          );
        }
      }
      entries.push([uri, marker]);
      totalMarkerCount += marker.length;
      if (totalMarkerCount > this._maxDiagnosticsTotal) {
        break;
      }
    }
    __privateGet(this, _proxy2).$changeMany(this._owner, entries);
  }
  delete(uri) {
    var _a30;
    this._checkDisposed();
    __privateGet(this, _onDidChangeDiagnostics).fire([uri]);
    __privateGet(this, _data).delete(uri);
    (_a30 = __privateGet(this, _proxy2)) == null ? void 0 : _a30.$changeMany(this._owner, [[uri, void 0]]);
  }
  clear() {
    var _a30;
    this._checkDisposed();
    __privateGet(this, _onDidChangeDiagnostics).fire([...__privateGet(this, _data).keys()]);
    __privateGet(this, _data).clear();
    (_a30 = __privateGet(this, _proxy2)) == null ? void 0 : _a30.$clear(this._owner);
  }
  forEach(callback, thisArg) {
    this._checkDisposed();
    for (const [uri, values] of this) {
      callback.call(thisArg, uri, values, this);
    }
  }
  *[Symbol.iterator]() {
    this._checkDisposed();
    for (const uri of __privateGet(this, _data).keys()) {
      yield [uri, this.get(uri)];
    }
  }
  get(uri) {
    this._checkDisposed();
    const result = __privateGet(this, _data).get(uri);
    if (Array.isArray(result)) {
      return Object.freeze(result.slice(0));
    }
    return [];
  }
  has(uri) {
    this._checkDisposed();
    return Array.isArray(__privateGet(this, _data).get(uri));
  }
  _checkDisposed() {
    if (this._isDisposed) {
      throw new Error("illegal state - object is disposed");
    }
  }
  static _compareIndexedTuplesByUri(a, b) {
    if (a[0].toString() < b[0].toString()) {
      return -1;
    } else if (a[0].toString() > b[0].toString()) {
      return 1;
    } else {
      return 0;
    }
  }
};
_proxy2 = new WeakMap();
_onDidChangeDiagnostics = new WeakMap();
_data = new WeakMap();
var DiagnosticCollection = _DiagnosticCollection;
var _a3;
var ExtHostDiagnostics = (_a3 = class {
  static _mapper(last) {
    const map = new ResourceMap();
    for (const uri of last) {
      map.set(uri, uri);
    }
    return { uris: Object.freeze(Array.from(map.values())) };
  }
  constructor(mainContext, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors) {
    this._logService = _logService;
    this._fileSystemInfoService = _fileSystemInfoService;
    this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
    this._collections = /* @__PURE__ */ new Map();
    this._onDidChangeDiagnostics = new DebounceEmitter({ merge: (all) => all.flat(), delay: 50 });
    this.onDidChangeDiagnostics = Event.map(this._onDidChangeDiagnostics.event, ExtHostDiagnostics_1._mapper);
    this._proxy = mainContext.getProxy(MainContext.MainThreadDiagnostics);
  }
  createDiagnosticCollection(extensionId, name) {
    const { _collections, _proxy: _proxy10, _onDidChangeDiagnostics: _onDidChangeDiagnostics2, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors } = this;
    const loggingProxy = new class {
      $changeMany(owner2, entries) {
        _proxy10.$changeMany(owner2, entries);
        _logService.trace("[DiagnosticCollection] change many (extension, owner, uris)", extensionId.value, owner2, entries.length === 0 ? "CLEARING" : entries);
      }
      $clear(owner2) {
        _proxy10.$clear(owner2);
        _logService.trace("[DiagnosticCollection] remove all (extension, owner)", extensionId.value, owner2);
      }
      dispose() {
        _proxy10.dispose();
      }
    }();
    let owner;
    if (!name) {
      name = "_generated_diagnostic_collection_name_#" + ExtHostDiagnostics_1._idPool++;
      owner = name;
    } else if (!_collections.has(name)) {
      owner = name;
    } else {
      this._logService.warn(`DiagnosticCollection with name '${name}' does already exist.`);
      do {
        owner = name + ExtHostDiagnostics_1._idPool++;
      } while (_collections.has(owner));
    }
    const result = new class extends DiagnosticCollection {
      constructor() {
        super(name, owner, ExtHostDiagnostics_1._maxDiagnosticsTotal, ExtHostDiagnostics_1._maxDiagnosticsPerFile, (uri) => {
          var _a30;
          return (_a30 = _extHostDocumentsAndEditors.getDocument(uri)) == null ? void 0 : _a30.version;
        }, _fileSystemInfoService.extUri, loggingProxy, _onDidChangeDiagnostics2);
        _collections.set(owner, this);
      }
      dispose() {
        super.dispose();
        _collections.delete(owner);
      }
    }();
    return result;
  }
  getDiagnostics(resource) {
    if (resource) {
      return this._getDiagnostics(resource);
    } else {
      const index = /* @__PURE__ */ new Map();
      const res = [];
      for (const collection of this._collections.values()) {
        collection.forEach((uri, diagnostics) => {
          let idx = index.get(uri.toString());
          if (typeof idx === "undefined") {
            idx = res.length;
            index.set(uri.toString(), idx);
            res.push([uri, []]);
          }
          res[idx][1] = res[idx][1].concat(...diagnostics);
        });
      }
      return res;
    }
  }
  _getDiagnostics(resource) {
    let res = [];
    for (const collection of this._collections.values()) {
      if (collection.has(resource)) {
        res = res.concat(collection.get(resource));
      }
    }
    return res;
  }
  $acceptMarkersChange(data) {
    if (!this._mirrorCollection) {
      const name = "_generated_mirror";
      const collection = new DiagnosticCollection(
        name,
        name,
        Number.MAX_SAFE_INTEGER,
        Number.MAX_SAFE_INTEGER,
        (_uri) => void 0,
        this._fileSystemInfoService.extUri,
        void 0,
        this._onDidChangeDiagnostics
      );
      this._collections.set(name, collection);
      this._mirrorCollection = collection;
    }
    for (const [uri, markers] of data) {
      this._mirrorCollection.set(URI.revive(uri), markers.map(Diagnostic2.to));
    }
  }
}, ExtHostDiagnostics_1 = _a3, _a3._idPool = 0, _a3._maxDiagnosticsPerFile = 1e3, _a3._maxDiagnosticsTotal = 1.1 * ExtHostDiagnostics_1._maxDiagnosticsPerFile, _a3);
ExtHostDiagnostics = ExtHostDiagnostics_1 = __decorate([
  __param(1, ILogService),
  __param(2, IExtHostFileSystemInfo)
], ExtHostDiagnostics);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDialogs.js
init_uri();
init_extHost_protocol();
var ExtHostDialogs = class {
  constructor(mainContext) {
    this._proxy = mainContext.getProxy(MainContext.MainThreadDialogs);
  }
  showOpenDialog(extension, options) {
    if (options == null ? void 0 : options.allowUIResources) {
      checkProposedApiEnabled(extension, "showLocal");
    }
    return this._proxy.$showOpenDialog(options).then((filepaths) => {
      return filepaths ? filepaths.map((p) => URI.revive(p)) : void 0;
    });
  }
  showSaveDialog(options) {
    return this._proxy.$showSaveDialog(options).then((filepath) => {
      return filepath ? URI.revive(filepath) : void 0;
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocumentContentProviders.js
init_errors();
init_uri();
init_extHostTypes();
init_extHost_protocol();
init_network();
init_cancellation();
init_strings();
var _ExtHostDocumentContentProvider = class _ExtHostDocumentContentProvider {
  constructor(mainContext, _documentsAndEditors, _logService) {
    this._documentsAndEditors = _documentsAndEditors;
    this._logService = _logService;
    this._documentContentProviders = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadDocumentContentProviders);
  }
  registerTextDocumentContentProvider(scheme, provider) {
    if (Object.keys(Schemas).indexOf(scheme) >= 0) {
      throw new Error(`scheme '${scheme}' already registered`);
    }
    const handle = _ExtHostDocumentContentProvider._handlePool++;
    this._documentContentProviders.set(handle, provider);
    this._proxy.$registerTextContentProvider(handle, scheme);
    let subscription;
    if (typeof provider.onDidChange === "function") {
      subscription = provider.onDidChange((uri) => {
        if (uri.scheme !== scheme) {
          this._logService.warn(`Provider for scheme '${scheme}' is firing event for schema '${uri.scheme}' which will be IGNORED`);
          return;
        }
        if (this._documentsAndEditors.getDocument(uri)) {
          this.$provideTextDocumentContent(handle, uri).then((value) => {
            if (!value && typeof value !== "string") {
              return;
            }
            const document2 = this._documentsAndEditors.getDocument(uri);
            if (!document2) {
              return;
            }
            const lines = splitLines(value);
            if (!document2.equalLines(lines)) {
              return this._proxy.$onVirtualDocumentChange(uri, value);
            }
          }, onUnexpectedError);
        }
      });
    }
    return new Disposable2(() => {
      if (this._documentContentProviders.delete(handle)) {
        this._proxy.$unregisterTextContentProvider(handle);
      }
      if (subscription) {
        subscription.dispose();
        subscription = void 0;
      }
    });
  }
  $provideTextDocumentContent(handle, uri) {
    const provider = this._documentContentProviders.get(handle);
    if (!provider) {
      return Promise.reject(new Error(`unsupported uri-scheme: ${uri.scheme}`));
    }
    return Promise.resolve(provider.provideTextDocumentContent(URI.revive(uri), CancellationToken.None));
  }
};
_ExtHostDocumentContentProvider._handlePool = 0;
var ExtHostDocumentContentProvider = _ExtHostDocumentContentProvider;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocumentSaveParticipant.js
init_uri();
init_errors();
init_extHostTypes();
init_linkedList();
var ExtHostDocumentSaveParticipant = class {
  constructor(_logService, _documents, _mainThreadBulkEdits, _thresholds = { timeout: 1500, errors: 3 }) {
    this._logService = _logService;
    this._documents = _documents;
    this._mainThreadBulkEdits = _mainThreadBulkEdits;
    this._thresholds = _thresholds;
    this._callbacks = new LinkedList();
    this._badListeners = /* @__PURE__ */ new WeakMap();
  }
  dispose() {
    this._callbacks.clear();
  }
  getOnWillSaveTextDocumentEvent(extension) {
    return (listener, thisArg, disposables) => {
      const remove = this._callbacks.push([listener, thisArg, extension]);
      const result = { dispose: remove };
      if (Array.isArray(disposables)) {
        disposables.push(result);
      }
      return result;
    };
  }
  async $participateInSave(data, reason) {
    const resource = URI.revive(data);
    let didTimeout = false;
    const didTimeoutHandle = setTimeout(() => didTimeout = true, this._thresholds.timeout);
    const results = [];
    try {
      for (const listener of [...this._callbacks]) {
        if (didTimeout) {
          break;
        }
        const document2 = this._documents.getDocument(resource);
        const success = await this._deliverEventAsyncAndBlameBadListeners(listener, { document: document2, reason: TextDocumentSaveReason2.to(reason) });
        results.push(success);
      }
    } finally {
      clearTimeout(didTimeoutHandle);
    }
    return results;
  }
  _deliverEventAsyncAndBlameBadListeners([listener, thisArg, extension], stubEvent) {
    const errors = this._badListeners.get(listener);
    if (typeof errors === "number" && errors > this._thresholds.errors) {
      return Promise.resolve(false);
    }
    return this._deliverEventAsync(extension, listener, thisArg, stubEvent).then(() => {
      return true;
    }, (err) => {
      this._logService.error(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' threw ERROR`);
      this._logService.error(err);
      if (!(err instanceof Error) || err.message !== "concurrent_edits") {
        const errors2 = this._badListeners.get(listener);
        this._badListeners.set(listener, !errors2 ? 1 : errors2 + 1);
        if (typeof errors2 === "number" && errors2 > this._thresholds.errors) {
          this._logService.info(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' will now be IGNORED because of timeouts and/or errors`);
        }
      }
      return false;
    });
  }
  _deliverEventAsync(extension, listener, thisArg, stubEvent) {
    const promises = [];
    const t1 = Date.now();
    const { document: document2, reason } = stubEvent;
    const { version } = document2;
    const event = Object.freeze({
      document: document2,
      reason,
      waitUntil(p) {
        if (Object.isFrozen(promises)) {
          throw illegalState("waitUntil can not be called async");
        }
        promises.push(Promise.resolve(p));
      }
    });
    try {
      listener.apply(thisArg, [event]);
    } catch (err) {
      return Promise.reject(err);
    }
    return new Promise((resolve, reject) => {
      const handle = setTimeout(() => reject(new Error("timeout")), this._thresholds.timeout);
      return Promise.all(promises).then((edits) => {
        this._logService.debug(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' finished after ${Date.now() - t1}ms`);
        clearTimeout(handle);
        resolve(edits);
      }).catch((err) => {
        clearTimeout(handle);
        reject(err);
      });
    }).then((values) => {
      const dto = { edits: [] };
      for (const value of values) {
        if (Array.isArray(value) && value.every((e) => e instanceof TextEdit)) {
          for (const { newText, newEol, range } of value) {
            dto.edits.push({
              resource: document2.uri,
              versionId: void 0,
              textEdit: {
                range: range && Range3.from(range),
                text: newText,
                eol: newEol && EndOfLine2.from(newEol)
              }
            });
          }
        }
      }
      if (dto.edits.length === 0) {
        return void 0;
      }
      if (version === document2.version) {
        return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(dto);
      }
      return Promise.reject(new Error("concurrent_edits"));
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocuments.js
init_event();
init_lifecycle();
init_uri();
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocumentData.js
init_assert();
init_network();
init_strings();
init_wordHelper();
init_extHostTypes();
init_arrays();
var _languageId2WordDefinition = /* @__PURE__ */ new Map();
function setWordDefinitionFor(languageId, wordDefinition) {
  if (!wordDefinition) {
    _languageId2WordDefinition.delete(languageId);
  } else {
    _languageId2WordDefinition.set(languageId, wordDefinition);
  }
}
function getWordDefinitionFor(languageId) {
  return _languageId2WordDefinition.get(languageId);
}
var ExtHostDocumentData = class extends MirrorTextModel {
  constructor(_proxy10, uri, lines, eol, versionId, _languageId, _isDirty, notebook) {
    super(uri, lines, eol, versionId);
    this._proxy = _proxy10;
    this._languageId = _languageId;
    this._isDirty = _isDirty;
    this.notebook = notebook;
    this._isDisposed = false;
  }
  dispose() {
    ok(!this._isDisposed);
    this._isDisposed = true;
    this._isDirty = false;
  }
  equalLines(lines) {
    return equals(this._lines, lines);
  }
  get document() {
    if (!this._document) {
      const that = this;
      this._document = {
        get uri() {
          return that._uri;
        },
        get fileName() {
          return that._uri.fsPath;
        },
        get isUntitled() {
          return that._uri.scheme === Schemas.untitled;
        },
        get languageId() {
          return that._languageId;
        },
        get version() {
          return that._versionId;
        },
        get isClosed() {
          return that._isDisposed;
        },
        get isDirty() {
          return that._isDirty;
        },
        save() {
          return that._save();
        },
        getText(range) {
          return range ? that._getTextInRange(range) : that.getText();
        },
        get eol() {
          return that._eol === "\n" ? EndOfLine.LF : EndOfLine.CRLF;
        },
        get lineCount() {
          return that._lines.length;
        },
        lineAt(lineOrPos) {
          return that._lineAt(lineOrPos);
        },
        offsetAt(pos) {
          return that._offsetAt(pos);
        },
        positionAt(offset) {
          return that._positionAt(offset);
        },
        validateRange(ran) {
          return that._validateRange(ran);
        },
        validatePosition(pos) {
          return that._validatePosition(pos);
        },
        getWordRangeAtPosition(pos, regexp) {
          return that._getWordRangeAtPosition(pos, regexp);
        }
      };
    }
    return Object.freeze(this._document);
  }
  _acceptLanguageId(newLanguageId) {
    ok(!this._isDisposed);
    this._languageId = newLanguageId;
  }
  _acceptIsDirty(isDirty) {
    ok(!this._isDisposed);
    this._isDirty = isDirty;
  }
  _save() {
    if (this._isDisposed) {
      return Promise.reject(new Error("Document has been closed"));
    }
    return this._proxy.$trySaveDocument(this._uri);
  }
  _getTextInRange(_range) {
    const range = this._validateRange(_range);
    if (range.isEmpty) {
      return "";
    }
    if (range.isSingleLine) {
      return this._lines[range.start.line].substring(range.start.character, range.end.character);
    }
    const lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];
    resultLines.push(this._lines[startLineIndex].substring(range.start.character));
    for (let i = startLineIndex + 1; i < endLineIndex; i++) {
      resultLines.push(this._lines[i]);
    }
    resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));
    return resultLines.join(lineEnding);
  }
  _lineAt(lineOrPosition) {
    let line;
    if (lineOrPosition instanceof Position2) {
      line = lineOrPosition.line;
    } else if (typeof lineOrPosition === "number") {
      line = lineOrPosition;
    }
    if (typeof line !== "number" || line < 0 || line >= this._lines.length || Math.floor(line) !== line) {
      throw new Error("Illegal value for `line`");
    }
    return new ExtHostDocumentLine(line, this._lines[line], line === this._lines.length - 1);
  }
  _offsetAt(position) {
    position = this._validatePosition(position);
    this._ensureLineStarts();
    return this._lineStarts.getPrefixSum(position.line - 1) + position.character;
  }
  _positionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    this._ensureLineStarts();
    const out = this._lineStarts.getIndexOf(offset);
    const lineLength = this._lines[out.index].length;
    return new Position2(out.index, Math.min(out.remainder, lineLength));
  }
  _validateRange(range) {
    if (!(range instanceof Range2)) {
      throw new Error("Invalid argument");
    }
    const start = this._validatePosition(range.start);
    const end = this._validatePosition(range.end);
    if (start === range.start && end === range.end) {
      return range;
    }
    return new Range2(start.line, start.character, end.line, end.character);
  }
  _validatePosition(position) {
    if (!(position instanceof Position2)) {
      throw new Error("Invalid argument");
    }
    if (this._lines.length === 0) {
      return position.with(0, 0);
    }
    let { line, character } = position;
    let hasChanged = false;
    if (line < 0) {
      line = 0;
      character = 0;
      hasChanged = true;
    } else if (line >= this._lines.length) {
      line = this._lines.length - 1;
      character = this._lines[line].length;
      hasChanged = true;
    } else {
      const maxCharacter = this._lines[line].length;
      if (character < 0) {
        character = 0;
        hasChanged = true;
      } else if (character > maxCharacter) {
        character = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    }
    return new Position2(line, character);
  }
  _getWordRangeAtPosition(_position, regexp) {
    const position = this._validatePosition(_position);
    if (!regexp) {
      regexp = getWordDefinitionFor(this._languageId);
    } else if (regExpLeadsToEndlessLoop(regexp)) {
      throw new Error(`[getWordRangeAtPosition]: ignoring custom regexp '${regexp.source}' because it matches the empty string.`);
    }
    const wordAtText = getWordAtText(position.character + 1, ensureValidWordDefinition(regexp), this._lines[position.line], 0);
    if (wordAtText) {
      return new Range2(
        position.line,
        wordAtText.startColumn - 1,
        position.line,
        wordAtText.endColumn - 1
      );
    }
    return void 0;
  }
};
var ExtHostDocumentLine = class {
  constructor(line, text, isLastLine) {
    this._line = line;
    this._text = text;
    this._isLastLine = isLastLine;
  }
  get lineNumber() {
    return this._line;
  }
  get text() {
    return this._text;
  }
  get range() {
    return new Range2(this._line, 0, this._line, this._text.length);
  }
  get rangeIncludingLineBreak() {
    if (this._isLastLine) {
      return this.range;
    }
    return new Range2(this._line, 0, this._line + 1, 0);
  }
  get firstNonWhitespaceCharacterIndex() {
    return /^(\s*)/.exec(this._text)[1].length;
  }
  get isEmptyOrWhitespace() {
    return this.firstNonWhitespaceCharacterIndex === this._text.length;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocuments.js
init_types();
init_objects();
init_extHostTypes();
init_errors();
var ExtHostDocuments = class {
  constructor(mainContext, documentsAndEditors) {
    this._onDidAddDocument = new Emitter({ onListenerError: onUnexpectedExternalError });
    this._onDidRemoveDocument = new Emitter({ onListenerError: onUnexpectedExternalError });
    this._onDidChangeDocument = new Emitter({ onListenerError: onUnexpectedExternalError });
    this._onDidSaveDocument = new Emitter({ onListenerError: onUnexpectedExternalError });
    this.onDidAddDocument = this._onDidAddDocument.event;
    this.onDidRemoveDocument = this._onDidRemoveDocument.event;
    this.onDidChangeDocument = this._onDidChangeDocument.event;
    this.onDidSaveDocument = this._onDidSaveDocument.event;
    this._toDispose = new DisposableStore();
    this._documentLoader = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadDocuments);
    this._documentsAndEditors = documentsAndEditors;
    this._documentsAndEditors.onDidRemoveDocuments((documents) => {
      for (const data of documents) {
        this._onDidRemoveDocument.fire(data.document);
      }
    }, void 0, this._toDispose);
    this._documentsAndEditors.onDidAddDocuments((documents) => {
      for (const data of documents) {
        this._onDidAddDocument.fire(data.document);
      }
    }, void 0, this._toDispose);
  }
  dispose() {
    this._toDispose.dispose();
  }
  getAllDocumentData() {
    return [...this._documentsAndEditors.allDocuments()];
  }
  getDocumentData(resource) {
    if (!resource) {
      return void 0;
    }
    const data = this._documentsAndEditors.getDocument(resource);
    if (data) {
      return data;
    }
    return void 0;
  }
  getDocument(resource) {
    const data = this.getDocumentData(resource);
    if (!(data == null ? void 0 : data.document)) {
      throw new Error(`Unable to retrieve document from URI '${resource}'`);
    }
    return data.document;
  }
  ensureDocumentData(uri) {
    const cached = this._documentsAndEditors.getDocument(uri);
    if (cached) {
      return Promise.resolve(cached);
    }
    let promise = this._documentLoader.get(uri.toString());
    if (!promise) {
      promise = this._proxy.$tryOpenDocument(uri).then((uriData) => {
        this._documentLoader.delete(uri.toString());
        const canonicalUri = URI.revive(uriData);
        return assertIsDefined(this._documentsAndEditors.getDocument(canonicalUri));
      }, (err) => {
        this._documentLoader.delete(uri.toString());
        return Promise.reject(err);
      });
      this._documentLoader.set(uri.toString(), promise);
    }
    return promise;
  }
  createDocumentData(options) {
    return this._proxy.$tryCreateDocument(options).then((data) => URI.revive(data));
  }
  $acceptModelLanguageChanged(uriComponents, newLanguageId) {
    const uri = URI.revive(uriComponents);
    const data = this._documentsAndEditors.getDocument(uri);
    if (!data) {
      throw new Error("unknown document");
    }
    this._onDidRemoveDocument.fire(data.document);
    data._acceptLanguageId(newLanguageId);
    this._onDidAddDocument.fire(data.document);
  }
  $acceptModelSaved(uriComponents) {
    const uri = URI.revive(uriComponents);
    const data = this._documentsAndEditors.getDocument(uri);
    if (!data) {
      throw new Error("unknown document");
    }
    this.$acceptDirtyStateChanged(uriComponents, false);
    this._onDidSaveDocument.fire(data.document);
  }
  $acceptDirtyStateChanged(uriComponents, isDirty) {
    const uri = URI.revive(uriComponents);
    const data = this._documentsAndEditors.getDocument(uri);
    if (!data) {
      throw new Error("unknown document");
    }
    data._acceptIsDirty(isDirty);
    this._onDidChangeDocument.fire({
      document: data.document,
      contentChanges: [],
      reason: void 0
    });
  }
  $acceptModelChanged(uriComponents, events, isDirty) {
    const uri = URI.revive(uriComponents);
    const data = this._documentsAndEditors.getDocument(uri);
    if (!data) {
      throw new Error("unknown document");
    }
    data._acceptIsDirty(isDirty);
    data.onEvents(events);
    let reason = void 0;
    if (events.isUndoing) {
      reason = TextDocumentChangeReason.Undo;
    } else if (events.isRedoing) {
      reason = TextDocumentChangeReason.Redo;
    }
    this._onDidChangeDocument.fire(deepFreeze({
      document: data.document,
      contentChanges: events.changes.map((change) => {
        return {
          range: Range3.to(change.range),
          rangeOffset: change.rangeOffset,
          rangeLength: change.rangeLength,
          text: change.text
        };
      }),
      reason
    }));
  }
  setWordDefinitionFor(languageId, wordDefinition) {
    setWordDefinitionFor(languageId, wordDefinition);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocumentsAndEditors.js
init_tslib_es6();
init_assert();
init_event();
init_lifecycle();
init_uri();
init_instantiation();
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTextEditor.js
init_assert();
init_errors();
init_extHostTypes();
var _TextEditorDecorationType = class _TextEditorDecorationType {
  constructor(proxy, extension, options) {
    const key = _TextEditorDecorationType._Keys.nextId();
    proxy.$registerTextEditorDecorationType(extension.identifier, key, DecorationRenderOptions.from(options));
    this.value = Object.freeze({
      key,
      dispose() {
        proxy.$removeTextEditorDecorationType(key);
      }
    });
  }
};
_TextEditorDecorationType._Keys = new IdGenerator("TextEditorDecorationType");
var TextEditorDecorationType = _TextEditorDecorationType;
var TextEditorEdit = class {
  constructor(document2, options) {
    this._collectedEdits = [];
    this._setEndOfLine = void 0;
    this._finalized = false;
    this._document = document2;
    this._documentVersionId = document2.version;
    this._undoStopBefore = options.undoStopBefore;
    this._undoStopAfter = options.undoStopAfter;
  }
  finalize() {
    this._finalized = true;
    return {
      documentVersionId: this._documentVersionId,
      edits: this._collectedEdits,
      setEndOfLine: this._setEndOfLine,
      undoStopBefore: this._undoStopBefore,
      undoStopAfter: this._undoStopAfter
    };
  }
  _throwIfFinalized() {
    if (this._finalized) {
      throw new Error("Edit is only valid while callback runs");
    }
  }
  replace(location2, value) {
    this._throwIfFinalized();
    let range = null;
    if (location2 instanceof Position2) {
      range = new Range2(location2, location2);
    } else if (location2 instanceof Range2) {
      range = location2;
    } else {
      throw new Error("Unrecognized location");
    }
    this._pushEdit(range, value, false);
  }
  insert(location2, value) {
    this._throwIfFinalized();
    this._pushEdit(new Range2(location2, location2), value, true);
  }
  delete(location2) {
    this._throwIfFinalized();
    let range = null;
    if (location2 instanceof Range2) {
      range = location2;
    } else {
      throw new Error("Unrecognized location");
    }
    this._pushEdit(range, null, true);
  }
  _pushEdit(range, text, forceMoveMarkers) {
    const validRange = this._document.validateRange(range);
    this._collectedEdits.push({
      range: validRange,
      text,
      forceMoveMarkers
    });
  }
  setEndOfLine(endOfLine) {
    this._throwIfFinalized();
    if (endOfLine !== EndOfLine.LF && endOfLine !== EndOfLine.CRLF) {
      throw illegalArgument("endOfLine");
    }
    this._setEndOfLine = endOfLine;
  }
};
var ExtHostTextEditorOptions = class {
  constructor(proxy, id, source, logService) {
    this._proxy = proxy;
    this._id = id;
    this._accept(source);
    this._logService = logService;
    const that = this;
    this.value = {
      get tabSize() {
        return that._tabSize;
      },
      set tabSize(value) {
        that._setTabSize(value);
      },
      get indentSize() {
        return that._indentSize;
      },
      set indentSize(value) {
        that._setIndentSize(value);
      },
      get insertSpaces() {
        return that._insertSpaces;
      },
      set insertSpaces(value) {
        that._setInsertSpaces(value);
      },
      get cursorStyle() {
        return that._cursorStyle;
      },
      set cursorStyle(value) {
        that._setCursorStyle(value);
      },
      get lineNumbers() {
        return that._lineNumbers;
      },
      set lineNumbers(value) {
        that._setLineNumbers(value);
      }
    };
  }
  _accept(source) {
    this._tabSize = source.tabSize;
    this._indentSize = source.indentSize;
    this._insertSpaces = source.insertSpaces;
    this._cursorStyle = source.cursorStyle;
    this._lineNumbers = TextEditorLineNumbersStyle2.to(source.lineNumbers);
  }
  _validateTabSize(value) {
    if (value === "auto") {
      return "auto";
    }
    if (typeof value === "number") {
      const r = Math.floor(value);
      return r > 0 ? r : null;
    }
    if (typeof value === "string") {
      const r = parseInt(value, 10);
      if (isNaN(r)) {
        return null;
      }
      return r > 0 ? r : null;
    }
    return null;
  }
  _setTabSize(value) {
    const tabSize = this._validateTabSize(value);
    if (tabSize === null) {
      return;
    }
    if (typeof tabSize === "number") {
      if (this._tabSize === tabSize) {
        return;
      }
      this._tabSize = tabSize;
    }
    this._warnOnError("setTabSize", this._proxy.$trySetOptions(this._id, {
      tabSize
    }));
  }
  _validateIndentSize(value) {
    if (value === "tabSize") {
      return "tabSize";
    }
    if (typeof value === "number") {
      const r = Math.floor(value);
      return r > 0 ? r : null;
    }
    if (typeof value === "string") {
      const r = parseInt(value, 10);
      if (isNaN(r)) {
        return null;
      }
      return r > 0 ? r : null;
    }
    return null;
  }
  _setIndentSize(value) {
    const indentSize = this._validateIndentSize(value);
    if (indentSize === null) {
      return;
    }
    if (typeof indentSize === "number") {
      if (this._indentSize === indentSize) {
        return;
      }
      this._indentSize = indentSize;
    }
    this._warnOnError("setIndentSize", this._proxy.$trySetOptions(this._id, {
      indentSize
    }));
  }
  _validateInsertSpaces(value) {
    if (value === "auto") {
      return "auto";
    }
    return value === "false" ? false : Boolean(value);
  }
  _setInsertSpaces(value) {
    const insertSpaces = this._validateInsertSpaces(value);
    if (typeof insertSpaces === "boolean") {
      if (this._insertSpaces === insertSpaces) {
        return;
      }
      this._insertSpaces = insertSpaces;
    }
    this._warnOnError("setInsertSpaces", this._proxy.$trySetOptions(this._id, {
      insertSpaces
    }));
  }
  _setCursorStyle(value) {
    if (this._cursorStyle === value) {
      return;
    }
    this._cursorStyle = value;
    this._warnOnError("setCursorStyle", this._proxy.$trySetOptions(this._id, {
      cursorStyle: value
    }));
  }
  _setLineNumbers(value) {
    if (this._lineNumbers === value) {
      return;
    }
    this._lineNumbers = value;
    this._warnOnError("setLineNumbers", this._proxy.$trySetOptions(this._id, {
      lineNumbers: TextEditorLineNumbersStyle2.from(value)
    }));
  }
  assign(newOptions) {
    const bulkConfigurationUpdate = {};
    let hasUpdate = false;
    if (typeof newOptions.tabSize !== "undefined") {
      const tabSize = this._validateTabSize(newOptions.tabSize);
      if (tabSize === "auto") {
        hasUpdate = true;
        bulkConfigurationUpdate.tabSize = tabSize;
      } else if (typeof tabSize === "number" && this._tabSize !== tabSize) {
        this._tabSize = tabSize;
        hasUpdate = true;
        bulkConfigurationUpdate.tabSize = tabSize;
      }
    }
    if (typeof newOptions.indentSize !== "undefined") {
      const indentSize = this._validateIndentSize(newOptions.indentSize);
      if (indentSize === "tabSize") {
        hasUpdate = true;
        bulkConfigurationUpdate.indentSize = indentSize;
      } else if (typeof indentSize === "number" && this._indentSize !== indentSize) {
        this._indentSize = indentSize;
        hasUpdate = true;
        bulkConfigurationUpdate.indentSize = indentSize;
      }
    }
    if (typeof newOptions.insertSpaces !== "undefined") {
      const insertSpaces = this._validateInsertSpaces(newOptions.insertSpaces);
      if (insertSpaces === "auto") {
        hasUpdate = true;
        bulkConfigurationUpdate.insertSpaces = insertSpaces;
      } else if (this._insertSpaces !== insertSpaces) {
        this._insertSpaces = insertSpaces;
        hasUpdate = true;
        bulkConfigurationUpdate.insertSpaces = insertSpaces;
      }
    }
    if (typeof newOptions.cursorStyle !== "undefined") {
      if (this._cursorStyle !== newOptions.cursorStyle) {
        this._cursorStyle = newOptions.cursorStyle;
        hasUpdate = true;
        bulkConfigurationUpdate.cursorStyle = newOptions.cursorStyle;
      }
    }
    if (typeof newOptions.lineNumbers !== "undefined") {
      if (this._lineNumbers !== newOptions.lineNumbers) {
        this._lineNumbers = newOptions.lineNumbers;
        hasUpdate = true;
        bulkConfigurationUpdate.lineNumbers = TextEditorLineNumbersStyle2.from(newOptions.lineNumbers);
      }
    }
    if (hasUpdate) {
      this._warnOnError("setOptions", this._proxy.$trySetOptions(this._id, bulkConfigurationUpdate));
    }
  }
  _warnOnError(action, promise) {
    promise.catch((err) => {
      this._logService.warn(`ExtHostTextEditorOptions '${action}' failed:'`);
      this._logService.warn(err);
    });
  }
};
var ExtHostTextEditor = class {
  constructor(id, _proxy10, _logService, document2, selections, options, visibleRanges, viewColumn) {
    this.id = id;
    this._proxy = _proxy10;
    this._logService = _logService;
    this._disposed = false;
    this._hasDecorationsForKey = /* @__PURE__ */ new Set();
    this._selections = selections;
    this._options = new ExtHostTextEditorOptions(this._proxy, this.id, options, _logService);
    this._visibleRanges = visibleRanges;
    this._viewColumn = viewColumn;
    const that = this;
    this.value = Object.freeze({
      get document() {
        return document2.value;
      },
      set document(_value) {
        throw readonly("document");
      },
      get selection() {
        return that._selections && that._selections[0];
      },
      set selection(value) {
        if (!(value instanceof Selection)) {
          throw illegalArgument("selection");
        }
        that._selections = [value];
        that._trySetSelection();
      },
      get selections() {
        return that._selections;
      },
      set selections(value) {
        if (!Array.isArray(value) || value.some((a) => !(a instanceof Selection))) {
          throw illegalArgument("selections");
        }
        that._selections = value;
        that._trySetSelection();
      },
      get visibleRanges() {
        return that._visibleRanges;
      },
      set visibleRanges(_value) {
        throw readonly("visibleRanges");
      },
      get options() {
        return that._options.value;
      },
      set options(value) {
        if (!that._disposed) {
          that._options.assign(value);
        }
      },
      get viewColumn() {
        return that._viewColumn;
      },
      set viewColumn(_value) {
        throw readonly("viewColumn");
      },
      edit(callback, options2 = { undoStopBefore: true, undoStopAfter: true }) {
        if (that._disposed) {
          return Promise.reject(new Error("TextEditor#edit not possible on closed editors"));
        }
        const edit = new TextEditorEdit(document2.value, options2);
        callback(edit);
        return that._applyEdit(edit);
      },
      insertSnippet(snippet, where, options2 = { undoStopBefore: true, undoStopAfter: true }) {
        if (that._disposed) {
          return Promise.reject(new Error("TextEditor#insertSnippet not possible on closed editors"));
        }
        let ranges;
        if (!where || Array.isArray(where) && where.length === 0) {
          ranges = that._selections.map((range) => Range3.from(range));
        } else if (where instanceof Position2) {
          const { lineNumber, column } = Position3.from(where);
          ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];
        } else if (where instanceof Range2) {
          ranges = [Range3.from(where)];
        } else {
          ranges = [];
          for (const posOrRange of where) {
            if (posOrRange instanceof Range2) {
              ranges.push(Range3.from(posOrRange));
            } else {
              const { lineNumber, column } = Position3.from(posOrRange);
              ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });
            }
          }
        }
        return _proxy10.$tryInsertSnippet(id, document2.value.version, snippet.value, ranges, options2);
      },
      setDecorations(decorationType, ranges) {
        const willBeEmpty = ranges.length === 0;
        if (willBeEmpty && !that._hasDecorationsForKey.has(decorationType.key)) {
          return;
        }
        if (willBeEmpty) {
          that._hasDecorationsForKey.delete(decorationType.key);
        } else {
          that._hasDecorationsForKey.add(decorationType.key);
        }
        that._runOnProxy(() => {
          if (isDecorationOptionsArr(ranges)) {
            return _proxy10.$trySetDecorations(id, decorationType.key, fromRangeOrRangeWithMessage(ranges));
          } else {
            const _ranges = new Array(4 * ranges.length);
            for (let i = 0, len = ranges.length; i < len; i++) {
              const range = ranges[i];
              _ranges[4 * i] = range.start.line + 1;
              _ranges[4 * i + 1] = range.start.character + 1;
              _ranges[4 * i + 2] = range.end.line + 1;
              _ranges[4 * i + 3] = range.end.character + 1;
            }
            return _proxy10.$trySetDecorationsFast(id, decorationType.key, _ranges);
          }
        });
      },
      revealRange(range, revealType) {
        that._runOnProxy(() => _proxy10.$tryRevealRange(id, Range3.from(range), revealType || TextEditorRevealType2.Default));
      },
      show(column) {
        _proxy10.$tryShowEditor(id, ViewColumn2.from(column));
      },
      hide() {
        _proxy10.$tryHideEditor(id);
      }
    });
  }
  dispose() {
    ok(!this._disposed);
    this._disposed = true;
  }
  _acceptOptions(options) {
    ok(!this._disposed);
    this._options._accept(options);
  }
  _acceptVisibleRanges(value) {
    ok(!this._disposed);
    this._visibleRanges = value;
  }
  _acceptViewColumn(value) {
    ok(!this._disposed);
    this._viewColumn = value;
  }
  _acceptSelections(selections) {
    ok(!this._disposed);
    this._selections = selections;
  }
  async _trySetSelection() {
    const selection = this._selections.map(Selection3.from);
    await this._runOnProxy(() => this._proxy.$trySetSelections(this.id, selection));
    return this.value;
  }
  _applyEdit(editBuilder) {
    const editData = editBuilder.finalize();
    if (editData.edits.length === 0 && !editData.setEndOfLine) {
      return Promise.resolve(true);
    }
    const editRanges = editData.edits.map((edit) => edit.range);
    editRanges.sort((a, b) => {
      if (a.end.line === b.end.line) {
        if (a.end.character === b.end.character) {
          if (a.start.line === b.start.line) {
            return a.start.character - b.start.character;
          }
          return a.start.line - b.start.line;
        }
        return a.end.character - b.end.character;
      }
      return a.end.line - b.end.line;
    });
    for (let i = 0, count2 = editRanges.length - 1; i < count2; i++) {
      const rangeEnd = editRanges[i].end;
      const nextRangeStart = editRanges[i + 1].start;
      if (nextRangeStart.isBefore(rangeEnd)) {
        return Promise.reject(new Error("Overlapping ranges are not allowed!"));
      }
    }
    const edits = editData.edits.map((edit) => {
      return {
        range: Range3.from(edit.range),
        text: edit.text,
        forceMoveMarkers: edit.forceMoveMarkers
      };
    });
    return this._proxy.$tryApplyEdits(this.id, editData.documentVersionId, edits, {
      setEndOfLine: typeof editData.setEndOfLine === "number" ? EndOfLine2.from(editData.setEndOfLine) : void 0,
      undoStopBefore: editData.undoStopBefore,
      undoStopAfter: editData.undoStopAfter
    });
  }
  _runOnProxy(callback) {
    if (this._disposed) {
      this._logService.warn("TextEditor is closed/disposed");
      return Promise.resolve(void 0);
    }
    return callback().then(() => this, (err) => {
      if (!(err instanceof Error && err.name === "DISPOSED")) {
        this._logService.warn(err);
      }
      return null;
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocumentsAndEditors.js
init_log();
init_map();
init_network();
init_iterator();
init_lazy();
var Reference = class {
  constructor(value) {
    this.value = value;
    this._count = 0;
  }
  ref() {
    this._count++;
  }
  unref() {
    return --this._count === 0;
  }
};
var ExtHostDocumentsAndEditors = class ExtHostDocumentsAndEditors2 {
  constructor(_extHostRpc, _logService) {
    this._extHostRpc = _extHostRpc;
    this._logService = _logService;
    this._activeEditorId = null;
    this._editors = /* @__PURE__ */ new Map();
    this._documents = new ResourceMap();
    this._onDidAddDocuments = new Emitter();
    this._onDidRemoveDocuments = new Emitter();
    this._onDidChangeVisibleTextEditors = new Emitter();
    this._onDidChangeActiveTextEditor = new Emitter();
    this.onDidAddDocuments = this._onDidAddDocuments.event;
    this.onDidRemoveDocuments = this._onDidRemoveDocuments.event;
    this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
    this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
  }
  $acceptDocumentsAndEditorsDelta(delta3) {
    this.acceptDocumentsAndEditorsDelta(delta3);
  }
  acceptDocumentsAndEditorsDelta(delta3) {
    const removedDocuments = [];
    const addedDocuments = [];
    const removedEditors = [];
    if (delta3.removedDocuments) {
      for (const uriComponent of delta3.removedDocuments) {
        const uri = URI.revive(uriComponent);
        const data = this._documents.get(uri);
        if (data == null ? void 0 : data.unref()) {
          this._documents.delete(uri);
          removedDocuments.push(data.value);
        }
      }
    }
    if (delta3.addedDocuments) {
      for (const data of delta3.addedDocuments) {
        const resource = URI.revive(data.uri);
        let ref = this._documents.get(resource);
        if (ref) {
          if (resource.scheme !== Schemas.vscodeNotebookCell && resource.scheme !== Schemas.vscodeInteractiveInput) {
            throw new Error(`document '${resource} already exists!'`);
          }
        }
        if (!ref) {
          ref = new Reference(new ExtHostDocumentData(this._extHostRpc.getProxy(MainContext.MainThreadDocuments), resource, data.lines, data.EOL, data.versionId, data.languageId, data.isDirty, data.notebook));
          this._documents.set(resource, ref);
          addedDocuments.push(ref.value);
        }
        ref.ref();
      }
    }
    if (delta3.removedEditors) {
      for (const id of delta3.removedEditors) {
        const editor = this._editors.get(id);
        this._editors.delete(id);
        if (editor) {
          removedEditors.push(editor);
        }
      }
    }
    if (delta3.addedEditors) {
      for (const data of delta3.addedEditors) {
        const resource = URI.revive(data.documentUri);
        ok(this._documents.has(resource), `document '${resource}' does not exist`);
        ok(!this._editors.has(data.id), `editor '${data.id}' already exists!`);
        const documentData = this._documents.get(resource).value;
        const editor = new ExtHostTextEditor(data.id, this._extHostRpc.getProxy(MainContext.MainThreadTextEditors), this._logService, new Lazy(() => documentData.document), data.selections.map(Selection3.to), data.options, data.visibleRanges.map((range) => Range3.to(range)), typeof data.editorPosition === "number" ? ViewColumn2.to(data.editorPosition) : void 0);
        this._editors.set(data.id, editor);
      }
    }
    if (delta3.newActiveEditor !== void 0) {
      ok(delta3.newActiveEditor === null || this._editors.has(delta3.newActiveEditor), `active editor '${delta3.newActiveEditor}' does not exist`);
      this._activeEditorId = delta3.newActiveEditor;
    }
    dispose(removedDocuments);
    dispose(removedEditors);
    if (delta3.removedDocuments) {
      this._onDidRemoveDocuments.fire(removedDocuments);
    }
    if (delta3.addedDocuments) {
      this._onDidAddDocuments.fire(addedDocuments);
    }
    if (delta3.removedEditors || delta3.addedEditors) {
      this._onDidChangeVisibleTextEditors.fire(this.allEditors().map((editor) => editor.value));
    }
    if (delta3.newActiveEditor !== void 0) {
      this._onDidChangeActiveTextEditor.fire(this.activeEditor());
    }
  }
  getDocument(uri) {
    var _a30;
    return (_a30 = this._documents.get(uri)) == null ? void 0 : _a30.value;
  }
  allDocuments() {
    return Iterable.map(this._documents.values(), (ref) => ref.value);
  }
  getEditor(id) {
    return this._editors.get(id);
  }
  activeEditor(internal) {
    if (!this._activeEditorId) {
      return void 0;
    }
    const editor = this._editors.get(this._activeEditorId);
    if (internal) {
      return editor;
    } else {
      return editor == null ? void 0 : editor.value;
    }
  }
  allEditors() {
    return [...this._editors.values()];
  }
};
ExtHostDocumentsAndEditors = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService)
], ExtHostDocumentsAndEditors);
var IExtHostDocumentsAndEditors = createDecorator("IExtHostDocumentsAndEditors");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostFileSystem.js
init_uri();
init_extHost_protocol();
init_lifecycle();
init_extHostTypes();
init_strings();
init_buffer();
init_htmlContent();
var FsLinkProvider = class {
  constructor() {
    this._schemes = [];
  }
  add(scheme) {
    this._stateMachine = void 0;
    this._schemes.push(scheme);
  }
  delete(scheme) {
    const idx = this._schemes.indexOf(scheme);
    if (idx >= 0) {
      this._schemes.splice(idx, 1);
      this._stateMachine = void 0;
    }
  }
  _initStateMachine() {
    if (!this._stateMachine) {
      const schemes = this._schemes.sort();
      const edges = [];
      let prevScheme;
      let prevState;
      let lastState = 14;
      let nextState = 14;
      for (const scheme of schemes) {
        let pos = !prevScheme ? 0 : commonPrefixLength(prevScheme, scheme);
        if (pos === 0) {
          prevState = 1;
        } else {
          prevState = nextState;
        }
        for (; pos < scheme.length; pos++) {
          if (pos + 1 === scheme.length) {
            lastState = nextState;
            nextState = 9;
          } else {
            nextState += 1;
          }
          edges.push([prevState, scheme.toUpperCase().charCodeAt(pos), nextState]);
          edges.push([prevState, scheme.toLowerCase().charCodeAt(pos), nextState]);
          prevState = nextState;
        }
        prevScheme = scheme;
        nextState = lastState;
      }
      edges.push([9, 58, 10]);
      edges.push([10, 47, 12]);
      this._stateMachine = new StateMachine(edges);
    }
  }
  provideDocumentLinks(document2) {
    this._initStateMachine();
    const result = [];
    const links = LinkComputer.computeLinks({
      getLineContent(lineNumber) {
        return document2.lineAt(lineNumber - 1).text;
      },
      getLineCount() {
        return document2.lineCount;
      }
    }, this._stateMachine);
    for (const link of links) {
      const docLink = DocumentLink2.to(link);
      if (docLink.target) {
        result.push(docLink);
      }
    }
    return result;
  }
};
var ExtHostFileSystem = class _ExtHostFileSystem {
  constructor(mainContext, _extHostLanguageFeatures) {
    this._extHostLanguageFeatures = _extHostLanguageFeatures;
    this._linkProvider = new FsLinkProvider();
    this._fsProvider = /* @__PURE__ */ new Map();
    this._registeredSchemes = /* @__PURE__ */ new Set();
    this._watches = /* @__PURE__ */ new Map();
    this._handlePool = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadFileSystem);
  }
  dispose() {
    var _a30;
    (_a30 = this._linkProviderRegistration) == null ? void 0 : _a30.dispose();
  }
  registerFileSystemProvider(extension, scheme, provider, options = {}) {
    _ExtHostFileSystem._validateFileSystemProvider(provider);
    if (this._registeredSchemes.has(scheme)) {
      throw new Error(`a provider for the scheme '${scheme}' is already registered`);
    }
    if (!this._linkProviderRegistration) {
      this._linkProviderRegistration = this._extHostLanguageFeatures.registerDocumentLinkProvider(extension, "*", this._linkProvider);
    }
    const handle = this._handlePool++;
    this._linkProvider.add(scheme);
    this._registeredSchemes.add(scheme);
    this._fsProvider.set(handle, provider);
    let capabilities = 2;
    if (options.isCaseSensitive) {
      capabilities += 1024;
    }
    if (options.isReadonly) {
      capabilities += 2048;
    }
    if (typeof provider.copy === "function") {
      capabilities += 8;
    }
    if (typeof provider.open === "function" && typeof provider.close === "function" && typeof provider.read === "function" && typeof provider.write === "function") {
      checkProposedApiEnabled(extension, "fsChunks");
      capabilities += 4;
    }
    let readOnlyMessage;
    if (options.isReadonly && isMarkdownString(options.isReadonly)) {
      checkProposedApiEnabled(extension, "readonlyMessage");
      readOnlyMessage = {
        value: options.isReadonly.value,
        isTrusted: options.isReadonly.isTrusted,
        supportThemeIcons: options.isReadonly.supportThemeIcons,
        supportHtml: options.isReadonly.supportHtml,
        baseUri: options.isReadonly.baseUri,
        uris: options.isReadonly.uris
      };
    }
    this._proxy.$registerFileSystemProvider(handle, scheme, capabilities, readOnlyMessage).catch((err) => {
      console.error(`FAILED to register filesystem provider of ${extension.identifier.value}-extension for the scheme ${scheme}`);
      console.error(err);
    });
    const subscription = provider.onDidChangeFile((event) => {
      const mapped = [];
      for (const e of event) {
        const { uri: resource, type } = e;
        if (resource.scheme !== scheme) {
          continue;
        }
        let newType;
        switch (type) {
          case FileChangeType.Changed:
            newType = 0;
            break;
          case FileChangeType.Created:
            newType = 1;
            break;
          case FileChangeType.Deleted:
            newType = 2;
            break;
          default:
            throw new Error("Unknown FileChangeType");
        }
        mapped.push({ resource, type: newType });
      }
      this._proxy.$onFileSystemChange(handle, mapped);
    });
    return toDisposable(() => {
      subscription.dispose();
      this._linkProvider.delete(scheme);
      this._registeredSchemes.delete(scheme);
      this._fsProvider.delete(handle);
      this._proxy.$unregisterProvider(handle);
    });
  }
  static _validateFileSystemProvider(provider) {
    if (!provider) {
      throw new Error("MISSING provider");
    }
    if (typeof provider.watch !== "function") {
      throw new Error("Provider does NOT implement watch");
    }
    if (typeof provider.stat !== "function") {
      throw new Error("Provider does NOT implement stat");
    }
    if (typeof provider.readDirectory !== "function") {
      throw new Error("Provider does NOT implement readDirectory");
    }
    if (typeof provider.createDirectory !== "function") {
      throw new Error("Provider does NOT implement createDirectory");
    }
    if (typeof provider.readFile !== "function") {
      throw new Error("Provider does NOT implement readFile");
    }
    if (typeof provider.writeFile !== "function") {
      throw new Error("Provider does NOT implement writeFile");
    }
    if (typeof provider.delete !== "function") {
      throw new Error("Provider does NOT implement delete");
    }
    if (typeof provider.rename !== "function") {
      throw new Error("Provider does NOT implement rename");
    }
  }
  static _asIStat(stat) {
    const { type, ctime, mtime, size, permissions } = stat;
    return { type, ctime, mtime, size, permissions };
  }
  $stat(handle, resource) {
    return Promise.resolve(this._getFsProvider(handle).stat(URI.revive(resource))).then((stat) => _ExtHostFileSystem._asIStat(stat));
  }
  $readdir(handle, resource) {
    return Promise.resolve(this._getFsProvider(handle).readDirectory(URI.revive(resource)));
  }
  $readFile(handle, resource) {
    return Promise.resolve(this._getFsProvider(handle).readFile(URI.revive(resource))).then((data) => VSBuffer.wrap(data));
  }
  $writeFile(handle, resource, content, opts) {
    return Promise.resolve(this._getFsProvider(handle).writeFile(URI.revive(resource), content.buffer, opts));
  }
  $delete(handle, resource, opts) {
    return Promise.resolve(this._getFsProvider(handle).delete(URI.revive(resource), opts));
  }
  $rename(handle, oldUri, newUri, opts) {
    return Promise.resolve(this._getFsProvider(handle).rename(URI.revive(oldUri), URI.revive(newUri), opts));
  }
  $copy(handle, oldUri, newUri, opts) {
    const provider = this._getFsProvider(handle);
    if (!provider.copy) {
      throw new Error('FileSystemProvider does not implement "copy"');
    }
    return Promise.resolve(provider.copy(URI.revive(oldUri), URI.revive(newUri), opts));
  }
  $mkdir(handle, resource) {
    return Promise.resolve(this._getFsProvider(handle).createDirectory(URI.revive(resource)));
  }
  $watch(handle, session, resource, opts) {
    const subscription = this._getFsProvider(handle).watch(URI.revive(resource), opts);
    this._watches.set(session, subscription);
  }
  $unwatch(_handle4, session) {
    const subscription = this._watches.get(session);
    if (subscription) {
      subscription.dispose();
      this._watches.delete(session);
    }
  }
  $open(handle, resource, opts) {
    const provider = this._getFsProvider(handle);
    if (!provider.open) {
      throw new Error('FileSystemProvider does not implement "open"');
    }
    return Promise.resolve(provider.open(URI.revive(resource), opts));
  }
  $close(handle, fd) {
    const provider = this._getFsProvider(handle);
    if (!provider.close) {
      throw new Error('FileSystemProvider does not implement "close"');
    }
    return Promise.resolve(provider.close(fd));
  }
  $read(handle, fd, pos, length) {
    const provider = this._getFsProvider(handle);
    if (!provider.read) {
      throw new Error('FileSystemProvider does not implement "read"');
    }
    const data = VSBuffer.alloc(length);
    return Promise.resolve(provider.read(fd, pos, data.buffer, 0, length)).then((read) => {
      return data.slice(0, read);
    });
  }
  $write(handle, fd, pos, data) {
    const provider = this._getFsProvider(handle);
    if (!provider.write) {
      throw new Error('FileSystemProvider does not implement "write"');
    }
    return Promise.resolve(provider.write(fd, pos, data.buffer, 0, data.byteLength));
  }
  _getFsProvider(handle) {
    const provider = this._fsProvider.get(handle);
    if (!provider) {
      const err = new Error();
      err.name = "ENOPRO";
      err.message = `no provider`;
      throw err;
    }
    return provider;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostFileSystemEventService.js
init_event();
init_uri();
init_extHost_protocol();
init_extHostTypes();
var FileSystemWatcher = class {
  get ignoreCreateEvents() {
    return Boolean(this._config & 1);
  }
  get ignoreChangeEvents() {
    return Boolean(this._config & 2);
  }
  get ignoreDeleteEvents() {
    return Boolean(this._config & 4);
  }
  constructor(mainContext, workspace, extension, dispatcher, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
    this._onDidCreate = new Emitter();
    this._onDidChange = new Emitter();
    this._onDidDelete = new Emitter();
    const watcherDisposable = this.ensureWatching(mainContext, extension, globPattern);
    this._config = 0;
    if (ignoreCreateEvents) {
      this._config += 1;
    }
    if (ignoreChangeEvents) {
      this._config += 2;
    }
    if (ignoreDeleteEvents) {
      this._config += 4;
    }
    const parsedPattern = parse2(globPattern);
    const excludeOutOfWorkspaceEvents = typeof globPattern === "string";
    const subscription = dispatcher((events) => {
      if (!ignoreCreateEvents) {
        for (const created of events.created) {
          const uri = URI.revive(created);
          if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {
            this._onDidCreate.fire(uri);
          }
        }
      }
      if (!ignoreChangeEvents) {
        for (const changed of events.changed) {
          const uri = URI.revive(changed);
          if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {
            this._onDidChange.fire(uri);
          }
        }
      }
      if (!ignoreDeleteEvents) {
        for (const deleted of events.deleted) {
          const uri = URI.revive(deleted);
          if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {
            this._onDidDelete.fire(uri);
          }
        }
      }
    });
    this._disposable = Disposable2.from(watcherDisposable, this._onDidCreate, this._onDidChange, this._onDidDelete, subscription);
  }
  ensureWatching(mainContext, extension, globPattern) {
    const disposable = Disposable2.from();
    if (typeof globPattern === "string") {
      return disposable;
    }
    const proxy = mainContext.getProxy(MainContext.MainThreadFileSystem);
    let recursive = false;
    if (globPattern.pattern.includes(GLOBSTAR) || globPattern.pattern.includes(GLOB_SPLIT)) {
      recursive = true;
    }
    const session = Math.random();
    proxy.$watch(extension.identifier.value, session, globPattern.baseUri, { recursive, excludes: [] });
    return Disposable2.from({ dispose: () => proxy.$unwatch(session) });
  }
  dispose() {
    this._disposable.dispose();
  }
  get onDidCreate() {
    return this._onDidCreate.event;
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get onDidDelete() {
    return this._onDidDelete.event;
  }
};
var ExtHostFileSystemEventService = class {
  constructor(_mainContext, _logService, _extHostDocumentsAndEditors) {
    this._mainContext = _mainContext;
    this._logService = _logService;
    this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
    this._onFileSystemEvent = new Emitter();
    this._onDidRenameFile = new Emitter();
    this._onDidCreateFile = new Emitter();
    this._onDidDeleteFile = new Emitter();
    this._onWillRenameFile = new AsyncEmitter();
    this._onWillCreateFile = new AsyncEmitter();
    this._onWillDeleteFile = new AsyncEmitter();
    this.onDidRenameFile = this._onDidRenameFile.event;
    this.onDidCreateFile = this._onDidCreateFile.event;
    this.onDidDeleteFile = this._onDidDeleteFile.event;
  }
  createFileSystemWatcher(workspace, extension, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
    return new FileSystemWatcher(
      this._mainContext,
      workspace,
      extension,
      this._onFileSystemEvent.event,
      GlobPattern.from(globPattern),
      ignoreCreateEvents,
      ignoreChangeEvents,
      ignoreDeleteEvents
    );
  }
  $onFileEvent(events) {
    this._onFileSystemEvent.fire(events);
  }
  $onDidRunFileOperation(operation, files) {
    switch (operation) {
      case 2:
        this._onDidRenameFile.fire(Object.freeze({ files: files.map((f) => ({ oldUri: URI.revive(f.source), newUri: URI.revive(f.target) })) }));
        break;
      case 1:
        this._onDidDeleteFile.fire(Object.freeze({ files: files.map((f) => URI.revive(f.target)) }));
        break;
      case 0:
      case 3:
        this._onDidCreateFile.fire(Object.freeze({ files: files.map((f) => URI.revive(f.target)) }));
        break;
    }
  }
  getOnWillRenameFileEvent(extension) {
    return this._createWillExecuteEvent(extension, this._onWillRenameFile);
  }
  getOnWillCreateFileEvent(extension) {
    return this._createWillExecuteEvent(extension, this._onWillCreateFile);
  }
  getOnWillDeleteFileEvent(extension) {
    return this._createWillExecuteEvent(extension, this._onWillDeleteFile);
  }
  _createWillExecuteEvent(extension, emitter) {
    return (listener, thisArg, disposables) => {
      const wrappedListener = function wrapped(e) {
        listener.call(thisArg, e);
      };
      wrappedListener.extension = extension;
      return emitter.event(wrappedListener, void 0, disposables);
    };
  }
  async $onWillRunFileOperation(operation, files, timeout2, token) {
    switch (operation) {
      case 2:
        return await this._fireWillEvent(this._onWillRenameFile, { files: files.map((f) => ({ oldUri: URI.revive(f.source), newUri: URI.revive(f.target) })) }, timeout2, token);
      case 1:
        return await this._fireWillEvent(this._onWillDeleteFile, { files: files.map((f) => URI.revive(f.target)) }, timeout2, token);
      case 0:
      case 3:
        return await this._fireWillEvent(this._onWillCreateFile, { files: files.map((f) => URI.revive(f.target)) }, timeout2, token);
    }
    return void 0;
  }
  async _fireWillEvent(emitter, data, timeout2, token) {
    const extensionNames = /* @__PURE__ */ new Set();
    const edits = [];
    await emitter.fireAsync(data, token, async (thenable, listener) => {
      const now = Date.now();
      const result = await Promise.resolve(thenable);
      if (result instanceof WorkspaceEdit) {
        edits.push([listener.extension, result]);
        extensionNames.add(listener.extension.displayName ?? listener.extension.identifier.value);
      }
      if (Date.now() - now > timeout2) {
        this._logService.warn("SLOW file-participant", listener.extension.identifier);
      }
    });
    if (token.isCancellationRequested) {
      return void 0;
    }
    if (edits.length === 0) {
      return void 0;
    }
    const dto = { edits: [] };
    for (const [, edit] of edits) {
      const { edits: edits2 } = WorkspaceEdit2.from(edit, {
        getTextDocumentVersion: (uri) => {
          var _a30;
          return (_a30 = this._extHostDocumentsAndEditors.getDocument(uri)) == null ? void 0 : _a30.version;
        },
        getNotebookDocumentVersion: () => void 0
      });
      dto.edits = dto.edits.concat(edits2);
    }
    return { edit: dto, extensionNames: Array.from(extensionNames) };
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLanguageFeatures.js
init_uri();
init_objects();
init_extHostTypes();
init_languages();
init_extHost_protocol();
init_strings();
init_range();
init_arrays();
init_types();
init_selection();
init_cancellation();
init_extensions();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/workbench/api/common/cache.js
var _Cache = class _Cache {
  constructor(id) {
    this.id = id;
    this._data = /* @__PURE__ */ new Map();
    this._idPool = 1;
  }
  add(item) {
    const id = this._idPool++;
    this._data.set(id, item);
    this.logDebugInfo();
    return id;
  }
  get(pid, id) {
    return this._data.has(pid) ? this._data.get(pid)[id] : void 0;
  }
  delete(id) {
    this._data.delete(id);
    this.logDebugInfo();
  }
  logDebugInfo() {
    if (!_Cache.enableDebugLogging) {
      return;
    }
    console.log(`${this.id} cache size - ${this._data.size}`);
  }
};
_Cache.enableDebugLogging = false;
var Cache = _Cache;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLanguageFeatures.js
init_stopwatch();
init_errors();
init_async();
init_nls();
var DocumentSymbolAdapter = class _DocumentSymbolAdapter {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentSymbols(resource, token) {
    const doc = this._documents.getDocument(resource);
    const value = await this._provider.provideDocumentSymbols(doc, token);
    if (isFalsyOrEmpty(value)) {
      return void 0;
    } else if (value[0] instanceof DocumentSymbol) {
      return value.map(DocumentSymbol2.from);
    } else {
      return _DocumentSymbolAdapter._asDocumentSymbolTree(value);
    }
  }
  static _asDocumentSymbolTree(infos) {
    var _a30, _b;
    infos = infos.slice(0).sort((a, b) => {
      let res2 = a.location.range.start.compareTo(b.location.range.start);
      if (res2 === 0) {
        res2 = b.location.range.end.compareTo(a.location.range.end);
      }
      return res2;
    });
    const res = [];
    const parentStack = [];
    for (const info of infos) {
      const element = {
        name: info.name || "!!MISSING: name!!",
        kind: SymbolKind2.from(info.kind),
        tags: ((_a30 = info.tags) == null ? void 0 : _a30.map(SymbolTag2.from)) || [],
        detail: "",
        containerName: info.containerName,
        range: Range3.from(info.location.range),
        selectionRange: Range3.from(info.location.range),
        children: []
      };
      while (true) {
        if (parentStack.length === 0) {
          parentStack.push(element);
          res.push(element);
          break;
        }
        const parent = parentStack[parentStack.length - 1];
        if (Range.containsRange(parent.range, element.range) && !Range.equalsRange(parent.range, element.range)) {
          (_b = parent.children) == null ? void 0 : _b.push(element);
          parentStack.push(element);
          break;
        }
        parentStack.pop();
      }
    }
    return res;
  }
};
var _CodeLensAdapter = class _CodeLensAdapter {
  constructor(_documents, _commands2, _provider) {
    this._documents = _documents;
    this._commands = _commands2;
    this._provider = _provider;
    this._cache = new Cache("CodeLens");
    this._disposables = /* @__PURE__ */ new Map();
  }
  async provideCodeLenses(resource, token) {
    const doc = this._documents.getDocument(resource);
    const lenses = await this._provider.provideCodeLenses(doc, token);
    if (!lenses || token.isCancellationRequested) {
      return void 0;
    }
    const cacheId = this._cache.add(lenses);
    const disposables = new DisposableStore();
    this._disposables.set(cacheId, disposables);
    const result = {
      cacheId,
      lenses: []
    };
    for (let i = 0; i < lenses.length; i++) {
      result.lenses.push({
        cacheId: [cacheId, i],
        range: Range3.from(lenses[i].range),
        command: this._commands.toInternal(lenses[i].command, disposables)
      });
    }
    return result;
  }
  async resolveCodeLens(symbol, token) {
    const lens = symbol.cacheId && this._cache.get(...symbol.cacheId);
    if (!lens) {
      return void 0;
    }
    let resolvedLens;
    if (typeof this._provider.resolveCodeLens !== "function" || lens.isResolved) {
      resolvedLens = lens;
    } else {
      resolvedLens = await this._provider.resolveCodeLens(lens, token);
    }
    if (!resolvedLens) {
      resolvedLens = lens;
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    const disposables = symbol.cacheId && this._disposables.get(symbol.cacheId[0]);
    if (!disposables) {
      return void 0;
    }
    symbol.command = this._commands.toInternal(resolvedLens.command ?? _CodeLensAdapter._badCmd, disposables);
    return symbol;
  }
  releaseCodeLenses(cachedId) {
    var _a30;
    (_a30 = this._disposables.get(cachedId)) == null ? void 0 : _a30.dispose();
    this._disposables.delete(cachedId);
    this._cache.delete(cachedId);
  }
};
_CodeLensAdapter._badCmd = { command: "missing", title: "!!MISSING: command!!" };
var CodeLensAdapter = _CodeLensAdapter;
function convertToLocationLinks(value) {
  if (Array.isArray(value)) {
    return value.map(DefinitionLink.from);
  } else if (value) {
    return [DefinitionLink.from(value)];
  }
  return [];
}
var DefinitionAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDefinition(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideDefinition(doc, pos, token);
    return convertToLocationLinks(value);
  }
};
var DeclarationAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDeclaration(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideDeclaration(doc, pos, token);
    return convertToLocationLinks(value);
  }
};
var ImplementationAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideImplementation(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideImplementation(doc, pos, token);
    return convertToLocationLinks(value);
  }
};
var TypeDefinitionAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideTypeDefinition(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideTypeDefinition(doc, pos, token);
    return convertToLocationLinks(value);
  }
};
var HoverAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideHover(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideHover(doc, pos, token);
    if (!value || isFalsyOrEmpty(value.contents)) {
      return void 0;
    }
    if (!value.range) {
      value.range = doc.getWordRangeAtPosition(pos);
    }
    if (!value.range) {
      value.range = new Range2(pos, pos);
    }
    return Hover2.from(value);
  }
};
var EvaluatableExpressionAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideEvaluatableExpression(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideEvaluatableExpression(doc, pos, token);
    if (value) {
      return EvaluatableExpression2.from(value);
    }
    return void 0;
  }
};
var InlineValuesAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideInlineValues(resource, viewPort, context, token) {
    const doc = this._documents.getDocument(resource);
    const value = await this._provider.provideInlineValues(doc, Range3.to(viewPort), InlineValueContext2.to(context), token);
    if (Array.isArray(value)) {
      return value.map((iv) => InlineValue.from(iv));
    }
    return void 0;
  }
};
var DocumentHighlightAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentHighlights(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideDocumentHighlights(doc, pos, token);
    if (Array.isArray(value)) {
      return value.map(DocumentHighlight2.from);
    }
    return void 0;
  }
};
var LinkedEditingRangeAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideLinkedEditingRanges(resource, position, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideLinkedEditingRanges(doc, pos, token);
    if (value && Array.isArray(value.ranges)) {
      return {
        ranges: coalesce(value.ranges.map(Range3.from)),
        wordPattern: value.wordPattern
      };
    }
    return void 0;
  }
};
var ReferenceAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideReferences(resource, position, context, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideReferences(doc, pos, context, token);
    if (Array.isArray(value)) {
      return value.map(location.from);
    }
    return void 0;
  }
};
var _CodeActionAdapter = class _CodeActionAdapter {
  constructor(_documents, _commands2, _diagnostics, _provider, _logService, _extension2, _apiDeprecation) {
    this._documents = _documents;
    this._commands = _commands2;
    this._diagnostics = _diagnostics;
    this._provider = _provider;
    this._logService = _logService;
    this._extension = _extension2;
    this._apiDeprecation = _apiDeprecation;
    this._cache = new Cache("CodeAction");
    this._disposables = /* @__PURE__ */ new Map();
    this.nbKind = new CodeActionKind("notebook");
  }
  async provideCodeActions(resource, rangeOrSelection, context, token) {
    var _a30;
    const doc = this._documents.getDocument(resource);
    const ran = Selection2.isISelection(rangeOrSelection) ? Selection3.to(rangeOrSelection) : Range3.to(rangeOrSelection);
    const allDiagnostics = [];
    for (const diagnostic of this._diagnostics.getDiagnostics(resource)) {
      if (ran.intersection(diagnostic.range)) {
        const newLen = allDiagnostics.push(diagnostic);
        if (newLen > _CodeActionAdapter._maxCodeActionsPerFile) {
          break;
        }
      }
    }
    const codeActionContext = {
      diagnostics: allDiagnostics,
      only: context.only ? new CodeActionKind(context.only) : void 0,
      triggerKind: CodeActionTriggerKind2.to(context.trigger)
    };
    const commandsOrActions = await this._provider.provideCodeActions(doc, ran, codeActionContext, token);
    if (!isNonEmptyArray(commandsOrActions) || token.isCancellationRequested) {
      return void 0;
    }
    const cacheId = this._cache.add(commandsOrActions);
    const disposables = new DisposableStore();
    this._disposables.set(cacheId, disposables);
    const actions = [];
    for (let i = 0; i < commandsOrActions.length; i++) {
      const candidate = commandsOrActions[i];
      if (!candidate) {
        continue;
      }
      if (_CodeActionAdapter._isCommand(candidate)) {
        this._apiDeprecation.report("CodeActionProvider.provideCodeActions - return commands", this._extension, `Return 'CodeAction' instances instead.`);
        actions.push({
          _isSynthetic: true,
          title: candidate.title,
          command: this._commands.toInternal(candidate, disposables)
        });
      } else {
        if (codeActionContext.triggerKind !== CodeActionTriggerKind.Invoke && candidate.kind && this.nbKind.contains(candidate.kind)) {
          continue;
        }
        if (codeActionContext.only) {
          if (!candidate.kind) {
            this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value} 'requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`);
          } else if (!codeActionContext.only.contains(candidate.kind)) {
            this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value} 'requested but returned code action is of kind '${candidate.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`);
          }
        }
        actions.push({
          cacheId: [cacheId, i],
          title: candidate.title,
          command: candidate.command && this._commands.toInternal(candidate.command, disposables),
          diagnostics: candidate.diagnostics && candidate.diagnostics.map(Diagnostic2.from),
          edit: candidate.edit && WorkspaceEdit2.from(candidate.edit, void 0),
          kind: candidate.kind && candidate.kind.value,
          isPreferred: candidate.isPreferred,
          disabled: (_a30 = candidate.disabled) == null ? void 0 : _a30.reason
        });
      }
    }
    return { cacheId, actions };
  }
  async resolveCodeAction(id, token) {
    const [sessionId, itemId] = id;
    const item = this._cache.get(sessionId, itemId);
    if (!item || _CodeActionAdapter._isCommand(item)) {
      return {};
    }
    if (!this._provider.resolveCodeAction) {
      return {};
    }
    const resolvedItem = await this._provider.resolveCodeAction(item, token) ?? item;
    let resolvedEdit;
    if (resolvedItem.edit) {
      resolvedEdit = WorkspaceEdit2.from(resolvedItem.edit, void 0);
    }
    let resolvedCommand;
    if (resolvedItem.command) {
      const disposables = this._disposables.get(sessionId);
      if (disposables) {
        resolvedCommand = this._commands.toInternal(resolvedItem.command, disposables);
      }
    }
    return { edit: resolvedEdit, command: resolvedCommand };
  }
  releaseCodeActions(cachedId) {
    var _a30;
    (_a30 = this._disposables.get(cachedId)) == null ? void 0 : _a30.dispose();
    this._disposables.delete(cachedId);
    this._cache.delete(cachedId);
  }
  static _isCommand(thing) {
    return typeof thing.command === "string" && typeof thing.title === "string";
  }
};
_CodeActionAdapter._maxCodeActionsPerFile = 1e3;
var CodeActionAdapter = _CodeActionAdapter;
var DocumentPasteEditProvider = class _DocumentPasteEditProvider {
  static toInternalProviderId(extId, editId) {
    return extId + "." + editId;
  }
  constructor(_proxy10, _documents, _provider, _handle4, _extension2) {
    this._proxy = _proxy10;
    this._documents = _documents;
    this._provider = _provider;
    this._handle = _handle4;
    this._extension = _extension2;
  }
  async prepareDocumentPaste(resource, ranges, dataTransferDto, token) {
    if (!this._provider.prepareDocumentPaste) {
      return;
    }
    const doc = this._documents.getDocument(resource);
    const vscodeRanges = ranges.map((range) => Range3.to(range));
    const dataTransfer = DataTransfer2.toDataTransfer(dataTransferDto, () => {
      throw new NotImplementedError();
    });
    await this._provider.prepareDocumentPaste(doc, vscodeRanges, dataTransfer, token);
    if (token.isCancellationRequested) {
      return;
    }
    const entries = Array.from(dataTransfer).filter(([, value]) => !(value instanceof InternalDataTransferItem));
    return DataTransfer2.from(entries);
  }
  async providePasteEdits(requestId, resource, ranges, dataTransferDto, token) {
    var _a30;
    if (!this._provider.provideDocumentPasteEdits) {
      return;
    }
    const doc = this._documents.getDocument(resource);
    const vscodeRanges = ranges.map((range) => Range3.to(range));
    const dataTransfer = DataTransfer2.toDataTransfer(dataTransferDto, async (id) => {
      return (await this._proxy.$resolvePasteFileData(this._handle, requestId, id)).buffer;
    });
    const edit = await this._provider.provideDocumentPasteEdits(doc, vscodeRanges, dataTransfer, token);
    if (!edit) {
      return;
    }
    return {
      label: edit.label ?? localize(
        "defaultPasteLabel",
        "Paste using '{0}' extension",
        this._extension.displayName || this._extension.name
      ),
      detail: this._extension.displayName || this._extension.name,
      yieldTo: (_a30 = edit.yieldTo) == null ? void 0 : _a30.map((yTo) => {
        return "mimeType" in yTo ? yTo : { providerId: _DocumentPasteEditProvider.toInternalProviderId(yTo.extensionId, yTo.providerId) };
      }),
      insertText: typeof edit.insertText === "string" ? edit.insertText : { snippet: edit.insertText.value },
      additionalEdit: edit.additionalEdit ? WorkspaceEdit2.from(edit.additionalEdit, void 0) : void 0
    };
  }
};
var DocumentFormattingAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentFormattingEdits(resource, options, token) {
    const document2 = this._documents.getDocument(resource);
    const value = await this._provider.provideDocumentFormattingEdits(document2, options, token);
    if (Array.isArray(value)) {
      return value.map(TextEdit2.from);
    }
    return void 0;
  }
};
var RangeFormattingAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentRangeFormattingEdits(resource, range, options, token) {
    const document2 = this._documents.getDocument(resource);
    const ran = Range3.to(range);
    const value = await this._provider.provideDocumentRangeFormattingEdits(document2, ran, options, token);
    if (Array.isArray(value)) {
      return value.map(TextEdit2.from);
    }
    return void 0;
  }
  async provideDocumentRangesFormattingEdits(resource, ranges, options, token) {
    assertType(typeof this._provider.provideDocumentRangesFormattingEdits === "function", "INVALID invocation of `provideDocumentRangesFormattingEdits`");
    const document2 = this._documents.getDocument(resource);
    const _ranges = ranges.map(Range3.to);
    const value = await this._provider.provideDocumentRangesFormattingEdits(document2, _ranges, options, token);
    if (Array.isArray(value)) {
      return value.map(TextEdit2.from);
    }
    return void 0;
  }
};
var OnTypeFormattingAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this.autoFormatTriggerCharacters = [];
  }
  async provideOnTypeFormattingEdits(resource, position, ch, options, token) {
    const document2 = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const value = await this._provider.provideOnTypeFormattingEdits(document2, pos, ch, options, token);
    if (Array.isArray(value)) {
      return value.map(TextEdit2.from);
    }
    return void 0;
  }
};
var NavigateTypeAdapter = class {
  constructor(_provider, _logService) {
    this._provider = _provider;
    this._logService = _logService;
    this._cache = new Cache("WorkspaceSymbols");
  }
  async provideWorkspaceSymbols(search, token) {
    const value = await this._provider.provideWorkspaceSymbols(search, token);
    if (!isNonEmptyArray(value)) {
      return { symbols: [] };
    }
    const sid = this._cache.add(value);
    const result = {
      cacheId: sid,
      symbols: []
    };
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      if (!item || !item.name) {
        this._logService.warn("INVALID SymbolInformation", item);
        continue;
      }
      result.symbols.push({
        ...WorkspaceSymbol.from(item),
        cacheId: [sid, i]
      });
    }
    return result;
  }
  async resolveWorkspaceSymbol(symbol, token) {
    if (typeof this._provider.resolveWorkspaceSymbol !== "function") {
      return symbol;
    }
    if (!symbol.cacheId) {
      return symbol;
    }
    const item = this._cache.get(...symbol.cacheId);
    if (item) {
      const value = await this._provider.resolveWorkspaceSymbol(item, token);
      return value && mixin(symbol, WorkspaceSymbol.from(value), true);
    }
    return void 0;
  }
  releaseWorkspaceSymbols(id) {
    this._cache.delete(id);
  }
};
var RenameAdapter = class _RenameAdapter {
  static supportsResolving(provider) {
    return typeof provider.prepareRename === "function";
  }
  constructor(_documents, _provider, _logService) {
    this._documents = _documents;
    this._provider = _provider;
    this._logService = _logService;
  }
  async provideRenameEdits(resource, position, newName, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    try {
      const value = await this._provider.provideRenameEdits(doc, pos, newName, token);
      if (!value) {
        return void 0;
      }
      return WorkspaceEdit2.from(value);
    } catch (err) {
      const rejectReason = _RenameAdapter._asMessage(err);
      if (rejectReason) {
        return { rejectReason, edits: void 0 };
      } else {
        return Promise.reject(err);
      }
    }
  }
  async resolveRenameLocation(resource, position, token) {
    if (typeof this._provider.prepareRename !== "function") {
      return Promise.resolve(void 0);
    }
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    try {
      const rangeOrLocation = await this._provider.prepareRename(doc, pos, token);
      let range;
      let text;
      if (Range2.isRange(rangeOrLocation)) {
        range = rangeOrLocation;
        text = doc.getText(rangeOrLocation);
      } else if (isObject(rangeOrLocation)) {
        range = rangeOrLocation.range;
        text = rangeOrLocation.placeholder;
      }
      if (!range || !text) {
        return void 0;
      }
      if (range.start.line > pos.line || range.end.line < pos.line) {
        this._logService.warn("INVALID rename location: position line must be within range start/end lines");
        return void 0;
      }
      return { range: Range3.from(range), text };
    } catch (err) {
      const rejectReason = _RenameAdapter._asMessage(err);
      if (rejectReason) {
        return { rejectReason, range: void 0, text: void 0 };
      } else {
        return Promise.reject(err);
      }
    }
  }
  static _asMessage(err) {
    if (typeof err === "string") {
      return err;
    } else if (err instanceof Error && typeof err.message === "string") {
      return err.message;
    } else {
      return void 0;
    }
  }
};
var SemanticTokensPreviousResult = class {
  constructor(resultId, tokens) {
    this.resultId = resultId;
    this.tokens = tokens;
  }
};
var DocumentSemanticTokensAdapter = class _DocumentSemanticTokensAdapter {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._nextResultId = 1;
    this._previousResults = /* @__PURE__ */ new Map();
  }
  async provideDocumentSemanticTokens(resource, previousResultId, token) {
    const doc = this._documents.getDocument(resource);
    const previousResult = previousResultId !== 0 ? this._previousResults.get(previousResultId) : null;
    let value = typeof (previousResult == null ? void 0 : previousResult.resultId) === "string" && typeof this._provider.provideDocumentSemanticTokensEdits === "function" ? await this._provider.provideDocumentSemanticTokensEdits(doc, previousResult.resultId, token) : await this._provider.provideDocumentSemanticTokens(doc, token);
    if (previousResult) {
      this._previousResults.delete(previousResultId);
    }
    if (!value) {
      return null;
    }
    value = _DocumentSemanticTokensAdapter._fixProvidedSemanticTokens(value);
    return this._send(_DocumentSemanticTokensAdapter._convertToEdits(previousResult, value), value);
  }
  async releaseDocumentSemanticColoring(semanticColoringResultId) {
    this._previousResults.delete(semanticColoringResultId);
  }
  static _fixProvidedSemanticTokens(v) {
    if (_DocumentSemanticTokensAdapter._isSemanticTokens(v)) {
      if (_DocumentSemanticTokensAdapter._isCorrectSemanticTokens(v)) {
        return v;
      }
      return new SemanticTokens(new Uint32Array(v.data), v.resultId);
    } else if (_DocumentSemanticTokensAdapter._isSemanticTokensEdits(v)) {
      if (_DocumentSemanticTokensAdapter._isCorrectSemanticTokensEdits(v)) {
        return v;
      }
      return new SemanticTokensEdits(v.edits.map((edit) => new SemanticTokensEdit(
        edit.start,
        edit.deleteCount,
        edit.data ? new Uint32Array(edit.data) : edit.data
      )), v.resultId);
    }
    return v;
  }
  static _isSemanticTokens(v) {
    return v && !!v.data;
  }
  static _isCorrectSemanticTokens(v) {
    return v.data instanceof Uint32Array;
  }
  static _isSemanticTokensEdits(v) {
    return v && Array.isArray(v.edits);
  }
  static _isCorrectSemanticTokensEdits(v) {
    for (const edit of v.edits) {
      if (!(edit.data instanceof Uint32Array)) {
        return false;
      }
    }
    return true;
  }
  static _convertToEdits(previousResult, newResult) {
    if (!_DocumentSemanticTokensAdapter._isSemanticTokens(newResult)) {
      return newResult;
    }
    if (!previousResult || !previousResult.tokens) {
      return newResult;
    }
    const oldData = previousResult.tokens;
    const oldLength = oldData.length;
    const newData = newResult.data;
    const newLength = newData.length;
    let commonPrefixLength2 = 0;
    const maxCommonPrefixLength = Math.min(oldLength, newLength);
    while (commonPrefixLength2 < maxCommonPrefixLength && oldData[commonPrefixLength2] === newData[commonPrefixLength2]) {
      commonPrefixLength2++;
    }
    if (commonPrefixLength2 === oldLength && commonPrefixLength2 === newLength) {
      return new SemanticTokensEdits([], newResult.resultId);
    }
    let commonSuffixLength = 0;
    const maxCommonSuffixLength = maxCommonPrefixLength - commonPrefixLength2;
    while (commonSuffixLength < maxCommonSuffixLength && oldData[oldLength - commonSuffixLength - 1] === newData[newLength - commonSuffixLength - 1]) {
      commonSuffixLength++;
    }
    return new SemanticTokensEdits([{
      start: commonPrefixLength2,
      deleteCount: oldLength - commonPrefixLength2 - commonSuffixLength,
      data: newData.subarray(commonPrefixLength2, newLength - commonSuffixLength)
    }], newResult.resultId);
  }
  _send(value, original2) {
    if (_DocumentSemanticTokensAdapter._isSemanticTokens(value)) {
      const myId = this._nextResultId++;
      this._previousResults.set(myId, new SemanticTokensPreviousResult(value.resultId, value.data));
      return encodeSemanticTokensDto({
        id: myId,
        type: "full",
        data: value.data
      });
    }
    if (_DocumentSemanticTokensAdapter._isSemanticTokensEdits(value)) {
      const myId = this._nextResultId++;
      if (_DocumentSemanticTokensAdapter._isSemanticTokens(original2)) {
        this._previousResults.set(myId, new SemanticTokensPreviousResult(original2.resultId, original2.data));
      } else {
        this._previousResults.set(myId, new SemanticTokensPreviousResult(value.resultId));
      }
      return encodeSemanticTokensDto({
        id: myId,
        type: "delta",
        deltas: (value.edits || []).map(
          (edit) => ({ start: edit.start, deleteCount: edit.deleteCount, data: edit.data })
        )
      });
    }
    return null;
  }
};
var DocumentRangeSemanticTokensAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideDocumentRangeSemanticTokens(resource, range, token) {
    const doc = this._documents.getDocument(resource);
    const value = await this._provider.provideDocumentRangeSemanticTokens(doc, Range3.to(range), token);
    if (!value) {
      return null;
    }
    return this._send(value);
  }
  _send(value) {
    return encodeSemanticTokensDto({
      id: 0,
      type: "full",
      data: value.data
    });
  }
};
var CompletionsAdapter = class _CompletionsAdapter {
  static supportsResolving(provider) {
    return typeof provider.resolveCompletionItem === "function";
  }
  constructor(_documents, _commands2, _provider, _apiDeprecation, _extension2) {
    this._documents = _documents;
    this._commands = _commands2;
    this._provider = _provider;
    this._apiDeprecation = _apiDeprecation;
    this._extension = _extension2;
    this._cache = new Cache("CompletionItem");
    this._disposables = /* @__PURE__ */ new Map();
  }
  async provideCompletionItems(resource, position, context, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const replaceRange = doc.getWordRangeAtPosition(pos) || new Range2(pos, pos);
    const insertRange = replaceRange.with({ end: pos });
    const sw = new StopWatch();
    const itemsOrList = await this._provider.provideCompletionItems(doc, pos, token, CompletionContext.to(context));
    if (!itemsOrList) {
      return void 0;
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    const list = Array.isArray(itemsOrList) ? new CompletionList(itemsOrList) : itemsOrList;
    const pid = _CompletionsAdapter.supportsResolving(this._provider) ? this._cache.add(list.items) : this._cache.add([]);
    const disposables = new DisposableStore();
    this._disposables.set(pid, disposables);
    const completions = [];
    const result = {
      x: pid,
      ["b"]: completions,
      ["a"]: { replace: Range3.from(replaceRange), insert: Range3.from(insertRange) },
      ["c"]: list.isIncomplete || void 0,
      ["d"]: sw.elapsed()
    };
    for (let i = 0; i < list.items.length; i++) {
      const item = list.items[i];
      const dto = this._convertCompletionItem(item, [pid, i], insertRange, replaceRange);
      completions.push(dto);
    }
    return result;
  }
  async resolveCompletionItem(id, token) {
    if (typeof this._provider.resolveCompletionItem !== "function") {
      return void 0;
    }
    const item = this._cache.get(...id);
    if (!item) {
      return void 0;
    }
    const dto1 = this._convertCompletionItem(item, id);
    const resolvedItem = await this._provider.resolveCompletionItem(item, token);
    if (!resolvedItem) {
      return void 0;
    }
    const dto2 = this._convertCompletionItem(resolvedItem, id);
    if (dto1["h"] !== dto2["h"] || dto1["i"] !== dto2["i"]) {
      this._apiDeprecation.report("CompletionItem.insertText", this._extension, "extension MAY NOT change 'insertText' of a CompletionItem during resolve");
    }
    if (dto1["n"] !== dto2["n"] || dto1["o"] !== dto2["o"] || !equals2(dto1["p"], dto2["p"])) {
      this._apiDeprecation.report("CompletionItem.command", this._extension, "extension MAY NOT change 'command' of a CompletionItem during resolve");
    }
    return {
      ...dto1,
      ["d"]: dto2["d"],
      ["c"]: dto2["c"],
      ["l"]: dto2["l"],
      ["h"]: dto2["h"],
      ["i"]: dto2["i"],
      ["n"]: dto2["n"],
      ["o"]: dto2["o"],
      ["p"]: dto2["p"]
    };
  }
  releaseCompletionItems(id) {
    var _a30;
    (_a30 = this._disposables.get(id)) == null ? void 0 : _a30.dispose();
    this._disposables.delete(id);
    this._cache.delete(id);
  }
  _convertCompletionItem(item, id, defaultInsertRange, defaultReplaceRange) {
    var _a30;
    const disposables = this._disposables.get(id[0]);
    if (!disposables) {
      throw Error("DisposableStore is missing...");
    }
    const command = this._commands.toInternal(item.command, disposables);
    const result = {
      x: id,
      ["a"]: item.label,
      ["b"]: item.kind !== void 0 ? CompletionItemKind2.from(item.kind) : void 0,
      ["m"]: item.tags && item.tags.map(CompletionItemTag2.from),
      ["c"]: item.detail,
      ["d"]: typeof item.documentation === "undefined" ? void 0 : MarkdownString3.fromStrict(item.documentation),
      ["e"]: item.sortText !== item.label ? item.sortText : void 0,
      ["f"]: item.filterText !== item.label ? item.filterText : void 0,
      ["g"]: item.preselect || void 0,
      ["i"]: item.keepWhitespace ? 1 : 0,
      ["k"]: (_a30 = item.commitCharacters) == null ? void 0 : _a30.join(""),
      ["l"]: item.additionalTextEdits && item.additionalTextEdits.map(TextEdit2.from),
      ["n"]: command == null ? void 0 : command.$ident,
      ["o"]: command == null ? void 0 : command.id,
      ["p"]: (command == null ? void 0 : command.$ident) ? void 0 : command == null ? void 0 : command.arguments
    };
    if (item.textEdit) {
      this._apiDeprecation.report("CompletionItem.textEdit", this._extension, `Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.`);
      result["h"] = item.textEdit.newText;
    } else if (typeof item.insertText === "string") {
      result["h"] = item.insertText;
    } else if (item.insertText instanceof SnippetString) {
      result["h"] = item.insertText.value;
      result["i"] |= 4;
    }
    let range;
    if (item.textEdit) {
      range = item.textEdit.range;
    } else if (item.range) {
      range = item.range;
    }
    if (Range2.isRange(range)) {
      result["j"] = Range3.from(range);
    } else if (range && (!(defaultInsertRange == null ? void 0 : defaultInsertRange.isEqual(range.inserting)) || !(defaultReplaceRange == null ? void 0 : defaultReplaceRange.isEqual(range.replacing)))) {
      result["j"] = {
        insert: Range3.from(range.inserting),
        replace: Range3.from(range.replacing)
      };
    }
    return result;
  }
};
var InlineCompletionAdapterBase = class {
  async provideInlineCompletions(resource, position, context, token) {
    return void 0;
  }
  disposeCompletions(pid) {
  }
  handleDidShowCompletionItem(pid, idx, updatedInsertText) {
  }
  handlePartialAccept(pid, idx, acceptedCharacters) {
  }
};
var InlineCompletionAdapter = class extends InlineCompletionAdapterBase {
  constructor(_extension2, _documents, _provider, _commands2) {
    super();
    this._extension = _extension2;
    this._documents = _documents;
    this._provider = _provider;
    this._commands = _commands2;
    this._references = new ReferenceMap();
    this._isAdditionsProposedApiEnabled = isProposedApiEnabled(this._extension, "inlineCompletionsAdditions");
    this.languageTriggerKindToVSCodeTriggerKind = {
      [InlineCompletionTriggerKind.Automatic]: InlineCompletionTriggerKind2.Automatic,
      [InlineCompletionTriggerKind.Explicit]: InlineCompletionTriggerKind2.Invoke
    };
  }
  get supportsHandleEvents() {
    return isProposedApiEnabled(this._extension, "inlineCompletionsAdditions") && (typeof this._provider.handleDidShowCompletionItem === "function" || typeof this._provider.handleDidPartiallyAcceptCompletionItem === "function");
  }
  async provideInlineCompletions(resource, position, context, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const result = await this._provider.provideInlineCompletionItems(doc, pos, {
      selectedCompletionInfo: context.selectedSuggestionInfo ? {
        range: Range3.to(context.selectedSuggestionInfo.range),
        text: context.selectedSuggestionInfo.text
      } : void 0,
      triggerKind: this.languageTriggerKindToVSCodeTriggerKind[context.triggerKind]
    }, token);
    if (!result) {
      return void 0;
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    const normalizedResult = Array.isArray(result) ? result : result.items;
    const commands = this._isAdditionsProposedApiEnabled ? Array.isArray(result) ? [] : result.commands || [] : [];
    const enableForwardStability = this._isAdditionsProposedApiEnabled && !Array.isArray(result) ? result.enableForwardStability : void 0;
    let disposableStore = void 0;
    const pid = this._references.createReferenceId({
      dispose() {
        disposableStore == null ? void 0 : disposableStore.dispose();
      },
      items: normalizedResult
    });
    return {
      pid,
      items: normalizedResult.map((item, idx) => {
        let command = void 0;
        if (item.command) {
          if (!disposableStore) {
            disposableStore = new DisposableStore();
          }
          command = this._commands.toInternal(item.command, disposableStore);
        }
        const insertText = item.insertText;
        return {
          insertText: typeof insertText === "string" ? insertText : { snippet: insertText.value },
          filterText: item.filterText,
          range: item.range ? Range3.from(item.range) : void 0,
          command,
          idx,
          completeBracketPairs: this._isAdditionsProposedApiEnabled ? item.completeBracketPairs : false
        };
      }),
      commands: commands.map((c) => {
        if (!disposableStore) {
          disposableStore = new DisposableStore();
        }
        return this._commands.toInternal(c, disposableStore);
      }),
      suppressSuggestions: false,
      enableForwardStability
    };
  }
  disposeCompletions(pid) {
    const data = this._references.disposeReferenceId(pid);
    data == null ? void 0 : data.dispose();
  }
  handleDidShowCompletionItem(pid, idx, updatedInsertText) {
    var _a30;
    const completionItem = (_a30 = this._references.get(pid)) == null ? void 0 : _a30.items[idx];
    if (completionItem) {
      if (this._provider.handleDidShowCompletionItem && this._isAdditionsProposedApiEnabled) {
        this._provider.handleDidShowCompletionItem(completionItem, updatedInsertText);
      }
    }
  }
  handlePartialAccept(pid, idx, acceptedCharacters) {
    var _a30;
    const completionItem = (_a30 = this._references.get(pid)) == null ? void 0 : _a30.items[idx];
    if (completionItem) {
      if (this._provider.handleDidPartiallyAcceptCompletionItem && this._isAdditionsProposedApiEnabled) {
        this._provider.handleDidPartiallyAcceptCompletionItem(completionItem, acceptedCharacters);
      }
    }
  }
};
var ReferenceMap = class {
  constructor() {
    this._references = /* @__PURE__ */ new Map();
    this._idPool = 1;
  }
  createReferenceId(value) {
    const id = this._idPool++;
    this._references.set(id, value);
    return id;
  }
  disposeReferenceId(referenceId) {
    const value = this._references.get(referenceId);
    this._references.delete(referenceId);
    return value;
  }
  get(referenceId) {
    return this._references.get(referenceId);
  }
};
var SignatureHelpAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._cache = new Cache("SignatureHelp");
  }
  async provideSignatureHelp(resource, position, context, token) {
    const doc = this._documents.getDocument(resource);
    const pos = Position3.to(position);
    const vscodeContext = this.reviveContext(context);
    const value = await this._provider.provideSignatureHelp(doc, pos, token, vscodeContext);
    if (value) {
      const id = this._cache.add([value]);
      return { ...SignatureHelp2.from(value), id };
    }
    return void 0;
  }
  reviveContext(context) {
    let activeSignatureHelp = void 0;
    if (context.activeSignatureHelp) {
      const revivedSignatureHelp = SignatureHelp2.to(context.activeSignatureHelp);
      const saved = this._cache.get(context.activeSignatureHelp.id, 0);
      if (saved) {
        activeSignatureHelp = saved;
        activeSignatureHelp.activeSignature = revivedSignatureHelp.activeSignature;
        activeSignatureHelp.activeParameter = revivedSignatureHelp.activeParameter;
      } else {
        activeSignatureHelp = revivedSignatureHelp;
      }
    }
    return { ...context, activeSignatureHelp };
  }
  releaseSignatureHelp(id) {
    this._cache.delete(id);
  }
};
var InlayHintsAdapter = class {
  constructor(_documents, _commands2, _provider, _logService, _extension2) {
    this._documents = _documents;
    this._commands = _commands2;
    this._provider = _provider;
    this._logService = _logService;
    this._extension = _extension2;
    this._cache = new Cache("InlayHints");
    this._disposables = /* @__PURE__ */ new Map();
  }
  async provideInlayHints(resource, ran, token) {
    const doc = this._documents.getDocument(resource);
    const range = Range3.to(ran);
    const hints = await this._provider.provideInlayHints(doc, range, token);
    if (!Array.isArray(hints) || hints.length === 0) {
      this._logService.trace(`[InlayHints] NO inlay hints from '${this._extension.identifier.value}' for ${ran}`);
      return void 0;
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    const pid = this._cache.add(hints);
    this._disposables.set(pid, new DisposableStore());
    const result = { hints: [], cacheId: pid };
    for (let i = 0; i < hints.length; i++) {
      if (this._isValidInlayHint(hints[i], range)) {
        result.hints.push(this._convertInlayHint(hints[i], [pid, i]));
      }
    }
    this._logService.trace(`[InlayHints] ${result.hints.length} inlay hints from '${this._extension.identifier.value}' for ${ran}`);
    return result;
  }
  async resolveInlayHint(id, token) {
    if (typeof this._provider.resolveInlayHint !== "function") {
      return void 0;
    }
    const item = this._cache.get(...id);
    if (!item) {
      return void 0;
    }
    const hint = await this._provider.resolveInlayHint(item, token);
    if (!hint) {
      return void 0;
    }
    if (!this._isValidInlayHint(hint)) {
      return void 0;
    }
    return this._convertInlayHint(hint, id);
  }
  releaseHints(id) {
    var _a30;
    (_a30 = this._disposables.get(id)) == null ? void 0 : _a30.dispose();
    this._disposables.delete(id);
    this._cache.delete(id);
  }
  _isValidInlayHint(hint, range) {
    if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every((part) => part.value.length === 0)) {
      console.log("INVALID inlay hint, empty label", hint);
      return false;
    }
    if (range && !range.contains(hint.position)) {
      return false;
    }
    return true;
  }
  _convertInlayHint(hint, id) {
    const disposables = this._disposables.get(id[0]);
    if (!disposables) {
      throw Error("DisposableStore is missing...");
    }
    const result = {
      label: "",
      cacheId: id,
      tooltip: MarkdownString3.fromStrict(hint.tooltip),
      position: Position3.from(hint.position),
      textEdits: hint.textEdits && hint.textEdits.map(TextEdit2.from),
      kind: hint.kind && InlayHintKind2.from(hint.kind),
      paddingLeft: hint.paddingLeft,
      paddingRight: hint.paddingRight
    };
    if (typeof hint.label === "string") {
      result.label = hint.label;
    } else {
      result.label = hint.label.map((part) => {
        const result2 = { label: part.value };
        result2.tooltip = MarkdownString3.fromStrict(part.tooltip);
        if (Location.isLocation(part.location)) {
          result2.location = location.from(part.location);
        }
        if (part.command) {
          result2.command = this._commands.toInternal(part.command, disposables);
        }
        return result2;
      });
    }
    return result;
  }
};
var LinkProviderAdapter = class _LinkProviderAdapter {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._cache = new Cache("DocumentLink");
  }
  async provideLinks(resource, token) {
    const doc = this._documents.getDocument(resource);
    const links = await this._provider.provideDocumentLinks(doc, token);
    if (!Array.isArray(links) || links.length === 0) {
      return void 0;
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    if (typeof this._provider.resolveDocumentLink !== "function") {
      return { links: links.filter(_LinkProviderAdapter._validateLink).map(DocumentLink2.from) };
    } else {
      const pid = this._cache.add(links);
      const result = { links: [], cacheId: pid };
      for (let i = 0; i < links.length; i++) {
        if (!_LinkProviderAdapter._validateLink(links[i])) {
          continue;
        }
        const dto = DocumentLink2.from(links[i]);
        dto.cacheId = [pid, i];
        result.links.push(dto);
      }
      return result;
    }
  }
  static _validateLink(link) {
    if (link.target && link.target.path.length > 5e4) {
      console.warn("DROPPING link because it is too long");
      return false;
    }
    return true;
  }
  async resolveLink(id, token) {
    if (typeof this._provider.resolveDocumentLink !== "function") {
      return void 0;
    }
    const item = this._cache.get(...id);
    if (!item) {
      return void 0;
    }
    const link = await this._provider.resolveDocumentLink(item, token);
    if (!link || !_LinkProviderAdapter._validateLink(link)) {
      return void 0;
    }
    return DocumentLink2.from(link);
  }
  releaseLinks(id) {
    this._cache.delete(id);
  }
};
var ColorProviderAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideColors(resource, token) {
    const doc = this._documents.getDocument(resource);
    const colors = await this._provider.provideDocumentColors(doc, token);
    if (!Array.isArray(colors)) {
      return [];
    }
    const colorInfos = colors.map((ci) => {
      return {
        color: Color3.from(ci.color),
        range: Range3.from(ci.range)
      };
    });
    return colorInfos;
  }
  async provideColorPresentations(resource, raw, token) {
    const document2 = this._documents.getDocument(resource);
    const range = Range3.to(raw.range);
    const color2 = Color3.to(raw.color);
    const value = await this._provider.provideColorPresentations(color2, { document: document2, range }, token);
    if (!Array.isArray(value)) {
      return void 0;
    }
    return value.map(ColorPresentation2.from);
  }
};
var FoldingProviderAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideFoldingRanges(resource, context, token) {
    const doc = this._documents.getDocument(resource);
    const ranges = await this._provider.provideFoldingRanges(doc, context, token);
    if (!Array.isArray(ranges)) {
      return void 0;
    }
    return ranges.map(FoldingRange2.from);
  }
};
var SelectionRangeAdapter = class {
  constructor(_documents, _provider, _logService) {
    this._documents = _documents;
    this._provider = _provider;
    this._logService = _logService;
  }
  async provideSelectionRanges(resource, pos, token) {
    const document2 = this._documents.getDocument(resource);
    const positions = pos.map(Position3.to);
    const allProviderRanges = await this._provider.provideSelectionRanges(document2, positions, token);
    if (!isNonEmptyArray(allProviderRanges)) {
      return [];
    }
    if (allProviderRanges.length !== positions.length) {
      this._logService.warn("BAD selection ranges, provider must return ranges for each position");
      return [];
    }
    const allResults = [];
    for (let i = 0; i < positions.length; i++) {
      const oneResult = [];
      allResults.push(oneResult);
      let last = positions[i];
      let selectionRange = allProviderRanges[i];
      while (true) {
        if (!selectionRange.range.contains(last)) {
          throw new Error("INVALID selection range, must contain the previous range");
        }
        oneResult.push(SelectionRange2.from(selectionRange));
        if (!selectionRange.parent) {
          break;
        }
        last = selectionRange.range;
        selectionRange = selectionRange.parent;
      }
    }
    return allResults;
  }
};
var CallHierarchyAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._idPool = new IdGenerator("");
    this._cache = /* @__PURE__ */ new Map();
  }
  async prepareSession(uri, position, token) {
    const doc = this._documents.getDocument(uri);
    const pos = Position3.to(position);
    const items = await this._provider.prepareCallHierarchy(doc, pos, token);
    if (!items) {
      return void 0;
    }
    const sessionId = this._idPool.nextId();
    this._cache.set(sessionId, /* @__PURE__ */ new Map());
    if (Array.isArray(items)) {
      return items.map((item) => this._cacheAndConvertItem(sessionId, item));
    } else {
      return [this._cacheAndConvertItem(sessionId, items)];
    }
  }
  async provideCallsTo(sessionId, itemId, token) {
    const item = this._itemFromCache(sessionId, itemId);
    if (!item) {
      throw new Error("missing call hierarchy item");
    }
    const calls = await this._provider.provideCallHierarchyIncomingCalls(item, token);
    if (!calls) {
      return void 0;
    }
    return calls.map((call) => {
      return {
        from: this._cacheAndConvertItem(sessionId, call.from),
        fromRanges: call.fromRanges.map((r) => Range3.from(r))
      };
    });
  }
  async provideCallsFrom(sessionId, itemId, token) {
    const item = this._itemFromCache(sessionId, itemId);
    if (!item) {
      throw new Error("missing call hierarchy item");
    }
    const calls = await this._provider.provideCallHierarchyOutgoingCalls(item, token);
    if (!calls) {
      return void 0;
    }
    return calls.map((call) => {
      return {
        to: this._cacheAndConvertItem(sessionId, call.to),
        fromRanges: call.fromRanges.map((r) => Range3.from(r))
      };
    });
  }
  releaseSession(sessionId) {
    this._cache.delete(sessionId);
  }
  _cacheAndConvertItem(sessionId, item) {
    const map = this._cache.get(sessionId);
    const dto = CallHierarchyItem2.from(item, sessionId, map.size.toString(36));
    map.set(dto._itemId, item);
    return dto;
  }
  _itemFromCache(sessionId, itemId) {
    const map = this._cache.get(sessionId);
    return map == null ? void 0 : map.get(itemId);
  }
};
var TypeHierarchyAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
    this._idPool = new IdGenerator("");
    this._cache = /* @__PURE__ */ new Map();
  }
  async prepareSession(uri, position, token) {
    const doc = this._documents.getDocument(uri);
    const pos = Position3.to(position);
    const items = await this._provider.prepareTypeHierarchy(doc, pos, token);
    if (!items) {
      return void 0;
    }
    const sessionId = this._idPool.nextId();
    this._cache.set(sessionId, /* @__PURE__ */ new Map());
    if (Array.isArray(items)) {
      return items.map((item) => this._cacheAndConvertItem(sessionId, item));
    } else {
      return [this._cacheAndConvertItem(sessionId, items)];
    }
  }
  async provideSupertypes(sessionId, itemId, token) {
    const item = this._itemFromCache(sessionId, itemId);
    if (!item) {
      throw new Error("missing type hierarchy item");
    }
    const supertypes = await this._provider.provideTypeHierarchySupertypes(item, token);
    if (!supertypes) {
      return void 0;
    }
    return supertypes.map((supertype) => {
      return this._cacheAndConvertItem(sessionId, supertype);
    });
  }
  async provideSubtypes(sessionId, itemId, token) {
    const item = this._itemFromCache(sessionId, itemId);
    if (!item) {
      throw new Error("missing type hierarchy item");
    }
    const subtypes = await this._provider.provideTypeHierarchySubtypes(item, token);
    if (!subtypes) {
      return void 0;
    }
    return subtypes.map((subtype) => {
      return this._cacheAndConvertItem(sessionId, subtype);
    });
  }
  releaseSession(sessionId) {
    this._cache.delete(sessionId);
  }
  _cacheAndConvertItem(sessionId, item) {
    const map = this._cache.get(sessionId);
    const dto = TypeHierarchyItem2.from(item, sessionId, map.size.toString(36));
    map.set(dto._itemId, item);
    return dto;
  }
  _itemFromCache(sessionId, itemId) {
    const map = this._cache.get(sessionId);
    return map == null ? void 0 : map.get(itemId);
  }
};
var DocumentOnDropEditAdapter = class _DocumentOnDropEditAdapter {
  static toInternalProviderId(extId, editId) {
    return extId + "." + editId;
  }
  constructor(_proxy10, _documents, _provider, _handle4, _extension2) {
    this._proxy = _proxy10;
    this._documents = _documents;
    this._provider = _provider;
    this._handle = _handle4;
    this._extension = _extension2;
  }
  async provideDocumentOnDropEdits(requestId, uri, position, dataTransferDto, token) {
    var _a30;
    const doc = this._documents.getDocument(uri);
    const pos = Position3.to(position);
    const dataTransfer = DataTransfer2.toDataTransfer(dataTransferDto, async (id) => {
      return (await this._proxy.$resolveDocumentOnDropFileData(this._handle, requestId, id)).buffer;
    });
    const edit = await this._provider.provideDocumentDropEdits(doc, pos, dataTransfer, token);
    if (!edit) {
      return void 0;
    }
    return {
      label: edit.label ?? localize(
        "defaultDropLabel",
        "Drop using '{0}' extension",
        this._extension.displayName || this._extension.name
      ),
      yieldTo: (_a30 = edit.yieldTo) == null ? void 0 : _a30.map((yTo) => {
        return "mimeType" in yTo ? yTo : { providerId: _DocumentOnDropEditAdapter.toInternalProviderId(yTo.extensionId, yTo.providerId) };
      }),
      insertText: typeof edit.insertText === "string" ? edit.insertText : { snippet: edit.insertText.value },
      additionalEdit: edit.additionalEdit ? WorkspaceEdit2.from(edit.additionalEdit, void 0) : void 0
    };
  }
};
var MappedEditsAdapter = class {
  constructor(_documents, _provider) {
    this._documents = _documents;
    this._provider = _provider;
  }
  async provideMappedEdits(resource, codeBlocks, context, token) {
    const uri = URI.revive(resource);
    const doc = this._documents.getDocument(uri);
    const ctx = {
      selections: context.selections.map((s) => Selection3.to(s)),
      related: context.related.map((r) => ({ uri: URI.revive(r.uri), range: Range3.to(r.range) }))
    };
    const mappedEdits = await this._provider.provideMappedEdits(doc, codeBlocks, ctx, token);
    return mappedEdits ? WorkspaceEdit2.from(mappedEdits) : null;
  }
};
var AdapterData = class {
  constructor(adapter, extension) {
    this.adapter = adapter;
    this.extension = extension;
  }
};
var _ExtHostLanguageFeatures = class _ExtHostLanguageFeatures {
  constructor(mainContext, _uriTransformer, _documents, _commands2, _diagnostics, _logService, _apiDeprecation, _extensionTelemetry) {
    this._uriTransformer = _uriTransformer;
    this._documents = _documents;
    this._commands = _commands2;
    this._diagnostics = _diagnostics;
    this._logService = _logService;
    this._apiDeprecation = _apiDeprecation;
    this._extensionTelemetry = _extensionTelemetry;
    this._adapter = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadLanguageFeatures);
  }
  _transformDocumentSelector(selector, extension) {
    return DocumentSelector.from(selector, this._uriTransformer, extension);
  }
  _createDisposable(handle) {
    return new Disposable2(() => {
      this._adapter.delete(handle);
      this._proxy.$unregister(handle);
    });
  }
  _nextHandle() {
    return _ExtHostLanguageFeatures._handlePool++;
  }
  async _withAdapter(handle, ctor, callback, fallbackValue, tokenToRaceAgainst, doNotLog = false) {
    const data = this._adapter.get(handle);
    if (!data || !(data.adapter instanceof ctor)) {
      return fallbackValue;
    }
    const t1 = Date.now();
    if (!doNotLog) {
      this._logService.trace(`[${data.extension.identifier.value}] INVOKE provider '${callback.toString().replace(/[\r\n]/g, "")}'`);
    }
    const result = callback(data.adapter, data.extension);
    Promise.resolve(result).catch((err) => {
      if (!isCancellationError(err)) {
        this._logService.error(`[${data.extension.identifier.value}] provider FAILED`);
        this._logService.error(err);
        this._extensionTelemetry.onExtensionError(data.extension.identifier, err);
      }
    }).finally(() => {
      if (!doNotLog) {
        this._logService.trace(`[${data.extension.identifier.value}] provider DONE after ${Date.now() - t1}ms`);
      }
    });
    if (CancellationToken.isCancellationToken(tokenToRaceAgainst)) {
      return raceCancellationError(result, tokenToRaceAgainst);
    }
    return result;
  }
  _addNewAdapter(adapter, extension) {
    const handle = this._nextHandle();
    this._adapter.set(handle, new AdapterData(adapter, extension));
    return handle;
  }
  static _extLabel(ext) {
    return ext.displayName || ext.name;
  }
  registerDocumentSymbolProvider(extension, selector, provider, metadata) {
    const handle = this._addNewAdapter(new DocumentSymbolAdapter(this._documents, provider), extension);
    const displayName = metadata && metadata.label || _ExtHostLanguageFeatures._extLabel(extension);
    this._proxy.$registerDocumentSymbolProvider(handle, this._transformDocumentSelector(selector, extension), displayName);
    return this._createDisposable(handle);
  }
  $provideDocumentSymbols(handle, resource, token) {
    return this._withAdapter(handle, DocumentSymbolAdapter, (adapter) => adapter.provideDocumentSymbols(URI.revive(resource), token), void 0, token);
  }
  registerCodeLensProvider(extension, selector, provider) {
    const handle = this._nextHandle();
    const eventHandle = typeof provider.onDidChangeCodeLenses === "function" ? this._nextHandle() : void 0;
    this._adapter.set(handle, new AdapterData(
      new CodeLensAdapter(this._documents, this._commands.converter, provider),
      extension
    ));
    this._proxy.$registerCodeLensSupport(handle, this._transformDocumentSelector(selector, extension), eventHandle);
    let result = this._createDisposable(handle);
    if (eventHandle !== void 0) {
      const subscription = provider.onDidChangeCodeLenses((_) => this._proxy.$emitCodeLensEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideCodeLenses(handle, resource, token) {
    return this._withAdapter(handle, CodeLensAdapter, (adapter) => adapter.provideCodeLenses(URI.revive(resource), token), void 0, token);
  }
  $resolveCodeLens(handle, symbol, token) {
    return this._withAdapter(handle, CodeLensAdapter, (adapter) => adapter.resolveCodeLens(symbol, token), void 0, void 0);
  }
  $releaseCodeLenses(handle, cacheId) {
    this._withAdapter(handle, CodeLensAdapter, (adapter) => Promise.resolve(adapter.releaseCodeLenses(cacheId)), void 0, void 0);
  }
  registerDefinitionProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new DefinitionAdapter(this._documents, provider), extension);
    this._proxy.$registerDefinitionSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideDefinition(handle, resource, position, token) {
    return this._withAdapter(handle, DefinitionAdapter, (adapter) => adapter.provideDefinition(URI.revive(resource), position, token), [], token);
  }
  registerDeclarationProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new DeclarationAdapter(this._documents, provider), extension);
    this._proxy.$registerDeclarationSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideDeclaration(handle, resource, position, token) {
    return this._withAdapter(handle, DeclarationAdapter, (adapter) => adapter.provideDeclaration(URI.revive(resource), position, token), [], token);
  }
  registerImplementationProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new ImplementationAdapter(this._documents, provider), extension);
    this._proxy.$registerImplementationSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideImplementation(handle, resource, position, token) {
    return this._withAdapter(handle, ImplementationAdapter, (adapter) => adapter.provideImplementation(URI.revive(resource), position, token), [], token);
  }
  registerTypeDefinitionProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new TypeDefinitionAdapter(this._documents, provider), extension);
    this._proxy.$registerTypeDefinitionSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideTypeDefinition(handle, resource, position, token) {
    return this._withAdapter(handle, TypeDefinitionAdapter, (adapter) => adapter.provideTypeDefinition(URI.revive(resource), position, token), [], token);
  }
  registerHoverProvider(extension, selector, provider, extensionId) {
    const handle = this._addNewAdapter(new HoverAdapter(this._documents, provider), extension);
    this._proxy.$registerHoverProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideHover(handle, resource, position, token) {
    return this._withAdapter(handle, HoverAdapter, (adapter) => adapter.provideHover(URI.revive(resource), position, token), void 0, token);
  }
  registerEvaluatableExpressionProvider(extension, selector, provider, extensionId) {
    const handle = this._addNewAdapter(new EvaluatableExpressionAdapter(this._documents, provider), extension);
    this._proxy.$registerEvaluatableExpressionProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideEvaluatableExpression(handle, resource, position, token) {
    return this._withAdapter(handle, EvaluatableExpressionAdapter, (adapter) => adapter.provideEvaluatableExpression(URI.revive(resource), position, token), void 0, token);
  }
  registerInlineValuesProvider(extension, selector, provider, extensionId) {
    const eventHandle = typeof provider.onDidChangeInlineValues === "function" ? this._nextHandle() : void 0;
    const handle = this._addNewAdapter(new InlineValuesAdapter(this._documents, provider), extension);
    this._proxy.$registerInlineValuesProvider(handle, this._transformDocumentSelector(selector, extension), eventHandle);
    let result = this._createDisposable(handle);
    if (eventHandle !== void 0) {
      const subscription = provider.onDidChangeInlineValues((_) => this._proxy.$emitInlineValuesEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideInlineValues(handle, resource, range, context, token) {
    return this._withAdapter(handle, InlineValuesAdapter, (adapter) => adapter.provideInlineValues(URI.revive(resource), range, context, token), void 0, token);
  }
  registerDocumentHighlightProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new DocumentHighlightAdapter(this._documents, provider), extension);
    this._proxy.$registerDocumentHighlightProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideDocumentHighlights(handle, resource, position, token) {
    return this._withAdapter(handle, DocumentHighlightAdapter, (adapter) => adapter.provideDocumentHighlights(URI.revive(resource), position, token), void 0, token);
  }
  registerLinkedEditingRangeProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new LinkedEditingRangeAdapter(this._documents, provider), extension);
    this._proxy.$registerLinkedEditingRangeProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideLinkedEditingRanges(handle, resource, position, token) {
    return this._withAdapter(handle, LinkedEditingRangeAdapter, async (adapter) => {
      const res = await adapter.provideLinkedEditingRanges(URI.revive(resource), position, token);
      if (res) {
        return {
          ranges: res.ranges,
          wordPattern: res.wordPattern ? _ExtHostLanguageFeatures._serializeRegExp(res.wordPattern) : void 0
        };
      }
      return void 0;
    }, void 0, token);
  }
  registerReferenceProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new ReferenceAdapter(this._documents, provider), extension);
    this._proxy.$registerReferenceSupport(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideReferences(handle, resource, position, context, token) {
    return this._withAdapter(handle, ReferenceAdapter, (adapter) => adapter.provideReferences(URI.revive(resource), position, context, token), void 0, token);
  }
  registerCodeActionProvider(extension, selector, provider, metadata) {
    var _a30, _b;
    const store = new DisposableStore();
    const handle = this._addNewAdapter(new CodeActionAdapter(
      this._documents,
      this._commands.converter,
      this._diagnostics,
      provider,
      this._logService,
      extension,
      this._apiDeprecation
    ), extension);
    this._proxy.$registerQuickFixSupport(handle, this._transformDocumentSelector(selector, extension), {
      providedKinds: (_a30 = metadata == null ? void 0 : metadata.providedCodeActionKinds) == null ? void 0 : _a30.map((kind) => kind.value),
      documentation: (_b = metadata == null ? void 0 : metadata.documentation) == null ? void 0 : _b.map((x) => ({
        kind: x.kind.value,
        command: this._commands.converter.toInternal(x.command, store)
      }))
    }, _ExtHostLanguageFeatures._extLabel(extension), Boolean(provider.resolveCodeAction));
    store.add(this._createDisposable(handle));
    return store;
  }
  $provideCodeActions(handle, resource, rangeOrSelection, context, token) {
    return this._withAdapter(handle, CodeActionAdapter, (adapter) => adapter.provideCodeActions(URI.revive(resource), rangeOrSelection, context, token), void 0, token);
  }
  $resolveCodeAction(handle, id, token) {
    return this._withAdapter(handle, CodeActionAdapter, (adapter) => adapter.resolveCodeAction(id, token), {}, void 0);
  }
  $releaseCodeActions(handle, cacheId) {
    this._withAdapter(handle, CodeActionAdapter, (adapter) => Promise.resolve(adapter.releaseCodeActions(cacheId)), void 0, void 0);
  }
  registerDocumentFormattingEditProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new DocumentFormattingAdapter(this._documents, provider), extension);
    this._proxy.$registerDocumentFormattingSupport(handle, this._transformDocumentSelector(selector, extension), extension.identifier, extension.displayName || extension.name);
    return this._createDisposable(handle);
  }
  $provideDocumentFormattingEdits(handle, resource, options, token) {
    return this._withAdapter(handle, DocumentFormattingAdapter, (adapter) => adapter.provideDocumentFormattingEdits(URI.revive(resource), options, token), void 0, token);
  }
  registerDocumentRangeFormattingEditProvider(extension, selector, provider) {
    const canFormatMultipleRanges = typeof provider.provideDocumentRangesFormattingEdits === "function";
    const handle = this._addNewAdapter(new RangeFormattingAdapter(this._documents, provider), extension);
    this._proxy.$registerRangeFormattingSupport(handle, this._transformDocumentSelector(selector, extension), extension.identifier, extension.displayName || extension.name, canFormatMultipleRanges);
    return this._createDisposable(handle);
  }
  $provideDocumentRangeFormattingEdits(handle, resource, range, options, token) {
    return this._withAdapter(handle, RangeFormattingAdapter, (adapter) => adapter.provideDocumentRangeFormattingEdits(URI.revive(resource), range, options, token), void 0, token);
  }
  $provideDocumentRangesFormattingEdits(handle, resource, ranges, options, token) {
    return this._withAdapter(handle, RangeFormattingAdapter, (adapter) => adapter.provideDocumentRangesFormattingEdits(URI.revive(resource), ranges, options, token), void 0, token);
  }
  registerOnTypeFormattingEditProvider(extension, selector, provider, triggerCharacters) {
    const handle = this._addNewAdapter(new OnTypeFormattingAdapter(this._documents, provider), extension);
    this._proxy.$registerOnTypeFormattingSupport(handle, this._transformDocumentSelector(selector, extension), triggerCharacters, extension.identifier);
    return this._createDisposable(handle);
  }
  $provideOnTypeFormattingEdits(handle, resource, position, ch, options, token) {
    return this._withAdapter(handle, OnTypeFormattingAdapter, (adapter) => adapter.provideOnTypeFormattingEdits(URI.revive(resource), position, ch, options, token), void 0, token);
  }
  registerWorkspaceSymbolProvider(extension, provider) {
    const handle = this._addNewAdapter(new NavigateTypeAdapter(provider, this._logService), extension);
    this._proxy.$registerNavigateTypeSupport(handle, typeof provider.resolveWorkspaceSymbol === "function");
    return this._createDisposable(handle);
  }
  $provideWorkspaceSymbols(handle, search, token) {
    return this._withAdapter(handle, NavigateTypeAdapter, (adapter) => adapter.provideWorkspaceSymbols(search, token), { symbols: [] }, token);
  }
  $resolveWorkspaceSymbol(handle, symbol, token) {
    return this._withAdapter(handle, NavigateTypeAdapter, (adapter) => adapter.resolveWorkspaceSymbol(symbol, token), void 0, void 0);
  }
  $releaseWorkspaceSymbols(handle, id) {
    this._withAdapter(handle, NavigateTypeAdapter, (adapter) => adapter.releaseWorkspaceSymbols(id), void 0, void 0);
  }
  registerRenameProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new RenameAdapter(this._documents, provider, this._logService), extension);
    this._proxy.$registerRenameSupport(handle, this._transformDocumentSelector(selector, extension), RenameAdapter.supportsResolving(provider));
    return this._createDisposable(handle);
  }
  $provideRenameEdits(handle, resource, position, newName, token) {
    return this._withAdapter(handle, RenameAdapter, (adapter) => adapter.provideRenameEdits(URI.revive(resource), position, newName, token), void 0, token);
  }
  $resolveRenameLocation(handle, resource, position, token) {
    return this._withAdapter(handle, RenameAdapter, (adapter) => adapter.resolveRenameLocation(URI.revive(resource), position, token), void 0, token);
  }
  registerDocumentSemanticTokensProvider(extension, selector, provider, legend) {
    const handle = this._addNewAdapter(new DocumentSemanticTokensAdapter(this._documents, provider), extension);
    const eventHandle = typeof provider.onDidChangeSemanticTokens === "function" ? this._nextHandle() : void 0;
    this._proxy.$registerDocumentSemanticTokensProvider(handle, this._transformDocumentSelector(selector, extension), legend, eventHandle);
    let result = this._createDisposable(handle);
    if (eventHandle) {
      const subscription = provider.onDidChangeSemanticTokens((_) => this._proxy.$emitDocumentSemanticTokensEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideDocumentSemanticTokens(handle, resource, previousResultId, token) {
    return this._withAdapter(handle, DocumentSemanticTokensAdapter, (adapter) => adapter.provideDocumentSemanticTokens(URI.revive(resource), previousResultId, token), null, token);
  }
  $releaseDocumentSemanticTokens(handle, semanticColoringResultId) {
    this._withAdapter(handle, DocumentSemanticTokensAdapter, (adapter) => adapter.releaseDocumentSemanticColoring(semanticColoringResultId), void 0, void 0);
  }
  registerDocumentRangeSemanticTokensProvider(extension, selector, provider, legend) {
    const handle = this._addNewAdapter(new DocumentRangeSemanticTokensAdapter(this._documents, provider), extension);
    this._proxy.$registerDocumentRangeSemanticTokensProvider(handle, this._transformDocumentSelector(selector, extension), legend);
    return this._createDisposable(handle);
  }
  $provideDocumentRangeSemanticTokens(handle, resource, range, token) {
    return this._withAdapter(handle, DocumentRangeSemanticTokensAdapter, (adapter) => adapter.provideDocumentRangeSemanticTokens(URI.revive(resource), range, token), null, token);
  }
  registerCompletionItemProvider(extension, selector, provider, triggerCharacters) {
    const handle = this._addNewAdapter(new CompletionsAdapter(
      this._documents,
      this._commands.converter,
      provider,
      this._apiDeprecation,
      extension
    ), extension);
    this._proxy.$registerCompletionsProvider(handle, this._transformDocumentSelector(selector, extension), triggerCharacters, CompletionsAdapter.supportsResolving(provider), extension.identifier);
    return this._createDisposable(handle);
  }
  $provideCompletionItems(handle, resource, position, context, token) {
    return this._withAdapter(handle, CompletionsAdapter, (adapter) => adapter.provideCompletionItems(URI.revive(resource), position, context, token), void 0, token);
  }
  $resolveCompletionItem(handle, id, token) {
    return this._withAdapter(handle, CompletionsAdapter, (adapter) => adapter.resolveCompletionItem(id, token), void 0, token);
  }
  $releaseCompletionItems(handle, id) {
    this._withAdapter(handle, CompletionsAdapter, (adapter) => adapter.releaseCompletionItems(id), void 0, void 0);
  }
  registerInlineCompletionsProvider(extension, selector, provider, metadata) {
    var _a30;
    const adapter = new InlineCompletionAdapter(extension, this._documents, provider, this._commands.converter);
    const handle = this._addNewAdapter(adapter, extension);
    this._proxy.$registerInlineCompletionsSupport(handle, this._transformDocumentSelector(selector, extension), adapter.supportsHandleEvents, ExtensionIdentifier.toKey(extension.identifier.value), ((_a30 = metadata == null ? void 0 : metadata.yieldTo) == null ? void 0 : _a30.map((extId) => ExtensionIdentifier.toKey(extId))) || []);
    return this._createDisposable(handle);
  }
  $provideInlineCompletions(handle, resource, position, context, token) {
    return this._withAdapter(handle, InlineCompletionAdapterBase, (adapter) => adapter.provideInlineCompletions(URI.revive(resource), position, context, token), void 0, token);
  }
  $handleInlineCompletionDidShow(handle, pid, idx, updatedInsertText) {
    this._withAdapter(handle, InlineCompletionAdapterBase, async (adapter) => {
      adapter.handleDidShowCompletionItem(pid, idx, updatedInsertText);
    }, void 0, void 0);
  }
  $handleInlineCompletionPartialAccept(handle, pid, idx, acceptedCharacters) {
    this._withAdapter(handle, InlineCompletionAdapterBase, async (adapter) => {
      adapter.handlePartialAccept(pid, idx, acceptedCharacters);
    }, void 0, void 0);
  }
  $freeInlineCompletionsList(handle, pid) {
    this._withAdapter(handle, InlineCompletionAdapterBase, async (adapter) => {
      adapter.disposeCompletions(pid);
    }, void 0, void 0);
  }
  registerSignatureHelpProvider(extension, selector, provider, metadataOrTriggerChars) {
    const metadata = Array.isArray(metadataOrTriggerChars) ? { triggerCharacters: metadataOrTriggerChars, retriggerCharacters: [] } : metadataOrTriggerChars;
    const handle = this._addNewAdapter(new SignatureHelpAdapter(this._documents, provider), extension);
    this._proxy.$registerSignatureHelpProvider(handle, this._transformDocumentSelector(selector, extension), metadata);
    return this._createDisposable(handle);
  }
  $provideSignatureHelp(handle, resource, position, context, token) {
    return this._withAdapter(handle, SignatureHelpAdapter, (adapter) => adapter.provideSignatureHelp(URI.revive(resource), position, context, token), void 0, token);
  }
  $releaseSignatureHelp(handle, id) {
    this._withAdapter(handle, SignatureHelpAdapter, (adapter) => adapter.releaseSignatureHelp(id), void 0, void 0);
  }
  registerInlayHintsProvider(extension, selector, provider) {
    const eventHandle = typeof provider.onDidChangeInlayHints === "function" ? this._nextHandle() : void 0;
    const handle = this._addNewAdapter(new InlayHintsAdapter(
      this._documents,
      this._commands.converter,
      provider,
      this._logService,
      extension
    ), extension);
    this._proxy.$registerInlayHintsProvider(handle, this._transformDocumentSelector(selector, extension), typeof provider.resolveInlayHint === "function", eventHandle, _ExtHostLanguageFeatures._extLabel(extension));
    let result = this._createDisposable(handle);
    if (eventHandle !== void 0) {
      const subscription = provider.onDidChangeInlayHints((uri) => this._proxy.$emitInlayHintsEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideInlayHints(handle, resource, range, token) {
    return this._withAdapter(handle, InlayHintsAdapter, (adapter) => adapter.provideInlayHints(URI.revive(resource), range, token), void 0, token);
  }
  $resolveInlayHint(handle, id, token) {
    return this._withAdapter(handle, InlayHintsAdapter, (adapter) => adapter.resolveInlayHint(id, token), void 0, token);
  }
  $releaseInlayHints(handle, id) {
    this._withAdapter(handle, InlayHintsAdapter, (adapter) => adapter.releaseHints(id), void 0, void 0);
  }
  registerDocumentLinkProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new LinkProviderAdapter(this._documents, provider), extension);
    this._proxy.$registerDocumentLinkProvider(handle, this._transformDocumentSelector(selector, extension), typeof provider.resolveDocumentLink === "function");
    return this._createDisposable(handle);
  }
  $provideDocumentLinks(handle, resource, token) {
    return this._withAdapter(handle, LinkProviderAdapter, (adapter) => adapter.provideLinks(URI.revive(resource), token), void 0, token, resource.scheme === "output");
  }
  $resolveDocumentLink(handle, id, token) {
    return this._withAdapter(handle, LinkProviderAdapter, (adapter) => adapter.resolveLink(id, token), void 0, void 0, true);
  }
  $releaseDocumentLinks(handle, id) {
    this._withAdapter(handle, LinkProviderAdapter, (adapter) => adapter.releaseLinks(id), void 0, void 0, true);
  }
  registerColorProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new ColorProviderAdapter(this._documents, provider), extension);
    this._proxy.$registerDocumentColorProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideDocumentColors(handle, resource, token) {
    return this._withAdapter(handle, ColorProviderAdapter, (adapter) => adapter.provideColors(URI.revive(resource), token), [], token);
  }
  $provideColorPresentations(handle, resource, colorInfo, token) {
    return this._withAdapter(handle, ColorProviderAdapter, (adapter) => adapter.provideColorPresentations(URI.revive(resource), colorInfo, token), void 0, token);
  }
  registerFoldingRangeProvider(extension, selector, provider) {
    const handle = this._nextHandle();
    const eventHandle = typeof provider.onDidChangeFoldingRanges === "function" ? this._nextHandle() : void 0;
    this._adapter.set(handle, new AdapterData(
      new FoldingProviderAdapter(this._documents, provider),
      extension
    ));
    this._proxy.$registerFoldingRangeProvider(handle, this._transformDocumentSelector(selector, extension), extension.identifier, eventHandle);
    let result = this._createDisposable(handle);
    if (eventHandle !== void 0) {
      const subscription = provider.onDidChangeFoldingRanges(() => this._proxy.$emitFoldingRangeEvent(eventHandle));
      result = Disposable2.from(result, subscription);
    }
    return result;
  }
  $provideFoldingRanges(handle, resource, context, token) {
    return this._withAdapter(handle, FoldingProviderAdapter, (adapter) => adapter.provideFoldingRanges(URI.revive(resource), context, token), void 0, token);
  }
  registerSelectionRangeProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new SelectionRangeAdapter(this._documents, provider, this._logService), extension);
    this._proxy.$registerSelectionRangeProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideSelectionRanges(handle, resource, positions, token) {
    return this._withAdapter(handle, SelectionRangeAdapter, (adapter) => adapter.provideSelectionRanges(URI.revive(resource), positions, token), [], token);
  }
  registerCallHierarchyProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new CallHierarchyAdapter(this._documents, provider), extension);
    this._proxy.$registerCallHierarchyProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $prepareCallHierarchy(handle, resource, position, token) {
    return this._withAdapter(handle, CallHierarchyAdapter, (adapter) => Promise.resolve(adapter.prepareSession(URI.revive(resource), position, token)), void 0, token);
  }
  $provideCallHierarchyIncomingCalls(handle, sessionId, itemId, token) {
    return this._withAdapter(handle, CallHierarchyAdapter, (adapter) => adapter.provideCallsTo(sessionId, itemId, token), void 0, token);
  }
  $provideCallHierarchyOutgoingCalls(handle, sessionId, itemId, token) {
    return this._withAdapter(handle, CallHierarchyAdapter, (adapter) => adapter.provideCallsFrom(sessionId, itemId, token), void 0, token);
  }
  $releaseCallHierarchy(handle, sessionId) {
    this._withAdapter(handle, CallHierarchyAdapter, (adapter) => Promise.resolve(adapter.releaseSession(sessionId)), void 0, void 0);
  }
  registerTypeHierarchyProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new TypeHierarchyAdapter(this._documents, provider), extension);
    this._proxy.$registerTypeHierarchyProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $prepareTypeHierarchy(handle, resource, position, token) {
    return this._withAdapter(handle, TypeHierarchyAdapter, (adapter) => Promise.resolve(adapter.prepareSession(URI.revive(resource), position, token)), void 0, token);
  }
  $provideTypeHierarchySupertypes(handle, sessionId, itemId, token) {
    return this._withAdapter(handle, TypeHierarchyAdapter, (adapter) => adapter.provideSupertypes(sessionId, itemId, token), void 0, token);
  }
  $provideTypeHierarchySubtypes(handle, sessionId, itemId, token) {
    return this._withAdapter(handle, TypeHierarchyAdapter, (adapter) => adapter.provideSubtypes(sessionId, itemId, token), void 0, token);
  }
  $releaseTypeHierarchy(handle, sessionId) {
    this._withAdapter(handle, TypeHierarchyAdapter, (adapter) => Promise.resolve(adapter.releaseSession(sessionId)), void 0, void 0);
  }
  registerDocumentOnDropEditProvider(extension, selector, provider, metadata) {
    const handle = this._nextHandle();
    this._adapter.set(handle, new AdapterData(
      new DocumentOnDropEditAdapter(this._proxy, this._documents, provider, handle, extension),
      extension
    ));
    const id = isProposedApiEnabled(extension, "dropMetadata") && metadata ? DocumentOnDropEditAdapter.toInternalProviderId(extension.identifier.value, metadata.id) : void 0;
    this._proxy.$registerDocumentOnDropEditProvider(handle, this._transformDocumentSelector(selector, extension), id, isProposedApiEnabled(extension, "dropMetadata") ? metadata : void 0);
    return this._createDisposable(handle);
  }
  $provideDocumentOnDropEdits(handle, requestId, resource, position, dataTransferDto, token) {
    return this._withAdapter(handle, DocumentOnDropEditAdapter, (adapter) => Promise.resolve(adapter.provideDocumentOnDropEdits(requestId, URI.revive(resource), position, dataTransferDto, token)), void 0, void 0);
  }
  registerMappedEditsProvider(extension, selector, provider) {
    const handle = this._addNewAdapter(new MappedEditsAdapter(this._documents, provider), extension);
    this._proxy.$registerMappedEditsProvider(handle, this._transformDocumentSelector(selector, extension));
    return this._createDisposable(handle);
  }
  $provideMappedEdits(handle, document2, codeBlocks, context, token) {
    return this._withAdapter(handle, MappedEditsAdapter, (adapter) => Promise.resolve(adapter.provideMappedEdits(document2, codeBlocks, context, token)), null, token);
  }
  registerDocumentPasteEditProvider(extension, selector, provider, metadata) {
    const handle = this._nextHandle();
    this._adapter.set(handle, new AdapterData(
      new DocumentPasteEditProvider(this._proxy, this._documents, provider, handle, extension),
      extension
    ));
    const internalId = DocumentPasteEditProvider.toInternalProviderId(extension.identifier.value, metadata.id);
    this._proxy.$registerPasteEditProvider(handle, this._transformDocumentSelector(selector, extension), internalId, {
      supportsCopy: !!provider.prepareDocumentPaste,
      supportsPaste: !!provider.provideDocumentPasteEdits,
      copyMimeTypes: metadata.copyMimeTypes,
      pasteMimeTypes: metadata.pasteMimeTypes
    });
    return this._createDisposable(handle);
  }
  $prepareDocumentPaste(handle, resource, ranges, dataTransfer, token) {
    return this._withAdapter(handle, DocumentPasteEditProvider, (adapter) => adapter.prepareDocumentPaste(URI.revive(resource), ranges, dataTransfer, token), void 0, token);
  }
  $providePasteEdits(handle, requestId, resource, ranges, dataTransferDto, token) {
    return this._withAdapter(handle, DocumentPasteEditProvider, (adapter) => adapter.providePasteEdits(requestId, URI.revive(resource), ranges, dataTransferDto, token), void 0, token);
  }
  static _serializeRegExp(regExp) {
    return {
      pattern: regExp.source,
      flags: regExp.flags
    };
  }
  static _serializeIndentationRule(indentationRule) {
    return {
      decreaseIndentPattern: _ExtHostLanguageFeatures._serializeRegExp(indentationRule.decreaseIndentPattern),
      increaseIndentPattern: _ExtHostLanguageFeatures._serializeRegExp(indentationRule.increaseIndentPattern),
      indentNextLinePattern: indentationRule.indentNextLinePattern ? _ExtHostLanguageFeatures._serializeRegExp(indentationRule.indentNextLinePattern) : void 0,
      unIndentedLinePattern: indentationRule.unIndentedLinePattern ? _ExtHostLanguageFeatures._serializeRegExp(indentationRule.unIndentedLinePattern) : void 0
    };
  }
  static _serializeOnEnterRule(onEnterRule) {
    return {
      beforeText: _ExtHostLanguageFeatures._serializeRegExp(onEnterRule.beforeText),
      afterText: onEnterRule.afterText ? _ExtHostLanguageFeatures._serializeRegExp(onEnterRule.afterText) : void 0,
      previousLineText: onEnterRule.previousLineText ? _ExtHostLanguageFeatures._serializeRegExp(onEnterRule.previousLineText) : void 0,
      action: onEnterRule.action
    };
  }
  static _serializeOnEnterRules(onEnterRules) {
    return onEnterRules.map(_ExtHostLanguageFeatures._serializeOnEnterRule);
  }
  setLanguageConfiguration(extension, languageId, configuration) {
    const { wordPattern } = configuration;
    if (wordPattern && regExpLeadsToEndlessLoop(wordPattern)) {
      throw new Error(`Invalid language configuration: wordPattern '${wordPattern}' is not allowed to match the empty string.`);
    }
    if (wordPattern) {
      this._documents.setWordDefinitionFor(languageId, wordPattern);
    } else {
      this._documents.setWordDefinitionFor(languageId, void 0);
    }
    if (configuration.__electricCharacterSupport) {
      this._apiDeprecation.report("LanguageConfiguration.__electricCharacterSupport", extension, `Do not use.`);
    }
    if (configuration.__characterPairSupport) {
      this._apiDeprecation.report("LanguageConfiguration.__characterPairSupport", extension, `Do not use.`);
    }
    if (configuration.autoClosingPairs) {
      checkProposedApiEnabled(extension, "languageConfigurationAutoClosingPairs");
    }
    const handle = this._nextHandle();
    const serializedConfiguration = {
      comments: configuration.comments,
      brackets: configuration.brackets,
      wordPattern: configuration.wordPattern ? _ExtHostLanguageFeatures._serializeRegExp(configuration.wordPattern) : void 0,
      indentationRules: configuration.indentationRules ? _ExtHostLanguageFeatures._serializeIndentationRule(configuration.indentationRules) : void 0,
      onEnterRules: configuration.onEnterRules ? _ExtHostLanguageFeatures._serializeOnEnterRules(configuration.onEnterRules) : void 0,
      __electricCharacterSupport: configuration.__electricCharacterSupport,
      __characterPairSupport: configuration.__characterPairSupport,
      autoClosingPairs: configuration.autoClosingPairs
    };
    this._proxy.$setLanguageConfiguration(handle, languageId, serializedConfiguration);
    return this._createDisposable(handle);
  }
  $setWordDefinitions(wordDefinitions) {
    for (const wordDefinition of wordDefinitions) {
      this._documents.setWordDefinitionFor(wordDefinition.languageId, new RegExp(wordDefinition.regexSource, wordDefinition.regexFlags));
    }
  }
};
_ExtHostLanguageFeatures._handlePool = 0;
var ExtHostLanguageFeatures = _ExtHostLanguageFeatures;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLanguages.js
init_extHost_protocol();
init_extHostTypes();
init_async();
init_lifecycle();
var ExtHostLanguages = class {
  constructor(mainContext, _documents, _commands2, _uriTransformer) {
    this._documents = _documents;
    this._commands = _commands2;
    this._uriTransformer = _uriTransformer;
    this._languageIds = [];
    this._handlePool = 0;
    this._ids = /* @__PURE__ */ new Set();
    this._proxy = mainContext.getProxy(MainContext.MainThreadLanguages);
  }
  $acceptLanguageIds(ids) {
    this._languageIds = ids;
  }
  async getLanguages() {
    return this._languageIds.slice(0);
  }
  async changeLanguage(uri, languageId) {
    await this._proxy.$changeLanguage(uri, languageId);
    const data = this._documents.getDocumentData(uri);
    if (!data) {
      throw new Error(`document '${uri.toString()}' NOT found`);
    }
    return data.document;
  }
  async tokenAtPosition(document2, position) {
    const versionNow = document2.version;
    const pos = Position3.from(position);
    const info = await this._proxy.$tokensAtPosition(document2.uri, pos);
    const defaultRange = {
      type: StandardTokenType.Other,
      range: document2.getWordRangeAtPosition(position) ?? new Range2(position.line, position.character, position.line, position.character)
    };
    if (!info) {
      return defaultRange;
    }
    const result = {
      range: Range3.to(info.range),
      type: TokenType.to(info.type)
    };
    if (!result.range.contains(position)) {
      return defaultRange;
    }
    if (versionNow !== document2.version) {
      return defaultRange;
    }
    return result;
  }
  createLanguageStatusItem(extension, id, selector) {
    const handle = this._handlePool++;
    const proxy = this._proxy;
    const ids = this._ids;
    const fullyQualifiedId = `${extension.identifier.value}/${id}`;
    if (ids.has(fullyQualifiedId)) {
      throw new Error(`LanguageStatusItem with id '${id}' ALREADY exists`);
    }
    ids.add(fullyQualifiedId);
    const data = {
      selector,
      id,
      name: extension.displayName ?? extension.name,
      severity: LanguageStatusSeverity.Information,
      command: void 0,
      text: "",
      detail: "",
      busy: false
    };
    let soonHandle;
    const commandDisposables = new DisposableStore();
    const updateAsync = () => {
      soonHandle == null ? void 0 : soonHandle.dispose();
      if (!ids.has(fullyQualifiedId)) {
        console.warn(`LanguageStatusItem (${id}) from ${extension.identifier.value} has been disposed and CANNOT be updated anymore`);
        return;
      }
      soonHandle = disposableTimeout(() => {
        commandDisposables.clear();
        this._proxy.$setLanguageStatus(handle, {
          id: fullyQualifiedId,
          name: data.name ?? extension.displayName ?? extension.name,
          source: extension.displayName ?? extension.name,
          selector: DocumentSelector.from(data.selector, this._uriTransformer),
          label: data.text,
          detail: data.detail ?? "",
          severity: data.severity === LanguageStatusSeverity.Error ? severity_default.Error : data.severity === LanguageStatusSeverity.Warning ? severity_default.Warning : severity_default.Info,
          command: data.command && this._commands.toInternal(data.command, commandDisposables),
          accessibilityInfo: data.accessibilityInformation,
          busy: data.busy
        });
      }, 0);
    };
    const result = {
      dispose() {
        commandDisposables.dispose();
        soonHandle == null ? void 0 : soonHandle.dispose();
        proxy.$removeLanguageStatus(handle);
        ids.delete(fullyQualifiedId);
      },
      get id() {
        return data.id;
      },
      get name() {
        return data.name;
      },
      set name(value) {
        data.name = value;
        updateAsync();
      },
      get selector() {
        return data.selector;
      },
      set selector(value) {
        data.selector = value;
        updateAsync();
      },
      get text() {
        return data.text;
      },
      set text(value) {
        data.text = value;
        updateAsync();
      },
      get detail() {
        return data.detail;
      },
      set detail(value) {
        data.detail = value;
        updateAsync();
      },
      get severity() {
        return data.severity;
      },
      set severity(value) {
        data.severity = value;
        updateAsync();
      },
      get accessibilityInformation() {
        return data.accessibilityInformation;
      },
      set accessibilityInformation(value) {
        data.accessibilityInformation = value;
        updateAsync();
      },
      get command() {
        return data.command;
      },
      set command(value) {
        data.command = value;
        updateAsync();
      },
      get busy() {
        return data.busy;
      },
      set busy(value) {
        data.busy = value;
        updateAsync();
      }
    };
    updateAsync();
    return result;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostMessageService.js
init_tslib_es6();
init_extHost_protocol();
init_log();
function isMessageItem(item) {
  return item && item.title;
}
var ExtHostMessageService = class ExtHostMessageService2 {
  constructor(mainContext, _logService) {
    this._logService = _logService;
    this._proxy = mainContext.getProxy(MainContext.MainThreadMessageService);
  }
  showMessage(extension, severity, message, optionsOrFirstItem, rest) {
    const options = {
      source: { identifier: extension.identifier, label: extension.displayName || extension.name }
    };
    let items;
    if (typeof optionsOrFirstItem === "string" || isMessageItem(optionsOrFirstItem)) {
      items = [optionsOrFirstItem, ...rest];
    } else {
      options.modal = optionsOrFirstItem == null ? void 0 : optionsOrFirstItem.modal;
      options.useCustom = optionsOrFirstItem == null ? void 0 : optionsOrFirstItem.useCustom;
      options.detail = optionsOrFirstItem == null ? void 0 : optionsOrFirstItem.detail;
      items = rest;
    }
    if (options.useCustom) {
      checkProposedApiEnabled(extension, "resolvers");
    }
    const commands = [];
    for (let handle = 0; handle < items.length; handle++) {
      const command = items[handle];
      if (typeof command === "string") {
        commands.push({ title: command, handle, isCloseAffordance: false });
      } else if (typeof command === "object") {
        const { title, isCloseAffordance } = command;
        commands.push({ title, isCloseAffordance: !!isCloseAffordance, handle });
      } else {
        this._logService.warn("Invalid message item:", command);
      }
    }
    return this._proxy.$showMessage(severity, message, options, commands).then((handle) => {
      if (typeof handle === "number") {
        return items[handle];
      }
      return void 0;
    });
  }
};
ExtHostMessageService = __decorate([
  __param(1, ILogService)
], ExtHostMessageService);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostOutput.js
init_tslib_es6();
init_extHost_protocol();
init_instantiation();
init_extensions();
init_log();
init_buffer();
init_types();
init_files();
init_event();
init_lifecycle();
var ExtHostOutputChannel = class extends AbstractMessageLogger {
  get disposed() {
    return this._disposed;
  }
  constructor(id, name, logger, proxy, extension) {
    super();
    this.id = id;
    this.name = name;
    this.logger = logger;
    this.proxy = proxy;
    this.extension = extension;
    this.offset = 0;
    this._disposed = false;
    this.visible = false;
    this.setLevel(logger.getLevel());
    this._register(logger.onDidChangeLogLevel((level) => this.setLevel(level)));
  }
  get logLevel() {
    return this.getLevel();
  }
  appendLine(value) {
    this.append(value + "\n");
  }
  append(value) {
    this.info(value);
  }
  clear() {
    const till = this.offset;
    this.logger.flush();
    this.proxy.$update(this.id, OutputChannelUpdateMode.Clear, till);
  }
  replace(value) {
    const till = this.offset;
    this.info(value);
    this.proxy.$update(this.id, OutputChannelUpdateMode.Replace, till);
    if (this.visible) {
      this.logger.flush();
    }
  }
  show(columnOrPreserveFocus, preserveFocus) {
    this.logger.flush();
    this.proxy.$reveal(this.id, !!(typeof columnOrPreserveFocus === "boolean" ? columnOrPreserveFocus : preserveFocus));
  }
  hide() {
    this.proxy.$close(this.id);
  }
  log(level, message) {
    this.offset += VSBuffer.fromString(message).byteLength;
    log(this.logger, level, message);
    if (this.visible) {
      this.logger.flush();
      this.proxy.$update(this.id, OutputChannelUpdateMode.Append);
    }
  }
  dispose() {
    super.dispose();
    if (!this._disposed) {
      this.proxy.$dispose(this.id);
      this._disposed = true;
    }
  }
};
var ExtHostLogOutputChannel = class extends ExtHostOutputChannel {
  appendLine(value) {
    this.append(value);
  }
};
var ExtHostOutputService = class ExtHostOutputService2 {
  constructor(extHostRpc, initData, extHostFileSystem, extHostFileSystemInfo, loggerService, logService) {
    this.initData = initData;
    this.extHostFileSystem = extHostFileSystem;
    this.extHostFileSystemInfo = extHostFileSystemInfo;
    this.loggerService = loggerService;
    this.logService = logService;
    this.extensionLogDirectoryPromise = /* @__PURE__ */ new Map();
    this.namePool = 1;
    this.channels = /* @__PURE__ */ new Map();
    this.visibleChannelId = null;
    this.proxy = extHostRpc.getProxy(MainContext.MainThreadOutputService);
    this.outputsLocation = this.extHostFileSystemInfo.extUri.joinPath(initData.logsLocation, `output_logging_${toLocalISOString(/* @__PURE__ */ new Date()).replace(/-|:|\.\d+Z$/g, "")}`);
  }
  $setVisibleChannel(visibleChannelId) {
    this.visibleChannelId = visibleChannelId;
    for (const [id, channel] of this.channels) {
      channel.visible = id === this.visibleChannelId;
    }
  }
  createOutputChannel(name, options, extension) {
    var _a30, _b;
    name = name.trim();
    if (!name) {
      throw new Error("illegal argument `name`. must not be falsy");
    }
    const log3 = typeof options === "object" && options.log;
    const languageId = isString(options) ? options : void 0;
    if (isString(languageId) && !languageId.trim()) {
      throw new Error("illegal argument `languageId`. must not be empty");
    }
    let logLevel;
    const logLevelValue = (_b = (_a30 = this.initData.environment.extensionLogLevel) == null ? void 0 : _a30.find(([identifier]) => ExtensionIdentifier.equals(extension.identifier, identifier))) == null ? void 0 : _b[1];
    if (logLevelValue) {
      logLevel = parseLogLevel(logLevelValue);
    }
    const extHostOutputChannel = log3 ? this.doCreateLogOutputChannel(name, logLevel, extension) : this.doCreateOutputChannel(name, languageId, extension);
    extHostOutputChannel.then((channel) => {
      this.channels.set(channel.id, channel);
      channel.visible = channel.id === this.visibleChannelId;
    });
    return log3 ? this.createExtHostLogOutputChannel(name, logLevel ?? this.logService.getLevel(), extHostOutputChannel) : this.createExtHostOutputChannel(name, extHostOutputChannel);
  }
  async doCreateOutputChannel(name, languageId, extension) {
    if (!this.outputDirectoryPromise) {
      this.outputDirectoryPromise = this.extHostFileSystem.value.createDirectory(this.outputsLocation).then(() => this.outputsLocation);
    }
    const outputDir = await this.outputDirectoryPromise;
    const file = this.extHostFileSystemInfo.extUri.joinPath(outputDir, `${this.namePool++}-${name.replace(/[\\/:\*\?"<>\|]/g, "")}.log`);
    const logger = this.loggerService.createLogger(file, { logLevel: "always", donotRotate: true, donotUseFormatters: true, hidden: true });
    const id = await this.proxy.$register(name, file, languageId, extension.identifier.value);
    return new ExtHostOutputChannel(id, name, logger, this.proxy, extension);
  }
  async doCreateLogOutputChannel(name, logLevel, extension) {
    const extensionLogDir = await this.createExtensionLogDirectory(extension);
    const fileName = name.replace(/[\\/:\*\?"<>\|]/g, "");
    const file = this.extHostFileSystemInfo.extUri.joinPath(extensionLogDir, `${fileName}.log`);
    const id = `${extension.identifier.value}.${fileName}`;
    const logger = this.loggerService.createLogger(file, { id, name, logLevel, extensionId: extension.identifier.value });
    return new ExtHostLogOutputChannel(id, name, logger, this.proxy, extension);
  }
  createExtensionLogDirectory(extension) {
    let extensionLogDirectoryPromise = this.extensionLogDirectoryPromise.get(extension.identifier.value);
    if (!extensionLogDirectoryPromise) {
      const extensionLogDirectory = this.extHostFileSystemInfo.extUri.joinPath(this.initData.logsLocation, extension.identifier.value);
      this.extensionLogDirectoryPromise.set(extension.identifier.value, extensionLogDirectoryPromise = (async () => {
        try {
          await this.extHostFileSystem.value.createDirectory(extensionLogDirectory);
        } catch (err) {
          if (toFileSystemProviderErrorCode(err) !== FileSystemProviderErrorCode.FileExists) {
            throw err;
          }
        }
        return extensionLogDirectory;
      })());
    }
    return extensionLogDirectoryPromise;
  }
  createExtHostOutputChannel(name, channelPromise) {
    let disposed2 = false;
    const validate = () => {
      if (disposed2) {
        throw new Error("Channel has been closed");
      }
    };
    return {
      get name() {
        return name;
      },
      append(value) {
        validate();
        channelPromise.then((channel) => channel.append(value));
      },
      appendLine(value) {
        validate();
        channelPromise.then((channel) => channel.appendLine(value));
      },
      clear() {
        validate();
        channelPromise.then((channel) => channel.clear());
      },
      replace(value) {
        validate();
        channelPromise.then((channel) => channel.replace(value));
      },
      show(columnOrPreserveFocus, preserveFocus) {
        validate();
        channelPromise.then((channel) => channel.show(columnOrPreserveFocus, preserveFocus));
      },
      hide() {
        validate();
        channelPromise.then((channel) => channel.hide());
      },
      dispose() {
        disposed2 = true;
        channelPromise.then((channel) => channel.dispose());
      }
    };
  }
  createExtHostLogOutputChannel(name, logLevel, channelPromise) {
    const disposables = new DisposableStore();
    const validate = () => {
      if (disposables.isDisposed) {
        throw new Error("Channel has been closed");
      }
    };
    const onDidChangeLogLevel = disposables.add(new Emitter());
    function setLogLevel(newLogLevel) {
      logLevel = newLogLevel;
      onDidChangeLogLevel.fire(newLogLevel);
    }
    channelPromise.then((channel) => {
      disposables.add(channel);
      if (channel.logLevel !== logLevel) {
        setLogLevel(channel.logLevel);
      }
      disposables.add(channel.onDidChangeLogLevel((e) => setLogLevel(e)));
    });
    return {
      ...this.createExtHostOutputChannel(name, channelPromise),
      get logLevel() {
        return logLevel;
      },
      onDidChangeLogLevel: onDidChangeLogLevel.event,
      trace(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.trace(value, ...args));
      },
      debug(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.debug(value, ...args));
      },
      info(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.info(value, ...args));
      },
      warn(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.warn(value, ...args));
      },
      error(value, ...args) {
        validate();
        channelPromise.then((channel) => channel.error(value, ...args));
      },
      dispose() {
        disposables.dispose();
      }
    };
  }
};
ExtHostOutputService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, IExtHostConsumerFileSystem),
  __param(3, IExtHostFileSystemInfo),
  __param(4, ILoggerService),
  __param(5, ILogService)
], ExtHostOutputService);
var IExtHostOutputService = createDecorator("IExtHostOutputService");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostProgress.js
init_tslib_es6();
init_progress();
init_nls();
init_cancellation();
init_errors();
var ExtHostProgress = class {
  constructor(proxy) {
    this._handles = 0;
    this._mapHandleToCancellationSource = /* @__PURE__ */ new Map();
    this._proxy = proxy;
  }
  async withProgress(extension, options, task) {
    const handle = this._handles++;
    const { title, location: location2, cancellable } = options;
    const source = { label: localize(
      "extensionSource",
      "{0} (Extension)",
      extension.displayName || extension.name
    ), id: extension.identifier.value };
    this._proxy.$startProgress(handle, { location: ProgressLocation2.from(location2), title, source, cancellable }, !extension.isUnderDevelopment ? extension.identifier.value : void 0).catch(onUnexpectedExternalError);
    return this._withProgress(handle, task, !!cancellable);
  }
  _withProgress(handle, task, cancellable) {
    let source;
    if (cancellable) {
      source = new CancellationTokenSource();
      this._mapHandleToCancellationSource.set(handle, source);
    }
    const progressEnd = (handle2) => {
      this._proxy.$progressEnd(handle2);
      this._mapHandleToCancellationSource.delete(handle2);
      source == null ? void 0 : source.dispose();
    };
    let p;
    try {
      p = task(new ProgressCallback(this._proxy, handle), cancellable && source ? source.token : CancellationToken.None);
    } catch (err) {
      progressEnd(handle);
      throw err;
    }
    p.then((result) => progressEnd(handle), (err) => progressEnd(handle));
    return p;
  }
  $acceptProgressCanceled(handle) {
    const source = this._mapHandleToCancellationSource.get(handle);
    if (source) {
      source.cancel();
      this._mapHandleToCancellationSource.delete(handle);
    }
  }
};
function mergeProgress(result, currentValue) {
  result.message = currentValue.message;
  if (typeof currentValue.increment === "number") {
    if (typeof result.increment === "number") {
      result.increment += currentValue.increment;
    } else {
      result.increment = currentValue.increment;
    }
  }
  return result;
}
var ProgressCallback = class extends Progress {
  constructor(_proxy10, _handle4) {
    super((p) => this.throttledReport(p));
    this._proxy = _proxy10;
    this._handle = _handle4;
  }
  throttledReport(p) {
    this._proxy.$progressReport(this._handle, p);
  }
};
ProgressCallback.__decorator = __decorate([
  throttle(100, (result, currentValue) => mergeProgress(result, currentValue), () => /* @__PURE__ */ Object.create(null))
], ProgressCallback.prototype, "throttledReport", null);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostQuickOpen.js
init_cancellation();
init_event();
init_lifecycle();
init_extHost_protocol();
init_uri();
init_extHostTypes();
init_errors();
init_arrays();
init_themables();
function createExtHostQuickOpen(mainContext, workspace, commands) {
  const proxy = mainContext.getProxy(MainContext.MainThreadQuickOpen);
  class ExtHostQuickOpenImpl {
    constructor(workspace2, commands2) {
      this._sessions = /* @__PURE__ */ new Map();
      this._instances = 0;
      this._workspace = workspace2;
      this._commands = commands2;
    }
    showQuickPick(extension, itemsOrItemsPromise, options, token = CancellationToken.None) {
      this._onDidSelectItem = void 0;
      const itemsPromise = Promise.resolve(itemsOrItemsPromise);
      const instance = ++this._instances;
      const quickPickWidget = proxy.$show(instance, {
        title: options == null ? void 0 : options.title,
        placeHolder: options == null ? void 0 : options.placeHolder,
        matchOnDescription: options == null ? void 0 : options.matchOnDescription,
        matchOnDetail: options == null ? void 0 : options.matchOnDetail,
        ignoreFocusLost: options == null ? void 0 : options.ignoreFocusOut,
        canPickMany: options == null ? void 0 : options.canPickMany
      }, token);
      const widgetClosedMarker = {};
      const widgetClosedPromise = quickPickWidget.then(() => widgetClosedMarker);
      return Promise.race([widgetClosedPromise, itemsPromise]).then((result) => {
        if (result === widgetClosedMarker) {
          return void 0;
        }
        const allowedTooltips = isProposedApiEnabled(extension, "quickPickItemTooltip");
        return itemsPromise.then((items) => {
          const pickItems = [];
          for (let handle = 0; handle < items.length; handle++) {
            const item = items[handle];
            if (typeof item === "string") {
              pickItems.push({ label: item, handle });
            } else if (item.kind === QuickPickItemKind.Separator) {
              pickItems.push({ type: "separator", label: item.label });
            } else {
              if (item.tooltip && !allowedTooltips) {
                console.warn(`Extension '${extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${extension.identifier.value}`);
              }
              const icon = item.iconPath ? getIconPathOrClass(item.iconPath) : void 0;
              pickItems.push({
                label: item.label,
                iconPath: icon == null ? void 0 : icon.iconPath,
                iconClass: icon == null ? void 0 : icon.iconClass,
                description: item.description,
                detail: item.detail,
                picked: item.picked,
                alwaysShow: item.alwaysShow,
                tooltip: allowedTooltips ? MarkdownString3.fromStrict(item.tooltip) : void 0,
                handle
              });
            }
          }
          if (options && typeof options.onDidSelectItem === "function") {
            this._onDidSelectItem = (handle) => {
              options.onDidSelectItem(items[handle]);
            };
          }
          proxy.$setItems(instance, pickItems);
          return quickPickWidget.then((handle) => {
            if (typeof handle === "number") {
              return items[handle];
            } else if (Array.isArray(handle)) {
              return handle.map((h) => items[h]);
            }
            return void 0;
          });
        });
      }).then(void 0, (err) => {
        if (isCancellationError(err)) {
          return void 0;
        }
        proxy.$setError(instance, err);
        return Promise.reject(err);
      });
    }
    $onItemSelected(handle) {
      var _a30;
      (_a30 = this._onDidSelectItem) == null ? void 0 : _a30.call(this, handle);
    }
    showInput(options, token = CancellationToken.None) {
      this._validateInput = options == null ? void 0 : options.validateInput;
      return proxy.$input(options, typeof this._validateInput === "function", token).then(void 0, (err) => {
        if (isCancellationError(err)) {
          return void 0;
        }
        return Promise.reject(err);
      });
    }
    async $validateInput(input) {
      if (!this._validateInput) {
        return;
      }
      const result = await this._validateInput(input);
      if (!result || typeof result === "string") {
        return result;
      }
      let severity;
      switch (result.severity) {
        case InputBoxValidationSeverity.Info:
          severity = severity_default.Info;
          break;
        case InputBoxValidationSeverity.Warning:
          severity = severity_default.Warning;
          break;
        case InputBoxValidationSeverity.Error:
          severity = severity_default.Error;
          break;
        default:
          severity = result.message ? severity_default.Error : severity_default.Ignore;
          break;
      }
      return {
        content: result.message,
        severity
      };
    }
    async showWorkspaceFolderPick(options, token = CancellationToken.None) {
      const selectedFolder = await this._commands.executeCommand("_workbench.pickWorkspaceFolder", [options]);
      if (!selectedFolder) {
        return void 0;
      }
      const workspaceFolders = await this._workspace.getWorkspaceFolders2();
      if (!workspaceFolders) {
        return void 0;
      }
      return workspaceFolders.find((folder) => folder.uri.toString() === selectedFolder.uri.toString());
    }
    createQuickPick(extension) {
      const session = new ExtHostQuickPick(extension, () => this._sessions.delete(session._id));
      this._sessions.set(session._id, session);
      return session;
    }
    createInputBox(extension) {
      const session = new ExtHostInputBox(extension, () => this._sessions.delete(session._id));
      this._sessions.set(session._id, session);
      return session;
    }
    $onDidChangeValue(sessionId, value) {
      const session = this._sessions.get(sessionId);
      session == null ? void 0 : session._fireDidChangeValue(value);
    }
    $onDidAccept(sessionId) {
      const session = this._sessions.get(sessionId);
      session == null ? void 0 : session._fireDidAccept();
    }
    $onDidChangeActive(sessionId, handles) {
      const session = this._sessions.get(sessionId);
      if (session instanceof ExtHostQuickPick) {
        session._fireDidChangeActive(handles);
      }
    }
    $onDidChangeSelection(sessionId, handles) {
      const session = this._sessions.get(sessionId);
      if (session instanceof ExtHostQuickPick) {
        session._fireDidChangeSelection(handles);
      }
    }
    $onDidTriggerButton(sessionId, handle) {
      const session = this._sessions.get(sessionId);
      session == null ? void 0 : session._fireDidTriggerButton(handle);
    }
    $onDidTriggerItemButton(sessionId, itemHandle, buttonHandle) {
      const session = this._sessions.get(sessionId);
      if (session instanceof ExtHostQuickPick) {
        session._fireDidTriggerItemButton(itemHandle, buttonHandle);
      }
    }
    $onDidHide(sessionId) {
      const session = this._sessions.get(sessionId);
      session == null ? void 0 : session._fireDidHide();
    }
  }
  const _ExtHostQuickInput = class _ExtHostQuickInput {
    constructor(_extensionId, _onDidDispose3) {
      this._extensionId = _extensionId;
      this._onDidDispose = _onDidDispose3;
      this._id = ExtHostQuickPick._nextId++;
      this._visible = false;
      this._expectingHide = false;
      this._enabled = true;
      this._busy = false;
      this._ignoreFocusOut = true;
      this._value = "";
      this._buttons = [];
      this._handlesToButtons = /* @__PURE__ */ new Map();
      this._onDidAcceptEmitter = new Emitter();
      this._onDidChangeValueEmitter = new Emitter();
      this._onDidTriggerButtonEmitter = new Emitter();
      this._onDidHideEmitter = new Emitter();
      this._pendingUpdate = { id: this._id };
      this._disposed = false;
      this._disposables = [
        this._onDidTriggerButtonEmitter,
        this._onDidHideEmitter,
        this._onDidAcceptEmitter,
        this._onDidChangeValueEmitter
      ];
      this.onDidChangeValue = this._onDidChangeValueEmitter.event;
      this.onDidAccept = this._onDidAcceptEmitter.event;
      this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event;
      this.onDidHide = this._onDidHideEmitter.event;
    }
    get title() {
      return this._title;
    }
    set title(title) {
      this._title = title;
      this.update({ title });
    }
    get step() {
      return this._steps;
    }
    set step(step) {
      this._steps = step;
      this.update({ step });
    }
    get totalSteps() {
      return this._totalSteps;
    }
    set totalSteps(totalSteps) {
      this._totalSteps = totalSteps;
      this.update({ totalSteps });
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(enabled) {
      this._enabled = enabled;
      this.update({ enabled });
    }
    get busy() {
      return this._busy;
    }
    set busy(busy) {
      this._busy = busy;
      this.update({ busy });
    }
    get ignoreFocusOut() {
      return this._ignoreFocusOut;
    }
    set ignoreFocusOut(ignoreFocusOut) {
      this._ignoreFocusOut = ignoreFocusOut;
      this.update({ ignoreFocusOut });
    }
    get value() {
      return this._value;
    }
    set value(value) {
      this._value = value;
      this.update({ value });
    }
    get placeholder() {
      return this._placeholder;
    }
    set placeholder(placeholder) {
      this._placeholder = placeholder;
      this.update({ placeholder });
    }
    get buttons() {
      return this._buttons;
    }
    set buttons(buttons) {
      this._buttons = buttons.slice();
      this._handlesToButtons.clear();
      buttons.forEach((button, i) => {
        const handle = button === QuickInputButtons.Back ? -1 : i;
        this._handlesToButtons.set(handle, button);
      });
      this.update({
        buttons: buttons.map((button, i) => {
          return {
            ...getIconPathOrClass(button.iconPath),
            tooltip: button.tooltip,
            handle: button === QuickInputButtons.Back ? -1 : i
          };
        })
      });
    }
    show() {
      this._visible = true;
      this._expectingHide = true;
      this.update({ visible: true });
    }
    hide() {
      this._visible = false;
      this.update({ visible: false });
    }
    _fireDidAccept() {
      this._onDidAcceptEmitter.fire();
    }
    _fireDidChangeValue(value) {
      this._value = value;
      this._onDidChangeValueEmitter.fire(value);
    }
    _fireDidTriggerButton(handle) {
      const button = this._handlesToButtons.get(handle);
      if (button) {
        this._onDidTriggerButtonEmitter.fire(button);
      }
    }
    _fireDidHide() {
      if (this._expectingHide) {
        this._expectingHide = this._visible;
        this._onDidHideEmitter.fire();
      }
    }
    dispose() {
      if (this._disposed) {
        return;
      }
      this._disposed = true;
      this._fireDidHide();
      this._disposables = dispose(this._disposables);
      if (this._updateTimeout) {
        clearTimeout(this._updateTimeout);
        this._updateTimeout = void 0;
      }
      this._onDidDispose();
      proxy.$dispose(this._id);
    }
    update(properties) {
      if (this._disposed) {
        return;
      }
      for (const key of Object.keys(properties)) {
        const value = properties[key];
        this._pendingUpdate[key] = value === void 0 ? null : value;
      }
      if ("visible" in this._pendingUpdate) {
        if (this._updateTimeout) {
          clearTimeout(this._updateTimeout);
          this._updateTimeout = void 0;
        }
        this.dispatchUpdate();
      } else if (this._visible && !this._updateTimeout) {
        this._updateTimeout = setTimeout(() => {
          this._updateTimeout = void 0;
          this.dispatchUpdate();
        }, 0);
      }
    }
    dispatchUpdate() {
      proxy.$createOrUpdate(this._pendingUpdate);
      this._pendingUpdate = { id: this._id };
    }
  };
  _ExtHostQuickInput._nextId = 1;
  let ExtHostQuickInput = _ExtHostQuickInput;
  function getIconUris(iconPath) {
    if (iconPath instanceof ThemeIcon2) {
      return { id: iconPath.id };
    }
    const dark = getDarkIconUri(iconPath);
    const light = getLightIconUri(iconPath);
    return {
      dark: typeof dark === "string" ? URI.file(dark) : dark,
      light: typeof light === "string" ? URI.file(light) : light
    };
  }
  function getLightIconUri(iconPath) {
    return typeof iconPath === "object" && "light" in iconPath ? iconPath.light : iconPath;
  }
  function getDarkIconUri(iconPath) {
    return typeof iconPath === "object" && "dark" in iconPath ? iconPath.dark : iconPath;
  }
  function getIconPathOrClass(icon) {
    const iconPathOrIconClass = getIconUris(icon);
    let iconPath;
    let iconClass;
    if ("id" in iconPathOrIconClass) {
      iconClass = ThemeIcon.asClassName(iconPathOrIconClass);
    } else {
      iconPath = iconPathOrIconClass;
    }
    return {
      iconPath,
      iconClass
    };
  }
  class ExtHostQuickPick extends ExtHostQuickInput {
    constructor(extension, onDispose) {
      super(extension.identifier, onDispose);
      this.extension = extension;
      this._items = [];
      this._handlesToItems = /* @__PURE__ */ new Map();
      this._itemsToHandles = /* @__PURE__ */ new Map();
      this._canSelectMany = false;
      this._matchOnDescription = true;
      this._matchOnDetail = true;
      this._sortByLabel = true;
      this._keepScrollPosition = false;
      this._activeItems = [];
      this._onDidChangeActiveEmitter = new Emitter();
      this._selectedItems = [];
      this._onDidChangeSelectionEmitter = new Emitter();
      this._onDidTriggerItemButtonEmitter = new Emitter();
      this.onDidChangeActive = this._onDidChangeActiveEmitter.event;
      this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event;
      this.onDidTriggerItemButton = this._onDidTriggerItemButtonEmitter.event;
      this._disposables.push(this._onDidChangeActiveEmitter, this._onDidChangeSelectionEmitter, this._onDidTriggerItemButtonEmitter);
      this.update({ type: "quickPick" });
    }
    get items() {
      return this._items;
    }
    set items(items) {
      var _a30;
      this._items = items.slice();
      this._handlesToItems.clear();
      this._itemsToHandles.clear();
      items.forEach((item, i) => {
        this._handlesToItems.set(i, item);
        this._itemsToHandles.set(item, i);
      });
      const allowedTooltips = isProposedApiEnabled(this.extension, "quickPickItemTooltip");
      const pickItems = [];
      for (let handle = 0; handle < items.length; handle++) {
        const item = items[handle];
        if (item.kind === QuickPickItemKind.Separator) {
          pickItems.push({ type: "separator", label: item.label });
        } else {
          if (item.tooltip && !allowedTooltips) {
            console.warn(`Extension '${this.extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this.extension.identifier.value}`);
          }
          const icon = item.iconPath ? getIconPathOrClass(item.iconPath) : void 0;
          pickItems.push({
            handle,
            label: item.label,
            iconPath: icon == null ? void 0 : icon.iconPath,
            iconClass: icon == null ? void 0 : icon.iconClass,
            description: item.description,
            detail: item.detail,
            picked: item.picked,
            alwaysShow: item.alwaysShow,
            tooltip: allowedTooltips ? MarkdownString3.fromStrict(item.tooltip) : void 0,
            buttons: (_a30 = item.buttons) == null ? void 0 : _a30.map((button, i) => {
              return {
                ...getIconPathOrClass(button.iconPath),
                tooltip: button.tooltip,
                handle: i
              };
            })
          });
        }
      }
      this.update({
        items: pickItems
      });
    }
    get canSelectMany() {
      return this._canSelectMany;
    }
    set canSelectMany(canSelectMany) {
      this._canSelectMany = canSelectMany;
      this.update({ canSelectMany });
    }
    get matchOnDescription() {
      return this._matchOnDescription;
    }
    set matchOnDescription(matchOnDescription) {
      this._matchOnDescription = matchOnDescription;
      this.update({ matchOnDescription });
    }
    get matchOnDetail() {
      return this._matchOnDetail;
    }
    set matchOnDetail(matchOnDetail) {
      this._matchOnDetail = matchOnDetail;
      this.update({ matchOnDetail });
    }
    get sortByLabel() {
      return this._sortByLabel;
    }
    set sortByLabel(sortByLabel) {
      this._sortByLabel = sortByLabel;
      this.update({ sortByLabel });
    }
    get keepScrollPosition() {
      return this._keepScrollPosition;
    }
    set keepScrollPosition(keepScrollPosition) {
      this._keepScrollPosition = keepScrollPosition;
      this.update({ keepScrollPosition });
    }
    get activeItems() {
      return this._activeItems;
    }
    set activeItems(activeItems) {
      this._activeItems = activeItems.filter((item) => this._itemsToHandles.has(item));
      this.update({ activeItems: this._activeItems.map((item) => this._itemsToHandles.get(item)) });
    }
    get selectedItems() {
      return this._selectedItems;
    }
    set selectedItems(selectedItems) {
      this._selectedItems = selectedItems.filter((item) => this._itemsToHandles.has(item));
      this.update({ selectedItems: this._selectedItems.map((item) => this._itemsToHandles.get(item)) });
    }
    _fireDidChangeActive(handles) {
      const items = coalesce(handles.map((handle) => this._handlesToItems.get(handle)));
      this._activeItems = items;
      this._onDidChangeActiveEmitter.fire(items);
    }
    _fireDidChangeSelection(handles) {
      const items = coalesce(handles.map((handle) => this._handlesToItems.get(handle)));
      this._selectedItems = items;
      this._onDidChangeSelectionEmitter.fire(items);
    }
    _fireDidTriggerItemButton(itemHandle, buttonHandle) {
      const item = this._handlesToItems.get(itemHandle);
      if (!item || !item.buttons || !item.buttons.length) {
        return;
      }
      const button = item.buttons[buttonHandle];
      if (button) {
        this._onDidTriggerItemButtonEmitter.fire({
          button,
          item
        });
      }
    }
  }
  class ExtHostInputBox extends ExtHostQuickInput {
    constructor(extension, onDispose) {
      super(extension.identifier, onDispose);
      this._password = false;
      this.update({ type: "inputBox" });
    }
    get password() {
      return this._password;
    }
    set password(password) {
      this._password = password;
      this.update({ password });
    }
    get prompt() {
      return this._prompt;
    }
    set prompt(prompt) {
      this._prompt = prompt;
      this.update({ prompt });
    }
    get valueSelection() {
      return this._valueSelection;
    }
    set valueSelection(valueSelection) {
      this._valueSelection = valueSelection;
      this.update({ valueSelection });
    }
    get validationMessage() {
      return this._validationMessage;
    }
    set validationMessage(validationMessage) {
      this._validationMessage = validationMessage;
      if (!validationMessage) {
        this.update({ validationMessage: void 0, severity: severity_default.Ignore });
      } else if (typeof validationMessage === "string") {
        this.update({ validationMessage, severity: severity_default.Error });
      } else {
        this.update({ validationMessage: validationMessage.message, severity: validationMessage.severity ?? severity_default.Error });
      }
    }
  }
  return new ExtHostQuickOpenImpl(workspace, commands);
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSCM.js
init_tslib_es6();
init_uri();
init_event();
init_lifecycle();
init_async();
init_extHost_protocol();
init_arrays();
init_log();
init_extensions();
init_themables();
init_network();
var ExtHostSCM_1;
function getIconResource(decorations) {
  if (!decorations) {
    return void 0;
  } else if (typeof decorations.iconPath === "string") {
    return URI.file(decorations.iconPath);
  } else if (URI.isUri(decorations.iconPath)) {
    return decorations.iconPath;
  } else if (ThemeIcon.isThemeIcon(decorations.iconPath)) {
    return decorations.iconPath;
  } else {
    return void 0;
  }
}
function compareResourceThemableDecorations(a, b) {
  if (!a.iconPath && !b.iconPath) {
    return 0;
  } else if (!a.iconPath) {
    return -1;
  } else if (!b.iconPath) {
    return 1;
  }
  const aPath = typeof a.iconPath === "string" ? a.iconPath : URI.isUri(a.iconPath) ? a.iconPath.fsPath : a.iconPath.id;
  const bPath = typeof b.iconPath === "string" ? b.iconPath : URI.isUri(b.iconPath) ? b.iconPath.fsPath : b.iconPath.id;
  return comparePaths(aPath, bPath);
}
function compareResourceStatesDecorations(a, b) {
  let result = 0;
  if (a.strikeThrough !== b.strikeThrough) {
    return a.strikeThrough ? 1 : -1;
  }
  if (a.faded !== b.faded) {
    return a.faded ? 1 : -1;
  }
  if (a.tooltip !== b.tooltip) {
    return (a.tooltip || "").localeCompare(b.tooltip || "");
  }
  result = compareResourceThemableDecorations(a, b);
  if (result !== 0) {
    return result;
  }
  if (a.light && b.light) {
    result = compareResourceThemableDecorations(a.light, b.light);
  } else if (a.light) {
    return 1;
  } else if (b.light) {
    return -1;
  }
  if (result !== 0) {
    return result;
  }
  if (a.dark && b.dark) {
    result = compareResourceThemableDecorations(a.dark, b.dark);
  } else if (a.dark) {
    return 1;
  } else if (b.dark) {
    return -1;
  }
  return result;
}
function compareCommands(a, b) {
  if (a.command !== b.command) {
    return a.command < b.command ? -1 : 1;
  }
  if (a.title !== b.title) {
    return a.title < b.title ? -1 : 1;
  }
  if (a.tooltip !== b.tooltip) {
    if (a.tooltip !== void 0 && b.tooltip !== void 0) {
      return a.tooltip < b.tooltip ? -1 : 1;
    } else if (a.tooltip !== void 0) {
      return 1;
    } else if (b.tooltip !== void 0) {
      return -1;
    }
  }
  if (a.arguments === b.arguments) {
    return 0;
  } else if (!a.arguments) {
    return -1;
  } else if (!b.arguments) {
    return 1;
  } else if (a.arguments.length !== b.arguments.length) {
    return a.arguments.length - b.arguments.length;
  }
  for (let i = 0; i < a.arguments.length; i++) {
    const aArg = a.arguments[i];
    const bArg = b.arguments[i];
    if (aArg === bArg) {
      continue;
    }
    return aArg < bArg ? -1 : 1;
  }
  return 0;
}
function compareResourceStates(a, b) {
  let result = comparePaths(a.resourceUri.fsPath, b.resourceUri.fsPath, true);
  if (result !== 0) {
    return result;
  }
  if (a.command && b.command) {
    result = compareCommands(a.command, b.command);
  } else if (a.command) {
    return 1;
  } else if (b.command) {
    return -1;
  }
  if (result !== 0) {
    return result;
  }
  if (a.decorations && b.decorations) {
    result = compareResourceStatesDecorations(a.decorations, b.decorations);
  } else if (a.decorations) {
    return 1;
  } else if (b.decorations) {
    return -1;
  }
  return result;
}
function compareArgs(a, b) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function commandEquals(a, b) {
  return a.command === b.command && a.title === b.title && a.tooltip === b.tooltip && (a.arguments && b.arguments ? compareArgs(a.arguments, b.arguments) : a.arguments === b.arguments);
}
function commandListEquals(a, b) {
  return equals(a, b, commandEquals);
}
var _proxy3, _extHostDocuments;
var ExtHostSCMInputBox = class {
  constructor(_extension2, _extHostDocuments2, proxy, _sourceControlHandle, _documentUri) {
    __privateAdd(this, _proxy3, void 0);
    __privateAdd(this, _extHostDocuments, void 0);
    this._extension = _extension2;
    this._sourceControlHandle = _sourceControlHandle;
    this._documentUri = _documentUri;
    this._value = "";
    this._onDidChange = new Emitter();
    this._placeholder = "";
    this._enabled = true;
    this._visible = true;
    __privateSet(this, _extHostDocuments, _extHostDocuments2);
    __privateSet(this, _proxy3, proxy);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    value = value ?? "";
    __privateGet(this, _proxy3).$setInputBoxValue(this._sourceControlHandle, value);
    this.updateValue(value);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(placeholder) {
    __privateGet(this, _proxy3).$setInputBoxPlaceholder(this._sourceControlHandle, placeholder);
    this._placeholder = placeholder;
  }
  get validateInput() {
    checkProposedApiEnabled(this._extension, "scmValidation");
    return this._validateInput;
  }
  set validateInput(fn) {
    checkProposedApiEnabled(this._extension, "scmValidation");
    if (fn && typeof fn !== "function") {
      throw new Error(`[${this._extension.identifier.value}]: Invalid SCM input box validation function`);
    }
    this._validateInput = fn;
    __privateGet(this, _proxy3).$setValidationProviderIsEnabled(this._sourceControlHandle, !!fn);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    enabled = !!enabled;
    if (this._enabled === enabled) {
      return;
    }
    this._enabled = enabled;
    __privateGet(this, _proxy3).$setInputBoxEnablement(this._sourceControlHandle, enabled);
  }
  get visible() {
    return this._visible;
  }
  set visible(visible) {
    visible = !!visible;
    if (this._visible === visible) {
      return;
    }
    this._visible = visible;
    __privateGet(this, _proxy3).$setInputBoxVisibility(this._sourceControlHandle, visible);
  }
  get document() {
    checkProposedApiEnabled(this._extension, "scmTextDocument");
    return __privateGet(this, _extHostDocuments).getDocument(this._documentUri);
  }
  showValidationMessage(message, type) {
    checkProposedApiEnabled(this._extension, "scmValidation");
    __privateGet(this, _proxy3).$showValidationMessage(this._sourceControlHandle, message, type);
  }
  $onInputBoxValueChange(value) {
    this.updateValue(value);
  }
  updateValue(value) {
    this._value = value;
    this._onDidChange.fire(value);
  }
};
_proxy3 = new WeakMap();
_extHostDocuments = new WeakMap();
var _ExtHostSourceControlResourceGroup = class _ExtHostSourceControlResourceGroup {
  get disposed() {
    return this._disposed;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(label) {
    this._label = label;
    this._proxy.$updateGroupLabel(this._sourceControlHandle, this.handle, label);
  }
  get hideWhenEmpty() {
    return this._hideWhenEmpty;
  }
  set hideWhenEmpty(hideWhenEmpty) {
    this._hideWhenEmpty = hideWhenEmpty;
    this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features);
  }
  get features() {
    return {
      hideWhenEmpty: this.hideWhenEmpty
    };
  }
  get resourceStates() {
    return [...this._resourceStates];
  }
  set resourceStates(resources) {
    this._resourceStates = [...resources];
    this._onDidUpdateResourceStates.fire();
  }
  constructor(_proxy10, _commands2, _sourceControlHandle, _id, _label) {
    this._proxy = _proxy10;
    this._commands = _commands2;
    this._sourceControlHandle = _sourceControlHandle;
    this._id = _id;
    this._label = _label;
    this._resourceHandlePool = 0;
    this._resourceStates = [];
    this._resourceStatesMap = /* @__PURE__ */ new Map();
    this._resourceStatesCommandsMap = /* @__PURE__ */ new Map();
    this._resourceStatesDisposablesMap = /* @__PURE__ */ new Map();
    this._onDidUpdateResourceStates = new Emitter();
    this.onDidUpdateResourceStates = this._onDidUpdateResourceStates.event;
    this._disposed = false;
    this._onDidDispose = new Emitter();
    this.onDidDispose = this._onDidDispose.event;
    this._handlesSnapshot = [];
    this._resourceSnapshot = [];
    this._hideWhenEmpty = void 0;
    this.handle = _ExtHostSourceControlResourceGroup._handlePool++;
  }
  getResourceState(handle) {
    return this._resourceStatesMap.get(handle);
  }
  $executeResourceCommand(handle, preserveFocus) {
    const command = this._resourceStatesCommandsMap.get(handle);
    if (!command) {
      return Promise.resolve(void 0);
    }
    return asPromise(() => this._commands.executeCommand(command.command, ...command.arguments || [], preserveFocus));
  }
  _takeResourceStateSnapshot() {
    var _a30;
    const snapshot = [...this._resourceStates].sort(compareResourceStates);
    const diffs = sortedDiff(this._resourceSnapshot, snapshot, compareResourceStates);
    const splices = diffs.map((diff) => {
      const toInsert = diff.toInsert.map((r) => {
        const handle = this._resourceHandlePool++;
        this._resourceStatesMap.set(handle, r);
        const sourceUri = r.resourceUri;
        let command;
        if (r.command) {
          if (r.command.command === "vscode.open" || r.command.command === "vscode.diff") {
            const disposables = new DisposableStore();
            command = this._commands.converter.toInternal(r.command, disposables);
            this._resourceStatesDisposablesMap.set(handle, disposables);
          } else {
            this._resourceStatesCommandsMap.set(handle, r.command);
          }
        }
        const icon = getIconResource(r.decorations);
        const lightIcon = r.decorations && getIconResource(r.decorations.light) || icon;
        const darkIcon = r.decorations && getIconResource(r.decorations.dark) || icon;
        const icons = [lightIcon, darkIcon];
        const tooltip = r.decorations && r.decorations.tooltip || "";
        const strikeThrough = r.decorations && !!r.decorations.strikeThrough;
        const faded = r.decorations && !!r.decorations.faded;
        const contextValue = r.contextValue || "";
        const rawResource = [handle, sourceUri, icons, tooltip, strikeThrough, faded, contextValue, command];
        return { rawResource, handle };
      });
      return { start: diff.start, deleteCount: diff.deleteCount, toInsert };
    });
    const rawResourceSplices = splices.map(
      ({ start, deleteCount, toInsert }) => [start, deleteCount, toInsert.map((i) => i.rawResource)]
    );
    const reverseSplices = splices.reverse();
    for (const { start, deleteCount, toInsert } of reverseSplices) {
      const handles = toInsert.map((i) => i.handle);
      const handlesToDelete = this._handlesSnapshot.splice(start, deleteCount, ...handles);
      for (const handle of handlesToDelete) {
        this._resourceStatesMap.delete(handle);
        this._resourceStatesCommandsMap.delete(handle);
        (_a30 = this._resourceStatesDisposablesMap.get(handle)) == null ? void 0 : _a30.dispose();
        this._resourceStatesDisposablesMap.delete(handle);
      }
    }
    this._resourceSnapshot = snapshot;
    return rawResourceSplices;
  }
  dispose() {
    this._disposed = true;
    this._onDidDispose.fire();
  }
};
_ExtHostSourceControlResourceGroup._handlePool = 0;
var ExtHostSourceControlResourceGroup = _ExtHostSourceControlResourceGroup;
var _proxy4;
var _ExtHostSourceControl = class _ExtHostSourceControl {
  constructor(_extension2, _extHostDocuments2, proxy, _commands2, _id, _label, _rootUri) {
    __privateAdd(this, _proxy4, void 0);
    this._extension = _extension2;
    this._commands = _commands2;
    this._id = _id;
    this._label = _label;
    this._rootUri = _rootUri;
    this._groups = /* @__PURE__ */ new Map();
    this._count = void 0;
    this._quickDiffProvider = void 0;
    this._commitTemplate = void 0;
    this._acceptInputDisposables = new MutableDisposable();
    this._acceptInputCommand = void 0;
    this._actionButtonDisposables = new MutableDisposable();
    this._statusBarDisposables = new MutableDisposable();
    this._statusBarCommands = void 0;
    this._selected = false;
    this._onDidChangeSelection = new Emitter();
    this.onDidChangeSelection = this._onDidChangeSelection.event;
    this.handle = _ExtHostSourceControl._handlePool++;
    this.createdResourceGroups = /* @__PURE__ */ new Map();
    this.updatedResourceGroups = /* @__PURE__ */ new Set();
    __privateSet(this, _proxy4, proxy);
    const inputBoxDocumentUri = URI.from({
      scheme: Schemas.vscodeSourceControl,
      path: `${_id}/scm${this.handle}/input`,
      query: _rootUri ? `rootUri=${encodeURIComponent(_rootUri.toString())}` : void 0
    });
    this._inputBox = new ExtHostSCMInputBox(
      _extension2,
      _extHostDocuments2,
      __privateGet(this, _proxy4),
      this.handle,
      inputBoxDocumentUri
    );
    __privateGet(this, _proxy4).$registerSourceControl(this.handle, _id, _label, _rootUri, inputBoxDocumentUri);
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  get rootUri() {
    return this._rootUri;
  }
  get inputBox() {
    return this._inputBox;
  }
  get count() {
    return this._count;
  }
  set count(count2) {
    if (this._count === count2) {
      return;
    }
    this._count = count2;
    __privateGet(this, _proxy4).$updateSourceControl(this.handle, { count: count2 });
  }
  get quickDiffProvider() {
    return this._quickDiffProvider;
  }
  set quickDiffProvider(quickDiffProvider) {
    this._quickDiffProvider = quickDiffProvider;
    let quickDiffLabel = void 0;
    if (isProposedApiEnabled(this._extension, "quickDiffProvider")) {
      quickDiffLabel = quickDiffProvider == null ? void 0 : quickDiffProvider.label;
    }
    __privateGet(this, _proxy4).$updateSourceControl(this.handle, { hasQuickDiffProvider: !!quickDiffProvider, quickDiffLabel });
  }
  get commitTemplate() {
    return this._commitTemplate;
  }
  set commitTemplate(commitTemplate) {
    if (commitTemplate === this._commitTemplate) {
      return;
    }
    this._commitTemplate = commitTemplate;
    __privateGet(this, _proxy4).$updateSourceControl(this.handle, { commitTemplate });
  }
  get acceptInputCommand() {
    return this._acceptInputCommand;
  }
  set acceptInputCommand(acceptInputCommand) {
    this._acceptInputDisposables.value = new DisposableStore();
    this._acceptInputCommand = acceptInputCommand;
    const internal = this._commands.converter.toInternal(acceptInputCommand, this._acceptInputDisposables.value);
    __privateGet(this, _proxy4).$updateSourceControl(this.handle, { acceptInputCommand: internal });
  }
  get actionButton() {
    checkProposedApiEnabled(this._extension, "scmActionButton");
    return this._actionButton;
  }
  set actionButton(actionButton) {
    var _a30;
    checkProposedApiEnabled(this._extension, "scmActionButton");
    this._actionButtonDisposables.value = new DisposableStore();
    this._actionButton = actionButton;
    const internal = actionButton !== void 0 ? {
      command: this._commands.converter.toInternal(actionButton.command, this._actionButtonDisposables.value),
      secondaryCommands: (_a30 = actionButton.secondaryCommands) == null ? void 0 : _a30.map((commandGroup) => {
        return commandGroup.map(
          (command) => this._commands.converter.toInternal(command, this._actionButtonDisposables.value)
        );
      }),
      description: actionButton.description,
      enabled: actionButton.enabled
    } : void 0;
    __privateGet(this, _proxy4).$updateSourceControl(this.handle, { actionButton: internal ?? null });
  }
  get statusBarCommands() {
    return this._statusBarCommands;
  }
  set statusBarCommands(statusBarCommands) {
    if (this._statusBarCommands && statusBarCommands && commandListEquals(this._statusBarCommands, statusBarCommands)) {
      return;
    }
    this._statusBarDisposables.value = new DisposableStore();
    this._statusBarCommands = statusBarCommands;
    const internal = (statusBarCommands || []).map(
      (c) => this._commands.converter.toInternal(c, this._statusBarDisposables.value)
    );
    __privateGet(this, _proxy4).$updateSourceControl(this.handle, { statusBarCommands: internal });
  }
  get selected() {
    return this._selected;
  }
  createResourceGroup(id, label) {
    const group = new ExtHostSourceControlResourceGroup(__privateGet(this, _proxy4), this._commands, this.handle, id, label);
    const disposable = Event.once(group.onDidDispose)(() => this.createdResourceGroups.delete(group));
    this.createdResourceGroups.set(group, disposable);
    this.eventuallyAddResourceGroups();
    return group;
  }
  eventuallyAddResourceGroups() {
    const groups = [];
    const splices = [];
    for (const [group, disposable] of this.createdResourceGroups) {
      disposable.dispose();
      const updateListener = group.onDidUpdateResourceStates(() => {
        this.updatedResourceGroups.add(group);
        this.eventuallyUpdateResourceStates();
      });
      Event.once(group.onDidDispose)(() => {
        this.updatedResourceGroups.delete(group);
        updateListener.dispose();
        this._groups.delete(group.handle);
        __privateGet(this, _proxy4).$unregisterGroup(this.handle, group.handle);
      });
      groups.push([group.handle, group.id, group.label, group.features]);
      const snapshot = group._takeResourceStateSnapshot();
      if (snapshot.length > 0) {
        splices.push([group.handle, snapshot]);
      }
      this._groups.set(group.handle, group);
    }
    __privateGet(this, _proxy4).$registerGroups(this.handle, groups, splices);
    this.createdResourceGroups.clear();
  }
  eventuallyUpdateResourceStates() {
    const splices = [];
    this.updatedResourceGroups.forEach((group) => {
      const snapshot = group._takeResourceStateSnapshot();
      if (snapshot.length === 0) {
        return;
      }
      splices.push([group.handle, snapshot]);
    });
    if (splices.length > 0) {
      __privateGet(this, _proxy4).$spliceResourceStates(this.handle, splices);
    }
    this.updatedResourceGroups.clear();
  }
  getResourceGroup(handle) {
    return this._groups.get(handle);
  }
  setSelectionState(selected) {
    this._selected = selected;
    this._onDidChangeSelection.fire(selected);
  }
  dispose() {
    this._acceptInputDisposables.dispose();
    this._actionButtonDisposables.dispose();
    this._statusBarDisposables.dispose();
    this._groups.forEach((group) => group.dispose());
    __privateGet(this, _proxy4).$unregisterSourceControl(this.handle);
  }
};
_proxy4 = new WeakMap();
_ExtHostSourceControl._handlePool = 0;
var ExtHostSourceControl = _ExtHostSourceControl;
ExtHostSourceControl.__decorator = __decorate([
  debounce(100)
], ExtHostSourceControl.prototype, "eventuallyAddResourceGroups", null);
ExtHostSourceControl.__decorator = __decorate([
  debounce(100)
], ExtHostSourceControl.prototype, "eventuallyUpdateResourceStates", null);
var _a4;
var ExtHostSCM = (_a4 = class {
  get onDidChangeActiveProvider() {
    return this._onDidChangeActiveProvider.event;
  }
  constructor(mainContext, _commands2, _extHostDocuments2, logService) {
    this._commands = _commands2;
    this._extHostDocuments = _extHostDocuments2;
    this.logService = logService;
    this._sourceControls = /* @__PURE__ */ new Map();
    this._sourceControlsByExtension = new ExtensionIdentifierMap();
    this._onDidChangeActiveProvider = new Emitter();
    this._proxy = mainContext.getProxy(MainContext.MainThreadSCM);
    this._telemetry = mainContext.getProxy(MainContext.MainThreadTelemetry);
    _commands2.registerArgumentProcessor({
      processArgument: (arg) => {
        if (arg && arg.$mid === 3) {
          const sourceControl = this._sourceControls.get(arg.sourceControlHandle);
          if (!sourceControl) {
            return arg;
          }
          const group = sourceControl.getResourceGroup(arg.groupHandle);
          if (!group) {
            return arg;
          }
          return group.getResourceState(arg.handle);
        } else if (arg && arg.$mid === 4) {
          const sourceControl = this._sourceControls.get(arg.sourceControlHandle);
          if (!sourceControl) {
            return arg;
          }
          return sourceControl.getResourceGroup(arg.groupHandle);
        } else if (arg && arg.$mid === 5) {
          const sourceControl = this._sourceControls.get(arg.handle);
          if (!sourceControl) {
            return arg;
          }
          return sourceControl;
        }
        return arg;
      }
    });
  }
  createSourceControl(extension, id, label, rootUri) {
    this.logService.trace("ExtHostSCM#createSourceControl", extension.identifier.value, id, label, rootUri);
    this._telemetry.$publicLog2("api/scm/createSourceControl", {
      extensionId: extension.identifier.value
    });
    const handle = ExtHostSCM_1._handlePool++;
    const sourceControl = new ExtHostSourceControl(
      extension,
      this._extHostDocuments,
      this._proxy,
      this._commands,
      id,
      label,
      rootUri
    );
    this._sourceControls.set(handle, sourceControl);
    const sourceControls = this._sourceControlsByExtension.get(extension.identifier) || [];
    sourceControls.push(sourceControl);
    this._sourceControlsByExtension.set(extension.identifier, sourceControls);
    return sourceControl;
  }
  getLastInputBox(extension) {
    this.logService.trace("ExtHostSCM#getLastInputBox", extension.identifier.value);
    const sourceControls = this._sourceControlsByExtension.get(extension.identifier);
    const sourceControl = sourceControls && sourceControls[sourceControls.length - 1];
    return sourceControl && sourceControl.inputBox;
  }
  $provideOriginalResource(sourceControlHandle, uriComponents, token) {
    const uri = URI.revive(uriComponents);
    this.logService.trace("ExtHostSCM#$provideOriginalResource", sourceControlHandle, uri.toString());
    const sourceControl = this._sourceControls.get(sourceControlHandle);
    if (!sourceControl || !sourceControl.quickDiffProvider || !sourceControl.quickDiffProvider.provideOriginalResource) {
      return Promise.resolve(null);
    }
    return asPromise(() => sourceControl.quickDiffProvider.provideOriginalResource(uri, token)).then((r) => r || null);
  }
  $onInputBoxValueChange(sourceControlHandle, value) {
    this.logService.trace("ExtHostSCM#$onInputBoxValueChange", sourceControlHandle);
    const sourceControl = this._sourceControls.get(sourceControlHandle);
    if (!sourceControl) {
      return Promise.resolve(void 0);
    }
    sourceControl.inputBox.$onInputBoxValueChange(value);
    return Promise.resolve(void 0);
  }
  $executeResourceCommand(sourceControlHandle, groupHandle, handle, preserveFocus) {
    this.logService.trace("ExtHostSCM#$executeResourceCommand", sourceControlHandle, groupHandle, handle);
    const sourceControl = this._sourceControls.get(sourceControlHandle);
    if (!sourceControl) {
      return Promise.resolve(void 0);
    }
    const group = sourceControl.getResourceGroup(groupHandle);
    if (!group) {
      return Promise.resolve(void 0);
    }
    return group.$executeResourceCommand(handle, preserveFocus);
  }
  $validateInput(sourceControlHandle, value, cursorPosition) {
    this.logService.trace("ExtHostSCM#$validateInput", sourceControlHandle);
    const sourceControl = this._sourceControls.get(sourceControlHandle);
    if (!sourceControl) {
      return Promise.resolve(void 0);
    }
    if (!sourceControl.inputBox.validateInput) {
      return Promise.resolve(void 0);
    }
    return asPromise(() => sourceControl.inputBox.validateInput(value, cursorPosition)).then((result) => {
      if (!result) {
        return Promise.resolve(void 0);
      }
      const message = MarkdownString3.fromStrict(result.message);
      if (!message) {
        return Promise.resolve(void 0);
      }
      return Promise.resolve([message, result.type]);
    });
  }
  $setSelectedSourceControl(selectedSourceControlHandle) {
    var _a30, _b;
    this.logService.trace("ExtHostSCM#$setSelectedSourceControl", selectedSourceControlHandle);
    if (selectedSourceControlHandle !== void 0) {
      (_a30 = this._sourceControls.get(selectedSourceControlHandle)) == null ? void 0 : _a30.setSelectionState(true);
    }
    if (this._selectedSourceControlHandle !== void 0) {
      (_b = this._sourceControls.get(this._selectedSourceControlHandle)) == null ? void 0 : _b.setSelectionState(false);
    }
    this._selectedSourceControlHandle = selectedSourceControlHandle;
    return Promise.resolve(void 0);
  }
}, ExtHostSCM_1 = _a4, _a4._handlePool = 0, _a4);
ExtHostSCM = ExtHostSCM_1 = __decorate([
  __param(3, ILogService)
], ExtHostSCM);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostStatusBar.js
init_extHostTypes();
init_extHost_protocol();
init_nls();
init_lifecycle();
init_types();
var _proxy5, _commands;
var _ExtHostStatusBarEntry = class _ExtHostStatusBarEntry {
  constructor(proxy, commands, staticItems, extension, id, alignment = StatusBarAlignment.Left, priority) {
    __privateAdd(this, _proxy5, void 0);
    __privateAdd(this, _commands, void 0);
    this._disposed = false;
    this._text = "";
    this._staleCommandRegistrations = new DisposableStore();
    __privateSet(this, _proxy5, proxy);
    __privateSet(this, _commands, commands);
    if (id && extension) {
      this._entryId = asStatusBarItemIdentifier(extension.identifier, id);
      const item = staticItems.get(this._entryId);
      if (item) {
        alignment = item.alignLeft ? StatusBarAlignment.Left : StatusBarAlignment.Right;
        priority = item.priority;
        this._visible = true;
        this.name = item.name;
        this.text = item.text;
        this.tooltip = item.tooltip;
        this.command = item.command;
        this.accessibilityInformation = item.accessibilityInformation;
      }
    } else {
      this._entryId = String(_ExtHostStatusBarEntry.ID_GEN++);
    }
    this._extension = extension;
    this._id = id;
    this._alignment = alignment;
    this._priority = this.validatePriority(priority);
  }
  validatePriority(priority) {
    if (!isNumber(priority)) {
      return void 0;
    }
    if (priority === Number.POSITIVE_INFINITY) {
      return Number.MAX_VALUE;
    }
    if (priority === Number.NEGATIVE_INFINITY) {
      return -Number.MAX_VALUE;
    }
    return priority;
  }
  get id() {
    return this._id ?? this._extension.identifier.value;
  }
  get alignment() {
    return this._alignment;
  }
  get priority() {
    return this._priority;
  }
  get text() {
    return this._text;
  }
  get name() {
    return this._name;
  }
  get tooltip() {
    return this._tooltip;
  }
  get color() {
    return this._color;
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  get command() {
    var _a30;
    return (_a30 = this._command) == null ? void 0 : _a30.fromApi;
  }
  get accessibilityInformation() {
    return this._accessibilityInformation;
  }
  set text(text) {
    this._text = text;
    this.update();
  }
  set name(name) {
    this._name = name;
    this.update();
  }
  set tooltip(tooltip) {
    this._tooltip = tooltip;
    this.update();
  }
  set color(color2) {
    this._color = color2;
    this.update();
  }
  set backgroundColor(color2) {
    if (color2 && !_ExtHostStatusBarEntry.ALLOWED_BACKGROUND_COLORS.has(color2.id)) {
      color2 = void 0;
    }
    this._backgroundColor = color2;
    this.update();
  }
  set command(command) {
    var _a30;
    if (((_a30 = this._command) == null ? void 0 : _a30.fromApi) === command) {
      return;
    }
    if (this._latestCommandRegistration) {
      this._staleCommandRegistrations.add(this._latestCommandRegistration);
    }
    this._latestCommandRegistration = new DisposableStore();
    if (typeof command === "string") {
      this._command = {
        fromApi: command,
        internal: __privateGet(this, _commands).toInternal({ title: "", command }, this._latestCommandRegistration)
      };
    } else if (command) {
      this._command = {
        fromApi: command,
        internal: __privateGet(this, _commands).toInternal(command, this._latestCommandRegistration)
      };
    } else {
      this._command = void 0;
    }
    this.update();
  }
  set accessibilityInformation(accessibilityInformation) {
    this._accessibilityInformation = accessibilityInformation;
    this.update();
  }
  show() {
    this._visible = true;
    this.update();
  }
  hide() {
    clearTimeout(this._timeoutHandle);
    this._visible = false;
    __privateGet(this, _proxy5).$disposeEntry(this._entryId);
  }
  update() {
    if (this._disposed || !this._visible) {
      return;
    }
    clearTimeout(this._timeoutHandle);
    this._timeoutHandle = setTimeout(() => {
      var _a30, _b;
      this._timeoutHandle = void 0;
      let id;
      if (this._extension) {
        if (this._id) {
          id = `${this._extension.identifier.value}.${this._id}`;
        } else {
          id = this._extension.identifier.value;
        }
      } else {
        id = this._id;
      }
      let name;
      if (this._name) {
        name = this._name;
      } else {
        name = localize(
          "extensionLabel",
          "{0} (Extension)",
          this._extension.displayName || this._extension.name
        );
      }
      let color2 = this._color;
      if (this._backgroundColor) {
        color2 = _ExtHostStatusBarEntry.ALLOWED_BACKGROUND_COLORS.get(this._backgroundColor.id);
      }
      const tooltip = MarkdownString3.fromStrict(this._tooltip);
      __privateGet(this, _proxy5).$setEntry(this._entryId, id, (_a30 = this._extension) == null ? void 0 : _a30.identifier.value, name, this._text, tooltip, (_b = this._command) == null ? void 0 : _b.internal, color2, this._backgroundColor, this._alignment === StatusBarAlignment.Left, this._priority, this._accessibilityInformation);
      this._staleCommandRegistrations.clear();
    }, 0);
  }
  dispose() {
    this.hide();
    this._disposed = true;
  }
};
_proxy5 = new WeakMap();
_commands = new WeakMap();
_ExtHostStatusBarEntry.ID_GEN = 0;
_ExtHostStatusBarEntry.ALLOWED_BACKGROUND_COLORS = /* @__PURE__ */ new Map([
  ["statusBarItem.errorBackground", new ThemeColor2("statusBarItem.errorForeground")],
  ["statusBarItem.warningBackground", new ThemeColor2("statusBarItem.warningForeground")]
]);
var ExtHostStatusBarEntry = _ExtHostStatusBarEntry;
var StatusBarMessage = class {
  constructor(statusBar) {
    this._messages = [];
    this._item = statusBar.createStatusBarEntry(void 0, "status.extensionMessage", StatusBarAlignment.Left, Number.MIN_VALUE);
    this._item.name = localize("status.extensionMessage", "Extension Status");
  }
  dispose() {
    this._messages.length = 0;
    this._item.dispose();
  }
  setMessage(message) {
    const data = { message };
    this._messages.unshift(data);
    this._update();
    return new Disposable2(() => {
      const idx = this._messages.indexOf(data);
      if (idx >= 0) {
        this._messages.splice(idx, 1);
        this._update();
      }
    });
  }
  _update() {
    if (this._messages.length > 0) {
      this._item.text = this._messages[0].message;
      this._item.show();
    } else {
      this._item.hide();
    }
  }
};
var ExtHostStatusBar = class {
  constructor(mainContext, commands) {
    this._existingItems = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadStatusBar);
    this._commands = commands;
    this._statusMessage = new StatusBarMessage(this);
  }
  $acceptStaticEntries(added) {
    for (const item of added) {
      this._existingItems.set(item.entryId, item);
    }
  }
  createStatusBarEntry(extension, id, alignment, priority) {
    return new ExtHostStatusBarEntry(
      this._proxy,
      this._commands,
      this._existingItems,
      extension,
      id,
      alignment,
      priority
    );
  }
  setStatusBarMessage(text, timeoutOrThenable) {
    const d = this._statusMessage.setMessage(text);
    let handle;
    if (typeof timeoutOrThenable === "number") {
      handle = setTimeout(() => d.dispose(), timeoutOrThenable);
    } else if (typeof timeoutOrThenable !== "undefined") {
      timeoutOrThenable.then(() => d.dispose(), () => d.dispose());
    }
    return new Disposable2(() => {
      d.dispose();
      clearTimeout(handle);
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTextEditors.js
init_arrays();
init_errors();
init_event();
init_extHost_protocol();
init_extHostTypes();
var ExtHostEditors = class {
  constructor(mainContext, _extHostDocumentsAndEditors) {
    this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
    this._onDidChangeTextEditorSelection = new Emitter({ onListenerError: onUnexpectedExternalError });
    this._onDidChangeTextEditorOptions = new Emitter({ onListenerError: onUnexpectedExternalError });
    this._onDidChangeTextEditorVisibleRanges = new Emitter({ onListenerError: onUnexpectedExternalError });
    this._onDidChangeTextEditorViewColumn = new Emitter({ onListenerError: onUnexpectedExternalError });
    this._onDidChangeActiveTextEditor = new Emitter({ onListenerError: onUnexpectedExternalError });
    this._onDidChangeVisibleTextEditors = new Emitter({ onListenerError: onUnexpectedExternalError });
    this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event;
    this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event;
    this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event;
    this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event;
    this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
    this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadTextEditors);
    this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors((e) => this._onDidChangeVisibleTextEditors.fire(e));
    this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor((e) => this._onDidChangeActiveTextEditor.fire(e));
  }
  getActiveTextEditor() {
    return this._extHostDocumentsAndEditors.activeEditor();
  }
  getVisibleTextEditors(internal) {
    const editors = this._extHostDocumentsAndEditors.allEditors();
    return internal ? editors : editors.map((editor) => editor.value);
  }
  async showTextDocument(document2, columnOrOptions, preserveFocus) {
    let options;
    if (typeof columnOrOptions === "number") {
      options = {
        position: ViewColumn2.from(columnOrOptions),
        preserveFocus
      };
    } else if (typeof columnOrOptions === "object") {
      options = {
        position: ViewColumn2.from(columnOrOptions.viewColumn),
        preserveFocus: columnOrOptions.preserveFocus,
        selection: typeof columnOrOptions.selection === "object" ? Range3.from(columnOrOptions.selection) : void 0,
        pinned: typeof columnOrOptions.preview === "boolean" ? !columnOrOptions.preview : void 0
      };
    } else {
      options = {
        preserveFocus: false
      };
    }
    const editorId = await this._proxy.$tryShowTextDocument(document2.uri, options);
    const editor = editorId && this._extHostDocumentsAndEditors.getEditor(editorId);
    if (editor) {
      return editor.value;
    }
    if (editorId) {
      throw new Error(`Could NOT open editor for "${document2.uri.toString()}" because another editor opened in the meantime.`);
    } else {
      throw new Error(`Could NOT open editor for "${document2.uri.toString()}".`);
    }
  }
  createTextEditorDecorationType(extension, options) {
    return new TextEditorDecorationType(this._proxy, extension, options).value;
  }
  $acceptEditorPropertiesChanged(id, data) {
    const textEditor = this._extHostDocumentsAndEditors.getEditor(id);
    if (!textEditor) {
      throw new Error("unknown text editor");
    }
    if (data.options) {
      textEditor._acceptOptions(data.options);
    }
    if (data.selections) {
      const selections = data.selections.selections.map(Selection3.to);
      textEditor._acceptSelections(selections);
    }
    if (data.visibleRanges) {
      const visibleRanges = coalesce(data.visibleRanges.map(Range3.to));
      textEditor._acceptVisibleRanges(visibleRanges);
    }
    if (data.options) {
      this._onDidChangeTextEditorOptions.fire({
        textEditor: textEditor.value,
        options: { ...data.options, lineNumbers: TextEditorLineNumbersStyle2.to(data.options.lineNumbers) }
      });
    }
    if (data.selections) {
      const kind = TextEditorSelectionChangeKind.fromValue(data.selections.source);
      const selections = data.selections.selections.map(Selection3.to);
      this._onDidChangeTextEditorSelection.fire({
        textEditor: textEditor.value,
        selections,
        kind
      });
    }
    if (data.visibleRanges) {
      const visibleRanges = coalesce(data.visibleRanges.map(Range3.to));
      this._onDidChangeTextEditorVisibleRanges.fire({
        textEditor: textEditor.value,
        visibleRanges
      });
    }
  }
  $acceptEditorPositionData(data) {
    for (const id in data) {
      const textEditor = this._extHostDocumentsAndEditors.getEditor(id);
      if (!textEditor) {
        throw new Error("Unknown text editor");
      }
      const viewColumn = ViewColumn2.to(data[id]);
      if (textEditor.value.viewColumn !== viewColumn) {
        textEditor._acceptViewColumn(viewColumn);
        this._onDidChangeTextEditorViewColumn.fire({ textEditor: textEditor.value, viewColumn });
      }
    }
  }
  getDiffInformation(id) {
    return Promise.resolve(this._proxy.$getDiffInformation(id));
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTreeViews.js
init_nls();
init_extHostTypes();
init_resources();
init_uri();
init_event();
init_lifecycle();
init_async();
init_types();
init_arrays();
init_htmlContent();
init_cancellation();
function toTreeItemLabel(label, extension) {
  if (isString(label)) {
    return { label };
  }
  if (label && typeof label === "object" && typeof label.label === "string") {
    let highlights = void 0;
    if (Array.isArray(label.highlights)) {
      highlights = label.highlights.filter((highlight) => highlight.length === 2 && typeof highlight[0] === "number" && typeof highlight[1] === "number");
      highlights = highlights.length ? highlights : void 0;
    }
    return { label: label.label, highlights };
  }
  return void 0;
}
var ExtHostTreeViews = class {
  constructor(_proxy10, commands, logService) {
    this._proxy = _proxy10;
    this.commands = commands;
    this.logService = logService;
    this.treeViews = /* @__PURE__ */ new Map();
    this.treeDragAndDropService = new TreeViewsDnDService();
    function isTreeViewConvertableItem(arg) {
      return arg && arg.$treeViewId && (arg.$treeItemHandle || arg.$selectedTreeItems || arg.$focusedTreeItem);
    }
    commands.registerArgumentProcessor({
      processArgument: (arg) => {
        if (isTreeViewConvertableItem(arg)) {
          return this.convertArgument(arg);
        } else if (Array.isArray(arg) && arg.length > 0) {
          return arg.map((item) => {
            if (isTreeViewConvertableItem(item)) {
              return this.convertArgument(item);
            }
            return item;
          });
        }
        return arg;
      }
    });
  }
  registerTreeDataProvider(id, treeDataProvider, extension) {
    const treeView = this.createTreeView(id, { treeDataProvider }, extension);
    return { dispose: () => treeView.dispose() };
  }
  createTreeView(viewId, options, extension) {
    var _a30, _b, _c, _d;
    if (!options || !options.treeDataProvider) {
      throw new Error("Options with treeDataProvider is mandatory");
    }
    const dropMimeTypes = ((_a30 = options.dragAndDropController) == null ? void 0 : _a30.dropMimeTypes) ?? [];
    const dragMimeTypes = ((_b = options.dragAndDropController) == null ? void 0 : _b.dragMimeTypes) ?? [];
    const hasHandleDrag = !!((_c = options.dragAndDropController) == null ? void 0 : _c.handleDrag);
    const hasHandleDrop = !!((_d = options.dragAndDropController) == null ? void 0 : _d.handleDrop);
    const treeView = this.createExtHostTreeView(viewId, options, extension);
    const proxyOptions = { showCollapseAll: !!options.showCollapseAll, canSelectMany: !!options.canSelectMany, dropMimeTypes, dragMimeTypes, hasHandleDrag, hasHandleDrop, manuallyManageCheckboxes: !!options.manageCheckboxStateManually };
    const registerPromise = this._proxy.$registerTreeViewDataProvider(viewId, proxyOptions);
    const view = {
      get onDidCollapseElement() {
        return treeView.onDidCollapseElement;
      },
      get onDidExpandElement() {
        return treeView.onDidExpandElement;
      },
      get selection() {
        return treeView.selectedElements;
      },
      get onDidChangeSelection() {
        return treeView.onDidChangeSelection;
      },
      get activeItem() {
        checkProposedApiEnabled(extension, "treeViewActiveItem");
        return treeView.focusedElement;
      },
      get onDidChangeActiveItem() {
        checkProposedApiEnabled(extension, "treeViewActiveItem");
        return treeView.onDidChangeActiveItem;
      },
      get visible() {
        return treeView.visible;
      },
      get onDidChangeVisibility() {
        return treeView.onDidChangeVisibility;
      },
      get onDidChangeCheckboxState() {
        return treeView.onDidChangeCheckboxState;
      },
      get message() {
        return treeView.message;
      },
      set message(message) {
        if (isMarkdownString(message)) {
          checkProposedApiEnabled(extension, "treeViewMarkdownMessage");
        }
        treeView.message = message;
      },
      get title() {
        return treeView.title;
      },
      set title(title) {
        treeView.title = title;
      },
      get description() {
        return treeView.description;
      },
      set description(description) {
        treeView.description = description;
      },
      get badge() {
        return treeView.badge;
      },
      set badge(badge) {
        if (badge !== void 0 && ViewBadge.isViewBadge(badge)) {
          treeView.badge = {
            value: Math.floor(Math.abs(badge.value)),
            tooltip: badge.tooltip
          };
        } else if (badge === void 0) {
          treeView.badge = void 0;
        }
      },
      reveal: (element, options2) => {
        return treeView.reveal(element, options2);
      },
      dispose: async () => {
        await registerPromise;
        this.treeViews.delete(viewId);
        treeView.dispose();
      }
    };
    return view;
  }
  $getChildren(treeViewId, treeItemHandle) {
    const treeView = this.treeViews.get(treeViewId);
    if (!treeView) {
      return Promise.reject(new NoTreeViewError(treeViewId));
    }
    return treeView.getChildren(treeItemHandle);
  }
  async $handleDrop(destinationViewId, requestId, treeDataTransferDTO, targetItemHandle, token, operationUuid, sourceViewId, sourceTreeItemHandles) {
    const treeView = this.treeViews.get(destinationViewId);
    if (!treeView) {
      return Promise.reject(new NoTreeViewError(destinationViewId));
    }
    const treeDataTransfer = DataTransfer2.toDataTransfer(treeDataTransferDTO, async (dataItemIndex) => {
      return (await this._proxy.$resolveDropFileData(destinationViewId, requestId, dataItemIndex)).buffer;
    });
    if (sourceViewId === destinationViewId && sourceTreeItemHandles) {
      await this.addAdditionalTransferItems(treeDataTransfer, treeView, sourceTreeItemHandles, token, operationUuid);
    }
    return treeView.onDrop(treeDataTransfer, targetItemHandle, token);
  }
  async addAdditionalTransferItems(treeDataTransfer, treeView, sourceTreeItemHandles, token, operationUuid) {
    var _a30;
    const existingTransferOperation = this.treeDragAndDropService.removeDragOperationTransfer(operationUuid);
    if (existingTransferOperation) {
      (_a30 = await existingTransferOperation) == null ? void 0 : _a30.forEach((value, key) => {
        if (value) {
          treeDataTransfer.set(key, value);
        }
      });
    } else if (operationUuid && treeView.handleDrag) {
      const willDropPromise = treeView.handleDrag(sourceTreeItemHandles, treeDataTransfer, token);
      this.treeDragAndDropService.addDragOperationTransfer(operationUuid, willDropPromise);
      await willDropPromise;
    }
    return treeDataTransfer;
  }
  async $handleDrag(sourceViewId, sourceTreeItemHandles, operationUuid, token) {
    const treeView = this.treeViews.get(sourceViewId);
    if (!treeView) {
      return Promise.reject(new NoTreeViewError(sourceViewId));
    }
    const treeDataTransfer = await this.addAdditionalTransferItems(new DataTransfer(), treeView, sourceTreeItemHandles, token, operationUuid);
    if (!treeDataTransfer || token.isCancellationRequested) {
      return;
    }
    return DataTransfer2.from(treeDataTransfer);
  }
  async $hasResolve(treeViewId) {
    const treeView = this.treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    return treeView.hasResolve;
  }
  $resolve(treeViewId, treeItemHandle, token) {
    const treeView = this.treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    return treeView.resolveTreeItem(treeItemHandle, token);
  }
  $setExpanded(treeViewId, treeItemHandle, expanded) {
    const treeView = this.treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    treeView.setExpanded(treeItemHandle, expanded);
  }
  $setSelectionAndFocus(treeViewId, selectedHandles, focusedHandle) {
    const treeView = this.treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    treeView.setSelectionAndFocus(selectedHandles, focusedHandle);
  }
  $setVisible(treeViewId, isVisible) {
    const treeView = this.treeViews.get(treeViewId);
    if (!treeView) {
      if (!isVisible) {
        return;
      }
      throw new NoTreeViewError(treeViewId);
    }
    treeView.setVisible(isVisible);
  }
  $changeCheckboxState(treeViewId, checkboxUpdate) {
    const treeView = this.treeViews.get(treeViewId);
    if (!treeView) {
      throw new NoTreeViewError(treeViewId);
    }
    treeView.setCheckboxState(checkboxUpdate);
  }
  createExtHostTreeView(id, options, extension) {
    const treeView = new ExtHostTreeView(
      id,
      options,
      this._proxy,
      this.commands.converter,
      this.logService,
      extension
    );
    this.treeViews.set(id, treeView);
    return treeView;
  }
  convertArgument(arg) {
    const treeView = this.treeViews.get(arg.$treeViewId);
    if (treeView && "$treeItemHandle" in arg) {
      return treeView.getExtensionElement(arg.$treeItemHandle);
    }
    if (treeView && "$focusedTreeItem" in arg && arg.$focusedTreeItem) {
      return treeView.focusedElement;
    }
    return null;
  }
};
var _ExtHostTreeView = class _ExtHostTreeView extends Disposable {
  get visible() {
    return this._visible;
  }
  get selectedElements() {
    return this._selectedHandles.map((handle) => this.getExtensionElement(handle)).filter((element) => !isUndefinedOrNull(element));
  }
  get focusedElement() {
    return this._focusedHandle ? this.getExtensionElement(this._focusedHandle) : void 0;
  }
  constructor(viewId, options, proxy, commands, logService, extension) {
    super();
    this.viewId = viewId;
    this.proxy = proxy;
    this.commands = commands;
    this.logService = logService;
    this.extension = extension;
    this.roots = void 0;
    this.elements = /* @__PURE__ */ new Map();
    this.nodes = /* @__PURE__ */ new Map();
    this._visible = false;
    this._selectedHandles = [];
    this._focusedHandle = void 0;
    this._onDidExpandElement = this._register(new Emitter());
    this.onDidExpandElement = this._onDidExpandElement.event;
    this._onDidCollapseElement = this._register(new Emitter());
    this.onDidCollapseElement = this._onDidCollapseElement.event;
    this._onDidChangeSelection = this._register(new Emitter());
    this.onDidChangeSelection = this._onDidChangeSelection.event;
    this._onDidChangeActiveItem = this._register(new Emitter());
    this.onDidChangeActiveItem = this._onDidChangeActiveItem.event;
    this._onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    this._onDidChangeCheckboxState = this._register(new Emitter());
    this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;
    this._onDidChangeData = this._register(new Emitter());
    this.refreshPromise = Promise.resolve();
    this.refreshQueue = Promise.resolve();
    this._message = "";
    this._title = "";
    this._refreshCancellationSource = new CancellationTokenSource();
    if (extension.contributes && extension.contributes.views) {
      for (const location2 in extension.contributes.views) {
        for (const view of extension.contributes.views[location2]) {
          if (view.id === viewId) {
            this._title = view.name;
          }
        }
      }
    }
    this.dataProvider = options.treeDataProvider;
    this.dndController = options.dragAndDropController;
    if (this.dataProvider.onDidChangeTreeData) {
      this._register(this.dataProvider.onDidChangeTreeData((elementOrElements) => this._onDidChangeData.fire({ message: false, element: elementOrElements })));
    }
    let refreshingPromise;
    let promiseCallback;
    this._register(Event.debounce(this._onDidChangeData.event, (result, current) => {
      if (!result) {
        result = { message: false, elements: [] };
      }
      if (current.element !== false) {
        if (!refreshingPromise) {
          refreshingPromise = new Promise((c) => promiseCallback = c);
          this.refreshPromise = this.refreshPromise.then(() => refreshingPromise);
        }
        if (Array.isArray(current.element)) {
          result.elements.push(...current.element);
        } else {
          result.elements.push(current.element);
        }
      }
      if (current.message) {
        result.message = true;
      }
      return result;
    }, 200, true)(({ message, elements }) => {
      if (elements.length) {
        this.refreshQueue = this.refreshQueue.then(() => {
          const _promiseCallback = promiseCallback;
          refreshingPromise = null;
          return this.refresh(elements).then(() => _promiseCallback());
        });
      }
      if (message) {
        this.proxy.$setMessage(this.viewId, MarkdownString3.fromStrict(this._message) ?? "");
      }
    }));
  }
  async getChildren(parentHandle) {
    const parentElement = parentHandle ? this.getExtensionElement(parentHandle) : void 0;
    if (parentHandle && !parentElement) {
      this.logService.error(`No tree item with id '${parentHandle}' found.`);
      return Promise.resolve([]);
    }
    let childrenNodes = this.getChildrenNodes(parentHandle);
    if (!childrenNodes) {
      childrenNodes = await this.fetchChildrenNodes(parentElement);
    }
    return childrenNodes ? childrenNodes.map((n2) => n2.item) : void 0;
  }
  getExtensionElement(treeItemHandle) {
    return this.elements.get(treeItemHandle);
  }
  reveal(element, options) {
    options = options ? options : { select: true, focus: false };
    const select = isUndefinedOrNull(options.select) ? true : options.select;
    const focus = isUndefinedOrNull(options.focus) ? false : options.focus;
    const expand = isUndefinedOrNull(options.expand) ? false : options.expand;
    if (typeof this.dataProvider.getParent !== "function") {
      return Promise.reject(new Error(
        `Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method`
      ));
    }
    if (element) {
      return this.refreshPromise.then(() => this.resolveUnknownParentChain(element)).then((parentChain) => this.resolveTreeNode(element, parentChain[parentChain.length - 1]).then((treeNode) => this.proxy.$reveal(this.viewId, { item: treeNode.item, parentChain: parentChain.map((p) => p.item) }, { select, focus, expand })), (error) => this.logService.error(error));
    } else {
      return this.proxy.$reveal(this.viewId, void 0, { select, focus, expand });
    }
  }
  get message() {
    return this._message;
  }
  set message(message) {
    this._message = message;
    this._onDidChangeData.fire({ message: true, element: false });
  }
  get title() {
    return this._title;
  }
  set title(title) {
    this._title = title;
    this.proxy.$setTitle(this.viewId, title, this._description);
  }
  get description() {
    return this._description;
  }
  set description(description) {
    this._description = description;
    this.proxy.$setTitle(this.viewId, this._title, description);
  }
  get badge() {
    return this._badge;
  }
  set badge(badge) {
    var _a30, _b;
    if (((_a30 = this._badge) == null ? void 0 : _a30.value) === (badge == null ? void 0 : badge.value) && ((_b = this._badge) == null ? void 0 : _b.tooltip) === (badge == null ? void 0 : badge.tooltip)) {
      return;
    }
    this._badge = ViewBadge2.from(badge);
    this.proxy.$setBadge(this.viewId, badge);
  }
  setExpanded(treeItemHandle, expanded) {
    const element = this.getExtensionElement(treeItemHandle);
    if (element) {
      if (expanded) {
        this._onDidExpandElement.fire(Object.freeze({ element }));
      } else {
        this._onDidCollapseElement.fire(Object.freeze({ element }));
      }
    }
  }
  setSelectionAndFocus(selectedHandles, focusedHandle) {
    const changedSelection = !equals(this._selectedHandles, selectedHandles);
    this._selectedHandles = selectedHandles;
    const changedFocus = this._focusedHandle !== focusedHandle;
    this._focusedHandle = focusedHandle;
    if (changedSelection) {
      this._onDidChangeSelection.fire(Object.freeze({ selection: this.selectedElements }));
    }
    if (changedFocus) {
      this._onDidChangeActiveItem.fire(Object.freeze({ activeItem: this.focusedElement }));
    }
  }
  setVisible(visible) {
    if (visible !== this._visible) {
      this._visible = visible;
      this._onDidChangeVisibility.fire(Object.freeze({ visible: this._visible }));
    }
  }
  async setCheckboxState(checkboxUpdates) {
    const items = (await Promise.all(checkboxUpdates.map(async (checkboxUpdate) => {
      const extensionItem = this.getExtensionElement(checkboxUpdate.treeItemHandle);
      if (extensionItem) {
        return {
          extensionItem,
          treeItem: await this.dataProvider.getTreeItem(extensionItem),
          newState: checkboxUpdate.newState ? TreeItemCheckboxState.Checked : TreeItemCheckboxState.Unchecked
        };
      }
      return Promise.resolve(void 0);
    }))).filter((item) => item !== void 0);
    items.forEach((item) => {
      item.treeItem.checkboxState = item.newState ? TreeItemCheckboxState.Checked : TreeItemCheckboxState.Unchecked;
    });
    this._onDidChangeCheckboxState.fire({ items: items.map((item) => [item.extensionItem, item.newState]) });
  }
  async handleDrag(sourceTreeItemHandles, treeDataTransfer, token) {
    var _a30;
    const extensionTreeItems = [];
    for (const sourceHandle of sourceTreeItemHandles) {
      const extensionItem = this.getExtensionElement(sourceHandle);
      if (extensionItem) {
        extensionTreeItems.push(extensionItem);
      }
    }
    if (!((_a30 = this.dndController) == null ? void 0 : _a30.handleDrag) || extensionTreeItems.length === 0) {
      return;
    }
    await this.dndController.handleDrag(extensionTreeItems, treeDataTransfer, token);
    return treeDataTransfer;
  }
  get hasHandleDrag() {
    var _a30;
    return !!((_a30 = this.dndController) == null ? void 0 : _a30.handleDrag);
  }
  async onDrop(treeDataTransfer, targetHandleOrNode, token) {
    var _a30;
    const target = targetHandleOrNode ? this.getExtensionElement(targetHandleOrNode) : void 0;
    if (!target && targetHandleOrNode || !((_a30 = this.dndController) == null ? void 0 : _a30.handleDrop)) {
      return;
    }
    return asPromise(() => {
      var _a31;
      return ((_a31 = this.dndController) == null ? void 0 : _a31.handleDrop) ? this.dndController.handleDrop(target, treeDataTransfer, token) : void 0;
    });
  }
  get hasResolve() {
    return !!this.dataProvider.resolveTreeItem;
  }
  async resolveTreeItem(treeItemHandle, token) {
    if (!this.dataProvider.resolveTreeItem) {
      return;
    }
    const element = this.elements.get(treeItemHandle);
    if (element) {
      const node = this.nodes.get(element);
      if (node) {
        const resolve = await this.dataProvider.resolveTreeItem(node.extensionItem, element, token) ?? node.extensionItem;
        this.validateTreeItem(resolve);
        node.item.tooltip = this.getTooltip(resolve.tooltip);
        node.item.command = this.getCommand(node.disposableStore, resolve.command);
        return node.item;
      }
    }
    return;
  }
  resolveUnknownParentChain(element) {
    return this.resolveParent(element).then((parent) => {
      if (!parent) {
        return Promise.resolve([]);
      }
      return this.resolveUnknownParentChain(parent).then((result) => this.resolveTreeNode(parent, result[result.length - 1]).then((parentNode) => {
        result.push(parentNode);
        return result;
      }));
    });
  }
  resolveParent(element) {
    const node = this.nodes.get(element);
    if (node) {
      return Promise.resolve(node.parent ? this.elements.get(node.parent.item.handle) : void 0);
    }
    return asPromise(() => this.dataProvider.getParent(element));
  }
  resolveTreeNode(element, parent) {
    const node = this.nodes.get(element);
    if (node) {
      return Promise.resolve(node);
    }
    return asPromise(() => this.dataProvider.getTreeItem(element)).then((extTreeItem) => this.createHandle(element, extTreeItem, parent, true)).then((handle) => this.getChildren(parent ? parent.item.handle : void 0).then(() => {
      const cachedElement = this.getExtensionElement(handle);
      if (cachedElement) {
        const node2 = this.nodes.get(cachedElement);
        if (node2) {
          return Promise.resolve(node2);
        }
      }
      throw new Error(`Cannot resolve tree item for element ${handle} from extension ${this.extension.identifier.value}`);
    }));
  }
  getChildrenNodes(parentNodeOrHandle) {
    if (parentNodeOrHandle) {
      let parentNode;
      if (typeof parentNodeOrHandle === "string") {
        const parentElement = this.getExtensionElement(parentNodeOrHandle);
        parentNode = parentElement ? this.nodes.get(parentElement) : void 0;
      } else {
        parentNode = parentNodeOrHandle;
      }
      return parentNode ? parentNode.children || void 0 : void 0;
    }
    return this.roots;
  }
  async fetchChildrenNodes(parentElement) {
    this.clearChildren(parentElement);
    const cts = new CancellationTokenSource(this._refreshCancellationSource.token);
    try {
      const parentNode = parentElement ? this.nodes.get(parentElement) : void 0;
      const elements = await this.dataProvider.getChildren(parentElement);
      if (cts.token.isCancellationRequested) {
        return void 0;
      }
      const items = await Promise.all(coalesce(elements || []).map(async (element) => {
        const item = await this.dataProvider.getTreeItem(element);
        return item && !cts.token.isCancellationRequested ? this.createAndRegisterTreeNode(element, item, parentNode) : null;
      }));
      if (cts.token.isCancellationRequested) {
        return void 0;
      }
      return coalesce(items);
    } finally {
      cts.dispose();
    }
  }
  refresh(elements) {
    const hasRoot = elements.some((element) => !element);
    if (hasRoot) {
      this._refreshCancellationSource.dispose(true);
      this._refreshCancellationSource = new CancellationTokenSource();
      this.clearAll();
      return this.proxy.$refresh(this.viewId);
    } else {
      const handlesToRefresh = this.getHandlesToRefresh(elements);
      if (handlesToRefresh.length) {
        return this.refreshHandles(handlesToRefresh);
      }
    }
    return Promise.resolve(void 0);
  }
  getHandlesToRefresh(elements) {
    const elementsToUpdate = /* @__PURE__ */ new Set();
    const elementNodes = elements.map((element) => this.nodes.get(element));
    for (const elementNode of elementNodes) {
      if (elementNode && !elementsToUpdate.has(elementNode.item.handle)) {
        let currentNode = elementNode;
        while (currentNode && currentNode.parent && elementNodes.findIndex((node) => currentNode && currentNode.parent && node && node.item.handle === currentNode.parent.item.handle) === -1) {
          const parentElement = this.elements.get(currentNode.parent.item.handle);
          currentNode = parentElement ? this.nodes.get(parentElement) : void 0;
        }
        if (currentNode && !currentNode.parent) {
          elementsToUpdate.add(elementNode.item.handle);
        }
      }
    }
    const handlesToUpdate = [];
    elementsToUpdate.forEach((handle) => {
      const element = this.elements.get(handle);
      if (element) {
        const node = this.nodes.get(element);
        if (node && (!node.parent || !elementsToUpdate.has(node.parent.item.handle))) {
          handlesToUpdate.push(handle);
        }
      }
    });
    return handlesToUpdate;
  }
  refreshHandles(itemHandles) {
    const itemsToRefresh = {};
    return Promise.all(itemHandles.map((treeItemHandle) => this.refreshNode(treeItemHandle).then((node) => {
      if (node) {
        itemsToRefresh[treeItemHandle] = node.item;
      }
    }))).then(() => Object.keys(itemsToRefresh).length ? this.proxy.$refresh(this.viewId, itemsToRefresh) : void 0);
  }
  refreshNode(treeItemHandle) {
    const extElement = this.getExtensionElement(treeItemHandle);
    if (extElement) {
      const existing = this.nodes.get(extElement);
      if (existing) {
        this.clearChildren(extElement);
        return asPromise(() => this.dataProvider.getTreeItem(extElement)).then((extTreeItem) => {
          if (extTreeItem) {
            const newNode = this.createTreeNode(extElement, extTreeItem, existing.parent);
            this.updateNodeCache(extElement, newNode, existing, existing.parent);
            existing.dispose();
            return newNode;
          }
          return null;
        });
      }
    }
    return Promise.resolve(null);
  }
  createAndRegisterTreeNode(element, extTreeItem, parentNode) {
    const node = this.createTreeNode(element, extTreeItem, parentNode);
    if (extTreeItem.id && this.elements.has(node.item.handle)) {
      throw new Error(localize("treeView.duplicateElement", "Element with id {0} is already registered", extTreeItem.id));
    }
    this.addNodeToCache(element, node);
    this.addNodeToParentCache(node, parentNode);
    return node;
  }
  getTooltip(tooltip) {
    if (MarkdownString2.isMarkdownString(tooltip)) {
      return MarkdownString3.from(tooltip);
    }
    return tooltip;
  }
  getCommand(disposable, command) {
    return command ? { ...this.commands.toInternal(command, disposable), originalId: command.command } : void 0;
  }
  getCheckbox(extensionTreeItem) {
    if (extensionTreeItem.checkboxState === void 0) {
      return void 0;
    }
    let checkboxState;
    let tooltip = void 0;
    let accessibilityInformation = void 0;
    if (typeof extensionTreeItem.checkboxState === "number") {
      checkboxState = extensionTreeItem.checkboxState;
    } else {
      checkboxState = extensionTreeItem.checkboxState.state;
      tooltip = extensionTreeItem.checkboxState.tooltip;
      accessibilityInformation = extensionTreeItem.checkboxState.accessibilityInformation;
    }
    return { isChecked: checkboxState === TreeItemCheckboxState.Checked, tooltip, accessibilityInformation };
  }
  validateTreeItem(extensionTreeItem) {
    if (!TreeItem.isTreeItem(extensionTreeItem, this.extension)) {
      throw new Error(`Extension ${this.extension.identifier.value} has provided an invalid tree item.`);
    }
  }
  createTreeNode(element, extensionTreeItem, parent) {
    this.validateTreeItem(extensionTreeItem);
    const disposableStore = new DisposableStore();
    const handle = this.createHandle(element, extensionTreeItem, parent);
    const icon = this.getLightIconPath(extensionTreeItem);
    const item = {
      handle,
      parentHandle: parent ? parent.item.handle : void 0,
      label: toTreeItemLabel(extensionTreeItem.label),
      description: extensionTreeItem.description,
      resourceUri: extensionTreeItem.resourceUri,
      tooltip: this.getTooltip(extensionTreeItem.tooltip),
      command: this.getCommand(disposableStore, extensionTreeItem.command),
      contextValue: extensionTreeItem.contextValue,
      icon,
      iconDark: this.getDarkIconPath(extensionTreeItem) || icon,
      themeIcon: this.getThemeIcon(extensionTreeItem),
      collapsibleState: isUndefinedOrNull(extensionTreeItem.collapsibleState) ? TreeItemCollapsibleState.None : extensionTreeItem.collapsibleState,
      accessibilityInformation: extensionTreeItem.accessibilityInformation,
      checkbox: this.getCheckbox(extensionTreeItem)
    };
    return {
      item,
      extensionItem: extensionTreeItem,
      parent,
      children: void 0,
      disposableStore,
      dispose() {
        disposableStore.dispose();
      }
    };
  }
  getThemeIcon(extensionTreeItem) {
    return extensionTreeItem.iconPath instanceof ThemeIcon2 ? extensionTreeItem.iconPath : void 0;
  }
  createHandle(element, { id, label, resourceUri }, parent, returnFirst) {
    if (id) {
      return `${_ExtHostTreeView.ID_HANDLE_PREFIX}/${id}`;
    }
    const treeItemLabel = toTreeItemLabel(label);
    const prefix = parent ? parent.item.handle : _ExtHostTreeView.LABEL_HANDLE_PREFIX;
    let elementId = treeItemLabel ? treeItemLabel.label : resourceUri ? basename2(resourceUri) : "";
    elementId = elementId.indexOf("/") !== -1 ? elementId.replace("/", "//") : elementId;
    const existingHandle = this.nodes.has(element) ? this.nodes.get(element).item.handle : void 0;
    const childrenNodes = this.getChildrenNodes(parent) || [];
    let handle;
    let counter = 0;
    do {
      handle = `${prefix}/${counter}:${elementId}`;
      if (returnFirst || !this.elements.has(handle) || existingHandle === handle) {
        break;
      }
      counter++;
    } while (counter <= childrenNodes.length);
    return handle;
  }
  getLightIconPath(extensionTreeItem) {
    if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof ThemeIcon2)) {
      if (typeof extensionTreeItem.iconPath === "string" || URI.isUri(extensionTreeItem.iconPath)) {
        return this.getIconPath(extensionTreeItem.iconPath);
      }
      return this.getIconPath(extensionTreeItem.iconPath.light);
    }
    return void 0;
  }
  getDarkIconPath(extensionTreeItem) {
    if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof ThemeIcon2) && extensionTreeItem.iconPath.dark) {
      return this.getIconPath(extensionTreeItem.iconPath.dark);
    }
    return void 0;
  }
  getIconPath(iconPath) {
    if (URI.isUri(iconPath)) {
      return iconPath;
    }
    return URI.file(iconPath);
  }
  addNodeToCache(element, node) {
    this.elements.set(node.item.handle, element);
    this.nodes.set(element, node);
  }
  updateNodeCache(element, newNode, existing, parentNode) {
    this.elements.delete(newNode.item.handle);
    this.nodes.delete(element);
    if (newNode.item.handle !== existing.item.handle) {
      this.elements.delete(existing.item.handle);
    }
    this.addNodeToCache(element, newNode);
    const childrenNodes = this.getChildrenNodes(parentNode) || [];
    const childNode = childrenNodes.filter((c) => c.item.handle === existing.item.handle)[0];
    if (childNode) {
      childrenNodes.splice(childrenNodes.indexOf(childNode), 1, newNode);
    }
  }
  addNodeToParentCache(node, parentNode) {
    if (parentNode) {
      if (!parentNode.children) {
        parentNode.children = [];
      }
      parentNode.children.push(node);
    } else {
      if (!this.roots) {
        this.roots = [];
      }
      this.roots.push(node);
    }
  }
  clearChildren(parentElement) {
    if (parentElement) {
      const node = this.nodes.get(parentElement);
      if (node) {
        if (node.children) {
          for (const child of node.children) {
            const childElement = this.elements.get(child.item.handle);
            if (childElement) {
              this.clear(childElement);
            }
          }
        }
        node.children = void 0;
      }
    } else {
      this.clearAll();
    }
  }
  clear(element) {
    const node = this.nodes.get(element);
    if (node) {
      if (node.children) {
        for (const child of node.children) {
          const childElement = this.elements.get(child.item.handle);
          if (childElement) {
            this.clear(childElement);
          }
        }
      }
      this.nodes.delete(element);
      this.elements.delete(node.item.handle);
      node.dispose();
    }
  }
  clearAll() {
    this.roots = void 0;
    this.elements.clear();
    this.nodes.forEach((node) => node.dispose());
    this.nodes.clear();
  }
  dispose() {
    this._refreshCancellationSource.dispose();
    this.clearAll();
    this.proxy.$disposeTree(this.viewId);
  }
};
_ExtHostTreeView.LABEL_HANDLE_PREFIX = "0";
_ExtHostTreeView.ID_HANDLE_PREFIX = "1";
var ExtHostTreeView = _ExtHostTreeView;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js
init_extHostTypes();
init_telemetryUtils();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostUrls.js
init_extHost_protocol();
init_uri();
init_lifecycle();
init_errors();
init_extensions();
var _ExtHostUrls = class _ExtHostUrls {
  constructor(mainContext) {
    this.handles = new ExtensionIdentifierSet();
    this.handlers = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadUrls);
  }
  registerUriHandler(extension, handler) {
    const extensionId = extension.identifier;
    if (this.handles.has(extensionId)) {
      throw new Error(`Protocol handler already registered for extension ${extensionId}`);
    }
    const handle = _ExtHostUrls.HandlePool++;
    this.handles.add(extensionId);
    this.handlers.set(handle, handler);
    this._proxy.$registerUriHandler(handle, extensionId, extension.displayName || extension.name);
    return toDisposable(() => {
      this.handles.delete(extensionId);
      this.handlers.delete(handle);
      this._proxy.$unregisterUriHandler(handle);
    });
  }
  $handleExternalUri(handle, uri) {
    const handler = this.handlers.get(handle);
    if (!handler) {
      return Promise.resolve(void 0);
    }
    try {
      handler.handleUri(URI.revive(uri));
    } catch (err) {
      onUnexpectedError(err);
    }
    return Promise.resolve(void 0);
  }
  async createAppUri(uri) {
    return URI.revive(await this._proxy.$createAppUri(uri));
  }
};
_ExtHostUrls.HandlePool = 0;
var ExtHostUrls = _ExtHostUrls;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWebview.js
init_event();
init_network();
init_objects();
init_uri();

// node_modules/vscode/vscode/src/vs/platform/extensions/common/extensionValidator.js
var VERSION_REGEXP = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/;
var NOT_BEFORE_REGEXP = /^-(\d{4})(\d{2})(\d{2})$/;
function isValidVersionStr(version) {
  version = version.trim();
  return version === "*" || VERSION_REGEXP.test(version);
}
function parseVersion(version) {
  if (!isValidVersionStr(version)) {
    return null;
  }
  version = version.trim();
  if (version === "*") {
    return {
      hasCaret: false,
      hasGreaterEquals: false,
      majorBase: 0,
      majorMustEqual: false,
      minorBase: 0,
      minorMustEqual: false,
      patchBase: 0,
      patchMustEqual: false,
      preRelease: null
    };
  }
  const m = version.match(VERSION_REGEXP);
  if (!m) {
    return null;
  }
  return {
    hasCaret: m[1] === "^",
    hasGreaterEquals: m[1] === ">=",
    majorBase: m[2] === "x" ? 0 : parseInt(m[2], 10),
    majorMustEqual: m[2] === "x" ? false : true,
    minorBase: m[4] === "x" ? 0 : parseInt(m[4], 10),
    minorMustEqual: m[4] === "x" ? false : true,
    patchBase: m[6] === "x" ? 0 : parseInt(m[6], 10),
    patchMustEqual: m[6] === "x" ? false : true,
    preRelease: m[8] || null
  };
}
function normalizeVersion(version) {
  if (!version) {
    return null;
  }
  const majorBase = version.majorBase;
  const majorMustEqual = version.majorMustEqual;
  const minorBase = version.minorBase;
  let minorMustEqual = version.minorMustEqual;
  const patchBase = version.patchBase;
  let patchMustEqual = version.patchMustEqual;
  if (version.hasCaret) {
    if (majorBase === 0) {
      patchMustEqual = false;
    } else {
      minorMustEqual = false;
      patchMustEqual = false;
    }
  }
  let notBefore = 0;
  if (version.preRelease) {
    const match = NOT_BEFORE_REGEXP.exec(version.preRelease);
    if (match) {
      const [, year, month, day] = match;
      notBefore = Date.UTC(Number(year), Number(month) - 1, Number(day));
    }
  }
  return {
    majorBase,
    majorMustEqual,
    minorBase,
    minorMustEqual,
    patchBase,
    patchMustEqual,
    isMinimum: version.hasGreaterEquals,
    notBefore
  };
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWebviewMessaging.js
init_buffer();
var ArrayBufferSet = class {
  constructor() {
    this.buffers = [];
  }
  add(buffer) {
    let index = this.buffers.indexOf(buffer);
    if (index < 0) {
      index = this.buffers.length;
      this.buffers.push(buffer);
    }
    return index;
  }
};
function serializeWebviewMessage(message, options) {
  if (options.serializeBuffersForPostMessage) {
    const arrayBuffers = new ArrayBufferSet();
    const replacer = (_key, value) => {
      if (value instanceof ArrayBuffer) {
        const index = arrayBuffers.add(value);
        return {
          $$vscode_array_buffer_reference$$: true,
          index
        };
      } else if (ArrayBuffer.isView(value)) {
        const type = getTypedArrayType(value);
        if (type) {
          const index = arrayBuffers.add(value.buffer);
          return {
            $$vscode_array_buffer_reference$$: true,
            index,
            view: {
              type,
              byteLength: value.byteLength,
              byteOffset: value.byteOffset
            }
          };
        }
      }
      return value;
    };
    const serializedMessage = JSON.stringify(message, replacer);
    const buffers = arrayBuffers.buffers.map((arrayBuffer) => {
      const bytes = new Uint8Array(arrayBuffer);
      return VSBuffer.wrap(bytes);
    });
    return { message: serializedMessage, buffers };
  } else {
    return { message: JSON.stringify(message), buffers: [] };
  }
}
function getTypedArrayType(value) {
  switch (value.constructor.name) {
    case "Int8Array":
      return 1;
    case "Uint8Array":
      return 2;
    case "Uint8ClampedArray":
      return 3;
    case "Int16Array":
      return 4;
    case "Uint16Array":
      return 5;
    case "Int32Array":
      return 6;
    case "Uint32Array":
      return 7;
    case "Float32Array":
      return 8;
    case "Float64Array":
      return 9;
    case "BigInt64Array":
      return 10;
    case "BigUint64Array":
      return 11;
  }
  return void 0;
}
function deserializeWebviewMessage(jsonMessage, buffers) {
  const arrayBuffers = buffers.map((buffer) => {
    const arrayBuffer = new ArrayBuffer(buffer.byteLength);
    const uint8Array = new Uint8Array(arrayBuffer);
    uint8Array.set(buffer.buffer);
    return arrayBuffer;
  });
  const reviver = !buffers.length ? void 0 : (_key, value) => {
    if (value && typeof value === "object" && value.$$vscode_array_buffer_reference$$) {
      const ref = value;
      const { index } = ref;
      const arrayBuffer = arrayBuffers[index];
      if (ref.view) {
        switch (ref.view.type) {
          case 1:
            return new Int8Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / Int8Array.BYTES_PER_ELEMENT
            );
          case 2:
            return new Uint8Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / Uint8Array.BYTES_PER_ELEMENT
            );
          case 3:
            return new Uint8ClampedArray(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT
            );
          case 4:
            return new Int16Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / Int16Array.BYTES_PER_ELEMENT
            );
          case 5:
            return new Uint16Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / Uint16Array.BYTES_PER_ELEMENT
            );
          case 6:
            return new Int32Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / Int32Array.BYTES_PER_ELEMENT
            );
          case 7:
            return new Uint32Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / Uint32Array.BYTES_PER_ELEMENT
            );
          case 8:
            return new Float32Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / Float32Array.BYTES_PER_ELEMENT
            );
          case 9:
            return new Float64Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / Float64Array.BYTES_PER_ELEMENT
            );
          case 10:
            return new BigInt64Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT
            );
          case 11:
            return new BigUint64Array(
              arrayBuffer,
              ref.view.byteOffset,
              ref.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT
            );
          default:
            throw new Error("Unknown array buffer view type");
        }
      }
      return arrayBuffer;
    }
    return value;
  };
  const message = JSON.parse(jsonMessage, reviver);
  return { message, arrayBuffers };
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/webview/common/webview.js
init_network();
init_uri();
var webviewResourceBaseHost = "vscode-cdn.net";
var webviewRootResourceAuthority = `vscode-resource.${webviewResourceBaseHost}`;
var webviewGenericCspSource = `'self' https://*.${webviewResourceBaseHost}`;
function asWebviewUri(resource, remoteInfo) {
  if (resource.scheme === Schemas.http || resource.scheme === Schemas.https) {
    return resource;
  }
  if (remoteInfo && remoteInfo.authority && remoteInfo.isRemote && resource.scheme === Schemas.file) {
    resource = URI.from({
      scheme: Schemas.vscodeRemote,
      authority: remoteInfo.authority,
      path: resource.path
    });
  }
  return URI.from({
    scheme: Schemas.https,
    authority: `${resource.scheme}+${encodeAuthority(resource.authority)}.${webviewRootResourceAuthority}`,
    path: resource.path,
    fragment: resource.fragment,
    query: resource.query
  });
}
function encodeAuthority(authority) {
  return authority.replace(/./g, (char) => {
    const code = char.charCodeAt(0);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57) {
      return char;
    }
    return "-" + code.toString(16).padStart(4, "0");
  });
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWebview.js
init_extHost_protocol();
var _handle, _proxy6, _deprecationService, _remoteInfo, _workspace, _extension, _html, _options, _isDisposed, _hasCalledAsWebviewUri, _serializeBuffersForPostMessage, _shouldRewriteOldResourceUris, _onDidDisposeEmitter;
var ExtHostWebview = class {
  constructor(handle, proxy, options, remoteInfo, workspace, extension, deprecationService) {
    __privateAdd(this, _handle, void 0);
    __privateAdd(this, _proxy6, void 0);
    __privateAdd(this, _deprecationService, void 0);
    __privateAdd(this, _remoteInfo, void 0);
    __privateAdd(this, _workspace, void 0);
    __privateAdd(this, _extension, void 0);
    __privateAdd(this, _html, void 0);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _isDisposed, void 0);
    __privateAdd(this, _hasCalledAsWebviewUri, void 0);
    __privateAdd(this, _serializeBuffersForPostMessage, void 0);
    __privateAdd(this, _shouldRewriteOldResourceUris, void 0);
    __privateAdd(this, _onDidDisposeEmitter, void 0);
    __privateSet(this, _html, "");
    __privateSet(this, _isDisposed, false);
    __privateSet(this, _hasCalledAsWebviewUri, false);
    this._onMessageEmitter = new Emitter();
    this.onDidReceiveMessage = this._onMessageEmitter.event;
    __privateSet(this, _onDidDisposeEmitter, new Emitter());
    this._onDidDispose = __privateGet(this, _onDidDisposeEmitter).event;
    __privateSet(this, _handle, handle);
    __privateSet(this, _proxy6, proxy);
    __privateSet(this, _options, options);
    __privateSet(this, _remoteInfo, remoteInfo);
    __privateSet(this, _workspace, workspace);
    __privateSet(this, _extension, extension);
    __privateSet(this, _serializeBuffersForPostMessage, shouldSerializeBuffersForPostMessage(extension));
    __privateSet(this, _shouldRewriteOldResourceUris, shouldTryRewritingOldResourceUris(extension));
    __privateSet(this, _deprecationService, deprecationService);
  }
  dispose() {
    __privateSet(this, _isDisposed, true);
    __privateGet(this, _onDidDisposeEmitter).fire();
    __privateGet(this, _onDidDisposeEmitter).dispose();
    this._onMessageEmitter.dispose();
  }
  asWebviewUri(resource) {
    __privateSet(this, _hasCalledAsWebviewUri, true);
    return asWebviewUri(resource, __privateGet(this, _remoteInfo));
  }
  get cspSource() {
    const extensionLocation = __privateGet(this, _extension).extensionLocation;
    if (extensionLocation.scheme === Schemas.https || extensionLocation.scheme === Schemas.http) {
      let extensionCspRule = extensionLocation.toString();
      if (!extensionCspRule.endsWith("/")) {
        extensionCspRule += "/";
      }
      return extensionCspRule + " " + webviewGenericCspSource;
    }
    return webviewGenericCspSource;
  }
  get html() {
    this.assertNotDisposed();
    return __privateGet(this, _html);
  }
  set html(value) {
    this.assertNotDisposed();
    if (__privateGet(this, _html) !== value) {
      __privateSet(this, _html, value);
      if (__privateGet(this, _shouldRewriteOldResourceUris) && !__privateGet(this, _hasCalledAsWebviewUri) && /(["'])vscode-resource:([^\s'"]+?)(["'])/i.test(value)) {
        __privateSet(this, _hasCalledAsWebviewUri, true);
        __privateGet(this, _deprecationService).report("Webview vscode-resource: uris", __privateGet(this, _extension), `Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri`);
      }
      __privateGet(this, _proxy6).$setHtml(__privateGet(this, _handle), this.rewriteOldResourceUrlsIfNeeded(value));
    }
  }
  get options() {
    this.assertNotDisposed();
    return __privateGet(this, _options);
  }
  set options(newOptions) {
    this.assertNotDisposed();
    if (!equals2(__privateGet(this, _options), newOptions)) {
      __privateGet(this, _proxy6).$setOptions(__privateGet(this, _handle), serializeWebviewOptions(__privateGet(this, _extension), __privateGet(this, _workspace), newOptions));
    }
    __privateSet(this, _options, newOptions);
  }
  async postMessage(message) {
    if (__privateGet(this, _isDisposed)) {
      return false;
    }
    const serialized = serializeWebviewMessage(message, { serializeBuffersForPostMessage: __privateGet(this, _serializeBuffersForPostMessage) });
    return __privateGet(this, _proxy6).$postMessage(__privateGet(this, _handle), serialized.message, ...serialized.buffers);
  }
  assertNotDisposed() {
    if (__privateGet(this, _isDisposed)) {
      throw new Error("Webview is disposed");
    }
  }
  rewriteOldResourceUrlsIfNeeded(value) {
    var _a30;
    if (!__privateGet(this, _shouldRewriteOldResourceUris)) {
      return value;
    }
    const isRemote = ((_a30 = __privateGet(this, _extension).extensionLocation) == null ? void 0 : _a30.scheme) === Schemas.vscodeRemote;
    const remoteAuthority = __privateGet(this, _extension).extensionLocation.scheme === Schemas.vscodeRemote ? __privateGet(this, _extension).extensionLocation.authority : void 0;
    return value.replace(/(["'])(?:vscode-resource):(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (_match, startQuote, _1, scheme, path, endQuote) => {
      const uri = URI.from({
        scheme: scheme || "file",
        path: decodeURIComponent(path)
      });
      const webviewUri = asWebviewUri(uri, { isRemote, authority: remoteAuthority }).toString();
      return `${startQuote}${webviewUri}${endQuote}`;
    }).replace(/(["'])(?:vscode-webview-resource):(\/\/[^\s\/'"]+\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (_match, startQuote, _1, scheme, path, endQuote) => {
      const uri = URI.from({
        scheme: scheme || "file",
        path: decodeURIComponent(path)
      });
      const webviewUri = asWebviewUri(uri, { isRemote, authority: remoteAuthority }).toString();
      return `${startQuote}${webviewUri}${endQuote}`;
    });
  }
};
_handle = new WeakMap();
_proxy6 = new WeakMap();
_deprecationService = new WeakMap();
_remoteInfo = new WeakMap();
_workspace = new WeakMap();
_extension = new WeakMap();
_html = new WeakMap();
_options = new WeakMap();
_isDisposed = new WeakMap();
_hasCalledAsWebviewUri = new WeakMap();
_serializeBuffersForPostMessage = new WeakMap();
_shouldRewriteOldResourceUris = new WeakMap();
_onDidDisposeEmitter = new WeakMap();
function shouldSerializeBuffersForPostMessage(extension) {
  try {
    const version = normalizeVersion(parseVersion(extension.engines.vscode));
    return !!version && version.majorBase >= 1 && version.minorBase >= 57;
  } catch {
    return false;
  }
}
function shouldTryRewritingOldResourceUris(extension) {
  try {
    const version = normalizeVersion(parseVersion(extension.engines.vscode));
    if (!version) {
      return false;
    }
    return version.majorBase < 1 || version.majorBase === 1 && version.minorBase < 60;
  } catch {
    return false;
  }
}
var ExtHostWebviews = class {
  constructor(mainContext, remoteInfo, workspace, _logService, _deprecationService2) {
    this.remoteInfo = remoteInfo;
    this.workspace = workspace;
    this._logService = _logService;
    this._deprecationService = _deprecationService2;
    this._webviews = /* @__PURE__ */ new Map();
    this._webviewProxy = mainContext.getProxy(MainContext.MainThreadWebviews);
  }
  $onMessage(handle, jsonMessage, buffers) {
    const webview = this.getWebview(handle);
    if (webview) {
      const { message } = deserializeWebviewMessage(jsonMessage, buffers.value);
      webview._onMessageEmitter.fire(message);
    }
  }
  $onMissingCsp(_handle4, extensionId) {
    this._logService.warn(`${extensionId} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`);
  }
  createNewWebview(handle, options, extension) {
    const webview = new ExtHostWebview(
      handle,
      this._webviewProxy,
      reviveOptions(options),
      this.remoteInfo,
      this.workspace,
      extension,
      this._deprecationService
    );
    this._webviews.set(handle, webview);
    webview._onDidDispose(() => {
      this._webviews.delete(handle);
    });
    return webview;
  }
  deleteWebview(handle) {
    this._webviews.delete(handle);
  }
  getWebview(handle) {
    return this._webviews.get(handle);
  }
};
function toExtensionData(extension) {
  return { id: extension.identifier, location: extension.extensionLocation };
}
function serializeWebviewOptions(extension, workspace, options) {
  return {
    enableCommandUris: options.enableCommandUris,
    enableScripts: options.enableScripts,
    enableForms: options.enableForms,
    portMapping: options.portMapping,
    localResourceRoots: options.localResourceRoots || getDefaultLocalResourceRoots(extension, workspace)
  };
}
function reviveOptions(options) {
  var _a30;
  return {
    enableCommandUris: options.enableCommandUris,
    enableScripts: options.enableScripts,
    enableForms: options.enableForms,
    portMapping: options.portMapping,
    localResourceRoots: (_a30 = options.localResourceRoots) == null ? void 0 : _a30.map((components) => URI.from(components))
  };
}
function getDefaultLocalResourceRoots(extension, workspace) {
  return [
    ...((workspace == null ? void 0 : workspace.getWorkspaceFolders()) || []).map((x) => x.uri),
    extension.extensionLocation
  ];
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWindow.js
init_tslib_es6();
init_event();
init_extHost_protocol();
init_uri();
init_network();
init_strings();
init_instantiation();
var ExtHostWindow_1;
var _a5;
var ExtHostWindow = (_a5 = class {
  getState(extension) {
    const state = this._state;
    return {
      get focused() {
        return state.focused;
      },
      get active() {
        checkProposedApiEnabled(extension, "windowActivity");
        return state.active;
      }
    };
  }
  constructor(extHostRpc) {
    this._onDidChangeWindowState = new Emitter();
    this.onDidChangeWindowState = this._onDidChangeWindowState.event;
    this._state = ExtHostWindow_1.InitialState;
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadWindow);
    this._proxy.$getInitialState().then(({ isFocused, isActive }) => {
      this.onDidChangeWindowProperty("focused", isFocused);
      this.onDidChangeWindowProperty("active", isActive);
    });
  }
  $onDidChangeWindowFocus(value) {
    this.onDidChangeWindowProperty("focused", value);
  }
  $onDidChangeWindowActive(value) {
    this.onDidChangeWindowProperty("active", value);
  }
  onDidChangeWindowProperty(property, value) {
    if (value === this._state[property]) {
      return;
    }
    this._state = { ...this._state, [property]: value };
    this._onDidChangeWindowState.fire(this._state);
  }
  openUri(stringOrUri, options) {
    let uriAsString;
    if (typeof stringOrUri === "string") {
      uriAsString = stringOrUri;
      try {
        stringOrUri = URI.parse(stringOrUri);
      } catch (e) {
        return Promise.reject(`Invalid uri - '${stringOrUri}'`);
      }
    }
    if (isFalsyOrWhitespace(stringOrUri.scheme)) {
      return Promise.reject("Invalid scheme - cannot be empty");
    } else if (stringOrUri.scheme === Schemas.command) {
      return Promise.reject(`Invalid scheme '${stringOrUri.scheme}'`);
    }
    return this._proxy.$openUri(stringOrUri, uriAsString, options);
  }
  async asExternalUri(uri, options) {
    if (isFalsyOrWhitespace(uri.scheme)) {
      return Promise.reject("Invalid scheme - cannot be empty");
    }
    const result = await this._proxy.$asExternalUri(uri, options);
    return URI.from(result);
  }
}, ExtHostWindow_1 = _a5, _a5.InitialState = {
  focused: true,
  active: true
}, _a5);
ExtHostWindow = ExtHostWindow_1 = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostWindow);
var IExtHostWindow = createDecorator("IExtHostWindow");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js
init_extensions();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostCodeInsets.js
init_event();
init_lifecycle();
var ExtHostEditorInsets = class {
  constructor(_proxy10, _editors, _remoteInfo2) {
    this._proxy = _proxy10;
    this._editors = _editors;
    this._remoteInfo = _remoteInfo2;
    this._handlePool = 0;
    this._disposables = new DisposableStore();
    this._insets = /* @__PURE__ */ new Map();
    this._disposables.add(_editors.onDidChangeVisibleTextEditors(() => {
      const visibleEditor = _editors.getVisibleTextEditors();
      for (const value of this._insets.values()) {
        if (visibleEditor.indexOf(value.editor) < 0) {
          value.inset.dispose();
        }
      }
    }));
  }
  dispose() {
    this._insets.forEach((value) => value.inset.dispose());
    this._disposables.dispose();
  }
  createWebviewEditorInset(editor, line, height, options, extension) {
    let apiEditor;
    for (const candidate of this._editors.getVisibleTextEditors(true)) {
      if (candidate.value === editor) {
        apiEditor = candidate;
        break;
      }
    }
    if (!apiEditor) {
      throw new Error("not a visible editor");
    }
    const that = this;
    const handle = this._handlePool++;
    const onDidReceiveMessage = new Emitter();
    const onDidDispose = new Emitter();
    const webview = new class {
      constructor() {
        this._html = "";
        this._options = /* @__PURE__ */ Object.create(null);
      }
      asWebviewUri(resource) {
        return asWebviewUri(resource, that._remoteInfo);
      }
      get cspSource() {
        return webviewGenericCspSource;
      }
      set options(value) {
        this._options = value;
        that._proxy.$setOptions(handle, value);
      }
      get options() {
        return this._options;
      }
      set html(value) {
        this._html = value;
        that._proxy.$setHtml(handle, value);
      }
      get html() {
        return this._html;
      }
      get onDidReceiveMessage() {
        return onDidReceiveMessage.event;
      }
      postMessage(message) {
        return that._proxy.$postMessage(handle, message);
      }
    }();
    const inset = new class {
      constructor() {
        this.editor = editor;
        this.line = line;
        this.height = height;
        this.webview = webview;
        this.onDidDispose = onDidDispose.event;
      }
      dispose() {
        if (that._insets.has(handle)) {
          that._insets.delete(handle);
          that._proxy.$disposeEditorInset(handle);
          onDidDispose.fire();
          onDidDispose.dispose();
          onDidReceiveMessage.dispose();
        }
      }
    }();
    this._proxy.$createEditorInset(handle, apiEditor.id, apiEditor.value.document.uri, line + 1, height, options || {}, extension.identifier, extension.extensionLocation);
    this._insets.set(handle, { editor, inset, onDidReceiveMessage });
    return inset;
  }
  $onDidDispose(handle) {
    const value = this._insets.get(handle);
    if (value) {
      value.inset.dispose();
    }
  }
  $onDidReceiveMessage(handle, message) {
    const value = this._insets.get(handle);
    value == null ? void 0 : value.onDidReceiveMessage.fire(message);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLabelService.js
init_lifecycle();
init_extHost_protocol();
var ExtHostLabelService = class {
  constructor(mainContext) {
    this._handlePool = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadLabelService);
  }
  $registerResourceLabelFormatter(formatter) {
    const handle = this._handlePool++;
    this._proxy.$registerResourceLabelFormatter(handle, formatter);
    return toDisposable(() => {
      this._proxy.$unregisterResourceLabelFormatter(handle);
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js
init_remoteHosts();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDecorations.js
init_tslib_es6();
init_uri();
init_extHost_protocol();
init_extHostTypes();
init_instantiation();
init_log();
init_arrays();
init_strings();
init_path();
var ExtHostDecorations_1;
var _a6;
var ExtHostDecorations = (_a6 = class {
  constructor(extHostRpc, _logService) {
    this._logService = _logService;
    this._provider = /* @__PURE__ */ new Map();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadDecorations);
  }
  registerFileDecorationProvider(provider, extensionDescription) {
    const handle = ExtHostDecorations_1._handlePool++;
    this._provider.set(handle, { provider, extensionDescription });
    this._proxy.$registerDecorationProvider(handle, extensionDescription.identifier.value);
    const listener = provider.onDidChangeFileDecorations && provider.onDidChangeFileDecorations((e) => {
      if (!e) {
        this._proxy.$onDidChange(handle, null);
        return;
      }
      const array = asArray(e);
      if (array.length <= ExtHostDecorations_1._maxEventSize) {
        this._proxy.$onDidChange(handle, array);
        return;
      }
      this._logService.warn("[Decorations] CAPPING events from decorations provider", extensionDescription.identifier.value, array.length);
      const mapped = array.map((uri) => ({ uri, rank: count(uri.path, "/") }));
      const groups = groupBy(mapped, (a, b) => a.rank - b.rank || compare(a.uri.path, b.uri.path));
      const picked = [];
      outer:
        for (const uris of groups) {
          let lastDirname;
          for (const obj of uris) {
            const myDirname = dirname(obj.uri.path);
            if (lastDirname !== myDirname) {
              lastDirname = myDirname;
              if (picked.push(obj.uri) >= ExtHostDecorations_1._maxEventSize) {
                break outer;
              }
            }
          }
        }
      this._proxy.$onDidChange(handle, picked);
    });
    return new Disposable2(() => {
      listener == null ? void 0 : listener.dispose();
      this._proxy.$unregisterDecorationProvider(handle);
      this._provider.delete(handle);
    });
  }
  async $provideDecorations(handle, requests, token) {
    if (!this._provider.has(handle)) {
      return /* @__PURE__ */ Object.create(null);
    }
    const result = /* @__PURE__ */ Object.create(null);
    const { provider, extensionDescription: extensionId } = this._provider.get(handle);
    await Promise.all(requests.map(async (request) => {
      try {
        const { uri, id } = request;
        const data = await Promise.resolve(provider.provideFileDecoration(URI.revive(uri), token));
        if (!data) {
          return;
        }
        try {
          FileDecoration.validate(data);
          if (data.badge && typeof data.badge !== "string") {
            checkProposedApiEnabled(extensionId, "codiconDecoration");
          }
          result[id] = [data.propagate, data.tooltip, data.badge, data.color];
        } catch (e) {
          this._logService.warn(`INVALID decoration from extension '${extensionId.identifier.value}': ${e}`);
        }
      } catch (err) {
        this._logService.error(err);
      }
    }));
    return result;
  }
}, ExtHostDecorations_1 = _a6, _a6._handlePool = 0, _a6._maxEventSize = 250, _a6);
ExtHostDecorations = ExtHostDecorations_1 = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService)
], ExtHostDecorations);
var IExtHostDecorations = createDecorator("IExtHostDecorations");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTask.js
init_tslib_es6();
init_uri();
init_async();
init_event();
init_extHost_protocol();
init_extHostTypes();
init_cancellation();
init_instantiation();
init_network();
init_platform();
init_log();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostApiDeprecationService.js
init_tslib_es6();
init_instantiation();
init_log();
init_extHost_protocol();
var IExtHostApiDeprecationService = createDecorator("IExtHostApiDeprecationService");
var ExtHostApiDeprecationService = class ExtHostApiDeprecationService2 {
  constructor(rpc, _extHostLogService) {
    this._extHostLogService = _extHostLogService;
    this._reportedUsages = /* @__PURE__ */ new Set();
    this._telemetryShape = rpc.getProxy(MainContext.MainThreadTelemetry);
  }
  report(apiId, extension, migrationSuggestion) {
    const key = this.getUsageKey(apiId, extension);
    if (this._reportedUsages.has(key)) {
      return;
    }
    this._reportedUsages.add(key);
    if (extension.isUnderDevelopment) {
      this._extHostLogService.warn(`[Deprecation Warning] '${apiId}' is deprecated. ${migrationSuggestion}`);
    }
    this._telemetryShape.$publicLog2("extHostDeprecatedApiUsage", {
      extensionId: extension.identifier.value,
      apiId
    });
  }
  getUsageKey(apiId, extension) {
    return `${apiId}-${extension.identifier.value}`;
  }
};
ExtHostApiDeprecationService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, ILogService)
], ExtHostApiDeprecationService);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTask.js
init_errors();
var TaskDefinitionDTO;
(function(TaskDefinitionDTO3) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  TaskDefinitionDTO3.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  TaskDefinitionDTO3.to = to;
})(TaskDefinitionDTO || (TaskDefinitionDTO = {}));
var TaskPresentationOptionsDTO;
(function(TaskPresentationOptionsDTO3) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  TaskPresentationOptionsDTO3.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  TaskPresentationOptionsDTO3.to = to;
})(TaskPresentationOptionsDTO || (TaskPresentationOptionsDTO = {}));
var ProcessExecutionOptionsDTO;
(function(ProcessExecutionOptionsDTO3) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  ProcessExecutionOptionsDTO3.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  ProcessExecutionOptionsDTO3.to = to;
})(ProcessExecutionOptionsDTO || (ProcessExecutionOptionsDTO = {}));
var ProcessExecutionDTO;
(function(ProcessExecutionDTO3) {
  function is(value) {
    if (value) {
      const candidate = value;
      return candidate && !!candidate.process;
    } else {
      return false;
    }
  }
  ProcessExecutionDTO3.is = is;
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    const result = {
      process: value.process,
      args: value.args
    };
    if (value.options) {
      result.options = ProcessExecutionOptionsDTO.from(value.options);
    }
    return result;
  }
  ProcessExecutionDTO3.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return new ProcessExecution(value.process, value.args, value.options);
  }
  ProcessExecutionDTO3.to = to;
})(ProcessExecutionDTO || (ProcessExecutionDTO = {}));
var ShellExecutionOptionsDTO;
(function(ShellExecutionOptionsDTO3) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  ShellExecutionOptionsDTO3.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return value;
  }
  ShellExecutionOptionsDTO3.to = to;
})(ShellExecutionOptionsDTO || (ShellExecutionOptionsDTO = {}));
var ShellExecutionDTO;
(function(ShellExecutionDTO3) {
  function is(value) {
    if (value) {
      const candidate = value;
      return candidate && (!!candidate.commandLine || !!candidate.command);
    } else {
      return false;
    }
  }
  ShellExecutionDTO3.is = is;
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    const result = {};
    if (value.commandLine !== void 0) {
      result.commandLine = value.commandLine;
    } else {
      result.command = value.command;
      result.args = value.args;
    }
    if (value.options) {
      result.options = ShellExecutionOptionsDTO.from(value.options);
    }
    return result;
  }
  ShellExecutionDTO3.from = from;
  function to(value) {
    if (value === void 0 || value === null || value.command === void 0 && value.commandLine === void 0) {
      return void 0;
    }
    if (value.commandLine) {
      return new ShellExecution(value.commandLine, value.options);
    } else {
      return new ShellExecution(value.command, value.args ? value.args : [], value.options);
    }
  }
  ShellExecutionDTO3.to = to;
})(ShellExecutionDTO || (ShellExecutionDTO = {}));
var CustomExecutionDTO;
(function(CustomExecutionDTO3) {
  function is(value) {
    if (value) {
      const candidate = value;
      return candidate && candidate.customExecution === "customExecution";
    } else {
      return false;
    }
  }
  CustomExecutionDTO3.is = is;
  function from(value) {
    return {
      customExecution: "customExecution"
    };
  }
  CustomExecutionDTO3.from = from;
  function to(taskId, providedCustomExeutions) {
    return providedCustomExeutions.get(taskId);
  }
  CustomExecutionDTO3.to = to;
})(CustomExecutionDTO || (CustomExecutionDTO = {}));
var TaskGroupDTO;
(function(TaskGroupDTO3) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return { _id: value.id, isDefault: value.isDefault };
  }
  TaskGroupDTO3.from = from;
})(TaskGroupDTO || (TaskGroupDTO = {}));
var TaskDTO;
(function(TaskDTO3) {
  function fromMany(tasks, extension) {
    if (tasks === void 0 || tasks === null) {
      return [];
    }
    const result = [];
    for (const task of tasks) {
      const converted = from(task, extension);
      if (converted) {
        result.push(converted);
      }
    }
    return result;
  }
  TaskDTO3.fromMany = fromMany;
  function from(value, extension) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    let execution;
    if (value.execution instanceof ProcessExecution) {
      execution = ProcessExecutionDTO.from(value.execution);
    } else if (value.execution instanceof ShellExecution) {
      execution = ShellExecutionDTO.from(value.execution);
    } else if (value.execution && value.execution instanceof CustomExecution) {
      execution = CustomExecutionDTO.from(value.execution);
    }
    const definition = TaskDefinitionDTO.from(value.definition);
    let scope;
    if (value.scope) {
      if (typeof value.scope === "number") {
        scope = value.scope;
      } else {
        scope = value.scope.uri;
      }
    } else {
      scope = TaskScope.Workspace;
    }
    if (!definition || !scope) {
      return void 0;
    }
    const result = {
      _id: value._id,
      definition,
      name: value.name,
      source: {
        extensionId: extension.identifier.value,
        label: value.source,
        scope
      },
      execution,
      isBackground: value.isBackground,
      group: TaskGroupDTO.from(value.group),
      presentationOptions: TaskPresentationOptionsDTO.from(value.presentationOptions),
      problemMatchers: value.problemMatchers,
      hasDefinedMatchers: value.hasDefinedMatchers,
      runOptions: value.runOptions ? value.runOptions : { reevaluateOnRerun: true },
      detail: value.detail
    };
    return result;
  }
  TaskDTO3.from = from;
  async function to(value, workspace, providedCustomExeutions) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    let execution;
    if (ProcessExecutionDTO.is(value.execution)) {
      execution = ProcessExecutionDTO.to(value.execution);
    } else if (ShellExecutionDTO.is(value.execution)) {
      execution = ShellExecutionDTO.to(value.execution);
    } else if (CustomExecutionDTO.is(value.execution)) {
      execution = CustomExecutionDTO.to(value._id, providedCustomExeutions);
    }
    const definition = TaskDefinitionDTO.to(value.definition);
    let scope;
    if (value.source) {
      if (value.source.scope !== void 0) {
        if (typeof value.source.scope === "number") {
          scope = value.source.scope;
        } else {
          scope = await workspace.resolveWorkspaceFolder(URI.revive(value.source.scope));
        }
      } else {
        scope = TaskScope.Workspace;
      }
    }
    if (!definition || !scope) {
      return void 0;
    }
    const result = new Task(definition, scope, value.name, value.source.label, execution, value.problemMatchers);
    if (value.isBackground !== void 0) {
      result.isBackground = value.isBackground;
    }
    if (value.group !== void 0) {
      result.group = TaskGroup.from(value.group._id);
      if (result.group && value.group.isDefault) {
        result.group = new TaskGroup(result.group.id, result.group.label);
        if (value.group.isDefault === true) {
          result.group.isDefault = value.group.isDefault;
        }
      }
    }
    if (value.presentationOptions) {
      result.presentationOptions = TaskPresentationOptionsDTO.to(value.presentationOptions);
    }
    if (value._id) {
      result._id = value._id;
    }
    if (value.detail) {
      result.detail = value.detail;
    }
    return result;
  }
  TaskDTO3.to = to;
})(TaskDTO || (TaskDTO = {}));
var TaskFilterDTO;
(function(TaskFilterDTO3) {
  function from(value) {
    return value;
  }
  TaskFilterDTO3.from = from;
  function to(value) {
    if (!value) {
      return void 0;
    }
    return Object.assign(/* @__PURE__ */ Object.create(null), value);
  }
  TaskFilterDTO3.to = to;
})(TaskFilterDTO || (TaskFilterDTO = {}));
var _tasks;
var TaskExecutionImpl = class {
  constructor(tasks, _id, _task) {
    __privateAdd(this, _tasks, void 0);
    this._id = _id;
    this._task = _task;
    __privateSet(this, _tasks, tasks);
  }
  get task() {
    return this._task;
  }
  terminate() {
    __privateGet(this, _tasks).terminateTask(this);
  }
  fireDidStartProcess(value) {
  }
  fireDidEndProcess(value) {
  }
};
_tasks = new WeakMap();
var ExtHostTaskBase = class ExtHostTaskBase2 {
  constructor(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService) {
    this._onDidExecuteTask = new Emitter();
    this._onDidTerminateTask = new Emitter();
    this._onDidTaskProcessStarted = new Emitter();
    this._onDidTaskProcessEnded = new Emitter();
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadTask);
    this._workspaceProvider = workspaceService;
    this._editorService = editorService;
    this._configurationService = configurationService;
    this._terminalService = extHostTerminalService;
    this._handleCounter = 0;
    this._handlers = /* @__PURE__ */ new Map();
    this._taskExecutions = /* @__PURE__ */ new Map();
    this._taskExecutionPromises = /* @__PURE__ */ new Map();
    this._providedCustomExecutions2 = /* @__PURE__ */ new Map();
    this._notProvidedCustomExecutions = /* @__PURE__ */ new Set();
    this._activeCustomExecutions2 = /* @__PURE__ */ new Map();
    this._logService = logService;
    this._deprecationService = deprecationService;
    this._proxy.$registerSupportedExecutions(true);
  }
  registerTaskProvider(extension, type, provider) {
    if (!provider) {
      return new Disposable2(() => {
      });
    }
    const handle = this.nextHandle();
    this._handlers.set(handle, { type, provider, extension });
    this._proxy.$registerTaskProvider(handle, type);
    return new Disposable2(() => {
      this._handlers.delete(handle);
      this._proxy.$unregisterTaskProvider(handle);
    });
  }
  registerTaskSystem(scheme, info) {
    this._proxy.$registerTaskSystem(scheme, info);
  }
  fetchTasks(filter2) {
    return this._proxy.$fetchTasks(TaskFilterDTO.from(filter2)).then(async (values) => {
      const result = [];
      for (const value of values) {
        const task = await TaskDTO.to(value, this._workspaceProvider, this._providedCustomExecutions2);
        if (task) {
          result.push(task);
        }
      }
      return result;
    });
  }
  get taskExecutions() {
    const result = [];
    this._taskExecutions.forEach((value) => result.push(value));
    return result;
  }
  terminateTask(execution) {
    if (!(execution instanceof TaskExecutionImpl)) {
      throw new Error("No valid task execution provided");
    }
    return this._proxy.$terminateTask(execution._id);
  }
  get onDidStartTask() {
    return this._onDidExecuteTask.event;
  }
  async $onDidStartTask(execution, terminalId, resolvedDefinition) {
    const customExecution = this._providedCustomExecutions2.get(execution.id);
    if (customExecution) {
      this._activeCustomExecutions2.set(execution.id, customExecution);
      this._terminalService.attachPtyToTerminal(terminalId, await customExecution.callback(resolvedDefinition));
    }
    this._lastStartedTask = execution.id;
    this._onDidExecuteTask.fire({
      execution: await this.getTaskExecution(execution)
    });
  }
  get onDidEndTask() {
    return this._onDidTerminateTask.event;
  }
  async $OnDidEndTask(execution) {
    const _execution = await this.getTaskExecution(execution);
    this._taskExecutionPromises.delete(execution.id);
    this._taskExecutions.delete(execution.id);
    this.customExecutionComplete(execution);
    this._onDidTerminateTask.fire({
      execution: _execution
    });
  }
  get onDidStartTaskProcess() {
    return this._onDidTaskProcessStarted.event;
  }
  async $onDidStartTaskProcess(value) {
    const execution = await this.getTaskExecution(value.id);
    this._onDidTaskProcessStarted.fire({
      execution,
      processId: value.processId
    });
  }
  get onDidEndTaskProcess() {
    return this._onDidTaskProcessEnded.event;
  }
  async $onDidEndTaskProcess(value) {
    const execution = await this.getTaskExecution(value.id);
    this._onDidTaskProcessEnded.fire({
      execution,
      exitCode: value.exitCode
    });
  }
  $provideTasks(handle, validTypes) {
    const handler = this._handlers.get(handle);
    if (!handler) {
      return Promise.reject(new Error("no handler found"));
    }
    const taskIdPromises = [];
    const fetchPromise = asPromise(() => handler.provider.provideTasks(CancellationToken.None)).then((value) => {
      return this.provideTasksInternal(validTypes, taskIdPromises, handler, value);
    });
    return new Promise((resolve) => {
      fetchPromise.then((result) => {
        Promise.all(taskIdPromises).then(() => {
          resolve(result);
        });
      });
    });
  }
  async $resolveTask(handle, taskDTO) {
    const handler = this._handlers.get(handle);
    if (!handler) {
      return Promise.reject(new Error("no handler found"));
    }
    if (taskDTO.definition.type !== handler.type) {
      throw new Error(`Unexpected: Task of type [${taskDTO.definition.type}] cannot be resolved by provider of type [${handler.type}].`);
    }
    const task = await TaskDTO.to(taskDTO, this._workspaceProvider, this._providedCustomExecutions2);
    if (!task) {
      throw new Error("Unexpected: Task cannot be resolved.");
    }
    const resolvedTask = await handler.provider.resolveTask(task, CancellationToken.None);
    if (!resolvedTask) {
      return;
    }
    this.checkDeprecation(resolvedTask, handler);
    const resolvedTaskDTO = TaskDTO.from(resolvedTask, handler.extension);
    if (!resolvedTaskDTO) {
      throw new Error("Unexpected: Task cannot be resolved.");
    }
    if (resolvedTask.definition !== task.definition) {
      throw new Error("Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.");
    }
    if (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {
      await this.addCustomExecution(resolvedTaskDTO, resolvedTask, true);
    }
    return await this.resolveTaskInternal(resolvedTaskDTO);
  }
  nextHandle() {
    return this._handleCounter++;
  }
  async addCustomExecution(taskDTO, task, isProvided) {
    const taskId = await this._proxy.$createTaskId(taskDTO);
    if (!isProvided && !this._providedCustomExecutions2.has(taskId)) {
      this._notProvidedCustomExecutions.add(taskId);
      this._activeCustomExecutions2.set(taskId, task.execution);
    }
    this._providedCustomExecutions2.set(taskId, task.execution);
  }
  async getTaskExecution(execution, task) {
    if (typeof execution === "string") {
      const taskExecution = this._taskExecutionPromises.get(execution);
      if (!taskExecution) {
        throw new ErrorNoTelemetry("Unexpected: The specified task is missing an execution");
      }
      return taskExecution;
    }
    const result = this._taskExecutionPromises.get(execution.id);
    if (result) {
      return result;
    }
    const createdResult = new Promise((resolve, reject) => {
      function resolvePromiseWithCreatedTask(that, execution2, taskToCreate) {
        if (!taskToCreate) {
          reject("Unexpected: Task does not exist.");
        } else {
          resolve(new TaskExecutionImpl(that, execution2.id, taskToCreate));
        }
      }
      if (task) {
        resolvePromiseWithCreatedTask(this, execution, task);
      } else {
        TaskDTO.to(execution.task, this._workspaceProvider, this._providedCustomExecutions2).then((task2) => resolvePromiseWithCreatedTask(this, execution, task2));
      }
    });
    this._taskExecutionPromises.set(execution.id, createdResult);
    return createdResult.then((executionCreatedResult) => {
      this._taskExecutions.set(execution.id, executionCreatedResult);
      return executionCreatedResult;
    }, (rejected) => {
      return Promise.reject(rejected);
    });
  }
  checkDeprecation(task, handler) {
    const tTask = task;
    if (tTask._deprecated) {
      this._deprecationService.report("Task.constructor", handler.extension, "Use the Task constructor that takes a `scope` instead.");
    }
  }
  customExecutionComplete(execution) {
    const extensionCallback2 = this._activeCustomExecutions2.get(execution.id);
    if (extensionCallback2) {
      this._activeCustomExecutions2.delete(execution.id);
    }
    if (this._notProvidedCustomExecutions.has(execution.id) && this._lastStartedTask !== execution.id) {
      this._providedCustomExecutions2.delete(execution.id);
      this._notProvidedCustomExecutions.delete(execution.id);
    }
    const iterator = this._notProvidedCustomExecutions.values();
    let iteratorResult = iterator.next();
    while (!iteratorResult.done) {
      if (!this._activeCustomExecutions2.has(iteratorResult.value) && this._lastStartedTask !== iteratorResult.value) {
        this._providedCustomExecutions2.delete(iteratorResult.value);
        this._notProvidedCustomExecutions.delete(iteratorResult.value);
      }
      iteratorResult = iterator.next();
    }
  }
};
ExtHostTaskBase = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, IExtHostWorkspace),
  __param(3, IExtHostDocumentsAndEditors),
  __param(4, IExtHostConfiguration),
  __param(5, IExtHostTerminalService),
  __param(6, ILogService),
  __param(7, IExtHostApiDeprecationService)
], ExtHostTaskBase);
var WorkerExtHostTask = class WorkerExtHostTask2 extends ExtHostTaskBase {
  constructor(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService) {
    super(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService);
    this.registerTaskSystem(Schemas.vscodeRemote, {
      scheme: Schemas.vscodeRemote,
      authority: "",
      platform: PlatformToString(0)
    });
  }
  async executeTask(extension, task) {
    if (!task.execution) {
      throw new Error("Tasks to execute must include an execution");
    }
    const dto = TaskDTO.from(task, extension);
    if (dto === void 0) {
      throw new Error("Task is not valid");
    }
    if (CustomExecutionDTO.is(dto.execution)) {
      await this.addCustomExecution(dto, task, false);
    } else {
      throw new NotSupportedError();
    }
    const execution = await this.getTaskExecution(await this._proxy.$getTaskExecution(dto), task);
    this._proxy.$executeTask(dto).catch((error) => {
      throw new Error(error);
    });
    return execution;
  }
  provideTasksInternal(validTypes, taskIdPromises, handler, value) {
    const taskDTOs = [];
    if (value) {
      for (const task of value) {
        this.checkDeprecation(task, handler);
        if (!task.definition || !validTypes[task.definition.type]) {
          this._logService.warn(`The task [${task.source}, ${task.name}] uses an undefined task type. The task will be ignored in the future.`);
        }
        const taskDTO = TaskDTO.from(task, handler.extension);
        if (taskDTO && CustomExecutionDTO.is(taskDTO.execution)) {
          taskDTOs.push(taskDTO);
          taskIdPromises.push(this.addCustomExecution(taskDTO, task, true));
        } else {
          this._logService.warn("Only custom execution tasks supported.");
        }
      }
    }
    return {
      tasks: taskDTOs,
      extension: handler.extension
    };
  }
  async resolveTaskInternal(resolvedTaskDTO) {
    if (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {
      return resolvedTaskDTO;
    } else {
      this._logService.warn("Only custom execution tasks supported.");
    }
    return void 0;
  }
  async $resolveVariables(uriComponents, toResolve) {
    const result = {
      process: void 0,
      variables: /* @__PURE__ */ Object.create(null)
    };
    return result;
  }
  async $jsonTasksSupported() {
    return false;
  }
  async $findExecutable(command, cwd2, paths) {
    return void 0;
  }
};
WorkerExtHostTask = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService),
  __param(2, IExtHostWorkspace),
  __param(3, IExtHostDocumentsAndEditors),
  __param(4, IExtHostConfiguration),
  __param(5, IExtHostTerminalService),
  __param(6, ILogService),
  __param(7, IExtHostApiDeprecationService)
], WorkerExtHostTask);
var IExtHostTask = createDecorator("IExtHostTask");

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDebugService.js
init_tslib_es6();
init_async();
init_event();
init_uri();
init_instantiation();
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostEditorTabs.js
init_tslib_es6();
init_extHost_protocol();
init_uri();
init_event();
init_instantiation();
init_extHostTypes();
init_types();
var IExtHostEditorTabs = createDecorator("IExtHostEditorTabs");
var ExtHostEditorTab = class {
  constructor(dto, parentGroup, activeTabIdGetter) {
    this._activeTabIdGetter = activeTabIdGetter;
    this._parentGroup = parentGroup;
    this.acceptDtoUpdate(dto);
  }
  get apiObject() {
    if (!this._apiObject) {
      const that = this;
      const obj = {
        get isActive() {
          return that._dto.id === that._activeTabIdGetter();
        },
        get label() {
          return that._dto.label;
        },
        get input() {
          return that._input;
        },
        get isDirty() {
          return that._dto.isDirty;
        },
        get isPinned() {
          return that._dto.isPinned;
        },
        get isPreview() {
          return that._dto.isPreview;
        },
        get group() {
          return that._parentGroup.apiObject;
        }
      };
      this._apiObject = Object.freeze(obj);
    }
    return this._apiObject;
  }
  get tabId() {
    return this._dto.id;
  }
  acceptDtoUpdate(dto) {
    this._dto = dto;
    this._input = this._initInput();
  }
  _initInput() {
    switch (this._dto.input.kind) {
      case 1:
        return new TextTabInput(URI.revive(this._dto.input.uri));
      case 2:
        return new TextDiffTabInput(URI.revive(this._dto.input.original), URI.revive(this._dto.input.modified));
      case 3:
        return new TextMergeTabInput(
          URI.revive(this._dto.input.base),
          URI.revive(this._dto.input.input1),
          URI.revive(this._dto.input.input2),
          URI.revive(this._dto.input.result)
        );
      case 6:
        return new CustomEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.viewType);
      case 7:
        return new WebviewEditorTabInput(this._dto.input.viewType);
      case 4:
        return new NotebookEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.notebookType);
      case 5:
        return new NotebookDiffEditorTabInput(
          URI.revive(this._dto.input.original),
          URI.revive(this._dto.input.modified),
          this._dto.input.notebookType
        );
      case 8:
        return new TerminalEditorTabInput();
      case 9:
        return new InteractiveWindowInput(URI.revive(this._dto.input.uri), URI.revive(this._dto.input.inputBoxUri));
      default:
        return void 0;
    }
  }
};
var ExtHostEditorTabGroup = class {
  constructor(dto, activeGroupIdGetter) {
    this._tabs = [];
    this._activeTabId = "";
    this._dto = dto;
    this._activeGroupIdGetter = activeGroupIdGetter;
    for (const tabDto of dto.tabs) {
      if (tabDto.isActive) {
        this._activeTabId = tabDto.id;
      }
      this._tabs.push(new ExtHostEditorTab(tabDto, this, () => this.activeTabId()));
    }
  }
  get apiObject() {
    if (!this._apiObject) {
      const that = this;
      const obj = {
        get isActive() {
          return that._dto.groupId === that._activeGroupIdGetter();
        },
        get viewColumn() {
          return ViewColumn2.to(that._dto.viewColumn);
        },
        get activeTab() {
          var _a30;
          return (_a30 = that._tabs.find((tab) => tab.tabId === that._activeTabId)) == null ? void 0 : _a30.apiObject;
        },
        get tabs() {
          return Object.freeze(that._tabs.map((tab) => tab.apiObject));
        }
      };
      this._apiObject = Object.freeze(obj);
    }
    return this._apiObject;
  }
  get groupId() {
    return this._dto.groupId;
  }
  get tabs() {
    return this._tabs;
  }
  acceptGroupDtoUpdate(dto) {
    this._dto = dto;
  }
  acceptTabOperation(operation) {
    if (operation.kind === 0) {
      const tab2 = new ExtHostEditorTab(operation.tabDto, this, () => this.activeTabId());
      this._tabs.splice(operation.index, 0, tab2);
      if (operation.tabDto.isActive) {
        this._activeTabId = tab2.tabId;
      }
      return tab2;
    } else if (operation.kind === 1) {
      const tab2 = this._tabs.splice(operation.index, 1)[0];
      if (!tab2) {
        throw new Error(`Tab close updated received for index ${operation.index} which does not exist`);
      }
      if (tab2.tabId === this._activeTabId) {
        this._activeTabId = "";
      }
      return tab2;
    } else if (operation.kind === 3) {
      if (operation.oldIndex === void 0) {
        throw new Error("Invalid old index on move IPC");
      }
      const tab2 = this._tabs.splice(operation.oldIndex, 1)[0];
      if (!tab2) {
        throw new Error(`Tab move updated received for index ${operation.oldIndex} which does not exist`);
      }
      this._tabs.splice(operation.index, 0, tab2);
      return tab2;
    }
    const tab = this._tabs.find((extHostTab) => extHostTab.tabId === operation.tabDto.id);
    if (!tab) {
      throw new Error("INVALID tab");
    }
    if (operation.tabDto.isActive) {
      this._activeTabId = operation.tabDto.id;
    } else if (this._activeTabId === operation.tabDto.id && !operation.tabDto.isActive) {
      this._activeTabId = "";
    }
    tab.acceptDtoUpdate(operation.tabDto);
    return tab;
  }
  activeTabId() {
    return this._activeTabId;
  }
};
var ExtHostEditorTabs = class ExtHostEditorTabs2 {
  constructor(extHostRpc) {
    this._onDidChangeTabs = new Emitter();
    this._onDidChangeTabGroups = new Emitter();
    this._extHostTabGroups = [];
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadEditorTabs);
  }
  get tabGroups() {
    if (!this._apiObject) {
      const that = this;
      const obj = {
        onDidChangeTabGroups: that._onDidChangeTabGroups.event,
        onDidChangeTabs: that._onDidChangeTabs.event,
        get all() {
          return Object.freeze(that._extHostTabGroups.map((group) => group.apiObject));
        },
        get activeTabGroup() {
          var _a30;
          const activeTabGroupId = that._activeGroupId;
          const activeTabGroup = assertIsDefined((_a30 = that._extHostTabGroups.find((candidate) => candidate.groupId === activeTabGroupId)) == null ? void 0 : _a30.apiObject);
          return activeTabGroup;
        },
        close: async (tabOrTabGroup, preserveFocus) => {
          const tabsOrTabGroups = Array.isArray(tabOrTabGroup) ? tabOrTabGroup : [tabOrTabGroup];
          if (!tabsOrTabGroups.length) {
            return true;
          }
          if (isTabGroup(tabsOrTabGroups[0])) {
            return this._closeGroups(tabsOrTabGroups, preserveFocus);
          } else {
            return this._closeTabs(tabsOrTabGroups, preserveFocus);
          }
        }
      };
      this._apiObject = Object.freeze(obj);
    }
    return this._apiObject;
  }
  $acceptEditorTabModel(tabGroups) {
    var _a30;
    const groupIdsBefore = new Set(this._extHostTabGroups.map((group) => group.groupId));
    const groupIdsAfter = new Set(tabGroups.map((dto) => dto.groupId));
    const diff = diffSets(groupIdsBefore, groupIdsAfter);
    const closed = this._extHostTabGroups.filter((group) => diff.removed.includes(group.groupId)).map((group) => group.apiObject);
    const opened = [];
    const changed = [];
    this._extHostTabGroups = tabGroups.map((tabGroup) => {
      const group = new ExtHostEditorTabGroup(tabGroup, () => this._activeGroupId);
      if (diff.added.includes(group.groupId)) {
        opened.push(group.apiObject);
      } else {
        changed.push(group.apiObject);
      }
      return group;
    });
    const activeTabGroupId = assertIsDefined((_a30 = tabGroups.find((group) => group.isActive === true)) == null ? void 0 : _a30.groupId);
    if (activeTabGroupId !== void 0 && this._activeGroupId !== activeTabGroupId) {
      this._activeGroupId = activeTabGroupId;
    }
    this._onDidChangeTabGroups.fire(Object.freeze({ opened, closed, changed }));
  }
  $acceptTabGroupUpdate(groupDto) {
    const group = this._extHostTabGroups.find((group2) => group2.groupId === groupDto.groupId);
    if (!group) {
      throw new Error("Update Group IPC call received before group creation.");
    }
    group.acceptGroupDtoUpdate(groupDto);
    if (groupDto.isActive) {
      this._activeGroupId = groupDto.groupId;
    }
    this._onDidChangeTabGroups.fire(Object.freeze({ changed: [group.apiObject], opened: [], closed: [] }));
  }
  $acceptTabOperation(operation) {
    const group = this._extHostTabGroups.find((group2) => group2.groupId === operation.groupId);
    if (!group) {
      throw new Error("Update Tabs IPC call received before group creation.");
    }
    const tab = group.acceptTabOperation(operation);
    switch (operation.kind) {
      case 0:
        this._onDidChangeTabs.fire(Object.freeze({
          opened: [tab.apiObject],
          closed: [],
          changed: []
        }));
        return;
      case 1:
        this._onDidChangeTabs.fire(Object.freeze({
          opened: [],
          closed: [tab.apiObject],
          changed: []
        }));
        return;
      case 3:
      case 2:
        this._onDidChangeTabs.fire(Object.freeze({
          opened: [],
          closed: [],
          changed: [tab.apiObject]
        }));
        return;
    }
  }
  _findExtHostTabFromApi(apiTab) {
    for (const group of this._extHostTabGroups) {
      for (const tab of group.tabs) {
        if (tab.apiObject === apiTab) {
          return tab;
        }
      }
    }
    return;
  }
  _findExtHostTabGroupFromApi(apiTabGroup) {
    return this._extHostTabGroups.find((candidate) => candidate.apiObject === apiTabGroup);
  }
  async _closeTabs(tabs, preserveFocus) {
    const extHostTabIds = [];
    for (const tab of tabs) {
      const extHostTab = this._findExtHostTabFromApi(tab);
      if (!extHostTab) {
        throw new Error("Tab close: Invalid tab not found!");
      }
      extHostTabIds.push(extHostTab.tabId);
    }
    return this._proxy.$closeTab(extHostTabIds, preserveFocus);
  }
  async _closeGroups(groups, preserverFoucs) {
    const extHostGroupIds = [];
    for (const group of groups) {
      const extHostGroup = this._findExtHostTabGroupFromApi(group);
      if (!extHostGroup) {
        throw new Error("Group close: Invalid group not found!");
      }
      extHostGroupIds.push(extHostGroup.groupId);
    }
    return this._proxy.$closeGroup(extHostGroupIds, preserverFoucs);
  }
};
ExtHostEditorTabs = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostEditorTabs);
function isTabGroup(obj) {
  const tabGroup = obj;
  if (tabGroup.tabs !== void 0) {
    return true;
  }
  return false;
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDebugService.js
init_extHostTypes();

// node_modules/vscode/vscode/src/vs/workbench/contrib/debug/common/abstractDebugAdapter.js
init_event();
init_async();
init_nls();
var AbstractDebugAdapter = class {
  constructor() {
    this.pendingRequests = /* @__PURE__ */ new Map();
    this.queue = [];
    this._onError = new Emitter();
    this._onExit = new Emitter();
    this.sequence = 1;
  }
  get onError() {
    return this._onError.event;
  }
  get onExit() {
    return this._onExit.event;
  }
  onMessage(callback) {
    if (this.messageCallback) {
      this._onError.fire(new Error(`attempt to set more than one 'Message' callback`));
    }
    this.messageCallback = callback;
  }
  onEvent(callback) {
    if (this.eventCallback) {
      this._onError.fire(new Error(`attempt to set more than one 'Event' callback`));
    }
    this.eventCallback = callback;
  }
  onRequest(callback) {
    if (this.requestCallback) {
      this._onError.fire(new Error(`attempt to set more than one 'Request' callback`));
    }
    this.requestCallback = callback;
  }
  sendResponse(response) {
    if (response.seq > 0) {
      this._onError.fire(new Error(`attempt to send more than one response for command ${response.command}`));
    } else {
      this.internalSend("response", response);
    }
  }
  sendRequest(command, args, clb, timeout2) {
    const request = {
      command
    };
    if (args && Object.keys(args).length > 0) {
      request.arguments = args;
    }
    this.internalSend("request", request);
    if (typeof timeout2 === "number") {
      const timer = setTimeout(() => {
        clearTimeout(timer);
        const clb2 = this.pendingRequests.get(request.seq);
        if (clb2) {
          this.pendingRequests.delete(request.seq);
          const err = {
            type: "response",
            seq: 0,
            request_seq: request.seq,
            success: false,
            command,
            message: localize("timeout", "Timeout after {0} ms for '{1}'", timeout2, command)
          };
          clb2(err);
        }
      }, timeout2);
    }
    if (clb) {
      this.pendingRequests.set(request.seq, clb);
    }
    return request.seq;
  }
  acceptMessage(message) {
    if (this.messageCallback) {
      this.messageCallback(message);
    } else {
      this.queue.push(message);
      if (this.queue.length === 1) {
        this.processQueue();
      }
    }
  }
  needsTaskBoundaryBetween(messageA, messageB) {
    return messageA.type !== "event" || messageB.type !== "event";
  }
  async processQueue() {
    var _a30, _b;
    let message;
    while (this.queue.length) {
      if (!message || this.needsTaskBoundaryBetween(this.queue[0], message)) {
        await timeout(0);
      }
      message = this.queue.shift();
      if (!message) {
        return;
      }
      switch (message.type) {
        case "event":
          (_a30 = this.eventCallback) == null ? void 0 : _a30.call(this, message);
          break;
        case "request":
          (_b = this.requestCallback) == null ? void 0 : _b.call(this, message);
          break;
        case "response": {
          const response = message;
          const clb = this.pendingRequests.get(response.request_seq);
          if (clb) {
            this.pendingRequests.delete(response.request_seq);
            clb(response);
          }
          break;
        }
      }
    }
  }
  internalSend(typ, message) {
    message.type = typ;
    message.seq = this.sequence++;
    this.sendMessage(message);
  }
  async cancelPendingRequests() {
    if (this.pendingRequests.size === 0) {
      return Promise.resolve();
    }
    const pending = /* @__PURE__ */ new Map();
    this.pendingRequests.forEach((value, key) => pending.set(key, value));
    await timeout(500);
    pending.forEach((callback, request_seq) => {
      const err = {
        type: "response",
        seq: 0,
        request_seq,
        success: false,
        command: "canceled",
        message: "canceled"
      };
      callback(err);
      this.pendingRequests.delete(request_seq);
    });
  }
  getPendingRequestIds() {
    return Array.from(this.pendingRequests.keys());
  }
  dispose() {
    this.queue = [];
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/debug/common/debugUtils.js
init_strings();
init_uri();
init_path();
init_objects();
init_network();
init_range();
init_cancellation();
init_arrays();
function isSessionAttach(session) {
  return session.configuration.request === "attach" && !getExtensionHostDebugSession(session) && (!session.parentSession || isSessionAttach(session.parentSession));
}
function getExtensionHostDebugSession(session) {
  let type = session.configuration.type;
  if (!type) {
    return;
  }
  if (type === "vslsShare") {
    type = session.configuration.adapterProxy.configuration.type;
  }
  if (equalsIgnoreCase(type, "extensionhost") || equalsIgnoreCase(type, "pwa-extensionhost")) {
    return session;
  }
  return session.parentSession ? getExtensionHostDebugSession(session.parentSession) : void 0;
}
function isDebuggerMainContribution(dbg) {
  return dbg.type && (dbg.label || dbg.program || dbg.runtime);
}
var _schemePattern = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/;
function isUri2(s) {
  return !!(s && s.match(_schemePattern));
}
function stringToUri(source) {
  if (typeof source.path === "string") {
    if (typeof source.sourceReference === "number" && source.sourceReference > 0)
      ;
    else {
      if (isUri2(source.path)) {
        return URI.parse(source.path);
      } else {
        if (isAbsolute(source.path)) {
          return URI.file(source.path);
        }
      }
    }
  }
  return source.path;
}
function uriToString(source) {
  if (typeof source.path === "object") {
    const u = URI.revive(source.path);
    if (u) {
      if (u.scheme === Schemas.file) {
        return u.fsPath;
      } else {
        return u.toString();
      }
    }
  }
  return source.path;
}
function convertToDAPaths(message, toUri) {
  const fixPath = toUri ? stringToUri : uriToString;
  const msg = deepClone(message);
  convertPaths(msg, (toDA, source) => {
    if (toDA && source) {
      source.path = fixPath(source);
    }
  });
  return msg;
}
function convertToVSCPaths(message, toUri) {
  const fixPath = toUri ? stringToUri : uriToString;
  const msg = deepClone(message);
  convertPaths(msg, (toDA, source) => {
    if (!toDA && source) {
      source.path = fixPath(source);
    }
  });
  return msg;
}
function convertPaths(msg, fixSourcePath) {
  var _a30;
  switch (msg.type) {
    case "event": {
      const event = msg;
      switch (event.event) {
        case "output":
          fixSourcePath(false, event.body.source);
          break;
        case "loadedSource":
          fixSourcePath(false, event.body.source);
          break;
        case "breakpoint":
          fixSourcePath(false, event.body.breakpoint.source);
          break;
      }
      break;
    }
    case "request": {
      const request = msg;
      switch (request.command) {
        case "setBreakpoints":
          fixSourcePath(true, request.arguments.source);
          break;
        case "breakpointLocations":
          fixSourcePath(true, request.arguments.source);
          break;
        case "source":
          fixSourcePath(true, request.arguments.source);
          break;
        case "gotoTargets":
          fixSourcePath(true, request.arguments.source);
          break;
        case "launchVSCode":
          request.arguments.args.forEach((arg) => fixSourcePath(false, arg));
          break;
      }
      break;
    }
    case "response": {
      const response = msg;
      if (response.success && response.body) {
        switch (response.command) {
          case "stackTrace":
            response.body.stackFrames.forEach((frame) => fixSourcePath(false, frame.source));
            break;
          case "loadedSources":
            response.body.sources.forEach((source) => fixSourcePath(false, source));
            break;
          case "scopes":
            response.body.scopes.forEach((scope) => fixSourcePath(false, scope.source));
            break;
          case "setFunctionBreakpoints":
            response.body.breakpoints.forEach((bp) => fixSourcePath(false, bp.source));
            break;
          case "setBreakpoints":
            response.body.breakpoints.forEach((bp) => fixSourcePath(false, bp.source));
            break;
          case "disassemble":
            {
              const di = response;
              (_a30 = di.body) == null ? void 0 : _a30.instructions.forEach((di2) => fixSourcePath(false, di2.location));
            }
            break;
        }
      }
      break;
    }
  }
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostVariableResolverService.js
init_tslib_es6();
init_lazy();
init_lifecycle();
init_path();
init_process();
init_instantiation();
init_extHostTypes();

// node_modules/vscode/vscode/src/vs/workbench/services/configurationResolver/common/variableResolver.js
init_path();
init_process();
init_types();
init_objects();
init_platform();
init_nls();
init_strings();
var _AbstractVariableResolverService = class _AbstractVariableResolverService {
  constructor(_context, _labelService, _userHomePromise, _envVariablesPromise) {
    this._contributedVariables = /* @__PURE__ */ new Map();
    this._context = _context;
    this._labelService = _labelService;
    this._userHomePromise = _userHomePromise;
    if (_envVariablesPromise) {
      this._envVariablesPromise = _envVariablesPromise.then((envVariables) => {
        return this.prepareEnv(envVariables);
      });
    }
  }
  prepareEnv(envVariables) {
    if (isWindows) {
      const ev = /* @__PURE__ */ Object.create(null);
      Object.keys(envVariables).forEach((key) => {
        ev[key.toLowerCase()] = envVariables[key];
      });
      return ev;
    }
    return envVariables;
  }
  resolveWithEnvironment(environment, root, value) {
    return this.recursiveResolve({ env: this.prepareEnv(environment), userHome: void 0 }, root ? root.uri : void 0, value);
  }
  async resolveAsync(root, value) {
    const environment = {
      env: await this._envVariablesPromise,
      userHome: await this._userHomePromise
    };
    return this.recursiveResolve(environment, root ? root.uri : void 0, value);
  }
  async resolveAnyBase(workspaceFolder, config, commandValueMapping, resolvedVariables) {
    const result = deepClone(config);
    if (isWindows && result.windows) {
      Object.keys(result.windows).forEach((key) => result[key] = result.windows[key]);
    } else if (isMacintosh && result.osx) {
      Object.keys(result.osx).forEach((key) => result[key] = result.osx[key]);
    } else if (isLinux && result.linux) {
      Object.keys(result.linux).forEach((key) => result[key] = result.linux[key]);
    }
    delete result.windows;
    delete result.osx;
    delete result.linux;
    const environmentPromises = {
      env: await this._envVariablesPromise,
      userHome: await this._userHomePromise
    };
    return this.recursiveResolve(environmentPromises, workspaceFolder ? workspaceFolder.uri : void 0, result, commandValueMapping, resolvedVariables);
  }
  async resolveAnyAsync(workspaceFolder, config, commandValueMapping) {
    return this.resolveAnyBase(workspaceFolder, config, commandValueMapping);
  }
  async resolveAnyMap(workspaceFolder, config, commandValueMapping) {
    const resolvedVariables = /* @__PURE__ */ new Map();
    const newConfig = await this.resolveAnyBase(workspaceFolder, config, commandValueMapping, resolvedVariables);
    return { newConfig, resolvedVariables };
  }
  resolveWithInteractionReplace(folder, config, section, variables) {
    throw new Error("resolveWithInteractionReplace not implemented.");
  }
  resolveWithInteraction(folder, config, section, variables) {
    throw new Error("resolveWithInteraction not implemented.");
  }
  contributeVariable(variable, resolution) {
    if (this._contributedVariables.has(variable)) {
      throw new Error("Variable " + variable + " is contributed twice.");
    } else {
      this._contributedVariables.set(variable, resolution);
    }
  }
  async recursiveResolve(environment, folderUri, value, commandValueMapping, resolvedVariables) {
    if (isString(value)) {
      return this.resolveString(environment, folderUri, value, commandValueMapping, resolvedVariables);
    } else if (Array.isArray(value)) {
      return Promise.all(value.map(
        (s) => this.recursiveResolve(environment, folderUri, s, commandValueMapping, resolvedVariables)
      ));
    } else if (isObject(value)) {
      const result = /* @__PURE__ */ Object.create(null);
      const replaced = await Promise.all(Object.keys(value).map(async (key) => {
        const replaced2 = await this.resolveString(environment, folderUri, key, commandValueMapping, resolvedVariables);
        return [replaced2, await this.recursiveResolve(environment, folderUri, value[key], commandValueMapping, resolvedVariables)];
      }));
      for (const [key, value2] of replaced) {
        result[key] = value2;
      }
      return result;
    }
    return value;
  }
  resolveString(environment, folderUri, value, commandValueMapping, resolvedVariables) {
    return replaceAsync(value, _AbstractVariableResolverService.VARIABLE_REGEXP, async (match, variable) => {
      if (variable.includes(_AbstractVariableResolverService.VARIABLE_LHS)) {
        return match;
      }
      let resolvedValue = await this.evaluateSingleVariable(environment, match, variable, folderUri, commandValueMapping);
      resolvedVariables == null ? void 0 : resolvedVariables.set(variable, resolvedValue);
      if (resolvedValue !== match && isString(resolvedValue) && resolvedValue.match(_AbstractVariableResolverService.VARIABLE_REGEXP)) {
        resolvedValue = await this.resolveString(environment, folderUri, resolvedValue, commandValueMapping, resolvedVariables);
      }
      return resolvedValue;
    });
  }
  fsPath(displayUri) {
    return this._labelService ? this._labelService.getUriLabel(displayUri, { noPrefix: true }) : displayUri.fsPath;
  }
  async evaluateSingleVariable(environment, match, variable, folderUri, commandValueMapping) {
    let argument;
    const parts = variable.split(":");
    if (parts.length > 1) {
      variable = parts[0];
      argument = parts[1];
    }
    const getFilePath = (variableKind) => {
      const filePath = this._context.getFilePath();
      if (filePath) {
        return normalizeDriveLetter(filePath);
      }
      throw new VariableError(variableKind, localize("canNotResolveFile", "Variable {0} can not be resolved. Please open an editor.", match));
    };
    const getFolderPathForFile = (variableKind) => {
      const filePath = getFilePath(variableKind);
      if (this._context.getWorkspaceFolderPathForFile) {
        const folderPath = this._context.getWorkspaceFolderPathForFile();
        if (folderPath) {
          return normalizeDriveLetter(folderPath);
        }
      }
      throw new VariableError(variableKind, localize("canNotResolveFolderForFile", "Variable {0}: can not find workspace folder of '{1}'.", match, basename(filePath)));
    };
    const getFolderUri = (variableKind) => {
      if (argument) {
        const folder = this._context.getFolderUri(argument);
        if (folder) {
          return folder;
        }
        throw new VariableError(variableKind, localize("canNotFindFolder", "Variable {0} can not be resolved. No such folder '{1}'.", match, argument));
      }
      if (folderUri) {
        return folderUri;
      }
      if (this._context.getWorkspaceFolderCount() > 1) {
        throw new VariableError(variableKind, localize("canNotResolveWorkspaceFolderMultiRoot", "Variable {0} can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.", match));
      }
      throw new VariableError(variableKind, localize("canNotResolveWorkspaceFolder", "Variable {0} can not be resolved. Please open a folder.", match));
    };
    switch (variable) {
      case "env":
        if (argument) {
          if (environment.env) {
            const env2 = environment.env[isWindows ? argument.toLowerCase() : argument];
            if (isString(env2)) {
              return env2;
            }
          }
          return "";
        }
        throw new VariableError(VariableKind.Env, localize("missingEnvVarName", "Variable {0} can not be resolved because no environment variable name is given.", match));
      case "config":
        if (argument) {
          const config = this._context.getConfigurationValue(folderUri, argument);
          if (isUndefinedOrNull(config)) {
            throw new VariableError(VariableKind.Config, localize("configNotFound", "Variable {0} can not be resolved because setting '{1}' not found.", match, argument));
          }
          if (isObject(config)) {
            throw new VariableError(VariableKind.Config, localize("configNoString", "Variable {0} can not be resolved because '{1}' is a structured value.", match, argument));
          }
          return config;
        }
        throw new VariableError(VariableKind.Config, localize("missingConfigName", "Variable {0} can not be resolved because no settings name is given.", match));
      case "command":
        return this.resolveFromMap(VariableKind.Command, match, argument, commandValueMapping, "command");
      case "input":
        return this.resolveFromMap(VariableKind.Input, match, argument, commandValueMapping, "input");
      case "extensionInstallFolder":
        if (argument) {
          const ext = await this._context.getExtension(argument);
          if (!ext) {
            throw new VariableError(VariableKind.ExtensionInstallFolder, localize("extensionNotInstalled", "Variable {0} can not be resolved because the extension {1} is not installed.", match, argument));
          }
          return this.fsPath(ext.extensionLocation);
        }
        throw new VariableError(VariableKind.ExtensionInstallFolder, localize("missingExtensionName", "Variable {0} can not be resolved because no extension name is given.", match));
      default: {
        switch (variable) {
          case "workspaceRoot":
          case "workspaceFolder":
            return normalizeDriveLetter(this.fsPath(getFolderUri(VariableKind.WorkspaceFolder)));
          case "cwd":
            return folderUri || argument ? normalizeDriveLetter(this.fsPath(getFolderUri(VariableKind.Cwd))) : cwd();
          case "workspaceRootFolderName":
          case "workspaceFolderBasename":
            return normalizeDriveLetter(basename(this.fsPath(getFolderUri(VariableKind.WorkspaceFolderBasename))));
          case "userHome": {
            if (environment.userHome) {
              return environment.userHome;
            }
            throw new VariableError(VariableKind.UserHome, localize("canNotResolveUserHome", "Variable {0} can not be resolved. UserHome path is not defined", match));
          }
          case "lineNumber": {
            const lineNumber = this._context.getLineNumber();
            if (lineNumber) {
              return lineNumber;
            }
            throw new VariableError(VariableKind.LineNumber, localize("canNotResolveLineNumber", "Variable {0} can not be resolved. Make sure to have a line selected in the active editor.", match));
          }
          case "selectedText": {
            const selectedText = this._context.getSelectedText();
            if (selectedText) {
              return selectedText;
            }
            throw new VariableError(VariableKind.SelectedText, localize("canNotResolveSelectedText", "Variable {0} can not be resolved. Make sure to have some text selected in the active editor.", match));
          }
          case "file":
            return getFilePath(VariableKind.File);
          case "fileWorkspaceFolder":
            return getFolderPathForFile(VariableKind.FileWorkspaceFolder);
          case "relativeFile":
            if (folderUri || argument) {
              return relative(this.fsPath(getFolderUri(VariableKind.RelativeFile)), getFilePath(VariableKind.RelativeFile));
            }
            return getFilePath(VariableKind.RelativeFile);
          case "relativeFileDirname": {
            const dirname3 = dirname(getFilePath(VariableKind.RelativeFileDirname));
            if (folderUri || argument) {
              const relative2 = relative(this.fsPath(getFolderUri(VariableKind.RelativeFileDirname)), dirname3);
              return relative2.length === 0 ? "." : relative2;
            }
            return dirname3;
          }
          case "fileDirname":
            return dirname(getFilePath(VariableKind.FileDirname));
          case "fileExtname":
            return extname(getFilePath(VariableKind.FileExtname));
          case "fileBasename":
            return basename(getFilePath(VariableKind.FileBasename));
          case "fileBasenameNoExtension": {
            const basename3 = basename(getFilePath(VariableKind.FileBasenameNoExtension));
            return basename3.slice(0, basename3.length - extname(basename3).length);
          }
          case "fileDirnameBasename":
            return basename(dirname(getFilePath(VariableKind.FileDirnameBasename)));
          case "execPath": {
            const ep = this._context.getExecPath();
            if (ep) {
              return ep;
            }
            return match;
          }
          case "execInstallFolder": {
            const ar = this._context.getAppRoot();
            if (ar) {
              return ar;
            }
            return match;
          }
          case "pathSeparator":
            return sep;
          default:
            try {
              const key = argument ? `${variable}:${argument}` : variable;
              return this.resolveFromMap(VariableKind.Unknown, match, key, commandValueMapping, void 0);
            } catch (error) {
              return match;
            }
        }
      }
    }
  }
  resolveFromMap(variableKind, match, argument, commandValueMapping, prefix) {
    if (argument && commandValueMapping) {
      const v = prefix === void 0 ? commandValueMapping[argument] : commandValueMapping[prefix + ":" + argument];
      if (typeof v === "string") {
        return v;
      }
      throw new VariableError(variableKind, localize("noValueForCommand", "Variable {0} can not be resolved because the command has no value.", match));
    }
    return match;
  }
};
_AbstractVariableResolverService.VARIABLE_LHS = "${";
_AbstractVariableResolverService.VARIABLE_REGEXP = /\$\{(.*?)\}/g;
var AbstractVariableResolverService = _AbstractVariableResolverService;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostVariableResolverService.js
var IExtHostVariableResolverProvider = createDecorator("IExtHostVariableResolverProvider");
var ExtHostVariableResolverService = class extends AbstractVariableResolverService {
  constructor(extensionService, workspaceService, editorService, editorTabs, configProvider, context, homeDir) {
    function getActiveUri() {
      var _a30;
      if (editorService) {
        const activeEditor = editorService.activeEditor();
        if (activeEditor) {
          return activeEditor.document.uri;
        }
        const activeTab = (_a30 = editorTabs.tabGroups.all.find((group) => group.isActive)) == null ? void 0 : _a30.activeTab;
        if (activeTab !== void 0) {
          if (activeTab.input instanceof TextDiffTabInput || activeTab.input instanceof NotebookDiffEditorTabInput) {
            return activeTab.input.modified;
          } else if (activeTab.input instanceof TextTabInput || activeTab.input instanceof NotebookEditorTabInput || activeTab.input instanceof CustomEditorTabInput) {
            return activeTab.input.uri;
          }
        }
      }
      return void 0;
    }
    super({
      getFolderUri: (folderName) => {
        const found = context.folders.filter((f) => f.name === folderName);
        if (found && found.length > 0) {
          return found[0].uri;
        }
        return void 0;
      },
      getWorkspaceFolderCount: () => {
        return context.folders.length;
      },
      getConfigurationValue: (folderUri, section) => {
        return configProvider.getConfiguration(void 0, folderUri).get(section);
      },
      getAppRoot: () => {
        return cwd();
      },
      getExecPath: () => {
        return env["VSCODE_EXEC_PATH"];
      },
      getFilePath: () => {
        const activeUri = getActiveUri();
        if (activeUri) {
          return normalize(activeUri.fsPath);
        }
        return void 0;
      },
      getWorkspaceFolderPathForFile: () => {
        if (workspaceService) {
          const activeUri = getActiveUri();
          if (activeUri) {
            const ws = workspaceService.getWorkspaceFolder(activeUri);
            if (ws) {
              return normalize(ws.uri.fsPath);
            }
          }
        }
        return void 0;
      },
      getSelectedText: () => {
        if (editorService) {
          const activeEditor = editorService.activeEditor();
          if (activeEditor && !activeEditor.selection.isEmpty) {
            return activeEditor.document.getText(activeEditor.selection);
          }
        }
        return void 0;
      },
      getLineNumber: () => {
        if (editorService) {
          const activeEditor = editorService.activeEditor();
          if (activeEditor) {
            return String(activeEditor.selection.end.line + 1);
          }
        }
        return void 0;
      },
      getExtension: (id) => {
        return extensionService.getExtension(id);
      }
    }, void 0, homeDir ? Promise.resolve(homeDir) : void 0, Promise.resolve(env));
  }
};
var ExtHostVariableResolverProviderService = class ExtHostVariableResolverProviderService2 extends Disposable {
  constructor(extensionService, workspaceService, editorService, configurationService, editorTabs) {
    super();
    this.extensionService = extensionService;
    this.workspaceService = workspaceService;
    this.editorService = editorService;
    this.configurationService = configurationService;
    this.editorTabs = editorTabs;
    this._resolver = new Lazy(async () => {
      const configProvider = await this.configurationService.getConfigProvider();
      const folders = await this.workspaceService.getWorkspaceFolders2() || [];
      const dynamic = { folders };
      this._register(this.workspaceService.onDidChangeWorkspace(async (e) => {
        dynamic.folders = await this.workspaceService.getWorkspaceFolders2() || [];
      }));
      return new ExtHostVariableResolverService(
        this.extensionService,
        this.workspaceService,
        this.editorService,
        this.editorTabs,
        configProvider,
        dynamic,
        this.homeDir()
      );
    });
  }
  getResolver() {
    return this._resolver.value;
  }
  homeDir() {
    return void 0;
  }
};
ExtHostVariableResolverProviderService = __decorate([
  __param(0, IExtHostExtensionService),
  __param(1, IExtHostWorkspace),
  __param(2, IExtHostDocumentsAndEditors),
  __param(3, IExtHostConfiguration),
  __param(4, IExtHostEditorTabs)
], ExtHostVariableResolverProviderService);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDebugService.js
var IExtHostDebugService = createDecorator("IExtHostDebugService");
var ExtHostDebugServiceBase = class ExtHostDebugServiceBase2 {
  get onDidStartDebugSession() {
    return this._onDidStartDebugSession.event;
  }
  get onDidTerminateDebugSession() {
    return this._onDidTerminateDebugSession.event;
  }
  get onDidChangeActiveDebugSession() {
    return this._onDidChangeActiveDebugSession.event;
  }
  get activeDebugSession() {
    return this._activeDebugSession;
  }
  get onDidReceiveDebugSessionCustomEvent() {
    return this._onDidReceiveDebugSessionCustomEvent.event;
  }
  get activeDebugConsole() {
    return this._activeDebugConsole.value;
  }
  constructor(extHostRpcService, _workspaceService, _extensionService2, _configurationService, _editorTabs, _variableResolver) {
    this._workspaceService = _workspaceService;
    this._extensionService = _extensionService2;
    this._configurationService = _configurationService;
    this._editorTabs = _editorTabs;
    this._variableResolver = _variableResolver;
    this._debugSessions = /* @__PURE__ */ new Map();
    this._configProviderHandleCounter = 0;
    this._configProviders = [];
    this._adapterFactoryHandleCounter = 0;
    this._adapterFactories = [];
    this._trackerFactoryHandleCounter = 0;
    this._trackerFactories = [];
    this._debugAdapters = /* @__PURE__ */ new Map();
    this._debugAdaptersTrackers = /* @__PURE__ */ new Map();
    this._onDidStartDebugSession = new Emitter();
    this._onDidTerminateDebugSession = new Emitter();
    this._onDidChangeActiveDebugSession = new Emitter();
    this._onDidReceiveDebugSessionCustomEvent = new Emitter();
    this._debugServiceProxy = extHostRpcService.getProxy(MainContext.MainThreadDebugService);
    this._onDidChangeBreakpoints = new Emitter();
    this._onDidChangeStackFrameFocus = new Emitter();
    this._activeDebugConsole = new ExtHostDebugConsole(this._debugServiceProxy);
    this._breakpoints = /* @__PURE__ */ new Map();
    this._extensionService.getExtensionRegistry().then((extensionRegistry) => {
      extensionRegistry.onDidChange((_) => {
        this.registerAllDebugTypes(extensionRegistry);
      });
      this.registerAllDebugTypes(extensionRegistry);
    });
  }
  asDebugSourceUri(src, session) {
    const source = src;
    if (typeof source.sourceReference === "number" && source.sourceReference > 0) {
      let debug = `debug:${encodeURIComponent(source.path || "")}`;
      let sep2 = "?";
      if (session) {
        debug += `${sep2}session=${encodeURIComponent(session.id)}`;
        sep2 = "&";
      }
      debug += `${sep2}ref=${source.sourceReference}`;
      return URI.parse(debug);
    } else if (source.path) {
      return URI.file(source.path);
    } else {
      throw new Error(`cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.`);
    }
  }
  registerAllDebugTypes(extensionRegistry) {
    const debugTypes = [];
    for (const ed of extensionRegistry.getAllExtensionDescriptions()) {
      if (ed.contributes) {
        const debuggers = ed.contributes["debuggers"];
        if (debuggers && debuggers.length > 0) {
          for (const dbg of debuggers) {
            if (isDebuggerMainContribution(dbg)) {
              debugTypes.push(dbg.type);
            }
          }
        }
      }
    }
    this._debugServiceProxy.$registerDebugTypes(debugTypes);
  }
  get stackFrameFocus() {
    return this._stackFrameFocus;
  }
  get onDidChangeStackFrameFocus() {
    return this._onDidChangeStackFrameFocus.event;
  }
  get onDidChangeBreakpoints() {
    return this._onDidChangeBreakpoints.event;
  }
  get breakpoints() {
    const result = [];
    this._breakpoints.forEach((bp) => result.push(bp));
    return result;
  }
  addBreakpoints(breakpoints0) {
    const breakpoints = breakpoints0.filter((bp) => {
      const id = bp.id;
      if (!this._breakpoints.has(id)) {
        this._breakpoints.set(id, bp);
        return true;
      }
      return false;
    });
    this.fireBreakpointChanges(breakpoints, [], []);
    const dtos = [];
    const map = /* @__PURE__ */ new Map();
    for (const bp of breakpoints) {
      if (bp instanceof SourceBreakpoint) {
        let dto = map.get(bp.location.uri.toString());
        if (!dto) {
          dto = {
            type: "sourceMulti",
            uri: bp.location.uri,
            lines: []
          };
          map.set(bp.location.uri.toString(), dto);
          dtos.push(dto);
        }
        dto.lines.push({
          id: bp.id,
          enabled: bp.enabled,
          condition: bp.condition,
          hitCondition: bp.hitCondition,
          logMessage: bp.logMessage,
          line: bp.location.range.start.line,
          character: bp.location.range.start.character
        });
      } else if (bp instanceof FunctionBreakpoint) {
        dtos.push({
          type: "function",
          id: bp.id,
          enabled: bp.enabled,
          hitCondition: bp.hitCondition,
          logMessage: bp.logMessage,
          condition: bp.condition,
          functionName: bp.functionName
        });
      }
    }
    return this._debugServiceProxy.$registerBreakpoints(dtos);
  }
  removeBreakpoints(breakpoints0) {
    const breakpoints = breakpoints0.filter((b) => this._breakpoints.delete(b.id));
    this.fireBreakpointChanges([], breakpoints, []);
    const ids = breakpoints.filter((bp) => bp instanceof SourceBreakpoint).map((bp) => bp.id);
    const fids = breakpoints.filter((bp) => bp instanceof FunctionBreakpoint).map((bp) => bp.id);
    const dids = breakpoints.filter((bp) => bp instanceof DataBreakpoint).map((bp) => bp.id);
    return this._debugServiceProxy.$unregisterBreakpoints(ids, fids, dids);
  }
  startDebugging(folder, nameOrConfig, options) {
    var _a30, _b, _c;
    return this._debugServiceProxy.$startDebugging(folder ? folder.uri : void 0, nameOrConfig, {
      parentSessionID: options.parentSession ? options.parentSession.id : void 0,
      lifecycleManagedByParent: options.lifecycleManagedByParent,
      repl: options.consoleMode === DebugConsoleMode.MergeWithParent ? "mergeWithParent" : "separate",
      noDebug: options.noDebug,
      compact: options.compact,
      suppressSaveBeforeStart: options.suppressSaveBeforeStart,
      suppressDebugStatusbar: options.suppressDebugStatusbar ?? ((_a30 = options.debugUI) == null ? void 0 : _a30.simple),
      suppressDebugToolbar: options.suppressDebugToolbar ?? ((_b = options.debugUI) == null ? void 0 : _b.simple),
      suppressDebugView: options.suppressDebugView ?? ((_c = options.debugUI) == null ? void 0 : _c.simple)
    });
  }
  stopDebugging(session) {
    return this._debugServiceProxy.$stopDebugging(session ? session.id : void 0);
  }
  registerDebugConfigurationProvider(type, provider, trigger) {
    if (!provider) {
      return new Disposable2(() => {
      });
    }
    const handle = this._configProviderHandleCounter++;
    this._configProviders.push({ type, handle, provider });
    this._debugServiceProxy.$registerDebugConfigurationProvider(type, trigger, !!provider.provideDebugConfigurations, !!provider.resolveDebugConfiguration, !!provider.resolveDebugConfigurationWithSubstitutedVariables, handle);
    return new Disposable2(() => {
      this._configProviders = this._configProviders.filter((p) => p.provider !== provider);
      this._debugServiceProxy.$unregisterDebugConfigurationProvider(handle);
    });
  }
  registerDebugAdapterDescriptorFactory(extension, type, factory) {
    if (!factory) {
      return new Disposable2(() => {
      });
    }
    if (!this.definesDebugType(extension, type)) {
      throw new Error(`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${type}' debugger.`);
    }
    if (this.getAdapterDescriptorFactoryByType(type)) {
      throw new Error(`a DebugAdapterDescriptorFactory can only be registered once per a type.`);
    }
    const handle = this._adapterFactoryHandleCounter++;
    this._adapterFactories.push({ type, handle, factory });
    this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(type, handle);
    return new Disposable2(() => {
      this._adapterFactories = this._adapterFactories.filter((p) => p.factory !== factory);
      this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(handle);
    });
  }
  registerDebugAdapterTrackerFactory(type, factory) {
    if (!factory) {
      return new Disposable2(() => {
      });
    }
    const handle = this._trackerFactoryHandleCounter++;
    this._trackerFactories.push({ type, handle, factory });
    return new Disposable2(() => {
      this._trackerFactories = this._trackerFactories.filter((p) => p.factory !== factory);
    });
  }
  async $runInTerminal(args, sessionId) {
    return Promise.resolve(void 0);
  }
  async $substituteVariables(folderUri, config) {
    let ws;
    const folder = await this.getFolder(folderUri);
    if (folder) {
      ws = {
        uri: folder.uri,
        name: folder.name,
        index: folder.index,
        toResource: () => {
          throw new Error("Not implemented");
        }
      };
    }
    const variableResolver = await this._variableResolver.getResolver();
    return variableResolver.resolveAnyAsync(ws, config);
  }
  createDebugAdapter(adapter, session) {
    if (adapter.type === "implementation") {
      return new DirectDebugAdapter(adapter.implementation);
    }
    return void 0;
  }
  createSignService() {
    return void 0;
  }
  async $startDASession(debugAdapterHandle, sessionDto) {
    const mythis = this;
    const session = await this.getSession(sessionDto);
    return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(session.type), session).then((daDescriptor) => {
      if (!daDescriptor) {
        throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}' (extension might have failed to activate)`);
      }
      const adapterDescriptor = this.convertToDto(daDescriptor);
      const da = this.createDebugAdapter(adapterDescriptor, session);
      if (!da) {
        throw new Error(`Couldn't create a debug adapter for type '${session.type}'.`);
      }
      const debugAdapter = da;
      this._debugAdapters.set(debugAdapterHandle, debugAdapter);
      return this.getDebugAdapterTrackers(session).then((tracker) => {
        if (tracker) {
          this._debugAdaptersTrackers.set(debugAdapterHandle, tracker);
        }
        debugAdapter.onMessage(async (message) => {
          if (message.type === "request" && message.command === "handshake") {
            const request = message;
            const response = {
              type: "response",
              seq: 0,
              command: request.command,
              request_seq: request.seq,
              success: true
            };
            if (!this._signService) {
              this._signService = this.createSignService();
            }
            try {
              if (this._signService) {
                const signature = await this._signService.sign(request.arguments.value);
                response.body = {
                  signature
                };
                debugAdapter.sendResponse(response);
              } else {
                throw new Error("no signer");
              }
            } catch (e) {
              response.success = false;
              response.message = e.message;
              debugAdapter.sendResponse(response);
            }
          } else {
            if (tracker && tracker.onDidSendMessage) {
              tracker.onDidSendMessage(message);
            }
            message = convertToVSCPaths(message, true);
            mythis._debugServiceProxy.$acceptDAMessage(debugAdapterHandle, message);
          }
        });
        debugAdapter.onError((err) => {
          if (tracker && tracker.onError) {
            tracker.onError(err);
          }
          this._debugServiceProxy.$acceptDAError(debugAdapterHandle, err.name, err.message, err.stack);
        });
        debugAdapter.onExit((code) => {
          if (tracker && tracker.onExit) {
            tracker.onExit(code ?? void 0, void 0);
          }
          this._debugServiceProxy.$acceptDAExit(debugAdapterHandle, code ?? void 0, void 0);
        });
        if (tracker && tracker.onWillStartSession) {
          tracker.onWillStartSession();
        }
        return debugAdapter.startSession();
      });
    });
  }
  $sendDAMessage(debugAdapterHandle, message) {
    message = convertToDAPaths(message, false);
    const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);
    if (tracker && tracker.onWillReceiveMessage) {
      tracker.onWillReceiveMessage(message);
    }
    const da = this._debugAdapters.get(debugAdapterHandle);
    da == null ? void 0 : da.sendMessage(message);
  }
  $stopDASession(debugAdapterHandle) {
    const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);
    this._debugAdaptersTrackers.delete(debugAdapterHandle);
    if (tracker && tracker.onWillStopSession) {
      tracker.onWillStopSession();
    }
    const da = this._debugAdapters.get(debugAdapterHandle);
    this._debugAdapters.delete(debugAdapterHandle);
    if (da) {
      return da.stopSession();
    } else {
      return Promise.resolve(void 0);
    }
  }
  $acceptBreakpointsDelta(delta3) {
    const a = [];
    const r = [];
    const c = [];
    if (delta3.added) {
      for (const bpd of delta3.added) {
        const id = bpd.id;
        if (id && !this._breakpoints.has(id)) {
          let bp;
          if (bpd.type === "function") {
            bp = new FunctionBreakpoint(
              bpd.functionName,
              bpd.enabled,
              bpd.condition,
              bpd.hitCondition,
              bpd.logMessage
            );
          } else if (bpd.type === "data") {
            bp = new DataBreakpoint(
              bpd.label,
              bpd.dataId,
              bpd.canPersist,
              bpd.enabled,
              bpd.hitCondition,
              bpd.condition,
              bpd.logMessage
            );
          } else {
            const uri = URI.revive(bpd.uri);
            bp = new SourceBreakpoint(new Location(uri, new Position2(bpd.line, bpd.character)), bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage);
          }
          setBreakpointId(bp, id);
          this._breakpoints.set(id, bp);
          a.push(bp);
        }
      }
    }
    if (delta3.removed) {
      for (const id of delta3.removed) {
        const bp = this._breakpoints.get(id);
        if (bp) {
          this._breakpoints.delete(id);
          r.push(bp);
        }
      }
    }
    if (delta3.changed) {
      for (const bpd of delta3.changed) {
        if (bpd.id) {
          const bp = this._breakpoints.get(bpd.id);
          if (bp) {
            if (bp instanceof FunctionBreakpoint && bpd.type === "function") {
              const fbp = bp;
              fbp.enabled = bpd.enabled;
              fbp.condition = bpd.condition;
              fbp.hitCondition = bpd.hitCondition;
              fbp.logMessage = bpd.logMessage;
              fbp.functionName = bpd.functionName;
            } else if (bp instanceof SourceBreakpoint && bpd.type === "source") {
              const sbp = bp;
              sbp.enabled = bpd.enabled;
              sbp.condition = bpd.condition;
              sbp.hitCondition = bpd.hitCondition;
              sbp.logMessage = bpd.logMessage;
              sbp.location = new Location(URI.revive(bpd.uri), new Position2(bpd.line, bpd.character));
            }
            c.push(bp);
          }
        }
      }
    }
    this.fireBreakpointChanges(a, r, c);
  }
  async $acceptStackFrameFocus(focusDto) {
    let focus;
    const session = focusDto.sessionId ? await this.getSession(focusDto.sessionId) : void 0;
    if (!session) {
      throw new Error("no DebugSession found for debug focus context");
    }
    if (focusDto.kind === "thread") {
      focus = new ThreadFocus(session, focusDto.threadId);
    } else {
      focus = new StackFrameFocus(session, focusDto.threadId, focusDto.frameId);
    }
    this._stackFrameFocus = focus;
    this._onDidChangeStackFrameFocus.fire(this._stackFrameFocus);
  }
  $provideDebugConfigurations(configProviderHandle, folderUri, token) {
    return asPromise(async () => {
      const provider = this.getConfigProviderByHandle(configProviderHandle);
      if (!provider) {
        throw new Error("no DebugConfigurationProvider found");
      }
      if (!provider.provideDebugConfigurations) {
        throw new Error("DebugConfigurationProvider has no method provideDebugConfigurations");
      }
      const folder = await this.getFolder(folderUri);
      return provider.provideDebugConfigurations(folder, token);
    }).then((debugConfigurations) => {
      if (!debugConfigurations) {
        throw new Error("nothing returned from DebugConfigurationProvider.provideDebugConfigurations");
      }
      return debugConfigurations;
    });
  }
  $resolveDebugConfiguration(configProviderHandle, folderUri, debugConfiguration, token) {
    return asPromise(async () => {
      const provider = this.getConfigProviderByHandle(configProviderHandle);
      if (!provider) {
        throw new Error("no DebugConfigurationProvider found");
      }
      if (!provider.resolveDebugConfiguration) {
        throw new Error("DebugConfigurationProvider has no method resolveDebugConfiguration");
      }
      const folder = await this.getFolder(folderUri);
      return provider.resolveDebugConfiguration(folder, debugConfiguration, token);
    });
  }
  $resolveDebugConfigurationWithSubstitutedVariables(configProviderHandle, folderUri, debugConfiguration, token) {
    return asPromise(async () => {
      const provider = this.getConfigProviderByHandle(configProviderHandle);
      if (!provider) {
        throw new Error("no DebugConfigurationProvider found");
      }
      if (!provider.resolveDebugConfigurationWithSubstitutedVariables) {
        throw new Error("DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables");
      }
      const folder = await this.getFolder(folderUri);
      return provider.resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfiguration, token);
    });
  }
  async $provideDebugAdapter(adapterFactoryHandle, sessionDto) {
    const adapterDescriptorFactory = this.getAdapterDescriptorFactoryByHandle(adapterFactoryHandle);
    if (!adapterDescriptorFactory) {
      return Promise.reject(new Error("no adapter descriptor factory found for handle"));
    }
    const session = await this.getSession(sessionDto);
    return this.getAdapterDescriptor(adapterDescriptorFactory, session).then((adapterDescriptor) => {
      if (!adapterDescriptor) {
        throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}'`);
      }
      return this.convertToDto(adapterDescriptor);
    });
  }
  async $acceptDebugSessionStarted(sessionDto) {
    const session = await this.getSession(sessionDto);
    this._onDidStartDebugSession.fire(session);
  }
  async $acceptDebugSessionTerminated(sessionDto) {
    const session = await this.getSession(sessionDto);
    if (session) {
      this._onDidTerminateDebugSession.fire(session);
      this._debugSessions.delete(session.id);
    }
  }
  async $acceptDebugSessionActiveChanged(sessionDto) {
    this._activeDebugSession = sessionDto ? await this.getSession(sessionDto) : void 0;
    this._onDidChangeActiveDebugSession.fire(this._activeDebugSession);
  }
  async $acceptDebugSessionNameChanged(sessionDto, name) {
    const session = await this.getSession(sessionDto);
    session == null ? void 0 : session._acceptNameChanged(name);
  }
  async $acceptDebugSessionCustomEvent(sessionDto, event) {
    const session = await this.getSession(sessionDto);
    const ee = {
      session,
      event: event.event,
      body: event.body
    };
    this._onDidReceiveDebugSessionCustomEvent.fire(ee);
  }
  convertToDto(x) {
    if (x instanceof DebugAdapterExecutable) {
      return {
        type: "executable",
        command: x.command,
        args: x.args,
        options: x.options
      };
    } else if (x instanceof DebugAdapterServer) {
      return {
        type: "server",
        port: x.port,
        host: x.host
      };
    } else if (x instanceof DebugAdapterNamedPipeServer) {
      return {
        type: "pipeServer",
        path: x.path
      };
    } else if (x instanceof DebugAdapterInlineImplementation) {
      return {
        type: "implementation",
        implementation: x.implementation
      };
    } else {
      throw new Error("convertToDto unexpected type");
    }
  }
  getAdapterDescriptorFactoryByType(type) {
    const results = this._adapterFactories.filter((p) => p.type === type);
    if (results.length > 0) {
      return results[0].factory;
    }
    return void 0;
  }
  getAdapterDescriptorFactoryByHandle(handle) {
    const results = this._adapterFactories.filter((p) => p.handle === handle);
    if (results.length > 0) {
      return results[0].factory;
    }
    return void 0;
  }
  getConfigProviderByHandle(handle) {
    const results = this._configProviders.filter((p) => p.handle === handle);
    if (results.length > 0) {
      return results[0].provider;
    }
    return void 0;
  }
  definesDebugType(ed, type) {
    if (ed.contributes) {
      const debuggers = ed.contributes["debuggers"];
      if (debuggers && debuggers.length > 0) {
        for (const dbg of debuggers) {
          if (dbg.label && dbg.type) {
            if (dbg.type === type) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  getDebugAdapterTrackers(session) {
    const config = session.configuration;
    const type = config.type;
    const promises = this._trackerFactories.filter((tuple) => tuple.type === type || tuple.type === "*").map(
      (tuple) => asPromise(() => tuple.factory.createDebugAdapterTracker(session)).then((p) => p, (err) => null)
    );
    return Promise.race([
      Promise.all(promises).then((result) => {
        const trackers = result.filter((t) => !!t);
        if (trackers.length > 0) {
          return new MultiTracker(trackers);
        }
        return void 0;
      }),
      new Promise((resolve) => setTimeout(() => resolve(void 0), 1e3))
    ]).catch((err) => {
      return void 0;
    });
  }
  async getAdapterDescriptor(adapterDescriptorFactory, session) {
    const serverPort = session.configuration.debugServer;
    if (typeof serverPort === "number") {
      return Promise.resolve(new DebugAdapterServer(serverPort));
    }
    if (adapterDescriptorFactory) {
      const extensionRegistry2 = await this._extensionService.getExtensionRegistry();
      return asPromise(() => adapterDescriptorFactory.createDebugAdapterDescriptor(session, this.daExecutableFromPackage(session, extensionRegistry2))).then((daDescriptor) => {
        if (daDescriptor) {
          return daDescriptor;
        }
        return void 0;
      });
    }
    const extensionRegistry = await this._extensionService.getExtensionRegistry();
    return Promise.resolve(this.daExecutableFromPackage(session, extensionRegistry));
  }
  daExecutableFromPackage(session, extensionRegistry) {
    return void 0;
  }
  fireBreakpointChanges(added, removed, changed) {
    if (added.length > 0 || removed.length > 0 || changed.length > 0) {
      this._onDidChangeBreakpoints.fire(Object.freeze({
        added,
        removed,
        changed
      }));
    }
  }
  async getSession(dto) {
    if (dto) {
      if (typeof dto === "string") {
        const ds = this._debugSessions.get(dto);
        if (ds) {
          return ds;
        }
      } else {
        let ds = this._debugSessions.get(dto.id);
        if (!ds) {
          const folder = await this.getFolder(dto.folderUri);
          const parent = dto.parent ? this._debugSessions.get(dto.parent) : void 0;
          ds = new ExtHostDebugSession(
            this._debugServiceProxy,
            dto.id,
            dto.type,
            dto.name,
            folder,
            dto.configuration,
            parent
          );
          this._debugSessions.set(ds.id, ds);
          this._debugServiceProxy.$sessionCached(ds.id);
        }
        return ds;
      }
    }
    throw new Error("cannot find session");
  }
  getFolder(_folderUri) {
    if (_folderUri) {
      const folderURI = URI.revive(_folderUri);
      return this._workspaceService.resolveWorkspaceFolder(folderURI);
    }
    return Promise.resolve(void 0);
  }
};
ExtHostDebugServiceBase = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostWorkspace),
  __param(2, IExtHostExtensionService),
  __param(3, IExtHostConfiguration),
  __param(4, IExtHostEditorTabs),
  __param(5, IExtHostVariableResolverProvider)
], ExtHostDebugServiceBase);
var ExtHostDebugSession = class {
  constructor(_debugServiceProxy, _id, _type, _name, _workspaceFolder, _configuration, _parentSession) {
    this._debugServiceProxy = _debugServiceProxy;
    this._id = _id;
    this._type = _type;
    this._name = _name;
    this._workspaceFolder = _workspaceFolder;
    this._configuration = _configuration;
    this._parentSession = _parentSession;
  }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this._debugServiceProxy.$setDebugSessionName(this._id, name);
  }
  get parentSession() {
    return this._parentSession;
  }
  _acceptNameChanged(name) {
    this._name = name;
  }
  get workspaceFolder() {
    return this._workspaceFolder;
  }
  get configuration() {
    return this._configuration;
  }
  customRequest(command, args) {
    return this._debugServiceProxy.$customDebugAdapterRequest(this._id, command, args);
  }
  getDebugProtocolBreakpoint(breakpoint) {
    return this._debugServiceProxy.$getDebugProtocolBreakpoint(this._id, breakpoint.id);
  }
};
var ExtHostDebugConsole = class {
  constructor(proxy) {
    this.value = Object.freeze({
      append(value) {
        proxy.$appendDebugConsole(value);
      },
      appendLine(value) {
        this.append(value + "\n");
      }
    });
  }
};
var MultiTracker = class {
  constructor(trackers) {
    this.trackers = trackers;
  }
  onWillStartSession() {
    this.trackers.forEach((t) => t.onWillStartSession ? t.onWillStartSession() : void 0);
  }
  onWillReceiveMessage(message) {
    this.trackers.forEach((t) => t.onWillReceiveMessage ? t.onWillReceiveMessage(message) : void 0);
  }
  onDidSendMessage(message) {
    this.trackers.forEach((t) => t.onDidSendMessage ? t.onDidSendMessage(message) : void 0);
  }
  onWillStopSession() {
    this.trackers.forEach((t) => t.onWillStopSession ? t.onWillStopSession() : void 0);
  }
  onError(error) {
    this.trackers.forEach((t) => t.onError ? t.onError(error) : void 0);
  }
  onExit(code, signal) {
    this.trackers.forEach((t) => t.onExit ? t.onExit(code, signal) : void 0);
  }
};
var DirectDebugAdapter = class extends AbstractDebugAdapter {
  constructor(implementation) {
    super();
    this.implementation = implementation;
    implementation.onDidSendMessage((message) => {
      this.acceptMessage(message);
    });
  }
  startSession() {
    return Promise.resolve(void 0);
  }
  sendMessage(message) {
    this.implementation.handleMessage(message);
  }
  stopSession() {
    this.implementation.dispose();
    return Promise.resolve(void 0);
  }
};
var WorkerExtHostDebugService = class WorkerExtHostDebugService2 extends ExtHostDebugServiceBase {
  constructor(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver) {
    super(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver);
  }
};
WorkerExtHostDebugService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostWorkspace),
  __param(2, IExtHostExtensionService),
  __param(3, IExtHostConfiguration),
  __param(4, IExtHostEditorTabs),
  __param(5, IExtHostVariableResolverProvider)
], WorkerExtHostDebugService);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSearch.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/services/search/common/fileSearchManager.js
init_path();
init_cancellation();
init_errorMessage();
init_resources();
init_stopwatch();
var FileSearchEngine = class {
  constructor(config, provider, sessionToken) {
    this.config = config;
    this.provider = provider;
    this.sessionToken = sessionToken;
    this.isLimitHit = false;
    this.resultCount = 0;
    this.isCanceled = false;
    this.filePattern = config.filePattern;
    this.includePattern = config.includePattern && parse2(config.includePattern);
    this.maxResults = config.maxResults || void 0;
    this.exists = config.exists;
    this.activeCancellationTokens = /* @__PURE__ */ new Set();
    this.globalExcludePattern = config.excludePattern && parse2(config.excludePattern);
  }
  cancel() {
    this.isCanceled = true;
    this.activeCancellationTokens.forEach((t) => t.cancel());
    this.activeCancellationTokens = /* @__PURE__ */ new Set();
  }
  search(_onResult) {
    const folderQueries = this.config.folderQueries || [];
    return new Promise((resolve, reject) => {
      const onResult = (match) => {
        this.resultCount++;
        _onResult(match);
      };
      if (this.isCanceled) {
        return resolve({ limitHit: this.isLimitHit });
      }
      if (this.config.extraFileResources) {
        this.config.extraFileResources.forEach((extraFile) => {
          const extraFileStr = extraFile.toString();
          const basename3 = basename(extraFileStr);
          if (this.globalExcludePattern && this.globalExcludePattern(extraFileStr, basename3)) {
            return;
          }
          this.matchFile(onResult, { base: extraFile, basename: basename3 });
        });
      }
      Promise.all(folderQueries.map((fq) => {
        return this.searchInFolder(fq, onResult);
      })).then((stats) => {
        resolve({
          limitHit: this.isLimitHit,
          stats: stats[0] || void 0
        });
      }, (err) => {
        reject(new Error(toErrorMessage(err)));
      });
    });
  }
  async searchInFolder(fq, onResult) {
    const cancellation = new CancellationTokenSource();
    const options = this.getSearchOptionsForFolder(fq);
    const tree = this.initDirectoryTree();
    const queryTester = new QueryGlobTester(this.config, fq);
    const noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();
    let providerSW;
    try {
      this.activeCancellationTokens.add(cancellation);
      providerSW = StopWatch.create();
      const results = await this.provider.provideFileSearchResults({
        pattern: this.config.filePattern || ""
      }, options, cancellation.token);
      const providerTime = providerSW.elapsed();
      const postProcessSW = StopWatch.create();
      if (this.isCanceled && !this.isLimitHit) {
        return null;
      }
      if (results) {
        results.forEach((result) => {
          const relativePath2 = posix.relative(fq.folder.path, result.path);
          if (noSiblingsClauses) {
            const basename3 = basename(result.path);
            this.matchFile(onResult, { base: fq.folder, relativePath: relativePath2, basename: basename3 });
            return;
          }
          this.addDirectoryEntries(tree, fq.folder, relativePath2, onResult);
        });
      }
      if (this.isCanceled && !this.isLimitHit) {
        return null;
      }
      this.matchDirectoryTree(tree, queryTester, onResult);
      return {
        providerTime,
        postProcessTime: postProcessSW.elapsed()
      };
    } finally {
      cancellation.dispose();
      this.activeCancellationTokens.delete(cancellation);
    }
  }
  getSearchOptionsForFolder(fq) {
    const includes2 = resolvePatternsForProvider(this.config.includePattern, fq.includePattern);
    const excludes = resolvePatternsForProvider(this.config.excludePattern, fq.excludePattern);
    return {
      folder: fq.folder,
      excludes,
      includes: includes2,
      useIgnoreFiles: !fq.disregardIgnoreFiles,
      useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,
      useParentIgnoreFiles: !fq.disregardParentIgnoreFiles,
      followSymlinks: !fq.ignoreSymlinks,
      maxResults: this.config.maxResults,
      session: this.sessionToken
    };
  }
  initDirectoryTree() {
    const tree = {
      rootEntries: [],
      pathToEntries: /* @__PURE__ */ Object.create(null)
    };
    tree.pathToEntries["."] = tree.rootEntries;
    return tree;
  }
  addDirectoryEntries({ pathToEntries }, base, relativeFile, onResult) {
    if (relativeFile === this.filePattern) {
      const basename3 = basename(this.filePattern);
      this.matchFile(onResult, { base, relativePath: this.filePattern, basename: basename3 });
    }
    function add(relativePath2) {
      const basename3 = basename(relativePath2);
      const dirname3 = dirname(relativePath2);
      let entries = pathToEntries[dirname3];
      if (!entries) {
        entries = pathToEntries[dirname3] = [];
        add(dirname3);
      }
      entries.push({
        base,
        relativePath: relativePath2,
        basename: basename3
      });
    }
    add(relativeFile);
  }
  matchDirectoryTree({ rootEntries, pathToEntries }, queryTester, onResult) {
    const self2 = this;
    const filePattern = this.filePattern;
    function matchDirectory(entries) {
      const hasSibling = hasSiblingFn(() => entries.map((entry) => entry.basename));
      for (let i = 0, n2 = entries.length; i < n2; i++) {
        const entry = entries[i];
        const { relativePath: relativePath2, basename: basename3 } = entry;
        if (queryTester.matchesExcludesSync(relativePath2, basename3, filePattern !== basename3 ? hasSibling : void 0)) {
          continue;
        }
        const sub = pathToEntries[relativePath2];
        if (sub) {
          matchDirectory(sub);
        } else {
          if (relativePath2 === filePattern) {
            continue;
          }
          self2.matchFile(onResult, entry);
        }
        if (self2.isLimitHit) {
          break;
        }
      }
    }
    matchDirectory(rootEntries);
  }
  matchFile(onResult, candidate) {
    if (!this.includePattern || candidate.relativePath && this.includePattern(candidate.relativePath, candidate.basename)) {
      if (this.exists || this.maxResults && this.resultCount >= this.maxResults) {
        this.isLimitHit = true;
        this.cancel();
      }
      if (!this.isLimitHit) {
        onResult(candidate);
      }
    }
  }
};
var _FileSearchManager = class _FileSearchManager {
  constructor() {
    this.sessions = /* @__PURE__ */ new Map();
  }
  fileSearch(config, provider, onBatch, token) {
    const sessionTokenSource = this.getSessionTokenSource(config.cacheKey);
    const engine = new FileSearchEngine(config, provider, sessionTokenSource && sessionTokenSource.token);
    let resultCount = 0;
    const onInternalResult = (batch) => {
      resultCount += batch.length;
      onBatch(batch.map((m) => this.rawMatchToSearchItem(m)));
    };
    return this.doSearch(engine, _FileSearchManager.BATCH_SIZE, onInternalResult, token).then((result) => {
      return {
        limitHit: result.limitHit,
        stats: {
          fromCache: false,
          type: "fileSearchProvider",
          resultCount,
          detailStats: result.stats
        }
      };
    });
  }
  clearCache(cacheKey) {
    const sessionTokenSource = this.getSessionTokenSource(cacheKey);
    sessionTokenSource == null ? void 0 : sessionTokenSource.cancel();
  }
  getSessionTokenSource(cacheKey) {
    if (!cacheKey) {
      return void 0;
    }
    if (!this.sessions.has(cacheKey)) {
      this.sessions.set(cacheKey, new CancellationTokenSource());
    }
    return this.sessions.get(cacheKey);
  }
  rawMatchToSearchItem(match) {
    if (match.relativePath) {
      return {
        resource: joinPath(match.base, match.relativePath)
      };
    } else {
      return {
        resource: match.base
      };
    }
  }
  doSearch(engine, batchSize, onResultBatch, token) {
    token.onCancellationRequested(() => {
      engine.cancel();
    });
    const _onResult = (match) => {
      if (match) {
        batch.push(match);
        if (batchSize > 0 && batch.length >= batchSize) {
          onResultBatch(batch);
          batch = [];
        }
      }
    };
    let batch = [];
    return engine.search(_onResult).then((result) => {
      if (batch.length) {
        onResultBatch(batch);
      }
      return result;
    }, (error) => {
      if (batch.length) {
        onResultBatch(batch);
      }
      return Promise.reject(error);
    });
  }
};
_FileSearchManager.BATCH_SIZE = 512;
var FileSearchManager = _FileSearchManager;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSearch.js
init_log();
init_uri();

// node_modules/vscode/vscode/src/vs/workbench/services/search/common/textSearchManager.js
init_arrays();
init_async();
init_cancellation();
init_errorMessage();
init_network();
init_path();
init_resources();
init_uri();
var TextSearchManager = class {
  constructor(query, provider, fileUtils, processType) {
    this.query = query;
    this.provider = provider;
    this.fileUtils = fileUtils;
    this.processType = processType;
    this.collector = null;
    this.isLimitHit = false;
    this.resultCount = 0;
  }
  search(onProgress, token) {
    const folderQueries = this.query.folderQueries || [];
    const tokenSource = new CancellationTokenSource();
    token.onCancellationRequested(() => tokenSource.cancel());
    return new Promise((resolve, reject) => {
      this.collector = new TextSearchResultsCollector(onProgress);
      let isCanceled = false;
      const onResult = (result, folderIdx) => {
        if (isCanceled) {
          return;
        }
        if (!this.isLimitHit) {
          const resultSize = this.resultSize(result);
          if (extensionResultIsMatch(result) && typeof this.query.maxResults === "number" && this.resultCount + resultSize > this.query.maxResults) {
            this.isLimitHit = true;
            isCanceled = true;
            tokenSource.cancel();
            result = this.trimResultToSize(result, this.query.maxResults - this.resultCount);
          }
          const newResultSize = this.resultSize(result);
          this.resultCount += newResultSize;
          if (newResultSize > 0 || !extensionResultIsMatch(result)) {
            this.collector.add(result, folderIdx);
          }
        }
      };
      Promise.all(folderQueries.map((fq, i) => {
        return this.searchInFolder(fq, (r) => onResult(r, i), tokenSource.token);
      })).then((results) => {
        tokenSource.dispose();
        this.collector.flush();
        const someFolderHitLImit = results.some((result) => !!result && !!result.limitHit);
        resolve({
          limitHit: this.isLimitHit || someFolderHitLImit,
          messages: flatten(results.map((result) => {
            if (!(result == null ? void 0 : result.message)) {
              return [];
            }
            if (Array.isArray(result.message)) {
              return result.message;
            } else {
              return [result.message];
            }
          })),
          stats: {
            type: this.processType
          }
        });
      }, (err) => {
        tokenSource.dispose();
        const errMsg = toErrorMessage(err);
        reject(new Error(errMsg));
      });
    });
  }
  resultSize(result) {
    if (extensionResultIsMatch(result)) {
      return Array.isArray(result.ranges) ? result.ranges.length : 1;
    } else {
      return 0;
    }
  }
  trimResultToSize(result, size) {
    const rangesArr = Array.isArray(result.ranges) ? result.ranges : [result.ranges];
    const matchesArr = Array.isArray(result.preview.matches) ? result.preview.matches : [result.preview.matches];
    return {
      ranges: rangesArr.slice(0, size),
      preview: {
        matches: matchesArr.slice(0, size),
        text: result.preview.text
      },
      uri: result.uri
    };
  }
  async searchInFolder(folderQuery, onResult, token) {
    const queryTester = new QueryGlobTester(this.query, folderQuery);
    const testingPs = [];
    const progress = {
      report: (result2) => {
        if (!this.validateProviderResult(result2)) {
          return;
        }
        const hasSibling = folderQuery.folder.scheme === Schemas.file ? hasSiblingPromiseFn(() => {
          return this.fileUtils.readdir(dirname2(result2.uri));
        }) : void 0;
        const relativePath2 = relativePath(folderQuery.folder, result2.uri);
        if (relativePath2) {
          const included = queryTester.includedInQuery(relativePath2, basename(relativePath2), hasSibling);
          if (isThenable(included)) {
            testingPs.push(included.then((isIncluded) => {
              if (isIncluded) {
                onResult(result2);
              }
            }));
          } else if (included) {
            onResult(result2);
          }
        }
      }
    };
    const searchOptions = this.getSearchOptionsForFolder(folderQuery);
    const result = await this.provider.provideTextSearchResults(patternInfoToQuery(this.query.contentPattern), searchOptions, progress, token);
    if (testingPs.length) {
      await Promise.all(testingPs);
    }
    return result;
  }
  validateProviderResult(result) {
    if (extensionResultIsMatch(result)) {
      if (Array.isArray(result.ranges)) {
        if (!Array.isArray(result.preview.matches)) {
          console.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same type.");
          return false;
        }
        if (result.preview.matches.length !== result.ranges.length) {
          console.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.");
          return false;
        }
      } else {
        if (Array.isArray(result.preview.matches)) {
          console.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.");
          return false;
        }
      }
    }
    return true;
  }
  getSearchOptionsForFolder(fq) {
    const includes2 = resolvePatternsForProvider(this.query.includePattern, fq.includePattern);
    const excludes = resolvePatternsForProvider(this.query.excludePattern, fq.excludePattern);
    const options = {
      folder: URI.from(fq.folder),
      excludes,
      includes: includes2,
      useIgnoreFiles: !fq.disregardIgnoreFiles,
      useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,
      useParentIgnoreFiles: !fq.disregardParentIgnoreFiles,
      followSymlinks: !fq.ignoreSymlinks,
      encoding: fq.fileEncoding && this.fileUtils.toCanonicalName(fq.fileEncoding),
      maxFileSize: this.query.maxFileSize,
      maxResults: this.query.maxResults,
      previewOptions: this.query.previewOptions,
      afterContext: this.query.afterContext,
      beforeContext: this.query.beforeContext
    };
    options.usePCRE2 = this.query.usePCRE2;
    return options;
  }
};
function patternInfoToQuery(patternInfo) {
  return {
    isCaseSensitive: patternInfo.isCaseSensitive || false,
    isRegExp: patternInfo.isRegExp || false,
    isWordMatch: patternInfo.isWordMatch || false,
    isMultiline: patternInfo.isMultiline || false,
    pattern: patternInfo.pattern
  };
}
var TextSearchResultsCollector = class {
  constructor(_onResult) {
    this._onResult = _onResult;
    this._currentFolderIdx = -1;
    this._currentFileMatch = null;
    this._batchedCollector = new BatchedCollector(512, (items) => this.sendItems(items));
  }
  add(data, folderIdx) {
    if (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !isEqual(this._currentUri, data.uri))) {
      this.pushToCollector();
      this._currentFileMatch = null;
    }
    if (!this._currentFileMatch) {
      this._currentFolderIdx = folderIdx;
      this._currentFileMatch = {
        resource: data.uri,
        results: []
      };
    }
    this._currentFileMatch.results.push(extensionResultToFrontendResult(data));
  }
  pushToCollector() {
    const size = this._currentFileMatch && this._currentFileMatch.results ? this._currentFileMatch.results.length : 0;
    this._batchedCollector.addItem(this._currentFileMatch, size);
  }
  flush() {
    this.pushToCollector();
    this._batchedCollector.flush();
  }
  sendItems(items) {
    this._onResult(items);
  }
};
function extensionResultToFrontendResult(data) {
  if (extensionResultIsMatch(data)) {
    return {
      preview: {
        matches: mapArrayOrNot(data.preview.matches, (m) => ({
          startLineNumber: m.start.line,
          startColumn: m.start.character,
          endLineNumber: m.end.line,
          endColumn: m.end.character
        })),
        text: data.preview.text
      },
      ranges: mapArrayOrNot(data.ranges, (r) => ({
        startLineNumber: r.start.line,
        startColumn: r.start.character,
        endLineNumber: r.end.line,
        endColumn: r.end.character
      }))
    };
  } else {
    return {
      text: data.text,
      lineNumber: data.lineNumber
    };
  }
}
function extensionResultIsMatch(data) {
  return !!data.preview;
}
var _BatchedCollector = class _BatchedCollector {
  constructor(maxBatchSize, cb) {
    this.maxBatchSize = maxBatchSize;
    this.cb = cb;
    this.totalNumberCompleted = 0;
    this.batch = [];
    this.batchSize = 0;
  }
  addItem(item, size) {
    if (!item) {
      return;
    }
    this.addItemToBatch(item, size);
  }
  addItems(items, size) {
    if (!items) {
      return;
    }
    this.addItemsToBatch(items, size);
  }
  addItemToBatch(item, size) {
    this.batch.push(item);
    this.batchSize += size;
    this.onUpdate();
  }
  addItemsToBatch(item, size) {
    this.batch = this.batch.concat(item);
    this.batchSize += size;
    this.onUpdate();
  }
  onUpdate() {
    if (this.totalNumberCompleted < _BatchedCollector.START_BATCH_AFTER_COUNT) {
      this.flush();
    } else if (this.batchSize >= this.maxBatchSize) {
      this.flush();
    } else if (!this.timeoutHandle) {
      this.timeoutHandle = setTimeout(() => {
        this.flush();
      }, _BatchedCollector.TIMEOUT);
    }
  }
  flush() {
    if (this.batchSize) {
      this.totalNumberCompleted += this.batchSize;
      this.cb(this.batch);
      this.batch = [];
      this.batchSize = 0;
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = 0;
      }
    }
  }
};
_BatchedCollector.TIMEOUT = 4e3;
_BatchedCollector.START_BATCH_AFTER_COUNT = 50;
var BatchedCollector = _BatchedCollector;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSearch.js
var IExtHostSearch = createDecorator("IExtHostSearch");
var ExtHostSearch = class ExtHostSearch2 {
  constructor(extHostRpc, _uriTransformer, _logService) {
    this.extHostRpc = extHostRpc;
    this._uriTransformer = _uriTransformer;
    this._logService = _logService;
    this._proxy = this.extHostRpc.getProxy(MainContext.MainThreadSearch);
    this._handlePool = 0;
    this._textSearchProvider = /* @__PURE__ */ new Map();
    this._textSearchUsedSchemes = /* @__PURE__ */ new Set();
    this._fileSearchProvider = /* @__PURE__ */ new Map();
    this._fileSearchUsedSchemes = /* @__PURE__ */ new Set();
    this._fileSearchManager = new FileSearchManager();
  }
  _transformScheme(scheme) {
    return this._uriTransformer.transformOutgoingScheme(scheme);
  }
  registerTextSearchProvider(scheme, provider) {
    if (this._textSearchUsedSchemes.has(scheme)) {
      throw new Error(`a text search provider for the scheme '${scheme}' is already registered`);
    }
    this._textSearchUsedSchemes.add(scheme);
    const handle = this._handlePool++;
    this._textSearchProvider.set(handle, provider);
    this._proxy.$registerTextSearchProvider(handle, this._transformScheme(scheme));
    return toDisposable(() => {
      this._textSearchUsedSchemes.delete(scheme);
      this._textSearchProvider.delete(handle);
      this._proxy.$unregisterProvider(handle);
    });
  }
  registerFileSearchProvider(scheme, provider) {
    if (this._fileSearchUsedSchemes.has(scheme)) {
      throw new Error(`a file search provider for the scheme '${scheme}' is already registered`);
    }
    this._fileSearchUsedSchemes.add(scheme);
    const handle = this._handlePool++;
    this._fileSearchProvider.set(handle, provider);
    this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));
    return toDisposable(() => {
      this._fileSearchUsedSchemes.delete(scheme);
      this._fileSearchProvider.delete(handle);
      this._proxy.$unregisterProvider(handle);
    });
  }
  $provideFileSearchResults(handle, session, rawQuery, token) {
    const query = reviveQuery(rawQuery);
    const provider = this._fileSearchProvider.get(handle);
    if (provider) {
      return this._fileSearchManager.fileSearch(query, provider, (batch) => {
        this._proxy.$handleFileMatch(handle, session, batch.map((p) => p.resource));
      }, token);
    } else {
      throw new Error("unknown provider: " + handle);
    }
  }
  $clearCache(cacheKey) {
    this._fileSearchManager.clearCache(cacheKey);
    return Promise.resolve(void 0);
  }
  $provideTextSearchResults(handle, session, rawQuery, token) {
    const provider = this._textSearchProvider.get(handle);
    if (!provider || !provider.provideTextSearchResults) {
      throw new Error(`Unknown provider ${handle}`);
    }
    const query = reviveQuery(rawQuery);
    const engine = this.createTextSearchManager(query, provider);
    return engine.search((progress) => this._proxy.$handleTextMatch(handle, session, progress), token);
  }
  $enableExtensionHostSearch() {
  }
  createTextSearchManager(query, provider) {
    return new TextSearchManager(query, provider, {
      readdir: (resource) => Promise.resolve([]),
      toCanonicalName: (encoding) => encoding
    }, "textSearchProvider");
  }
};
ExtHostSearch = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IURITransformerService),
  __param(2, ILogService)
], ExtHostSearch);
function reviveQuery(rawQuery) {
  return {
    ...rawQuery,
    ...{
      folderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),
      extraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map((components) => URI.revive(components))
    }
  };
}
function reviveFolderQuery(rawFolderQuery) {
  return {
    ...rawFolderQuery,
    folder: URI.revive(rawFolderQuery.folder)
  };
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js
init_log();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebook.js
init_nls();
init_buffer();
init_event();
init_lifecycle();
init_map();
init_strings();
init_types();
init_uri();
init_files();
init_extHost_protocol();
init_extHostTypes();
init_proxyIdentifier();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookDocument.js
init_network();
init_uri();
init_extHostTypes();
init_notebookCommon();
var RawContentChangeEvent = class {
  constructor(start, deletedCount, deletedItems, items) {
    this.start = start;
    this.deletedCount = deletedCount;
    this.deletedItems = deletedItems;
    this.items = items;
  }
  asApiEvent() {
    return {
      range: new NotebookRange(this.start, this.start + this.deletedCount),
      addedCells: this.items.map((cell) => cell.apiCell),
      removedCells: this.deletedItems
    };
  }
};
var ExtHostCell = class {
  static asModelAddData(notebook, cell) {
    return {
      EOL: cell.eol,
      lines: cell.source,
      languageId: cell.language,
      uri: cell.uri,
      isDirty: false,
      versionId: 1,
      notebook
    };
  }
  constructor(notebook, _extHostDocument, _cellData) {
    this.notebook = notebook;
    this._extHostDocument = _extHostDocument;
    this._cellData = _cellData;
    this.handle = _cellData.handle;
    this.uri = URI.revive(_cellData.uri);
    this.cellKind = _cellData.cellKind;
    this._outputs = _cellData.outputs.map(NotebookCellOutput2.to);
    this._internalMetadata = _cellData.internalMetadata ?? {};
    this._metadata = Object.freeze(_cellData.metadata ?? {});
    this._previousResult = Object.freeze(
      NotebookCellExecutionSummary.to(_cellData.internalMetadata ?? {})
    );
  }
  get internalMetadata() {
    return this._internalMetadata;
  }
  get apiCell() {
    if (!this._apiCell) {
      const that = this;
      const data = this._extHostDocument.getDocument(this.uri);
      if (!data) {
        throw new Error(`MISSING extHostDocument for notebook cell: ${this.uri}`);
      }
      const apiCell = {
        get index() {
          return that.notebook.getCellIndex(that);
        },
        notebook: that.notebook.apiNotebook,
        kind: NotebookCellKind2.to(this._cellData.cellKind),
        document: data.document,
        get mime() {
          return that._mime;
        },
        set mime(value) {
          that._mime = value;
        },
        get outputs() {
          return that._outputs.slice(0);
        },
        get metadata() {
          return that._metadata;
        },
        get executionSummary() {
          return that._previousResult;
        }
      };
      this._apiCell = Object.freeze(apiCell);
    }
    return this._apiCell;
  }
  setOutputs(newOutputs) {
    this._outputs = newOutputs.map(NotebookCellOutput2.to);
  }
  setOutputItems(outputId, append2, newOutputItems) {
    const newItems = newOutputItems.map(NotebookCellOutputItem2.to);
    const output = this._outputs.find((op) => op.id === outputId);
    if (output) {
      if (!append2) {
        output.items.length = 0;
      }
      output.items.push(...newItems);
      if (output.items.length > 1 && output.items.every((item) => isTextStreamMime(item.mime))) {
        const mimeOutputs = /* @__PURE__ */ new Map();
        const mimeTypes = [];
        output.items.forEach((item) => {
          let items;
          if (mimeOutputs.has(item.mime)) {
            items = mimeOutputs.get(item.mime);
          } else {
            items = [];
            mimeOutputs.set(item.mime, items);
            mimeTypes.push(item.mime);
          }
          items.push(item.data);
        });
        output.items.length = 0;
        mimeTypes.forEach((mime) => {
          const compressed = compressOutputItemStreams(mimeOutputs.get(mime));
          output.items.push({
            mime,
            data: compressed.data.buffer
          });
        });
      }
    }
  }
  setMetadata(newMetadata) {
    this._metadata = Object.freeze(newMetadata);
  }
  setInternalMetadata(newInternalMetadata) {
    this._internalMetadata = newInternalMetadata;
    this._previousResult = Object.freeze(NotebookCellExecutionSummary.to(newInternalMetadata));
  }
  setMime(newMime) {
  }
};
var _ExtHostNotebookDocument = class _ExtHostNotebookDocument {
  constructor(_proxy10, _textDocumentsAndEditors, _textDocuments, uri, data) {
    this._proxy = _proxy10;
    this._textDocumentsAndEditors = _textDocumentsAndEditors;
    this._textDocuments = _textDocuments;
    this.uri = uri;
    this.handle = _ExtHostNotebookDocument._handlePool++;
    this._cells = [];
    this._versionId = 0;
    this._isDirty = false;
    this._disposed = false;
    this._notebookType = data.viewType;
    this._metadata = Object.freeze(data.metadata ?? /* @__PURE__ */ Object.create(null));
    this._spliceNotebookCells([[0, 0, data.cells]], true, void 0);
    this._versionId = data.versionId;
  }
  dispose() {
    this._disposed = true;
  }
  get versionId() {
    return this._versionId;
  }
  get apiNotebook() {
    if (!this._notebook) {
      const that = this;
      const apiObject = {
        get uri() {
          return that.uri;
        },
        get version() {
          return that._versionId;
        },
        get notebookType() {
          return that._notebookType;
        },
        get isDirty() {
          return that._isDirty;
        },
        get isUntitled() {
          return that.uri.scheme === Schemas.untitled;
        },
        get isClosed() {
          return that._disposed;
        },
        get metadata() {
          return that._metadata;
        },
        get cellCount() {
          return that._cells.length;
        },
        cellAt(index) {
          index = that._validateIndex(index);
          return that._cells[index].apiCell;
        },
        getCells(range) {
          const cells = range ? that._getCells(range) : that._cells;
          return cells.map((cell) => cell.apiCell);
        },
        save() {
          return that._save();
        }
      };
      this._notebook = Object.freeze(apiObject);
    }
    return this._notebook;
  }
  acceptDocumentPropertiesChanged(data) {
    if (data.metadata) {
      this._metadata = Object.freeze({ ...this._metadata, ...data.metadata });
    }
  }
  acceptDirty(isDirty) {
    this._isDirty = isDirty;
  }
  acceptModelChanged(event, isDirty, newMetadata) {
    this._versionId = event.versionId;
    this._isDirty = isDirty;
    this.acceptDocumentPropertiesChanged({ metadata: newMetadata });
    const result = {
      notebook: this.apiNotebook,
      metadata: newMetadata,
      cellChanges: [],
      contentChanges: []
    };
    const relaxedCellChanges = [];
    for (const rawEvent of event.rawEvents) {
      if (rawEvent.kind === NotebookCellsChangeType.ModelChange) {
        this._spliceNotebookCells(rawEvent.changes, false, result.contentChanges);
      } else if (rawEvent.kind === NotebookCellsChangeType.Move) {
        this._moveCells(rawEvent.index, rawEvent.length, rawEvent.newIdx, result.contentChanges);
      } else if (rawEvent.kind === NotebookCellsChangeType.Output) {
        this._setCellOutputs(rawEvent.index, rawEvent.outputs);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, outputs: this._cells[rawEvent.index].apiCell.outputs });
      } else if (rawEvent.kind === NotebookCellsChangeType.OutputItem) {
        this._setCellOutputItems(rawEvent.index, rawEvent.outputId, rawEvent.append, rawEvent.outputItems);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, outputs: this._cells[rawEvent.index].apiCell.outputs });
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellLanguage) {
        this._changeCellLanguage(rawEvent.index, rawEvent.language);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, document: this._cells[rawEvent.index].apiCell.document });
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellContent) {
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, document: this._cells[rawEvent.index].apiCell.document });
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellMime) {
        this._changeCellMime(rawEvent.index, rawEvent.mime);
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellMetadata) {
        this._changeCellMetadata(rawEvent.index, rawEvent.metadata);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, metadata: this._cells[rawEvent.index].apiCell.metadata });
      } else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellInternalMetadata) {
        this._changeCellInternalMetadata(rawEvent.index, rawEvent.internalMetadata);
        relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, executionSummary: this._cells[rawEvent.index].apiCell.executionSummary });
      }
    }
    const map = /* @__PURE__ */ new Map();
    for (let i = 0; i < relaxedCellChanges.length; i++) {
      const relaxedCellChange = relaxedCellChanges[i];
      const existing = map.get(relaxedCellChange.cell);
      if (existing === void 0) {
        const newLen = result.cellChanges.push({
          document: void 0,
          executionSummary: void 0,
          metadata: void 0,
          outputs: void 0,
          ...relaxedCellChange
        });
        map.set(relaxedCellChange.cell, newLen - 1);
      } else {
        result.cellChanges[existing] = {
          ...result.cellChanges[existing],
          ...relaxedCellChange
        };
      }
    }
    return result;
  }
  _validateIndex(index) {
    index = index | 0;
    if (index < 0) {
      return 0;
    } else if (index >= this._cells.length) {
      return this._cells.length - 1;
    } else {
      return index;
    }
  }
  _validateRange(range) {
    let start = range.start | 0;
    let end = range.end | 0;
    if (start < 0) {
      start = 0;
    }
    if (end > this._cells.length) {
      end = this._cells.length;
    }
    return range.with({ start, end });
  }
  _getCells(range) {
    range = this._validateRange(range);
    const result = [];
    for (let i = range.start; i < range.end; i++) {
      result.push(this._cells[i]);
    }
    return result;
  }
  async _save() {
    if (this._disposed) {
      return Promise.reject(new Error("Notebook has been closed"));
    }
    return this._proxy.$trySaveNotebook(this.uri);
  }
  _spliceNotebookCells(splices, initialization, bucket) {
    if (this._disposed) {
      return;
    }
    const contentChangeEvents = [];
    const addedCellDocuments = [];
    const removedCellDocuments = [];
    splices.reverse().forEach((splice) => {
      const cellDtos = splice[2];
      const newCells = cellDtos.map((cell) => {
        const extCell = new ExtHostCell(this, this._textDocumentsAndEditors, cell);
        if (!initialization) {
          addedCellDocuments.push(ExtHostCell.asModelAddData(this.apiNotebook, cell));
        }
        return extCell;
      });
      const changeEvent = new RawContentChangeEvent(splice[0], splice[1], [], newCells);
      const deletedItems = this._cells.splice(splice[0], splice[1], ...newCells);
      for (const cell of deletedItems) {
        removedCellDocuments.push(cell.uri);
        changeEvent.deletedItems.push(cell.apiCell);
      }
      contentChangeEvents.push(changeEvent);
    });
    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
      addedDocuments: addedCellDocuments,
      removedDocuments: removedCellDocuments
    });
    if (bucket) {
      for (const changeEvent of contentChangeEvents) {
        bucket.push(changeEvent.asApiEvent());
      }
    }
  }
  _moveCells(index, length, newIdx, bucket) {
    const cells = this._cells.splice(index, length);
    this._cells.splice(newIdx, 0, ...cells);
    const changes = [
      new RawContentChangeEvent(index, length, cells.map((c) => c.apiCell), []),
      new RawContentChangeEvent(newIdx, 0, [], cells)
    ];
    for (const change of changes) {
      bucket.push(change.asApiEvent());
    }
  }
  _setCellOutputs(index, outputs) {
    const cell = this._cells[index];
    cell.setOutputs(outputs);
  }
  _setCellOutputItems(index, outputId, append2, outputItems) {
    const cell = this._cells[index];
    cell.setOutputItems(outputId, append2, outputItems);
  }
  _changeCellLanguage(index, newLanguageId) {
    const cell = this._cells[index];
    if (cell.apiCell.document.languageId !== newLanguageId) {
      this._textDocuments.$acceptModelLanguageChanged(cell.uri, newLanguageId);
    }
  }
  _changeCellMime(index, newMime) {
    const cell = this._cells[index];
    cell.apiCell.mime = newMime;
  }
  _changeCellMetadata(index, newMetadata) {
    const cell = this._cells[index];
    cell.setMetadata(newMetadata);
  }
  _changeCellInternalMetadata(index, newInternalMetadata) {
    const cell = this._cells[index];
    cell.setInternalMetadata(newInternalMetadata);
  }
  getCellFromApiCell(apiCell) {
    return this._cells.find((cell) => cell.apiCell === apiCell);
  }
  getCellFromIndex(index) {
    return this._cells[index];
  }
  getCell(cellHandle) {
    return this._cells.find((cell) => cell.handle === cellHandle);
  }
  getCellIndex(cell) {
    return this._cells.indexOf(cell);
  }
};
_ExtHostNotebookDocument._handlePool = 0;
var ExtHostNotebookDocument = _ExtHostNotebookDocument;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookEditor.js
init_errors();
init_extHostTypes();
var _ExtHostNotebookEditor = class _ExtHostNotebookEditor {
  constructor(id, _proxy10, notebookData, visibleRanges, selections, viewColumn) {
    this.id = id;
    this._proxy = _proxy10;
    this.notebookData = notebookData;
    this._selections = [];
    this._visibleRanges = [];
    this._visible = false;
    this._selections = selections;
    this._visibleRanges = visibleRanges;
    this._viewColumn = viewColumn;
  }
  get apiEditor() {
    if (!this._editor) {
      const that = this;
      this._editor = {
        get notebook() {
          return that.notebookData.apiNotebook;
        },
        get selection() {
          return that._selections[0];
        },
        set selection(selection) {
          this.selections = [selection];
        },
        get selections() {
          return that._selections;
        },
        set selections(value) {
          if (!Array.isArray(value) || !value.every(NotebookRange.isNotebookRange)) {
            throw illegalArgument("selections");
          }
          that._selections = value;
          that._trySetSelections(value);
        },
        get visibleRanges() {
          return that._visibleRanges;
        },
        revealRange(range, revealType) {
          that._proxy.$tryRevealRange(that.id, NotebookRange2.from(range), revealType ?? NotebookEditorRevealType2.Default);
        },
        get viewColumn() {
          return that._viewColumn;
        }
      };
      _ExtHostNotebookEditor.apiEditorsToExtHost.set(this._editor, this);
    }
    return this._editor;
  }
  get visible() {
    return this._visible;
  }
  _acceptVisibility(value) {
    this._visible = value;
  }
  _acceptVisibleRanges(value) {
    this._visibleRanges = value;
  }
  _acceptSelections(selections) {
    this._selections = selections;
  }
  _trySetSelections(value) {
    this._proxy.$trySetSelections(this.id, value.map(NotebookRange2.from));
  }
  _acceptViewColumn(value) {
    this._viewColumn = value;
  }
};
_ExtHostNotebookEditor.apiEditorsToExtHost = /* @__PURE__ */ new WeakMap();
var ExtHostNotebookEditor = _ExtHostNotebookEditor;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebook.js
init_errors();
init_objects();
init_network();
var _ExtHostNotebookController = class _ExtHostNotebookController {
  get activeNotebookEditor() {
    var _a30;
    return (_a30 = this._activeNotebookEditor) == null ? void 0 : _a30.apiEditor;
  }
  get visibleNotebookEditors() {
    return this._visibleNotebookEditors.map((editor) => editor.apiEditor);
  }
  constructor(mainContext, commands, _textDocumentsAndEditors, _textDocuments, _extHostFileSystem) {
    this._textDocumentsAndEditors = _textDocumentsAndEditors;
    this._textDocuments = _textDocuments;
    this._extHostFileSystem = _extHostFileSystem;
    this._notebookStatusBarItemProviders = /* @__PURE__ */ new Map();
    this._documents = new ResourceMap();
    this._editors = /* @__PURE__ */ new Map();
    this._onDidChangeActiveNotebookEditor = new Emitter({ onListenerError: onUnexpectedExternalError });
    this.onDidChangeActiveNotebookEditor = this._onDidChangeActiveNotebookEditor.event;
    this._visibleNotebookEditors = [];
    this._onDidOpenNotebookDocument = new Emitter({ onListenerError: onUnexpectedExternalError });
    this.onDidOpenNotebookDocument = this._onDidOpenNotebookDocument.event;
    this._onDidCloseNotebookDocument = new Emitter({ onListenerError: onUnexpectedExternalError });
    this.onDidCloseNotebookDocument = this._onDidCloseNotebookDocument.event;
    this._onDidChangeVisibleNotebookEditors = new Emitter({ onListenerError: onUnexpectedExternalError });
    this.onDidChangeVisibleNotebookEditors = this._onDidChangeVisibleNotebookEditors.event;
    this._statusBarCache = new Cache("NotebookCellStatusBarCache");
    this._handlePool = 0;
    this._notebookSerializer = /* @__PURE__ */ new Map();
    this._notebookProxy = mainContext.getProxy(MainContext.MainThreadNotebook);
    this._notebookDocumentsProxy = mainContext.getProxy(MainContext.MainThreadNotebookDocuments);
    this._notebookEditorsProxy = mainContext.getProxy(MainContext.MainThreadNotebookEditors);
    this._commandsConverter = commands.converter;
    commands.registerArgumentProcessor({
      processArgument: (arg) => {
        var _a30;
        if (arg && arg.$mid === 13) {
          const notebookUri = (_a30 = arg.notebookEditor) == null ? void 0 : _a30.notebookUri;
          const cellHandle = arg.cell.handle;
          const data = this._documents.get(notebookUri);
          const cell = data == null ? void 0 : data.getCell(cellHandle);
          if (cell) {
            return cell.apiCell;
          }
        }
        if (arg && arg.$mid === 14) {
          const notebookUri = arg.uri;
          const data = this._documents.get(notebookUri);
          if (data) {
            return data.apiNotebook;
          }
        }
        return arg;
      }
    });
    _ExtHostNotebookController._registerApiCommands(commands);
  }
  getEditorById(editorId) {
    const editor = this._editors.get(editorId);
    if (!editor) {
      throw new Error(`unknown text editor: ${editorId}. known editors: ${[...this._editors.keys()]} `);
    }
    return editor;
  }
  getIdByEditor(editor) {
    for (const [id, candidate] of this._editors) {
      if (candidate.apiEditor === editor) {
        return id;
      }
    }
    return void 0;
  }
  get notebookDocuments() {
    return [...this._documents.values()];
  }
  getNotebookDocument(uri, relaxed) {
    const result = this._documents.get(uri);
    if (!result && !relaxed) {
      throw new Error(`NO notebook document for '${uri}'`);
    }
    return result;
  }
  static _convertNotebookRegistrationData(extension, registration) {
    if (!registration) {
      return;
    }
    const viewOptionsFilenamePattern = registration.filenamePattern.map((pattern) => NotebookExclusiveDocumentPattern.from(pattern)).filter((pattern) => pattern !== void 0);
    if (registration.filenamePattern && !viewOptionsFilenamePattern) {
      console.warn(`Notebook content provider view options file name pattern is invalid ${registration.filenamePattern}`);
      return void 0;
    }
    return {
      extension: extension.identifier,
      providerDisplayName: extension.displayName || extension.name,
      displayName: registration.displayName,
      filenamePattern: viewOptionsFilenamePattern,
      exclusive: registration.exclusive || false
    };
  }
  registerNotebookCellStatusBarItemProvider(extension, notebookType, provider) {
    const handle = _ExtHostNotebookController._notebookStatusBarItemProviderHandlePool++;
    const eventHandle = typeof provider.onDidChangeCellStatusBarItems === "function" ? _ExtHostNotebookController._notebookStatusBarItemProviderHandlePool++ : void 0;
    this._notebookStatusBarItemProviders.set(handle, provider);
    this._notebookProxy.$registerNotebookCellStatusBarItemProvider(handle, eventHandle, notebookType);
    let subscription;
    if (eventHandle !== void 0) {
      subscription = provider.onDidChangeCellStatusBarItems((_) => this._notebookProxy.$emitCellStatusBarEvent(eventHandle));
    }
    return new Disposable2(() => {
      this._notebookStatusBarItemProviders.delete(handle);
      this._notebookProxy.$unregisterNotebookCellStatusBarItemProvider(handle, eventHandle);
      subscription == null ? void 0 : subscription.dispose();
    });
  }
  async createNotebookDocument(options) {
    const canonicalUri = await this._notebookDocumentsProxy.$tryCreateNotebook({
      viewType: options.viewType,
      content: options.content && NotebookData2.from(options.content)
    });
    return URI.revive(canonicalUri);
  }
  async openNotebookDocument(uri) {
    const cached = this._documents.get(uri);
    if (cached) {
      return cached.apiNotebook;
    }
    const canonicalUri = await this._notebookDocumentsProxy.$tryOpenNotebook(uri);
    const document2 = this._documents.get(URI.revive(canonicalUri));
    return assertIsDefined(document2 == null ? void 0 : document2.apiNotebook);
  }
  async showNotebookDocument(notebookOrUri, options) {
    var _a30;
    if (URI.isUri(notebookOrUri)) {
      notebookOrUri = await this.openNotebookDocument(notebookOrUri);
    }
    let resolvedOptions;
    if (typeof options === "object") {
      resolvedOptions = {
        position: ViewColumn2.from(options.viewColumn),
        preserveFocus: options.preserveFocus,
        selections: options.selections && options.selections.map(NotebookRange2.from),
        pinned: typeof options.preview === "boolean" ? !options.preview : void 0
      };
    } else {
      resolvedOptions = {
        preserveFocus: false
      };
    }
    const editorId = await this._notebookEditorsProxy.$tryShowNotebookDocument(notebookOrUri.uri, notebookOrUri.notebookType, resolvedOptions);
    const editor = editorId && ((_a30 = this._editors.get(editorId)) == null ? void 0 : _a30.apiEditor);
    if (editor) {
      return editor;
    }
    if (editorId) {
      throw new Error(`Could NOT open editor for "${notebookOrUri.uri.toString()}" because another editor opened in the meantime.`);
    } else {
      throw new Error(`Could NOT open editor for "${notebookOrUri.uri.toString()}".`);
    }
  }
  async $provideNotebookCellStatusBarItems(handle, uri, index, token) {
    const provider = this._notebookStatusBarItemProviders.get(handle);
    const revivedUri = URI.revive(uri);
    const document2 = this._documents.get(revivedUri);
    if (!document2 || !provider) {
      return;
    }
    const cell = document2.getCellFromIndex(index);
    if (!cell) {
      return;
    }
    const result = await provider.provideCellStatusBarItems(cell.apiCell, token);
    if (!result) {
      return void 0;
    }
    const disposables = new DisposableStore();
    const cacheId = this._statusBarCache.add([disposables]);
    const resultArr = Array.isArray(result) ? result : [result];
    const items = resultArr.map(
      (item) => NotebookStatusBarItem.from(item, this._commandsConverter, disposables)
    );
    return {
      cacheId,
      items
    };
  }
  $releaseNotebookCellStatusBarItems(cacheId) {
    this._statusBarCache.delete(cacheId);
  }
  registerNotebookSerializer(extension, viewType, serializer, options, registration) {
    if (isFalsyOrWhitespace(viewType)) {
      throw new Error(`viewType cannot be empty or just whitespace`);
    }
    const handle = this._handlePool++;
    this._notebookSerializer.set(handle, { viewType, serializer, options });
    this._notebookProxy.$registerNotebookSerializer(handle, { id: extension.identifier, location: extension.extensionLocation }, viewType, NotebookDocumentContentOptions.from(options), _ExtHostNotebookController._convertNotebookRegistrationData(extension, registration));
    return toDisposable(() => {
      this._notebookProxy.$unregisterNotebookSerializer(handle);
    });
  }
  async $dataToNotebook(handle, bytes, token) {
    const serializer = this._notebookSerializer.get(handle);
    if (!serializer) {
      throw new Error("NO serializer found");
    }
    const data = await serializer.serializer.deserializeNotebook(bytes.buffer, token);
    return new SerializableObjectWithBuffers(NotebookData2.from(data));
  }
  async $notebookToData(handle, data, token) {
    const serializer = this._notebookSerializer.get(handle);
    if (!serializer) {
      throw new Error("NO serializer found");
    }
    const bytes = await serializer.serializer.serializeNotebook(NotebookData2.to(data.value), token);
    return VSBuffer.wrap(bytes);
  }
  async $saveNotebook(handle, uriComponents, versionId, options, token) {
    var _a30;
    const uri = URI.revive(uriComponents);
    const serializer = this._notebookSerializer.get(handle);
    if (!serializer) {
      throw new Error("NO serializer found");
    }
    const document2 = this._documents.get(uri);
    if (!document2) {
      throw new Error("Document NOT found");
    }
    if (document2.versionId !== versionId) {
      throw new Error("Document version mismatch");
    }
    if (!this._extHostFileSystem.value.isWritableFileSystem(uri.scheme)) {
      throw new FileOperationError(localize("err.readonly", "Unable to modify read-only file '{0}'", this._resourceForError(uri)), 6);
    }
    await this._validateWriteFile(uri, options);
    const data = {
      metadata: filter(document2.apiNotebook.metadata, (key) => {
        var _a31;
        return !(((_a31 = serializer.options) == null ? void 0 : _a31.transientDocumentMetadata) ?? {})[key];
      }),
      cells: []
    };
    for (const cell of document2.apiNotebook.getCells()) {
      const cellData = new NotebookCellData(cell.kind, cell.document.getText(), cell.document.languageId, cell.mime, !((_a30 = serializer.options) == null ? void 0 : _a30.transientOutputs) ? [...cell.outputs] : [], cell.metadata, cell.executionSummary);
      cellData.metadata = filter(cell.metadata, (key) => {
        var _a31;
        return !(((_a31 = serializer.options) == null ? void 0 : _a31.transientCellMetadata) ?? {})[key];
      });
      data.cells.push(cellData);
    }
    const bytes = await serializer.serializer.serializeNotebook(data, token);
    await this._extHostFileSystem.value.writeFile(uri, bytes);
    const providerExtUri = this._extHostFileSystem.getFileSystemProviderExtUri(uri.scheme);
    const stat = await this._extHostFileSystem.value.stat(uri);
    const fileStats = {
      name: providerExtUri.basename(uri),
      isFile: (stat.type & FileType.File) !== 0,
      isDirectory: (stat.type & FileType.Directory) !== 0,
      isSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,
      mtime: stat.mtime,
      ctime: stat.ctime,
      size: stat.size,
      readonly: Boolean((stat.permissions ?? 0) & FilePermission.Readonly) || !this._extHostFileSystem.value.isWritableFileSystem(uri.scheme),
      locked: Boolean((stat.permissions ?? 0) & FilePermission.Locked),
      etag: etag({ mtime: stat.mtime, size: stat.size }),
      children: void 0
    };
    return fileStats;
  }
  async _validateWriteFile(uri, options) {
    const stat = await this._extHostFileSystem.value.stat(uri);
    if (typeof (options == null ? void 0 : options.mtime) === "number" && typeof options.etag === "string" && options.etag !== ETAG_DISABLED && typeof stat.mtime === "number" && typeof stat.size === "number" && options.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime, size: stat.size })) {
      throw new FileOperationError(localize("fileModifiedError", "File Modified Since"), 3, options);
    }
    return;
  }
  _resourceForError(uri) {
    return uri.scheme === Schemas.file ? uri.fsPath : uri.toString();
  }
  _createExtHostEditor(document2, editorId, data) {
    if (this._editors.has(editorId)) {
      throw new Error(`editor with id ALREADY EXSIST: ${editorId}`);
    }
    const editor = new ExtHostNotebookEditor(editorId, this._notebookEditorsProxy, document2, data.visibleRanges.map(NotebookRange2.to), data.selections.map(NotebookRange2.to), typeof data.viewColumn === "number" ? ViewColumn2.to(data.viewColumn) : void 0);
    this._editors.set(editorId, editor);
  }
  $acceptDocumentAndEditorsDelta(delta3) {
    var _a30, _b, _c;
    if (delta3.value.removedDocuments) {
      for (const uri of delta3.value.removedDocuments) {
        const revivedUri = URI.revive(uri);
        const document2 = this._documents.get(revivedUri);
        if (document2) {
          document2.dispose();
          this._documents.delete(revivedUri);
          this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ removedDocuments: document2.apiNotebook.getCells().map((cell) => cell.document.uri) });
          this._onDidCloseNotebookDocument.fire(document2.apiNotebook);
        }
        for (const editor of this._editors.values()) {
          if (editor.notebookData.uri.toString() === revivedUri.toString()) {
            this._editors.delete(editor.id);
          }
        }
      }
    }
    if (delta3.value.addedDocuments) {
      const addedCellDocuments = [];
      for (const modelData of delta3.value.addedDocuments) {
        const uri = URI.revive(modelData.uri);
        if (this._documents.has(uri)) {
          throw new Error(`adding EXISTING notebook ${uri} `);
        }
        const document2 = new ExtHostNotebookDocument(
          this._notebookDocumentsProxy,
          this._textDocumentsAndEditors,
          this._textDocuments,
          uri,
          modelData
        );
        addedCellDocuments.push(...modelData.cells.map((cell) => ExtHostCell.asModelAddData(document2.apiNotebook, cell)));
        (_a30 = this._documents.get(uri)) == null ? void 0 : _a30.dispose();
        this._documents.set(uri, document2);
        this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ addedDocuments: addedCellDocuments });
        this._onDidOpenNotebookDocument.fire(document2.apiNotebook);
      }
    }
    if (delta3.value.addedEditors) {
      for (const editorModelData of delta3.value.addedEditors) {
        if (this._editors.has(editorModelData.id)) {
          return;
        }
        const revivedUri = URI.revive(editorModelData.documentUri);
        const document2 = this._documents.get(revivedUri);
        if (document2) {
          this._createExtHostEditor(document2, editorModelData.id, editorModelData);
        }
      }
    }
    if (delta3.value.removedEditors) {
      for (const editorid of delta3.value.removedEditors) {
        const editor = this._editors.get(editorid);
        if (editor) {
          this._editors.delete(editorid);
          if (((_b = this._activeNotebookEditor) == null ? void 0 : _b.id) === editor.id) {
            this._activeNotebookEditor = void 0;
          }
        }
      }
    }
    if (delta3.value.visibleEditors) {
      this._visibleNotebookEditors = delta3.value.visibleEditors.map((id) => this._editors.get(id)).filter((editor) => !!editor);
      const visibleEditorsSet = /* @__PURE__ */ new Set();
      this._visibleNotebookEditors.forEach((editor) => visibleEditorsSet.add(editor.id));
      for (const editor of this._editors.values()) {
        const newValue = visibleEditorsSet.has(editor.id);
        editor._acceptVisibility(newValue);
      }
      this._visibleNotebookEditors = [...this._editors.values()].map((e) => e).filter((e) => e.visible);
      this._onDidChangeVisibleNotebookEditors.fire(this.visibleNotebookEditors);
    }
    if (delta3.value.newActiveEditor === null) {
      this._activeNotebookEditor = void 0;
    } else if (delta3.value.newActiveEditor) {
      const activeEditor = this._editors.get(delta3.value.newActiveEditor);
      if (!activeEditor) {
        console.error(`FAILED to find active notebook editor ${delta3.value.newActiveEditor}`);
      }
      this._activeNotebookEditor = this._editors.get(delta3.value.newActiveEditor);
    }
    if (delta3.value.newActiveEditor !== void 0) {
      this._onDidChangeActiveNotebookEditor.fire((_c = this._activeNotebookEditor) == null ? void 0 : _c.apiEditor);
    }
  }
  static _registerApiCommands(extHostCommands) {
    const notebookTypeArg = ApiCommandArgument.String.with("notebookType", "A notebook type");
    const commandDataToNotebook = new ApiCommand(
      "vscode.executeDataToNotebook",
      "_executeDataToNotebook",
      "Invoke notebook serializer",
      [notebookTypeArg, new ApiCommandArgument(
        "data",
        "Bytes to convert to data",
        (v) => v instanceof Uint8Array,
        (v) => VSBuffer.wrap(v)
      )],
      new ApiCommandResult("Notebook Data", (data) => NotebookData2.to(data.value))
    );
    const commandNotebookToData = new ApiCommand(
      "vscode.executeNotebookToData",
      "_executeNotebookToData",
      "Invoke notebook serializer",
      [notebookTypeArg, new ApiCommandArgument(
        "NotebookData",
        "Notebook data to convert to bytes",
        (v) => true,
        (v) => new SerializableObjectWithBuffers(NotebookData2.from(v))
      )],
      new ApiCommandResult("Bytes", (dto) => dto.buffer)
    );
    extHostCommands.registerApiCommand(commandDataToNotebook);
    extHostCommands.registerApiCommand(commandNotebookToData);
  }
};
_ExtHostNotebookController._notebookStatusBarItemProviderHandlePool = 0;
var ExtHostNotebookController = _ExtHostNotebookController;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTheming.js
init_tslib_es6();
init_extHostTypes();
init_event();
var ExtHostTheming = class ExtHostTheming2 {
  constructor(_extHostRpc) {
    this._actual = new ColorTheme(ColorThemeKind.Dark);
    this._onDidChangeActiveColorTheme = new Emitter();
  }
  get activeColorTheme() {
    return this._actual;
  }
  $onColorThemeChange(type) {
    let kind;
    switch (type) {
      case "light":
        kind = ColorThemeKind.Light;
        break;
      case "hcDark":
        kind = ColorThemeKind.HighContrast;
        break;
      case "hcLight":
        kind = ColorThemeKind.HighContrastLight;
        break;
      default:
        kind = ColorThemeKind.Dark;
    }
    this._actual = new ColorTheme(kind);
    this._onDidChangeActiveColorTheme.fire(this._actual);
  }
  get onDidChangeActiveColorTheme() {
    return this._onDidChangeActiveColorTheme.event;
  }
};
ExtHostTheming = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostTheming);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostAuthentication.js
init_event();
init_extHost_protocol();
init_extHostTypes();
init_extensions();
var ExtHostAuthentication = class {
  constructor(mainContext) {
    this._authenticationProviders = /* @__PURE__ */ new Map();
    this._providers = [];
    this._onDidChangeSessions = new Emitter();
    this.onDidChangeSessions = this._onDidChangeSessions.event;
    this._getSessionTaskSingler = new TaskSingler();
    this._getSessionsTaskSingler = new TaskSingler();
    this._proxy = mainContext.getProxy(MainContext.MainThreadAuthentication);
  }
  $setProviders(providers2) {
    this._providers = providers2;
    return Promise.resolve();
  }
  async getSession(requestingExtension, providerId, scopes, options = {}) {
    const extensionId = ExtensionIdentifier.toKey(requestingExtension.identifier);
    const sortedScopes = [...scopes].sort().join(" ");
    return await this._getSessionTaskSingler.getOrCreate(`${extensionId} ${providerId} ${sortedScopes}`, async () => {
      await this._proxy.$ensureProvider(providerId);
      const extensionName = requestingExtension.displayName || requestingExtension.name;
      return this._proxy.$getSession(providerId, scopes, extensionId, extensionName, options);
    });
  }
  async getSessions(requestingExtension, providerId, scopes) {
    const extensionId = ExtensionIdentifier.toKey(requestingExtension.identifier);
    const sortedScopes = [...scopes].sort().join(" ");
    return await this._getSessionsTaskSingler.getOrCreate(`${extensionId} ${sortedScopes}`, async () => {
      await this._proxy.$ensureProvider(providerId);
      const extensionName = requestingExtension.displayName || requestingExtension.name;
      return this._proxy.$getSessions(providerId, scopes, extensionId, extensionName);
    });
  }
  async removeSession(providerId, sessionId) {
    const providerData = this._authenticationProviders.get(providerId);
    if (!providerData) {
      return this._proxy.$removeSession(providerId, sessionId);
    }
    return providerData.provider.removeSession(sessionId);
  }
  registerAuthenticationProvider(id, label, provider, options) {
    if (this._authenticationProviders.get(id)) {
      throw new Error(`An authentication provider with id '${id}' is already registered.`);
    }
    this._authenticationProviders.set(id, { label, provider, options: options ?? { supportsMultipleAccounts: false } });
    if (!this._providers.find((p) => p.id === id)) {
      this._providers.push({
        id,
        label
      });
    }
    const listener = provider.onDidChangeSessions((e) => {
      this._proxy.$sendDidChangeSessions(id, {
        added: e.added ?? [],
        changed: e.changed ?? [],
        removed: e.removed ?? []
      });
    });
    this._proxy.$registerAuthenticationProvider(id, label, (options == null ? void 0 : options.supportsMultipleAccounts) ?? false);
    return new Disposable2(() => {
      listener.dispose();
      this._authenticationProviders.delete(id);
      const i = this._providers.findIndex((p) => p.id === id);
      if (i > -1) {
        this._providers.splice(i);
      }
      this._proxy.$unregisterAuthenticationProvider(id);
    });
  }
  $createSession(providerId, scopes, options) {
    const providerData = this._authenticationProviders.get(providerId);
    if (providerData) {
      return Promise.resolve(providerData.provider.createSession(scopes, options));
    }
    throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
  }
  $removeSession(providerId, sessionId) {
    const providerData = this._authenticationProviders.get(providerId);
    if (providerData) {
      return Promise.resolve(providerData.provider.removeSession(sessionId));
    }
    throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
  }
  $getSessions(providerId, scopes) {
    const providerData = this._authenticationProviders.get(providerId);
    if (providerData) {
      return Promise.resolve(providerData.provider.getSessions(scopes));
    }
    throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
  }
  $onDidChangeAuthenticationSessions(id, label) {
    this._onDidChangeSessions.fire({ provider: { id, label } });
    return Promise.resolve();
  }
};
var TaskSingler = class {
  constructor() {
    this._inFlightPromises = /* @__PURE__ */ new Map();
  }
  getOrCreate(key, promiseFactory) {
    const inFlight = this._inFlightPromises.get(key);
    if (inFlight) {
      return inFlight;
    }
    const promise = promiseFactory().finally(() => this._inFlightPromises.delete(key));
    this._inFlightPromises.set(key, promise);
    return promise;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTimeline.js
init_uri();
init_extHost_protocol();
init_lifecycle();
init_extHostTypes();
init_extensions();
init_types();
var ExtHostTimeline = class {
  constructor(mainContext, commands) {
    this._providers = /* @__PURE__ */ new Map();
    this._itemsBySourceAndUriMap = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadTimeline);
    commands.registerArgumentProcessor({
      processArgument: (arg, extension) => {
        var _a30, _b, _c;
        if (arg && arg.$mid === 12) {
          if (this._providers.get(arg.source) && ExtensionIdentifier.equals(extension, (_a30 = this._providers.get(arg.source)) == null ? void 0 : _a30.extension)) {
            const uri = arg.uri === void 0 ? void 0 : URI.revive(arg.uri);
            return (_c = (_b = this._itemsBySourceAndUriMap.get(arg.source)) == null ? void 0 : _b.get(getUriKey(uri))) == null ? void 0 : _c.get(arg.handle);
          } else {
            return void 0;
          }
        }
        return arg;
      }
    });
  }
  async $getTimeline(id, uri, options, token) {
    const item = this._providers.get(id);
    return item == null ? void 0 : item.provider.provideTimeline(URI.revive(uri), options, token);
  }
  registerTimelineProvider(scheme, provider, extensionId, commandConverter) {
    const timelineDisposables = new DisposableStore();
    const convertTimelineItem = this.convertTimelineItem(provider.id, commandConverter, timelineDisposables).bind(this);
    let disposable;
    if (provider.onDidChange) {
      disposable = provider.onDidChange((e) => this._proxy.$emitTimelineChangeEvent({ uri: void 0, reset: true, ...e, id: provider.id }), this);
    }
    const itemsBySourceAndUriMap = this._itemsBySourceAndUriMap;
    return this.registerTimelineProviderCore({
      ...provider,
      scheme,
      onDidChange: void 0,
      async provideTimeline(uri, options, token) {
        var _a30;
        if (options == null ? void 0 : options.resetCache) {
          timelineDisposables.clear();
          (_a30 = itemsBySourceAndUriMap.get(provider.id)) == null ? void 0 : _a30.clear();
        }
        const result = await provider.provideTimeline(uri, options, token);
        if (result === void 0 || result === null) {
          return void 0;
        }
        const convertItem = convertTimelineItem(uri, options);
        return {
          ...result,
          source: provider.id,
          items: result.items.map(convertItem)
        };
      },
      dispose() {
        var _a30;
        for (const sourceMap of itemsBySourceAndUriMap.values()) {
          (_a30 = sourceMap.get(provider.id)) == null ? void 0 : _a30.clear();
        }
        disposable == null ? void 0 : disposable.dispose();
        timelineDisposables.dispose();
      }
    }, extensionId);
  }
  convertTimelineItem(source, commandConverter, disposables) {
    return (uri, options) => {
      let items;
      if (options == null ? void 0 : options.cacheResults) {
        let itemsByUri = this._itemsBySourceAndUriMap.get(source);
        if (itemsByUri === void 0) {
          itemsByUri = /* @__PURE__ */ new Map();
          this._itemsBySourceAndUriMap.set(source, itemsByUri);
        }
        const uriKey = getUriKey(uri);
        items = itemsByUri.get(uriKey);
        if (items === void 0) {
          items = /* @__PURE__ */ new Map();
          itemsByUri.set(uriKey, items);
        }
      }
      return (item) => {
        const { iconPath, ...props } = item;
        const handle = `${source}|${item.id ?? item.timestamp}`;
        items == null ? void 0 : items.set(handle, item);
        let icon;
        let iconDark;
        let themeIcon;
        if (item.iconPath) {
          if (iconPath instanceof ThemeIcon2) {
            themeIcon = { id: iconPath.id, color: iconPath.color };
          } else if (URI.isUri(iconPath)) {
            icon = iconPath;
            iconDark = iconPath;
          } else {
            ({ light: icon, dark: iconDark } = iconPath);
          }
        }
        let tooltip;
        if (MarkdownString2.isMarkdownString(props.tooltip)) {
          tooltip = MarkdownString3.from(props.tooltip);
        } else if (isString(props.tooltip)) {
          tooltip = props.tooltip;
        } else if (MarkdownString2.isMarkdownString(props.detail)) {
          console.warn("Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip");
          tooltip = MarkdownString3.from(props.detail);
        } else if (isString(props.detail)) {
          console.warn("Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip");
          tooltip = props.detail;
        }
        return {
          ...props,
          id: props.id ?? void 0,
          handle,
          source,
          command: item.command ? commandConverter.toInternal(item.command, disposables) : void 0,
          icon,
          iconDark,
          themeIcon,
          tooltip,
          accessibilityInformation: item.accessibilityInformation
        };
      };
    };
  }
  registerTimelineProviderCore(provider, extension) {
    const existing = this._providers.get(provider.id);
    if (existing) {
      throw new Error(`Timeline Provider ${provider.id} already exists.`);
    }
    this._proxy.$registerTimelineProvider({
      id: provider.id,
      label: provider.label,
      scheme: provider.scheme
    });
    this._providers.set(provider.id, { provider, extension });
    return toDisposable(() => {
      var _a30;
      for (const sourceMap of this._itemsBySourceAndUriMap.values()) {
        (_a30 = sourceMap.get(provider.id)) == null ? void 0 : _a30.clear();
      }
      this._providers.delete(provider.id);
      this._proxy.$unregisterTimelineProvider(provider.id);
      provider.dispose();
    });
  }
};
function getUriKey(uri) {
  return uri == null ? void 0 : uri.toString();
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWebviewView.js
init_event();
init_lifecycle();
init_extHost_protocol();
init_extHostTypes();
var _handle2, _proxy7, _viewType, _webview, _isDisposed2, _isVisible, _title, _description, _badge, _onDidChangeVisibility, _onDidDispose;
var ExtHostWebviewView = class extends Disposable {
  constructor(handle, proxy, viewType, title, webview, isVisible) {
    super();
    __privateAdd(this, _handle2, void 0);
    __privateAdd(this, _proxy7, void 0);
    __privateAdd(this, _viewType, void 0);
    __privateAdd(this, _webview, void 0);
    __privateAdd(this, _isDisposed2, void 0);
    __privateAdd(this, _isVisible, void 0);
    __privateAdd(this, _title, void 0);
    __privateAdd(this, _description, void 0);
    __privateAdd(this, _badge, void 0);
    __privateAdd(this, _onDidChangeVisibility, void 0);
    __privateAdd(this, _onDidDispose, void 0);
    __privateSet(this, _isDisposed2, false);
    __privateSet(this, _onDidChangeVisibility, this._register(new Emitter()));
    this.onDidChangeVisibility = __privateGet(this, _onDidChangeVisibility).event;
    __privateSet(this, _onDidDispose, this._register(new Emitter()));
    this.onDidDispose = __privateGet(this, _onDidDispose).event;
    __privateSet(this, _viewType, viewType);
    __privateSet(this, _title, title);
    __privateSet(this, _handle2, handle);
    __privateSet(this, _proxy7, proxy);
    __privateSet(this, _webview, webview);
    __privateSet(this, _isVisible, isVisible);
  }
  dispose() {
    if (__privateGet(this, _isDisposed2)) {
      return;
    }
    __privateSet(this, _isDisposed2, true);
    __privateGet(this, _onDidDispose).fire();
    __privateGet(this, _webview).dispose();
    super.dispose();
  }
  get title() {
    this.assertNotDisposed();
    return __privateGet(this, _title);
  }
  set title(value) {
    this.assertNotDisposed();
    if (__privateGet(this, _title) !== value) {
      __privateSet(this, _title, value);
      __privateGet(this, _proxy7).$setWebviewViewTitle(__privateGet(this, _handle2), value);
    }
  }
  get description() {
    this.assertNotDisposed();
    return __privateGet(this, _description);
  }
  set description(value) {
    this.assertNotDisposed();
    if (__privateGet(this, _description) !== value) {
      __privateSet(this, _description, value);
      __privateGet(this, _proxy7).$setWebviewViewDescription(__privateGet(this, _handle2), value);
    }
  }
  get visible() {
    return __privateGet(this, _isVisible);
  }
  get webview() {
    return __privateGet(this, _webview);
  }
  get viewType() {
    return __privateGet(this, _viewType);
  }
  _setVisible(visible) {
    if (visible === __privateGet(this, _isVisible) || __privateGet(this, _isDisposed2)) {
      return;
    }
    __privateSet(this, _isVisible, visible);
    __privateGet(this, _onDidChangeVisibility).fire();
  }
  get badge() {
    this.assertNotDisposed();
    return __privateGet(this, _badge);
  }
  set badge(badge) {
    var _a30, _b;
    this.assertNotDisposed();
    if ((badge == null ? void 0 : badge.value) === ((_a30 = __privateGet(this, _badge)) == null ? void 0 : _a30.value) && (badge == null ? void 0 : badge.tooltip) === ((_b = __privateGet(this, _badge)) == null ? void 0 : _b.tooltip)) {
      return;
    }
    __privateSet(this, _badge, ViewBadge2.from(badge));
    __privateGet(this, _proxy7).$setWebviewViewBadge(__privateGet(this, _handle2), badge);
  }
  show(preserveFocus) {
    this.assertNotDisposed();
    __privateGet(this, _proxy7).$show(__privateGet(this, _handle2), !!preserveFocus);
  }
  assertNotDisposed() {
    if (__privateGet(this, _isDisposed2)) {
      throw new Error("Webview is disposed");
    }
  }
};
_handle2 = new WeakMap();
_proxy7 = new WeakMap();
_viewType = new WeakMap();
_webview = new WeakMap();
_isDisposed2 = new WeakMap();
_isVisible = new WeakMap();
_title = new WeakMap();
_description = new WeakMap();
_badge = new WeakMap();
_onDidChangeVisibility = new WeakMap();
_onDidDispose = new WeakMap();
var ExtHostWebviewViews = class {
  constructor(mainContext, _extHostWebview) {
    this._extHostWebview = _extHostWebview;
    this._viewProviders = /* @__PURE__ */ new Map();
    this._webviewViews = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadWebviewViews);
  }
  registerWebviewViewProvider(extension, viewType, provider, webviewOptions) {
    if (this._viewProviders.has(viewType)) {
      throw new Error(`View provider for '${viewType}' already registered`);
    }
    this._viewProviders.set(viewType, { provider, extension });
    this._proxy.$registerWebviewViewProvider(toExtensionData(extension), viewType, {
      retainContextWhenHidden: webviewOptions == null ? void 0 : webviewOptions.retainContextWhenHidden,
      serializeBuffersForPostMessage: shouldSerializeBuffersForPostMessage(extension)
    });
    return new Disposable2(() => {
      this._viewProviders.delete(viewType);
      this._proxy.$unregisterWebviewViewProvider(viewType);
    });
  }
  async $resolveWebviewView(webviewHandle, viewType, title, state, cancellation) {
    const entry = this._viewProviders.get(viewType);
    if (!entry) {
      throw new Error(`No view provider found for '${viewType}'`);
    }
    const { provider, extension } = entry;
    const webview = this._extHostWebview.createNewWebview(webviewHandle, {}, extension);
    const revivedView = new ExtHostWebviewView(webviewHandle, this._proxy, viewType, title, webview, true);
    this._webviewViews.set(webviewHandle, revivedView);
    await provider.resolveWebviewView(revivedView, { state }, cancellation);
  }
  async $onDidChangeWebviewViewVisibility(webviewHandle, visible) {
    const webviewView = this.getWebviewView(webviewHandle);
    webviewView._setVisible(visible);
  }
  async $disposeWebviewView(webviewHandle) {
    const webviewView = this.getWebviewView(webviewHandle);
    this._webviewViews.delete(webviewHandle);
    webviewView.dispose();
    this._extHostWebview.deleteWebview(webviewHandle);
  }
  getWebviewView(handle) {
    const entry = this._webviewViews.get(handle);
    if (!entry) {
      throw new Error("No webview found");
    }
    return entry;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostCustomEditors.js
init_cancellation();
init_hash();
init_lifecycle();
init_network();
init_resources();
init_uri();
init_extHost_protocol();
init_extHostTypes();
var CustomDocumentStoreEntry = class {
  constructor(document2, _storagePath) {
    this.document = document2;
    this._storagePath = _storagePath;
    this._backupCounter = 1;
    this._edits = new Cache("custom documents");
  }
  addEdit(item) {
    return this._edits.add([item]);
  }
  async undo(editId, isDirty) {
    await this.getEdit(editId).undo();
    if (!isDirty) {
      this.disposeBackup();
    }
  }
  async redo(editId, isDirty) {
    await this.getEdit(editId).redo();
    if (!isDirty) {
      this.disposeBackup();
    }
  }
  disposeEdits(editIds) {
    for (const id of editIds) {
      this._edits.delete(id);
    }
  }
  getNewBackupUri() {
    if (!this._storagePath) {
      throw new Error("Backup requires a valid storage path");
    }
    const fileName = hashPath(this.document.uri) + this._backupCounter++;
    return joinPath(this._storagePath, fileName);
  }
  updateBackup(backup) {
    var _a30;
    (_a30 = this._backup) == null ? void 0 : _a30.delete();
    this._backup = backup;
  }
  disposeBackup() {
    var _a30;
    (_a30 = this._backup) == null ? void 0 : _a30.delete();
    this._backup = void 0;
  }
  getEdit(editId) {
    const edit = this._edits.get(editId, 0);
    if (!edit) {
      throw new Error("No edit found");
    }
    return edit;
  }
};
var CustomDocumentStore = class {
  constructor() {
    this._documents = /* @__PURE__ */ new Map();
  }
  get(viewType, resource) {
    return this._documents.get(this.key(viewType, resource));
  }
  add(viewType, document2, storagePath) {
    const key = this.key(viewType, document2.uri);
    if (this._documents.has(key)) {
      throw new Error(`Document already exists for viewType:${viewType} resource:${document2.uri}`);
    }
    const entry = new CustomDocumentStoreEntry(document2, storagePath);
    this._documents.set(key, entry);
    return entry;
  }
  delete(viewType, document2) {
    const key = this.key(viewType, document2.uri);
    this._documents.delete(key);
  }
  key(viewType, resource) {
    return `${viewType}@@@${resource}`;
  }
};
var EditorProviderStore = class {
  constructor() {
    this._providers = /* @__PURE__ */ new Map();
  }
  addTextProvider(viewType, extension, provider) {
    return this.add(0, viewType, extension, provider);
  }
  addCustomProvider(viewType, extension, provider) {
    return this.add(1, viewType, extension, provider);
  }
  get(viewType) {
    return this._providers.get(viewType);
  }
  add(type, viewType, extension, provider) {
    if (this._providers.has(viewType)) {
      throw new Error(`Provider for viewType:${viewType} already registered`);
    }
    this._providers.set(viewType, { type, extension, provider });
    return new Disposable2(() => this._providers.delete(viewType));
  }
};
var ExtHostCustomEditors = class {
  constructor(mainContext, _extHostDocuments2, _extensionStoragePaths, _extHostWebview, _extHostWebviewPanels) {
    this._extHostDocuments = _extHostDocuments2;
    this._extensionStoragePaths = _extensionStoragePaths;
    this._extHostWebview = _extHostWebview;
    this._extHostWebviewPanels = _extHostWebviewPanels;
    this._editorProviders = new EditorProviderStore();
    this._documents = new CustomDocumentStore();
    this._proxy = mainContext.getProxy(MainContext.MainThreadCustomEditors);
  }
  registerCustomEditorProvider(extension, viewType, provider, options) {
    const disposables = new DisposableStore();
    if (isCustomTextEditorProvider(provider)) {
      disposables.add(this._editorProviders.addTextProvider(viewType, extension, provider));
      this._proxy.$registerTextEditorProvider(toExtensionData(extension), viewType, options.webviewOptions || {}, {
        supportsMove: !!provider.moveCustomTextEditor
      }, shouldSerializeBuffersForPostMessage(extension));
    } else {
      disposables.add(this._editorProviders.addCustomProvider(viewType, extension, provider));
      if (isCustomEditorProviderWithEditingCapability(provider)) {
        disposables.add(provider.onDidChangeCustomDocument((e) => {
          const entry = this.getCustomDocumentEntry(viewType, e.document.uri);
          if (isEditEvent(e)) {
            const editId = entry.addEdit(e);
            this._proxy.$onDidEdit(e.document.uri, viewType, editId, e.label);
          } else {
            this._proxy.$onContentChange(e.document.uri, viewType);
          }
        }));
      }
      this._proxy.$registerCustomEditorProvider(toExtensionData(extension), viewType, options.webviewOptions || {}, !!options.supportsMultipleEditorsPerDocument, shouldSerializeBuffersForPostMessage(extension));
    }
    return Disposable2.from(disposables, new Disposable2(() => {
      this._proxy.$unregisterEditorProvider(viewType);
    }));
  }
  async $createCustomDocument(resource, viewType, backupId, untitledDocumentData, cancellation) {
    const entry = this._editorProviders.get(viewType);
    if (!entry) {
      throw new Error(`No provider found for '${viewType}'`);
    }
    if (entry.type !== 1) {
      throw new Error(`Invalid provide type for '${viewType}'`);
    }
    const revivedResource = URI.revive(resource);
    const document2 = await entry.provider.openCustomDocument(revivedResource, { backupId, untitledDocumentData: untitledDocumentData == null ? void 0 : untitledDocumentData.buffer }, cancellation);
    let storageRoot;
    if (isCustomEditorProviderWithEditingCapability(entry.provider) && this._extensionStoragePaths) {
      storageRoot = this._extensionStoragePaths.workspaceValue(entry.extension) ?? this._extensionStoragePaths.globalValue(entry.extension);
    }
    this._documents.add(viewType, document2, storageRoot);
    return { editable: isCustomEditorProviderWithEditingCapability(entry.provider) };
  }
  async $disposeCustomDocument(resource, viewType) {
    const entry = this._editorProviders.get(viewType);
    if (!entry) {
      throw new Error(`No provider found for '${viewType}'`);
    }
    if (entry.type !== 1) {
      throw new Error(`Invalid provider type for '${viewType}'`);
    }
    const revivedResource = URI.revive(resource);
    const { document: document2 } = this.getCustomDocumentEntry(viewType, revivedResource);
    this._documents.delete(viewType, document2);
    document2.dispose();
  }
  async $resolveCustomEditor(resource, handle, viewType, initData, position, cancellation) {
    const entry = this._editorProviders.get(viewType);
    if (!entry) {
      throw new Error(`No provider found for '${viewType}'`);
    }
    const viewColumn = ViewColumn2.to(position);
    const webview = this._extHostWebview.createNewWebview(handle, initData.contentOptions, entry.extension);
    const panel = this._extHostWebviewPanels.createNewWebviewPanel(handle, viewType, initData.title, viewColumn, initData.options, webview, initData.active);
    const revivedResource = URI.revive(resource);
    switch (entry.type) {
      case 1: {
        const { document: document2 } = this.getCustomDocumentEntry(viewType, revivedResource);
        return entry.provider.resolveCustomEditor(document2, panel, cancellation);
      }
      case 0: {
        const document2 = this._extHostDocuments.getDocument(revivedResource);
        return entry.provider.resolveCustomTextEditor(document2, panel, cancellation);
      }
      default: {
        throw new Error("Unknown webview provider type");
      }
    }
  }
  $disposeEdits(resourceComponents, viewType, editIds) {
    const document2 = this.getCustomDocumentEntry(viewType, resourceComponents);
    document2.disposeEdits(editIds);
  }
  async $onMoveCustomEditor(handle, newResourceComponents, viewType) {
    const entry = this._editorProviders.get(viewType);
    if (!entry) {
      throw new Error(`No provider found for '${viewType}'`);
    }
    if (!entry.provider.moveCustomTextEditor) {
      throw new Error(`Provider does not implement move '${viewType}'`);
    }
    const webview = this._extHostWebviewPanels.getWebviewPanel(handle);
    if (!webview) {
      throw new Error(`No webview found`);
    }
    const resource = URI.revive(newResourceComponents);
    const document2 = this._extHostDocuments.getDocument(resource);
    await entry.provider.moveCustomTextEditor(document2, webview, CancellationToken.None);
  }
  async $undo(resourceComponents, viewType, editId, isDirty) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    return entry.undo(editId, isDirty);
  }
  async $redo(resourceComponents, viewType, editId, isDirty) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    return entry.redo(editId, isDirty);
  }
  async $revert(resourceComponents, viewType, cancellation) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    const provider = this.getCustomEditorProvider(viewType);
    await provider.revertCustomDocument(entry.document, cancellation);
    entry.disposeBackup();
  }
  async $onSave(resourceComponents, viewType, cancellation) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    const provider = this.getCustomEditorProvider(viewType);
    await provider.saveCustomDocument(entry.document, cancellation);
    entry.disposeBackup();
  }
  async $onSaveAs(resourceComponents, viewType, targetResource, cancellation) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    const provider = this.getCustomEditorProvider(viewType);
    return provider.saveCustomDocumentAs(entry.document, URI.revive(targetResource), cancellation);
  }
  async $backup(resourceComponents, viewType, cancellation) {
    const entry = this.getCustomDocumentEntry(viewType, resourceComponents);
    const provider = this.getCustomEditorProvider(viewType);
    const backup = await provider.backupCustomDocument(entry.document, {
      destination: entry.getNewBackupUri()
    }, cancellation);
    entry.updateBackup(backup);
    return backup.id;
  }
  getCustomDocumentEntry(viewType, resource) {
    const entry = this._documents.get(viewType, URI.revive(resource));
    if (!entry) {
      throw new Error("No custom document found");
    }
    return entry;
  }
  getCustomEditorProvider(viewType) {
    const entry = this._editorProviders.get(viewType);
    const provider = entry == null ? void 0 : entry.provider;
    if (!provider || !isCustomEditorProviderWithEditingCapability(provider)) {
      throw new Error("Custom document is not editable");
    }
    return provider;
  }
};
function isCustomEditorProviderWithEditingCapability(provider) {
  return !!provider.onDidChangeCustomDocument;
}
function isCustomTextEditorProvider(provider) {
  return typeof provider.resolveCustomTextEditor === "function";
}
function isEditEvent(e) {
  return typeof e.undo === "function" && typeof e.redo === "function";
}
function hashPath(resource) {
  const str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();
  return hash(str) + "";
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWebviewPanels.js
init_event();
init_lifecycle();
init_uri();
init_uuid();
init_extHost_protocol();
init_extHostTypes();
var _handle3, _proxy8, _viewType2, _webview2, _options2, _title2, _iconPath, _viewColumn, _visible, _active, _isDisposed3, _onDidDispose2, _onDidChangeViewState;
var ExtHostWebviewPanel = class extends Disposable {
  constructor(handle, proxy, webview, params) {
    super();
    __privateAdd(this, _handle3, void 0);
    __privateAdd(this, _proxy8, void 0);
    __privateAdd(this, _viewType2, void 0);
    __privateAdd(this, _webview2, void 0);
    __privateAdd(this, _options2, void 0);
    __privateAdd(this, _title2, void 0);
    __privateAdd(this, _iconPath, void 0);
    __privateAdd(this, _viewColumn, void 0);
    __privateAdd(this, _visible, void 0);
    __privateAdd(this, _active, void 0);
    __privateAdd(this, _isDisposed3, void 0);
    __privateAdd(this, _onDidDispose2, void 0);
    __privateAdd(this, _onDidChangeViewState, void 0);
    __privateSet(this, _viewColumn, void 0);
    __privateSet(this, _visible, true);
    __privateSet(this, _isDisposed3, false);
    __privateSet(this, _onDidDispose2, this._register(new Emitter()));
    this.onDidDispose = __privateGet(this, _onDidDispose2).event;
    __privateSet(this, _onDidChangeViewState, this._register(new Emitter()));
    this.onDidChangeViewState = __privateGet(this, _onDidChangeViewState).event;
    __privateSet(this, _handle3, handle);
    __privateSet(this, _proxy8, proxy);
    __privateSet(this, _webview2, webview);
    __privateSet(this, _viewType2, params.viewType);
    __privateSet(this, _options2, params.panelOptions);
    __privateSet(this, _viewColumn, params.viewColumn);
    __privateSet(this, _title2, params.title);
    __privateSet(this, _active, params.active);
  }
  dispose() {
    if (__privateGet(this, _isDisposed3)) {
      return;
    }
    __privateSet(this, _isDisposed3, true);
    __privateGet(this, _onDidDispose2).fire();
    __privateGet(this, _proxy8).$disposeWebview(__privateGet(this, _handle3));
    __privateGet(this, _webview2).dispose();
    super.dispose();
  }
  get webview() {
    this.assertNotDisposed();
    return __privateGet(this, _webview2);
  }
  get viewType() {
    this.assertNotDisposed();
    return __privateGet(this, _viewType2);
  }
  get title() {
    this.assertNotDisposed();
    return __privateGet(this, _title2);
  }
  set title(value) {
    this.assertNotDisposed();
    if (__privateGet(this, _title2) !== value) {
      __privateSet(this, _title2, value);
      __privateGet(this, _proxy8).$setTitle(__privateGet(this, _handle3), value);
    }
  }
  get iconPath() {
    this.assertNotDisposed();
    return __privateGet(this, _iconPath);
  }
  set iconPath(value) {
    this.assertNotDisposed();
    if (__privateGet(this, _iconPath) !== value) {
      __privateSet(this, _iconPath, value);
      __privateGet(this, _proxy8).$setIconPath(__privateGet(this, _handle3), URI.isUri(value) ? { light: value, dark: value } : value);
    }
  }
  get options() {
    return __privateGet(this, _options2);
  }
  get viewColumn() {
    this.assertNotDisposed();
    if (typeof __privateGet(this, _viewColumn) === "number" && __privateGet(this, _viewColumn) < 0) {
      return void 0;
    }
    return __privateGet(this, _viewColumn);
  }
  get active() {
    this.assertNotDisposed();
    return __privateGet(this, _active);
  }
  get visible() {
    this.assertNotDisposed();
    return __privateGet(this, _visible);
  }
  _updateViewState(newState) {
    if (__privateGet(this, _isDisposed3)) {
      return;
    }
    if (this.active !== newState.active || this.visible !== newState.visible || this.viewColumn !== newState.viewColumn) {
      __privateSet(this, _active, newState.active);
      __privateSet(this, _visible, newState.visible);
      __privateSet(this, _viewColumn, newState.viewColumn);
      __privateGet(this, _onDidChangeViewState).fire({ webviewPanel: this });
    }
  }
  reveal(viewColumn, preserveFocus) {
    this.assertNotDisposed();
    __privateGet(this, _proxy8).$reveal(__privateGet(this, _handle3), {
      viewColumn: typeof viewColumn === "undefined" ? void 0 : ViewColumn2.from(viewColumn),
      preserveFocus: !!preserveFocus
    });
  }
  assertNotDisposed() {
    if (__privateGet(this, _isDisposed3)) {
      throw new Error("Webview is disposed");
    }
  }
};
_handle3 = new WeakMap();
_proxy8 = new WeakMap();
_viewType2 = new WeakMap();
_webview2 = new WeakMap();
_options2 = new WeakMap();
_title2 = new WeakMap();
_iconPath = new WeakMap();
_viewColumn = new WeakMap();
_visible = new WeakMap();
_active = new WeakMap();
_isDisposed3 = new WeakMap();
_onDidDispose2 = new WeakMap();
_onDidChangeViewState = new WeakMap();
var ExtHostWebviewPanels = class _ExtHostWebviewPanels {
  static newHandle() {
    return generateUuid();
  }
  constructor(mainContext, webviews, workspace) {
    this.webviews = webviews;
    this.workspace = workspace;
    this._webviewPanels = /* @__PURE__ */ new Map();
    this._serializers = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadWebviewPanels);
  }
  createWebviewPanel(extension, viewType, title, showOptions, options = {}) {
    const viewColumn = typeof showOptions === "object" ? showOptions.viewColumn : showOptions;
    const webviewShowOptions = {
      viewColumn: ViewColumn2.from(viewColumn),
      preserveFocus: typeof showOptions === "object" && !!showOptions.preserveFocus
    };
    const serializeBuffersForPostMessage = shouldSerializeBuffersForPostMessage(extension);
    const handle = _ExtHostWebviewPanels.newHandle();
    this._proxy.$createWebviewPanel(toExtensionData(extension), handle, viewType, {
      title,
      panelOptions: serializeWebviewPanelOptions(options),
      webviewOptions: serializeWebviewOptions(extension, this.workspace, options),
      serializeBuffersForPostMessage
    }, webviewShowOptions);
    const webview = this.webviews.createNewWebview(handle, options, extension);
    const panel = this.createNewWebviewPanel(handle, viewType, title, viewColumn, options, webview, true);
    return panel;
  }
  $onDidChangeWebviewPanelViewStates(newStates) {
    const handles = Object.keys(newStates);
    handles.sort((a, b) => {
      const stateA = newStates[a];
      const stateB = newStates[b];
      if (stateA.active) {
        return 1;
      }
      if (stateB.active) {
        return -1;
      }
      return +stateA.visible - +stateB.visible;
    });
    for (const handle of handles) {
      const panel = this.getWebviewPanel(handle);
      if (!panel) {
        continue;
      }
      const newState = newStates[handle];
      panel._updateViewState({
        active: newState.active,
        visible: newState.visible,
        viewColumn: ViewColumn2.to(newState.position)
      });
    }
  }
  async $onDidDisposeWebviewPanel(handle) {
    const panel = this.getWebviewPanel(handle);
    panel == null ? void 0 : panel.dispose();
    this._webviewPanels.delete(handle);
    this.webviews.deleteWebview(handle);
  }
  registerWebviewPanelSerializer(extension, viewType, serializer) {
    if (this._serializers.has(viewType)) {
      throw new Error(`Serializer for '${viewType}' already registered`);
    }
    this._serializers.set(viewType, { serializer, extension });
    this._proxy.$registerSerializer(viewType, {
      serializeBuffersForPostMessage: shouldSerializeBuffersForPostMessage(extension)
    });
    return new Disposable2(() => {
      this._serializers.delete(viewType);
      this._proxy.$unregisterSerializer(viewType);
    });
  }
  async $deserializeWebviewPanel(webviewHandle, viewType, initData, position) {
    const entry = this._serializers.get(viewType);
    if (!entry) {
      throw new Error(`No serializer found for '${viewType}'`);
    }
    const { serializer, extension } = entry;
    const webview = this.webviews.createNewWebview(webviewHandle, initData.webviewOptions, extension);
    const revivedPanel = this.createNewWebviewPanel(webviewHandle, viewType, initData.title, position, initData.panelOptions, webview, initData.active);
    await serializer.deserializeWebviewPanel(revivedPanel, initData.state);
  }
  createNewWebviewPanel(webviewHandle, viewType, title, position, options, webview, active) {
    const panel = new ExtHostWebviewPanel(
      webviewHandle,
      this._proxy,
      webview,
      { viewType, title, viewColumn: position, panelOptions: options, active }
    );
    this._webviewPanels.set(webviewHandle, panel);
    return panel;
  }
  getWebviewPanel(handle) {
    return this._webviewPanels.get(handle);
  }
};
function serializeWebviewPanelOptions(options) {
  return {
    enableFindWidget: options.enableFindWidget,
    retainContextWhenHidden: options.retainContextWhenHidden
  };
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostBulkEdits.js
init_tslib_es6();
init_extHost_protocol();
var ExtHostBulkEdits = class ExtHostBulkEdits2 {
  constructor(extHostRpc, extHostDocumentsAndEditors) {
    this._proxy = extHostRpc.getProxy(MainContext.MainThreadBulkEdits);
    this._versionInformationProvider = {
      getTextDocumentVersion: (uri) => {
        var _a30;
        return (_a30 = extHostDocumentsAndEditors.getDocument(uri)) == null ? void 0 : _a30.version;
      },
      getNotebookDocumentVersion: () => void 0
    };
  }
  applyWorkspaceEdit(edit, extension, metadata) {
    const dto = WorkspaceEdit2.from(edit, this._versionInformationProvider);
    return this._proxy.$tryApplyWorkspaceEdit(dto, void 0, (metadata == null ? void 0 : metadata.isRefactoring) ?? false);
  }
};
ExtHostBulkEdits = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostBulkEdits);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTesting.js
init_tslib_es6();
init_arrays();
init_async();
init_buffer();
init_cancellation();
init_event();
init_functional();
init_hash();
init_lifecycle();
init_objects();
init_types();
init_uuid();
init_extHost_protocol();
init_extHostTypes();
var ExtHostTesting = class ExtHostTesting2 {
  constructor(rpc, commands, editors) {
    this.editors = editors;
    this.resultsChangedEmitter = new Emitter();
    this.controllers = /* @__PURE__ */ new Map();
    this.onResultsChanged = this.resultsChangedEmitter.event;
    this.results = [];
    this.proxy = rpc.getProxy(MainContext.MainThreadTesting);
    this.observer = new TestObservers(this.proxy);
    this.runTracker = new TestRunCoordinator(this.proxy);
    commands.registerArgumentProcessor({
      processArgument: (arg) => {
        var _a30, _b, _c;
        switch (arg == null ? void 0 : arg.$mid) {
          case 15: {
            const cast = arg;
            const targetTest = cast.tests[cast.tests.length - 1].item.extId;
            const controller = this.controllers.get(TestId.root(targetTest));
            return ((_a30 = controller == null ? void 0 : controller.collection.tree.get(targetTest)) == null ? void 0 : _a30.actual) ?? toItemFromContext(arg);
          }
          case 17: {
            const { extId, message } = arg;
            return {
              test: (_c = (_b = this.controllers.get(TestId.root(extId))) == null ? void 0 : _b.collection.tree.get(extId)) == null ? void 0 : _c.actual,
              message: TestMessage2.to(message)
            };
          }
          default:
            return arg;
        }
      }
    });
    commands.registerCommand(false, "testing.getExplorerSelection", async () => {
      const inner = await commands.executeCommand("_testing.getExplorerSelection");
      const lookup = (i) => {
        var _a30;
        const controller = this.controllers.get(TestId.root(i));
        if (!controller) {
          return void 0;
        }
        return TestId.isRoot(i) ? controller.controller : (_a30 = controller.collection.tree.get(i)) == null ? void 0 : _a30.actual;
      };
      return {
        include: (inner == null ? void 0 : inner.include.map(lookup).filter(isDefined)) || [],
        exclude: (inner == null ? void 0 : inner.exclude.map(lookup).filter(isDefined)) || []
      };
    });
  }
  createTestController(extension, controllerId, label, refreshHandler) {
    if (this.controllers.has(controllerId)) {
      throw new Error(`Attempt to insert a duplicate controller with ID "${controllerId}"`);
    }
    const disposable = new DisposableStore();
    const collection = disposable.add(new ExtHostTestItemCollection(controllerId, label, this.editors));
    collection.root.label = label;
    const profiles = /* @__PURE__ */ new Map();
    const proxy = this.proxy;
    const controller = {
      items: collection.root.children,
      get label() {
        return label;
      },
      set label(value) {
        label = value;
        collection.root.label = value;
        proxy.$updateController(controllerId, { label });
      },
      get refreshHandler() {
        return refreshHandler;
      },
      set refreshHandler(value) {
        refreshHandler = value;
        proxy.$updateController(controllerId, { canRefresh: !!value });
      },
      get id() {
        return controllerId;
      },
      createRunProfile: (label2, group, runHandler, isDefault, tag, supportsContinuousRun) => {
        let profileId = hash(label2);
        while (profiles.has(profileId)) {
          profileId++;
        }
        return new TestRunProfileImpl(
          this.proxy,
          profiles,
          controllerId,
          profileId,
          label2,
          group,
          runHandler,
          isDefault,
          tag,
          supportsContinuousRun
        );
      },
      createTestItem(id, label2, uri) {
        return new TestItemImpl(controllerId, id, label2, uri);
      },
      createTestRun: (request, name, persist = true) => {
        return this.runTracker.createTestRun(extension, controllerId, collection, request, name, persist);
      },
      invalidateTestResults: (items) => {
        if (items === void 0) {
          this.proxy.$markTestRetired(void 0);
        } else {
          const itemsArr = items instanceof Array ? items : [items];
          this.proxy.$markTestRetired(itemsArr.map((i) => TestId.fromExtHostTestItem(i, controllerId).toString()));
        }
      },
      set resolveHandler(fn) {
        collection.resolveHandler = fn;
      },
      get resolveHandler() {
        return collection.resolveHandler;
      },
      dispose: () => {
        disposable.dispose();
      }
    };
    proxy.$registerTestController(controllerId, label, !!refreshHandler);
    disposable.add(toDisposable(() => proxy.$unregisterTestController(controllerId)));
    const info = { controller, collection, profiles, extension };
    this.controllers.set(controllerId, info);
    disposable.add(toDisposable(() => this.controllers.delete(controllerId)));
    disposable.add(collection.onDidGenerateDiff((diff) => proxy.$publishDiff(controllerId, diff.map(TestsDiffOp.serialize))));
    return controller;
  }
  createTestObserver() {
    return this.observer.checkout();
  }
  async runTests(req, token = CancellationToken.None) {
    var _a30, _b;
    const profile = tryGetProfileFromTestRunReq(req);
    if (!profile) {
      throw new Error("The request passed to `vscode.test.runTests` must include a profile");
    }
    const controller = this.controllers.get(profile.controllerId);
    if (!controller) {
      throw new Error("Controller not found");
    }
    await this.proxy.$runTests({
      isUiTriggered: false,
      targets: [{
        testIds: ((_a30 = req.include) == null ? void 0 : _a30.map((t) => TestId.fromExtHostTestItem(t, controller.collection.root.id).toString())) ?? [controller.collection.root.id],
        profileGroup: profileGroupToBitset[profile.kind],
        profileId: profile.profileId,
        controllerId: profile.controllerId
      }],
      exclude: (_b = req.exclude) == null ? void 0 : _b.map((t) => t.id)
    }, token);
  }
  $syncTests() {
    for (const { collection } of this.controllers.values()) {
      collection.flushDiff();
    }
    return Promise.resolve();
  }
  $provideFileCoverage(runId, taskId, token) {
    const coverage = mapFind(this.runTracker.trackers, (t) => t.id === runId ? t.getCoverage(taskId) : void 0);
    return (coverage == null ? void 0 : coverage.provideFileCoverage(token)) ?? Promise.resolve([]);
  }
  $resolveFileCoverage(runId, taskId, fileIndex, token) {
    const coverage = mapFind(this.runTracker.trackers, (t) => t.id === runId ? t.getCoverage(taskId) : void 0);
    return (coverage == null ? void 0 : coverage.resolveFileCoverage(fileIndex, token)) ?? Promise.resolve([]);
  }
  $configureRunProfile(controllerId, profileId) {
    var _a30, _b, _c;
    (_c = (_b = (_a30 = this.controllers.get(controllerId)) == null ? void 0 : _a30.profiles.get(profileId)) == null ? void 0 : _b.configureHandler) == null ? void 0 : _c.call(_b);
  }
  async $refreshTests(controllerId, token) {
    var _a30, _b, _c;
    await ((_c = (_a30 = this.controllers.get(controllerId)) == null ? void 0 : (_b = _a30.controller).refreshHandler) == null ? void 0 : _c.call(_b, token));
  }
  $publishTestResults(results) {
    this.results = Object.freeze(results.map((r) => deepFreeze(TestResults.to(r))).concat(this.results).sort((a, b) => b.completedAt - a.completedAt).slice(0, 32));
    this.resultsChangedEmitter.fire();
  }
  async $expandTest(testId, levels) {
    var _a30;
    const collection = (_a30 = this.controllers.get(TestId.fromString(testId).controllerId)) == null ? void 0 : _a30.collection;
    if (collection) {
      await collection.expand(testId, levels < 0 ? Infinity : levels);
      collection.flushDiff();
    }
  }
  $acceptDiff(diff) {
    this.observer.applyDiff(diff.map(TestsDiffOp.deserialize));
  }
  async $runControllerTests(reqs, token) {
    return Promise.all(reqs.map((req) => this.runControllerTestRequest(req, false, token)));
  }
  async $startContinuousRun(reqs, token) {
    const cts = new CancellationTokenSource(token);
    const res = await Promise.all(reqs.map((req) => this.runControllerTestRequest(req, true, cts.token)));
    if (!token.isCancellationRequested && !res.some((r) => r.error)) {
      await new Promise((r) => token.onCancellationRequested(r));
    }
    cts.dispose(true);
    return res;
  }
  async runControllerTestRequest(req, isContinuous, token) {
    const lookup = this.controllers.get(req.controllerId);
    if (!lookup) {
      return {};
    }
    const { collection, profiles, extension } = lookup;
    const profile = profiles.get(req.profileId);
    if (!profile) {
      return {};
    }
    const includeTests = req.testIds.map((testId) => collection.tree.get(testId)).filter(isDefined);
    const excludeTests = req.excludeExtIds.map((id) => lookup.collection.tree.get(id)).filter(isDefined).filter((exclude) => includeTests.some(
      (include) => include.fullId.compare(exclude.fullId) === 2
    ));
    if (!includeTests.length) {
      return {};
    }
    const publicReq = new TestRunRequest(includeTests.some((i) => i.actual instanceof TestItemRootImpl) ? void 0 : includeTests.map((t) => t.actual), excludeTests.map((t) => t.actual), profile, isContinuous);
    const tracker = isStartControllerTests(req) && this.runTracker.prepareForMainThreadTestRun(publicReq, TestRunDto.fromInternal(req, lookup.collection), extension, token);
    try {
      await profile.runHandler(publicReq, token);
      return {};
    } catch (e) {
      return { error: String(e) };
    } finally {
      if (tracker) {
        if (tracker.hasRunningTasks && !token.isCancellationRequested) {
          await Event.toPromise(tracker.onEnd);
        }
        tracker.dispose();
      }
    }
  }
  $cancelExtensionTestRun(runId) {
    if (runId === void 0) {
      this.runTracker.cancelAllRuns();
    } else {
      this.runTracker.cancelRunById(runId);
    }
  }
};
ExtHostTesting = __decorate([
  __param(0, IExtHostRpcService)
], ExtHostTesting);
var RUN_CANCEL_DEADLINE = 1e4;
var TestRunTracker = class extends Disposable {
  get hasRunningTasks() {
    return this.tasks.size > 0;
  }
  get id() {
    return this.dto.id;
  }
  constructor(dto, proxy, extension, parentToken) {
    super();
    this.dto = dto;
    this.proxy = proxy;
    this.extension = extension;
    this.state = 0;
    this.tasks = /* @__PURE__ */ new Map();
    this.sharedTestIds = /* @__PURE__ */ new Set();
    this.endEmitter = this._register(new Emitter());
    this.onEnd = this.endEmitter.event;
    this.cts = this._register(new CancellationTokenSource(parentToken));
    const forciblyEnd = this._register(new RunOnceScheduler(() => this.forciblyEndTasks(), RUN_CANCEL_DEADLINE));
    this._register(this.cts.token.onCancellationRequested(() => forciblyEnd.schedule()));
  }
  cancel() {
    if (this.state === 0) {
      this.cts.cancel();
      this.state = 1;
    } else if (this.state === 1) {
      this.forciblyEndTasks();
    }
  }
  getCoverage(taskId) {
    var _a30;
    return (_a30 = this.tasks.get(taskId)) == null ? void 0 : _a30.coverage;
  }
  createRun(name) {
    const runId = this.dto.id;
    const ctrlId = this.dto.controllerId;
    const taskId = generateUuid();
    const coverage = new TestRunCoverageBearer(this.proxy, runId, taskId);
    const guardTestMutation = (fn) => (test, ...args) => {
      if (ended) {
        console.warn(`Setting the state of test "${test.id}" is a no-op after the run ends.`);
        return;
      }
      if (!this.dto.isIncluded(test)) {
        return;
      }
      this.ensureTestIsKnown(test);
      fn(test, ...args);
    };
    const appendMessages = (test, messages) => {
      const converted = messages instanceof Array ? messages.map(TestMessage2.from) : [TestMessage2.from(messages)];
      if (converted.some((c) => c.contextValue !== void 0)) {
        checkProposedApiEnabled(this.extension, "testMessageContextValue");
      }
      if (test.uri && test.range) {
        const defaultLocation = { range: Range3.from(test.range), uri: test.uri };
        for (const message of converted) {
          message.location = message.location || defaultLocation;
        }
      }
      this.proxy.$appendTestMessagesInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), converted);
    };
    let ended = false;
    const run = {
      isPersisted: this.dto.isPersisted,
      token: this.cts.token,
      name,
      get coverageProvider() {
        return coverage.coverageProvider;
      },
      set coverageProvider(provider) {
        coverage.coverageProvider = provider;
      },
      enqueued: guardTestMutation((test) => {
        this.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), 1);
      }),
      skipped: guardTestMutation((test) => {
        this.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), 5);
      }),
      started: guardTestMutation((test) => {
        this.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), 2);
      }),
      errored: guardTestMutation((test, messages, duration) => {
        appendMessages(test, messages);
        this.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), 6, duration);
      }),
      failed: guardTestMutation((test, messages, duration) => {
        appendMessages(test, messages);
        this.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), 4, duration);
      }),
      passed: guardTestMutation((test, duration) => {
        this.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, this.dto.controllerId).toString(), 3, duration);
      }),
      appendOutput: (output, location$1, test) => {
        if (ended) {
          return;
        }
        if (test) {
          if (this.dto.isIncluded(test)) {
            this.ensureTestIsKnown(test);
          } else {
            test = void 0;
          }
        }
        this.proxy.$appendOutputToRun(runId, taskId, VSBuffer.fromString(output), location$1 && location.from(location$1), test && TestId.fromExtHostTestItem(test, ctrlId).toString());
      },
      end: () => {
        if (ended) {
          return;
        }
        ended = true;
        this.proxy.$finishedTestRunTask(runId, taskId);
        this.tasks.delete(taskId);
        if (!this.tasks.size) {
          this.markEnded();
        }
      }
    };
    this.tasks.set(taskId, { run, coverage });
    this.proxy.$startedTestRunTask(runId, { id: taskId, name, running: true });
    return run;
  }
  forciblyEndTasks() {
    for (const { run } of this.tasks.values()) {
      run.end();
    }
  }
  markEnded() {
    if (this.state !== 2) {
      this.state = 2;
      this.endEmitter.fire();
    }
  }
  ensureTestIsKnown(test) {
    if (!(test instanceof TestItemImpl)) {
      throw new InvalidTestItemError(test.id);
    }
    if (this.sharedTestIds.has(TestId.fromExtHostTestItem(test, this.dto.controllerId).toString())) {
      return;
    }
    const chain = [];
    const root = this.dto.colllection.root;
    while (true) {
      const converted = TestItem.from(test);
      chain.unshift(converted);
      if (this.sharedTestIds.has(converted.extId)) {
        break;
      }
      this.sharedTestIds.add(converted.extId);
      if (test === root) {
        break;
      }
      test = test.parent || root;
    }
    this.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, chain);
  }
};
var TestRunCoordinator = class {
  get trackers() {
    return this.tracked.values();
  }
  constructor(proxy) {
    this.proxy = proxy;
    this.tracked = /* @__PURE__ */ new Map();
  }
  prepareForMainThreadTestRun(req, dto, extension, token) {
    return this.getTracker(req, dto, extension, token);
  }
  cancelRunById(runId) {
    for (const tracker of this.tracked.values()) {
      if (tracker.id === runId) {
        tracker.cancel();
        return;
      }
    }
  }
  cancelAllRuns() {
    for (const tracker of this.tracked.values()) {
      tracker.cancel();
    }
  }
  createTestRun(extension, controllerId, collection, request, name, persist) {
    var _a30, _b;
    const existing = this.tracked.get(request);
    if (existing) {
      return existing.createRun(name);
    }
    const dto = TestRunDto.fromPublic(controllerId, collection, request, persist);
    const profile = tryGetProfileFromTestRunReq(request);
    this.proxy.$startedExtensionTestRun({
      controllerId,
      continuous: !!request.continuous,
      profile: profile && { group: profileGroupToBitset[profile.kind], id: profile.profileId },
      exclude: ((_a30 = request.exclude) == null ? void 0 : _a30.map((t) => TestId.fromExtHostTestItem(t, collection.root.id).toString())) ?? [],
      id: dto.id,
      include: ((_b = request.include) == null ? void 0 : _b.map((t) => TestId.fromExtHostTestItem(t, collection.root.id).toString())) ?? [collection.root.id],
      persist
    });
    const tracker = this.getTracker(request, dto, extension);
    tracker.onEnd(() => {
      this.proxy.$finishedExtensionTestRun(dto.id);
      tracker.dispose();
    });
    return tracker.createRun(name);
  }
  getTracker(req, dto, extension, token) {
    const tracker = new TestRunTracker(dto, this.proxy, extension, token);
    this.tracked.set(req, tracker);
    tracker.onEnd(() => this.tracked.delete(req));
    return tracker;
  }
};
var tryGetProfileFromTestRunReq = (request) => {
  if (!request.profile) {
    return void 0;
  }
  if (!(request.profile instanceof TestRunProfileImpl)) {
    throw new Error(`TestRunRequest.profile is not an instance created from TestController.createRunProfile`);
  }
  return request.profile;
};
var TestRunDto = class _TestRunDto {
  static fromPublic(controllerId, collection, request, persist) {
    var _a30, _b;
    return new _TestRunDto(controllerId, generateUuid(), ((_a30 = request.include) == null ? void 0 : _a30.map((t) => TestId.fromExtHostTestItem(t, controllerId).toString())) ?? [controllerId], ((_b = request.exclude) == null ? void 0 : _b.map((t) => TestId.fromExtHostTestItem(t, controllerId).toString())) ?? [], persist, collection);
  }
  static fromInternal(request, collection) {
    return new _TestRunDto(
      request.controllerId,
      request.runId,
      request.testIds,
      request.excludeExtIds,
      true,
      collection
    );
  }
  constructor(controllerId, id, include, exclude, isPersisted, colllection) {
    this.controllerId = controllerId;
    this.id = id;
    this.isPersisted = isPersisted;
    this.colllection = colllection;
    this.includePrefix = include.map((id2) => id2 + "\0");
    this.excludePrefix = exclude.map((id2) => id2 + "\0");
  }
  isIncluded(test) {
    const id = TestId.fromExtHostTestItem(test, this.controllerId).toString() + "\0";
    for (const prefix of this.excludePrefix) {
      if (id === prefix || id.startsWith(prefix)) {
        return false;
      }
    }
    for (const prefix of this.includePrefix) {
      if (id === prefix || id.startsWith(prefix)) {
        return true;
      }
    }
    return false;
  }
};
var TestRunCoverageBearer = class {
  set coverageProvider(provider) {
    if (this._coverageProvider) {
      throw new Error("The TestCoverageProvider cannot be replaced after being provided");
    }
    if (!provider) {
      return;
    }
    this._coverageProvider = provider;
    this.proxy.$signalCoverageAvailable(this.runId, this.taskId);
  }
  get coverageProvider() {
    return this._coverageProvider;
  }
  constructor(proxy, runId, taskId) {
    this.proxy = proxy;
    this.runId = runId;
    this.taskId = taskId;
  }
  async provideFileCoverage(token) {
    if (!this._coverageProvider) {
      return [];
    }
    if (!this.fileCoverage) {
      this.fileCoverage = (async () => this._coverageProvider.provideFileCoverage(token))();
    }
    try {
      const coverage = await this.fileCoverage;
      return (coverage == null ? void 0 : coverage.map(TestCoverage.fromFile)) ?? [];
    } catch (e) {
      this.fileCoverage = void 0;
      throw e;
    }
  }
  async resolveFileCoverage(index, token) {
    var _a30, _b, _c;
    const fileCoverage = await this.fileCoverage;
    let file = fileCoverage == null ? void 0 : fileCoverage[index];
    if (!this._coverageProvider || !fileCoverage || !file) {
      return [];
    }
    if (!file.detailedCoverage) {
      file = fileCoverage[index] = await ((_b = (_a30 = this._coverageProvider).resolveFileCoverage) == null ? void 0 : _b.call(_a30, file, token)) ?? file;
    }
    return ((_c = file.detailedCoverage) == null ? void 0 : _c.map(TestCoverage.fromDetailed)) ?? [];
  }
};
var MirroredChangeCollector = class {
  get isEmpty() {
    return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;
  }
  constructor(emitter) {
    this.emitter = emitter;
    this.added = /* @__PURE__ */ new Set();
    this.updated = /* @__PURE__ */ new Set();
    this.removed = /* @__PURE__ */ new Set();
    this.alreadyRemoved = /* @__PURE__ */ new Set();
  }
  add(node) {
    this.added.add(node);
  }
  update(node) {
    Object.assign(node.revived, TestItem.toPlain(node.item));
    if (!this.added.has(node)) {
      this.updated.add(node);
    }
  }
  remove(node) {
    if (this.added.has(node)) {
      this.added.delete(node);
      return;
    }
    this.updated.delete(node);
    const parentId = TestId.parentId(node.item.extId);
    if (parentId && this.alreadyRemoved.has(parentId.toString())) {
      this.alreadyRemoved.add(node.item.extId);
      return;
    }
    this.removed.add(node);
  }
  getChangeEvent() {
    const { added, updated, removed } = this;
    return {
      get added() {
        return [...added].map((n2) => n2.revived);
      },
      get updated() {
        return [...updated].map((n2) => n2.revived);
      },
      get removed() {
        return [...removed].map((n2) => n2.revived);
      }
    };
  }
  complete() {
    if (!this.isEmpty) {
      this.emitter.fire(this.getChangeEvent());
    }
  }
};
var MirroredTestCollection = class extends AbstractIncrementalTestCollection {
  constructor() {
    super(...arguments);
    this.changeEmitter = new Emitter();
    this.onDidChangeTests = this.changeEmitter.event;
  }
  get rootTests() {
    return super.roots;
  }
  getMirroredTestDataById(itemId) {
    return this.items.get(itemId);
  }
  getMirroredTestDataByReference(item) {
    return this.items.get(item.id);
  }
  createItem(item, parent) {
    return {
      ...item,
      revived: TestItem.toPlain(item.item),
      depth: parent ? parent.depth + 1 : 0,
      children: /* @__PURE__ */ new Set()
    };
  }
  createChangeCollector() {
    return new MirroredChangeCollector(this.changeEmitter);
  }
};
var TestObservers = class {
  constructor(proxy) {
    this.proxy = proxy;
  }
  checkout() {
    if (!this.current) {
      this.current = this.createObserverData();
    }
    const current = this.current;
    current.observers++;
    return {
      onDidChangeTest: current.tests.onDidChangeTests,
      get tests() {
        return [...current.tests.rootTests].map((t) => t.revived);
      },
      dispose: once(() => {
        if (--current.observers === 0) {
          this.proxy.$unsubscribeFromDiffs();
          this.current = void 0;
        }
      })
    };
  }
  getMirroredTestDataByReference(ref) {
    var _a30;
    return (_a30 = this.current) == null ? void 0 : _a30.tests.getMirroredTestDataByReference(ref);
  }
  applyDiff(diff) {
    var _a30;
    (_a30 = this.current) == null ? void 0 : _a30.tests.apply(diff);
  }
  createObserverData() {
    const tests = new MirroredTestCollection();
    this.proxy.$subscribeToDiffs();
    return { observers: 0, tests };
  }
};
var _proxy9, _profiles;
var TestRunProfileImpl = class {
  constructor(proxy, profiles, controllerId, profileId, _label, kind, runHandler, _isDefault = false, _tag = void 0, _supportsContinuousRun = false) {
    __privateAdd(this, _proxy9, void 0);
    __privateAdd(this, _profiles, void 0);
    this.controllerId = controllerId;
    this.profileId = profileId;
    this._label = _label;
    this.kind = kind;
    this.runHandler = runHandler;
    this._isDefault = _isDefault;
    this._tag = _tag;
    this._supportsContinuousRun = _supportsContinuousRun;
    __privateSet(this, _proxy9, proxy);
    __privateSet(this, _profiles, profiles);
    profiles.set(profileId, this);
    const groupBitset = profileGroupToBitset[kind];
    if (typeof groupBitset !== "number") {
      throw new Error(`Unknown TestRunProfile.group ${kind}`);
    }
    __privateGet(this, _proxy9).$publishTestRunProfile({
      profileId,
      controllerId,
      tag: _tag ? TestTag2.namespace(this.controllerId, _tag.id) : null,
      label: _label,
      group: groupBitset,
      isDefault: _isDefault,
      hasConfigurationHandler: false,
      supportsContinuousRun: _supportsContinuousRun
    });
  }
  get label() {
    return this._label;
  }
  set label(label) {
    if (label !== this._label) {
      this._label = label;
      __privateGet(this, _proxy9).$updateTestRunConfig(this.controllerId, this.profileId, { label });
    }
  }
  get supportsContinuousRun() {
    return this._supportsContinuousRun;
  }
  set supportsContinuousRun(supports) {
    if (supports !== this._supportsContinuousRun) {
      this._supportsContinuousRun = supports;
      __privateGet(this, _proxy9).$updateTestRunConfig(this.controllerId, this.profileId, { supportsContinuousRun: supports });
    }
  }
  get isDefault() {
    return this._isDefault;
  }
  set isDefault(isDefault) {
    if (isDefault !== this._isDefault) {
      this._isDefault = isDefault;
      __privateGet(this, _proxy9).$updateTestRunConfig(this.controllerId, this.profileId, { isDefault });
    }
  }
  get tag() {
    return this._tag;
  }
  set tag(tag) {
    var _a30;
    if ((tag == null ? void 0 : tag.id) !== ((_a30 = this._tag) == null ? void 0 : _a30.id)) {
      this._tag = tag;
      __privateGet(this, _proxy9).$updateTestRunConfig(this.controllerId, this.profileId, {
        tag: tag ? TestTag2.namespace(this.controllerId, tag.id) : null
      });
    }
  }
  get configureHandler() {
    return this._configureHandler;
  }
  set configureHandler(handler) {
    if (handler !== this._configureHandler) {
      this._configureHandler = handler;
      __privateGet(this, _proxy9).$updateTestRunConfig(this.controllerId, this.profileId, { hasConfigurationHandler: !!handler });
    }
  }
  dispose() {
    var _a30;
    if ((_a30 = __privateGet(this, _profiles)) == null ? void 0 : _a30.delete(this.profileId)) {
      __privateSet(this, _profiles, void 0);
      __privateGet(this, _proxy9).$removeTestProfile(this.controllerId, this.profileId);
    }
  }
};
_proxy9 = new WeakMap();
_profiles = new WeakMap();
var profileGroupToBitset = {
  [TestRunProfileKind.Coverage]: 8,
  [TestRunProfileKind.Debug]: 4,
  [TestRunProfileKind.Run]: 2
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostUriOpener.js
init_lifecycle();
init_network();
init_uri();
init_extHost_protocol();
var _ExtHostUriOpeners = class _ExtHostUriOpeners {
  constructor(mainContext) {
    this._openers = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadUriOpeners);
  }
  registerExternalUriOpener(extensionId, id, opener, metadata) {
    if (this._openers.has(id)) {
      throw new Error(`Opener with id '${id}' already registered`);
    }
    const invalidScheme = metadata.schemes.find((scheme) => !_ExtHostUriOpeners.supportedSchemes.has(scheme));
    if (invalidScheme) {
      throw new Error(`Scheme '${invalidScheme}' is not supported. Only http and https are currently supported.`);
    }
    this._openers.set(id, opener);
    this._proxy.$registerUriOpener(id, metadata.schemes, extensionId, metadata.label);
    return toDisposable(() => {
      this._openers.delete(id);
      this._proxy.$unregisterUriOpener(id);
    });
  }
  async $canOpenUri(id, uriComponents, token) {
    const opener = this._openers.get(id);
    if (!opener) {
      throw new Error(`Unknown opener with id: ${id}`);
    }
    const uri = URI.revive(uriComponents);
    return opener.canOpenExternalUri(uri, token);
  }
  async $openUri(id, context, token) {
    const opener = this._openers.get(id);
    if (!opener) {
      throw new Error(`Unknown opener id: '${id}'`);
    }
    return opener.openExternalUri(URI.revive(context.resolvedUri), {
      sourceUri: URI.revive(context.sourceUri)
    }, token);
  }
};
_ExtHostUriOpeners.supportedSchemes = /* @__PURE__ */ new Set([Schemas.http, Schemas.https]);
var ExtHostUriOpeners = _ExtHostUriOpeners;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookKernels.js
init_tslib_es6();
init_arrays();
init_async();
init_cancellation();
init_event();
init_lifecycle();
init_map();
init_uri();
init_extensions();
init_log();
init_extHost_protocol();
init_extHostTypes();

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookExecutionService.js
var CellExecutionUpdateType;
(function(CellExecutionUpdateType2) {
  CellExecutionUpdateType2[CellExecutionUpdateType2["Output"] = 1] = "Output";
  CellExecutionUpdateType2[CellExecutionUpdateType2["OutputItems"] = 2] = "OutputItems";
  CellExecutionUpdateType2[CellExecutionUpdateType2["ExecutionState"] = 3] = "ExecutionState";
})(CellExecutionUpdateType || (CellExecutionUpdateType = {}));

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookKernels.js
init_proxyIdentifier();
var ExtHostNotebookKernels = class ExtHostNotebookKernels2 {
  constructor(mainContext, _initData, _extHostNotebook, _commands2, _logService) {
    this._initData = _initData;
    this._extHostNotebook = _extHostNotebook;
    this._commands = _commands2;
    this._logService = _logService;
    this._activeExecutions = new ResourceMap();
    this._activeNotebookExecutions = new ResourceMap();
    this._kernelDetectionTask = /* @__PURE__ */ new Map();
    this._kernelDetectionTaskHandlePool = 0;
    this._kernelSourceActionProviders = /* @__PURE__ */ new Map();
    this._kernelSourceActionProviderHandlePool = 0;
    this._kernelSourceActionProviderCache = new Cache("NotebookKernelSourceActionProviderCache");
    this._kernelData = /* @__PURE__ */ new Map();
    this._handlePool = 0;
    this._onDidChangeCellExecutionState = new Emitter();
    this.onDidChangeNotebookCellExecutionState = this._onDidChangeCellExecutionState.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadNotebookKernels);
    const selectKernelApiCommand = new ApiCommand(
      "notebook.selectKernel",
      "_notebook.selectKernel",
      "Trigger kernel picker for specified notebook editor widget",
      [
        new ApiCommandArgument("options", "Select kernel options", (v) => true, (v) => {
          if (v && "notebookEditor" in v && "id" in v) {
            const notebookEditorId = this._extHostNotebook.getIdByEditor(v.notebookEditor);
            return {
              id: v.id,
              extension: v.extension,
              notebookEditorId
            };
          } else if (v && "notebookEditor" in v) {
            const notebookEditorId = this._extHostNotebook.getIdByEditor(v.notebookEditor);
            if (notebookEditorId === void 0) {
              throw new Error(`Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${v.notebookEditor.notebook.uri.toString()}`);
            }
            return { notebookEditorId };
          }
          return v;
        })
      ],
      ApiCommandResult.Void
    );
    this._commands.registerApiCommand(selectKernelApiCommand);
  }
  createNotebookController(extension, id, viewType, label, handler, preloads) {
    for (const data2 of this._kernelData.values()) {
      if (data2.controller.id === id && ExtensionIdentifier.equals(extension.identifier, data2.extensionId)) {
        throw new Error(`notebook controller with id '${id}' ALREADY exist`);
      }
    }
    const handle = this._handlePool++;
    const that = this;
    this._logService.trace(`NotebookController[${handle}], CREATED by ${extension.identifier.value}, ${id}`);
    const _defaultExecutHandler = () => console.warn(`NO execute handler from notebook controller '${data.id}' of extension: '${extension.identifier}'`);
    let isDisposed = false;
    const commandDisposables = new DisposableStore();
    const onDidChangeSelection = new Emitter();
    const onDidReceiveMessage = new Emitter();
    const data = {
      id: createKernelId(extension.identifier, id),
      notebookType: viewType,
      extensionId: extension.identifier,
      extensionLocation: extension.extensionLocation,
      label: label || extension.identifier.value,
      preloads: preloads ? preloads.map(NotebookRendererScript2.from) : []
    };
    let _executeHandler = handler ?? _defaultExecutHandler;
    let _interruptHandler;
    this._proxy.$addKernel(handle, data).catch((err) => {
      console.log(err);
      isDisposed = true;
    });
    let tokenPool = 0;
    const _update = () => {
      if (isDisposed) {
        return;
      }
      const myToken = ++tokenPool;
      Promise.resolve().then(() => {
        if (myToken === tokenPool) {
          this._proxy.$updateKernel(handle, data);
        }
      });
    };
    const associatedNotebooks = new ResourceMap();
    const controller = {
      get id() {
        return id;
      },
      get notebookType() {
        return data.notebookType;
      },
      onDidChangeSelectedNotebooks: onDidChangeSelection.event,
      get label() {
        return data.label;
      },
      set label(value) {
        data.label = value ?? extension.displayName ?? extension.name;
        _update();
      },
      get detail() {
        return data.detail ?? "";
      },
      set detail(value) {
        data.detail = value;
        _update();
      },
      get description() {
        return data.description ?? "";
      },
      set description(value) {
        data.description = value;
        _update();
      },
      get supportedLanguages() {
        return data.supportedLanguages;
      },
      set supportedLanguages(value) {
        data.supportedLanguages = value;
        _update();
      },
      get supportsExecutionOrder() {
        return data.supportsExecutionOrder ?? false;
      },
      set supportsExecutionOrder(value) {
        data.supportsExecutionOrder = value;
        _update();
      },
      get rendererScripts() {
        return data.preloads ? data.preloads.map(NotebookRendererScript2.to) : [];
      },
      get executeHandler() {
        return _executeHandler;
      },
      set executeHandler(value) {
        _executeHandler = value ?? _defaultExecutHandler;
      },
      get interruptHandler() {
        return _interruptHandler;
      },
      set interruptHandler(value) {
        _interruptHandler = value;
        data.supportsInterrupt = Boolean(value);
        _update();
      },
      createNotebookCellExecution(cell) {
        if (isDisposed) {
          throw new Error("notebook controller is DISPOSED");
        }
        if (!associatedNotebooks.has(cell.notebook.uri)) {
          that._logService.trace(`NotebookController[${handle}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(associatedNotebooks.keys()).map((u) => u.toString()));
          throw new Error(`notebook controller is NOT associated to notebook: ${cell.notebook.uri.toString()}`);
        }
        return that._createNotebookCellExecution(cell, createKernelId(extension.identifier, this.id));
      },
      createNotebookExecution(notebook) {
        checkProposedApiEnabled(extension, "notebookExecution");
        if (isDisposed) {
          throw new Error("notebook controller is DISPOSED");
        }
        if (!associatedNotebooks.has(notebook.uri)) {
          that._logService.trace(`NotebookController[${handle}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(associatedNotebooks.keys()).map((u) => u.toString()));
          throw new Error(`notebook controller is NOT associated to notebook: ${notebook.uri.toString()}`);
        }
        return that._createNotebookExecution(notebook, createKernelId(extension.identifier, this.id));
      },
      dispose: () => {
        if (!isDisposed) {
          this._logService.trace(`NotebookController[${handle}], DISPOSED`);
          isDisposed = true;
          this._kernelData.delete(handle);
          commandDisposables.dispose();
          onDidChangeSelection.dispose();
          onDidReceiveMessage.dispose();
          this._proxy.$removeKernel(handle);
        }
      },
      updateNotebookAffinity(notebook, priority) {
        if (priority === NotebookControllerAffinity2.Hidden) {
          checkProposedApiEnabled(extension, "notebookControllerAffinityHidden");
        }
        that._proxy.$updateNotebookPriority(handle, notebook.uri, priority);
      },
      onDidReceiveMessage: onDidReceiveMessage.event,
      postMessage(message, editor) {
        checkProposedApiEnabled(extension, "notebookMessaging");
        return that._proxy.$postMessage(handle, editor && that._extHostNotebook.getIdByEditor(editor), message);
      },
      asWebviewUri(uri) {
        checkProposedApiEnabled(extension, "notebookMessaging");
        return asWebviewUri(uri, that._initData.remote);
      }
    };
    this._kernelData.set(handle, {
      extensionId: extension.identifier,
      controller,
      onDidReceiveMessage,
      onDidChangeSelection,
      associatedNotebooks
    });
    return controller;
  }
  getIdByController(controller) {
    for (const [_, candidate] of this._kernelData) {
      if (candidate.controller === controller) {
        return createKernelId(candidate.extensionId, controller.id);
      }
    }
    return null;
  }
  createNotebookControllerDetectionTask(extension, viewType) {
    const handle = this._kernelDetectionTaskHandlePool++;
    const that = this;
    this._logService.trace(`NotebookControllerDetectionTask[${handle}], CREATED by ${extension.identifier.value}`);
    this._proxy.$addKernelDetectionTask(handle, viewType);
    const detectionTask = {
      dispose: () => {
        this._kernelDetectionTask.delete(handle);
        that._proxy.$removeKernelDetectionTask(handle);
      }
    };
    this._kernelDetectionTask.set(handle, detectionTask);
    return detectionTask;
  }
  registerKernelSourceActionProvider(extension, viewType, provider) {
    const handle = this._kernelSourceActionProviderHandlePool++;
    const eventHandle = typeof provider.onDidChangeNotebookKernelSourceActions === "function" ? handle : void 0;
    const that = this;
    this._kernelSourceActionProviders.set(handle, provider);
    this._logService.trace(`NotebookKernelSourceActionProvider[${handle}], CREATED by ${extension.identifier.value}`);
    this._proxy.$addKernelSourceActionProvider(handle, handle, viewType);
    let subscription;
    if (eventHandle !== void 0) {
      subscription = provider.onDidChangeNotebookKernelSourceActions((_) => this._proxy.$emitNotebookKernelSourceActionsChangeEvent(eventHandle));
    }
    return {
      dispose: () => {
        this._kernelSourceActionProviders.delete(handle);
        that._proxy.$removeKernelSourceActionProvider(handle, handle);
        subscription == null ? void 0 : subscription.dispose();
      }
    };
  }
  async $provideKernelSourceActions(handle, token) {
    const provider = this._kernelSourceActionProviders.get(handle);
    if (provider) {
      const disposables = new DisposableStore();
      this._kernelSourceActionProviderCache.add([disposables]);
      const ret = await provider.provideNotebookKernelSourceActions(token);
      return (ret ?? []).map(
        (item) => NotebookKernelSourceAction2.from(item, this._commands.converter, disposables)
      );
    }
    return [];
  }
  $acceptNotebookAssociation(handle, uri, value) {
    const obj = this._kernelData.get(handle);
    if (obj) {
      const notebook = this._extHostNotebook.getNotebookDocument(URI.revive(uri));
      if (value) {
        obj.associatedNotebooks.set(notebook.uri, true);
      } else {
        obj.associatedNotebooks.delete(notebook.uri);
      }
      this._logService.trace(`NotebookController[${handle}] ASSOCIATE notebook`, notebook.uri.toString(), value);
      obj.onDidChangeSelection.fire({
        selected: value,
        notebook: notebook.apiNotebook
      });
    }
  }
  async $executeCells(handle, uri, handles) {
    const obj = this._kernelData.get(handle);
    if (!obj) {
      return;
    }
    const document2 = this._extHostNotebook.getNotebookDocument(URI.revive(uri));
    const cells = [];
    for (const cellHandle of handles) {
      const cell = document2.getCell(cellHandle);
      if (cell) {
        cells.push(cell.apiCell);
      }
    }
    try {
      this._logService.trace(`NotebookController[${handle}] EXECUTE cells`, document2.uri.toString(), cells.length);
      await obj.controller.executeHandler.call(obj.controller, cells, document2.apiNotebook, obj.controller);
    } catch (err) {
      this._logService.error(`NotebookController[${handle}] execute cells FAILED`, err);
      console.error(err);
    }
  }
  async $cancelCells(handle, uri, handles) {
    var _a30;
    const obj = this._kernelData.get(handle);
    if (!obj) {
      return;
    }
    const document2 = this._extHostNotebook.getNotebookDocument(URI.revive(uri));
    if (obj.controller.interruptHandler) {
      await obj.controller.interruptHandler.call(obj.controller, document2.apiNotebook);
    } else {
      for (const cellHandle of handles) {
        const cell = document2.getCell(cellHandle);
        if (cell) {
          (_a30 = this._activeExecutions.get(cell.uri)) == null ? void 0 : _a30.cancel();
        }
      }
    }
    if (obj.controller.interruptHandler) {
      const items = this._activeNotebookExecutions.get(document2.uri);
      if (handles.length && Array.isArray(items) && items.length) {
        items.forEach((d) => d.dispose());
      }
    }
  }
  $acceptKernelMessageFromRenderer(handle, editorId, message) {
    const obj = this._kernelData.get(handle);
    if (!obj) {
      return;
    }
    const editor = this._extHostNotebook.getEditorById(editorId);
    obj.onDidReceiveMessage.fire(Object.freeze({ editor: editor.apiEditor, message }));
  }
  $cellExecutionChanged(uri, cellHandle, state) {
    const document2 = this._extHostNotebook.getNotebookDocument(URI.revive(uri));
    const cell = document2.getCell(cellHandle);
    if (cell) {
      const newState = state ? NotebookCellExecutionState3.to(state) : NotebookCellExecutionState2.Idle;
      if (newState !== void 0) {
        this._onDidChangeCellExecutionState.fire({
          cell: cell.apiCell,
          state: newState
        });
      }
    }
  }
  _createNotebookCellExecution(cell, controllerId) {
    if (cell.index < 0) {
      throw new Error("CANNOT execute cell that has been REMOVED from notebook");
    }
    const notebook = this._extHostNotebook.getNotebookDocument(cell.notebook.uri);
    const cellObj = notebook.getCellFromApiCell(cell);
    if (!cellObj) {
      throw new Error("invalid cell");
    }
    if (this._activeExecutions.has(cellObj.uri)) {
      throw new Error(`duplicate execution for ${cellObj.uri}`);
    }
    const execution = new NotebookCellExecutionTask(controllerId, cellObj, this._proxy);
    this._activeExecutions.set(cellObj.uri, execution);
    const listener = execution.onDidChangeState(() => {
      if (execution.state === NotebookCellExecutionTaskState.Resolved) {
        execution.dispose();
        listener.dispose();
        this._activeExecutions.delete(cellObj.uri);
      }
    });
    return execution.asApiObject();
  }
  _createNotebookExecution(nb, controllerId) {
    const notebook = this._extHostNotebook.getNotebookDocument(nb.uri);
    const runningCell = nb.getCells().find((cell) => {
      const apiCell = notebook.getCellFromApiCell(cell);
      return apiCell && this._activeExecutions.has(apiCell.uri);
    });
    if (runningCell) {
      throw new Error(`duplicate cell execution for ${runningCell.document.uri}`);
    }
    if (this._activeNotebookExecutions.has(notebook.uri)) {
      throw new Error(`duplicate notebook execution for ${notebook.uri}`);
    }
    const execution = new NotebookExecutionTask(controllerId, notebook, this._proxy);
    const listener = execution.onDidChangeState(() => {
      if (execution.state === NotebookExecutionTaskState.Resolved) {
        execution.dispose();
        listener.dispose();
        this._activeNotebookExecutions.delete(notebook.uri);
      }
    });
    this._activeNotebookExecutions.set(notebook.uri, [execution, listener]);
    return execution.asApiObject();
  }
};
ExtHostNotebookKernels = __decorate([
  __param(4, ILogService)
], ExtHostNotebookKernels);
var NotebookCellExecutionTaskState;
(function(NotebookCellExecutionTaskState2) {
  NotebookCellExecutionTaskState2[NotebookCellExecutionTaskState2["Init"] = 0] = "Init";
  NotebookCellExecutionTaskState2[NotebookCellExecutionTaskState2["Started"] = 1] = "Started";
  NotebookCellExecutionTaskState2[NotebookCellExecutionTaskState2["Resolved"] = 2] = "Resolved";
})(NotebookCellExecutionTaskState || (NotebookCellExecutionTaskState = {}));
var _NotebookCellExecutionTask = class _NotebookCellExecutionTask extends Disposable {
  get state() {
    return this._state;
  }
  constructor(controllerId, _cell, _proxy10) {
    super();
    this._cell = _cell;
    this._proxy = _proxy10;
    this._handle = _NotebookCellExecutionTask.HANDLE++;
    this._onDidChangeState = new Emitter();
    this.onDidChangeState = this._onDidChangeState.event;
    this._state = NotebookCellExecutionTaskState.Init;
    this._tokenSource = this._register(new CancellationTokenSource());
    this._collector = new TimeoutBasedCollector(10, (updates) => this.update(updates));
    this._executionOrder = _cell.internalMetadata.executionOrder;
    this._proxy.$createExecution(this._handle, controllerId, this._cell.notebook.uri, this._cell.handle);
  }
  cancel() {
    this._tokenSource.cancel();
  }
  async updateSoon(update) {
    await this._collector.addItem(update);
  }
  async update(update) {
    const updates = Array.isArray(update) ? update : [update];
    return this._proxy.$updateExecution(this._handle, new SerializableObjectWithBuffers(updates));
  }
  verifyStateForOutput() {
    if (this._state === NotebookCellExecutionTaskState.Init) {
      throw new Error("Must call start before modifying cell output");
    }
    if (this._state === NotebookCellExecutionTaskState.Resolved) {
      throw new Error("Cannot modify cell output after calling resolve");
    }
  }
  cellIndexToHandle(cellOrCellIndex) {
    let cell = this._cell;
    if (cellOrCellIndex) {
      cell = this._cell.notebook.getCellFromApiCell(cellOrCellIndex);
    }
    if (!cell) {
      throw new Error("INVALID cell");
    }
    return cell.handle;
  }
  validateAndConvertOutputs(items) {
    return items.map((output) => {
      const newOutput = NotebookCellOutput.ensureUniqueMimeTypes(output.items, true);
      if (newOutput === output.items) {
        return NotebookCellOutput2.from(output);
      }
      return NotebookCellOutput2.from({
        items: newOutput,
        id: output.id,
        metadata: output.metadata
      });
    });
  }
  async updateOutputs(outputs, cell, append2) {
    const handle = this.cellIndexToHandle(cell);
    const outputDtos = this.validateAndConvertOutputs(asArray(outputs));
    return this.updateSoon({
      editType: CellExecutionUpdateType.Output,
      cellHandle: handle,
      append: append2,
      outputs: outputDtos
    });
  }
  async updateOutputItems(items, output, append2) {
    items = NotebookCellOutput.ensureUniqueMimeTypes(asArray(items), true);
    return this.updateSoon({
      editType: CellExecutionUpdateType.OutputItems,
      items: items.map(NotebookCellOutputItem2.from),
      outputId: output.id,
      append: append2
    });
  }
  asApiObject() {
    const that = this;
    const result = {
      get token() {
        return that._tokenSource.token;
      },
      get cell() {
        return that._cell.apiCell;
      },
      get executionOrder() {
        return that._executionOrder;
      },
      set executionOrder(v) {
        that._executionOrder = v;
        that.update([{
          editType: CellExecutionUpdateType.ExecutionState,
          executionOrder: that._executionOrder
        }]);
      },
      start(startTime) {
        if (that._state === NotebookCellExecutionTaskState.Resolved || that._state === NotebookCellExecutionTaskState.Started) {
          throw new Error("Cannot call start again");
        }
        that._state = NotebookCellExecutionTaskState.Started;
        that._onDidChangeState.fire();
        that.update({
          editType: CellExecutionUpdateType.ExecutionState,
          runStartTime: startTime
        });
      },
      end(success, endTime) {
        if (that._state === NotebookCellExecutionTaskState.Resolved) {
          throw new Error("Cannot call resolve twice");
        }
        that._state = NotebookCellExecutionTaskState.Resolved;
        that._onDidChangeState.fire();
        that._collector.flush();
        that._proxy.$completeExecution(that._handle, new SerializableObjectWithBuffers({
          runEndTime: endTime,
          lastRunSuccess: success
        }));
      },
      clearOutput(cell) {
        that.verifyStateForOutput();
        return that.updateOutputs([], cell, false);
      },
      appendOutput(outputs, cell) {
        that.verifyStateForOutput();
        return that.updateOutputs(outputs, cell, true);
      },
      replaceOutput(outputs, cell) {
        that.verifyStateForOutput();
        return that.updateOutputs(outputs, cell, false);
      },
      appendOutputItems(items, output) {
        that.verifyStateForOutput();
        return that.updateOutputItems(items, output, true);
      },
      replaceOutputItems(items, output) {
        that.verifyStateForOutput();
        return that.updateOutputItems(items, output, false);
      }
    };
    return Object.freeze(result);
  }
};
_NotebookCellExecutionTask.HANDLE = 0;
var NotebookCellExecutionTask = _NotebookCellExecutionTask;
var NotebookExecutionTaskState;
(function(NotebookExecutionTaskState2) {
  NotebookExecutionTaskState2[NotebookExecutionTaskState2["Init"] = 0] = "Init";
  NotebookExecutionTaskState2[NotebookExecutionTaskState2["Started"] = 1] = "Started";
  NotebookExecutionTaskState2[NotebookExecutionTaskState2["Resolved"] = 2] = "Resolved";
})(NotebookExecutionTaskState || (NotebookExecutionTaskState = {}));
var _NotebookExecutionTask = class _NotebookExecutionTask extends Disposable {
  get state() {
    return this._state;
  }
  constructor(controllerId, _notebook, _proxy10) {
    super();
    this._notebook = _notebook;
    this._proxy = _proxy10;
    this._handle = _NotebookExecutionTask.HANDLE++;
    this._onDidChangeState = new Emitter();
    this.onDidChangeState = this._onDidChangeState.event;
    this._state = NotebookExecutionTaskState.Init;
    this._tokenSource = this._register(new CancellationTokenSource());
    this._proxy.$createNotebookExecution(this._handle, controllerId, this._notebook.uri);
  }
  cancel() {
    this._tokenSource.cancel();
  }
  asApiObject() {
    const result = {
      start: () => {
        if (this._state === NotebookExecutionTaskState.Resolved || this._state === NotebookExecutionTaskState.Started) {
          throw new Error("Cannot call start again");
        }
        this._state = NotebookExecutionTaskState.Started;
        this._onDidChangeState.fire();
        this._proxy.$beginNotebookExecution(this._handle);
      },
      end: () => {
        if (this._state === NotebookExecutionTaskState.Resolved) {
          throw new Error("Cannot call resolve twice");
        }
        this._state = NotebookExecutionTaskState.Resolved;
        this._onDidChangeState.fire();
        this._proxy.$completeNotebookExecution(this._handle);
      }
    };
    return Object.freeze(result);
  }
};
_NotebookExecutionTask.HANDLE = 0;
var NotebookExecutionTask = _NotebookExecutionTask;
var TimeoutBasedCollector = class {
  constructor(delay, callback) {
    this.delay = delay;
    this.callback = callback;
    this.batch = [];
    this.startedTimer = Date.now();
  }
  addItem(item) {
    this.batch.push(item);
    if (!this.currentDeferred) {
      this.currentDeferred = new DeferredPromise();
      this.startedTimer = Date.now();
      timeout(this.delay).then(() => {
        return this.flush();
      });
    }
    if (Date.now() - this.startedTimer > this.delay) {
      return this.flush();
    }
    return this.currentDeferred.p;
  }
  flush() {
    if (this.batch.length === 0 || !this.currentDeferred) {
      return Promise.resolve();
    }
    const deferred = this.currentDeferred;
    this.currentDeferred = void 0;
    const batch = this.batch;
    this.batch = [];
    return this.callback(batch).finally(() => deferred.complete());
  }
};
function createKernelId(extensionIdentifier, id) {
  return `${extensionIdentifier.value}/${id}`;
}

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js
init_searchExtTypes();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookRenderers.js
init_event();
init_extHost_protocol();
var ExtHostNotebookRenderers = class {
  constructor(mainContext, _extHostNotebook) {
    this._extHostNotebook = _extHostNotebook;
    this._rendererMessageEmitters = /* @__PURE__ */ new Map();
    this.proxy = mainContext.getProxy(MainContext.MainThreadNotebookRenderers);
  }
  $postRendererMessage(editorId, rendererId, message) {
    var _a30;
    const editor = this._extHostNotebook.getEditorById(editorId);
    (_a30 = this._rendererMessageEmitters.get(rendererId)) == null ? void 0 : _a30.fire({ editor: editor.apiEditor, message });
  }
  createRendererMessaging(manifest, rendererId) {
    var _a30, _b;
    if (!((_b = (_a30 = manifest.contributes) == null ? void 0 : _a30.notebookRenderer) == null ? void 0 : _b.some((r) => r.id === rendererId))) {
      throw new Error(`Extensions may only call createRendererMessaging() for renderers they contribute (got ${rendererId})`);
    }
    const messaging = {
      onDidReceiveMessage: (listener, thisArg, disposables) => {
        return this.getOrCreateEmitterFor(rendererId).event(listener, thisArg, disposables);
      },
      postMessage: (message, editorOrAlias) => {
        if (ExtHostNotebookEditor.apiEditorsToExtHost.has(message)) {
          [message, editorOrAlias] = [editorOrAlias, message];
        }
        const extHostEditor = editorOrAlias && ExtHostNotebookEditor.apiEditorsToExtHost.get(editorOrAlias);
        return this.proxy.$postMessage(extHostEditor == null ? void 0 : extHostEditor.id, rendererId, message);
      }
    };
    return messaging;
  }
  getOrCreateEmitterFor(rendererId) {
    let emitter = this._rendererMessageEmitters.get(rendererId);
    if (emitter) {
      return emitter;
    }
    emitter = new Emitter({
      onDidRemoveLastListener: () => {
        emitter == null ? void 0 : emitter.dispose();
        this._rendererMessageEmitters.delete(rendererId);
      }
    });
    this._rendererMessageEmitters.set(rendererId, emitter);
    return emitter;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js
init_network();
init_opener();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookEditors.js
init_tslib_es6();
init_errors();
init_event();
init_log();
var ExtHostNotebookEditors = class ExtHostNotebookEditors2 {
  constructor(_logService, _notebooksAndEditors) {
    this._logService = _logService;
    this._notebooksAndEditors = _notebooksAndEditors;
    this._onDidChangeNotebookEditorSelection = new Emitter({ onListenerError: onUnexpectedExternalError });
    this._onDidChangeNotebookEditorVisibleRanges = new Emitter({ onListenerError: onUnexpectedExternalError });
    this.onDidChangeNotebookEditorSelection = this._onDidChangeNotebookEditorSelection.event;
    this.onDidChangeNotebookEditorVisibleRanges = this._onDidChangeNotebookEditorVisibleRanges.event;
  }
  $acceptEditorPropertiesChanged(id, data) {
    this._logService.debug("ExtHostNotebook#$acceptEditorPropertiesChanged", id, data);
    const editor = this._notebooksAndEditors.getEditorById(id);
    if (data.visibleRanges) {
      editor._acceptVisibleRanges(data.visibleRanges.ranges.map(NotebookRange2.to));
    }
    if (data.selections) {
      editor._acceptSelections(data.selections.selections.map(NotebookRange2.to));
    }
    if (data.visibleRanges) {
      this._onDidChangeNotebookEditorVisibleRanges.fire({
        notebookEditor: editor.apiEditor,
        visibleRanges: editor.apiEditor.visibleRanges
      });
    }
    if (data.selections) {
      this._onDidChangeNotebookEditorSelection.fire(Object.freeze({
        notebookEditor: editor.apiEditor,
        selections: editor.apiEditor.selections
      }));
    }
  }
  $acceptEditorViewColumns(data) {
    for (const id in data) {
      const editor = this._notebooksAndEditors.getEditorById(id);
      editor._acceptViewColumn(ViewColumn2.to(data[id]));
    }
  }
};
ExtHostNotebookEditors = __decorate([
  __param(0, ILogService)
], ExtHostNotebookEditors);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookDocuments.js
init_event();
init_uri();
var ExtHostNotebookDocuments = class {
  constructor(_notebooksAndEditors) {
    this._notebooksAndEditors = _notebooksAndEditors;
    this._onDidSaveNotebookDocument = new Emitter();
    this.onDidSaveNotebookDocument = this._onDidSaveNotebookDocument.event;
    this._onDidChangeNotebookDocument = new Emitter();
    this.onDidChangeNotebookDocument = this._onDidChangeNotebookDocument.event;
  }
  $acceptModelChanged(uri, event, isDirty, newMetadata) {
    const document2 = this._notebooksAndEditors.getNotebookDocument(URI.revive(uri));
    const e = document2.acceptModelChanged(event.value, isDirty, newMetadata);
    this._onDidChangeNotebookDocument.fire(e);
  }
  $acceptDirtyStateChanged(uri, isDirty) {
    const document2 = this._notebooksAndEditors.getNotebookDocument(URI.revive(uri));
    document2.acceptDirty(isDirty);
  }
  $acceptModelSaved(uri) {
    const document2 = this._notebooksAndEditors.getNotebookDocument(URI.revive(uri));
    this._onDidSaveNotebookDocument.fire(document2.apiNotebook);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostInteractive.js
init_uri();
var ExtHostInteractive = class {
  constructor(mainContext, _extHostNotebooks, _textDocumentsAndEditors, _commands2, _logService) {
    this._extHostNotebooks = _extHostNotebooks;
    this._textDocumentsAndEditors = _textDocumentsAndEditors;
    this._commands = _commands2;
    const openApiCommand = new ApiCommand(
      "interactive.open",
      "_interactive.open",
      "Open interactive window and return notebook editor and input URI",
      [
        new ApiCommandArgument("showOptions", "Show Options", (v) => true, (v) => v),
        new ApiCommandArgument("resource", "Interactive resource Uri", (v) => true, (v) => v),
        new ApiCommandArgument("controllerId", "Notebook controller Id", (v) => true, (v) => v),
        new ApiCommandArgument("title", "Interactive editor title", (v) => true, (v) => v)
      ],
      new ApiCommandResult("Notebook and input URI", (v) => {
        _logService.debug("[ExtHostInteractive] open iw with notebook editor id", v.notebookEditorId);
        if (v.notebookEditorId !== void 0) {
          const editor = this._extHostNotebooks.getEditorById(v.notebookEditorId);
          _logService.debug("[ExtHostInteractive] notebook editor found", editor.id);
          return { notebookUri: URI.revive(v.notebookUri), inputUri: URI.revive(v.inputUri), notebookEditor: editor.apiEditor };
        }
        _logService.debug("[ExtHostInteractive] notebook editor not found, uris for the interactive document", v.notebookUri, v.inputUri);
        return { notebookUri: URI.revive(v.notebookUri), inputUri: URI.revive(v.inputUri) };
      })
    );
    this._commands.registerApiCommand(openApiCommand);
  }
  $willAddInteractiveDocument(uri, eol, languageId, notebookUri) {
    var _a30;
    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
      addedDocuments: [{
        EOL: eol,
        lines: [""],
        languageId,
        uri,
        isDirty: false,
        versionId: 1,
        notebook: (_a30 = this._extHostNotebooks.getNotebookDocument(URI.revive(notebookUri))) == null ? void 0 : _a30.apiNotebook
      }]
    });
  }
  $willRemoveInteractiveDocument(uri, notebookUri) {
    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
      removedDocuments: [uri]
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js
init_lifecycle();
init_debug();
init_editSessions();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostProfileContentHandler.js
init_lifecycle();
init_types();
init_uri();
init_extHost_protocol();
var ExtHostProfileContentHandlers = class {
  constructor(mainContext) {
    this.handlers = /* @__PURE__ */ new Map();
    this.proxy = mainContext.getProxy(MainContext.MainThreadProfileContentHandlers);
  }
  registrProfileContentHandler(extension, id, handler) {
    checkProposedApiEnabled(extension, "profileContentHandlers");
    if (this.handlers.has(id)) {
      throw new Error(`Handler with id '${id}' already registered`);
    }
    this.handlers.set(id, handler);
    this.proxy.$registerProfileContentHandler(id, handler.name, handler.description, extension.identifier.value);
    return toDisposable(() => {
      this.handlers.delete(id);
      this.proxy.$unregisterProfileContentHandler(id);
    });
  }
  async $saveProfile(id, name, content, token) {
    const handler = this.handlers.get(id);
    if (!handler) {
      throw new Error(`Unknown handler with id: ${id}`);
    }
    return handler.saveProfile(name, content, token);
  }
  async $readProfile(id, idOrUri, token) {
    const handler = this.handlers.get(id);
    if (!handler) {
      throw new Error(`Unknown handler with id: ${id}`);
    }
    return handler.readProfile(isString(idOrUri) ? idOrUri : URI.revive(idOrUri), token);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostQuickDiff.js
init_uri();
init_extHost_protocol();
init_async();
var _ExtHostQuickDiff = class _ExtHostQuickDiff {
  constructor(mainContext, uriTransformer) {
    this.uriTransformer = uriTransformer;
    this.providers = /* @__PURE__ */ new Map();
    this.proxy = mainContext.getProxy(MainContext.MainThreadQuickDiff);
  }
  $provideOriginalResource(handle, uriComponents, token) {
    const uri = URI.revive(uriComponents);
    const provider = this.providers.get(handle);
    if (!provider) {
      return Promise.resolve(null);
    }
    return asPromise(() => provider.provideOriginalResource(uri, token)).then((r) => r || null);
  }
  registerQuickDiffProvider(selector, quickDiffProvider, label, rootUri) {
    const handle = _ExtHostQuickDiff.handlePool++;
    this.providers.set(handle, quickDiffProvider);
    this.proxy.$registerQuickDiffProvider(handle, DocumentSelector.from(selector, this.uriTransformer), label, rootUri);
    return {
      dispose: () => {
        this.proxy.$unregisterQuickDiffProvider(handle);
        this.providers.delete(handle);
      }
    };
  }
};
_ExtHostQuickDiff.handlePool = 0;
var ExtHostQuickDiff = _ExtHostQuickDiff;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostChat.js
init_async();
init_event();
init_iterator();
init_lifecycle();
init_stopwatch();
init_nls();
init_extHost_protocol();
var _ChatProviderWrapper = class _ChatProviderWrapper {
  constructor(extension, provider) {
    this.extension = extension;
    this.provider = provider;
    this.handle = _ChatProviderWrapper._pool++;
  }
};
_ChatProviderWrapper._pool = 0;
var ChatProviderWrapper = _ChatProviderWrapper;
var _ExtHostChat = class _ExtHostChat {
  constructor(mainContext, logService) {
    this.logService = logService;
    this._chatProvider = /* @__PURE__ */ new Map();
    this._chatSessions = /* @__PURE__ */ new Map();
    this._onDidPerformUserAction = new Emitter();
    this.onDidPerformUserAction = this._onDidPerformUserAction.event;
    this._proxy = mainContext.getProxy(MainContext.MainThreadChat);
  }
  registerChatProvider(extension, id, provider) {
    const wrapper = new ChatProviderWrapper(extension, provider);
    this._chatProvider.set(wrapper.handle, wrapper);
    this._proxy.$registerChatProvider(wrapper.handle, id);
    return toDisposable(() => {
      this._proxy.$unregisterChatProvider(wrapper.handle);
      this._chatProvider.delete(wrapper.handle);
    });
  }
  transferChatSession(session, newWorkspace) {
    const sessionId = Iterable.find(this._chatSessions.keys(), (key) => this._chatSessions.get(key) === session) ?? 0;
    if (typeof sessionId !== "number") {
      return;
    }
    this._proxy.$transferChatSession(sessionId, newWorkspace);
  }
  addChatRequest(context) {
    this._proxy.$addRequest(context);
  }
  sendInteractiveRequestToProvider(providerId, message) {
    this._proxy.$sendRequestToProvider(providerId, message);
  }
  async $prepareChat(handle, initialState, token) {
    var _a30, _b, _c, _d;
    const entry = this._chatProvider.get(handle);
    if (!entry) {
      return void 0;
    }
    const session = await entry.provider.prepareSession(initialState, token);
    if (!session) {
      return void 0;
    }
    const id = _ExtHostChat._nextId++;
    this._chatSessions.set(id, session);
    return {
      id,
      requesterUsername: (_a30 = session.requester) == null ? void 0 : _a30.name,
      requesterAvatarIconUri: (_b = session.requester) == null ? void 0 : _b.icon,
      responderUsername: (_c = session.responder) == null ? void 0 : _c.name,
      responderAvatarIconUri: (_d = session.responder) == null ? void 0 : _d.icon,
      inputPlaceholder: session.inputPlaceholder
    };
  }
  async $resolveRequest(handle, sessionId, context, token) {
    const entry = this._chatProvider.get(handle);
    if (!entry) {
      return void 0;
    }
    const realSession = this._chatSessions.get(sessionId);
    if (!realSession) {
      return void 0;
    }
    if (!entry.provider.resolveRequest) {
      return void 0;
    }
    const request = await entry.provider.resolveRequest(realSession, context, token);
    if (request) {
      return {
        message: typeof request.message === "string" ? request.message : ChatReplyFollowup.from(request.message)
      };
    }
    return void 0;
  }
  async $provideWelcomeMessage(handle, token) {
    const entry = this._chatProvider.get(handle);
    if (!entry) {
      return void 0;
    }
    if (!entry.provider.provideWelcomeMessage) {
      return void 0;
    }
    const content = await entry.provider.provideWelcomeMessage(token);
    if (!content) {
      return void 0;
    }
    return content.map((item) => {
      if (typeof item === "string") {
        return item;
      } else {
        return item.map((f) => ChatReplyFollowup.from(f));
      }
    });
  }
  async $provideFollowups(handle, sessionId, token) {
    const entry = this._chatProvider.get(handle);
    if (!entry) {
      return void 0;
    }
    const realSession = this._chatSessions.get(sessionId);
    if (!realSession) {
      return;
    }
    if (!entry.provider.provideFollowups) {
      return void 0;
    }
    const rawFollowups = await entry.provider.provideFollowups(realSession, token);
    return rawFollowups == null ? void 0 : rawFollowups.map((f) => ChatFollowup.from(f));
  }
  $removeRequest(handle, sessionId, requestId) {
    const entry = this._chatProvider.get(handle);
    if (!entry) {
      return;
    }
    const realSession = this._chatSessions.get(sessionId);
    if (!realSession) {
      return;
    }
    if (!entry.provider.removeRequest) {
      return;
    }
    entry.provider.removeRequest(realSession, requestId);
  }
  async $provideReply(handle, sessionId, request, token) {
    const entry = this._chatProvider.get(handle);
    if (!entry) {
      return void 0;
    }
    const realSession = this._chatSessions.get(sessionId);
    if (!realSession) {
      return;
    }
    const requestObj = {
      session: realSession,
      message: typeof request.message === "string" ? request.message : ChatReplyFollowup.to(request.message),
      variables: {}
    };
    if (request.variables) {
      for (const key of Object.keys(request.variables)) {
        requestObj.variables[key] = request.variables[key].map(ChatVariable.to);
      }
    }
    const stopWatch = StopWatch.create(false);
    let firstProgress;
    const progressObj = {
      report: (progress) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (typeof firstProgress === "undefined") {
          firstProgress = stopWatch.elapsed();
        }
        if ("responseId" in progress) {
          this._proxy.$acceptResponseProgress(handle, sessionId, { requestId: progress.responseId });
        } else if ("placeholder" in progress && "resolvedContent" in progress) {
          const resolvedContent = Promise.all([this._proxy.$acceptResponseProgress(handle, sessionId, { placeholder: progress.placeholder }), progress.resolvedContent]);
          raceCancellation(resolvedContent, token).then((res) => {
            if (!res) {
              return;
            }
            const [progressHandle, progressContent] = res;
            this._proxy.$acceptResponseProgress(handle, sessionId, progressContent, progressHandle ?? void 0);
          });
        } else if ("content" in progress) {
          this._proxy.$acceptResponseProgress(handle, sessionId, {
            content: typeof progress.content === "string" ? progress.content : MarkdownString3.from(progress.content)
          });
        } else {
          this._proxy.$acceptResponseProgress(handle, sessionId, progress);
        }
      }
    };
    let result;
    try {
      result = await entry.provider.provideResponseWithProgress(requestObj, progressObj, token);
      if (!result) {
        result = { errorDetails: { message: localize("emptyResponse", "Provider returned null response") } };
      }
    } catch (err) {
      result = { errorDetails: { message: localize("errorResponse", "Error from provider: {0}", err.message), responseIsIncomplete: true } };
      this.logService.error(err);
    }
    try {
      if (realSession.saveState && this._chatSessions.has(sessionId)) {
        const newState = realSession.saveState();
        this._proxy.$acceptChatState(sessionId, newState);
      }
    } catch (err) {
      this.logService.warn(err);
    }
    const timings = { firstProgress: firstProgress ?? 0, totalElapsed: stopWatch.elapsed() };
    return { errorDetails: result.errorDetails, timings };
  }
  async $provideSlashCommands(handle, sessionId, token) {
    const entry = this._chatProvider.get(handle);
    if (!entry) {
      return void 0;
    }
    const realSession = this._chatSessions.get(sessionId);
    if (!realSession) {
      return void 0;
    }
    if (!entry.provider.provideSlashCommands) {
      return void 0;
    }
    const slashCommands = await entry.provider.provideSlashCommands(realSession, token);
    return slashCommands == null ? void 0 : slashCommands.map((c) => ({
      ...c,
      kind: CompletionItemKind2.from(c.kind)
    }));
  }
  $releaseSession(sessionId) {
    this._chatSessions.delete(sessionId);
  }
  async $onDidPerformUserAction(event) {
    this._onDidPerformUserAction.fire(event);
  }
};
_ExtHostChat._nextId = 0;
var ExtHostChat = _ExtHostChat;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostInlineChat.js
init_lifecycle();
init_uri();
init_extHost_protocol();
init_extHostTypes();
var _ProviderWrapper = class _ProviderWrapper {
  constructor(extension, provider) {
    this.extension = extension;
    this.provider = provider;
    this.handle = _ProviderWrapper._pool++;
  }
};
_ProviderWrapper._pool = 0;
var ProviderWrapper = _ProviderWrapper;
var SessionWrapper = class {
  constructor(session) {
    this.session = session;
    this.responses = [];
  }
};
var _ExtHostInteractiveEditor = class _ExtHostInteractiveEditor {
  constructor(mainContext, extHostCommands, _documents, _logService) {
    this._documents = _documents;
    this._logService = _logService;
    this._inputProvider = /* @__PURE__ */ new Map();
    this._inputSessions = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadInlineChat);
    extHostCommands.registerApiCommand(new ApiCommand(
      "vscode.editorChat.start",
      "inlineChat.start",
      "Invoke a new editor chat session",
      [new ApiCommandArgument("Run arguments", "", (_v) => true, (v) => {
        if (!v) {
          return void 0;
        }
        return {
          initialRange: v.initialRange ? Range3.from(v.initialRange) : void 0,
          initialSelection: v.initialSelection ? Selection3.from(v.initialSelection) : void 0,
          message: v.message,
          autoSend: v.autoSend,
          position: v.position ? Position3.from(v.position) : void 0
        };
      })],
      ApiCommandResult.Void
    ));
  }
  registerProvider(extension, provider) {
    const wrapper = new ProviderWrapper(extension, provider);
    this._inputProvider.set(wrapper.handle, wrapper);
    this._proxy.$registerInteractiveEditorProvider(wrapper.handle, provider.label, extension.identifier.value, typeof provider.handleInteractiveEditorResponseFeedback === "function");
    return toDisposable(() => {
      this._proxy.$unregisterInteractiveEditorProvider(wrapper.handle);
      this._inputProvider.delete(wrapper.handle);
    });
  }
  async $prepareSession(handle, uri, range, token) {
    var _a30;
    const entry = this._inputProvider.get(handle);
    if (!entry) {
      this._logService.warn("CANNOT prepare session because the PROVIDER IS GONE");
      return void 0;
    }
    const document2 = this._documents.getDocument(URI.revive(uri));
    const selection = Selection3.to(range);
    const session = await entry.provider.prepareInteractiveEditorSession({ document: document2, selection }, token);
    if (!session) {
      return void 0;
    }
    if (session.wholeRange && !session.wholeRange.contains(selection)) {
      throw new Error(`InteractiveEditorSessionProvider returned a wholeRange that does not contain the selection.`);
    }
    const id = _ExtHostInteractiveEditor._nextId++;
    this._inputSessions.set(id, new SessionWrapper(session));
    return {
      id,
      placeholder: session.placeholder,
      slashCommands: (_a30 = session.slashCommands) == null ? void 0 : _a30.map((c) => ({ command: c.command, detail: c.detail, refer: c.refer, executeImmediately: c.executeImmediately })),
      wholeRange: Range3.from(session.wholeRange),
      message: session.message
    };
  }
  async $provideResponse(handle, item, request, token) {
    const entry = this._inputProvider.get(handle);
    if (!entry) {
      return void 0;
    }
    const sessionData = this._inputSessions.get(item.id);
    if (!sessionData) {
      return;
    }
    const apiRequest = {
      session: sessionData.session,
      prompt: request.prompt,
      selection: Selection3.to(request.selection),
      wholeRange: Range3.to(request.wholeRange),
      attempt: request.attempt,
      live: request.live
    };
    let done = false;
    const progress = {
      report: (value) => {
        var _a30;
        if (!request.live) {
          throw new Error("Progress reporting is only supported for live sessions");
        }
        if (done || token.isCancellationRequested) {
          return;
        }
        if (!value.message && !value.edits) {
          return;
        }
        this._proxy.$handleProgressChunk(request.requestId, {
          message: value.message,
          edits: (_a30 = value.edits) == null ? void 0 : _a30.map(TextEdit2.from)
        });
      }
    };
    const task = typeof entry.provider.provideInteractiveEditorResponse2 === "function" ? entry.provider.provideInteractiveEditorResponse2(apiRequest, progress, token) : entry.provider.provideInteractiveEditorResponse(apiRequest, token);
    Promise.resolve(task).finally(() => done = true);
    const res = await task;
    if (res) {
      const id = sessionData.responses.push(res) - 1;
      const stub = {
        wholeRange: Range3.from(res.wholeRange),
        placeholder: res.placeholder
      };
      if (_ExtHostInteractiveEditor._isMessageResponse(res)) {
        return {
          ...stub,
          id,
          type: "message",
          message: MarkdownString3.from(res.contents)
        };
      }
      const { edits } = res;
      if (edits instanceof WorkspaceEdit) {
        return {
          ...stub,
          id,
          type: "bulkEdit",
          edits: WorkspaceEdit2.from(edits)
        };
      } else if (Array.isArray(edits)) {
        return {
          ...stub,
          id,
          type: "editorEdit",
          edits: edits.map(TextEdit2.from)
        };
      }
    }
    return void 0;
  }
  $handleFeedback(handle, sessionId, responseId, kind) {
    var _a30, _b;
    const entry = this._inputProvider.get(handle);
    const sessionData = this._inputSessions.get(sessionId);
    const response = sessionData == null ? void 0 : sessionData.responses[responseId];
    if (entry && response) {
      let apiKind;
      switch (kind) {
        case 1:
          apiKind = InteractiveEditorResponseFeedbackKind.Helpful;
          break;
        case 0:
          apiKind = InteractiveEditorResponseFeedbackKind.Unhelpful;
          break;
        case 2:
          apiKind = InteractiveEditorResponseFeedbackKind.Undone;
          break;
        case 3:
          apiKind = InteractiveEditorResponseFeedbackKind.Accepted;
          break;
      }
      (_b = (_a30 = entry.provider).handleInteractiveEditorResponseFeedback) == null ? void 0 : _b.call(_a30, sessionData.session, response, apiKind);
    }
  }
  $releaseSession(handle, sessionId) {
    var _a30, _b;
    const sessionData = this._inputSessions.get(sessionId);
    const entry = this._inputProvider.get(handle);
    if (sessionData && entry) {
      (_b = (_a30 = entry.provider).releaseInteractiveEditorSession) == null ? void 0 : _b.call(_a30, sessionData.session);
    }
    this._inputSessions.delete(sessionId);
  }
  static _isMessageResponse(thing) {
    return typeof thing === "object" && typeof thing.contents === "object";
  }
};
_ExtHostInteractiveEditor._nextId = 0;
var ExtHostInteractiveEditor = _ExtHostInteractiveEditor;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookDocumentSaveParticipant.js
init_event();
init_uri();
init_extHostTypes();
var ExtHostNotebookDocumentSaveParticipant = class {
  constructor(_logService, _notebooksAndEditors, _mainThreadBulkEdits, _thresholds = { timeout: 1500, errors: 3 }) {
    this._logService = _logService;
    this._notebooksAndEditors = _notebooksAndEditors;
    this._mainThreadBulkEdits = _mainThreadBulkEdits;
    this._thresholds = _thresholds;
    this._onWillSaveNotebookDocumentEvent = new AsyncEmitter();
  }
  dispose() {
  }
  getOnWillSaveNotebookDocumentEvent(extension) {
    return (listener, thisArg, disposables) => {
      const wrappedListener = function wrapped(e) {
        listener.call(thisArg, e);
      };
      wrappedListener.extension = extension;
      return this._onWillSaveNotebookDocumentEvent.event(wrappedListener, void 0, disposables);
    };
  }
  async $participateInSave(resource, reason, token) {
    const revivedUri = URI.revive(resource);
    const document2 = this._notebooksAndEditors.getNotebookDocument(revivedUri);
    if (!document2) {
      throw new Error("Unable to resolve notebook document");
    }
    const edits = [];
    await this._onWillSaveNotebookDocumentEvent.fireAsync({ notebook: document2.apiNotebook, reason: TextDocumentSaveReason2.to(reason) }, token, async (thenable, listener) => {
      const now = Date.now();
      const data = await await Promise.resolve(thenable);
      if (Date.now() - now > this._thresholds.timeout) {
        this._logService.warn("onWillSaveNotebookDocument-listener from extension", listener.extension.identifier);
      }
      if (token.isCancellationRequested) {
        return;
      }
      if (data) {
        if (data instanceof WorkspaceEdit) {
          edits.push(data);
        } else {
          this._logService.warn("onWillSaveNotebookDocument-listener from extension", listener.extension.identifier, "ignored due to invalid data");
        }
      }
      return;
    });
    if (token.isCancellationRequested) {
      return false;
    }
    if (edits.length === 0) {
      return true;
    }
    const dto = { edits: [] };
    for (const edit of edits) {
      const { edits: edits2 } = WorkspaceEdit2.from(edit);
      dto.edits = dto.edits.concat(edits2);
    }
    return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(dto);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostIssueReporter.js
init_extHost_protocol();
init_extHostTypes();
var ExtHostIssueReporter = class {
  constructor(mainContext) {
    this._IssueUriRequestHandlers = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadIssueReporter);
  }
  async $getIssueReporterUri(extensionId, token) {
    if (this._IssueUriRequestHandlers.size === 0) {
      throw new Error("No issue request handlers registered");
    }
    const provider = this._IssueUriRequestHandlers.get(extensionId);
    if (!provider) {
      throw new Error("Issue request handler not found");
    }
    const result = await provider.handleIssueUrlRequest();
    if (!result) {
      throw new Error("Issue request handler returned no result");
    }
    return result;
  }
  registerIssueUriRequestHandler(extension, provider) {
    const extensionId = extension.identifier.value;
    this._IssueUriRequestHandlers.set(extensionId, provider);
    this._proxy.$registerIssueUriRequestHandler(extensionId);
    return new Disposable2(() => {
      this._proxy.$unregisterIssueUriRequestHandler(extensionId);
      this._IssueUriRequestHandlers.delete(extensionId);
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostShare.js
init_extHost_protocol();
init_uri();
var _ExtHostShare = class _ExtHostShare {
  constructor(mainContext, uriTransformer) {
    this.uriTransformer = uriTransformer;
    this.providers = /* @__PURE__ */ new Map();
    this.proxy = mainContext.getProxy(MainContext.MainThreadShare);
  }
  async $provideShare(handle, shareableItem, token) {
    const provider = this.providers.get(handle);
    const result = await (provider == null ? void 0 : provider.provideShare({ selection: Range3.to(shareableItem.selection), resourceUri: URI.revive(shareableItem.resourceUri) }, token));
    return result ?? void 0;
  }
  registerShareProvider(selector, provider) {
    const handle = _ExtHostShare.handlePool++;
    this.providers.set(handle, provider);
    this.proxy.$registerShareProvider(handle, DocumentSelector.from(selector, this.uriTransformer), provider.id, provider.label, provider.priority);
    return {
      dispose: () => {
        this.proxy.$unregisterShareProvider(handle);
        this.providers.delete(handle);
      }
    };
  }
};
_ExtHostShare.handlePool = 0;
var ExtHostShare = _ExtHostShare;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostChatProvider.js
init_lifecycle();
init_extHost_protocol();
init_progress();
init_extensions();
var _ExtHostChatProvider = class _ExtHostChatProvider {
  constructor(mainContext, _logService) {
    this._logService = _logService;
    this._providers = /* @__PURE__ */ new Map();
    this._pendingRequest = /* @__PURE__ */ new Map();
    this._chatAccessAllowList = new ExtensionIdentifierMap();
    this._proxy = mainContext.getProxy(MainContext.MainThreadChatProvider);
  }
  registerProvider(extension, identifier, provider, metadata) {
    const handle = _ExtHostChatProvider._idPool++;
    this._providers.set(handle, { extension, provider });
    this._proxy.$registerProvider(handle, identifier, { extension, displayName: metadata.name ?? extension.value });
    return toDisposable(() => {
      this._proxy.$unregisterProvider(handle);
      this._providers.delete(handle);
    });
  }
  async $provideChatResponse(handle, requestId, messages, options, token) {
    const data = this._providers.get(handle);
    if (!data) {
      return;
    }
    const progress = new Progress(async (fragment) => {
      if (token.isCancellationRequested) {
        this._logService.warn(`[CHAT](${data.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`);
        return;
      }
      await this._proxy.$handleProgressChunk(requestId, { index: fragment.index, part: fragment.part });
    }, { async: true });
    return data.provider.provideChatResponse(messages.map(ChatMessage2.to), options, progress, token);
  }
  allowListExtensionWhile(extension, promise) {
    this._chatAccessAllowList.set(extension, promise);
    promise.finally(() => this._chatAccessAllowList.delete(extension));
  }
  async requestChatResponseProvider(from, identifier) {
    if (!this._chatAccessAllowList.has(from)) {
      throw new Error("Extension is NOT allowed to make chat requests");
    }
    const that = this;
    return {
      get isRevoked() {
        return !that._chatAccessAllowList.has(from);
      },
      async makeRequest(messages, options, progress, token) {
        if (!that._chatAccessAllowList.has(from)) {
          throw new Error("Access to chat has been revoked");
        }
        const requestId = Math.random() * 1e6 | 0;
        that._pendingRequest.set(requestId, progress);
        try {
          await that._proxy.$fetchResponse(from, identifier, requestId, messages.map(ChatMessage2.from), options, token);
        } finally {
          that._pendingRequest.delete(requestId);
        }
      }
    };
  }
  async $handleResponseFragment(requestId, chunk) {
    var _a30;
    (_a30 = this._pendingRequest.get(requestId)) == null ? void 0 : _a30.report(chunk);
  }
};
_ExtHostChatProvider._idPool = 1;
var ExtHostChatProvider = _ExtHostChatProvider;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostChatSlashCommand.js
init_lifecycle();
init_extHost_protocol();
init_extHostTypes();
init_progress();
init_async();
var _ExtHostChatSlashCommands = class _ExtHostChatSlashCommands {
  constructor(mainContext, _extHostChatProvider, _logService) {
    this._extHostChatProvider = _extHostChatProvider;
    this._logService = _logService;
    this._commands = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadChatSlashCommands);
  }
  registerCommand(extension, name, command, metadata) {
    const handle = _ExtHostChatSlashCommands._idPool++;
    this._commands.set(handle, { extension, command });
    this._proxy.$registerCommand(handle, name, metadata.description);
    return toDisposable(() => {
      this._proxy.$unregisterCommand(handle);
      this._commands.delete(handle);
    });
  }
  async $executeCommand(handle, requestId, prompt, context, token) {
    const data = this._commands.get(handle);
    if (!data) {
      this._logService.warn(`[CHAT](${handle}) CANNOT execute command because the command is not registered`);
      return;
    }
    let done = false;
    function throwIfDone() {
      if (done) {
        throw new Error("Only valid while executing the command");
      }
    }
    const commandExecution = new DeferredPromise();
    token.onCancellationRequested(() => commandExecution.complete());
    setTimeout(() => commandExecution.complete(), 3 * 1e3);
    this._extHostChatProvider.allowListExtensionWhile(data.extension, commandExecution.p);
    const task = data.command({ role: ChatMessageRole.User, content: prompt }, { history: context.history.map(ChatMessage2.to) }, new Progress((p) => {
      throwIfDone();
      this._proxy.$handleProgressChunk(requestId, { content: p.message.value });
    }), token);
    try {
      await raceCancellation(Promise.resolve(task), token);
    } finally {
      done = true;
      commandExecution.complete();
    }
  }
};
_ExtHostChatSlashCommands._idPool = 0;
var ExtHostChatSlashCommands = _ExtHostChatSlashCommands;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostChatVariables.js
init_lifecycle();
init_extHost_protocol();
init_errors();
var _ExtHostChatVariables = class _ExtHostChatVariables {
  constructor(mainContext) {
    this._resolver = /* @__PURE__ */ new Map();
    this._proxy = mainContext.getProxy(MainContext.MainThreadChatVariables);
  }
  async $resolveVariable(handle, messageText, token) {
    const item = this._resolver.get(handle);
    if (!item) {
      return void 0;
    }
    try {
      const value = await item.resolver.resolve(item.data.name, { message: messageText }, token);
      if (value) {
        return value.map(ChatVariable.from);
      }
    } catch (err) {
      onUnexpectedExternalError(err);
    }
    return void 0;
  }
  registerVariableResolver(extension, name, description, resolver) {
    const handle = _ExtHostChatVariables._idPool++;
    this._resolver.set(handle, { extension: extension.identifier, data: { name, description }, resolver });
    this._proxy.$registerVariable(handle, { name, description });
    return toDisposable(() => {
      this._resolver.delete(handle);
      this._proxy.$unregisterVariable(handle);
    });
  }
};
_ExtHostChatVariables._idPool = 0;
var ExtHostChatVariables = _ExtHostChatVariables;

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostAiRelatedInformation.js
init_extHost_protocol();
init_extHostTypes();
var ExtHostRelatedInformation = class {
  constructor(mainContext) {
    this._relatedInformationProviders = /* @__PURE__ */ new Map();
    this._nextHandle = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadAiRelatedInformation);
  }
  async $provideAiRelatedInformation(handle, query, token) {
    if (this._relatedInformationProviders.size === 0) {
      throw new Error("No related information providers registered");
    }
    const provider = this._relatedInformationProviders.get(handle);
    if (!provider) {
      throw new Error("related information provider not found");
    }
    const result = await provider.provideRelatedInformation(query, token) ?? [];
    return result;
  }
  getRelatedInformation(extension, query, types) {
    return this._proxy.$getAiRelatedInformation(query, types);
  }
  registerRelatedInformationProvider(extension, type, provider) {
    const handle = this._nextHandle;
    this._nextHandle++;
    this._relatedInformationProviders.set(handle, provider);
    this._proxy.$registerAiRelatedInformationProvider(handle, type);
    return new Disposable2(() => {
      this._proxy.$unregisterAiRelatedInformationProvider(handle);
      this._relatedInformationProviders.delete(handle);
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostEmbeddingVector.js
init_extHost_protocol();
init_extHostTypes();
var ExtHostAiEmbeddingVector = class {
  constructor(mainContext) {
    this._AiEmbeddingVectorProviders = /* @__PURE__ */ new Map();
    this._nextHandle = 0;
    this._proxy = mainContext.getProxy(MainContext.MainThreadAiEmbeddingVector);
  }
  async $provideAiEmbeddingVector(handle, strings, token) {
    if (this._AiEmbeddingVectorProviders.size === 0) {
      throw new Error("No embedding vector providers registered");
    }
    const provider = this._AiEmbeddingVectorProviders.get(handle);
    if (!provider) {
      throw new Error("Embedding vector provider not found");
    }
    const result = await provider.provideEmbeddingVector(strings, token);
    if (!result) {
      throw new Error("Embedding vector provider returned undefined");
    }
    return result;
  }
  registerEmbeddingVectorProvider(extension, model, provider) {
    const handle = this._nextHandle;
    this._nextHandle++;
    this._AiEmbeddingVectorProviders.set(handle, provider);
    this._proxy.$registerAiEmbeddingVectorProvider(model, handle);
    return new Disposable2(() => {
      this._proxy.$unregisterAiEmbeddingVectorProvider(handle);
      this._AiEmbeddingVectorProviders.delete(handle);
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js
function createApiFactoryAndRegisterActors(accessor) {
  const initData = accessor.get(IExtHostInitDataService);
  const extHostFileSystemInfo = accessor.get(IExtHostFileSystemInfo);
  const extHostConsumerFileSystem = accessor.get(IExtHostConsumerFileSystem);
  const extensionService = accessor.get(IExtHostExtensionService);
  const extHostWorkspace = accessor.get(IExtHostWorkspace);
  const extHostTelemetry = accessor.get(IExtHostTelemetry);
  const extHostConfiguration = accessor.get(IExtHostConfiguration);
  const uriTransformer = accessor.get(IURITransformerService);
  const rpcProtocol = accessor.get(IExtHostRpcService);
  const extHostStorage = accessor.get(IExtHostStorage);
  const extensionStoragePaths = accessor.get(IExtensionStoragePaths);
  const extHostLoggerService = accessor.get(ILoggerService);
  const extHostLogService = accessor.get(ILogService);
  const extHostTunnelService = accessor.get(IExtHostTunnelService);
  const extHostApiDeprecation = accessor.get(IExtHostApiDeprecationService);
  const extHostWindow = accessor.get(IExtHostWindow);
  const extHostSecretState = accessor.get(IExtHostSecretState);
  const extHostEditorTabs = accessor.get(IExtHostEditorTabs);
  const extHostManagedSockets = accessor.get(IExtHostManagedSockets);
  rpcProtocol.set(ExtHostContext.ExtHostFileSystemInfo, extHostFileSystemInfo);
  rpcProtocol.set(ExtHostContext.ExtHostLogLevelServiceShape, extHostLoggerService);
  rpcProtocol.set(ExtHostContext.ExtHostWorkspace, extHostWorkspace);
  rpcProtocol.set(ExtHostContext.ExtHostConfiguration, extHostConfiguration);
  rpcProtocol.set(ExtHostContext.ExtHostExtensionService, extensionService);
  rpcProtocol.set(ExtHostContext.ExtHostStorage, extHostStorage);
  rpcProtocol.set(ExtHostContext.ExtHostTunnelService, extHostTunnelService);
  rpcProtocol.set(ExtHostContext.ExtHostWindow, extHostWindow);
  rpcProtocol.set(ExtHostContext.ExtHostSecretState, extHostSecretState);
  rpcProtocol.set(ExtHostContext.ExtHostTelemetry, extHostTelemetry);
  rpcProtocol.set(ExtHostContext.ExtHostEditorTabs, extHostEditorTabs);
  rpcProtocol.set(ExtHostContext.ExtHostManagedSockets, extHostManagedSockets);
  const extHostDecorations = rpcProtocol.set(ExtHostContext.ExtHostDecorations, accessor.get(IExtHostDecorations));
  const extHostDocumentsAndEditors = rpcProtocol.set(ExtHostContext.ExtHostDocumentsAndEditors, accessor.get(IExtHostDocumentsAndEditors));
  const extHostCommands = rpcProtocol.set(ExtHostContext.ExtHostCommands, accessor.get(IExtHostCommands));
  const extHostTerminalService = rpcProtocol.set(ExtHostContext.ExtHostTerminalService, accessor.get(IExtHostTerminalService));
  const extHostDebugService = rpcProtocol.set(ExtHostContext.ExtHostDebugService, accessor.get(IExtHostDebugService));
  const extHostSearch = rpcProtocol.set(ExtHostContext.ExtHostSearch, accessor.get(IExtHostSearch));
  const extHostTask = rpcProtocol.set(ExtHostContext.ExtHostTask, accessor.get(IExtHostTask));
  const extHostOutputService = rpcProtocol.set(ExtHostContext.ExtHostOutputService, accessor.get(IExtHostOutputService));
  const extHostLocalization = rpcProtocol.set(ExtHostContext.ExtHostLocalization, accessor.get(IExtHostLocalizationService));
  const extHostUrls = rpcProtocol.set(ExtHostContext.ExtHostUrls, new ExtHostUrls(rpcProtocol));
  const extHostDocuments = rpcProtocol.set(ExtHostContext.ExtHostDocuments, new ExtHostDocuments(rpcProtocol, extHostDocumentsAndEditors));
  const extHostDocumentContentProviders = rpcProtocol.set(ExtHostContext.ExtHostDocumentContentProviders, new ExtHostDocumentContentProvider(rpcProtocol, extHostDocumentsAndEditors, extHostLogService));
  const extHostDocumentSaveParticipant = rpcProtocol.set(ExtHostContext.ExtHostDocumentSaveParticipant, new ExtHostDocumentSaveParticipant(extHostLogService, extHostDocuments, rpcProtocol.getProxy(MainContext.MainThreadBulkEdits)));
  const extHostNotebook = rpcProtocol.set(ExtHostContext.ExtHostNotebook, new ExtHostNotebookController(
    rpcProtocol,
    extHostCommands,
    extHostDocumentsAndEditors,
    extHostDocuments,
    extHostConsumerFileSystem
  ));
  const extHostNotebookDocuments = rpcProtocol.set(ExtHostContext.ExtHostNotebookDocuments, new ExtHostNotebookDocuments(extHostNotebook));
  const extHostNotebookEditors = rpcProtocol.set(ExtHostContext.ExtHostNotebookEditors, new ExtHostNotebookEditors(extHostLogService, extHostNotebook));
  const extHostNotebookKernels = rpcProtocol.set(ExtHostContext.ExtHostNotebookKernels, new ExtHostNotebookKernels(rpcProtocol, initData, extHostNotebook, extHostCommands, extHostLogService));
  const extHostNotebookRenderers = rpcProtocol.set(ExtHostContext.ExtHostNotebookRenderers, new ExtHostNotebookRenderers(rpcProtocol, extHostNotebook));
  const extHostNotebookDocumentSaveParticipant = rpcProtocol.set(ExtHostContext.ExtHostNotebookDocumentSaveParticipant, new ExtHostNotebookDocumentSaveParticipant(extHostLogService, extHostNotebook, rpcProtocol.getProxy(MainContext.MainThreadBulkEdits)));
  const extHostEditors = rpcProtocol.set(ExtHostContext.ExtHostEditors, new ExtHostEditors(rpcProtocol, extHostDocumentsAndEditors));
  const extHostTreeViews = rpcProtocol.set(ExtHostContext.ExtHostTreeViews, new ExtHostTreeViews(rpcProtocol.getProxy(MainContext.MainThreadTreeViews), extHostCommands, extHostLogService));
  const extHostEditorInsets = rpcProtocol.set(ExtHostContext.ExtHostEditorInsets, new ExtHostEditorInsets(rpcProtocol.getProxy(MainContext.MainThreadEditorInsets), extHostEditors, initData.remote));
  const extHostDiagnostics = rpcProtocol.set(ExtHostContext.ExtHostDiagnostics, new ExtHostDiagnostics(
    rpcProtocol,
    extHostLogService,
    extHostFileSystemInfo,
    extHostDocumentsAndEditors
  ));
  const extHostLanguages = rpcProtocol.set(ExtHostContext.ExtHostLanguages, new ExtHostLanguages(rpcProtocol, extHostDocuments, extHostCommands.converter, uriTransformer));
  const extHostLanguageFeatures = rpcProtocol.set(ExtHostContext.ExtHostLanguageFeatures, new ExtHostLanguageFeatures(
    rpcProtocol,
    uriTransformer,
    extHostDocuments,
    extHostCommands,
    extHostDiagnostics,
    extHostLogService,
    extHostApiDeprecation,
    extHostTelemetry
  ));
  const extHostFileSystem = rpcProtocol.set(ExtHostContext.ExtHostFileSystem, new ExtHostFileSystem(rpcProtocol, extHostLanguageFeatures));
  const extHostFileSystemEvent = rpcProtocol.set(ExtHostContext.ExtHostFileSystemEventService, new ExtHostFileSystemEventService(rpcProtocol, extHostLogService, extHostDocumentsAndEditors));
  const extHostQuickOpen = rpcProtocol.set(ExtHostContext.ExtHostQuickOpen, createExtHostQuickOpen(rpcProtocol, extHostWorkspace, extHostCommands));
  const extHostSCM = rpcProtocol.set(ExtHostContext.ExtHostSCM, new ExtHostSCM(rpcProtocol, extHostCommands, extHostDocuments, extHostLogService));
  const extHostQuickDiff = rpcProtocol.set(ExtHostContext.ExtHostQuickDiff, new ExtHostQuickDiff(rpcProtocol, uriTransformer));
  const extHostShare = rpcProtocol.set(ExtHostContext.ExtHostShare, new ExtHostShare(rpcProtocol, uriTransformer));
  const extHostComment = rpcProtocol.set(ExtHostContext.ExtHostComments, createExtHostComments(rpcProtocol, extHostCommands, extHostDocuments));
  const extHostProgress = rpcProtocol.set(ExtHostContext.ExtHostProgress, new ExtHostProgress(rpcProtocol.getProxy(MainContext.MainThreadProgress)));
  const extHostLabelService = rpcProtocol.set(ExtHostContext.ExtHosLabelService, new ExtHostLabelService(rpcProtocol));
  const extHostTheming = rpcProtocol.set(ExtHostContext.ExtHostTheming, new ExtHostTheming(rpcProtocol));
  const extHostAuthentication = rpcProtocol.set(ExtHostContext.ExtHostAuthentication, new ExtHostAuthentication(rpcProtocol));
  const extHostTimeline = rpcProtocol.set(ExtHostContext.ExtHostTimeline, new ExtHostTimeline(rpcProtocol, extHostCommands));
  const extHostWebviews = rpcProtocol.set(ExtHostContext.ExtHostWebviews, new ExtHostWebviews(
    rpcProtocol,
    initData.remote,
    extHostWorkspace,
    extHostLogService,
    extHostApiDeprecation
  ));
  const extHostWebviewPanels = rpcProtocol.set(ExtHostContext.ExtHostWebviewPanels, new ExtHostWebviewPanels(rpcProtocol, extHostWebviews, extHostWorkspace));
  const extHostCustomEditors = rpcProtocol.set(ExtHostContext.ExtHostCustomEditors, new ExtHostCustomEditors(
    rpcProtocol,
    extHostDocuments,
    extensionStoragePaths,
    extHostWebviews,
    extHostWebviewPanels
  ));
  const extHostWebviewViews = rpcProtocol.set(ExtHostContext.ExtHostWebviewViews, new ExtHostWebviewViews(rpcProtocol, extHostWebviews));
  const extHostTesting = rpcProtocol.set(ExtHostContext.ExtHostTesting, new ExtHostTesting(rpcProtocol, extHostCommands, extHostDocumentsAndEditors));
  const extHostUriOpeners = rpcProtocol.set(ExtHostContext.ExtHostUriOpeners, new ExtHostUriOpeners(rpcProtocol));
  const extHostProfileContentHandlers = rpcProtocol.set(ExtHostContext.ExtHostProfileContentHandlers, new ExtHostProfileContentHandlers(rpcProtocol));
  rpcProtocol.set(ExtHostContext.ExtHostInteractive, new ExtHostInteractive(
    rpcProtocol,
    extHostNotebook,
    extHostDocumentsAndEditors,
    extHostCommands,
    extHostLogService
  ));
  const extHostInteractiveEditor = rpcProtocol.set(ExtHostContext.ExtHostInlineChat, new ExtHostInteractiveEditor(rpcProtocol, extHostCommands, extHostDocuments, extHostLogService));
  const extHostChatProvider = rpcProtocol.set(ExtHostContext.ExtHostChatProvider, new ExtHostChatProvider(rpcProtocol, extHostLogService));
  const extHostChatSlashCommands = rpcProtocol.set(ExtHostContext.ExtHostChatSlashCommands, new ExtHostChatSlashCommands(rpcProtocol, extHostChatProvider, extHostLogService));
  const extHostChatVariables = rpcProtocol.set(ExtHostContext.ExtHostChatVariables, new ExtHostChatVariables(rpcProtocol));
  const extHostChat = rpcProtocol.set(ExtHostContext.ExtHostChat, new ExtHostChat(rpcProtocol, extHostLogService));
  const extHostAiRelatedInformation = rpcProtocol.set(ExtHostContext.ExtHostAiRelatedInformation, new ExtHostRelatedInformation(rpcProtocol));
  const extHostAiEmbeddingVector = rpcProtocol.set(ExtHostContext.ExtHostAiEmbeddingVector, new ExtHostAiEmbeddingVector(rpcProtocol));
  const extHostIssueReporter = rpcProtocol.set(ExtHostContext.ExtHostIssueReporter, new ExtHostIssueReporter(rpcProtocol));
  const extHostStatusBar = rpcProtocol.set(ExtHostContext.ExtHostStatusBar, new ExtHostStatusBar(rpcProtocol, extHostCommands.converter));
  const extHostBulkEdits = new ExtHostBulkEdits(rpcProtocol, extHostDocumentsAndEditors);
  const extHostClipboard = new ExtHostClipboard(rpcProtocol);
  const extHostMessageService = new ExtHostMessageService(rpcProtocol, extHostLogService);
  const extHostDialogs = new ExtHostDialogs(rpcProtocol);
  ExtHostApiCommands.register(extHostCommands);
  return function(extension, extensionInfo, configProvider) {
    const checkSelector = function() {
      let done = !extension.isUnderDevelopment;
      function informOnce() {
        if (!done) {
          extHostLogService.info(`Extension '${extension.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`);
          done = true;
        }
      }
      return function perform(selector) {
        if (Array.isArray(selector)) {
          selector.forEach(perform);
        } else if (typeof selector === "string") {
          informOnce();
        } else {
          const filter2 = selector;
          if (typeof filter2.scheme === "undefined") {
            informOnce();
          }
          if (typeof filter2.exclusive === "boolean") {
            checkProposedApiEnabled(extension, "documentFiltersExclusive");
          }
        }
        return selector;
      };
    }();
    const authentication = {
      getSession(providerId, scopes, options) {
        return extHostAuthentication.getSession(extension, providerId, scopes, options);
      },
      getSessions(providerId, scopes) {
        checkProposedApiEnabled(extension, "authGetSessions");
        return extHostAuthentication.getSessions(extension, providerId, scopes);
      },
      async hasSession(providerId, scopes) {
        checkProposedApiEnabled(extension, "authSession");
        return !!await extHostAuthentication.getSession(extension, providerId, scopes, { silent: true });
      },
      get onDidChangeSessions() {
        return extHostAuthentication.onDidChangeSessions;
      },
      registerAuthenticationProvider(id, label, provider, options) {
        return extHostAuthentication.registerAuthenticationProvider(id, label, provider, options);
      }
    };
    const commands = {
      registerCommand(id, command, thisArgs) {
        return extHostCommands.registerCommand(true, id, command, thisArgs, void 0, extension);
      },
      registerTextEditorCommand(id, callback, thisArg) {
        return extHostCommands.registerCommand(true, id, (...args) => {
          const activeTextEditor = extHostEditors.getActiveTextEditor();
          if (!activeTextEditor) {
            extHostLogService.warn("Cannot execute " + id + " because there is no active text editor.");
            return void 0;
          }
          return activeTextEditor.edit((edit) => {
            callback.apply(thisArg, [activeTextEditor, edit, ...args]);
          }).then((result) => {
            if (!result) {
              extHostLogService.warn("Edits from command " + id + " were not applied.");
            }
          }, (err) => {
            extHostLogService.warn("An error occurred while running command " + id, err);
          });
        }, void 0, void 0, extension);
      },
      registerDiffInformationCommand: (id, callback, thisArg) => {
        checkProposedApiEnabled(extension, "diffCommand");
        return extHostCommands.registerCommand(true, id, async (...args) => {
          const activeTextEditor = extHostDocumentsAndEditors.activeEditor(true);
          if (!activeTextEditor) {
            extHostLogService.warn("Cannot execute " + id + " because there is no active text editor.");
            return void 0;
          }
          const diff = await extHostEditors.getDiffInformation(activeTextEditor.id);
          callback.apply(thisArg, [diff, ...args]);
        }, void 0, void 0, extension);
      },
      executeCommand(id, ...args) {
        return extHostCommands.executeCommand(id, ...args);
      },
      getCommands(filterInternal = false) {
        return extHostCommands.getCommands(filterInternal);
      }
    };
    const env2 = {
      get machineId() {
        return initData.telemetryInfo.machineId;
      },
      get sessionId() {
        return initData.telemetryInfo.sessionId;
      },
      get language() {
        return initData.environment.appLanguage;
      },
      get appName() {
        return initData.environment.appName;
      },
      get appRoot() {
        var _a30;
        return ((_a30 = initData.environment.appRoot) == null ? void 0 : _a30.fsPath) ?? "";
      },
      get appHost() {
        return initData.environment.appHost;
      },
      get uriScheme() {
        return initData.environment.appUriScheme;
      },
      get clipboard() {
        return extHostClipboard.value;
      },
      get shell() {
        return extHostTerminalService.getDefaultShell(false);
      },
      get onDidChangeShell() {
        checkProposedApiEnabled(extension, "envShellEvent");
        return extHostTerminalService.onDidChangeShell;
      },
      get isTelemetryEnabled() {
        return extHostTelemetry.getTelemetryConfiguration();
      },
      get onDidChangeTelemetryEnabled() {
        return extHostTelemetry.onDidChangeTelemetryEnabled;
      },
      get telemetryConfiguration() {
        checkProposedApiEnabled(extension, "telemetry");
        return extHostTelemetry.getTelemetryDetails();
      },
      get onDidChangeTelemetryConfiguration() {
        checkProposedApiEnabled(extension, "telemetry");
        return extHostTelemetry.onDidChangeTelemetryConfiguration;
      },
      get isNewAppInstall() {
        return isNewAppInstall(initData.telemetryInfo.firstSessionDate);
      },
      createTelemetryLogger(sender, options) {
        ExtHostTelemetryLogger.validateSender(sender);
        return extHostTelemetry.instantiateLogger(extension, sender, options);
      },
      openExternal(uri, options) {
        return extHostWindow.openUri(uri, {
          allowTunneling: !!initData.remote.authority,
          allowContributedOpeners: options == null ? void 0 : options.allowContributedOpeners
        });
      },
      async asExternalUri(uri) {
        if (uri.scheme === initData.environment.appUriScheme) {
          return extHostUrls.createAppUri(uri);
        }
        try {
          return await extHostWindow.asExternalUri(uri, { allowTunneling: !!initData.remote.authority });
        } catch (err) {
          if (matchesScheme(uri, Schemas.http) || matchesScheme(uri, Schemas.https)) {
            return uri;
          }
          throw err;
        }
      },
      get remoteName() {
        return getRemoteName(initData.remote.authority);
      },
      get remoteAuthority() {
        checkProposedApiEnabled(extension, "resolvers");
        return initData.remote.authority;
      },
      get uiKind() {
        return initData.uiKind;
      },
      get logLevel() {
        return extHostLogService.getLevel();
      },
      get onDidChangeLogLevel() {
        return extHostLogService.onDidChangeLogLevel;
      },
      registerIssueUriRequestHandler(handler) {
        checkProposedApiEnabled(extension, "handleIssueUri");
        return extHostIssueReporter.registerIssueUriRequestHandler(extension, handler);
      },
      get appQuality() {
        checkProposedApiEnabled(extension, "resolvers");
        return initData.quality;
      },
      get appCommit() {
        checkProposedApiEnabled(extension, "resolvers");
        return initData.commit;
      }
    };
    const tests = {
      createTestController(provider, label, refreshHandler) {
        return extHostTesting.createTestController(extension, provider, label, refreshHandler);
      },
      createTestObserver() {
        checkProposedApiEnabled(extension, "testObserver");
        return extHostTesting.createTestObserver();
      },
      runTests(provider) {
        checkProposedApiEnabled(extension, "testObserver");
        return extHostTesting.runTests(provider);
      },
      get onDidChangeTestResults() {
        checkProposedApiEnabled(extension, "testObserver");
        return extHostTesting.onResultsChanged;
      },
      get testResults() {
        checkProposedApiEnabled(extension, "testObserver");
        return extHostTesting.results;
      }
    };
    const extensionKind = initData.remote.isRemote ? ExtensionKind.Workspace : ExtensionKind.UI;
    const extensions = {
      getExtension(extensionId, includeFromDifferentExtensionHosts) {
        if (!isProposedApiEnabled(extension, "extensionsAny")) {
          includeFromDifferentExtensionHosts = false;
        }
        const mine = extensionInfo.mine.getExtensionDescription(extensionId);
        if (mine) {
          return new Extension(extensionService, extension.identifier, mine, extensionKind, false);
        }
        if (includeFromDifferentExtensionHosts) {
          const foreign = extensionInfo.all.getExtensionDescription(extensionId);
          if (foreign) {
            return new Extension(
              extensionService,
              extension.identifier,
              foreign,
              extensionKind,
              true
            );
          }
        }
        return void 0;
      },
      get all() {
        const result = [];
        for (const desc of extensionInfo.mine.getAllExtensionDescriptions()) {
          result.push(new Extension(extensionService, extension.identifier, desc, extensionKind, false));
        }
        return result;
      },
      get allAcrossExtensionHosts() {
        checkProposedApiEnabled(extension, "extensionsAny");
        const local = new ExtensionIdentifierSet(extensionInfo.mine.getAllExtensionDescriptions().map((desc) => desc.identifier));
        const result = [];
        for (const desc of extensionInfo.all.getAllExtensionDescriptions()) {
          const isFromDifferentExtensionHost = !local.has(desc.identifier);
          result.push(new Extension(
            extensionService,
            extension.identifier,
            desc,
            extensionKind,
            isFromDifferentExtensionHost
          ));
        }
        return result;
      },
      get onDidChange() {
        if (isProposedApiEnabled(extension, "extensionsAny")) {
          return Event.any(extensionInfo.mine.onDidChange, extensionInfo.all.onDidChange);
        }
        return extensionInfo.mine.onDidChange;
      }
    };
    const languages = {
      createDiagnosticCollection(name) {
        return extHostDiagnostics.createDiagnosticCollection(extension.identifier, name);
      },
      get onDidChangeDiagnostics() {
        return extHostDiagnostics.onDidChangeDiagnostics;
      },
      getDiagnostics: (resource) => {
        return extHostDiagnostics.getDiagnostics(resource);
      },
      getLanguages() {
        return extHostLanguages.getLanguages();
      },
      setTextDocumentLanguage(document2, languageId) {
        return extHostLanguages.changeLanguage(document2.uri, languageId);
      },
      match(selector, document2) {
        var _a30;
        const notebook = (_a30 = extHostDocuments.getDocumentData(document2.uri)) == null ? void 0 : _a30.notebook;
        return score(LanguageSelector.from(selector), document2.uri, document2.languageId, true, notebook == null ? void 0 : notebook.uri, notebook == null ? void 0 : notebook.notebookType);
      },
      registerCodeActionsProvider(selector, provider, metadata) {
        return extHostLanguageFeatures.registerCodeActionProvider(extension, checkSelector(selector), provider, metadata);
      },
      registerDocumentPasteEditProvider(selector, provider, metadata) {
        checkProposedApiEnabled(extension, "documentPaste");
        return extHostLanguageFeatures.registerDocumentPasteEditProvider(extension, checkSelector(selector), provider, metadata);
      },
      registerCodeLensProvider(selector, provider) {
        return extHostLanguageFeatures.registerCodeLensProvider(extension, checkSelector(selector), provider);
      },
      registerDefinitionProvider(selector, provider) {
        return extHostLanguageFeatures.registerDefinitionProvider(extension, checkSelector(selector), provider);
      },
      registerDeclarationProvider(selector, provider) {
        return extHostLanguageFeatures.registerDeclarationProvider(extension, checkSelector(selector), provider);
      },
      registerImplementationProvider(selector, provider) {
        return extHostLanguageFeatures.registerImplementationProvider(extension, checkSelector(selector), provider);
      },
      registerTypeDefinitionProvider(selector, provider) {
        return extHostLanguageFeatures.registerTypeDefinitionProvider(extension, checkSelector(selector), provider);
      },
      registerHoverProvider(selector, provider) {
        return extHostLanguageFeatures.registerHoverProvider(extension, checkSelector(selector), provider, extension.identifier);
      },
      registerEvaluatableExpressionProvider(selector, provider) {
        return extHostLanguageFeatures.registerEvaluatableExpressionProvider(extension, checkSelector(selector), provider, extension.identifier);
      },
      registerInlineValuesProvider(selector, provider) {
        return extHostLanguageFeatures.registerInlineValuesProvider(extension, checkSelector(selector), provider, extension.identifier);
      },
      registerDocumentHighlightProvider(selector, provider) {
        return extHostLanguageFeatures.registerDocumentHighlightProvider(extension, checkSelector(selector), provider);
      },
      registerLinkedEditingRangeProvider(selector, provider) {
        return extHostLanguageFeatures.registerLinkedEditingRangeProvider(extension, checkSelector(selector), provider);
      },
      registerReferenceProvider(selector, provider) {
        return extHostLanguageFeatures.registerReferenceProvider(extension, checkSelector(selector), provider);
      },
      registerRenameProvider(selector, provider) {
        return extHostLanguageFeatures.registerRenameProvider(extension, checkSelector(selector), provider);
      },
      registerDocumentSymbolProvider(selector, provider, metadata) {
        return extHostLanguageFeatures.registerDocumentSymbolProvider(extension, checkSelector(selector), provider, metadata);
      },
      registerWorkspaceSymbolProvider(provider) {
        return extHostLanguageFeatures.registerWorkspaceSymbolProvider(extension, provider);
      },
      registerDocumentFormattingEditProvider(selector, provider) {
        return extHostLanguageFeatures.registerDocumentFormattingEditProvider(extension, checkSelector(selector), provider);
      },
      registerDocumentRangeFormattingEditProvider(selector, provider) {
        return extHostLanguageFeatures.registerDocumentRangeFormattingEditProvider(extension, checkSelector(selector), provider);
      },
      registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacters) {
        return extHostLanguageFeatures.registerOnTypeFormattingEditProvider(extension, checkSelector(selector), provider, [firstTriggerCharacter].concat(moreTriggerCharacters));
      },
      registerDocumentSemanticTokensProvider(selector, provider, legend) {
        return extHostLanguageFeatures.registerDocumentSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
      },
      registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
        return extHostLanguageFeatures.registerDocumentRangeSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
      },
      registerSignatureHelpProvider(selector, provider, firstItem, ...remaining) {
        if (typeof firstItem === "object") {
          return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, firstItem);
        }
        return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, typeof firstItem === "undefined" ? [] : [firstItem, ...remaining]);
      },
      registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
        return extHostLanguageFeatures.registerCompletionItemProvider(extension, checkSelector(selector), provider, triggerCharacters);
      },
      registerInlineCompletionItemProvider(selector, provider, metadata) {
        if (provider.handleDidShowCompletionItem) {
          checkProposedApiEnabled(extension, "inlineCompletionsAdditions");
        }
        if (provider.handleDidPartiallyAcceptCompletionItem) {
          checkProposedApiEnabled(extension, "inlineCompletionsAdditions");
        }
        if (metadata) {
          checkProposedApiEnabled(extension, "inlineCompletionsAdditions");
        }
        return extHostLanguageFeatures.registerInlineCompletionsProvider(extension, checkSelector(selector), provider, metadata);
      },
      registerDocumentLinkProvider(selector, provider) {
        return extHostLanguageFeatures.registerDocumentLinkProvider(extension, checkSelector(selector), provider);
      },
      registerColorProvider(selector, provider) {
        return extHostLanguageFeatures.registerColorProvider(extension, checkSelector(selector), provider);
      },
      registerFoldingRangeProvider(selector, provider) {
        return extHostLanguageFeatures.registerFoldingRangeProvider(extension, checkSelector(selector), provider);
      },
      registerSelectionRangeProvider(selector, provider) {
        return extHostLanguageFeatures.registerSelectionRangeProvider(extension, selector, provider);
      },
      registerCallHierarchyProvider(selector, provider) {
        return extHostLanguageFeatures.registerCallHierarchyProvider(extension, selector, provider);
      },
      registerTypeHierarchyProvider(selector, provider) {
        return extHostLanguageFeatures.registerTypeHierarchyProvider(extension, selector, provider);
      },
      setLanguageConfiguration: (language2, configuration) => {
        return extHostLanguageFeatures.setLanguageConfiguration(extension, language2, configuration);
      },
      getTokenInformationAtPosition(doc, pos) {
        checkProposedApiEnabled(extension, "tokenInformation");
        return extHostLanguages.tokenAtPosition(doc, pos);
      },
      registerInlayHintsProvider(selector, provider) {
        return extHostLanguageFeatures.registerInlayHintsProvider(extension, selector, provider);
      },
      createLanguageStatusItem(id, selector) {
        return extHostLanguages.createLanguageStatusItem(extension, id, selector);
      },
      registerDocumentDropEditProvider(selector, provider, metadata) {
        return extHostLanguageFeatures.registerDocumentOnDropEditProvider(extension, selector, provider, isProposedApiEnabled(extension, "dropMetadata") ? metadata : void 0);
      }
    };
    const window2 = {
      get activeTextEditor() {
        return extHostEditors.getActiveTextEditor();
      },
      get visibleTextEditors() {
        return extHostEditors.getVisibleTextEditors();
      },
      get activeTerminal() {
        return extHostTerminalService.activeTerminal;
      },
      get terminals() {
        return extHostTerminalService.terminals;
      },
      async showTextDocument(documentOrUri, columnOrOptions, preserveFocus) {
        const document2 = await (URI.isUri(documentOrUri) ? Promise.resolve(workspace.openTextDocument(documentOrUri)) : Promise.resolve(documentOrUri));
        return extHostEditors.showTextDocument(document2, columnOrOptions, preserveFocus);
      },
      createTextEditorDecorationType(options) {
        return extHostEditors.createTextEditorDecorationType(extension, options);
      },
      onDidChangeActiveTextEditor(listener, thisArg, disposables) {
        return extHostEditors.onDidChangeActiveTextEditor(listener, thisArg, disposables);
      },
      onDidChangeVisibleTextEditors(listener, thisArg, disposables) {
        return extHostEditors.onDidChangeVisibleTextEditors(listener, thisArg, disposables);
      },
      onDidChangeTextEditorSelection(listener, thisArgs, disposables) {
        return extHostEditors.onDidChangeTextEditorSelection(listener, thisArgs, disposables);
      },
      onDidChangeTextEditorOptions(listener, thisArgs, disposables) {
        return extHostEditors.onDidChangeTextEditorOptions(listener, thisArgs, disposables);
      },
      onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables) {
        return extHostEditors.onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables);
      },
      onDidChangeTextEditorViewColumn(listener, thisArg, disposables) {
        return extHostEditors.onDidChangeTextEditorViewColumn(listener, thisArg, disposables);
      },
      onDidCloseTerminal(listener, thisArg, disposables) {
        return extHostTerminalService.onDidCloseTerminal(listener, thisArg, disposables);
      },
      onDidOpenTerminal(listener, thisArg, disposables) {
        return extHostTerminalService.onDidOpenTerminal(listener, thisArg, disposables);
      },
      onDidChangeActiveTerminal(listener, thisArg, disposables) {
        return extHostTerminalService.onDidChangeActiveTerminal(listener, thisArg, disposables);
      },
      onDidChangeTerminalDimensions(listener, thisArg, disposables) {
        checkProposedApiEnabled(extension, "terminalDimensions");
        return extHostTerminalService.onDidChangeTerminalDimensions(listener, thisArg, disposables);
      },
      onDidChangeTerminalState(listener, thisArg, disposables) {
        return extHostTerminalService.onDidChangeTerminalState(listener, thisArg, disposables);
      },
      onDidWriteTerminalData(listener, thisArg, disposables) {
        checkProposedApiEnabled(extension, "terminalDataWriteEvent");
        return extHostTerminalService.onDidWriteTerminalData(listener, thisArg, disposables);
      },
      onDidExecuteTerminalCommand(listener, thisArg, disposables) {
        checkProposedApiEnabled(extension, "terminalExecuteCommandEvent");
        return extHostTerminalService.onDidExecuteTerminalCommand(listener, thisArg, disposables);
      },
      get state() {
        return extHostWindow.getState(extension);
      },
      onDidChangeWindowState(listener, thisArg, disposables) {
        return extHostWindow.onDidChangeWindowState(listener, thisArg, disposables);
      },
      showInformationMessage(message, ...rest) {
        return extHostMessageService.showMessage(extension, severity_default.Info, message, rest[0], rest.slice(1));
      },
      showWarningMessage(message, ...rest) {
        return extHostMessageService.showMessage(extension, severity_default.Warning, message, rest[0], rest.slice(1));
      },
      showErrorMessage(message, ...rest) {
        return extHostMessageService.showMessage(extension, severity_default.Error, message, rest[0], rest.slice(1));
      },
      showQuickPick(items, options, token) {
        return extHostQuickOpen.showQuickPick(extension, items, options, token);
      },
      showWorkspaceFolderPick(options) {
        return extHostQuickOpen.showWorkspaceFolderPick(options);
      },
      showInputBox(options, token) {
        return extHostQuickOpen.showInput(options, token);
      },
      showOpenDialog(options) {
        return extHostDialogs.showOpenDialog(extension, options);
      },
      showSaveDialog(options) {
        return extHostDialogs.showSaveDialog(options);
      },
      createStatusBarItem(alignmentOrId, priorityOrAlignment, priorityArg) {
        let id;
        let alignment;
        let priority;
        if (typeof alignmentOrId === "string") {
          id = alignmentOrId;
          alignment = priorityOrAlignment;
          priority = priorityArg;
        } else {
          alignment = alignmentOrId;
          priority = priorityOrAlignment;
        }
        return extHostStatusBar.createStatusBarEntry(extension, id, alignment, priority);
      },
      setStatusBarMessage(text, timeoutOrThenable) {
        return extHostStatusBar.setStatusBarMessage(text, timeoutOrThenable);
      },
      withScmProgress(task) {
        extHostApiDeprecation.report("window.withScmProgress", extension, `Use 'withProgress' instead.`);
        return extHostProgress.withProgress(extension, { location: ProgressLocation.SourceControl }, (progress, token) => task({ report(n2) {
        } }));
      },
      withProgress(options, task) {
        return extHostProgress.withProgress(extension, options, task);
      },
      createOutputChannel(name, options) {
        return extHostOutputService.createOutputChannel(name, options, extension);
      },
      createWebviewPanel(viewType, title, showOptions, options) {
        return extHostWebviewPanels.createWebviewPanel(extension, viewType, title, showOptions, options);
      },
      createWebviewTextEditorInset(editor, line, height, options) {
        checkProposedApiEnabled(extension, "editorInsets");
        return extHostEditorInsets.createWebviewEditorInset(editor, line, height, options, extension);
      },
      createTerminal(nameOrOptions, shellPath, shellArgs) {
        if (typeof nameOrOptions === "object") {
          if ("pty" in nameOrOptions) {
            return extHostTerminalService.createExtensionTerminal(nameOrOptions);
          }
          return extHostTerminalService.createTerminalFromOptions(nameOrOptions);
        }
        return extHostTerminalService.createTerminal(nameOrOptions, shellPath, shellArgs);
      },
      registerTerminalLinkProvider(provider) {
        return extHostTerminalService.registerLinkProvider(provider);
      },
      registerTerminalProfileProvider(id, provider) {
        return extHostTerminalService.registerProfileProvider(extension, id, provider);
      },
      registerTerminalQuickFixProvider(id, provider) {
        checkProposedApiEnabled(extension, "terminalQuickFixProvider");
        return extHostTerminalService.registerTerminalQuickFixProvider(id, extension.identifier.value, provider);
      },
      registerTreeDataProvider(viewId, treeDataProvider) {
        return extHostTreeViews.registerTreeDataProvider(viewId, treeDataProvider, extension);
      },
      createTreeView(viewId, options) {
        return extHostTreeViews.createTreeView(viewId, options, extension);
      },
      registerWebviewPanelSerializer: (viewType, serializer) => {
        return extHostWebviewPanels.registerWebviewPanelSerializer(extension, viewType, serializer);
      },
      registerCustomEditorProvider: (viewType, provider, options = {}) => {
        return extHostCustomEditors.registerCustomEditorProvider(extension, viewType, provider, options);
      },
      registerFileDecorationProvider(provider) {
        return extHostDecorations.registerFileDecorationProvider(provider, extension);
      },
      registerUriHandler(handler) {
        return extHostUrls.registerUriHandler(extension, handler);
      },
      createQuickPick() {
        return extHostQuickOpen.createQuickPick(extension);
      },
      createInputBox() {
        return extHostQuickOpen.createInputBox(extension);
      },
      get activeColorTheme() {
        return extHostTheming.activeColorTheme;
      },
      onDidChangeActiveColorTheme(listener, thisArg, disposables) {
        return extHostTheming.onDidChangeActiveColorTheme(listener, thisArg, disposables);
      },
      registerWebviewViewProvider(viewId, provider, options) {
        return extHostWebviewViews.registerWebviewViewProvider(extension, viewId, provider, options == null ? void 0 : options.webviewOptions);
      },
      get activeNotebookEditor() {
        return extHostNotebook.activeNotebookEditor;
      },
      onDidChangeActiveNotebookEditor(listener, thisArgs, disposables) {
        return extHostNotebook.onDidChangeActiveNotebookEditor(listener, thisArgs, disposables);
      },
      get visibleNotebookEditors() {
        return extHostNotebook.visibleNotebookEditors;
      },
      get onDidChangeVisibleNotebookEditors() {
        return extHostNotebook.onDidChangeVisibleNotebookEditors;
      },
      onDidChangeNotebookEditorSelection(listener, thisArgs, disposables) {
        return extHostNotebookEditors.onDidChangeNotebookEditorSelection(listener, thisArgs, disposables);
      },
      onDidChangeNotebookEditorVisibleRanges(listener, thisArgs, disposables) {
        return extHostNotebookEditors.onDidChangeNotebookEditorVisibleRanges(listener, thisArgs, disposables);
      },
      showNotebookDocument(document2, options) {
        return extHostNotebook.showNotebookDocument(document2, options);
      },
      registerExternalUriOpener(id, opener, metadata) {
        checkProposedApiEnabled(extension, "externalUriOpener");
        return extHostUriOpeners.registerExternalUriOpener(extension.identifier, id, opener, metadata);
      },
      registerProfileContentHandler(id, handler) {
        checkProposedApiEnabled(extension, "profileContentHandlers");
        return extHostProfileContentHandlers.registrProfileContentHandler(extension, id, handler);
      },
      registerQuickDiffProvider(selector, quickDiffProvider, label, rootUri) {
        checkProposedApiEnabled(extension, "quickDiffProvider");
        return extHostQuickDiff.registerQuickDiffProvider(checkSelector(selector), quickDiffProvider, label, rootUri);
      },
      get tabGroups() {
        return extHostEditorTabs.tabGroups;
      },
      registerShareProvider(selector, provider) {
        checkProposedApiEnabled(extension, "shareProvider");
        return extHostShare.registerShareProvider(checkSelector(selector), provider);
      }
    };
    const workspace = {
      get rootPath() {
        extHostApiDeprecation.report("workspace.rootPath", extension, `Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath`);
        return extHostWorkspace.getPath();
      },
      set rootPath(value) {
        throw readonly();
      },
      getWorkspaceFolder(resource) {
        return extHostWorkspace.getWorkspaceFolder(resource);
      },
      get workspaceFolders() {
        return extHostWorkspace.getWorkspaceFolders();
      },
      get name() {
        return extHostWorkspace.name;
      },
      set name(value) {
        throw readonly();
      },
      get workspaceFile() {
        return extHostWorkspace.workspaceFile;
      },
      set workspaceFile(value) {
        throw readonly();
      },
      updateWorkspaceFolders: (index, deleteCount, ...workspaceFoldersToAdd) => {
        return extHostWorkspace.updateWorkspaceFolders(extension, index, deleteCount || 0, ...workspaceFoldersToAdd);
      },
      onDidChangeWorkspaceFolders: function(listener, thisArgs, disposables) {
        return extHostWorkspace.onDidChangeWorkspace(listener, thisArgs, disposables);
      },
      asRelativePath: (pathOrUri, includeWorkspace) => {
        return extHostWorkspace.getRelativePath(pathOrUri, includeWorkspace);
      },
      findFiles: (include, exclude, maxResults, token) => {
        return extHostWorkspace.findFiles(include, exclude, maxResults, extension.identifier, token);
      },
      findTextInFiles: (query, optionsOrCallback, callbackOrToken, token) => {
        checkProposedApiEnabled(extension, "findTextInFiles");
        let options;
        let callback;
        if (typeof optionsOrCallback === "object") {
          options = optionsOrCallback;
          callback = callbackOrToken;
        } else {
          options = {};
          callback = optionsOrCallback;
          token = callbackOrToken;
        }
        return extHostWorkspace.findTextInFiles(query, options || {}, callback, extension.identifier, token);
      },
      save: (uri) => {
        checkProposedApiEnabled(extension, "saveEditor");
        return extHostWorkspace.save(uri);
      },
      saveAs: (uri) => {
        checkProposedApiEnabled(extension, "saveEditor");
        return extHostWorkspace.saveAs(uri);
      },
      saveAll: (includeUntitled) => {
        return extHostWorkspace.saveAll(includeUntitled);
      },
      applyEdit(edit, metadata) {
        return extHostBulkEdits.applyWorkspaceEdit(edit, extension, metadata);
      },
      createFileSystemWatcher: (pattern, ignoreCreate, ignoreChange, ignoreDelete) => {
        return extHostFileSystemEvent.createFileSystemWatcher(extHostWorkspace, extension, pattern, ignoreCreate, ignoreChange, ignoreDelete);
      },
      get textDocuments() {
        return extHostDocuments.getAllDocumentData().map((data) => data.document);
      },
      set textDocuments(value) {
        throw readonly();
      },
      openTextDocument(uriOrFileNameOrOptions) {
        let uriPromise;
        const options = uriOrFileNameOrOptions;
        if (typeof uriOrFileNameOrOptions === "string") {
          uriPromise = Promise.resolve(URI.file(uriOrFileNameOrOptions));
        } else if (URI.isUri(uriOrFileNameOrOptions)) {
          uriPromise = Promise.resolve(uriOrFileNameOrOptions);
        } else if (!options || typeof options === "object") {
          uriPromise = extHostDocuments.createDocumentData(options);
        } else {
          throw new Error("illegal argument - uriOrFileNameOrOptions");
        }
        return uriPromise.then((uri) => {
          return extHostDocuments.ensureDocumentData(uri).then((documentData) => {
            return documentData.document;
          });
        });
      },
      onDidOpenTextDocument: (listener, thisArgs, disposables) => {
        return extHostDocuments.onDidAddDocument(listener, thisArgs, disposables);
      },
      onDidCloseTextDocument: (listener, thisArgs, disposables) => {
        return extHostDocuments.onDidRemoveDocument(listener, thisArgs, disposables);
      },
      onDidChangeTextDocument: (listener, thisArgs, disposables) => {
        return extHostDocuments.onDidChangeDocument(listener, thisArgs, disposables);
      },
      onDidSaveTextDocument: (listener, thisArgs, disposables) => {
        return extHostDocuments.onDidSaveDocument(listener, thisArgs, disposables);
      },
      onWillSaveTextDocument: (listener, thisArgs, disposables) => {
        return extHostDocumentSaveParticipant.getOnWillSaveTextDocumentEvent(extension)(listener, thisArgs, disposables);
      },
      get notebookDocuments() {
        return extHostNotebook.notebookDocuments.map((d) => d.apiNotebook);
      },
      async openNotebookDocument(uriOrType, content) {
        let uri;
        if (URI.isUri(uriOrType)) {
          uri = uriOrType;
          await extHostNotebook.openNotebookDocument(uriOrType);
        } else if (typeof uriOrType === "string") {
          uri = URI.revive(await extHostNotebook.createNotebookDocument({ viewType: uriOrType, content }));
        } else {
          throw new Error("Invalid arguments");
        }
        return extHostNotebook.getNotebookDocument(uri).apiNotebook;
      },
      onDidSaveNotebookDocument(listener, thisArg, disposables) {
        return extHostNotebookDocuments.onDidSaveNotebookDocument(listener, thisArg, disposables);
      },
      onDidChangeNotebookDocument(listener, thisArg, disposables) {
        return extHostNotebookDocuments.onDidChangeNotebookDocument(listener, thisArg, disposables);
      },
      onWillSaveNotebookDocument(listener, thisArg, disposables) {
        return extHostNotebookDocumentSaveParticipant.getOnWillSaveNotebookDocumentEvent(extension)(listener, thisArg, disposables);
      },
      get onDidOpenNotebookDocument() {
        return extHostNotebook.onDidOpenNotebookDocument;
      },
      get onDidCloseNotebookDocument() {
        return extHostNotebook.onDidCloseNotebookDocument;
      },
      registerNotebookSerializer(viewType, serializer, options, registration) {
        return extHostNotebook.registerNotebookSerializer(extension, viewType, serializer, options, isProposedApiEnabled(extension, "notebookLiveShare") ? registration : void 0);
      },
      onDidChangeConfiguration: (listener, thisArgs, disposables) => {
        return configProvider.onDidChangeConfiguration(listener, thisArgs, disposables);
      },
      getConfiguration(section, scope) {
        scope = arguments.length === 1 ? void 0 : scope;
        return configProvider.getConfiguration(section, scope, extension);
      },
      registerTextDocumentContentProvider(scheme, provider) {
        return extHostDocumentContentProviders.registerTextDocumentContentProvider(scheme, provider);
      },
      registerTaskProvider: (type, provider) => {
        extHostApiDeprecation.report("window.registerTaskProvider", extension, `Use the corresponding function on the 'tasks' namespace instead`);
        return extHostTask.registerTaskProvider(extension, type, provider);
      },
      registerFileSystemProvider(scheme, provider, options) {
        return combinedDisposable(extHostFileSystem.registerFileSystemProvider(extension, scheme, provider, options), extHostConsumerFileSystem.addFileSystemProvider(scheme, provider, options));
      },
      get fs() {
        return extHostConsumerFileSystem.value;
      },
      registerFileSearchProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "fileSearchProvider");
        return extHostSearch.registerFileSearchProvider(scheme, provider);
      },
      registerTextSearchProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "textSearchProvider");
        return extHostSearch.registerTextSearchProvider(scheme, provider);
      },
      registerRemoteAuthorityResolver: (authorityPrefix, resolver) => {
        checkProposedApiEnabled(extension, "resolvers");
        return extensionService.registerRemoteAuthorityResolver(authorityPrefix, resolver);
      },
      registerResourceLabelFormatter: (formatter) => {
        checkProposedApiEnabled(extension, "resolvers");
        return extHostLabelService.$registerResourceLabelFormatter(formatter);
      },
      getRemoteExecServer: (authority) => {
        checkProposedApiEnabled(extension, "resolvers");
        return extensionService.getRemoteExecServer(authority);
      },
      onDidCreateFiles: (listener, thisArg, disposables) => {
        return extHostFileSystemEvent.onDidCreateFile(listener, thisArg, disposables);
      },
      onDidDeleteFiles: (listener, thisArg, disposables) => {
        return extHostFileSystemEvent.onDidDeleteFile(listener, thisArg, disposables);
      },
      onDidRenameFiles: (listener, thisArg, disposables) => {
        return extHostFileSystemEvent.onDidRenameFile(listener, thisArg, disposables);
      },
      onWillCreateFiles: (listener, thisArg, disposables) => {
        return extHostFileSystemEvent.getOnWillCreateFileEvent(extension)(listener, thisArg, disposables);
      },
      onWillDeleteFiles: (listener, thisArg, disposables) => {
        return extHostFileSystemEvent.getOnWillDeleteFileEvent(extension)(listener, thisArg, disposables);
      },
      onWillRenameFiles: (listener, thisArg, disposables) => {
        return extHostFileSystemEvent.getOnWillRenameFileEvent(extension)(listener, thisArg, disposables);
      },
      openTunnel: (forward) => {
        checkProposedApiEnabled(extension, "tunnels");
        return extHostTunnelService.openTunnel(extension, forward).then((value) => {
          if (!value) {
            throw new Error("cannot open tunnel");
          }
          return value;
        });
      },
      get tunnels() {
        checkProposedApiEnabled(extension, "tunnels");
        return extHostTunnelService.getTunnels();
      },
      onDidChangeTunnels: (listener, thisArg, disposables) => {
        checkProposedApiEnabled(extension, "tunnels");
        return extHostTunnelService.onDidChangeTunnels(listener, thisArg, disposables);
      },
      registerPortAttributesProvider: (portSelector, provider) => {
        checkProposedApiEnabled(extension, "portsAttributes");
        return extHostTunnelService.registerPortsAttributesProvider(portSelector, provider);
      },
      registerTunnelProvider: (tunnelProvider, information) => {
        checkProposedApiEnabled(extension, "tunnelFactory");
        return extHostTunnelService.registerTunnelProvider(tunnelProvider, information);
      },
      registerTimelineProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "timeline");
        return extHostTimeline.registerTimelineProvider(scheme, provider, extension.identifier, extHostCommands.converter);
      },
      get isTrusted() {
        return extHostWorkspace.trusted;
      },
      requestWorkspaceTrust: (options) => {
        checkProposedApiEnabled(extension, "workspaceTrust");
        return extHostWorkspace.requestWorkspaceTrust(options);
      },
      onDidGrantWorkspaceTrust: (listener, thisArgs, disposables) => {
        return extHostWorkspace.onDidGrantWorkspaceTrust(listener, thisArgs, disposables);
      },
      registerEditSessionIdentityProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "editSessionIdentityProvider");
        return extHostWorkspace.registerEditSessionIdentityProvider(scheme, provider);
      },
      onWillCreateEditSessionIdentity: (listener, thisArgs, disposables) => {
        checkProposedApiEnabled(extension, "editSessionIdentityProvider");
        return extHostWorkspace.getOnWillCreateEditSessionIdentityEvent(extension)(listener, thisArgs, disposables);
      },
      registerCanonicalUriProvider: (scheme, provider) => {
        checkProposedApiEnabled(extension, "canonicalUriProvider");
        return extHostWorkspace.registerCanonicalUriProvider(scheme, provider);
      },
      getCanonicalUri: (uri, options, token) => {
        checkProposedApiEnabled(extension, "canonicalUriProvider");
        return extHostWorkspace.provideCanonicalUri(uri, options, token);
      }
    };
    const scm = {
      get inputBox() {
        extHostApiDeprecation.report("scm.inputBox", extension, `Use 'SourceControl.inputBox' instead`);
        return extHostSCM.getLastInputBox(extension);
      },
      createSourceControl(id, label, rootUri) {
        return extHostSCM.createSourceControl(extension, id, label, rootUri);
      }
    };
    const comments = {
      createCommentController(id, label) {
        return extHostComment.createCommentController(extension, id, label);
      }
    };
    const debug = {
      get activeDebugSession() {
        return extHostDebugService.activeDebugSession;
      },
      get activeDebugConsole() {
        return extHostDebugService.activeDebugConsole;
      },
      get breakpoints() {
        return extHostDebugService.breakpoints;
      },
      get stackFrameFocus() {
        return extHostDebugService.stackFrameFocus;
      },
      onDidStartDebugSession(listener, thisArg, disposables) {
        return extHostDebugService.onDidStartDebugSession(listener, thisArg, disposables);
      },
      onDidTerminateDebugSession(listener, thisArg, disposables) {
        return extHostDebugService.onDidTerminateDebugSession(listener, thisArg, disposables);
      },
      onDidChangeActiveDebugSession(listener, thisArg, disposables) {
        return extHostDebugService.onDidChangeActiveDebugSession(listener, thisArg, disposables);
      },
      onDidReceiveDebugSessionCustomEvent(listener, thisArg, disposables) {
        return extHostDebugService.onDidReceiveDebugSessionCustomEvent(listener, thisArg, disposables);
      },
      onDidChangeBreakpoints(listener, thisArgs, disposables) {
        return extHostDebugService.onDidChangeBreakpoints(listener, thisArgs, disposables);
      },
      onDidChangeStackFrameFocus(listener, thisArg, disposables) {
        checkProposedApiEnabled(extension, "debugFocus");
        return extHostDebugService.onDidChangeStackFrameFocus(listener, thisArg, disposables);
      },
      registerDebugConfigurationProvider(debugType, provider, triggerKind) {
        return extHostDebugService.registerDebugConfigurationProvider(debugType, provider, triggerKind || DebugConfigurationProviderTriggerKind.Initial);
      },
      registerDebugAdapterDescriptorFactory(debugType, factory) {
        return extHostDebugService.registerDebugAdapterDescriptorFactory(extension, debugType, factory);
      },
      registerDebugAdapterTrackerFactory(debugType, factory) {
        return extHostDebugService.registerDebugAdapterTrackerFactory(debugType, factory);
      },
      startDebugging(folder, nameOrConfig, parentSessionOrOptions) {
        if (!parentSessionOrOptions || typeof parentSessionOrOptions === "object" && "configuration" in parentSessionOrOptions) {
          return extHostDebugService.startDebugging(folder, nameOrConfig, { parentSession: parentSessionOrOptions });
        }
        return extHostDebugService.startDebugging(folder, nameOrConfig, parentSessionOrOptions || {});
      },
      stopDebugging(session) {
        return extHostDebugService.stopDebugging(session);
      },
      addBreakpoints(breakpoints) {
        return extHostDebugService.addBreakpoints(breakpoints);
      },
      removeBreakpoints(breakpoints) {
        return extHostDebugService.removeBreakpoints(breakpoints);
      },
      asDebugSourceUri(source, session) {
        return extHostDebugService.asDebugSourceUri(source, session);
      }
    };
    const tasks = {
      registerTaskProvider: (type, provider) => {
        return extHostTask.registerTaskProvider(extension, type, provider);
      },
      fetchTasks: (filter2) => {
        return extHostTask.fetchTasks(filter2);
      },
      executeTask: (task) => {
        return extHostTask.executeTask(extension, task);
      },
      get taskExecutions() {
        return extHostTask.taskExecutions;
      },
      onDidStartTask: (listeners, thisArgs, disposables) => {
        return extHostTask.onDidStartTask(listeners, thisArgs, disposables);
      },
      onDidEndTask: (listeners, thisArgs, disposables) => {
        return extHostTask.onDidEndTask(listeners, thisArgs, disposables);
      },
      onDidStartTaskProcess: (listeners, thisArgs, disposables) => {
        return extHostTask.onDidStartTaskProcess(listeners, thisArgs, disposables);
      },
      onDidEndTaskProcess: (listeners, thisArgs, disposables) => {
        return extHostTask.onDidEndTaskProcess(listeners, thisArgs, disposables);
      }
    };
    const notebooks = {
      createNotebookController(id, notebookType, label, handler, rendererScripts) {
        return extHostNotebookKernels.createNotebookController(extension, id, notebookType, label, handler, isProposedApiEnabled(extension, "notebookMessaging") ? rendererScripts : void 0);
      },
      registerNotebookCellStatusBarItemProvider: (notebookType, provider) => {
        return extHostNotebook.registerNotebookCellStatusBarItemProvider(extension, notebookType, provider);
      },
      createRendererMessaging(rendererId) {
        return extHostNotebookRenderers.createRendererMessaging(extension, rendererId);
      },
      createNotebookControllerDetectionTask(notebookType) {
        checkProposedApiEnabled(extension, "notebookKernelSource");
        return extHostNotebookKernels.createNotebookControllerDetectionTask(extension, notebookType);
      },
      registerKernelSourceActionProvider(notebookType, provider) {
        checkProposedApiEnabled(extension, "notebookKernelSource");
        return extHostNotebookKernels.registerKernelSourceActionProvider(extension, notebookType, provider);
      },
      onDidChangeNotebookCellExecutionState(listener, thisArgs, disposables) {
        checkProposedApiEnabled(extension, "notebookCellExecutionState");
        return extHostNotebookKernels.onDidChangeNotebookCellExecutionState(listener, thisArgs, disposables);
      }
    };
    const l10n = {
      t(...params) {
        if (typeof params[0] === "string") {
          const key = params.shift();
          const argsFormatted = !params || typeof params[0] !== "object" ? params : params[0];
          return extHostLocalization.getMessage(extension.identifier.value, { message: key, args: argsFormatted });
        }
        return extHostLocalization.getMessage(extension.identifier.value, params[0]);
      },
      get bundle() {
        return extHostLocalization.getBundle(extension.identifier.value);
      },
      get uri() {
        return extHostLocalization.getBundleUri(extension.identifier.value);
      }
    };
    const interactive = {
      _version: 1,
      registerInteractiveEditorSessionProvider(provider) {
        checkProposedApiEnabled(extension, "interactive");
        return extHostInteractiveEditor.registerProvider(extension, provider);
      },
      registerInteractiveSessionProvider(id, provider) {
        checkProposedApiEnabled(extension, "interactive");
        return extHostChat.registerChatProvider(extension, id, provider);
      },
      addInteractiveRequest(context) {
        checkProposedApiEnabled(extension, "interactive");
        return extHostChat.addChatRequest(context);
      },
      sendInteractiveRequestToProvider(providerId, message) {
        checkProposedApiEnabled(extension, "interactive");
        return extHostChat.sendInteractiveRequestToProvider(providerId, message);
      },
      get onDidPerformUserAction() {
        checkProposedApiEnabled(extension, "interactiveUserActions");
        return extHostChat.onDidPerformUserAction;
      },
      transferChatSession(session, toWorkspace) {
        checkProposedApiEnabled(extension, "interactive");
        return extHostChat.transferChatSession(session, toWorkspace);
      }
    };
    const ai = {
      getRelatedInformation(query, types) {
        checkProposedApiEnabled(extension, "aiRelatedInformation");
        return extHostAiRelatedInformation.getRelatedInformation(extension, query, types);
      },
      registerRelatedInformationProvider(type, provider) {
        checkProposedApiEnabled(extension, "aiRelatedInformation");
        return extHostAiRelatedInformation.registerRelatedInformationProvider(extension, type, provider);
      },
      registerEmbeddingVectorProvider(model, provider) {
        checkProposedApiEnabled(extension, "aiRelatedInformation");
        return extHostAiEmbeddingVector.registerEmbeddingVectorProvider(extension, model, provider);
      }
    };
    const chat = {
      registerChatResponseProvider(id, provider, metadata) {
        checkProposedApiEnabled(extension, "chatProvider");
        return extHostChatProvider.registerProvider(extension.identifier, id, provider, metadata);
      },
      registerSlashCommand(name, command, metadata) {
        checkProposedApiEnabled(extension, "chatSlashCommands");
        return extHostChatSlashCommands.registerCommand(extension.identifier, name, command, metadata ?? { description: "" });
      },
      requestChatAccess(id) {
        checkProposedApiEnabled(extension, "chatRequestAccess");
        return extHostChatProvider.requestChatResponseProvider(extension.identifier, id);
      },
      registerVariable(name, description, resolver) {
        checkProposedApiEnabled(extension, "chatVariables");
        return extHostChatVariables.registerVariableResolver(extension, name, description, resolver);
      },
      registerMappedEditsProvider(selector, provider) {
        checkProposedApiEnabled(extension, "mappedEditsProvider");
        return extHostLanguageFeatures.registerMappedEditsProvider(extension, selector, provider);
      }
    };
    return {
      version: initData.version,
      ai,
      authentication,
      commands,
      comments,
      chat,
      debug,
      env: env2,
      extensions,
      interactive,
      l10n,
      languages,
      notebooks,
      scm,
      tasks,
      tests,
      window: window2,
      workspace,
      Breakpoint,
      TerminalOutputAnchor,
      ChatMessage,
      ChatMessageRole,
      ChatVariableLevel,
      CallHierarchyIncomingCall,
      CallHierarchyItem,
      CallHierarchyOutgoingCall,
      CancellationError,
      CancellationTokenSource,
      CandidatePortSource,
      CodeAction,
      CodeActionKind,
      CodeActionTriggerKind,
      CodeLens,
      Color,
      ColorInformation,
      ColorPresentation,
      ColorThemeKind,
      CommentMode: CommentMode2,
      CommentState,
      CommentThreadCollapsibleState: CommentThreadCollapsibleState2,
      CommentThreadState: CommentThreadState2,
      CompletionItem,
      CompletionItemKind,
      CompletionItemTag,
      CompletionList,
      CompletionTriggerKind,
      ConfigurationTarget,
      CustomExecution,
      DebugAdapterExecutable,
      DebugAdapterInlineImplementation,
      DebugAdapterNamedPipeServer,
      DebugAdapterServer,
      DebugConfigurationProviderTriggerKind,
      DebugConsoleMode,
      DecorationRangeBehavior,
      Diagnostic,
      DiagnosticRelatedInformation,
      DiagnosticSeverity,
      DiagnosticTag,
      Disposable: Disposable2,
      DocumentHighlight,
      DocumentHighlightKind,
      DocumentLink,
      DocumentSymbol,
      EndOfLine,
      EnvironmentVariableMutatorType,
      EvaluatableExpression,
      InlineValueText,
      InlineValueVariableLookup,
      InlineValueEvaluatableExpression,
      InlineCompletionTriggerKind: InlineCompletionTriggerKind2,
      EventEmitter: Emitter,
      ExtensionKind,
      ExtensionMode,
      ExternalUriOpenerPriority,
      FileChangeType,
      FileDecoration,
      FileDecoration2: FileDecoration,
      FileSystemError,
      FileType,
      FilePermission,
      FoldingRange,
      FoldingRangeKind: FoldingRangeKind2,
      FunctionBreakpoint,
      InlineCompletionItem: InlineSuggestion,
      InlineCompletionList: InlineSuggestionList,
      Hover,
      IndentAction,
      Location,
      MarkdownString: MarkdownString2,
      OverviewRulerLane,
      ParameterInformation,
      PortAutoForwardAction,
      Position: Position2,
      ProcessExecution,
      ProgressLocation,
      QuickInputButtons,
      Range: Range2,
      RelativePattern,
      Selection,
      SelectionRange,
      SemanticTokens,
      SemanticTokensBuilder,
      SemanticTokensEdit,
      SemanticTokensEdits,
      SemanticTokensLegend,
      ShellExecution,
      ShellQuoting,
      SignatureHelp,
      SignatureHelpTriggerKind,
      SignatureInformation,
      SnippetString,
      SourceBreakpoint,
      StandardTokenType,
      StatusBarAlignment,
      SymbolInformation,
      SymbolKind,
      SymbolTag,
      Task,
      TaskGroup,
      TaskPanelKind,
      TaskRevealKind,
      TaskScope,
      TerminalLink,
      TerminalQuickFixExecuteTerminalCommand: TerminalQuickFixCommand,
      TerminalQuickFixOpener,
      TerminalLocation,
      TerminalProfile,
      TerminalExitReason,
      TextDocumentSaveReason,
      TextEdit,
      SnippetTextEdit,
      TextEditorCursorStyle,
      TextEditorLineNumbersStyle,
      TextEditorRevealType: TextEditorRevealType2,
      TextEditorSelectionChangeKind,
      TextDocumentChangeReason,
      ThemeColor: ThemeColor2,
      ThemeIcon: ThemeIcon2,
      TreeItem,
      TreeItemCheckboxState,
      TreeItemCollapsibleState,
      TypeHierarchyItem,
      UIKind,
      Uri: URI,
      ViewColumn,
      WorkspaceEdit,
      DocumentDropEdit,
      DocumentPasteEdit,
      InlayHint,
      InlayHintLabelPart,
      InlayHintKind,
      RemoteAuthorityResolverError: RemoteAuthorityResolverError2,
      ResolvedAuthority,
      ManagedResolvedAuthority,
      SourceControlInputBoxValidationType,
      ExtensionRuntime,
      TimelineItem,
      NotebookRange,
      NotebookCellKind,
      NotebookCellExecutionState: NotebookCellExecutionState2,
      NotebookCellData,
      NotebookData,
      NotebookRendererScript,
      NotebookCellStatusBarAlignment,
      NotebookEditorRevealType: NotebookEditorRevealType2,
      NotebookCellOutput,
      NotebookCellOutputItem,
      NotebookCellStatusBarItem,
      NotebookControllerAffinity,
      NotebookControllerAffinity2,
      NotebookEdit,
      NotebookKernelSourceAction,
      PortAttributes,
      LinkedEditingRanges,
      TestResultState,
      TestRunRequest,
      TestMessage,
      TestMessage2: TestMessage,
      TestTag,
      TestRunProfileKind,
      TextSearchCompleteMessageType,
      DataTransfer,
      DataTransferItem,
      CoveredCount,
      FileCoverage,
      StatementCoverage,
      BranchCoverage,
      FunctionCoverage,
      WorkspaceTrustState,
      LanguageStatusSeverity,
      QuickPickItemKind,
      InputBoxValidationSeverity,
      TabInputText: TextTabInput,
      TabInputTextDiff: TextDiffTabInput,
      TabInputTextMerge: TextMergeTabInput,
      TabInputCustom: CustomEditorTabInput,
      TabInputNotebook: NotebookEditorTabInput,
      TabInputNotebookDiff: NotebookDiffEditorTabInput,
      TabInputWebview: WebviewEditorTabInput,
      TabInputTerminal: TerminalEditorTabInput,
      TabInputInteractiveWindow: InteractiveWindowInput,
      TelemetryTrustedValue,
      LogLevel,
      EditSessionIdentityMatch,
      InteractiveSessionVoteDirection,
      InteractiveSessionCopyKind,
      InteractiveEditorResponseFeedbackKind,
      StackFrameFocus,
      ThreadFocus,
      NotebookCodeActionKind,
      RelatedInformationType
    };
  };
}

// node_modules/vscode/vscode/src/vs/workbench/api/worker/extHostExtensionService.js
init_uri();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostRequireInterceptor.js
init_tslib_es6();
init_uri();
init_extHost_protocol();
init_extensions();
init_instantiation();
init_process();
init_log();
init_strings();
var NodeModuleAliasingModuleFactory_1;
var RequireInterceptor = class RequireInterceptor2 {
  constructor(_apiFactory, _extensionRegistry, _instaService, _extHostConfiguration, _extHostExtensionService, _initData, _logService) {
    this._apiFactory = _apiFactory;
    this._extensionRegistry = _extensionRegistry;
    this._instaService = _instaService;
    this._extHostConfiguration = _extHostConfiguration;
    this._extHostExtensionService = _extHostExtensionService;
    this._initData = _initData;
    this._logService = _logService;
    this._factories = /* @__PURE__ */ new Map();
    this._alternatives = [];
  }
  async install() {
    this._installInterceptor();
    mark("code/extHost/willWaitForConfig");
    const configProvider = await this._extHostConfiguration.getConfigProvider();
    mark("code/extHost/didWaitForConfig");
    const extensionPaths = await this._extHostExtensionService.getExtensionPathIndex();
    this.register(new VSCodeNodeModuleFactory(
      this._apiFactory,
      extensionPaths,
      this._extensionRegistry,
      configProvider,
      this._logService
    ));
    this.register(this._instaService.createInstance(KeytarNodeModuleFactory, extensionPaths));
    this.register(this._instaService.createInstance(NodeModuleAliasingModuleFactory));
    if (this._initData.remote.isRemote) {
      this.register(this._instaService.createInstance(OpenNodeModuleFactory, extensionPaths, this._initData.environment.appUriScheme));
    }
  }
  register(interceptor) {
    if ("nodeModuleName" in interceptor) {
      if (Array.isArray(interceptor.nodeModuleName)) {
        for (const moduleName of interceptor.nodeModuleName) {
          this._factories.set(moduleName, interceptor);
        }
      } else {
        this._factories.set(interceptor.nodeModuleName, interceptor);
      }
    }
    if (typeof interceptor.alternativeModuleName === "function") {
      this._alternatives.push((moduleName) => {
        return interceptor.alternativeModuleName(moduleName);
      });
    }
  }
};
RequireInterceptor = __decorate([
  __param(2, IInstantiationService),
  __param(3, IExtHostConfiguration),
  __param(4, IExtHostExtensionService),
  __param(5, IExtHostInitDataService),
  __param(6, ILogService)
], RequireInterceptor);
var _a7;
var NodeModuleAliasingModuleFactory = (_a7 = class {
  constructor(initData) {
    if (initData.environment.appRoot && NodeModuleAliasingModuleFactory_1.aliased.size) {
      const root = escapeRegExpCharacters(this.forceForwardSlashes(initData.environment.appRoot.fsPath));
      const npmIdChrs = `[a-z0-9_.-]`;
      const npmModuleName = `@${npmIdChrs}+\\/${npmIdChrs}+|${npmIdChrs}+`;
      const moduleFolders = "node_modules|node_modules\\.asar(?:\\.unpacked)?";
      this.re = new RegExp(`^(${root}/${moduleFolders}\\/)(${npmModuleName})(.*)$`, "i");
    }
  }
  alternativeModuleName(name) {
    if (!this.re) {
      return;
    }
    const result = this.re.exec(this.forceForwardSlashes(name));
    if (!result) {
      return;
    }
    const [, prefix, moduleName, suffix] = result;
    const dealiased = NodeModuleAliasingModuleFactory_1.aliased.get(moduleName);
    if (dealiased === void 0) {
      return;
    }
    console.warn(`${moduleName} as been renamed to ${dealiased}, please update your imports`);
    return prefix + dealiased + suffix;
  }
  forceForwardSlashes(str) {
    return str.replace(/\\/g, "/");
  }
}, NodeModuleAliasingModuleFactory_1 = _a7, _a7.aliased = /* @__PURE__ */ new Map([
  ["vscode-ripgrep", "@vscode/ripgrep"],
  ["vscode-windows-registry", "@vscode/windows-registry"]
]), _a7);
NodeModuleAliasingModuleFactory = NodeModuleAliasingModuleFactory_1 = __decorate([
  __param(0, IExtHostInitDataService)
], NodeModuleAliasingModuleFactory);
var VSCodeNodeModuleFactory = class {
  constructor(_apiFactory, _extensionPaths, _extensionRegistry, _configProvider, _logService) {
    this._apiFactory = _apiFactory;
    this._extensionPaths = _extensionPaths;
    this._extensionRegistry = _extensionRegistry;
    this._configProvider = _configProvider;
    this._logService = _logService;
    this.nodeModuleName = "vscode";
    this._extApiImpl = new ExtensionIdentifierMap();
  }
  load(_request, parent) {
    const ext = this._extensionPaths.findSubstr(parent);
    if (ext) {
      let apiImpl = this._extApiImpl.get(ext.identifier);
      if (!apiImpl) {
        apiImpl = this._apiFactory(ext, this._extensionRegistry, this._configProvider);
        this._extApiImpl.set(ext.identifier, apiImpl);
      }
      return apiImpl;
    }
    if (!this._defaultApiImpl) {
      let extensionPathsPretty = "";
      this._extensionPaths.forEach((value, index) => extensionPathsPretty += `	${index} -> ${value.identifier.value}
`);
      this._logService.warn(`Could not identify extension for 'vscode' require call from ${parent}. These are the extension path mappings: 
${extensionPathsPretty}`);
      this._defaultApiImpl = this._apiFactory(nullExtensionDescription, this._extensionRegistry, this._configProvider);
    }
    return this._defaultApiImpl;
  }
};
var KeytarNodeModuleFactory = class KeytarNodeModuleFactory2 {
  constructor(_extensionPaths, rpcService, initData) {
    this._extensionPaths = _extensionPaths;
    this.nodeModuleName = "keytar";
    this._mainThreadTelemetry = rpcService.getProxy(MainContext.MainThreadTelemetry);
    const { environment } = initData;
    const mainThreadKeytar = rpcService.getProxy(MainContext.MainThreadKeytar);
    if (environment.appRoot) {
      let appRoot = environment.appRoot.fsPath;
      if (platform2 === "win32") {
        appRoot = appRoot.replace(/\\/g, "/");
      }
      if (appRoot[appRoot.length - 1] === "/") {
        appRoot = appRoot.substr(0, appRoot.length - 1);
      }
      this.alternativeNames = /* @__PURE__ */ new Set();
      this.alternativeNames.add(`${appRoot}/node_modules.asar/keytar`);
      this.alternativeNames.add(`${appRoot}/node_modules/keytar`);
    }
    this._impl = {
      getPassword: (service, account) => {
        return mainThreadKeytar.$getPassword(service, account);
      },
      setPassword: (service, account, password) => {
        return mainThreadKeytar.$setPassword(service, account, password);
      },
      deletePassword: (service, account) => {
        return mainThreadKeytar.$deletePassword(service, account);
      },
      findPassword: (service) => {
        return mainThreadKeytar.$findPassword(service);
      },
      findCredentials(service) {
        return mainThreadKeytar.$findCredentials(service);
      }
    };
  }
  load(_request, parent) {
    const ext = this._extensionPaths.findSubstr(parent);
    this._mainThreadTelemetry.$publicLog2("shimming.keytar", { extension: (ext == null ? void 0 : ext.identifier.value) ?? "unknown_extension" });
    return this._impl;
  }
  alternativeModuleName(name) {
    const length = name.length;
    if (length <= 7 || !this.alternativeNames) {
      return void 0;
    }
    const sep2 = length - 7;
    if ((name.charAt(sep2) === "/" || name.charAt(sep2) === "\\") && name.endsWith("keytar")) {
      name = name.replace(/\\/g, "/");
      if (this.alternativeNames.has(name)) {
        return "keytar";
      }
    }
    return void 0;
  }
};
KeytarNodeModuleFactory = __decorate([
  __param(1, IExtHostRpcService),
  __param(2, IExtHostInitDataService)
], KeytarNodeModuleFactory);
var OpenNodeModuleFactory = class OpenNodeModuleFactory2 {
  constructor(_extensionPaths, _appUriScheme, rpcService) {
    this._extensionPaths = _extensionPaths;
    this._appUriScheme = _appUriScheme;
    this.nodeModuleName = ["open", "opn"];
    this._mainThreadTelemetry = rpcService.getProxy(MainContext.MainThreadTelemetry);
    const mainThreadWindow = rpcService.getProxy(MainContext.MainThreadWindow);
    this._impl = (target, options) => {
      const uri = URI.parse(target);
      if (options) {
        return this.callOriginal(target, options);
      }
      if (uri.scheme === "http" || uri.scheme === "https") {
        return mainThreadWindow.$openUri(uri, target, { allowTunneling: true });
      } else if (uri.scheme === "mailto" || uri.scheme === this._appUriScheme) {
        return mainThreadWindow.$openUri(uri, target, {});
      }
      return this.callOriginal(target, options);
    };
  }
  load(request, parent, original2) {
    const extension = this._extensionPaths.findSubstr(parent);
    if (extension) {
      this._extensionId = extension.identifier.value;
      this.sendShimmingTelemetry();
    }
    this._original = original2(request);
    return this._impl;
  }
  callOriginal(target, options) {
    this.sendNoForwardTelemetry();
    return this._original(target, options);
  }
  sendShimmingTelemetry() {
    if (!this._extensionId) {
      return;
    }
    this._mainThreadTelemetry.$publicLog2("shimming.open", { extension: this._extensionId });
  }
  sendNoForwardTelemetry() {
    if (!this._extensionId) {
      return;
    }
    this._mainThreadTelemetry.$publicLog2("shimming.open.call.noForward", { extension: this._extensionId });
  }
};
OpenNodeModuleFactory = __decorate([
  __param(2, IExtHostRpcService)
], OpenNodeModuleFactory);

// node_modules/vscode/vscode/src/vs/workbench/api/worker/extHostExtensionService.js
init_extHostTypes();
init_async();

// node_modules/vscode/vscode/src/vs/workbench/api/worker/extHostConsoleForwarder.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostConsoleForwarder.js
init_tslib_es6();
init_objects();
init_extHost_protocol();
var AbstractExtHostConsoleForwarder = class AbstractExtHostConsoleForwarder2 {
  constructor(extHostRpc, initData) {
    this._mainThreadConsole = extHostRpc.getProxy(MainContext.MainThreadConsole);
    this._includeStack = initData.consoleForward.includeStack;
    this._logNative = initData.consoleForward.logNative;
    this._wrapConsoleMethod("info", "log");
    this._wrapConsoleMethod("log", "log");
    this._wrapConsoleMethod("warn", "warn");
    this._wrapConsoleMethod("error", "error");
  }
  _wrapConsoleMethod(method, severity) {
    const that = this;
    const original2 = console[method];
    Object.defineProperty(console, method, {
      set: () => {
      },
      get: () => function() {
        that._handleConsoleCall(method, severity, original2, arguments);
      }
    });
  }
  _handleConsoleCall(method, severity, original2, args) {
    this._mainThreadConsole.$logExtensionHostMessage({
      type: "__$console",
      severity,
      arguments: safeStringifyArgumentsToArray(args, this._includeStack)
    });
    if (this._logNative) {
      this._nativeConsoleLogMessage(method, original2, args);
    }
  }
};
AbstractExtHostConsoleForwarder = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService)
], AbstractExtHostConsoleForwarder);
var MAX_LENGTH = 1e5;
function safeStringifyArgumentsToArray(args, includeStack) {
  const argsArray = [];
  if (args.length) {
    for (let i = 0; i < args.length; i++) {
      let arg = args[i];
      if (typeof arg === "undefined") {
        arg = "undefined";
      } else if (arg instanceof Error) {
        const errorObj = arg;
        if (errorObj.stack) {
          arg = errorObj.stack;
        } else {
          arg = errorObj.toString();
        }
      }
      argsArray.push(arg);
    }
  }
  if (includeStack) {
    const stack = new Error().stack;
    if (stack) {
      argsArray.push({ __$stack: stack.split("\n").slice(3).join("\n") });
    }
  }
  try {
    const res = safeStringify(argsArray);
    if (res.length > MAX_LENGTH) {
      return "Output omitted for a large object that exceeds the limits";
    }
    return res;
  } catch (error) {
    return `Output omitted for an object that cannot be inspected ('${error.toString()}')`;
  }
}

// node_modules/vscode/vscode/src/vs/workbench/api/worker/extHostConsoleForwarder.js
var ExtHostConsoleForwarder = class ExtHostConsoleForwarder2 extends AbstractExtHostConsoleForwarder {
  constructor(extHostRpc, initData) {
    super(extHostRpc, initData);
  }
  _nativeConsoleLogMessage(method, original2, args) {
    original2.apply(console, args);
  }
};
ExtHostConsoleForwarder = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService)
], ExtHostConsoleForwarder);

// node_modules/vscode/vscode/src/vs/workbench/api/worker/extHostExtensionService.js
init_platform();
var WorkerRequireInterceptor = class extends RequireInterceptor {
  _installInterceptor() {
  }
  getModule(request, parent) {
    for (const alternativeModuleName of this._alternatives) {
      const alternative = alternativeModuleName(request);
      if (alternative) {
        request = alternative;
        break;
      }
    }
    if (this._factories.has(request)) {
      return this._factories.get(request).load(request, parent, () => {
        throw new Error("CANNOT LOAD MODULE from here.");
      });
    }
    return void 0;
  }
};
var ExtHostExtensionService = class extends AbstractExtHostExtensionService {
  constructor() {
    super(...arguments);
    this.extensionRuntime = ExtensionRuntime.Webworker;
  }
  async _beforeAlmostReadyToRunExtensions() {
    if (isWebWorker) {
      this._instaService.createInstance(ExtHostConsoleForwarder);
    }
    this._apiFactory = this._instaService.invokeFunction(createApiFactoryAndRegisterActors);
    this._fakeModules = this._instaService.createInstance(WorkerRequireInterceptor, this._apiFactory, { mine: this._myRegistry, all: this._globalRegistry });
    await this._fakeModules.install();
    performance.mark("code/extHost/didInitAPI");
    await this._waitForDebuggerAttachment();
  }
  _getEntryPoint(extensionDescription) {
    return extensionDescription.browser;
  }
  async _loadCommonJSModule(extension, module, activationTimesBuilder) {
    module = module.with({ path: ensureSuffix(module.path, ".js") });
    const extensionId = extension == null ? void 0 : extension.identifier.value;
    if (extensionId) {
      performance.mark(`code/extHost/willFetchExtensionCode/${extensionId}`);
    }
    const browserUri = URI.revive(await this._mainThreadExtensionsProxy.$asBrowserUri(module));
    const response = await fetch(browserUri.toString(true));
    if (extensionId) {
      performance.mark(`code/extHost/didFetchExtensionCode/${extensionId}`);
    }
    if (response.status !== 200) {
      throw new Error(response.statusText);
    }
    const source = await response.text();
    const sourceURL = `${module.toString(true)}#vscode-extension`;
    const fullSource = `${source}
//# sourceURL=${sourceURL}`;
    let initFn;
    try {
      initFn = new Function("module", "exports", "require", fullSource);
    } catch (err) {
      if (extensionId) {
        console.error(`Loading code for extension ${extensionId} failed: ${err.message}`);
      } else {
        console.error(`Loading code failed: ${err.message}`);
      }
      console.error(`${module.toString(true)}${typeof err.line === "number" ? ` line ${err.line}` : ""}${typeof err.column === "number" ? ` column ${err.column}` : ""}`);
      console.error(err);
      throw err;
    }
    if (extension) {
      await this._extHostLocalizationService.initializeLocalizedMessages(extension);
    }
    const _exports = {};
    const _module = { exports: _exports };
    const _require = (request) => {
      const result = this._fakeModules.getModule(request, module);
      if (result === void 0) {
        throw new Error(`Cannot load module '${request}'`);
      }
      return result;
    };
    try {
      activationTimesBuilder.codeLoadingStart();
      if (extensionId) {
        performance.mark(`code/extHost/willLoadExtensionCode/${extensionId}`);
      }
      initFn(_module, _exports, _require);
      return _module.exports !== _exports ? _module.exports : _exports;
    } finally {
      if (extensionId) {
        performance.mark(`code/extHost/didLoadExtensionCode/${extensionId}`);
      }
      activationTimesBuilder.codeLoadingStop();
    }
  }
  async $setRemoteEnvironment(_env) {
    return;
  }
  async _waitForDebuggerAttachment(waitTimeout = 5e3) {
    if (!this._initData.environment.isExtensionDevelopmentDebug) {
      return;
    }
    const deadline = Date.now() + waitTimeout;
    while (Date.now() < deadline && !("__jsDebugIsReady" in globalThis)) {
      await timeout(10);
    }
  }
};
function ensureSuffix(path, suffix) {
  return path.endsWith(suffix) ? path : path + suffix;
}

// node_modules/vscode/service-override/extensions.js
init_uri();
init_platform();
init_extensions2();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extensionHostMain.js
init_errors();
init_uri();
init_extHost_protocol();
init_log();
init_extensions2();
init_platform();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLogService.js
init_tslib_es6();
init_nls();
init_log();
var ExtHostLogService = class ExtHostLogService2 extends LogService {
  constructor(isWorker, loggerService, initData) {
    const id = initData.remote.isRemote ? "remoteexthost" : isWorker ? "workerexthost" : "exthost";
    const name = initData.remote.isRemote ? localize("remote", "Extension Host (Remote)") : isWorker ? localize("worker", "Extension Host (Worker)") : localize("local", "Extension Host");
    super(loggerService.createLogger(id, { name }));
  }
};
ExtHostLogService = __decorate([
  __param(1, ILoggerService),
  __param(2, IExtHostInitDataService)
], ExtHostLogService);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extensionHostMain.js
init_descriptors();

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLoggerService.js
init_tslib_es6();
init_log();
init_extHost_protocol();
init_uri();
var ExtHostLoggerService = class ExtHostLoggerService2 extends AbstractLoggerService {
  constructor(rpc, initData) {
    super(initData.logLevel, initData.logsLocation, initData.loggers.map((logger) => revive(logger)));
    this._proxy = rpc.getProxy(MainContext.MainThreadLogger);
  }
  $setLogLevel(logLevel, resource) {
    if (resource) {
      this.setLogLevel(URI.revive(resource), logLevel);
    } else {
      this.setLogLevel(logLevel);
    }
  }
  setVisibility(resource, visibility) {
    super.setVisibility(resource, visibility);
    this._proxy.$setVisibility(resource, visibility);
  }
  doCreateLogger(resource, logLevel, options) {
    return new Logger(this._proxy, resource, logLevel, options);
  }
};
ExtHostLoggerService = __decorate([
  __param(0, IExtHostRpcService),
  __param(1, IExtHostInitDataService)
], ExtHostLoggerService);
var Logger = class extends AbstractMessageLogger {
  constructor(proxy, file, logLevel, loggerOptions) {
    super((loggerOptions == null ? void 0 : loggerOptions.logLevel) === "always");
    this.proxy = proxy;
    this.file = file;
    this.isLoggerCreated = false;
    this.buffer = [];
    this.setLevel(logLevel);
    this.proxy.$createLogger(file, loggerOptions).then(() => {
      this.doLog(this.buffer);
      this.isLoggerCreated = true;
    });
  }
  log(level, message) {
    const messages = [[level, message]];
    if (this.isLoggerCreated) {
      this.doLog(messages);
    } else {
      this.buffer.push(...messages);
    }
  }
  doLog(messages) {
    this.proxy.$log(this.file, messages);
  }
  flush() {
    this.proxy.$flush(this.file);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/common/extensionHostMain.js
var ErrorHandler = class {
  static async installEarlyHandler(accessor) {
    Error.stackTraceLimit = 100;
    const logService = accessor.get(ILogService);
    const rpcService = accessor.get(IExtHostRpcService);
    const mainThreadErrors = rpcService.getProxy(MainContext.MainThreadErrors);
    setUnexpectedErrorHandler((err) => {
      logService.error(err);
      const data = transformErrorForSerialization(err);
      mainThreadErrors.$onUnexpectedError(data);
    });
  }
  static async installFullHandler(accessor) {
    const logService = accessor.get(ILogService);
    const rpcService = accessor.get(IExtHostRpcService);
    const extensionService = accessor.get(IExtHostExtensionService);
    const extensionTelemetry = accessor.get(IExtHostTelemetry);
    const mainThreadExtensions = rpcService.getProxy(MainContext.MainThreadExtensionService);
    const mainThreadErrors = rpcService.getProxy(MainContext.MainThreadErrors);
    const map = await extensionService.getExtensionPathIndex();
    const extensionErrors = /* @__PURE__ */ new WeakMap();
    function prepareStackTraceAndFindExtension(error, stackTrace) {
      if (extensionErrors.has(error)) {
        return extensionErrors.get(error).stack;
      }
      let stackTraceMessage = "";
      let extension;
      let fileName;
      for (const call of stackTrace) {
        stackTraceMessage += `
	at ${call.toString()}`;
        fileName = call.getFileName();
        if (!extension && fileName) {
          extension = map.findSubstr(URI.file(fileName));
        }
      }
      const result = `${error.name || "Error"}: ${error.message || ""}${stackTraceMessage}`;
      extensionErrors.set(error, { extensionIdentifier: extension == null ? void 0 : extension.identifier, stack: result });
      return result;
    }
    const _wasWrapped = Symbol("prepareStackTrace wrapped");
    let _prepareStackTrace = prepareStackTraceAndFindExtension;
    Object.defineProperty(Error, "prepareStackTrace", {
      configurable: false,
      get() {
        return _prepareStackTrace;
      },
      set(v) {
        if (v === prepareStackTraceAndFindExtension || !v || v[_wasWrapped]) {
          _prepareStackTrace = v || prepareStackTraceAndFindExtension;
          return;
        }
        _prepareStackTrace = function(error, stackTrace) {
          prepareStackTraceAndFindExtension(error, stackTrace);
          return v.call(Error, error, stackTrace);
        };
        Object.assign(_prepareStackTrace, { [_wasWrapped]: true });
      }
    });
    setUnexpectedErrorHandler((err) => {
      logService.error(err);
      const errorData = transformErrorForSerialization(err);
      const stackData = extensionErrors.get(err);
      if (!(stackData == null ? void 0 : stackData.extensionIdentifier)) {
        mainThreadErrors.$onUnexpectedError(errorData);
        return;
      }
      mainThreadExtensions.$onExtensionRuntimeError(stackData.extensionIdentifier, errorData);
      const reported = extensionTelemetry.onExtensionError(stackData.extensionIdentifier, err);
      logService.trace("forwarded error to extension?", reported, stackData);
    });
  }
};
var ExtensionHostMain = class _ExtensionHostMain {
  constructor(protocol, initData, hostUtils, uriTransformer, messagePorts) {
    this._hostUtils = hostUtils;
    this._rpcProtocol = new RPCProtocol(protocol, null, uriTransformer);
    initData = _ExtensionHostMain._transform(initData, this._rpcProtocol);
    const services = new ServiceCollection(...getSingletonServiceDescriptors());
    services.set(IExtHostInitDataService, { _serviceBrand: void 0, ...initData, messagePorts });
    services.set(IExtHostRpcService, new ExtHostRpcService(this._rpcProtocol));
    services.set(IURITransformerService, new URITransformerService(uriTransformer));
    services.set(IHostUtils, hostUtils);
    services.set(ILogService, new SyncDescriptor(ExtHostLogService, [true], true));
    services.set(ILoggerService, new SyncDescriptor(ExtHostLoggerService, [], true));
    const instaService = new InstantiationService(services, true);
    if (isWebWorker) {
      instaService.invokeFunction(ErrorHandler.installEarlyHandler);
    }
    this._logService = instaService.invokeFunction((accessor) => accessor.get(ILogService));
    mark(`code/extHost/didCreateServices`);
    if (this._hostUtils.pid) {
      this._logService.info(`Extension host with pid ${this._hostUtils.pid} started`);
    } else {
      this._logService.info(`Extension host started`);
    }
    this._logService.trace("initData", initData);
    this._extensionService = instaService.invokeFunction((accessor) => accessor.get(IExtHostExtensionService));
    this._extensionService.initialize();
    if (isWebWorker) {
      instaService.invokeFunction(ErrorHandler.installFullHandler);
    }
  }
  async asBrowserUri(uri) {
    const mainThreadExtensionsProxy = this._rpcProtocol.getProxy(MainContext.MainThreadExtensionService);
    return URI.revive(await mainThreadExtensionsProxy.$asBrowserUri(uri));
  }
  async getAllStaticBrowserUris() {
    const mainThreadExtensionsProxy = this._rpcProtocol.getProxy(MainContext.MainThreadExtensionService);
    return (await mainThreadExtensionsProxy.$getAllStaticBrowserUris()).map(([from, to]) => [URI.revive(from), URI.revive(to)]);
  }
  terminate(reason) {
    this._extensionService.terminate(reason);
  }
  getExtHostExtensionService() {
    return this._extensionService;
  }
  static _transform(initData, rpcProtocol) {
    initData.allExtensions.forEach((ext) => {
      ext.extensionLocation = URI.revive(rpcProtocol.transformIncomingURIs(ext.extensionLocation));
    });
    initData.environment.appRoot = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.appRoot));
    const extDevLocs = initData.environment.extensionDevelopmentLocationURI;
    if (extDevLocs) {
      initData.environment.extensionDevelopmentLocationURI = extDevLocs.map((url) => URI.revive(rpcProtocol.transformIncomingURIs(url)));
    }
    initData.environment.extensionTestsLocationURI = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.extensionTestsLocationURI));
    initData.environment.globalStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.globalStorageHome));
    initData.environment.workspaceStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.workspaceStorageHome));
    initData.environment.extensionTelemetryLogResource = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.extensionTelemetryLogResource));
    initData.nlsBaseUrl = URI.revive(rpcProtocol.transformIncomingURIs(initData.nlsBaseUrl));
    initData.logsLocation = URI.revive(rpcProtocol.transformIncomingURIs(initData.logsLocation));
    initData.workspace = rpcProtocol.transformIncomingURIs(initData.workspace);
    return initData;
  }
};

// node_modules/vscode/service-override/extensions.js
init_telemetryUtils();
init_resources();
init_async();
init_extensionHostProtocol();

// node_modules/vscode/service-override/output.js
init_tslib_es6();
init_descriptors();
init_uri();
init_files();
init_log();

// node_modules/vscode/vscode/src/vs/platform/log/common/fileLog.js
init_tslib_es6();
init_async();
init_buffer();
init_resources();
init_files();

// node_modules/vscode/vscode/src/vs/platform/log/common/bufferLog.js
init_log();
var BufferLogger = class extends AbstractMessageLogger {
  constructor(logLevel = DEFAULT_LOG_LEVEL) {
    super();
    this.buffer = [];
    this._logger = void 0;
    this.setLevel(logLevel);
    this._register(this.onDidChangeLogLevel((level) => {
      var _a30;
      (_a30 = this._logger) == null ? void 0 : _a30.setLevel(level);
    }));
  }
  set logger(logger) {
    this._logger = logger;
    for (const { level, message } of this.buffer) {
      log(logger, level, message);
    }
    this.buffer = [];
  }
  log(level, message) {
    if (this._logger) {
      log(this._logger, level, message);
    } else if (this.getLevel() <= level) {
      this.buffer.push({ level, message });
    }
  }
  dispose() {
    var _a30;
    (_a30 = this._logger) == null ? void 0 : _a30.dispose();
  }
  flush() {
    var _a30;
    (_a30 = this._logger) == null ? void 0 : _a30.flush();
  }
};

// node_modules/vscode/vscode/src/vs/platform/log/common/fileLog.js
init_log();
var MAX_FILE_SIZE = 5 * ByteSize.MB;
var FileLogger = class FileLogger2 extends AbstractMessageLogger {
  constructor(resource, level, donotUseFormatters, fileService) {
    super();
    this.resource = resource;
    this.donotUseFormatters = donotUseFormatters;
    this.fileService = fileService;
    this.backupIndex = 1;
    this.buffer = "";
    this.setLevel(level);
    this.flushDelayer = new ThrottledDelayer(100);
    this.initializePromise = this.initialize();
  }
  async flush() {
    if (!this.buffer) {
      return;
    }
    await this.initializePromise;
    let content = await this.loadContent();
    if (content.length > MAX_FILE_SIZE) {
      await this.fileService.writeFile(this.getBackupResource(), VSBuffer.fromString(content));
      content = "";
    }
    if (this.buffer) {
      content += this.buffer;
      this.buffer = "";
      await this.fileService.writeFile(this.resource, VSBuffer.fromString(content));
    }
  }
  async initialize() {
    try {
      await this.fileService.createFile(this.resource);
    } catch (error) {
      if (error.fileOperationResult !== 3) {
        throw error;
      }
    }
  }
  log(level, message) {
    if (this.donotUseFormatters) {
      this.buffer += message;
    } else {
      this.buffer += `${this.getCurrentTimestamp()} [${this.stringifyLogLevel(level)}] ${message}
`;
    }
    this.flushDelayer.trigger(() => this.flush());
  }
  getCurrentTimestamp() {
    const toTwoDigits = (v) => v < 10 ? `0${v}` : v;
    const toThreeDigits = (v) => v < 10 ? `00${v}` : v < 100 ? `0${v}` : v;
    const currentTime = /* @__PURE__ */ new Date();
    return `${currentTime.getFullYear()}-${toTwoDigits(currentTime.getMonth() + 1)}-${toTwoDigits(currentTime.getDate())} ${toTwoDigits(currentTime.getHours())}:${toTwoDigits(currentTime.getMinutes())}:${toTwoDigits(currentTime.getSeconds())}.${toThreeDigits(currentTime.getMilliseconds())}`;
  }
  getBackupResource() {
    this.backupIndex = this.backupIndex > 5 ? 1 : this.backupIndex;
    return joinPath(dirname2(this.resource), `${basename2(this.resource)}_${this.backupIndex++}`);
  }
  async loadContent() {
    try {
      const content = await this.fileService.readFile(this.resource);
      return content.value.toString();
    } catch (e) {
      return "";
    }
  }
  stringifyLogLevel(level) {
    switch (level) {
      case LogLevel.Debug:
        return "debug";
      case LogLevel.Error:
        return "error";
      case LogLevel.Info:
        return "info";
      case LogLevel.Trace:
        return "trace";
      case LogLevel.Warning:
        return "warning";
    }
    return "";
  }
};
FileLogger = __decorate([
  __param(3, IFileService)
], FileLogger);
var FileLoggerService = class extends AbstractLoggerService {
  constructor(logLevel, logsHome, fileService) {
    super(logLevel, logsHome);
    this.fileService = fileService;
  }
  doCreateLogger(resource, logLevel, options) {
    const logger = new BufferLogger(logLevel);
    whenProviderRegistered(resource, this.fileService).then(() => logger.logger = new FileLogger(
      resource,
      logger.getLevel(),
      !!(options == null ? void 0 : options.donotUseFormatters),
      this.fileService
    ));
    return logger;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/browser/output.contribution.js
init_tslib_es6();
init_nls();
init_aria();
init_keyCodes();
init_modesRegistry();
init_platform2();
init_actions2();

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/browser/outputView.js
init_tslib_es6();
init_nls();
init_telemetry();
init_instantiation();
init_contextkey();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/textResourceEditor.js
init_tslib_es6();
init_types();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/textCodeEditor.js
init_nls();
init_types();
init_contextkey();
init_resources();
var AbstractTextCodeEditor = class extends AbstractTextEditor {
  constructor() {
    super(...arguments);
    this.editorControl = void 0;
  }
  get scopedContextKeyService() {
    var _a30;
    return (_a30 = this.editorControl) == null ? void 0 : _a30.invokeWithinContext((accessor) => accessor.get(IContextKeyService));
  }
  getTitle() {
    if (this.input) {
      return this.input.getName();
    }
    return localize("textEditor", "Text Editor");
  }
  createEditorControl(parent, initialOptions) {
    this.editorControl = this._register(this.instantiationService.createInstance(CodeEditorWidget, parent, initialOptions, this.getCodeEditorWidgetOptions()));
  }
  getCodeEditorWidgetOptions() {
    return /* @__PURE__ */ Object.create(null);
  }
  updateEditorControlOptions(options) {
    var _a30;
    (_a30 = this.editorControl) == null ? void 0 : _a30.updateOptions(options);
  }
  getMainControl() {
    return this.editorControl;
  }
  getControl() {
    return this.editorControl;
  }
  computeEditorViewState(resource) {
    if (!this.editorControl) {
      return void 0;
    }
    const model = this.editorControl.getModel();
    if (!model) {
      return void 0;
    }
    const modelUri = model.uri;
    if (!modelUri) {
      return void 0;
    }
    if (!isEqual(modelUri, resource)) {
      return void 0;
    }
    return this.editorControl.saveViewState() ?? void 0;
  }
  setOptions(options) {
    super.setOptions(options);
    if (options) {
      applyTextEditorOptions(options, assertIsDefined(this.editorControl), 0);
    }
  }
  focus() {
    var _a30;
    (_a30 = this.editorControl) == null ? void 0 : _a30.focus();
  }
  hasFocus() {
    var _a30;
    return ((_a30 = this.editorControl) == null ? void 0 : _a30.hasTextFocus()) || super.hasFocus();
  }
  setEditorVisible(visible, group) {
    var _a30, _b;
    super.setEditorVisible(visible, group);
    if (visible) {
      (_a30 = this.editorControl) == null ? void 0 : _a30.onVisible();
    } else {
      (_b = this.editorControl) == null ? void 0 : _b.onHide();
    }
  }
  layout(dimension) {
    var _a30;
    (_a30 = this.editorControl) == null ? void 0 : _a30.layout(dimension);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/textResourceEditor.js
init_telemetry();
init_instantiation();
init_themeService();
init_model2();
init_language();
init_modesRegistry();
init_files();
var TextResourceEditor_1;
var AbstractTextResourceEditor = class AbstractTextResourceEditor2 extends AbstractTextCodeEditor {
  constructor(id, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorGroupService, editorService, fileService) {
    super(id, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorService, editorGroupService, fileService);
  }
  async setInput(input, options, context, token) {
    await super.setInput(input, options, context, token);
    const resolvedModel = await input.resolve(options);
    if (token.isCancellationRequested) {
      return void 0;
    }
    if (!(resolvedModel instanceof BaseTextEditorModel)) {
      throw new Error("Unable to open file as text");
    }
    const control = assertIsDefined(this.editorControl);
    const textEditorModel = resolvedModel.textEditorModel;
    control.setModel(textEditorModel);
    if (!isTextEditorViewState(options == null ? void 0 : options.viewState)) {
      const editorViewState = this.loadEditorViewState(input, context);
      if (editorViewState) {
        if (options == null ? void 0 : options.selection) {
          editorViewState.cursorState = [];
        }
        control.restoreViewState(editorViewState);
      }
    }
    if (options) {
      applyTextEditorOptions(options, control, 1);
    }
    control.updateOptions(this.getReadonlyConfiguration(resolvedModel.isReadonly()));
  }
  revealLastLine() {
    const control = this.editorControl;
    if (!control) {
      return;
    }
    const model = control.getModel();
    if (model) {
      const lastLine = model.getLineCount();
      control.revealPosition({ lineNumber: lastLine, column: model.getLineMaxColumn(lastLine) }, 0);
    }
  }
  clearInput() {
    var _a30;
    super.clearInput();
    (_a30 = this.editorControl) == null ? void 0 : _a30.setModel(null);
  }
  tracksEditorViewState(input) {
    return input instanceof UntitledTextEditorInput || input instanceof TextResourceEditorInput;
  }
};
AbstractTextResourceEditor = __decorate([
  __param(1, ITelemetryService),
  __param(2, IInstantiationService),
  __param(3, IStorageService),
  __param(4, ITextResourceConfigurationService),
  __param(5, IThemeService),
  __param(6, IEditorGroupsService),
  __param(7, IEditorService),
  __param(8, IFileService)
], AbstractTextResourceEditor);
var _a8;
var TextResourceEditor = (_a8 = class extends AbstractTextResourceEditor {
  constructor(telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorService, editorGroupService, modelService, languageService, fileService) {
    super(TextResourceEditor_1.ID, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorGroupService, editorService, fileService);
    this.modelService = modelService;
    this.languageService = languageService;
  }
  createEditorControl(parent, configuration) {
    super.createEditorControl(parent, configuration);
    const control = this.editorControl;
    if (control) {
      this._register(control.onDidPaste((e) => this.onDidEditorPaste(e, control)));
    }
  }
  onDidEditorPaste(e, codeEditor) {
    if (this.input instanceof UntitledTextEditorInput && this.input.model.hasLanguageSetExplicitly) {
      return;
    }
    if (e.range.startLineNumber !== 1 || e.range.startColumn !== 1) {
      return;
    }
    if (codeEditor.getOption(89)) {
      return;
    }
    const textModel = codeEditor.getModel();
    if (!textModel) {
      return;
    }
    const pasteIsWholeContents = textModel.getLineCount() === e.range.endLineNumber && textModel.getLineMaxColumn(e.range.endLineNumber) === e.range.endColumn;
    if (!pasteIsWholeContents) {
      return;
    }
    const currentLanguageId = textModel.getLanguageId();
    if (currentLanguageId !== PLAINTEXT_LANGUAGE_ID) {
      return;
    }
    let candidateLanguage = void 0;
    if (e.languageId) {
      candidateLanguage = { id: e.languageId, source: "event" };
    } else {
      const guess = this.languageService.guessLanguageIdByFilepathOrFirstLine(textModel.uri, textModel.getLineContent(1).substr(0, 1e3)) ?? void 0;
      if (guess) {
        candidateLanguage = { id: guess, source: "guess" };
      }
    }
    if (candidateLanguage && candidateLanguage.id !== PLAINTEXT_LANGUAGE_ID) {
      if (this.input instanceof UntitledTextEditorInput && candidateLanguage.source === "event") {
        this.input.model.setLanguageId(candidateLanguage.id);
      } else {
        textModel.setLanguage(this.languageService.createById(candidateLanguage.id));
      }
      const opts = this.modelService.getCreationOptions(textModel.getLanguageId(), textModel.uri, textModel.isForSimpleWidget);
      textModel.detectIndentation(opts.insertSpaces, opts.tabSize);
    }
  }
}, TextResourceEditor_1 = _a8, _a8.ID = "workbench.editors.textResourceEditor", _a8);
TextResourceEditor = TextResourceEditor_1 = __decorate([
  __param(0, ITelemetryService),
  __param(1, IInstantiationService),
  __param(2, IStorageService),
  __param(3, ITextResourceConfigurationService),
  __param(4, IThemeService),
  __param(5, IEditorService),
  __param(6, IEditorGroupsService),
  __param(7, IModelService),
  __param(8, ILanguageService),
  __param(9, IFileService)
], TextResourceEditor);

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/browser/outputView.js
init_themeService();
init_configuration();
init_opener();
init_colorRegistry();
init_dom();
init_async();
init_files();
var OutputViewPane = class OutputViewPane2 extends ViewPane {
  get scrollLock() {
    return !!this.scrollLockContextKey.get();
  }
  set scrollLock(scrollLock) {
    this.scrollLockContextKey.set(scrollLock);
  }
  constructor(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService) {
    super(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
    this.editorPromise = null;
    this.scrollLockContextKey = CONTEXT_OUTPUT_SCROLL_LOCK.bindTo(this.contextKeyService);
    const editorInstantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this.scopedContextKeyService]));
    this.editor = editorInstantiationService.createInstance(OutputEditor);
    this._register(this.editor.onTitleAreaUpdate(() => {
      this.updateTitle(this.editor.getTitle());
      this.updateActions();
    }));
    this._register(this.onDidChangeBodyVisibility(() => this.onDidChangeVisibility(this.isBodyVisible())));
  }
  showChannel(channel, preserveFocus) {
    if (this.channelId !== channel.id) {
      this.setInput(channel);
    }
    if (!preserveFocus) {
      this.focus();
    }
  }
  focus() {
    var _a30;
    super.focus();
    (_a30 = this.editorPromise) == null ? void 0 : _a30.then(() => this.editor.focus());
  }
  renderBody(container) {
    super.renderBody(container);
    this.editor.create(container);
    container.classList.add("output-view");
    const codeEditor = this.editor.getControl();
    codeEditor.setAriaOptions({ role: "document", activeDescendant: void 0 });
    this._register(codeEditor.onDidChangeModelContent(() => {
      if (!this.scrollLock) {
        this.editor.revealLastLine();
      }
    }));
    this._register(codeEditor.onDidChangeCursorPosition((e) => {
      if (e.reason !== 3) {
        return;
      }
      if (!this.configurationService.getValue("output.smartScroll.enabled")) {
        return;
      }
      const model = codeEditor.getModel();
      if (model) {
        const newPositionLine = e.position.lineNumber;
        const lastLine = model.getLineCount();
        this.scrollLock = lastLine !== newPositionLine;
      }
    }));
  }
  layoutBody(height, width) {
    super.layoutBody(height, width);
    this.editor.layout(new Dimension(width, height));
  }
  onDidChangeVisibility(visible) {
    this.editor.setVisible(visible);
    if (!visible) {
      this.clearInput();
    }
  }
  setInput(channel) {
    var _a30;
    this.channelId = channel.id;
    const input = this.createInput(channel);
    if (!this.editor.input || !input.matches(this.editor.input)) {
      (_a30 = this.editorPromise) == null ? void 0 : _a30.cancel();
      this.editorPromise = createCancelablePromise((token) => this.editor.setInput(this.createInput(channel), { preserveFocus: true }, /* @__PURE__ */ Object.create(null), token).then(() => this.editor));
    }
  }
  clearInput() {
    this.channelId = void 0;
    this.editor.clearInput();
    this.editorPromise = null;
  }
  createInput(channel) {
    return this.instantiationService.createInstance(TextResourceEditorInput, channel.uri, localize("output model title", "{0} - Output", channel.label), localize("channel", "Output channel for '{0}'", channel.label), void 0, void 0);
  }
};
OutputViewPane = __decorate([
  __param(1, IKeybindingService),
  __param(2, IContextMenuService),
  __param(3, IConfigurationService),
  __param(4, IContextKeyService),
  __param(5, IViewDescriptorService),
  __param(6, IInstantiationService),
  __param(7, IOpenerService),
  __param(8, IThemeService),
  __param(9, ITelemetryService)
], OutputViewPane);
var OutputEditor = class OutputEditor2 extends AbstractTextResourceEditor {
  constructor(telemetryService, instantiationService, storageService, configurationService, textResourceConfigurationService, themeService, editorGroupService, editorService, fileService, contextKeyService) {
    super(OUTPUT_VIEW_ID, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorGroupService, editorService, fileService);
    this.configurationService = configurationService;
    this.resourceContext = this._register(instantiationService.createInstance(ResourceContextKey));
  }
  getId() {
    return OUTPUT_VIEW_ID;
  }
  getTitle() {
    return localize("output", "Output");
  }
  getConfigurationOverrides() {
    const options = super.getConfigurationOverrides();
    options.wordWrap = "on";
    options.lineNumbers = "off";
    options.glyphMargin = false;
    options.lineDecorationsWidth = 20;
    options.rulers = [];
    options.folding = false;
    options.scrollBeyondLastLine = false;
    options.renderLineHighlight = "none";
    options.minimap = { enabled: false };
    options.renderValidationDecorations = "editable";
    options.padding = void 0;
    options.readOnly = true;
    options.domReadOnly = true;
    options.unicodeHighlight = {
      nonBasicASCII: false,
      invisibleCharacters: false,
      ambiguousCharacters: false
    };
    const outputConfig = this.configurationService.getValue("[Log]");
    if (outputConfig) {
      if (outputConfig["editor.minimap.enabled"]) {
        options.minimap = { enabled: true };
      }
      if ("editor.wordWrap" in outputConfig) {
        options.wordWrap = outputConfig["editor.wordWrap"];
      }
    }
    return options;
  }
  getAriaLabel() {
    return this.input ? this.input.getAriaLabel() : localize("outputViewAriaLabel", "Output panel");
  }
  async setInput(input, options, context, token) {
    const focus = !(options && options.preserveFocus);
    if (this.input && input.matches(this.input)) {
      return;
    }
    if (this.input) {
      this.input.dispose();
    }
    await super.setInput(input, options, context, token);
    this.resourceContext.set(input.resource);
    if (focus) {
      this.focus();
    }
    this.revealLastLine();
  }
  clearInput() {
    if (this.input) {
      this.input.dispose();
    }
    super.clearInput();
    this.resourceContext.reset();
  }
  createEditor(parent) {
    parent.setAttribute("role", "document");
    super.createEditor(parent);
    const scopedContextKeyService = this.scopedContextKeyService;
    if (scopedContextKeyService) {
      CONTEXT_IN_OUTPUT.bindTo(scopedContextKeyService).set(true);
    }
  }
};
OutputEditor = __decorate([
  __param(0, ITelemetryService),
  __param(1, IInstantiationService),
  __param(2, IStorageService),
  __param(3, IConfigurationService),
  __param(4, ITextResourceConfigurationService),
  __param(5, IThemeService),
  __param(6, IEditorGroupsService),
  __param(7, IEditorService),
  __param(8, IFileService),
  __param(9, IContextKeyService)
], OutputEditor);
registerThemingParticipant((theme, collector) => {
  const sidebarBackground = theme.getColor(SIDE_BAR_BACKGROUND);
  if (sidebarBackground && sidebarBackground !== theme.getColor(editorBackground)) {
    collector.addRule(`
			.monaco-workbench .part.sidebar .output-view .monaco-editor,
			.monaco-workbench .part.sidebar .output-view .monaco-editor .margin,
			.monaco-workbench .part.sidebar .output-view .monaco-editor .monaco-editor-background {
				background-color: ${sidebarBackground};
			}
		`);
  }
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/browser/logViewer.js
init_tslib_es6();
init_nls();
init_path();
init_telemetry();
init_instantiation();
init_themeService();
init_uri();
init_resolverService();
init_files();
var LogViewerInput_1;
var LogViewer_1;
var _a9;
var LogViewerInput = (_a9 = class extends TextResourceEditorInput {
  get typeId() {
    return LogViewerInput_1.ID;
  }
  constructor(outputChannelDescriptor, textModelResolverService, textFileService, editorService, fileService, labelService, filesConfigurationService) {
    super(URI.from({ scheme: LOG_SCHEME, path: outputChannelDescriptor.id }), basename(outputChannelDescriptor.file.path), dirname(outputChannelDescriptor.file.path), void 0, void 0, textModelResolverService, textFileService, editorService, fileService, labelService, filesConfigurationService);
  }
}, LogViewerInput_1 = _a9, _a9.ID = "workbench.editorinputs.output", _a9);
LogViewerInput = LogViewerInput_1 = __decorate([
  __param(1, ITextModelService),
  __param(2, ITextFileService),
  __param(3, IEditorService),
  __param(4, IFileService),
  __param(5, ILabelService),
  __param(6, IFilesConfigurationService)
], LogViewerInput);
var _a10;
var LogViewer = (_a10 = class extends AbstractTextResourceEditor {
  constructor(telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorGroupService, editorService, fileService) {
    super(LogViewer_1.LOG_VIEWER_EDITOR_ID, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorGroupService, editorService, fileService);
  }
  getConfigurationOverrides() {
    const options = super.getConfigurationOverrides();
    options.wordWrap = "off";
    options.folding = false;
    options.scrollBeyondLastLine = false;
    options.renderValidationDecorations = "editable";
    return options;
  }
  getAriaLabel() {
    return localize("logViewerAriaLabel", "Log viewer");
  }
}, LogViewer_1 = _a10, _a10.LOG_VIEWER_EDITOR_ID = "workbench.editors.logViewer", _a10);
LogViewer = LogViewer_1 = __decorate([
  __param(0, ITelemetryService),
  __param(1, IInstantiationService),
  __param(2, IStorageService),
  __param(3, ITextResourceConfigurationService),
  __param(4, IThemeService),
  __param(5, IEditorGroupsService),
  __param(6, IEditorService),
  __param(7, IFileService)
], LogViewer);

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/browser/output.contribution.js
init_descriptors();
init_instantiation();
init_resolverService();
init_configurationRegistry();
init_types();
init_contextkey();
init_codicons();
init_lifecycle();
ModesRegistry.registerLanguage({
  id: OUTPUT_MODE_ID,
  extensions: [],
  mimetypes: [OUTPUT_MIME]
});
ModesRegistry.registerLanguage({
  id: LOG_MODE_ID,
  extensions: [],
  mimetypes: [LOG_MIME]
});
var outputViewIcon = registerIcon("output-view-icon", Codicon.output, localize("outputViewIcon", "View icon of the output view."));
var VIEW_CONTAINER = Registry.as(Extensions5.ViewContainersRegistry).registerViewContainer({
  id: OUTPUT_VIEW_ID,
  title: localize("output", "Output"),
  icon: outputViewIcon,
  order: 1,
  ctorDescriptor: new SyncDescriptor(
    ViewPaneContainer,
    [OUTPUT_VIEW_ID, { mergeViewWithContainerWhenSingleView: true }]
  ),
  storageId: OUTPUT_VIEW_ID,
  hideIfEmpty: true
}, 1, { doNotRegisterOpenCommand: true });
Registry.as(Extensions5.ViewsRegistry).registerViews([{
  id: OUTPUT_VIEW_ID,
  name: localize("output", "Output"),
  containerIcon: outputViewIcon,
  canMoveView: true,
  canToggleVisibility: false,
  ctorDescriptor: new SyncDescriptor(OutputViewPane),
  openCommandActionDescriptor: {
    id: "workbench.action.output.toggleOutput",
    mnemonicTitle: localize({ key: "miToggleOutput", comment: ["&& denotes a mnemonic"] }, "&&Output"),
    keybindings: {
      primary: 2048 | 1024 | 51,
      linux: {
        primary: KeyChord(2048 | 41, 2048 | 38)
      }
    },
    order: 1
  }
}], VIEW_CONTAINER);
Registry.as(EditorExtensions.EditorPane).registerEditorPane(EditorPaneDescriptor.create(LogViewer, LogViewer.LOG_VIEWER_EDITOR_ID, localize("logViewer", "Log Viewer")), [
  new SyncDescriptor(LogViewerInput)
]);
var OutputContribution = class OutputContribution2 extends Disposable {
  constructor(instantiationService, textModelService, outputService) {
    super();
    this.outputService = outputService;
    textModelService.registerTextModelContentProvider(LOG_SCHEME, instantiationService.createInstance(LogContentProvider));
    this.registerActions();
  }
  registerActions() {
    this.registerSwitchOutputAction();
    this.registerShowOutputChannelsAction();
    this.registerClearOutputAction();
    this.registerToggleAutoScrollAction();
    this.registerOpenActiveLogOutputFileAction();
    this.registerShowLogsAction();
    this.registerOpenLogFileAction();
  }
  registerSwitchOutputAction() {
    this._register(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: `workbench.output.action.switchBetweenOutputs`,
          title: localize("switchBetweenOutputs.label", "Switch Output")
        });
      }
      async run(accessor, channelId) {
        if (channelId) {
          accessor.get(IOutputService).showChannel(channelId, true);
        }
      }
    }));
    const switchOutputMenu = new MenuId("workbench.output.menu.switchOutput");
    this._register(MenuRegistry.appendMenuItem(MenuId.ViewTitle, {
      submenu: switchOutputMenu,
      title: localize("switchToOutput.label", "Switch Output"),
      group: "navigation",
      when: ContextKeyExpr.equals("view", OUTPUT_VIEW_ID),
      order: 1,
      isSelection: true
    }));
    const registeredChannels = /* @__PURE__ */ new Map();
    this._register(toDisposable(() => dispose(registeredChannels.values())));
    const registerOutputChannels = (channels) => {
      for (const channel of channels) {
        const title = channel.label;
        const group = channel.extensionId ? "0_ext_outputchannels" : "1_core_outputchannels";
        registeredChannels.set(channel.id, registerAction2(class extends Action2 {
          constructor() {
            super({
              id: `workbench.action.output.show.${channel.id}`,
              title,
              toggled: ACTIVE_OUTPUT_CHANNEL_CONTEXT.isEqualTo(channel.id),
              menu: {
                id: switchOutputMenu,
                group
              }
            });
          }
          async run(accessor) {
            return accessor.get(IOutputService).showChannel(channel.id, true);
          }
        }));
      }
    };
    registerOutputChannels(this.outputService.getChannelDescriptors());
    const outputChannelRegistry = Registry.as(Extensions3.OutputChannels);
    this._register(outputChannelRegistry.onDidRegisterChannel((e) => {
      const channel = this.outputService.getChannelDescriptor(e);
      if (channel) {
        registerOutputChannels([channel]);
      }
    }));
    this._register(outputChannelRegistry.onDidRemoveChannel((e) => {
      var _a30;
      (_a30 = registeredChannels.get(e)) == null ? void 0 : _a30.dispose();
      registeredChannels.delete(e);
    }));
  }
  registerShowOutputChannelsAction() {
    this._register(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: "workbench.action.showOutputChannels",
          title: { value: localize("showOutputChannels", "Show Output Channels..."), original: "Show Output Channels..." },
          category: { value: localize("output", "Output"), original: "Output" },
          f1: true
        });
      }
      async run(accessor) {
        const outputService = accessor.get(IOutputService);
        const quickInputService = accessor.get(IQuickInputService);
        const extensionChannels = [], coreChannels = [];
        for (const channel of outputService.getChannelDescriptors()) {
          if (channel.extensionId) {
            extensionChannels.push(channel);
          } else {
            coreChannels.push(channel);
          }
        }
        const entries = [];
        for (const { id, label } of extensionChannels) {
          entries.push({ id, label });
        }
        if (extensionChannels.length && coreChannels.length) {
          entries.push({ type: "separator" });
        }
        for (const { id, label } of coreChannels) {
          entries.push({ id, label });
        }
        const entry = await quickInputService.pick(entries, { placeHolder: localize("selectOutput", "Select Output Channel") });
        if (entry) {
          return outputService.showChannel(entry.id);
        }
      }
    }));
  }
  registerClearOutputAction() {
    this._register(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: `workbench.output.action.clearOutput`,
          title: { value: localize("clearOutput.label", "Clear Output"), original: "Clear Output" },
          category: Categories.View,
          menu: [{
            id: MenuId.ViewTitle,
            when: ContextKeyExpr.equals("view", OUTPUT_VIEW_ID),
            group: "navigation",
            order: 2
          }, {
            id: MenuId.CommandPalette
          }, {
            id: MenuId.EditorContext,
            when: CONTEXT_IN_OUTPUT
          }],
          icon: Codicon.clearAll
        });
      }
      async run(accessor) {
        const outputService = accessor.get(IOutputService);
        const activeChannel = outputService.getActiveChannel();
        if (activeChannel) {
          activeChannel.clear();
          status(localize("outputCleared", "Output was cleared"));
        }
      }
    }));
  }
  registerToggleAutoScrollAction() {
    this._register(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: `workbench.output.action.toggleAutoScroll`,
          title: { value: localize("toggleAutoScroll", "Toggle Auto Scrolling"), original: "Toggle Auto Scrolling" },
          tooltip: localize("outputScrollOff", "Turn Auto Scrolling Off"),
          menu: {
            id: MenuId.ViewTitle,
            when: ContextKeyExpr.and(ContextKeyExpr.equals("view", OUTPUT_VIEW_ID)),
            group: "navigation",
            order: 3
          },
          icon: Codicon.lock,
          toggled: {
            condition: CONTEXT_OUTPUT_SCROLL_LOCK,
            icon: Codicon.unlock,
            tooltip: localize("outputScrollOn", "Turn Auto Scrolling On")
          }
        });
      }
      async run(accessor) {
        const outputView = accessor.get(IViewsService).getActiveViewWithId(OUTPUT_VIEW_ID);
        outputView.scrollLock = !outputView.scrollLock;
      }
    }));
  }
  registerOpenActiveLogOutputFileAction() {
    this._register(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: `workbench.action.openActiveLogOutputFile`,
          title: { value: localize("openActiveLogOutputFile", "Open Log Output File"), original: "Open Log Output File" },
          menu: [{
            id: MenuId.ViewTitle,
            when: ContextKeyExpr.equals("view", OUTPUT_VIEW_ID),
            group: "navigation",
            order: 4
          }],
          icon: Codicon.goToFile,
          precondition: CONTEXT_ACTIVE_LOG_OUTPUT
        });
      }
      async run(accessor) {
        const outputService = accessor.get(IOutputService);
        const editorService = accessor.get(IEditorService);
        const instantiationService = accessor.get(IInstantiationService);
        const logFileOutputChannelDescriptor = this.getLogFileOutputChannelDescriptor(outputService);
        if (logFileOutputChannelDescriptor) {
          await editorService.openEditor(instantiationService.createInstance(LogViewerInput, logFileOutputChannelDescriptor), { pinned: true });
        }
      }
      getLogFileOutputChannelDescriptor(outputService) {
        const channel = outputService.getActiveChannel();
        if (channel) {
          const descriptor = outputService.getChannelDescriptors().filter((c) => c.id === channel.id)[0];
          if (descriptor && descriptor.file && descriptor.log) {
            return descriptor;
          }
        }
        return null;
      }
    }));
  }
  registerShowLogsAction() {
    this._register(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: "workbench.action.showLogs",
          title: { value: localize("showLogs", "Show Logs..."), original: "Show Logs..." },
          category: Categories.Developer,
          menu: {
            id: MenuId.CommandPalette
          }
        });
      }
      async run(accessor) {
        const outputService = accessor.get(IOutputService);
        const quickInputService = accessor.get(IQuickInputService);
        const extensionLogs = [], logs = [];
        for (const channel of outputService.getChannelDescriptors()) {
          if (channel.log) {
            if (channel.extensionId) {
              extensionLogs.push(channel);
            } else {
              logs.push(channel);
            }
          }
        }
        const entries = [];
        for (const { id, label } of logs) {
          entries.push({ id, label });
        }
        if (extensionLogs.length && logs.length) {
          entries.push({ type: "separator", label: localize("extensionLogs", "Extension Logs") });
        }
        for (const { id, label } of extensionLogs) {
          entries.push({ id, label });
        }
        const entry = await quickInputService.pick(entries, { placeHolder: localize("selectlog", "Select Log") });
        if (entry) {
          return outputService.showChannel(entry.id);
        }
      }
    }));
  }
  registerOpenLogFileAction() {
    this._register(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: "workbench.action.openLogFile",
          title: { value: localize("openLogFile", "Open Log File..."), original: "Open Log File..." },
          category: Categories.Developer,
          menu: {
            id: MenuId.CommandPalette
          },
          description: {
            description: "workbench.action.openLogFile",
            args: [{
              name: "logFile",
              schema: {
                markdownDescription: localize(
                  "logFile",
                  'The id of the log file to open, for example `"window"`. Currently the best way to get this is to get the ID by checking the `workbench.action.output.show.<id>` commands'
                ),
                type: "string"
              }
            }]
          }
        });
      }
      async run(accessor, args) {
        const outputService = accessor.get(IOutputService);
        const quickInputService = accessor.get(IQuickInputService);
        const instantiationService = accessor.get(IInstantiationService);
        const editorService = accessor.get(IEditorService);
        const entries = outputService.getChannelDescriptors().filter((c) => c.file && c.log).map((channel) => ({ id: channel.id, label: channel.label, channel }));
        const argName = args && typeof args === "string" ? args : void 0;
        let entry;
        if (argName) {
          entry = entries.find((e) => e.id === argName);
        }
        if (!entry) {
          entry = await quickInputService.pick(entries, { placeHolder: localize("selectlogFile", "Select Log File") });
        }
        if (entry) {
          assertIsDefined(entry.channel.file);
          await editorService.openEditor(instantiationService.createInstance(LogViewerInput, entry.channel), { pinned: true });
        }
      }
    }));
  }
};
OutputContribution = __decorate([
  __param(0, IInstantiationService),
  __param(1, ITextModelService),
  __param(2, IOutputService)
], OutputContribution);
Registry.as(Extensions.Workbench).registerWorkbenchContribution(OutputContribution, 3);
Registry.as(Extensions2.Configuration).registerConfiguration({
  id: "output",
  order: 30,
  title: localize("output", "Output"),
  type: "object",
  properties: {
    "output.smartScroll.enabled": {
      type: "boolean",
      description: localize(
        "output.smartScroll.enabled",
        "Enable/disable the ability of smart scrolling in the output view. Smart scrolling allows you to lock scrolling automatically when you click in the output view and unlocks when you click in the last line."
      ),
      default: true,
      scope: 3,
      tags: ["output"]
    }
  }
});

// node_modules/vscode/service-override/output.js
var _FileLoggerService = class _FileLoggerService2 extends FileLoggerService {
  constructor(logLevel, fileService) {
    super(logLevel, URI.from({ scheme: "logs", path: "/" }), fileService);
  }
};
_FileLoggerService = __decorate([
  __param(1, IFileService)
], _FileLoggerService);
function getServiceOverride(logLevel = LogLevel.Info) {
  return {
    [ILoggerService.toString()]: new SyncDescriptor(_FileLoggerService, [logLevel], true)
  };
}

// node_modules/vscode/service-override/tools/url.js
function changeUrlDomain(url, domain) {
  if (domain == null) {
    return url;
  }
  const _url = new URL(url, domain);
  _url.host = new URL(domain).hostname;
  return _url.toString();
}

// node_modules/vscode/vscode/src/vs/workbench/services/themes/common/iconExtensionPoint.js
init_platform2();
var iconRegistry = Registry.as(Extensions4.IconContribution);
iconRegistry.getIconReferenceSchema();

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadLocalization.js
init_tslib_es6();
init_extHost_protocol();
init_uri();
init_files();
init_lifecycle();
var MainThreadLocalization = class MainThreadLocalization2 extends Disposable {
  constructor(extHostContext, fileService, languagePackService) {
    super();
    this.fileService = fileService;
    this.languagePackService = languagePackService;
  }
  async $fetchBuiltInBundleUri(id, language2) {
    try {
      const uri = await this.languagePackService.getBuiltInExtensionTranslationsUri(id, language2);
      return uri;
    } catch (e) {
      return void 0;
    }
  }
  async $fetchBundleContents(uriComponents) {
    const contents = await this.fileService.readFile(URI.revive(uriComponents));
    return contents.value.toString();
  }
};
MainThreadLocalization = __decorate([
  extHostNamedCustomer(MainContext.MainThreadLocalization),
  __param(1, IFileService),
  __param(2, ILanguagePackService)
], MainThreadLocalization);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadBulkEdits.js
init_tslib_es6();
init_buffer();
init_log();
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/workbench/contrib/bulkEdit/browser/bulkCellEdits.js
init_tslib_es6();
init_arrays();
init_strings();
init_types();
init_uri();

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/browser/notebookBrowser.js
init_notebookCommon();

// node_modules/vscode/override/vs/workbench/contrib/notebook/common/notebookEditorInput.js
var NotebookEditorInput = class {
};
function isCompositeNotebookEditorInput() {
  return false;
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/browser/notebookBrowser.js
var IPYNB_VIEW_TYPE = "jupyter-notebook";
var JUPYTER_EXTENSION_ID = "ms-toolsai.jupyter";
var KERNEL_RECOMMENDATIONS = /* @__PURE__ */ new Map();
KERNEL_RECOMMENDATIONS.set(IPYNB_VIEW_TYPE, /* @__PURE__ */ new Map());
var _a11;
(_a11 = KERNEL_RECOMMENDATIONS.get(IPYNB_VIEW_TYPE)) == null ? void 0 : _a11.set("python", {
  extensionIds: [
    "ms-python.python",
    JUPYTER_EXTENSION_ID
  ],
  displayName: "Python + Jupyter"
});
function getNotebookEditorFromEditorPane(editorPane) {
  var _a30;
  if (!editorPane) {
    return;
  }
  if (editorPane.getId() === NOTEBOOK_EDITOR_ID) {
    return editorPane.getControl();
  }
  const input = editorPane.input;
  if (input && isCompositeNotebookEditorInput()) {
    return (_a30 = editorPane.getControl()) == null ? void 0 : _a30.notebookEditor;
  }
  return void 0;
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/bulkEdit/browser/bulkCellEdits.js
init_notebookCommon();
var ResourceNotebookCellEdit = class _ResourceNotebookCellEdit extends ResourceEdit {
  static is(candidate) {
    if (candidate instanceof _ResourceNotebookCellEdit) {
      return true;
    }
    return URI.isUri(candidate.resource) && isObject(candidate.cellEdit);
  }
  static lift(edit) {
    if (edit instanceof _ResourceNotebookCellEdit) {
      return edit;
    }
    return new _ResourceNotebookCellEdit(edit.resource, edit.cellEdit, edit.notebookVersionId, edit.metadata);
  }
  constructor(resource, cellEdit, notebookVersionId = void 0, metadata) {
    super(metadata);
    this.resource = resource;
    this.cellEdit = cellEdit;
    this.notebookVersionId = notebookVersionId;
  }
};
var BulkCellEdits = class BulkCellEdits2 {
  constructor(_undoRedoGroup, undoRedoSource, _progress, _token, _edits, _editorService, _notebookModelService) {
    this._undoRedoGroup = _undoRedoGroup;
    this._progress = _progress;
    this._token = _token;
    this._edits = _edits;
    this._editorService = _editorService;
    this._notebookModelService = _notebookModelService;
    this._edits = this._edits.map((e) => {
      var _a30;
      if (e.resource.scheme === CellUri.scheme) {
        const uri = (_a30 = CellUri.parse(e.resource)) == null ? void 0 : _a30.notebook;
        if (!uri) {
          throw new Error(`Invalid notebook URI: ${e.resource}`);
        }
        return new ResourceNotebookCellEdit(uri, e.cellEdit, e.notebookVersionId, e.metadata);
      } else {
        return e;
      }
    });
  }
  async apply() {
    var _a30;
    const resources = [];
    const editsByNotebook = groupBy(this._edits, (a, b) => compare(a.resource.toString(), b.resource.toString()));
    for (const group of editsByNotebook) {
      if (this._token.isCancellationRequested) {
        break;
      }
      const [first] = group;
      const ref = await this._notebookModelService.resolve(first.resource);
      if (typeof first.notebookVersionId === "number" && ref.object.notebook.versionId !== first.notebookVersionId) {
        ref.dispose();
        throw new Error(`Notebook '${first.resource}' has changed in the meantime`);
      }
      const edits = group.map((entry) => entry.cellEdit);
      const computeUndo = !ref.object.isReadonly();
      const editor = getNotebookEditorFromEditorPane(this._editorService.activeEditorPane);
      const initialSelectionState = ((_a30 = editor == null ? void 0 : editor.textModel) == null ? void 0 : _a30.uri.toString()) === ref.object.notebook.uri.toString() ? {
        kind: SelectionStateType.Index,
        focus: editor.getFocus(),
        selections: editor.getSelections()
      } : void 0;
      ref.object.notebook.applyEdits(edits, true, initialSelectionState, () => void 0, this._undoRedoGroup, computeUndo);
      ref.dispose();
      this._progress.report(void 0);
      resources.push(first.resource);
    }
    return resources;
  }
};
BulkCellEdits = __decorate([
  __param(5, IEditorService),
  __param(6, INotebookEditorModelResolverService)
], BulkCellEdits);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadBulkEdits.js
var MainThreadBulkEdits = class MainThreadBulkEdits2 {
  constructor(_extHostContext, _bulkEditService, _logService, _uriIdentService) {
    this._bulkEditService = _bulkEditService;
    this._logService = _logService;
    this._uriIdentService = _uriIdentService;
  }
  dispose() {
  }
  $tryApplyWorkspaceEdit(dto, undoRedoGroupId, isRefactoring) {
    const edits = reviveWorkspaceEditDto(dto, this._uriIdentService);
    return this._bulkEditService.apply(edits, { undoRedoGroupId, respectAutoSaveConfig: isRefactoring }).then((res) => res.isApplied, (err) => {
      this._logService.warn(`IGNORING workspace edit: ${err}`);
      return false;
    });
  }
};
MainThreadBulkEdits = __decorate([
  extHostNamedCustomer(MainContext.MainThreadBulkEdits),
  __param(1, IBulkEditService),
  __param(2, ILogService),
  __param(3, IUriIdentityService)
], MainThreadBulkEdits);
function reviveWorkspaceEditDto(data, uriIdentityService, resolveDataTransferFile) {
  var _a30;
  if (!data || !data.edits) {
    return data;
  }
  const result = revive(data);
  for (const edit of result.edits) {
    if (ResourceTextEdit.is(edit)) {
      edit.resource = uriIdentityService.asCanonicalUri(edit.resource);
    }
    if (ResourceFileEdit.is(edit)) {
      if (edit.options) {
        const inContents = (_a30 = edit.options) == null ? void 0 : _a30.contents;
        if (inContents) {
          if (inContents.type === "base64") {
            edit.options.contents = Promise.resolve(decodeBase64(inContents.value));
          } else {
            if (resolveDataTransferFile) {
              edit.options.contents = resolveDataTransferFile(inContents.id);
            } else {
              throw new Error("Could not revive data transfer file");
            }
          }
        }
      }
      edit.newResource = edit.newResource && uriIdentityService.asCanonicalUri(edit.newResource);
      edit.oldResource = edit.oldResource && uriIdentityService.asCanonicalUri(edit.oldResource);
    }
    if (ResourceNotebookCellEdit.is(edit)) {
      edit.resource = uriIdentityService.asCanonicalUri(edit.resource);
    }
  }
  return data;
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadChatProvider.js
init_tslib_es6();
init_lifecycle();
init_log();
init_progress();
init_extHost_protocol();
var MainThreadChatProvider = class MainThreadChatProvider2 {
  constructor(extHostContext, _chatProviderService, _logService) {
    this._chatProviderService = _chatProviderService;
    this._logService = _logService;
    this._providerRegistrations = new DisposableMap();
    this._pendingProgress = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostChatProvider);
  }
  dispose() {
    this._providerRegistrations.dispose();
  }
  $registerProvider(handle, identifier, metadata) {
    const registration = this._chatProviderService.registerChatResponseProvider(identifier, {
      metadata,
      provideChatResponse: async (messages, options, progress, token) => {
        const requestId = Math.random() * 1e6 | 0;
        this._pendingProgress.set(requestId, progress);
        try {
          await this._proxy.$provideChatResponse(handle, requestId, messages, options, token);
        } finally {
          this._pendingProgress.delete(requestId);
        }
      }
    });
    this._providerRegistrations.set(handle, registration);
  }
  async $handleProgressChunk(requestId, chunk) {
    var _a30;
    (_a30 = this._pendingProgress.get(requestId)) == null ? void 0 : _a30.report(chunk);
  }
  $unregisterProvider(handle) {
    this._providerRegistrations.deleteAndDispose(handle);
  }
  async $fetchResponse(extension, providerId, requestId, messages, options, token) {
    this._logService.debug("[CHAT] extension request STARTED", extension.value, requestId);
    const task = this._chatProviderService.fetchChatResponse(providerId, messages, options, new Progress((value) => {
      this._proxy.$handleResponseFragment(requestId, value);
    }), token);
    task.catch((err) => {
      this._logService.error("[CHAT] extension request ERRORED", err, extension.value, requestId);
    }).finally(() => {
      this._logService.debug("[CHAT] extension request DONE", extension.value, requestId);
    });
    return task;
  }
};
MainThreadChatProvider = __decorate([
  extHostNamedCustomer(MainContext.MainThreadChatProvider),
  __param(1, IChatProviderService),
  __param(2, ILogService)
], MainThreadChatProvider);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadChatSlashCommands.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
var MainThreadChatSlashCommands = class MainThreadChatSlashCommands2 {
  constructor(extHostContext, _chatSlashCommandService) {
    this._chatSlashCommandService = _chatSlashCommandService;
    this._commands = new DisposableMap();
    this._pendingProgress = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostChatSlashCommands);
  }
  dispose() {
    this._commands.clearAndDisposeAll();
  }
  $registerCommand(handle, name, detail) {
    if (!this._chatSlashCommandService.hasCommand(name)) {
      this._chatSlashCommandService.registerSlashData({
        command: name,
        detail
      });
    }
    const d = this._chatSlashCommandService.registerSlashCallback(name, async (prompt, progress, history, token) => {
      const requestId = Math.random();
      this._pendingProgress.set(requestId, progress);
      try {
        await this._proxy.$executeCommand(handle, requestId, prompt, { history }, token);
      } finally {
        this._pendingProgress.delete(requestId);
      }
    });
    this._commands.set(handle, d);
  }
  async $handleProgressChunk(requestId, chunk) {
    var _a30;
    (_a30 = this._pendingProgress.get(requestId)) == null ? void 0 : _a30.report(chunk);
  }
  $unregisterCommand(handle) {
    this._commands.deleteAndDispose(handle);
  }
};
MainThreadChatSlashCommands = __decorate([
  extHostNamedCustomer(MainContext.MainThreadChatSlashCommands),
  __param(1, IChatSlashCommandService)
], MainThreadChatSlashCommands);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadChatVariables.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
var MainThreadChatSlashCommands3 = class MainThreadChatSlashCommands4 {
  constructor(extHostContext, _chatVariablesService) {
    this._chatVariablesService = _chatVariablesService;
    this._variables = new DisposableMap();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostChatVariables);
  }
  dispose() {
    this._variables.clearAndDisposeAll();
  }
  $registerVariable(handle, data) {
    const registration = this._chatVariablesService.registerVariable(data, (messageText, _arg, _model, token) => {
      return this._proxy.$resolveVariable(handle, messageText, token);
    });
    this._variables.set(handle, registration);
  }
  $unregisterVariable(handle) {
    this._variables.deleteAndDispose(handle);
  }
};
MainThreadChatSlashCommands3 = __decorate([
  extHostNamedCustomer(MainContext.MainThreadChatVariables),
  __param(1, IChatVariablesService)
], MainThreadChatSlashCommands3);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadCodeInsets.js
init_tslib_es6();
init_lifecycle();
init_resources();
init_uri();
init_codeEditorService();

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadWebviews.js
init_tslib_es6();
init_lifecycle();
init_network();
init_platform();
init_strings();
init_uri();
init_nls();
init_opener();
init_extHost_protocol();
init_proxyIdentifier();
var MainThreadWebviews_1;
var _a12;
var MainThreadWebviews = (_a12 = class extends Disposable {
  constructor(context, _openerService, _productService) {
    super();
    this._openerService = _openerService;
    this._productService = _productService;
    this._webviews = /* @__PURE__ */ new Map();
    this._proxy = context.getProxy(ExtHostContext.ExtHostWebviews);
  }
  addWebview(handle, webview, options) {
    if (this._webviews.has(handle)) {
      throw new Error("Webview already registered");
    }
    this._webviews.set(handle, webview);
    this.hookupWebviewEventDelegate(handle, webview, options);
  }
  $setHtml(handle, value) {
    var _a30;
    (_a30 = this.tryGetWebview(handle)) == null ? void 0 : _a30.setHtml(value);
  }
  $setOptions(handle, options) {
    const webview = this.tryGetWebview(handle);
    if (webview) {
      webview.contentOptions = reviveWebviewContentOptions(options);
    }
  }
  async $postMessage(handle, jsonMessage, ...buffers) {
    const webview = this.tryGetWebview(handle);
    if (!webview) {
      return false;
    }
    const { message, arrayBuffers } = deserializeWebviewMessage(jsonMessage, buffers);
    return webview.postMessage(message, arrayBuffers);
  }
  hookupWebviewEventDelegate(handle, webview, options) {
    const disposables = new DisposableStore();
    disposables.add(webview.onDidClickLink((uri) => this.onDidClickLink(handle, uri)));
    disposables.add(webview.onMessage((message) => {
      const serialized = serializeWebviewMessage(message.message, options);
      this._proxy.$onMessage(handle, serialized.message, new SerializableObjectWithBuffers(serialized.buffers));
    }));
    disposables.add(webview.onMissingCsp((extension) => this._proxy.$onMissingCsp(handle, extension.value)));
    disposables.add(webview.onDidDispose(() => {
      disposables.dispose();
      this._webviews.delete(handle);
    }));
  }
  onDidClickLink(handle, link) {
    const webview = this.getWebview(handle);
    if (this.isSupportedLink(webview, URI.parse(link))) {
      this._openerService.open(link, { fromUserGesture: true, allowContributedOpeners: true, allowCommands: Array.isArray(webview.contentOptions.enableCommandUris) || webview.contentOptions.enableCommandUris === true, fromWorkspace: true });
    }
  }
  isSupportedLink(webview, link) {
    if (MainThreadWebviews_1.standardSupportedLinkSchemes.has(link.scheme)) {
      return true;
    }
    if (!isWeb && this._productService.urlProtocol === link.scheme) {
      return true;
    }
    if (link.scheme === Schemas.command) {
      if (Array.isArray(webview.contentOptions.enableCommandUris)) {
        return webview.contentOptions.enableCommandUris.includes(link.path);
      }
      return webview.contentOptions.enableCommandUris === true;
    }
    return false;
  }
  tryGetWebview(handle) {
    return this._webviews.get(handle);
  }
  getWebview(handle) {
    const webview = this.tryGetWebview(handle);
    if (!webview) {
      throw new Error(`Unknown webview handle:${handle}`);
    }
    return webview;
  }
  getWebviewResolvedFailedContent(viewType) {
    return `<!DOCTYPE html>
		<html>
			<head>
				<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
				<meta http-equiv="Content-Security-Policy" content="default-src 'none';">
			</head>
			<body>${localize(
      "errorMessage",
      "An error occurred while loading view: {0}",
      escape(viewType)
    )}</body>
		</html>`;
  }
}, MainThreadWebviews_1 = _a12, _a12.standardSupportedLinkSchemes = /* @__PURE__ */ new Set([
  Schemas.http,
  Schemas.https,
  Schemas.mailto,
  Schemas.vscode,
  "vscode-insider"
]), _a12);
MainThreadWebviews = MainThreadWebviews_1 = __decorate([
  __param(1, IOpenerService),
  __param(2, IProductService)
], MainThreadWebviews);
function reviveWebviewExtension(extensionData) {
  return {
    id: extensionData.id,
    location: URI.revive(extensionData.location)
  };
}
function reviveWebviewContentOptions(webviewOptions) {
  return {
    allowScripts: webviewOptions.enableScripts,
    allowForms: webviewOptions.enableForms,
    enableCommandUris: webviewOptions.enableCommandUris,
    localResourceRoots: Array.isArray(webviewOptions.localResourceRoots) ? webviewOptions.localResourceRoots.map((r) => URI.revive(r)) : void 0,
    portMapping: webviewOptions.portMapping
  };
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadCodeInsets.js
init_extHost_protocol();
var EditorWebviewZone = class {
  constructor(editor, line, height, webview) {
    this.editor = editor;
    this.line = line;
    this.height = height;
    this.webview = webview;
    this.domNode = document.createElement("div");
    this.domNode.style.zIndex = "10";
    this.afterLineNumber = line;
    this.afterColumn = 1;
    this.heightInLines = height;
    editor.changeViewZones((accessor) => this._id = accessor.addZone(this));
    webview.mountTo(this.domNode);
  }
  dispose() {
    this.editor.changeViewZones((accessor) => this._id && accessor.removeZone(this._id));
  }
};
var MainThreadEditorInsets = class MainThreadEditorInsets2 {
  constructor(context, _editorService, _webviewService) {
    this._editorService = _editorService;
    this._webviewService = _webviewService;
    this._disposables = new DisposableStore();
    this._insets = /* @__PURE__ */ new Map();
    this._proxy = context.getProxy(ExtHostContext.ExtHostEditorInsets);
  }
  dispose() {
    this._disposables.dispose();
  }
  async $createEditorInset(handle, id, uri, line, height, options, extensionId, extensionLocation) {
    let editor;
    id = id.substr(0, id.indexOf(","));
    for (const candidate of this._editorService.listCodeEditors()) {
      if (candidate.getId() === id && candidate.hasModel() && isEqual(candidate.getModel().uri, URI.revive(uri))) {
        editor = candidate;
        break;
      }
    }
    if (!editor) {
      setTimeout(() => this._proxy.$onDidDispose(handle));
      return;
    }
    const disposables = new DisposableStore();
    const webview = this._webviewService.createWebviewElement({
      title: void 0,
      options: {
        enableFindWidget: false
      },
      contentOptions: reviveWebviewContentOptions(options),
      extension: { id: extensionId, location: URI.revive(extensionLocation) }
    });
    const webviewZone = new EditorWebviewZone(editor, line, height, webview);
    const remove = () => {
      disposables.dispose();
      this._proxy.$onDidDispose(handle);
      this._insets.delete(handle);
    };
    disposables.add(editor.onDidChangeModel(remove));
    disposables.add(editor.onDidDispose(remove));
    disposables.add(webviewZone);
    disposables.add(webview);
    disposables.add(webview.onMessage((msg) => this._proxy.$onDidReceiveMessage(handle, msg.message)));
    this._insets.set(handle, webviewZone);
  }
  $disposeEditorInset(handle) {
    const inset = this.getInset(handle);
    this._insets.delete(handle);
    inset.dispose();
  }
  $setHtml(handle, value) {
    const inset = this.getInset(handle);
    inset.webview.setHtml(value);
  }
  $setOptions(handle, options) {
    const inset = this.getInset(handle);
    inset.webview.contentOptions = reviveWebviewContentOptions(options);
  }
  async $postMessage(handle, value) {
    const inset = this.getInset(handle);
    inset.webview.postMessage(value);
    return true;
  }
  getInset(handle) {
    const inset = this._insets.get(handle);
    if (!inset) {
      throw new Error("Unknown inset");
    }
    return inset;
  }
};
MainThreadEditorInsets = __decorate([
  extHostNamedCustomer(MainContext.MainThreadEditorInsets),
  __param(1, ICodeEditorService),
  __param(2, IWebviewService)
], MainThreadEditorInsets);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadClipboard.js
init_tslib_es6();
init_extHost_protocol();
var MainThreadClipboard = class MainThreadClipboard2 {
  constructor(_context, _clipboardService) {
    this._clipboardService = _clipboardService;
  }
  dispose() {
  }
  $readText() {
    return this._clipboardService.readText();
  }
  $writeText(value) {
    return this._clipboardService.writeText(value);
  }
};
MainThreadClipboard = __decorate([
  extHostNamedCustomer(MainContext.MainThreadClipboard),
  __param(1, IClipboardService)
], MainThreadClipboard);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadCommands.js
init_tslib_es6();
init_lifecycle();
init_commands();
init_proxyIdentifier();
init_extHost_protocol();
var MainThreadCommands = class MainThreadCommands2 {
  constructor(extHostContext, _commandService, _extensionService2) {
    this._commandService = _commandService;
    this._extensionService = _extensionService2;
    this._commandRegistrations = new DisposableMap();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostCommands);
    this._generateCommandsDocumentationRegistration = CommandsRegistry.registerCommand("_generateCommandsDocumentation", () => this._generateCommandsDocumentation());
  }
  dispose() {
    this._commandRegistrations.dispose();
    this._generateCommandsDocumentationRegistration.dispose();
  }
  async _generateCommandsDocumentation() {
    const result = await this._proxy.$getContributedCommandHandlerDescriptions();
    const commands = CommandsRegistry.getCommands();
    for (const [id, command] of commands) {
      if (command.description) {
        result[id] = command.description;
      }
    }
    const all = [];
    for (const id in result) {
      all.push("`" + id + "` - " + _generateMarkdown(result[id]));
    }
    console.log(all.join("\n"));
  }
  $registerCommand(id) {
    this._commandRegistrations.set(id, CommandsRegistry.registerCommand(id, (accessor, ...args) => {
      return this._proxy.$executeContributedCommand(id, ...args).then((result) => {
        return revive(result);
      });
    }));
  }
  $unregisterCommand(id) {
    this._commandRegistrations.deleteAndDispose(id);
  }
  $fireCommandActivationEvent(id) {
    const activationEvent = `onCommand:${id}`;
    if (!this._extensionService.activationEventIsDone(activationEvent)) {
      this._extensionService.activateByEvent(activationEvent);
    }
  }
  async $executeCommand(id, args, retry) {
    if (args instanceof SerializableObjectWithBuffers) {
      args = args.value;
    }
    for (let i = 0; i < args.length; i++) {
      args[i] = revive(args[i]);
    }
    if (retry && args.length > 0 && !CommandsRegistry.getCommand(id)) {
      await this._extensionService.activateByEvent(`onCommand:${id}`);
      throw new Error("$executeCommand:retry");
    }
    return this._commandService.executeCommand(id, ...args);
  }
  $getCommands() {
    return Promise.resolve([...CommandsRegistry.getCommands().keys()]);
  }
};
MainThreadCommands = __decorate([
  extHostNamedCustomer(MainContext.MainThreadCommands),
  __param(1, ICommandService),
  __param(2, IExtensionService)
], MainThreadCommands);
function _generateMarkdown(description) {
  if (typeof description === "string") {
    return description;
  } else {
    const parts = [description.description];
    parts.push("\n\n");
    if (description.args) {
      for (const arg of description.args) {
        parts.push(`* _${arg.name}_ - ${arg.description || ""}
`);
      }
    }
    if (description.returns) {
      parts.push(`* _(returns)_ - ${description.returns}`);
    }
    parts.push("\n\n");
    return parts.join("");
  }
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadConfiguration.js
init_tslib_es6();
init_uri();
init_platform2();
init_configurationRegistry();
init_extHost_protocol();
init_configuration();
init_environment();
var MainThreadConfiguration = class MainThreadConfiguration2 {
  constructor(extHostContext, _workspaceContextService, configurationService, _environmentService) {
    this._workspaceContextService = _workspaceContextService;
    this.configurationService = configurationService;
    this._environmentService = _environmentService;
    const proxy = extHostContext.getProxy(ExtHostContext.ExtHostConfiguration);
    proxy.$initializeConfiguration(this._getConfigurationData());
    this._configurationListener = configurationService.onDidChangeConfiguration((e) => {
      proxy.$acceptConfigurationChanged(this._getConfigurationData(), e.change);
    });
  }
  _getConfigurationData() {
    const configurationData = { ...this.configurationService.getConfigurationData(), configurationScopes: [] };
    if (!this._environmentService.isBuilt || this._environmentService.isExtensionDevelopment) {
      configurationData.configurationScopes = getScopes();
    }
    return configurationData;
  }
  dispose() {
    this._configurationListener.dispose();
  }
  $updateConfigurationOption(target, key, value, overrides, scopeToLanguage) {
    overrides = { resource: (overrides == null ? void 0 : overrides.resource) ? URI.revive(overrides.resource) : void 0, overrideIdentifier: overrides == null ? void 0 : overrides.overrideIdentifier };
    return this.writeConfiguration(target, key, value, overrides, scopeToLanguage);
  }
  $removeConfigurationOption(target, key, overrides, scopeToLanguage) {
    overrides = { resource: (overrides == null ? void 0 : overrides.resource) ? URI.revive(overrides.resource) : void 0, overrideIdentifier: overrides == null ? void 0 : overrides.overrideIdentifier };
    return this.writeConfiguration(target, key, void 0, overrides, scopeToLanguage);
  }
  writeConfiguration(target, key, value, overrides, scopeToLanguage) {
    var _a30, _b, _c, _d, _e;
    target = target !== null && target !== void 0 ? target : this.deriveConfigurationTarget(key, overrides);
    const configurationValue = this.configurationService.inspect(key, overrides);
    switch (target) {
      case 8:
        return this._updateValue(key, value, target, (_a30 = configurationValue == null ? void 0 : configurationValue.memory) == null ? void 0 : _a30.override, overrides, scopeToLanguage);
      case 6:
        return this._updateValue(key, value, target, (_b = configurationValue == null ? void 0 : configurationValue.workspaceFolder) == null ? void 0 : _b.override, overrides, scopeToLanguage);
      case 5:
        return this._updateValue(key, value, target, (_c = configurationValue == null ? void 0 : configurationValue.workspace) == null ? void 0 : _c.override, overrides, scopeToLanguage);
      case 4:
        return this._updateValue(key, value, target, (_d = configurationValue == null ? void 0 : configurationValue.userRemote) == null ? void 0 : _d.override, overrides, scopeToLanguage);
      default:
        return this._updateValue(key, value, target, (_e = configurationValue == null ? void 0 : configurationValue.userLocal) == null ? void 0 : _e.override, overrides, scopeToLanguage);
    }
  }
  _updateValue(key, value, configurationTarget, overriddenValue, overrides, scopeToLanguage) {
    overrides = scopeToLanguage === true ? overrides : scopeToLanguage === false ? { resource: overrides.resource } : overrides.overrideIdentifier && overriddenValue !== void 0 ? overrides : { resource: overrides.resource };
    return this.configurationService.updateValue(key, value, overrides, configurationTarget, { donotNotifyError: true });
  }
  deriveConfigurationTarget(key, overrides) {
    if (overrides.resource && this._workspaceContextService.getWorkbenchState() === 3) {
      const configurationProperties = Registry.as(Extensions2.Configuration).getConfigurationProperties();
      if (configurationProperties[key] && (configurationProperties[key].scope === 4 || configurationProperties[key].scope === 5)) {
        return 6;
      }
    }
    return 5;
  }
};
MainThreadConfiguration = __decorate([
  extHostNamedCustomer(MainContext.MainThreadConfiguration),
  __param(1, IWorkspaceContextService),
  __param(2, IConfigurationService),
  __param(3, IEnvironmentService)
], MainThreadConfiguration);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadConsole.js
init_tslib_es6();
init_extHost_protocol();
init_environment();

// node_modules/vscode/vscode/src/vs/base/common/console.js
function parse3(entry) {
  const args = [];
  let stack;
  try {
    const parsedArguments = JSON.parse(entry.arguments);
    const stackArgument = parsedArguments[parsedArguments.length - 1];
    if (stackArgument && stackArgument.__$stack) {
      parsedArguments.pop();
      stack = stackArgument.__$stack;
    }
    args.push(...parsedArguments);
  } catch (error) {
    args.push("Unable to log remote console arguments", entry.arguments);
  }
  return { args, stack };
}
function findFirstFrame(stack) {
  if (!stack) {
    return stack;
  }
  const newlineIndex = stack.indexOf("\n");
  if (newlineIndex === -1) {
    return stack;
  }
  return stack.substring(0, newlineIndex);
}
function log2(entry, label) {
  const { args, stack } = parse3(entry);
  const isOneStringArg = typeof args[0] === "string" && args.length === 1;
  let topFrame = findFirstFrame(stack);
  if (topFrame) {
    topFrame = `(${topFrame.trim()})`;
  }
  let consoleArgs = [];
  if (typeof args[0] === "string") {
    if (topFrame && isOneStringArg) {
      consoleArgs = [`%c[${label}] %c${args[0]} %c${topFrame}`, color("blue"), color(""), color("grey")];
    } else {
      consoleArgs = [`%c[${label}] %c${args[0]}`, color("blue"), color(""), ...args.slice(1)];
    }
  } else {
    consoleArgs = [`%c[${label}]%`, color("blue"), ...args];
  }
  if (topFrame && !isOneStringArg) {
    consoleArgs.push(topFrame);
  }
  if (typeof console[entry.severity] !== "function") {
    throw new Error("Unknown console method");
  }
  console[entry.severity].apply(console, consoleArgs);
}
function color(color2) {
  return `color: ${color2}`;
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/remoteConsoleUtil.js
function logRemoteEntry(logService, entry, label = null) {
  const args = parse3(entry).args;
  let firstArg = args.shift();
  if (typeof firstArg !== "string") {
    return;
  }
  if (!entry.severity) {
    entry.severity = "info";
  }
  if (label) {
    if (!/^\[/.test(label)) {
      label = `[${label}]`;
    }
    if (!/ $/.test(label)) {
      label = `${label} `;
    }
    firstArg = label + firstArg;
  }
  switch (entry.severity) {
    case "log":
    case "info":
      logService.info(firstArg, ...args);
      break;
    case "warn":
      logService.warn(firstArg, ...args);
      break;
    case "error":
      logService.error(firstArg, ...args);
      break;
  }
}
function logRemoteEntryIfError(logService, entry, label) {
  const args = parse3(entry).args;
  const firstArg = args.shift();
  if (typeof firstArg !== "string" || entry.severity !== "error") {
    return;
  }
  if (!/^\[/.test(label)) {
    label = `[${label}]`;
  }
  if (!/ $/.test(label)) {
    label = `${label} `;
  }
  logService.error(label + firstArg, ...args);
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadConsole.js
init_log();
var MainThreadConsole = class MainThreadConsole2 {
  constructor(_extHostContext, _environmentService, _logService) {
    this._environmentService = _environmentService;
    this._logService = _logService;
    const devOpts = parseExtensionDevOptions(this._environmentService);
    this._isExtensionDevTestFromCli = devOpts.isExtensionDevTestFromCli;
  }
  dispose() {
  }
  $logExtensionHostMessage(entry) {
    if (this._isExtensionDevTestFromCli) {
      logRemoteEntry(this._logService, entry);
    } else {
      logRemoteEntryIfError(this._logService, entry, "Extension Host");
      log2(entry, "Extension Host");
    }
  }
};
MainThreadConsole = __decorate([
  extHostNamedCustomer(MainContext.MainThreadConsole),
  __param(1, IEnvironmentService),
  __param(2, ILogService)
], MainThreadConsole);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadDebugService.js
init_tslib_es6();
init_lifecycle();
init_uri();
init_debug();
init_extHost_protocol();
init_errors();
var MainThreadDebugService = class MainThreadDebugService2 {
  constructor(extHostContext, debugService) {
    this.debugService = debugService;
    this._toDispose = new DisposableStore();
    this._debugAdaptersHandleCounter = 1;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostDebugService);
    this._toDispose.add(debugService.onDidNewSession((session) => {
      this._proxy.$acceptDebugSessionStarted(this.getSessionDto(session));
      this._toDispose.add(session.onDidChangeName((name) => {
        this._proxy.$acceptDebugSessionNameChanged(this.getSessionDto(session), name);
      }));
    }));
    this._toDispose.add(debugService.onWillNewSession((session) => {
      this._toDispose.add(session.onDidCustomEvent((event) => this._proxy.$acceptDebugSessionCustomEvent(this.getSessionDto(session), event)));
    }));
    this._toDispose.add(debugService.onDidEndSession((session) => {
      this._proxy.$acceptDebugSessionTerminated(this.getSessionDto(session));
      this._sessions.delete(session.getId());
    }));
    this._toDispose.add(debugService.getViewModel().onDidFocusSession((session) => {
      this._proxy.$acceptDebugSessionActiveChanged(this.getSessionDto(session));
    }));
    this._toDispose.add(toDisposable(() => {
      for (const [handle, da] of this._debugAdapters) {
        da.fireError(handle, new Error("Extension host shut down"));
      }
    }));
    this._debugAdapters = /* @__PURE__ */ new Map();
    this._debugConfigurationProviders = /* @__PURE__ */ new Map();
    this._debugAdapterDescriptorFactories = /* @__PURE__ */ new Map();
    this._sessions = /* @__PURE__ */ new Set();
    this._toDispose.add(this.debugService.getViewModel().onDidFocusThread(({ thread, explicit, session }) => {
      if (session) {
        const dto = {
          kind: "thread",
          threadId: thread == null ? void 0 : thread.threadId,
          sessionId: session.getId()
        };
        this._proxy.$acceptStackFrameFocus(dto);
      }
    }));
    this._toDispose.add(this.debugService.getViewModel().onDidFocusStackFrame(({ stackFrame, explicit, session }) => {
      if (session) {
        const dto = {
          kind: "stackFrame",
          threadId: stackFrame == null ? void 0 : stackFrame.thread.threadId,
          frameId: stackFrame == null ? void 0 : stackFrame.frameId,
          sessionId: session.getId()
        };
        this._proxy.$acceptStackFrameFocus(dto);
      }
    }));
    this.sendBreakpointsAndListen();
  }
  sendBreakpointsAndListen() {
    this._toDispose.add(this.debugService.getModel().onDidChangeBreakpoints((e) => {
      if (e && !e.sessionOnly) {
        const delta3 = {};
        if (e.added) {
          delta3.added = this.convertToDto(e.added);
        }
        if (e.removed) {
          delta3.removed = e.removed.map((x) => x.getId());
        }
        if (e.changed) {
          delta3.changed = this.convertToDto(e.changed);
        }
        if (delta3.added || delta3.removed || delta3.changed) {
          this._proxy.$acceptBreakpointsDelta(delta3);
        }
      }
    }));
    const bps = this.debugService.getModel().getBreakpoints();
    const fbps = this.debugService.getModel().getFunctionBreakpoints();
    const dbps = this.debugService.getModel().getDataBreakpoints();
    if (bps.length > 0 || fbps.length > 0) {
      this._proxy.$acceptBreakpointsDelta({
        added: this.convertToDto(bps).concat(this.convertToDto(fbps)).concat(this.convertToDto(dbps))
      });
    }
  }
  dispose() {
    this._toDispose.dispose();
  }
  createDebugAdapter(session) {
    const handle = this._debugAdaptersHandleCounter++;
    const da = new ExtensionHostDebugAdapter(this, handle, this._proxy, session);
    this._debugAdapters.set(handle, da);
    return da;
  }
  substituteVariables(folder, config) {
    return Promise.resolve(this._proxy.$substituteVariables(folder ? folder.uri : void 0, config));
  }
  runInTerminal(args, sessionId) {
    return this._proxy.$runInTerminal(args, sessionId);
  }
  $registerDebugTypes(debugTypes) {
    this._toDispose.add(this.debugService.getAdapterManager().registerDebugAdapterFactory(debugTypes, this));
  }
  $registerBreakpoints(DTOs) {
    for (const dto of DTOs) {
      if (dto.type === "sourceMulti") {
        const rawbps = dto.lines.map((l) => ({
          id: l.id,
          enabled: l.enabled,
          lineNumber: l.line + 1,
          column: l.character > 0 ? l.character + 1 : void 0,
          condition: l.condition,
          hitCondition: l.hitCondition,
          logMessage: l.logMessage
        }));
        this.debugService.addBreakpoints(URI.revive(dto.uri), rawbps);
      } else if (dto.type === "function") {
        this.debugService.addFunctionBreakpoint(dto.functionName, dto.id);
      } else if (dto.type === "data") {
        this.debugService.addDataBreakpoint(dto.label, dto.dataId, dto.canPersist, dto.accessTypes, dto.accessType);
      }
    }
    return Promise.resolve();
  }
  $unregisterBreakpoints(breakpointIds, functionBreakpointIds, dataBreakpointIds) {
    breakpointIds.forEach((id) => this.debugService.removeBreakpoints(id));
    functionBreakpointIds.forEach((id) => this.debugService.removeFunctionBreakpoints(id));
    dataBreakpointIds.forEach((id) => this.debugService.removeDataBreakpoints(id));
    return Promise.resolve();
  }
  $registerDebugConfigurationProvider(debugType, providerTriggerKind, hasProvide, hasResolve, hasResolve2, handle) {
    const provider = {
      type: debugType,
      triggerKind: providerTriggerKind
    };
    if (hasProvide) {
      provider.provideDebugConfigurations = (folder, token) => {
        return this._proxy.$provideDebugConfigurations(handle, folder, token);
      };
    }
    if (hasResolve) {
      provider.resolveDebugConfiguration = (folder, config, token) => {
        return this._proxy.$resolveDebugConfiguration(handle, folder, config, token);
      };
    }
    if (hasResolve2) {
      provider.resolveDebugConfigurationWithSubstitutedVariables = (folder, config, token) => {
        return this._proxy.$resolveDebugConfigurationWithSubstitutedVariables(handle, folder, config, token);
      };
    }
    this._debugConfigurationProviders.set(handle, provider);
    this._toDispose.add(this.debugService.getConfigurationManager().registerDebugConfigurationProvider(provider));
    return Promise.resolve(void 0);
  }
  $unregisterDebugConfigurationProvider(handle) {
    const provider = this._debugConfigurationProviders.get(handle);
    if (provider) {
      this._debugConfigurationProviders.delete(handle);
      this.debugService.getConfigurationManager().unregisterDebugConfigurationProvider(provider);
    }
  }
  $registerDebugAdapterDescriptorFactory(debugType, handle) {
    const provider = {
      type: debugType,
      createDebugAdapterDescriptor: (session) => {
        return Promise.resolve(this._proxy.$provideDebugAdapter(handle, this.getSessionDto(session)));
      }
    };
    this._debugAdapterDescriptorFactories.set(handle, provider);
    this._toDispose.add(this.debugService.getAdapterManager().registerDebugAdapterDescriptorFactory(provider));
    return Promise.resolve(void 0);
  }
  $unregisterDebugAdapterDescriptorFactory(handle) {
    const provider = this._debugAdapterDescriptorFactories.get(handle);
    if (provider) {
      this._debugAdapterDescriptorFactories.delete(handle);
      this.debugService.getAdapterManager().unregisterDebugAdapterDescriptorFactory(provider);
    }
  }
  getSession(sessionId) {
    if (sessionId) {
      return this.debugService.getModel().getSession(sessionId, true);
    }
    return void 0;
  }
  async $startDebugging(folder, nameOrConfig, options) {
    const folderUri = folder ? URI.revive(folder) : void 0;
    const launch = this.debugService.getConfigurationManager().getLaunch(folderUri);
    const parentSession = this.getSession(options.parentSessionID);
    const saveBeforeStart = typeof options.suppressSaveBeforeStart === "boolean" ? !options.suppressSaveBeforeStart : void 0;
    const debugOptions = {
      noDebug: options.noDebug,
      parentSession,
      lifecycleManagedByParent: options.lifecycleManagedByParent,
      repl: options.repl,
      compact: options.compact,
      compoundRoot: parentSession == null ? void 0 : parentSession.compoundRoot,
      saveBeforeRestart: saveBeforeStart,
      suppressDebugStatusbar: options.suppressDebugStatusbar,
      suppressDebugToolbar: options.suppressDebugToolbar,
      suppressDebugView: options.suppressDebugView
    };
    try {
      return this.debugService.startDebugging(launch, nameOrConfig, debugOptions, saveBeforeStart);
    } catch (err) {
      throw new ErrorNoTelemetry(err && err.message ? err.message : "cannot start debugging");
    }
  }
  $setDebugSessionName(sessionId, name) {
    const session = this.debugService.getModel().getSession(sessionId);
    session == null ? void 0 : session.setName(name);
  }
  $customDebugAdapterRequest(sessionId, request, args) {
    const session = this.debugService.getModel().getSession(sessionId, true);
    if (session) {
      return session.customRequest(request, args).then((response) => {
        if (response && response.success) {
          return response.body;
        } else {
          return Promise.reject(new ErrorNoTelemetry(response ? response.message : "custom request failed"));
        }
      });
    }
    return Promise.reject(new ErrorNoTelemetry("debug session not found"));
  }
  $getDebugProtocolBreakpoint(sessionId, breakpoinId) {
    const session = this.debugService.getModel().getSession(sessionId, true);
    if (session) {
      return Promise.resolve(session.getDebugProtocolBreakpoint(breakpoinId));
    }
    return Promise.reject(new ErrorNoTelemetry("debug session not found"));
  }
  $stopDebugging(sessionId) {
    if (sessionId) {
      const session = this.debugService.getModel().getSession(sessionId, true);
      if (session) {
        return this.debugService.stopSession(session, isSessionAttach(session));
      }
    } else {
      return this.debugService.stopSession(void 0);
    }
    return Promise.reject(new ErrorNoTelemetry("debug session not found"));
  }
  $appendDebugConsole(value) {
    const session = this.debugService.getViewModel().focusedSession;
    session == null ? void 0 : session.appendToRepl({ output: value, sev: severity_default.Warning });
  }
  $acceptDAMessage(handle, message) {
    this.getDebugAdapter(handle).acceptMessage(convertToVSCPaths(message, false));
  }
  $acceptDAError(handle, name, message, stack) {
    this.getDebugAdapter(handle).fireError(handle, new Error(`${name}: ${message}
${stack}`));
  }
  $acceptDAExit(handle, code, signal) {
    this.getDebugAdapter(handle).fireExit(handle, code, signal);
  }
  getDebugAdapter(handle) {
    const adapter = this._debugAdapters.get(handle);
    if (!adapter) {
      throw new Error("Invalid debug adapter");
    }
    return adapter;
  }
  $sessionCached(sessionID) {
    this._sessions.add(sessionID);
  }
  getSessionDto(session) {
    var _a30;
    if (session) {
      const sessionID = session.getId();
      if (this._sessions.has(sessionID)) {
        return sessionID;
      } else {
        return {
          id: sessionID,
          type: session.configuration.type,
          name: session.name,
          folderUri: session.root ? session.root.uri : void 0,
          configuration: session.configuration,
          parent: (_a30 = session.parentSession) == null ? void 0 : _a30.getId()
        };
      }
    }
    return void 0;
  }
  convertToDto(bps) {
    return bps.map((bp) => {
      if ("name" in bp) {
        const fbp = bp;
        return {
          type: "function",
          id: fbp.getId(),
          enabled: fbp.enabled,
          condition: fbp.condition,
          hitCondition: fbp.hitCondition,
          logMessage: fbp.logMessage,
          functionName: fbp.name
        };
      } else if ("dataId" in bp) {
        const dbp = bp;
        return {
          type: "data",
          id: dbp.getId(),
          dataId: dbp.dataId,
          enabled: dbp.enabled,
          condition: dbp.condition,
          hitCondition: dbp.hitCondition,
          logMessage: dbp.logMessage,
          label: dbp.description,
          canPersist: dbp.canPersist
        };
      } else {
        const sbp = bp;
        return {
          type: "source",
          id: sbp.getId(),
          enabled: sbp.enabled,
          condition: sbp.condition,
          hitCondition: sbp.hitCondition,
          logMessage: sbp.logMessage,
          uri: sbp.uri,
          line: sbp.lineNumber > 0 ? sbp.lineNumber - 1 : 0,
          character: typeof sbp.column === "number" && sbp.column > 0 ? sbp.column - 1 : 0
        };
      }
    });
  }
};
MainThreadDebugService = __decorate([
  extHostNamedCustomer(MainContext.MainThreadDebugService),
  __param(1, IDebugService)
], MainThreadDebugService);
var ExtensionHostDebugAdapter = class extends AbstractDebugAdapter {
  constructor(_ds, _handle4, _proxy10, _session) {
    super();
    this._ds = _ds;
    this._handle = _handle4;
    this._proxy = _proxy10;
    this._session = _session;
  }
  fireError(handle, err) {
    this._onError.fire(err);
  }
  fireExit(handle, code, signal) {
    this._onExit.fire(code);
  }
  startSession() {
    return Promise.resolve(this._proxy.$startDASession(this._handle, this._ds.getSessionDto(this._session)));
  }
  sendMessage(message) {
    this._proxy.$sendDAMessage(this._handle, convertToDAPaths(message, true));
  }
  async stopSession() {
    await this.cancelPendingRequests();
    return Promise.resolve(this._proxy.$stopDASession(this._handle));
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadDecorations.js
init_tslib_es6();
init_uri();
init_event();
init_lifecycle();
init_extHost_protocol();
init_cancellation();
var DecorationRequestsQueue = class {
  constructor(_proxy10, _handle4) {
    this._proxy = _proxy10;
    this._handle = _handle4;
    this._idPool = 0;
    this._requests = /* @__PURE__ */ new Map();
    this._resolver = /* @__PURE__ */ new Map();
  }
  enqueue(uri, token) {
    const id = ++this._idPool;
    const result = new Promise((resolve) => {
      this._requests.set(id, { id, uri });
      this._resolver.set(id, resolve);
      this._processQueue();
    });
    const sub = token.onCancellationRequested(() => {
      this._requests.delete(id);
      this._resolver.delete(id);
    });
    return result.finally(() => sub.dispose());
  }
  _processQueue() {
    if (typeof this._timer === "number") {
      return;
    }
    this._timer = setTimeout(() => {
      const requests = this._requests;
      const resolver = this._resolver;
      this._proxy.$provideDecorations(this._handle, [...requests.values()], CancellationToken.None).then((data) => {
        for (const [id, resolve] of resolver) {
          resolve(data[id]);
        }
      });
      this._requests = /* @__PURE__ */ new Map();
      this._resolver = /* @__PURE__ */ new Map();
      this._timer = void 0;
    }, 0);
  }
};
var MainThreadDecorations = class MainThreadDecorations2 {
  constructor(context, _decorationsService) {
    this._decorationsService = _decorationsService;
    this._provider = /* @__PURE__ */ new Map();
    this._proxy = context.getProxy(ExtHostContext.ExtHostDecorations);
  }
  dispose() {
    this._provider.forEach((value) => dispose(value));
    this._provider.clear();
  }
  $registerDecorationProvider(handle, label) {
    const emitter = new Emitter();
    const queue = new DecorationRequestsQueue(this._proxy, handle);
    const registration = this._decorationsService.registerDecorationsProvider({
      label,
      onDidChange: emitter.event,
      provideDecorations: async (uri, token) => {
        const data = await queue.enqueue(uri, token);
        if (!data) {
          return void 0;
        }
        const [bubble, tooltip, letter, themeColor] = data;
        return {
          weight: 10,
          bubble: bubble ?? false,
          color: themeColor == null ? void 0 : themeColor.id,
          tooltip,
          letter
        };
      }
    });
    this._provider.set(handle, [emitter, registration]);
  }
  $onDidChange(handle, resources) {
    const provider = this._provider.get(handle);
    if (provider) {
      const [emitter] = provider;
      emitter.fire(resources && resources.map((r) => URI.revive(r)));
    }
  }
  $unregisterDecorationProvider(handle) {
    const provider = this._provider.get(handle);
    if (provider) {
      dispose(provider);
      this._provider.delete(handle);
    }
  }
};
MainThreadDecorations = __decorate([
  extHostNamedCustomer(MainContext.MainThreadDecorations),
  __param(1, IDecorationsService)
], MainThreadDecorations);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadDiagnostics.js
init_tslib_es6();
init_uri();
init_extHost_protocol();
var MainThreadDiagnostics = class MainThreadDiagnostics2 {
  constructor(extHostContext, _markerService, _uriIdentService) {
    this._markerService = _markerService;
    this._uriIdentService = _uriIdentService;
    this._activeOwners = /* @__PURE__ */ new Set();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostDiagnostics);
    this._markerListener = this._markerService.onMarkerChanged(this._forwardMarkers, this);
  }
  dispose() {
    this._markerListener.dispose();
    this._activeOwners.forEach((owner) => this._markerService.changeAll(owner, []));
    this._activeOwners.clear();
  }
  _forwardMarkers(resources) {
    const data = [];
    for (const resource of resources) {
      const allMarkerData = this._markerService.read({ resource });
      if (allMarkerData.length === 0) {
        data.push([resource, []]);
      } else {
        const forgeinMarkerData = allMarkerData.filter((marker) => !this._activeOwners.has(marker.owner));
        if (forgeinMarkerData.length > 0) {
          data.push([resource, forgeinMarkerData]);
        }
      }
    }
    if (data.length > 0) {
      this._proxy.$acceptMarkersChange(data);
    }
  }
  $changeMany(owner, entries) {
    for (const entry of entries) {
      const [uri, markers] = entry;
      if (markers) {
        for (const marker of markers) {
          if (marker.relatedInformation) {
            for (const relatedInformation of marker.relatedInformation) {
              relatedInformation.resource = URI.revive(relatedInformation.resource);
            }
          }
          if (marker.code && typeof marker.code !== "string") {
            marker.code.target = URI.revive(marker.code.target);
          }
        }
      }
      this._markerService.changeOne(owner, this._uriIdentService.asCanonicalUri(URI.revive(uri)), markers);
    }
    this._activeOwners.add(owner);
  }
  $clear(owner) {
    this._markerService.changeAll(owner, []);
    this._activeOwners.delete(owner);
  }
};
MainThreadDiagnostics = __decorate([
  extHostNamedCustomer(MainContext.MainThreadDiagnostics),
  __param(1, IMarkerService),
  __param(2, IUriIdentityService)
], MainThreadDiagnostics);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadDialogs.js
init_tslib_es6();
init_uri();
init_extHost_protocol();
init_network();
var MainThreadDialogs_1;
var MainThreadDialogs = MainThreadDialogs_1 = class MainThreadDialogs2 {
  constructor(context, _fileDialogService) {
    this._fileDialogService = _fileDialogService;
  }
  dispose() {
  }
  async $showOpenDialog(options) {
    const convertedOptions = MainThreadDialogs_1._convertOpenOptions(options);
    if (!convertedOptions.defaultUri) {
      convertedOptions.defaultUri = await this._fileDialogService.defaultFilePath();
    }
    return Promise.resolve(this._fileDialogService.showOpenDialog(convertedOptions));
  }
  async $showSaveDialog(options) {
    const convertedOptions = MainThreadDialogs_1._convertSaveOptions(options);
    if (!convertedOptions.defaultUri) {
      convertedOptions.defaultUri = await this._fileDialogService.defaultFilePath();
    }
    return Promise.resolve(this._fileDialogService.showSaveDialog(convertedOptions));
  }
  static _convertOpenOptions(options) {
    const result = {
      openLabel: (options == null ? void 0 : options.openLabel) || void 0,
      canSelectFiles: (options == null ? void 0 : options.canSelectFiles) || !(options == null ? void 0 : options.canSelectFiles) && !(options == null ? void 0 : options.canSelectFolders),
      canSelectFolders: options == null ? void 0 : options.canSelectFolders,
      canSelectMany: options == null ? void 0 : options.canSelectMany,
      defaultUri: (options == null ? void 0 : options.defaultUri) ? URI.revive(options.defaultUri) : void 0,
      title: (options == null ? void 0 : options.title) || void 0,
      availableFileSystems: (options == null ? void 0 : options.allowUIResources) ? [Schemas.vscodeRemote, Schemas.file] : []
    };
    if (options == null ? void 0 : options.filters) {
      result.filters = [];
      for (const [key, value] of Object.entries(options.filters)) {
        result.filters.push({ name: key, extensions: value });
      }
    }
    return result;
  }
  static _convertSaveOptions(options) {
    const result = {
      defaultUri: (options == null ? void 0 : options.defaultUri) ? URI.revive(options.defaultUri) : void 0,
      saveLabel: (options == null ? void 0 : options.saveLabel) || void 0,
      title: (options == null ? void 0 : options.title) || void 0
    };
    if (options == null ? void 0 : options.filters) {
      result.filters = [];
      for (const [key, value] of Object.entries(options.filters)) {
        result.filters.push({ name: key, extensions: value });
      }
    }
    return result;
  }
};
MainThreadDialogs = MainThreadDialogs_1 = __decorate([
  extHostNamedCustomer(MainContext.MainThreadDialogs),
  __param(1, IFileDialogService)
], MainThreadDialogs);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadDocumentContentProviders.js
init_tslib_es6();
init_errors();
init_lifecycle();
init_uri();
init_editOperation();
init_range();
init_editorWorker();
init_model2();
init_language();
init_resolverService();
init_extHost_protocol();
init_cancellation();
var MainThreadDocumentContentProviders = class MainThreadDocumentContentProviders2 {
  constructor(extHostContext, _textModelResolverService, _languageService, _modelService, _editorWorkerService) {
    this._textModelResolverService = _textModelResolverService;
    this._languageService = _languageService;
    this._modelService = _modelService;
    this._editorWorkerService = _editorWorkerService;
    this._resourceContentProvider = new DisposableMap();
    this._pendingUpdate = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostDocumentContentProviders);
  }
  dispose() {
    this._resourceContentProvider.dispose();
    dispose(this._pendingUpdate.values());
  }
  $registerTextContentProvider(handle, scheme) {
    const registration = this._textModelResolverService.registerTextModelContentProvider(scheme, {
      provideTextContent: (uri) => {
        return this._proxy.$provideTextDocumentContent(handle, uri).then((value) => {
          if (typeof value === "string") {
            const firstLineText = value.substr(0, 1 + value.search(/\r?\n/));
            const languageSelection = this._languageService.createByFilepathOrFirstLine(uri, firstLineText);
            return this._modelService.createModel(value, languageSelection, uri);
          }
          return null;
        });
      }
    });
    this._resourceContentProvider.set(handle, registration);
  }
  $unregisterTextContentProvider(handle) {
    this._resourceContentProvider.deleteAndDispose(handle);
  }
  $onVirtualDocumentChange(uri, value) {
    const model = this._modelService.getModel(URI.revive(uri));
    if (!model) {
      return;
    }
    const pending = this._pendingUpdate.get(model.id);
    pending == null ? void 0 : pending.cancel();
    const myToken = new CancellationTokenSource();
    this._pendingUpdate.set(model.id, myToken);
    this._editorWorkerService.computeMoreMinimalEdits(model.uri, [{ text: value, range: model.getFullModelRange() }]).then((edits) => {
      this._pendingUpdate.delete(model.id);
      if (myToken.token.isCancellationRequested) {
        return;
      }
      if (edits && edits.length > 0) {
        model.applyEdits(edits.map((edit) => EditOperation.replace(Range.lift(edit.range), edit.text)));
      }
    }).catch(onUnexpectedError);
  }
};
MainThreadDocumentContentProviders = __decorate([
  extHostNamedCustomer(MainContext.MainThreadDocumentContentProviders),
  __param(1, ITextModelService),
  __param(2, ILanguageService),
  __param(3, IModelService),
  __param(4, IEditorWorkerService)
], MainThreadDocumentContentProviders);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadDocuments.js
init_tslib_es6();
init_errorMessage();
init_lifecycle();
init_network();
init_uri();
init_model();
init_model2();
init_resolverService();
init_files();
init_extHost_protocol();
init_resources();
init_event();
init_map();
init_errors();
var BoundModelReferenceCollection = class {
  constructor(_extUri, _maxAge = 1e3 * 60 * 3, _maxLength = 1024 * 1024 * 80, _maxSize = 50) {
    this._extUri = _extUri;
    this._maxAge = _maxAge;
    this._maxLength = _maxLength;
    this._maxSize = _maxSize;
    this._data = new Array();
    this._length = 0;
  }
  dispose() {
    this._data = dispose(this._data);
  }
  remove(uri) {
    for (const entry of [...this._data]) {
      if (this._extUri.isEqualOrParent(entry.uri, uri)) {
        entry.dispose();
      }
    }
  }
  add(uri, ref, length = 0) {
    const dispose2 = () => {
      const idx = this._data.indexOf(entry);
      if (idx >= 0) {
        this._length -= length;
        ref.dispose();
        clearTimeout(handle);
        this._data.splice(idx, 1);
      }
    };
    const handle = setTimeout(dispose2, this._maxAge);
    const entry = { uri, length, dispose: dispose2 };
    this._data.push(entry);
    this._length += length;
    this._cleanup();
  }
  _cleanup() {
    while (this._length > this._maxLength) {
      this._data[0].dispose();
    }
    const extraSize = Math.ceil(this._maxSize * 1.2);
    if (this._data.length >= extraSize) {
      dispose(this._data.slice(0, extraSize - this._maxSize));
    }
  }
};
var ModelTracker = class extends Disposable {
  constructor(_model, _onIsCaughtUpWithContentChanges, _proxy10, _textFileService) {
    super();
    this._model = _model;
    this._onIsCaughtUpWithContentChanges = _onIsCaughtUpWithContentChanges;
    this._proxy = _proxy10;
    this._textFileService = _textFileService;
    this._knownVersionId = this._model.getVersionId();
    this._store.add(this._model.onDidChangeContent((e) => {
      this._knownVersionId = e.versionId;
      this._proxy.$acceptModelChanged(this._model.uri, e, this._textFileService.isDirty(this._model.uri));
      if (this.isCaughtUpWithContentChanges()) {
        this._onIsCaughtUpWithContentChanges.fire(this._model.uri);
      }
    }));
  }
  isCaughtUpWithContentChanges() {
    return this._model.getVersionId() === this._knownVersionId;
  }
};
var MainThreadDocuments = class MainThreadDocuments2 extends Disposable {
  constructor(extHostContext, _modelService, _textFileService, _fileService, _textModelResolverService, _environmentService, _uriIdentityService, workingCopyFileService, _pathService) {
    super();
    this._modelService = _modelService;
    this._textFileService = _textFileService;
    this._fileService = _fileService;
    this._textModelResolverService = _textModelResolverService;
    this._environmentService = _environmentService;
    this._uriIdentityService = _uriIdentityService;
    this._pathService = _pathService;
    this._onIsCaughtUpWithContentChanges = this._store.add(new Emitter());
    this.onIsCaughtUpWithContentChanges = this._onIsCaughtUpWithContentChanges.event;
    this._modelTrackers = new ResourceMap();
    this._modelReferenceCollection = this._store.add(new BoundModelReferenceCollection(_uriIdentityService.extUri));
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostDocuments);
    this._store.add(_modelService.onModelLanguageChanged(this._onModelModeChanged, this));
    this._store.add(_textFileService.files.onDidSave((e) => {
      if (this._shouldHandleFileEvent(e.model.resource)) {
        this._proxy.$acceptModelSaved(e.model.resource);
      }
    }));
    this._store.add(_textFileService.files.onDidChangeDirty((m) => {
      if (this._shouldHandleFileEvent(m.resource)) {
        this._proxy.$acceptDirtyStateChanged(m.resource, m.isDirty());
      }
    }));
    this._store.add(workingCopyFileService.onDidRunWorkingCopyFileOperation((e) => {
      const isMove = e.operation === 2;
      if (isMove || e.operation === 1) {
        for (const pair of e.files) {
          const removed = isMove ? pair.source : pair.target;
          if (removed) {
            this._modelReferenceCollection.remove(removed);
          }
        }
      }
    }));
  }
  dispose() {
    dispose(this._modelTrackers.values());
    this._modelTrackers.clear();
    super.dispose();
  }
  isCaughtUpWithContentChanges(resource) {
    const tracker = this._modelTrackers.get(resource);
    if (tracker) {
      return tracker.isCaughtUpWithContentChanges();
    }
    return true;
  }
  _shouldHandleFileEvent(resource) {
    const model = this._modelService.getModel(resource);
    return !!model && shouldSynchronizeModel(model);
  }
  handleModelAdded(model) {
    if (!shouldSynchronizeModel(model)) {
      return;
    }
    this._modelTrackers.set(model.uri, new ModelTracker(
      model,
      this._onIsCaughtUpWithContentChanges,
      this._proxy,
      this._textFileService
    ));
  }
  _onModelModeChanged(event) {
    const { model } = event;
    if (!this._modelTrackers.has(model.uri)) {
      return;
    }
    this._proxy.$acceptModelLanguageChanged(model.uri, model.getLanguageId());
  }
  handleModelRemoved(modelUrl) {
    if (!this._modelTrackers.has(modelUrl)) {
      return;
    }
    this._modelTrackers.get(modelUrl).dispose();
    this._modelTrackers.delete(modelUrl);
  }
  async $trySaveDocument(uri) {
    const target = await this._textFileService.save(URI.revive(uri));
    return Boolean(target);
  }
  async $tryOpenDocument(uriData) {
    const inputUri = URI.revive(uriData);
    if (!inputUri.scheme || !(inputUri.fsPath || inputUri.authority)) {
      throw new ErrorNoTelemetry(`Invalid uri. Scheme and authority or path must be set.`);
    }
    const canonicalUri = this._uriIdentityService.asCanonicalUri(inputUri);
    let promise;
    switch (canonicalUri.scheme) {
      case Schemas.untitled:
        promise = this._handleUntitledScheme(canonicalUri);
        break;
      case Schemas.file:
      default:
        promise = this._handleAsResourceInput(canonicalUri);
        break;
    }
    let documentUri;
    try {
      documentUri = await promise;
    } catch (err) {
      throw new ErrorNoTelemetry(`cannot open ${canonicalUri.toString()}. Detail: ${toErrorMessage(err)}`);
    }
    if (!documentUri) {
      throw new ErrorNoTelemetry(`cannot open ${canonicalUri.toString()}`);
    } else if (!extUri.isEqual(documentUri, canonicalUri)) {
      throw new ErrorNoTelemetry(`cannot open ${canonicalUri.toString()}. Detail: Actual document opened as ${documentUri.toString()}`);
    } else if (!this._modelTrackers.has(canonicalUri)) {
      throw new ErrorNoTelemetry(`cannot open ${canonicalUri.toString()}. Detail: Files above 50MB cannot be synchronized with extensions.`);
    } else {
      return canonicalUri;
    }
  }
  $tryCreateDocument(options) {
    return this._doCreateUntitled(void 0, options ? options.language : void 0, options ? options.content : void 0);
  }
  async _handleAsResourceInput(uri) {
    const ref = await this._textModelResolverService.createModelReference(uri);
    this._modelReferenceCollection.add(uri, ref, ref.object.textEditorModel.getValueLength());
    return ref.object.textEditorModel.uri;
  }
  async _handleUntitledScheme(uri) {
    const asLocalUri = toLocalResource(uri, this._environmentService.remoteAuthority, this._pathService.defaultUriScheme);
    const exists = await this._fileService.exists(asLocalUri);
    if (exists) {
      return Promise.reject(new Error("file already exists"));
    }
    return await this._doCreateUntitled(Boolean(uri.path) ? uri : void 0);
  }
  async _doCreateUntitled(associatedResource, languageId, initialValue) {
    const model = await this._textFileService.untitled.resolve({
      associatedResource,
      languageId,
      initialValue
    });
    const resource = model.resource;
    if (!this._modelTrackers.has(resource)) {
      throw new Error(`expected URI ${resource.toString()} to have come to LIFE`);
    }
    this._proxy.$acceptDirtyStateChanged(resource, true);
    return resource;
  }
};
MainThreadDocuments = __decorate([
  __param(1, IModelService),
  __param(2, ITextFileService),
  __param(3, IFileService),
  __param(4, ITextModelService),
  __param(5, IWorkbenchEnvironmentService),
  __param(6, IUriIdentityService),
  __param(7, IWorkingCopyFileService),
  __param(8, IPathService)
], MainThreadDocuments);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadDocumentsAndEditors.js
init_tslib_es6();
init_event();
init_lifecycle();
init_editorBrowser();
init_codeEditorService();
init_model();
init_model2();
init_resolverService();
init_files();

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadEditor.js
init_event();
init_lifecycle();
init_editorOptions();
init_range();
init_selection();
init_extHost_protocol();
init_arrays();
init_editorState();
var MainThreadTextEditorProperties = class _MainThreadTextEditorProperties {
  static readFromEditor(previousProperties, model, codeEditor) {
    const selections = _MainThreadTextEditorProperties._readSelectionsFromCodeEditor(previousProperties, codeEditor);
    const options = _MainThreadTextEditorProperties._readOptionsFromCodeEditor(previousProperties, model, codeEditor);
    const visibleRanges = _MainThreadTextEditorProperties._readVisibleRangesFromCodeEditor(previousProperties, codeEditor);
    return new _MainThreadTextEditorProperties(selections, options, visibleRanges);
  }
  static _readSelectionsFromCodeEditor(previousProperties, codeEditor) {
    let result = null;
    if (codeEditor) {
      result = codeEditor.getSelections();
    }
    if (!result && previousProperties) {
      result = previousProperties.selections;
    }
    if (!result) {
      result = [new Selection2(1, 1, 1, 1)];
    }
    return result;
  }
  static _readOptionsFromCodeEditor(previousProperties, model, codeEditor) {
    if (model.isDisposed()) {
      if (previousProperties) {
        return previousProperties.options;
      } else {
        throw new Error("No valid properties");
      }
    }
    let cursorStyle;
    let lineNumbers;
    if (codeEditor) {
      const options = codeEditor.getOptions();
      const lineNumbersOpts = options.get(66);
      cursorStyle = options.get(27);
      lineNumbers = lineNumbersOpts.renderType;
    } else if (previousProperties) {
      cursorStyle = previousProperties.options.cursorStyle;
      lineNumbers = previousProperties.options.lineNumbers;
    } else {
      cursorStyle = TextEditorCursorStyle.Line;
      lineNumbers = 1;
    }
    const modelOptions = model.getOptions();
    return {
      insertSpaces: modelOptions.insertSpaces,
      tabSize: modelOptions.tabSize,
      indentSize: modelOptions.indentSize,
      cursorStyle,
      lineNumbers
    };
  }
  static _readVisibleRangesFromCodeEditor(previousProperties, codeEditor) {
    if (codeEditor) {
      return codeEditor.getVisibleRanges();
    }
    return [];
  }
  constructor(selections, options, visibleRanges) {
    this.selections = selections;
    this.options = options;
    this.visibleRanges = visibleRanges;
  }
  generateDelta(oldProps, selectionChangeSource) {
    const delta3 = {
      options: null,
      selections: null,
      visibleRanges: null
    };
    if (!oldProps || !_MainThreadTextEditorProperties._selectionsEqual(oldProps.selections, this.selections)) {
      delta3.selections = {
        selections: this.selections,
        source: selectionChangeSource ?? void 0
      };
    }
    if (!oldProps || !_MainThreadTextEditorProperties._optionsEqual(oldProps.options, this.options)) {
      delta3.options = this.options;
    }
    if (!oldProps || !_MainThreadTextEditorProperties._rangesEqual(oldProps.visibleRanges, this.visibleRanges)) {
      delta3.visibleRanges = this.visibleRanges;
    }
    if (delta3.selections || delta3.options || delta3.visibleRanges) {
      return delta3;
    }
    return null;
  }
  static _selectionsEqual(a, b) {
    return equals(a, b, (aValue, bValue) => aValue.equalsSelection(bValue));
  }
  static _rangesEqual(a, b) {
    return equals(a, b, (aValue, bValue) => aValue.equalsRange(bValue));
  }
  static _optionsEqual(a, b) {
    if (a && !b || !a && b) {
      return false;
    }
    if (!a && !b) {
      return true;
    }
    return a.tabSize === b.tabSize && a.indentSize === b.indentSize && a.insertSpaces === b.insertSpaces && a.cursorStyle === b.cursorStyle && a.lineNumbers === b.lineNumbers;
  }
};
var MainThreadTextEditor = class {
  constructor(id, model, codeEditor, focusTracker, mainThreadDocuments, modelService, clipboardService) {
    this._modelListeners = new DisposableStore();
    this._codeEditorListeners = new DisposableStore();
    this._id = id;
    this._model = model;
    this._codeEditor = null;
    this._properties = null;
    this._focusTracker = focusTracker;
    this._mainThreadDocuments = mainThreadDocuments;
    this._modelService = modelService;
    this._clipboardService = clipboardService;
    this._onPropertiesChanged = new Emitter();
    this._modelListeners.add(this._model.onDidChangeOptions((e) => {
      this._updatePropertiesNow(null);
    }));
    this.setCodeEditor(codeEditor);
    this._updatePropertiesNow(null);
  }
  dispose() {
    this._modelListeners.dispose();
    this._codeEditor = null;
    this._codeEditorListeners.dispose();
  }
  _updatePropertiesNow(selectionChangeSource) {
    this._setProperties(MainThreadTextEditorProperties.readFromEditor(this._properties, this._model, this._codeEditor), selectionChangeSource);
  }
  _setProperties(newProperties, selectionChangeSource) {
    const delta3 = newProperties.generateDelta(this._properties, selectionChangeSource);
    this._properties = newProperties;
    if (delta3) {
      this._onPropertiesChanged.fire(delta3);
    }
  }
  getId() {
    return this._id;
  }
  getModel() {
    return this._model;
  }
  getCodeEditor() {
    return this._codeEditor;
  }
  hasCodeEditor(codeEditor) {
    return this._codeEditor === codeEditor;
  }
  setCodeEditor(codeEditor) {
    if (this.hasCodeEditor(codeEditor)) {
      return;
    }
    this._codeEditorListeners.clear();
    this._codeEditor = codeEditor;
    if (this._codeEditor) {
      this._codeEditorListeners.add(this._codeEditor.onDidChangeModel(() => {
        this.setCodeEditor(null);
      }));
      this._codeEditorListeners.add(this._codeEditor.onDidFocusEditorWidget(() => {
        this._focusTracker.onGainedFocus();
      }));
      this._codeEditorListeners.add(this._codeEditor.onDidBlurEditorWidget(() => {
        this._focusTracker.onLostFocus();
      }));
      let nextSelectionChangeSource = null;
      this._codeEditorListeners.add(this._mainThreadDocuments.onIsCaughtUpWithContentChanges((uri) => {
        if (uri.toString() === this._model.uri.toString()) {
          const selectionChangeSource = nextSelectionChangeSource;
          nextSelectionChangeSource = null;
          this._updatePropertiesNow(selectionChangeSource);
        }
      }));
      const isValidCodeEditor = () => {
        return this._codeEditor && this._codeEditor.getModel() === this._model;
      };
      const updateProperties = (selectionChangeSource) => {
        if (this._mainThreadDocuments.isCaughtUpWithContentChanges(this._model.uri)) {
          nextSelectionChangeSource = null;
          this._updatePropertiesNow(selectionChangeSource);
        } else {
          nextSelectionChangeSource = selectionChangeSource;
        }
      };
      this._codeEditorListeners.add(this._codeEditor.onDidChangeCursorSelection((e) => {
        if (!isValidCodeEditor()) {
          return;
        }
        updateProperties(e.source);
      }));
      this._codeEditorListeners.add(this._codeEditor.onDidChangeConfiguration((e) => {
        if (!isValidCodeEditor()) {
          return;
        }
        updateProperties(null);
      }));
      this._codeEditorListeners.add(this._codeEditor.onDidLayoutChange(() => {
        if (!isValidCodeEditor()) {
          return;
        }
        updateProperties(null);
      }));
      this._codeEditorListeners.add(this._codeEditor.onDidScrollChange(() => {
        if (!isValidCodeEditor()) {
          return;
        }
        updateProperties(null);
      }));
      this._updatePropertiesNow(null);
    }
  }
  isVisible() {
    return !!this._codeEditor;
  }
  getProperties() {
    return this._properties;
  }
  get onPropertiesChanged() {
    return this._onPropertiesChanged.event;
  }
  setSelections(selections) {
    if (this._codeEditor) {
      this._codeEditor.setSelections(selections);
      return;
    }
    const newSelections = selections.map(Selection2.liftSelection);
    this._setProperties(new MainThreadTextEditorProperties(newSelections, this._properties.options, this._properties.visibleRanges), null);
  }
  _setIndentConfiguration(newConfiguration) {
    const creationOpts = this._modelService.getCreationOptions(this._model.getLanguageId(), this._model.uri, this._model.isForSimpleWidget);
    if (newConfiguration.tabSize === "auto" || newConfiguration.insertSpaces === "auto") {
      let insertSpaces = creationOpts.insertSpaces;
      let tabSize = creationOpts.tabSize;
      if (newConfiguration.insertSpaces !== "auto" && typeof newConfiguration.insertSpaces !== "undefined") {
        insertSpaces = newConfiguration.insertSpaces;
      }
      if (newConfiguration.tabSize !== "auto" && typeof newConfiguration.tabSize !== "undefined") {
        tabSize = newConfiguration.tabSize;
      }
      this._model.detectIndentation(insertSpaces, tabSize);
      return;
    }
    const newOpts = {};
    if (typeof newConfiguration.insertSpaces !== "undefined") {
      newOpts.insertSpaces = newConfiguration.insertSpaces;
    }
    if (typeof newConfiguration.tabSize !== "undefined") {
      newOpts.tabSize = newConfiguration.tabSize;
    }
    if (typeof newConfiguration.indentSize !== "undefined") {
      newOpts.indentSize = newConfiguration.indentSize;
    }
    this._model.updateOptions(newOpts);
  }
  setConfiguration(newConfiguration) {
    this._setIndentConfiguration(newConfiguration);
    if (!this._codeEditor) {
      return;
    }
    if (newConfiguration.cursorStyle) {
      const newCursorStyle = cursorStyleToString(newConfiguration.cursorStyle);
      this._codeEditor.updateOptions({
        cursorStyle: newCursorStyle
      });
    }
    if (typeof newConfiguration.lineNumbers !== "undefined") {
      let lineNumbers;
      switch (newConfiguration.lineNumbers) {
        case 1:
          lineNumbers = "on";
          break;
        case 2:
          lineNumbers = "relative";
          break;
        default:
          lineNumbers = "off";
      }
      this._codeEditor.updateOptions({
        lineNumbers
      });
    }
  }
  setDecorations(key, ranges) {
    if (!this._codeEditor) {
      return;
    }
    this._codeEditor.setDecorationsByType("exthost-api", key, ranges);
  }
  setDecorationsFast(key, _ranges) {
    if (!this._codeEditor) {
      return;
    }
    const ranges = [];
    for (let i = 0, len = Math.floor(_ranges.length / 4); i < len; i++) {
      ranges[i] = new Range(_ranges[4 * i], _ranges[4 * i + 1], _ranges[4 * i + 2], _ranges[4 * i + 3]);
    }
    this._codeEditor.setDecorationsByTypeFast(key, ranges);
  }
  revealRange(range, revealType) {
    if (!this._codeEditor) {
      return;
    }
    switch (revealType) {
      case TextEditorRevealType.Default:
        this._codeEditor.revealRange(range, 0);
        break;
      case TextEditorRevealType.InCenter:
        this._codeEditor.revealRangeInCenter(range, 0);
        break;
      case TextEditorRevealType.InCenterIfOutsideViewport:
        this._codeEditor.revealRangeInCenterIfOutsideViewport(range, 0);
        break;
      case TextEditorRevealType.AtTop:
        this._codeEditor.revealRangeAtTop(range, 0);
        break;
      default:
        console.warn(`Unknown revealType: ${revealType}`);
        break;
    }
  }
  isFocused() {
    if (this._codeEditor) {
      return this._codeEditor.hasTextFocus();
    }
    return false;
  }
  matches(editor) {
    if (!editor) {
      return false;
    }
    return editor.getControl() === this._codeEditor;
  }
  applyEdits(versionIdCheck, edits, opts) {
    if (this._model.getVersionId() !== versionIdCheck) {
      return false;
    }
    if (!this._codeEditor) {
      return false;
    }
    if (typeof opts.setEndOfLine !== "undefined") {
      this._model.pushEOL(opts.setEndOfLine);
    }
    const transformedEdits = edits.map((edit) => {
      return {
        range: Range.lift(edit.range),
        text: edit.text,
        forceMoveMarkers: edit.forceMoveMarkers
      };
    });
    if (opts.undoStopBefore) {
      this._codeEditor.pushUndoStop();
    }
    this._codeEditor.executeEdits("MainThreadTextEditor", transformedEdits);
    if (opts.undoStopAfter) {
      this._codeEditor.pushUndoStop();
    }
    return true;
  }
  async insertSnippet(modelVersionId, template, ranges, opts) {
    if (!this._codeEditor || !this._codeEditor.hasModel()) {
      return false;
    }
    let clipboardText;
    const needsTemplate = SnippetParser.guessNeedsClipboard(template);
    if (needsTemplate) {
      const state = new EditorState(
        this._codeEditor,
        1 | 4
      );
      clipboardText = await this._clipboardService.readText();
      if (!state.validate(this._codeEditor)) {
        return false;
      }
    }
    if (this._codeEditor.getModel().getVersionId() !== modelVersionId) {
      return false;
    }
    const snippetController = SnippetController2.get(this._codeEditor);
    if (!snippetController) {
      return false;
    }
    const selections = ranges.map((r) => new Selection2(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn));
    this._codeEditor.setSelections(selections);
    this._codeEditor.focus();
    snippetController.insert(template, {
      overwriteBefore: 0,
      overwriteAfter: 0,
      undoStopBefore: opts.undoStopBefore,
      undoStopAfter: opts.undoStopAfter,
      clipboardText
    });
    return true;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadEditors.js
init_tslib_es6();
init_errors();
init_lifecycle();
init_objects();
init_uri();
init_codeEditorService();
init_commands();
init_extHost_protocol();
init_environment();
init_editorBrowser();
init_configuration();
var MainThreadTextEditors_1;
var _a13;
var MainThreadTextEditors = (_a13 = class {
  constructor(_editorLocator, extHostContext, _codeEditorService, _editorService, _editorGroupService, _configurationService) {
    this._editorLocator = _editorLocator;
    this._codeEditorService = _codeEditorService;
    this._editorService = _editorService;
    this._editorGroupService = _editorGroupService;
    this._configurationService = _configurationService;
    this._toDispose = new DisposableStore();
    this._instanceId = String(++MainThreadTextEditors_1.INSTANCE_COUNT);
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostEditors);
    this._textEditorsListenersMap = /* @__PURE__ */ Object.create(null);
    this._editorPositionData = null;
    this._toDispose.add(this._editorService.onDidVisibleEditorsChange(() => this._updateActiveAndVisibleTextEditors()));
    this._toDispose.add(this._editorGroupService.onDidRemoveGroup(() => this._updateActiveAndVisibleTextEditors()));
    this._toDispose.add(this._editorGroupService.onDidMoveGroup(() => this._updateActiveAndVisibleTextEditors()));
    this._registeredDecorationTypes = /* @__PURE__ */ Object.create(null);
  }
  dispose() {
    Object.keys(this._textEditorsListenersMap).forEach((editorId) => {
      dispose(this._textEditorsListenersMap[editorId]);
    });
    this._textEditorsListenersMap = /* @__PURE__ */ Object.create(null);
    this._toDispose.dispose();
    for (const decorationType in this._registeredDecorationTypes) {
      this._codeEditorService.removeDecorationType(decorationType);
    }
    this._registeredDecorationTypes = /* @__PURE__ */ Object.create(null);
  }
  handleTextEditorAdded(textEditor) {
    const id = textEditor.getId();
    const toDispose = [];
    toDispose.push(textEditor.onPropertiesChanged((data) => {
      this._proxy.$acceptEditorPropertiesChanged(id, data);
    }));
    this._textEditorsListenersMap[id] = toDispose;
  }
  handleTextEditorRemoved(id) {
    dispose(this._textEditorsListenersMap[id]);
    delete this._textEditorsListenersMap[id];
  }
  _updateActiveAndVisibleTextEditors() {
    const editorPositionData = this._getTextEditorPositionData();
    if (!equals2(this._editorPositionData, editorPositionData)) {
      this._editorPositionData = editorPositionData;
      this._proxy.$acceptEditorPositionData(this._editorPositionData);
    }
  }
  _getTextEditorPositionData() {
    const result = /* @__PURE__ */ Object.create(null);
    for (const editorPane of this._editorService.visibleEditorPanes) {
      const id = this._editorLocator.findTextEditorIdFor(editorPane);
      if (id) {
        result[id] = editorGroupToColumn(this._editorGroupService, editorPane.group);
      }
    }
    return result;
  }
  async $tryShowTextDocument(resource, options) {
    const uri = URI.revive(resource);
    const editorOptions = {
      preserveFocus: options.preserveFocus,
      pinned: options.pinned,
      selection: options.selection,
      activation: options.preserveFocus ? EditorActivation.RESTORE : void 0,
      override: EditorResolution.EXCLUSIVE_ONLY
    };
    const input = {
      resource: uri,
      options: editorOptions
    };
    const editor = await this._editorService.openEditor(input, columnToEditorGroup(this._editorGroupService, this._configurationService, options.position));
    if (!editor) {
      return void 0;
    }
    const editorControl = editor.getControl();
    const codeEditor = getCodeEditor(editorControl);
    return codeEditor ? this._editorLocator.getIdOfCodeEditor(codeEditor) : void 0;
  }
  async $tryShowEditor(id, position) {
    const mainThreadEditor = this._editorLocator.getEditor(id);
    if (mainThreadEditor) {
      const model = mainThreadEditor.getModel();
      await this._editorService.openEditor({
        resource: model.uri,
        options: { preserveFocus: false }
      }, columnToEditorGroup(this._editorGroupService, this._configurationService, position));
      return;
    }
  }
  async $tryHideEditor(id) {
    const mainThreadEditor = this._editorLocator.getEditor(id);
    if (mainThreadEditor) {
      const editorPanes = this._editorService.visibleEditorPanes;
      for (const editorPane of editorPanes) {
        if (mainThreadEditor.matches(editorPane)) {
          await editorPane.group.closeEditor(editorPane.input);
          return;
        }
      }
    }
  }
  $trySetSelections(id, selections) {
    const editor = this._editorLocator.getEditor(id);
    if (!editor) {
      return Promise.reject(disposed(`TextEditor(${id})`));
    }
    editor.setSelections(selections);
    return Promise.resolve(void 0);
  }
  $trySetDecorations(id, key, ranges) {
    key = `${this._instanceId}-${key}`;
    const editor = this._editorLocator.getEditor(id);
    if (!editor) {
      return Promise.reject(disposed(`TextEditor(${id})`));
    }
    editor.setDecorations(key, ranges);
    return Promise.resolve(void 0);
  }
  $trySetDecorationsFast(id, key, ranges) {
    key = `${this._instanceId}-${key}`;
    const editor = this._editorLocator.getEditor(id);
    if (!editor) {
      return Promise.reject(disposed(`TextEditor(${id})`));
    }
    editor.setDecorationsFast(key, ranges);
    return Promise.resolve(void 0);
  }
  $tryRevealRange(id, range, revealType) {
    const editor = this._editorLocator.getEditor(id);
    if (!editor) {
      return Promise.reject(disposed(`TextEditor(${id})`));
    }
    editor.revealRange(range, revealType);
    return Promise.resolve();
  }
  $trySetOptions(id, options) {
    const editor = this._editorLocator.getEditor(id);
    if (!editor) {
      return Promise.reject(disposed(`TextEditor(${id})`));
    }
    editor.setConfiguration(options);
    return Promise.resolve(void 0);
  }
  $tryApplyEdits(id, modelVersionId, edits, opts) {
    const editor = this._editorLocator.getEditor(id);
    if (!editor) {
      return Promise.reject(disposed(`TextEditor(${id})`));
    }
    return Promise.resolve(editor.applyEdits(modelVersionId, edits, opts));
  }
  $tryInsertSnippet(id, modelVersionId, template, ranges, opts) {
    const editor = this._editorLocator.getEditor(id);
    if (!editor) {
      return Promise.reject(disposed(`TextEditor(${id})`));
    }
    return Promise.resolve(editor.insertSnippet(modelVersionId, template, ranges, opts));
  }
  $registerTextEditorDecorationType(extensionId, key, options) {
    key = `${this._instanceId}-${key}`;
    this._registeredDecorationTypes[key] = true;
    this._codeEditorService.registerDecorationType(`exthost-api-${extensionId}`, key, options);
  }
  $removeTextEditorDecorationType(key) {
    key = `${this._instanceId}-${key}`;
    delete this._registeredDecorationTypes[key];
    this._codeEditorService.removeDecorationType(key);
  }
  $getDiffInformation(id) {
    const editor = this._editorLocator.getEditor(id);
    if (!editor) {
      return Promise.reject(new Error("No such TextEditor"));
    }
    const codeEditor = editor.getCodeEditor();
    if (!codeEditor) {
      return Promise.reject(new Error("No such CodeEditor"));
    }
    const codeEditorId = codeEditor.getId();
    const diffEditors = this._codeEditorService.listDiffEditors();
    const [diffEditor] = diffEditors.filter((d) => d.getOriginalEditor().getId() === codeEditorId || d.getModifiedEditor().getId() === codeEditorId);
    if (diffEditor) {
      return Promise.resolve(diffEditor.getLineChanges() || []);
    }
    const dirtyDiffContribution = codeEditor.getContribution("editor.contrib.dirtydiff");
    if (dirtyDiffContribution) {
      return Promise.resolve(dirtyDiffContribution.getChanges());
    }
    return Promise.resolve([]);
  }
}, MainThreadTextEditors_1 = _a13, _a13.INSTANCE_COUNT = 0, _a13);
MainThreadTextEditors = MainThreadTextEditors_1 = __decorate([
  __param(2, ICodeEditorService),
  __param(3, IEditorService),
  __param(4, IEditorGroupsService),
  __param(5, IConfigurationService)
], MainThreadTextEditors);
CommandsRegistry.registerCommand("_workbench.revertAllDirty", async function(accessor) {
  const environmentService = accessor.get(IEnvironmentService);
  if (!environmentService.extensionTestsLocationURI) {
    throw new Error("Command is only available when running extension tests.");
  }
  const workingCopyService = accessor.get(IWorkingCopyService);
  for (const workingCopy of workingCopyService.dirtyWorkingCopies) {
    await workingCopy.revert({ soft: true });
  }
});

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadDocumentsAndEditors.js
init_extHost_protocol();
init_configuration();
var TextEditorSnapshot = class {
  constructor(editor) {
    this.editor = editor;
    this.id = `${editor.getId()},${editor.getModel().id}`;
  }
};
var DocumentAndEditorStateDelta = class {
  constructor(removedDocuments, addedDocuments, removedEditors, addedEditors, oldActiveEditor, newActiveEditor) {
    this.removedDocuments = removedDocuments;
    this.addedDocuments = addedDocuments;
    this.removedEditors = removedEditors;
    this.addedEditors = addedEditors;
    this.oldActiveEditor = oldActiveEditor;
    this.newActiveEditor = newActiveEditor;
    this.isEmpty = this.removedDocuments.length === 0 && this.addedDocuments.length === 0 && this.removedEditors.length === 0 && this.addedEditors.length === 0 && oldActiveEditor === newActiveEditor;
  }
  toString() {
    let ret = "DocumentAndEditorStateDelta\n";
    ret += `	Removed Documents: [${this.removedDocuments.map((d) => d.uri.toString(true)).join(", ")}]
`;
    ret += `	Added Documents: [${this.addedDocuments.map((d) => d.uri.toString(true)).join(", ")}]
`;
    ret += `	Removed Editors: [${this.removedEditors.map((e) => e.id).join(", ")}]
`;
    ret += `	Added Editors: [${this.addedEditors.map((e) => e.id).join(", ")}]
`;
    ret += `	New Active Editor: ${this.newActiveEditor}
`;
    return ret;
  }
};
var DocumentAndEditorState = class {
  static compute(before, after) {
    if (!before) {
      return new DocumentAndEditorStateDelta(
        [],
        [...after.documents.values()],
        [],
        [...after.textEditors.values()],
        void 0,
        after.activeEditor
      );
    }
    const documentDelta = diffSets(before.documents, after.documents);
    const editorDelta = diffMaps(before.textEditors, after.textEditors);
    const oldActiveEditor = before.activeEditor !== after.activeEditor ? before.activeEditor : void 0;
    const newActiveEditor = before.activeEditor !== after.activeEditor ? after.activeEditor : void 0;
    return new DocumentAndEditorStateDelta(
      documentDelta.removed,
      documentDelta.added,
      editorDelta.removed,
      editorDelta.added,
      oldActiveEditor,
      newActiveEditor
    );
  }
  constructor(documents, textEditors, activeEditor) {
    this.documents = documents;
    this.textEditors = textEditors;
    this.activeEditor = activeEditor;
  }
};
var MainThreadDocumentAndEditorStateComputer = class MainThreadDocumentAndEditorStateComputer2 {
  constructor(_onDidChangeState, _modelService, _codeEditorService, _editorService, _paneCompositeService) {
    this._onDidChangeState = _onDidChangeState;
    this._modelService = _modelService;
    this._codeEditorService = _codeEditorService;
    this._editorService = _editorService;
    this._paneCompositeService = _paneCompositeService;
    this._toDispose = new DisposableStore();
    this._toDisposeOnEditorRemove = new DisposableMap();
    this._activeEditorOrder = 0;
    this._modelService.onModelAdded(this._updateStateOnModelAdd, this, this._toDispose);
    this._modelService.onModelRemoved((_) => this._updateState(), this, this._toDispose);
    this._editorService.onDidActiveEditorChange((_) => this._updateState(), this, this._toDispose);
    this._codeEditorService.onCodeEditorAdd(this._onDidAddEditor, this, this._toDispose);
    this._codeEditorService.onCodeEditorRemove(this._onDidRemoveEditor, this, this._toDispose);
    this._codeEditorService.listCodeEditors().forEach(this._onDidAddEditor, this);
    Event.filter(this._paneCompositeService.onDidPaneCompositeOpen, (event) => event.viewContainerLocation === 1)((_) => this._activeEditorOrder = 1, void 0, this._toDispose);
    Event.filter(this._paneCompositeService.onDidPaneCompositeClose, (event) => event.viewContainerLocation === 1)((_) => this._activeEditorOrder = 0, void 0, this._toDispose);
    this._editorService.onDidVisibleEditorsChange((_) => this._activeEditorOrder = 0, void 0, this._toDispose);
    this._updateState();
  }
  dispose() {
    this._toDispose.dispose();
    this._toDisposeOnEditorRemove.dispose();
  }
  _onDidAddEditor(e) {
    this._toDisposeOnEditorRemove.set(e.getId(), combinedDisposable(e.onDidChangeModel(() => this._updateState()), e.onDidFocusEditorText(() => this._updateState()), e.onDidFocusEditorWidget(() => this._updateState(e))));
    this._updateState();
  }
  _onDidRemoveEditor(e) {
    const id = e.getId();
    if (this._toDisposeOnEditorRemove.has(id)) {
      this._toDisposeOnEditorRemove.deleteAndDispose(id);
      this._updateState();
    }
  }
  _updateStateOnModelAdd(model) {
    if (!shouldSynchronizeModel(model)) {
      return;
    }
    if (!this._currentState) {
      this._updateState();
      return;
    }
    this._currentState = new DocumentAndEditorState(
      this._currentState.documents.add(model),
      this._currentState.textEditors,
      this._currentState.activeEditor
    );
    this._onDidChangeState(new DocumentAndEditorStateDelta([], [model], [], [], void 0, void 0));
  }
  _updateState(widgetFocusCandidate) {
    const models = /* @__PURE__ */ new Set();
    for (const model of this._modelService.getModels()) {
      if (shouldSynchronizeModel(model)) {
        models.add(model);
      }
    }
    const editors = /* @__PURE__ */ new Map();
    let activeEditor = null;
    for (const editor of this._codeEditorService.listCodeEditors()) {
      if (editor.isSimpleWidget) {
        continue;
      }
      const model = editor.getModel();
      if (editor.hasModel() && model && shouldSynchronizeModel(model) && !model.isDisposed() && Boolean(this._modelService.getModel(model.uri))) {
        const apiEditor = new TextEditorSnapshot(editor);
        editors.set(apiEditor.id, apiEditor);
        if (editor.hasTextFocus() || widgetFocusCandidate === editor && editor.hasWidgetFocus()) {
          activeEditor = apiEditor.id;
        }
      }
    }
    if (!activeEditor) {
      let candidate;
      if (this._activeEditorOrder === 0) {
        candidate = this._getActiveEditorFromEditorPart() || this._getActiveEditorFromPanel();
      } else {
        candidate = this._getActiveEditorFromPanel() || this._getActiveEditorFromEditorPart();
      }
      if (candidate) {
        for (const snapshot of editors.values()) {
          if (candidate === snapshot.editor) {
            activeEditor = snapshot.id;
          }
        }
      }
    }
    const newState = new DocumentAndEditorState(models, editors, activeEditor);
    const delta3 = DocumentAndEditorState.compute(this._currentState, newState);
    if (!delta3.isEmpty) {
      this._currentState = newState;
      this._onDidChangeState(delta3);
    }
  }
  _getActiveEditorFromPanel() {
    const panel = this._paneCompositeService.getActivePaneComposite(1);
    if (panel instanceof FakeAbstractTextEditor) {
      const control = panel.getControl();
      if (isCodeEditor(control)) {
        return control;
      }
    }
    return void 0;
  }
  _getActiveEditorFromEditorPart() {
    let activeTextEditorControl = this._editorService.activeTextEditorControl;
    if (isDiffEditor(activeTextEditorControl)) {
      activeTextEditorControl = activeTextEditorControl.getModifiedEditor();
    }
    return activeTextEditorControl;
  }
};
MainThreadDocumentAndEditorStateComputer = __decorate([
  __param(1, IModelService),
  __param(2, ICodeEditorService),
  __param(3, IEditorService),
  __param(4, IPaneCompositePartService)
], MainThreadDocumentAndEditorStateComputer);
var MainThreadDocumentsAndEditors = class MainThreadDocumentsAndEditors2 {
  constructor(extHostContext, _modelService, _textFileService, _editorService, codeEditorService, fileService, textModelResolverService, _editorGroupService, paneCompositeService, environmentService, workingCopyFileService, uriIdentityService, _clipboardService, pathService, configurationService) {
    this._modelService = _modelService;
    this._textFileService = _textFileService;
    this._editorService = _editorService;
    this._editorGroupService = _editorGroupService;
    this._clipboardService = _clipboardService;
    this._toDispose = new DisposableStore();
    this._textEditors = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostDocumentsAndEditors);
    this._mainThreadDocuments = this._toDispose.add(new MainThreadDocuments(
      extHostContext,
      this._modelService,
      this._textFileService,
      fileService,
      textModelResolverService,
      environmentService,
      uriIdentityService,
      workingCopyFileService,
      pathService
    ));
    extHostContext.set(MainContext.MainThreadDocuments, this._mainThreadDocuments);
    this._mainThreadEditors = this._toDispose.add(new MainThreadTextEditors(
      this,
      extHostContext,
      codeEditorService,
      this._editorService,
      this._editorGroupService,
      configurationService
    ));
    extHostContext.set(MainContext.MainThreadTextEditors, this._mainThreadEditors);
    this._toDispose.add(new MainThreadDocumentAndEditorStateComputer(
      (delta3) => this._onDelta(delta3),
      _modelService,
      codeEditorService,
      this._editorService,
      paneCompositeService
    ));
  }
  dispose() {
    this._toDispose.dispose();
  }
  _onDelta(delta3) {
    const removedEditors = [];
    const addedEditors = [];
    const removedDocuments = delta3.removedDocuments.map((m) => m.uri);
    for (const apiEditor of delta3.addedEditors) {
      const mainThreadEditor = new MainThreadTextEditor(
        apiEditor.id,
        apiEditor.editor.getModel(),
        apiEditor.editor,
        { onGainedFocus() {
        }, onLostFocus() {
        } },
        this._mainThreadDocuments,
        this._modelService,
        this._clipboardService
      );
      this._textEditors.set(apiEditor.id, mainThreadEditor);
      addedEditors.push(mainThreadEditor);
    }
    for (const { id } of delta3.removedEditors) {
      const mainThreadEditor = this._textEditors.get(id);
      if (mainThreadEditor) {
        mainThreadEditor.dispose();
        this._textEditors.delete(id);
        removedEditors.push(id);
      }
    }
    const extHostDelta = /* @__PURE__ */ Object.create(null);
    let empty = true;
    if (delta3.newActiveEditor !== void 0) {
      empty = false;
      extHostDelta.newActiveEditor = delta3.newActiveEditor;
    }
    if (removedDocuments.length > 0) {
      empty = false;
      extHostDelta.removedDocuments = removedDocuments;
    }
    if (removedEditors.length > 0) {
      empty = false;
      extHostDelta.removedEditors = removedEditors;
    }
    if (delta3.addedDocuments.length > 0) {
      empty = false;
      extHostDelta.addedDocuments = delta3.addedDocuments.map((m) => this._toModelAddData(m));
    }
    if (delta3.addedEditors.length > 0) {
      empty = false;
      extHostDelta.addedEditors = addedEditors.map((e) => this._toTextEditorAddData(e));
    }
    if (!empty) {
      this._proxy.$acceptDocumentsAndEditorsDelta(extHostDelta);
      removedDocuments.forEach(this._mainThreadDocuments.handleModelRemoved, this._mainThreadDocuments);
      delta3.addedDocuments.forEach(this._mainThreadDocuments.handleModelAdded, this._mainThreadDocuments);
      removedEditors.forEach(this._mainThreadEditors.handleTextEditorRemoved, this._mainThreadEditors);
      addedEditors.forEach(this._mainThreadEditors.handleTextEditorAdded, this._mainThreadEditors);
    }
  }
  _toModelAddData(model) {
    return {
      uri: model.uri,
      versionId: model.getVersionId(),
      lines: model.getLinesContent(),
      EOL: model.getEOL(),
      languageId: model.getLanguageId(),
      isDirty: this._textFileService.isDirty(model.uri)
    };
  }
  _toTextEditorAddData(textEditor) {
    const props = textEditor.getProperties();
    return {
      id: textEditor.getId(),
      documentUri: textEditor.getModel().uri,
      options: props.options,
      selections: props.selections,
      visibleRanges: props.visibleRanges,
      editorPosition: this._findEditorPosition(textEditor)
    };
  }
  _findEditorPosition(editor) {
    for (const editorPane of this._editorService.visibleEditorPanes) {
      if (editor.matches(editorPane)) {
        return editorGroupToColumn(this._editorGroupService, editorPane.group);
      }
    }
    return void 0;
  }
  findTextEditorIdFor(editorPane) {
    for (const [id, editor] of this._textEditors) {
      if (editor.matches(editorPane)) {
        return id;
      }
    }
    return void 0;
  }
  getIdOfCodeEditor(codeEditor) {
    for (const [id, editor] of this._textEditors) {
      if (editor.getCodeEditor() === codeEditor) {
        return id;
      }
    }
    return void 0;
  }
  getEditor(id) {
    return this._textEditors.get(id);
  }
};
MainThreadDocumentsAndEditors = __decorate([
  extHostCustomer,
  __param(1, IModelService),
  __param(2, ITextFileService),
  __param(3, IEditorService),
  __param(4, ICodeEditorService),
  __param(5, IFileService),
  __param(6, ITextModelService),
  __param(7, IEditorGroupsService),
  __param(8, IPaneCompositePartService),
  __param(9, IWorkbenchEnvironmentService),
  __param(10, IWorkingCopyFileService),
  __param(11, IUriIdentityService),
  __param(12, IClipboardService),
  __param(13, IPathService),
  __param(14, IConfigurationService)
], MainThreadDocumentsAndEditors);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadEditorTabs.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/workbench/contrib/customEditor/browser/customEditorInput.js
init_tslib_es6();
init_buffer();
init_network();
init_path();
init_resources();
init_types();
init_files();
init_instantiation();
init_undoRedo();
var CustomEditorInput_1;
var _a14;
var CustomEditorInput = (_a14 = class extends LazilyResolvedWebviewEditorInput {
  static create(instantiationService, resource, viewType, group, options) {
    return instantiationService.invokeFunction((accessor) => {
      const untitledString = accessor.get(IUntitledTextEditorService).getValue(resource);
      const untitledDocumentData = untitledString ? VSBuffer.fromString(untitledString) : void 0;
      const webview = accessor.get(IWebviewService).createWebviewOverlay({
        providedViewType: viewType,
        title: void 0,
        options: { customClasses: options == null ? void 0 : options.customClasses },
        contentOptions: {},
        extension: void 0
      });
      const input = instantiationService.createInstance(CustomEditorInput_1, { resource, viewType }, webview, { untitledDocumentData, oldResource: options == null ? void 0 : options.oldResource });
      if (typeof group !== "undefined") {
        input.updateGroup(group);
      }
      return input;
    });
  }
  get resource() {
    return this._editorResource;
  }
  constructor(init, webview, options, webviewWorkbenchService, instantiationService, labelService, customEditorService, fileDialogService, undoRedoService, fileService, filesConfigurationService) {
    super({ providedId: init.viewType, viewType: init.viewType, name: "" }, webview, webviewWorkbenchService);
    this.instantiationService = instantiationService;
    this.labelService = labelService;
    this.customEditorService = customEditorService;
    this.fileDialogService = fileDialogService;
    this.undoRedoService = undoRedoService;
    this.fileService = fileService;
    this.filesConfigurationService = filesConfigurationService;
    this._shortDescription = void 0;
    this._mediumDescription = void 0;
    this._longDescription = void 0;
    this._shortTitle = void 0;
    this._mediumTitle = void 0;
    this._longTitle = void 0;
    this._editorResource = init.resource;
    this.oldResource = options.oldResource;
    this._defaultDirtyState = options.startsDirty;
    this._backupId = options.backupId;
    this._untitledDocumentData = options.untitledDocumentData;
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.labelService.onDidChangeFormatters((e) => this.onLabelEvent(e.scheme)));
    this._register(this.fileService.onDidChangeFileSystemProviderRegistrations((e) => this.onLabelEvent(e.scheme)));
    this._register(this.fileService.onDidChangeFileSystemProviderCapabilities((e) => this.onLabelEvent(e.scheme)));
  }
  onLabelEvent(scheme) {
    if (scheme === this.resource.scheme) {
      this.updateLabel();
    }
  }
  updateLabel() {
    this._shortDescription = void 0;
    this._mediumDescription = void 0;
    this._longDescription = void 0;
    this._shortTitle = void 0;
    this._mediumTitle = void 0;
    this._longTitle = void 0;
    this._onDidChangeLabel.fire();
  }
  get typeId() {
    return CustomEditorInput_1.typeId;
  }
  get editorId() {
    return this.viewType;
  }
  get capabilities() {
    var _a30;
    let capabilities = 0;
    capabilities |= 128;
    if (!((_a30 = this.customEditorService.getCustomEditorCapabilities(this.viewType)) == null ? void 0 : _a30.supportsMultipleEditorsPerDocument)) {
      capabilities |= 8;
    }
    if (this._modelRef) {
      if (this._modelRef.object.isReadonly()) {
        capabilities |= 2;
      }
    } else {
      if (this.filesConfigurationService.isReadonly(this.resource)) {
        capabilities |= 2;
      }
    }
    if (this.resource.scheme === Schemas.untitled) {
      capabilities |= 4;
    }
    return capabilities;
  }
  getName() {
    return basename(this.labelService.getUriLabel(this.resource));
  }
  getDescription(verbosity = 1) {
    switch (verbosity) {
      case 0:
        return this.shortDescription;
      case 2:
        return this.longDescription;
      case 1:
      default:
        return this.mediumDescription;
    }
  }
  get shortDescription() {
    if (typeof this._shortDescription !== "string") {
      this._shortDescription = this.labelService.getUriBasenameLabel(dirname2(this.resource));
    }
    return this._shortDescription;
  }
  get mediumDescription() {
    if (typeof this._mediumDescription !== "string") {
      this._mediumDescription = this.labelService.getUriLabel(dirname2(this.resource), { relative: true });
    }
    return this._mediumDescription;
  }
  get longDescription() {
    if (typeof this._longDescription !== "string") {
      this._longDescription = this.labelService.getUriLabel(dirname2(this.resource));
    }
    return this._longDescription;
  }
  get shortTitle() {
    if (typeof this._shortTitle !== "string") {
      this._shortTitle = this.getName();
    }
    return this._shortTitle;
  }
  get mediumTitle() {
    if (typeof this._mediumTitle !== "string") {
      this._mediumTitle = this.labelService.getUriLabel(this.resource, { relative: true });
    }
    return this._mediumTitle;
  }
  get longTitle() {
    if (typeof this._longTitle !== "string") {
      this._longTitle = this.labelService.getUriLabel(this.resource);
    }
    return this._longTitle;
  }
  getTitle(verbosity) {
    switch (verbosity) {
      case 0:
        return this.shortTitle;
      case 2:
        return this.longTitle;
      default:
      case 1:
        return this.mediumTitle;
    }
  }
  matches(other) {
    if (super.matches(other)) {
      return true;
    }
    return this === other || other instanceof CustomEditorInput_1 && this.viewType === other.viewType && isEqual(this.resource, other.resource);
  }
  copy() {
    return CustomEditorInput_1.create(this.instantiationService, this.resource, this.viewType, this.group, this.webview.options);
  }
  isReadonly() {
    if (!this._modelRef) {
      return this.filesConfigurationService.isReadonly(this.resource);
    }
    return this._modelRef.object.isReadonly();
  }
  isDirty() {
    if (!this._modelRef) {
      return !!this._defaultDirtyState;
    }
    return this._modelRef.object.isDirty();
  }
  async save(groupId, options) {
    if (!this._modelRef) {
      return void 0;
    }
    const target = await this._modelRef.object.saveCustomEditor(options);
    if (!target) {
      return void 0;
    }
    if (!isEqual(target, this.resource)) {
      return { resource: target };
    }
    return this;
  }
  async saveAs(groupId, options) {
    var _a30;
    if (!this._modelRef) {
      return void 0;
    }
    const dialogPath = this._editorResource;
    const target = await this.fileDialogService.pickFileToSave(dialogPath, options == null ? void 0 : options.availableFileSystems);
    if (!target) {
      return void 0;
    }
    if (!await this._modelRef.object.saveCustomEditorAs(this._editorResource, target, options)) {
      return void 0;
    }
    return (_a30 = await this.rename(groupId, target)) == null ? void 0 : _a30.editor;
  }
  async revert(group, options) {
    if (this._modelRef) {
      return this._modelRef.object.revert(options);
    }
    this._defaultDirtyState = false;
    this._onDidChangeDirty.fire();
  }
  async resolve() {
    await super.resolve();
    if (this.isDisposed()) {
      return null;
    }
    if (!this._modelRef) {
      const oldCapabilities = this.capabilities;
      this._modelRef = this._register(assertIsDefined(await this.customEditorService.models.tryRetain(this.resource, this.viewType)));
      this._register(this._modelRef.object.onDidChangeDirty(() => this._onDidChangeDirty.fire()));
      this._register(this._modelRef.object.onDidChangeReadonly(() => this._onDidChangeCapabilities.fire()));
      if (this._untitledDocumentData) {
        this._defaultDirtyState = true;
      }
      if (this.isDirty()) {
        this._onDidChangeDirty.fire();
      }
      if (this.capabilities !== oldCapabilities) {
        this._onDidChangeCapabilities.fire();
      }
    }
    return null;
  }
  async rename(group, newResource) {
    return { editor: { resource: newResource } };
  }
  undo() {
    assertIsDefined(this._modelRef);
    return this.undoRedoService.undo(this.resource);
  }
  redo() {
    assertIsDefined(this._modelRef);
    return this.undoRedoService.redo(this.resource);
  }
  onMove(handler) {
    this._moveHandler = handler;
  }
  transfer(other) {
    if (!super.transfer(other)) {
      return;
    }
    other._moveHandler = this._moveHandler;
    this._moveHandler = void 0;
    return other;
  }
  get backupId() {
    if (this._modelRef) {
      return this._modelRef.object.backupId;
    }
    return this._backupId;
  }
  get untitledDocumentData() {
    return this._untitledDocumentData;
  }
  toUntyped() {
    return {
      resource: this.resource,
      options: {
        override: this.viewType
      }
    };
  }
}, CustomEditorInput_1 = _a14, _a14.typeId = "workbench.editors.webviewEditor", _a14);
CustomEditorInput = CustomEditorInput_1 = __decorate([
  __param(3, IWebviewWorkbenchService),
  __param(4, IInstantiationService),
  __param(5, ILabelService),
  __param(6, ICustomEditorService),
  __param(7, IFileDialogService),
  __param(8, IUndoRedoService),
  __param(9, IFileService),
  __param(10, IFilesConfigurationService)
], CustomEditorInput);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadEditorTabs.js
init_uri();

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/browser/terminalEditorInput.js
init_tslib_es6();
init_nls();
init_lifecycle();
init_themeService();
init_themables();

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/browser/terminalIcon.js
init_hash();
init_uri();
init_theme();
init_themables();

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/common/terminalColorRegistry.js
init_nls();
init_colorRegistry();
var TERMINAL_BACKGROUND_COLOR = registerColor("terminal.background", null, localize(
  "terminal.background",
  "The background color of the terminal, this allows coloring the terminal differently to the panel."
));
var TERMINAL_FOREGROUND_COLOR = registerColor("terminal.foreground", {
  light: "#333333",
  dark: "#CCCCCC",
  hcDark: "#FFFFFF",
  hcLight: "#292929"
}, localize("terminal.foreground", "The foreground color of the terminal."));
var TERMINAL_CURSOR_FOREGROUND_COLOR = registerColor("terminalCursor.foreground", null, localize(
  "terminalCursor.foreground",
  "The foreground color of the terminal cursor."
));
var TERMINAL_CURSOR_BACKGROUND_COLOR = registerColor("terminalCursor.background", null, localize(
  "terminalCursor.background",
  "The background color of the terminal cursor. Allows customizing the color of a character overlapped by a block cursor."
));
var TERMINAL_SELECTION_BACKGROUND_COLOR = registerColor("terminal.selectionBackground", {
  light: editorSelectionBackground,
  dark: editorSelectionBackground,
  hcDark: editorSelectionBackground,
  hcLight: editorSelectionBackground
}, localize(
  "terminal.selectionBackground",
  "The selection background color of the terminal."
));
var TERMINAL_INACTIVE_SELECTION_BACKGROUND_COLOR = registerColor("terminal.inactiveSelectionBackground", {
  light: transparent(TERMINAL_SELECTION_BACKGROUND_COLOR, 0.5),
  dark: transparent(TERMINAL_SELECTION_BACKGROUND_COLOR, 0.5),
  hcDark: transparent(TERMINAL_SELECTION_BACKGROUND_COLOR, 0.7),
  hcLight: transparent(TERMINAL_SELECTION_BACKGROUND_COLOR, 0.5)
}, localize(
  "terminal.inactiveSelectionBackground",
  "The selection background color of the terminal when it does not have focus."
));
var TERMINAL_SELECTION_FOREGROUND_COLOR = registerColor("terminal.selectionForeground", {
  light: null,
  dark: null,
  hcDark: "#000000",
  hcLight: "#ffffff"
}, localize(
  "terminal.selectionForeground",
  "The selection foreground color of the terminal. When this is null the selection foreground will be retained and have the minimum contrast ratio feature applied."
));
var TERMINAL_COMMAND_DECORATION_DEFAULT_BACKGROUND_COLOR = registerColor("terminalCommandDecoration.defaultBackground", {
  light: "#00000040",
  dark: "#ffffff40",
  hcDark: "#ffffff80",
  hcLight: "#00000040"
}, localize(
  "terminalCommandDecoration.defaultBackground",
  "The default terminal command decoration background color."
));
var TERMINAL_COMMAND_DECORATION_SUCCESS_BACKGROUND_COLOR = registerColor("terminalCommandDecoration.successBackground", {
  dark: "#1B81A8",
  light: "#2090D3",
  hcDark: "#1B81A8",
  hcLight: "#007100"
}, localize(
  "terminalCommandDecoration.successBackground",
  "The terminal command decoration background color for successful commands."
));
var TERMINAL_COMMAND_DECORATION_ERROR_BACKGROUND_COLOR = registerColor("terminalCommandDecoration.errorBackground", {
  dark: "#F14C4C",
  light: "#E51400",
  hcDark: "#F14C4C",
  hcLight: "#B5200D"
}, localize(
  "terminalCommandDecoration.errorBackground",
  "The terminal command decoration background color for error commands."
));
var TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR = registerColor("terminalOverviewRuler.cursorForeground", {
  dark: "#A0A0A0CC",
  light: "#A0A0A0CC",
  hcDark: "#A0A0A0CC",
  hcLight: "#A0A0A0CC"
}, localize(
  "terminalOverviewRuler.cursorForeground",
  "The overview ruler cursor color."
));
registerColor("terminal.border", {
  dark: PANEL_BORDER,
  light: PANEL_BORDER,
  hcDark: PANEL_BORDER,
  hcLight: PANEL_BORDER
}, localize(
  "terminal.border",
  "The color of the border that separates split panes within the terminal. This defaults to panel.border."
));
var TERMINAL_FIND_MATCH_BACKGROUND_COLOR = registerColor("terminal.findMatchBackground", {
  dark: editorFindMatch,
  light: editorFindMatch,
  hcDark: null,
  hcLight: "#0F4A85"
}, localize(
  "terminal.findMatchBackground",
  "Color of the current search match in the terminal. The color must not be opaque so as not to hide underlying terminal content."
));
registerColor("terminal.hoverHighlightBackground", {
  dark: transparent(editorHoverHighlight, 0.5),
  light: transparent(editorHoverHighlight, 0.5),
  hcDark: transparent(editorHoverHighlight, 0.5),
  hcLight: transparent(editorHoverHighlight, 0.5)
}, localize(
  "terminal.findMatchHighlightBorder",
  "Border color of the other search matches in the terminal."
));
var TERMINAL_FIND_MATCH_BORDER_COLOR = registerColor("terminal.findMatchBorder", {
  dark: null,
  light: null,
  hcDark: "#f38518",
  hcLight: "#0F4A85"
}, localize(
  "terminal.findMatchBorder",
  "Border color of the current search match in the terminal."
));
var TERMINAL_FIND_MATCH_HIGHLIGHT_BACKGROUND_COLOR = registerColor("terminal.findMatchHighlightBackground", {
  dark: editorFindMatchHighlight,
  light: editorFindMatchHighlight,
  hcDark: null,
  hcLight: null
}, localize(
  "terminal.findMatchHighlightBackground",
  "Color of the other search matches in the terminal. The color must not be opaque so as not to hide underlying terminal content."
));
var TERMINAL_FIND_MATCH_HIGHLIGHT_BORDER_COLOR = registerColor("terminal.findMatchHighlightBorder", {
  dark: null,
  light: null,
  hcDark: "#f38518",
  hcLight: "#0F4A85"
}, localize(
  "terminal.findMatchHighlightBorder",
  "Border color of the other search matches in the terminal."
));
var TERMINAL_OVERVIEW_RULER_FIND_MATCH_FOREGROUND_COLOR = registerColor("terminalOverviewRuler.findMatchForeground", {
  dark: overviewRulerFindMatchForeground,
  light: overviewRulerFindMatchForeground,
  hcDark: "#f38518",
  hcLight: "#0F4A85"
}, localize(
  "terminalOverviewRuler.findMatchHighlightForeground",
  "Overview ruler marker color for find matches in the terminal."
));
registerColor("terminal.dropBackground", {
  dark: EDITOR_DRAG_AND_DROP_BACKGROUND,
  light: EDITOR_DRAG_AND_DROP_BACKGROUND,
  hcDark: EDITOR_DRAG_AND_DROP_BACKGROUND,
  hcLight: EDITOR_DRAG_AND_DROP_BACKGROUND
}, localize(
  "terminal.dragAndDropBackground",
  "Background color when dragging on top of terminals. The color should have transparency so that the terminal contents can still shine through."
));
registerColor("terminal.tab.activeBorder", {
  dark: TAB_ACTIVE_BORDER,
  light: TAB_ACTIVE_BORDER,
  hcDark: TAB_ACTIVE_BORDER,
  hcLight: TAB_ACTIVE_BORDER
}, localize(
  "terminal.tab.activeBorder",
  "Border on the side of the terminal tab in the panel. This defaults to tab.activeBorder."
));

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/browser/terminalIcon.js
function getColorClass(terminalOrColorKey) {
  let color2 = void 0;
  if (typeof terminalOrColorKey === "string") {
    color2 = terminalOrColorKey;
  } else if (terminalOrColorKey.color) {
    color2 = terminalOrColorKey.color.replace(/\./g, "_");
  } else if (ThemeIcon.isThemeIcon(terminalOrColorKey.icon) && terminalOrColorKey.icon.color) {
    color2 = terminalOrColorKey.icon.color.id.replace(/\./g, "_");
  }
  if (color2) {
    return `terminal-icon-${color2.replace(/\./g, "_")}`;
  }
  return void 0;
}
function getUriClasses(terminal, colorScheme, extensionContributed) {
  const icon = terminal.icon;
  if (!icon) {
    return void 0;
  }
  const iconClasses = [];
  let uri = void 0;
  if (extensionContributed) {
    if (typeof icon === "string" && (icon.startsWith("$(") || getIconRegistry().getIcon(icon))) {
      return iconClasses;
    } else if (typeof icon === "string") {
      uri = URI.parse(icon);
    }
  }
  if (icon instanceof URI) {
    uri = icon;
  } else if (icon instanceof Object && "light" in icon && "dark" in icon) {
    uri = colorScheme === ColorScheme.LIGHT ? icon.light : icon.dark;
  }
  if (uri instanceof URI) {
    const uriIconKey = hash(uri.path).toString(36);
    const className = `terminal-uri-icon-${uriIconKey}`;
    iconClasses.push(className);
    iconClasses.push(`terminal-uri-icon`);
  }
  return iconClasses;
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/browser/terminalEditorInput.js
init_instantiation();
init_contextkey();
init_configuration();

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/common/terminalContextKey.js
init_nls();
init_contextkey();
var TerminalContextKeys;
(function(TerminalContextKeys2) {
  TerminalContextKeys2.isOpen = new RawContextKey("terminalIsOpen", false, true);
  TerminalContextKeys2.focus = new RawContextKey(
    "terminalFocus",
    false,
    localize("terminalFocusContextKey", "Whether the terminal is focused.")
  );
  TerminalContextKeys2.focusInAny = new RawContextKey(
    "terminalFocusInAny",
    false,
    localize(
      "terminalFocusInAnyContextKey",
      "Whether any terminal is focused, including detached terminals used in other UI."
    )
  );
  TerminalContextKeys2.accessibleBufferFocus = new RawContextKey(
    "terminalAccessibleBufferFocus",
    false,
    localize(
      "terminalAccessibleBufferFocusContextKey",
      "Whether the terminal accessible buffer is focused."
    )
  );
  TerminalContextKeys2.accessibleBufferOnLastLine = new RawContextKey(
    "terminalAccessibleBufferOnLastLine",
    false,
    localize(
      "terminalAccessibleBufferOnLastLineContextKey",
      "Whether the accessible buffer focus is on the last line."
    )
  );
  TerminalContextKeys2.editorFocus = new RawContextKey(
    "terminalEditorFocus",
    false,
    localize(
      "terminalEditorFocusContextKey",
      "Whether a terminal in the editor area is focused."
    )
  );
  TerminalContextKeys2.count = new RawContextKey("terminalCount", 0, localize("terminalCountContextKey", "The current number of terminals."));
  TerminalContextKeys2.groupCount = new RawContextKey("terminalGroupCount", 0, true);
  TerminalContextKeys2.tabsNarrow = new RawContextKey(
    "isTerminalTabsNarrow",
    false,
    true
  );
  TerminalContextKeys2.terminalHasFixedWidth = new RawContextKey(
    "terminalHasFixedWidth",
    false,
    true
  );
  TerminalContextKeys2.tabsFocus = new RawContextKey(
    "terminalTabsFocus",
    false,
    localize(
      "terminalTabsFocusContextKey",
      "Whether the terminal tabs widget is focused."
    )
  );
  TerminalContextKeys2.webExtensionContributedProfile = new RawContextKey(
    "terminalWebExtensionContributedProfile",
    false,
    true
  );
  TerminalContextKeys2.terminalHasBeenCreated = new RawContextKey(
    "terminalHasBeenCreated",
    false,
    true
  );
  TerminalContextKeys2.terminalEditorActive = new RawContextKey(
    "terminalEditorActive",
    false,
    true
  );
  TerminalContextKeys2.tabsMouse = new RawContextKey("terminalTabsMouse", false, true);
  TerminalContextKeys2.shellType = new RawContextKey(
    "terminalShellType",
    void 0,
    { type: "string", description: localize(
      "terminalShellTypeContextKey",
      "The shell type of the active terminal, this is set to the last known value when no terminals exist."
    ) }
  );
  TerminalContextKeys2.altBufferActive = new RawContextKey(
    "terminalAltBufferActive",
    false,
    localize("terminalAltBufferActive", "Whether the terminal's alt buffer is active.")
  );
  TerminalContextKeys2.suggestWidgetVisible = new RawContextKey(
    "terminalSuggestWidgetVisible",
    false,
    localize(
      "terminalSuggestWidgetVisible",
      "Whether the terminal's suggest widget is visible."
    )
  );
  TerminalContextKeys2.notFocus = TerminalContextKeys2.focus.toNegated();
  TerminalContextKeys2.viewShowing = new RawContextKey(
    "terminalViewShowing",
    false,
    localize("terminalViewShowing", "Whether the terminal view is showing")
  );
  TerminalContextKeys2.textSelected = new RawContextKey(
    "terminalTextSelected",
    false,
    localize(
      "terminalTextSelectedContextKey",
      "Whether text is selected in the active terminal."
    )
  );
  TerminalContextKeys2.textSelectedInFocused = new RawContextKey(
    "terminalTextSelectedInFocused",
    false,
    localize(
      "terminalTextSelectedInFocusedContextKey",
      "Whether text is selected in a focused terminal."
    )
  );
  TerminalContextKeys2.notTextSelected = TerminalContextKeys2.textSelected.toNegated();
  TerminalContextKeys2.findVisible = new RawContextKey(
    "terminalFindVisible",
    false,
    true
  );
  TerminalContextKeys2.notFindVisible = TerminalContextKeys2.findVisible.toNegated();
  TerminalContextKeys2.findInputFocus = new RawContextKey(
    "terminalFindInputFocused",
    false,
    true
  );
  TerminalContextKeys2.findFocus = new RawContextKey(
    "terminalFindFocused",
    false,
    true
  );
  TerminalContextKeys2.notFindFocus = TerminalContextKeys2.findInputFocus.toNegated();
  TerminalContextKeys2.processSupported = new RawContextKey(
    "terminalProcessSupported",
    false,
    localize(
      "terminalProcessSupportedContextKey",
      "Whether terminal processes can be launched in the current workspace."
    )
  );
  TerminalContextKeys2.tabsSingularSelection = new RawContextKey(
    "terminalTabsSingularSelection",
    false,
    localize(
      "terminalTabsSingularSelectedContextKey",
      "Whether one terminal is selected in the terminal tabs list."
    )
  );
  TerminalContextKeys2.splitTerminal = new RawContextKey(
    "terminalSplitTerminal",
    false,
    localize(
      "isSplitTerminalContextKey",
      "Whether the focused tab's terminal is a split terminal."
    )
  );
  TerminalContextKeys2.inTerminalRunCommandPicker = new RawContextKey(
    "inTerminalRunCommandPicker",
    false,
    localize(
      "inTerminalRunCommandPickerContextKey",
      "Whether the terminal run command picker is currently open."
    )
  );
  TerminalContextKeys2.terminalShellIntegrationEnabled = new RawContextKey(
    "terminalShellIntegrationEnabled",
    false,
    localize(
      "terminalShellIntegrationEnabled",
      "Whether shell integration is enabled in the active terminal"
    )
  );
})(TerminalContextKeys || (TerminalContextKeys = {}));

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/browser/terminalEditorInput.js
init_event();
var TerminalEditorInput_1;
var _a15;
var TerminalEditorInput = (_a15 = class extends EditorInput {
  setGroup(group) {
    this._group = group;
  }
  get group() {
    return this._group;
  }
  get typeId() {
    return TerminalEditorInput_1.ID;
  }
  get editorId() {
    return terminalEditorId;
  }
  get capabilities() {
    return 2 | 8 | 128;
  }
  setTerminalInstance(instance) {
    if (this._terminalInstance) {
      throw new Error("cannot set instance that has already been set");
    }
    this._terminalInstance = instance;
    this._setupInstanceListeners();
  }
  copy() {
    const instance = this._terminalInstanceService.createInstance(this._copyLaunchConfig || {}, TerminalLocation2.Editor);
    instance.focusWhenReady();
    this._copyLaunchConfig = void 0;
    return this._instantiationService.createInstance(TerminalEditorInput_1, instance.resource, instance);
  }
  setCopyLaunchConfig(launchConfig) {
    this._copyLaunchConfig = launchConfig;
  }
  get terminalInstance() {
    return this._isDetached ? void 0 : this._terminalInstance;
  }
  showConfirm() {
    var _a30;
    if (this._isReverted) {
      return false;
    }
    const confirmOnKill = this._configurationService.getValue("terminal.integrated.confirmOnKill");
    if (confirmOnKill === "editor" || confirmOnKill === "always") {
      return ((_a30 = this._terminalInstance) == null ? void 0 : _a30.hasChildProcesses) || false;
    }
    return false;
  }
  async confirm(terminals) {
    const { confirmed } = await this._dialogService.confirm({
      type: severity_default.Warning,
      message: localize(
        "confirmDirtyTerminal.message",
        "Do you want to terminate running processes?"
      ),
      primaryButton: localize(
        { key: "confirmDirtyTerminal.button", comment: ["&& denotes a mnemonic"] },
        "&&Terminate"
      ),
      detail: terminals.length > 1 ? terminals.map((terminal) => terminal.editor.getName()).join("\n") + "\n\n" + localize(
        "confirmDirtyTerminals.detail",
        "Closing will terminate the running processes in the terminals."
      ) : localize(
        "confirmDirtyTerminal.detail",
        "Closing will terminate the running processes in this terminal."
      )
    });
    return confirmed ? 1 : 2;
  }
  async revert() {
    this._isReverted = true;
  }
  constructor(resource, _terminalInstance, _themeService, _terminalInstanceService, _instantiationService, _configurationService, _lifecycleService, _contextKeyService, _dialogService) {
    super();
    this.resource = resource;
    this._terminalInstance = _terminalInstance;
    this._themeService = _themeService;
    this._terminalInstanceService = _terminalInstanceService;
    this._instantiationService = _instantiationService;
    this._configurationService = _configurationService;
    this._lifecycleService = _lifecycleService;
    this._dialogService = _dialogService;
    this.closeHandler = this;
    this._isDetached = false;
    this._isShuttingDown = false;
    this._isReverted = false;
    this._onDidRequestAttach = this._register(new Emitter());
    this.onDidRequestAttach = this._onDidRequestAttach.event;
    this._terminalEditorFocusContextKey = TerminalContextKeys.editorFocus.bindTo(_contextKeyService);
    if (_terminalInstance) {
      this._setupInstanceListeners();
    }
  }
  _setupInstanceListeners() {
    const instance = this._terminalInstance;
    if (!instance) {
      return;
    }
    const instanceOnDidFocusListener = instance.onDidFocus(() => this._terminalEditorFocusContextKey.set(true));
    const instanceOnDidBlurListener = instance.onDidBlur(() => this._terminalEditorFocusContextKey.reset());
    this._register(toDisposable(() => {
      if (!this._isDetached && !this._isShuttingDown) {
        instance.dispose(TerminalExitReason2.User);
      }
      dispose([instanceOnDidFocusListener, instanceOnDidBlurListener]);
    }));
    const disposeListeners = [
      instance.onExit((e) => {
        if (!instance.waitOnExit) {
          this.dispose();
        }
      }),
      instance.onDisposed(() => this.dispose()),
      instance.onTitleChanged(() => this._onDidChangeLabel.fire()),
      instance.onIconChanged(() => this._onDidChangeLabel.fire()),
      instanceOnDidFocusListener,
      instanceOnDidBlurListener,
      instance.statusList.onDidChangePrimaryStatus(() => this._onDidChangeLabel.fire())
    ];
    this._lifecycleService.onWillShutdown((e) => {
      this._isShuttingDown = true;
      dispose(disposeListeners);
      const shouldPersistTerminals = this._configurationService.getValue("terminal.integrated.enablePersistentSessions") && e.reason === 3;
      if (shouldPersistTerminals) {
        instance.detachProcessAndDispose(TerminalExitReason2.Shutdown);
      } else {
        instance.dispose(TerminalExitReason2.Shutdown);
      }
    });
  }
  getName() {
    var _a30;
    return ((_a30 = this._terminalInstance) == null ? void 0 : _a30.title) || this.resource.fragment;
  }
  getLabelExtraClasses() {
    if (!this._terminalInstance) {
      return [];
    }
    const extraClasses = ["terminal-tab"];
    const colorClass = getColorClass(this._terminalInstance);
    if (colorClass) {
      extraClasses.push(colorClass);
    }
    const uriClasses = getUriClasses(this._terminalInstance, this._themeService.getColorTheme().type);
    if (uriClasses) {
      extraClasses.push(...uriClasses);
    }
    if (ThemeIcon.isThemeIcon(this._terminalInstance.icon)) {
      extraClasses.push(`codicon-${this._terminalInstance.icon.id}`);
    }
    return extraClasses;
  }
  detachInstance() {
    var _a30;
    if (!this._isShuttingDown) {
      (_a30 = this._terminalInstance) == null ? void 0 : _a30.detachFromElement();
      this._isDetached = true;
    }
  }
  getDescription() {
    var _a30;
    return (_a30 = this._terminalInstance) == null ? void 0 : _a30.description;
  }
  toUntyped() {
    return {
      resource: this.resource,
      options: {
        override: terminalEditorId,
        pinned: true,
        forceReload: true
      }
    };
  }
}, TerminalEditorInput_1 = _a15, _a15.ID = "workbench.editors.terminal", _a15);
TerminalEditorInput = TerminalEditorInput_1 = __decorate([
  __param(2, IThemeService),
  __param(3, ITerminalInstanceService),
  __param(4, IInstantiationService),
  __param(5, IConfigurationService),
  __param(6, ILifecycleService),
  __param(7, IContextKeyService),
  __param(8, IDialogService)
], TerminalEditorInput);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadEditorTabs.js
init_configuration();
init_resources();

// node_modules/vscode/vscode/src/vs/workbench/common/editor/editorGroupModel.js
init_tslib_es6();
init_event();
init_instantiation();
init_configuration();
init_lifecycle();
init_platform2();
init_arrays();
var EditorGroupModel_1;
var EditorOpenPositioning = {
  LEFT: "left",
  RIGHT: "right",
  FIRST: "first",
  LAST: "last"
};
function isSerializedEditorGroupModel(group) {
  const candidate = group;
  return !!(candidate && typeof candidate === "object" && Array.isArray(candidate.editors) && Array.isArray(candidate.mru));
}
function isGroupEditorMoveEvent(e) {
  const candidate = e;
  return candidate.kind === 5 && candidate.editorIndex !== void 0 && candidate.oldEditorIndex !== void 0;
}
var _a16;
var EditorGroupModel = (_a16 = class extends Disposable {
  get id() {
    return this._id;
  }
  constructor(labelOrSerializedGroup, instantiationService, configurationService) {
    super();
    this.instantiationService = instantiationService;
    this.configurationService = configurationService;
    this._onDidModelChange = this._register(new Emitter());
    this.onDidModelChange = this._onDidModelChange.event;
    this.editors = [];
    this.mru = [];
    this.editorListeners = /* @__PURE__ */ new Set();
    this.locked = false;
    this.preview = null;
    this.active = null;
    this.sticky = -1;
    if (isSerializedEditorGroupModel(labelOrSerializedGroup)) {
      this._id = this.deserialize(labelOrSerializedGroup);
    } else {
      this._id = EditorGroupModel_1.IDS++;
    }
    this.onConfigurationUpdated();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationUpdated(e)));
  }
  onConfigurationUpdated(e) {
    if (e && !e.affectsConfiguration("workbench.editor.openPositioning") && !e.affectsConfiguration("workbench.editor.focusRecentEditorAfterClose")) {
      return;
    }
    this.editorOpenPositioning = this.configurationService.getValue("workbench.editor.openPositioning");
    this.focusRecentEditorAfterClose = this.configurationService.getValue("workbench.editor.focusRecentEditorAfterClose");
  }
  get count() {
    return this.editors.length;
  }
  get stickyCount() {
    return this.sticky + 1;
  }
  getEditors(order, options) {
    const editors = order === 0 ? this.mru.slice(0) : this.editors.slice(0);
    if (options == null ? void 0 : options.excludeSticky) {
      if (order === 0) {
        return editors.filter((editor) => !this.isSticky(editor));
      }
      return editors.slice(this.sticky + 1);
    }
    return editors;
  }
  getEditorByIndex(index) {
    return this.editors[index];
  }
  get activeEditor() {
    return this.active;
  }
  isActive(editor) {
    return this.matches(this.active, editor);
  }
  get previewEditor() {
    return this.preview;
  }
  openEditor(candidate, options) {
    const makeSticky = (options == null ? void 0 : options.sticky) || typeof (options == null ? void 0 : options.index) === "number" && this.isSticky(options.index);
    const makePinned = (options == null ? void 0 : options.pinned) || (options == null ? void 0 : options.sticky);
    const makeActive = (options == null ? void 0 : options.active) || !this.activeEditor || !makePinned && this.matches(this.preview, this.activeEditor);
    const existingEditorAndIndex = this.findEditor(candidate, options);
    if (!existingEditorAndIndex) {
      const newEditor = candidate;
      const indexOfActive = this.indexOf(this.active);
      let targetIndex;
      if (options && typeof options.index === "number") {
        targetIndex = options.index;
      } else if (this.editorOpenPositioning === EditorOpenPositioning.FIRST) {
        targetIndex = 0;
        if (!makeSticky && this.isSticky(targetIndex)) {
          targetIndex = this.sticky + 1;
        }
      } else if (this.editorOpenPositioning === EditorOpenPositioning.LAST) {
        targetIndex = this.editors.length;
      } else {
        if (this.editorOpenPositioning === EditorOpenPositioning.LEFT) {
          if (indexOfActive === 0 || !this.editors.length) {
            targetIndex = 0;
          } else {
            targetIndex = indexOfActive;
          }
        } else {
          targetIndex = indexOfActive + 1;
        }
        if (!makeSticky && this.isSticky(targetIndex)) {
          targetIndex = this.sticky + 1;
        }
      }
      if (makeSticky) {
        this.sticky++;
        if (!this.isSticky(targetIndex)) {
          targetIndex = this.sticky;
        }
      }
      if (makePinned || !this.preview) {
        this.splice(targetIndex, false, newEditor);
      }
      if (!makePinned) {
        if (this.preview) {
          const indexOfPreview = this.indexOf(this.preview);
          if (targetIndex > indexOfPreview) {
            targetIndex--;
          }
          this.replaceEditor(this.preview, newEditor, targetIndex, !makeActive);
        }
        this.preview = newEditor;
      }
      this.registerEditorListeners(newEditor);
      const event = {
        kind: 3,
        editor: newEditor,
        editorIndex: targetIndex
      };
      this._onDidModelChange.fire(event);
      if (makeActive) {
        this.doSetActive(newEditor, targetIndex);
      }
      return {
        editor: newEditor,
        isNew: true
      };
    } else {
      const [existingEditor, existingEditorIndex] = existingEditorAndIndex;
      if (makePinned) {
        this.doPin(existingEditor, existingEditorIndex);
      }
      if (makeActive) {
        this.doSetActive(existingEditor, existingEditorIndex);
      }
      if (options && typeof options.index === "number") {
        this.moveEditor(existingEditor, options.index);
      }
      if (makeSticky) {
        this.doStick(existingEditor, this.indexOf(existingEditor));
      }
      return {
        editor: existingEditor,
        isNew: false
      };
    }
  }
  registerEditorListeners(editor) {
    const listeners = new DisposableStore();
    this.editorListeners.add(listeners);
    listeners.add(Event.once(editor.onWillDispose)(() => {
      const editorIndex = this.editors.indexOf(editor);
      if (editorIndex >= 0) {
        const event = {
          kind: 12,
          editor,
          editorIndex
        };
        this._onDidModelChange.fire(event);
      }
    }));
    listeners.add(editor.onDidChangeDirty(() => {
      const event = {
        kind: 11,
        editor,
        editorIndex: this.editors.indexOf(editor)
      };
      this._onDidModelChange.fire(event);
    }));
    listeners.add(editor.onDidChangeLabel(() => {
      const event = {
        kind: 7,
        editor,
        editorIndex: this.editors.indexOf(editor)
      };
      this._onDidModelChange.fire(event);
    }));
    listeners.add(editor.onDidChangeCapabilities(() => {
      const event = {
        kind: 8,
        editor,
        editorIndex: this.editors.indexOf(editor)
      };
      this._onDidModelChange.fire(event);
    }));
    listeners.add(this.onDidModelChange((event) => {
      var _a30;
      if (event.kind === 4 && ((_a30 = event.editor) == null ? void 0 : _a30.matches(editor))) {
        dispose(listeners);
        this.editorListeners.delete(listeners);
      }
    }));
  }
  replaceEditor(toReplace, replaceWith, replaceIndex, openNext = true) {
    const closeResult = this.doCloseEditor(toReplace, EditorCloseContext.REPLACE, openNext);
    this.splice(replaceIndex, false, replaceWith);
    if (closeResult) {
      const event = {
        kind: 4,
        ...closeResult
      };
      this._onDidModelChange.fire(event);
    }
  }
  closeEditor(candidate, context = EditorCloseContext.UNKNOWN, openNext = true) {
    const closeResult = this.doCloseEditor(candidate, context, openNext);
    if (closeResult) {
      const event = {
        kind: 4,
        ...closeResult
      };
      this._onDidModelChange.fire(event);
      return closeResult;
    }
    return void 0;
  }
  doCloseEditor(candidate, context, openNext) {
    const index = this.indexOf(candidate);
    if (index === -1) {
      return void 0;
    }
    const editor = this.editors[index];
    const sticky = this.isSticky(index);
    if (openNext && this.matches(this.active, editor)) {
      if (this.mru.length > 1) {
        let newActive;
        if (this.focusRecentEditorAfterClose) {
          newActive = this.mru[1];
        } else {
          if (index === this.editors.length - 1) {
            newActive = this.editors[index - 1];
          } else {
            newActive = this.editors[index + 1];
          }
        }
        this.doSetActive(newActive, this.editors.indexOf(newActive));
      } else {
        this.active = null;
      }
    }
    if (this.matches(this.preview, editor)) {
      this.preview = null;
    }
    this.splice(index, true);
    return { editor, sticky, editorIndex: index, context };
  }
  moveEditor(candidate, toIndex) {
    if (toIndex >= this.editors.length) {
      toIndex = this.editors.length - 1;
    } else if (toIndex < 0) {
      toIndex = 0;
    }
    const index = this.indexOf(candidate);
    if (index < 0 || toIndex === index) {
      return;
    }
    const editor = this.editors[index];
    const sticky = this.sticky;
    if (this.isSticky(index) && toIndex > this.sticky) {
      this.sticky--;
    } else if (!this.isSticky(index) && toIndex <= this.sticky) {
      this.sticky++;
    }
    this.editors.splice(index, 1);
    this.editors.splice(toIndex, 0, editor);
    const event = {
      kind: 5,
      editor,
      oldEditorIndex: index,
      editorIndex: toIndex
    };
    this._onDidModelChange.fire(event);
    if (sticky !== this.sticky) {
      const event2 = {
        kind: 10,
        editor,
        editorIndex: toIndex
      };
      this._onDidModelChange.fire(event2);
    }
    return editor;
  }
  setActive(candidate) {
    let result = void 0;
    if (!candidate) {
      this.setGroupActive();
    } else {
      result = this.setEditorActive(candidate);
    }
    return result;
  }
  setGroupActive() {
    this._onDidModelChange.fire({ kind: 0 });
  }
  setEditorActive(candidate) {
    const res = this.findEditor(candidate);
    if (!res) {
      return;
    }
    const [editor, editorIndex] = res;
    this.doSetActive(editor, editorIndex);
    return editor;
  }
  doSetActive(editor, editorIndex) {
    if (this.matches(this.active, editor)) {
      return;
    }
    this.active = editor;
    const mruIndex = this.indexOf(editor, this.mru);
    this.mru.splice(mruIndex, 1);
    this.mru.unshift(editor);
    const event = {
      kind: 6,
      editor,
      editorIndex
    };
    this._onDidModelChange.fire(event);
  }
  setIndex(index) {
    this._onDidModelChange.fire({ kind: 1 });
  }
  pin(candidate) {
    const res = this.findEditor(candidate);
    if (!res) {
      return;
    }
    const [editor, editorIndex] = res;
    this.doPin(editor, editorIndex);
    return editor;
  }
  doPin(editor, editorIndex) {
    if (this.isPinned(editor)) {
      return;
    }
    this.preview = null;
    const event = {
      kind: 9,
      editor,
      editorIndex
    };
    this._onDidModelChange.fire(event);
  }
  unpin(candidate) {
    const res = this.findEditor(candidate);
    if (!res) {
      return;
    }
    const [editor, editorIndex] = res;
    this.doUnpin(editor, editorIndex);
    return editor;
  }
  doUnpin(editor, editorIndex) {
    if (!this.isPinned(editor)) {
      return;
    }
    const oldPreview = this.preview;
    this.preview = editor;
    const event = {
      kind: 9,
      editor,
      editorIndex
    };
    this._onDidModelChange.fire(event);
    if (oldPreview) {
      this.closeEditor(oldPreview, EditorCloseContext.UNPIN);
    }
  }
  isPinned(editorOrIndex) {
    let editor;
    if (typeof editorOrIndex === "number") {
      editor = this.editors[editorOrIndex];
    } else {
      editor = editorOrIndex;
    }
    return !this.matches(this.preview, editor);
  }
  stick(candidate) {
    const res = this.findEditor(candidate);
    if (!res) {
      return;
    }
    const [editor, editorIndex] = res;
    this.doStick(editor, editorIndex);
    return editor;
  }
  doStick(editor, editorIndex) {
    if (this.isSticky(editorIndex)) {
      return;
    }
    this.pin(editor);
    const newEditorIndex = this.sticky + 1;
    this.moveEditor(editor, newEditorIndex);
    this.sticky++;
    const event = {
      kind: 10,
      editor,
      editorIndex: newEditorIndex
    };
    this._onDidModelChange.fire(event);
  }
  unstick(candidate) {
    const res = this.findEditor(candidate);
    if (!res) {
      return;
    }
    const [editor, editorIndex] = res;
    this.doUnstick(editor, editorIndex);
    return editor;
  }
  doUnstick(editor, editorIndex) {
    if (!this.isSticky(editorIndex)) {
      return;
    }
    const newEditorIndex = this.sticky;
    this.moveEditor(editor, newEditorIndex);
    this.sticky--;
    const event = {
      kind: 10,
      editor,
      editorIndex: newEditorIndex
    };
    this._onDidModelChange.fire(event);
  }
  isSticky(candidateOrIndex) {
    if (this.sticky < 0) {
      return false;
    }
    let index;
    if (typeof candidateOrIndex === "number") {
      index = candidateOrIndex;
    } else {
      index = this.indexOf(candidateOrIndex);
    }
    if (index < 0) {
      return false;
    }
    return index <= this.sticky;
  }
  splice(index, del, editor) {
    const editorToDeleteOrReplace = this.editors[index];
    if (del && this.isSticky(index)) {
      this.sticky--;
    }
    if (editor) {
      this.editors.splice(index, del ? 1 : 0, editor);
    } else {
      this.editors.splice(index, del ? 1 : 0);
    }
    {
      if (!del && editor) {
        if (this.mru.length === 0) {
          this.mru.push(editor);
        } else {
          this.mru.splice(1, 0, editor);
        }
      } else {
        const indexInMRU = this.indexOf(editorToDeleteOrReplace, this.mru);
        if (del && !editor) {
          this.mru.splice(indexInMRU, 1);
        } else if (del && editor) {
          this.mru.splice(indexInMRU, 1, editor);
        }
      }
    }
  }
  indexOf(candidate, editors = this.editors, options) {
    let index = -1;
    if (!candidate) {
      return index;
    }
    for (let i = 0; i < editors.length; i++) {
      const editor = editors[i];
      if (this.matches(editor, candidate, options)) {
        if ((options == null ? void 0 : options.supportSideBySide) && editor instanceof SideBySideEditorInput && !(candidate instanceof SideBySideEditorInput)) {
          index = i;
        } else {
          index = i;
          break;
        }
      }
    }
    return index;
  }
  findEditor(candidate, options) {
    const index = this.indexOf(candidate, this.editors, options);
    if (index === -1) {
      return void 0;
    }
    return [this.editors[index], index];
  }
  isFirst(candidate) {
    return this.matches(this.editors[0], candidate);
  }
  isLast(candidate) {
    return this.matches(this.editors[this.editors.length - 1], candidate);
  }
  contains(candidate, options) {
    return this.indexOf(candidate, this.editors, options) !== -1;
  }
  matches(editor, candidate, options) {
    if (!editor || !candidate) {
      return false;
    }
    if ((options == null ? void 0 : options.supportSideBySide) && editor instanceof SideBySideEditorInput && !(candidate instanceof SideBySideEditorInput)) {
      switch (options.supportSideBySide) {
        case SideBySideEditor.ANY:
          if (this.matches(editor.primary, candidate, options) || this.matches(editor.secondary, candidate, options)) {
            return true;
          }
          break;
        case SideBySideEditor.BOTH:
          if (this.matches(editor.primary, candidate, options) && this.matches(editor.secondary, candidate, options)) {
            return true;
          }
          break;
      }
    }
    const strictEquals = editor === candidate;
    if (options == null ? void 0 : options.strictEquals) {
      return strictEquals;
    }
    return strictEquals || editor.matches(candidate);
  }
  get isLocked() {
    return this.locked;
  }
  lock(locked) {
    if (this.isLocked !== locked) {
      this.locked = locked;
      this._onDidModelChange.fire({ kind: 2 });
    }
  }
  clone() {
    const clone = this.instantiationService.createInstance(EditorGroupModel_1, void 0);
    clone.editors = this.editors.slice(0);
    clone.mru = this.mru.slice(0);
    clone.preview = this.preview;
    clone.active = this.active;
    clone.sticky = this.sticky;
    for (const editor of clone.editors) {
      clone.registerEditorListeners(editor);
    }
    return clone;
  }
  serialize() {
    const registry = Registry.as(EditorExtensions.EditorFactory);
    const serializableEditors = [];
    const serializedEditors = [];
    let serializablePreviewIndex;
    let serializableSticky = this.sticky;
    for (let i = 0; i < this.editors.length; i++) {
      const editor = this.editors[i];
      let canSerializeEditor = false;
      const editorSerializer = registry.getEditorSerializer(editor);
      if (editorSerializer) {
        const value = editorSerializer.serialize(editor);
        if (typeof value === "string") {
          canSerializeEditor = true;
          serializedEditors.push({ id: editor.typeId, value });
          serializableEditors.push(editor);
          if (this.preview === editor) {
            serializablePreviewIndex = serializableEditors.length - 1;
          }
        } else {
          canSerializeEditor = false;
        }
      }
      if (!canSerializeEditor && this.isSticky(i)) {
        serializableSticky--;
      }
    }
    const serializableMru = this.mru.map((editor) => this.indexOf(editor, serializableEditors)).filter((i) => i >= 0);
    return {
      id: this.id,
      locked: this.locked ? true : void 0,
      editors: serializedEditors,
      mru: serializableMru,
      preview: serializablePreviewIndex,
      sticky: serializableSticky >= 0 ? serializableSticky : void 0
    };
  }
  deserialize(data) {
    const registry = Registry.as(EditorExtensions.EditorFactory);
    if (typeof data.id === "number") {
      this._id = data.id;
      EditorGroupModel_1.IDS = Math.max(data.id + 1, EditorGroupModel_1.IDS);
    } else {
      this._id = EditorGroupModel_1.IDS++;
    }
    if (data.locked) {
      this.locked = true;
    }
    this.editors = coalesce(data.editors.map((e, index) => {
      let editor = void 0;
      const editorSerializer = registry.getEditorSerializer(e.id);
      if (editorSerializer) {
        const deserializedEditor = editorSerializer.deserialize(this.instantiationService, e.value);
        if (deserializedEditor instanceof EditorInput) {
          editor = deserializedEditor;
          this.registerEditorListeners(editor);
        }
      }
      if (!editor && typeof data.sticky === "number" && index <= data.sticky) {
        data.sticky--;
      }
      return editor;
    }));
    this.mru = coalesce(data.mru.map((i) => this.editors[i]));
    this.active = this.mru[0];
    if (typeof data.preview === "number") {
      this.preview = this.editors[data.preview];
    }
    if (typeof data.sticky === "number") {
      this.sticky = data.sticky;
    }
    return this._id;
  }
  dispose() {
    dispose(Array.from(this.editorListeners));
    this.editorListeners.clear();
    super.dispose();
  }
}, EditorGroupModel_1 = _a16, _a16.IDS = 0, _a16);
EditorGroupModel = EditorGroupModel_1 = __decorate([
  __param(1, IInstantiationService),
  __param(2, IConfigurationService)
], EditorGroupModel);

// node_modules/vscode/vscode/src/vs/workbench/contrib/interactive/browser/interactiveEditorInput.js
init_tslib_es6();
init_event();
init_path();
init_resources();
init_modesRegistry();
init_resolverService();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/contrib/interactive/browser/interactiveHistoryService.js
init_instantiation();
var IInteractiveHistoryService = createDecorator("IInteractiveHistoryService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/interactive/browser/interactiveEditorInput.js
var InteractiveEditorInput_1;
var _a17;
var InteractiveEditorInput = (_a17 = class extends EditorInput {
  static create(instantiationService, resource, inputResource, title, language2) {
    return instantiationService.createInstance(InteractiveEditorInput_1, resource, inputResource, title, language2);
  }
  static setName(notebookUri, title) {
    if (title) {
      this.windowNames[notebookUri.path] = title;
    }
  }
  get editorId() {
    return "interactive";
  }
  get typeId() {
    return InteractiveEditorInput_1.ID;
  }
  get language() {
    var _a30;
    return ((_a30 = this._inputModelRef) == null ? void 0 : _a30.object.textEditorModel.getLanguageId()) ?? this._initLanguage;
  }
  get notebookEditorInput() {
    return this._notebookEditorInput;
  }
  get editorInputs() {
    return [this._notebookEditorInput];
  }
  get resource() {
    return this._resource;
  }
  get inputResource() {
    return this._inputResource;
  }
  get primary() {
    return this._notebookEditorInput;
  }
  constructor(resource, inputResource, title, languageId, instantiationService, textModelService, interactiveDocumentService, historyService, _notebookService, _fileDialogService) {
    const input = NotebookEditorInput.create(instantiationService, resource, "interactive", {});
    super();
    this._notebookService = _notebookService;
    this._fileDialogService = _fileDialogService;
    this._notebookEditorInput = input;
    this._register(this._notebookEditorInput);
    this.name = title ?? InteractiveEditorInput_1.windowNames[resource.path] ?? basename(resource.path, extname(resource.path));
    this._initLanguage = languageId;
    this._resource = resource;
    this._inputResource = inputResource;
    this._inputResolver = null;
    this._editorModelReference = null;
    this._inputModelRef = null;
    this._textModelService = textModelService;
    this._interactiveDocumentService = interactiveDocumentService;
    this._historyService = historyService;
    this._registerListeners();
  }
  _registerListeners() {
    const oncePrimaryDisposed = Event.once(this.primary.onWillDispose);
    this._register(oncePrimaryDisposed(() => {
      if (!this.isDisposed()) {
        this.dispose();
      }
    }));
    this._register(this.primary.onDidChangeDirty(() => this._onDidChangeDirty.fire()));
    this._register(this.primary.onDidChangeLabel(() => this._onDidChangeLabel.fire()));
    this._register(this.primary.onDidChangeCapabilities(() => this._onDidChangeCapabilities.fire()));
  }
  get capabilities() {
    return 4 | 2 | 512;
  }
  async _resolveEditorModel() {
    if (!this._editorModelReference) {
      this._editorModelReference = await this._notebookEditorInput.resolve();
    }
    return this._editorModelReference;
  }
  async resolve() {
    if (this._editorModelReference) {
      return this._editorModelReference;
    }
    if (this._inputResolver) {
      return this._inputResolver;
    }
    this._inputResolver = this._resolveEditorModel();
    return this._inputResolver;
  }
  async resolveInput(language2) {
    if (this._inputModelRef) {
      return this._inputModelRef.object.textEditorModel;
    }
    const resolvedLanguage = language2 ?? this._initLanguage ?? PLAINTEXT_LANGUAGE_ID;
    this._interactiveDocumentService.willCreateInteractiveDocument(this.resource, this.inputResource, resolvedLanguage);
    this._inputModelRef = await this._textModelService.createModelReference(this.inputResource);
    return this._inputModelRef.object.textEditorModel;
  }
  async save(group, options) {
    if (this._editorModelReference) {
      if (this.hasCapability(4)) {
        return this.saveAs(group, options);
      } else {
        await this._editorModelReference.save(options);
      }
      return this;
    }
    return void 0;
  }
  async saveAs(group, options) {
    if (!this._editorModelReference) {
      return void 0;
    }
    const provider = this._notebookService.getContributedNotebookType("interactive");
    if (!provider) {
      return void 0;
    }
    const filename = this.getName() + ".ipynb";
    const pathCandidate = joinPath(await this._fileDialogService.defaultFilePath(), filename);
    const target = await this._fileDialogService.pickFileToSave(pathCandidate, options == null ? void 0 : options.availableFileSystems);
    if (!target) {
      return void 0;
    }
    return await this._editorModelReference.saveAs(target);
  }
  matches(otherInput) {
    if (super.matches(otherInput)) {
      return true;
    }
    if (otherInput instanceof InteractiveEditorInput_1) {
      return isEqual(this.resource, otherInput.resource) && isEqual(this.inputResource, otherInput.inputResource);
    }
    return false;
  }
  getName() {
    return this.name;
  }
  isModified() {
    var _a30;
    return ((_a30 = this._editorModelReference) == null ? void 0 : _a30.isModified()) ?? false;
  }
  dispose() {
    var _a30, _b, _c, _d;
    (_a30 = this._editorModelReference) == null ? void 0 : _a30.revert({ soft: true });
    (_b = this._notebookEditorInput) == null ? void 0 : _b.dispose();
    (_c = this._editorModelReference) == null ? void 0 : _c.dispose();
    this._editorModelReference = null;
    this._interactiveDocumentService.willRemoveInteractiveDocument(this.resource, this.inputResource);
    (_d = this._inputModelRef) == null ? void 0 : _d.dispose();
    this._inputModelRef = null;
    super.dispose();
  }
  get historyService() {
    return this._historyService;
  }
}, InteractiveEditorInput_1 = _a17, _a17.windowNames = {}, _a17.ID = "workbench.input.interactive", _a17);
InteractiveEditorInput = InteractiveEditorInput_1 = __decorate([
  __param(4, IInstantiationService),
  __param(5, ITextModelService),
  __param(6, IInteractiveDocumentService),
  __param(7, IInteractiveHistoryService),
  __param(8, INotebookService),
  __param(9, IFileDialogService)
], InteractiveEditorInput);

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/mergeEditorInput.js
init_tslib_es6();
init_assert();
init_resources();
init_types();
init_nls();
init_configuration();
init_files();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/mergeEditorInputModel.js
init_tslib_es6();
init_assert();
init_errors();
init_event();
init_lifecycle();
init_resources();
init_model2();
init_resolverService();
init_nls();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/mergeMarkers/mergeMarkersController.js
var conflictMarkers = {
  start: "<<<<<<<",
  end: ">>>>>>>"
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/diffComputer.js
init_tslib_es6();
init_assert();
init_editorWorker();
init_configuration();

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/lineRange.js
init_arrays();
init_errors();
init_range();
var _LineRange = class _LineRange {
  static join(ranges) {
    if (ranges.length === 0) {
      return void 0;
    }
    let startLineNumber = Number.MAX_SAFE_INTEGER;
    let endLineNumber = 0;
    for (const range of ranges) {
      startLineNumber = Math.min(startLineNumber, range.startLineNumber);
      endLineNumber = Math.max(endLineNumber, range.startLineNumber + range.lineCount);
    }
    return new _LineRange(startLineNumber, endLineNumber - startLineNumber);
  }
  static fromLineNumbers(startLineNumber, endExclusiveLineNumber) {
    return new _LineRange(startLineNumber, endExclusiveLineNumber - startLineNumber);
  }
  constructor(startLineNumber, lineCount) {
    this.startLineNumber = startLineNumber;
    this.lineCount = lineCount;
    if (lineCount < 0) {
      throw new BugIndicatingError();
    }
  }
  join(other) {
    return new _LineRange(
      Math.min(this.startLineNumber, other.startLineNumber),
      Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive) - this.startLineNumber
    );
  }
  get endLineNumberExclusive() {
    return this.startLineNumber + this.lineCount;
  }
  get isEmpty() {
    return this.lineCount === 0;
  }
  touches(other) {
    return this.endLineNumberExclusive >= other.startLineNumber && other.endLineNumberExclusive >= this.startLineNumber;
  }
  isAfter(range) {
    return this.startLineNumber >= range.endLineNumberExclusive;
  }
  isBefore(range) {
    return range.startLineNumber >= this.endLineNumberExclusive;
  }
  delta(lineDelta) {
    return new _LineRange(this.startLineNumber + lineDelta, this.lineCount);
  }
  toString() {
    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
  }
  equals(originalRange) {
    return this.startLineNumber === originalRange.startLineNumber && this.lineCount === originalRange.lineCount;
  }
  contains(lineNumber) {
    return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
  }
  deltaEnd(delta3) {
    return new _LineRange(this.startLineNumber, this.lineCount + delta3);
  }
  deltaStart(lineDelta) {
    return new _LineRange(this.startLineNumber + lineDelta, this.lineCount - lineDelta);
  }
  getLines(model) {
    const result = new Array(this.lineCount);
    for (let i = 0; i < this.lineCount; i++) {
      result[i] = model.getLineContent(this.startLineNumber + i);
    }
    return result;
  }
  containsRange(range) {
    return this.startLineNumber <= range.startLineNumber && range.endLineNumberExclusive <= this.endLineNumberExclusive;
  }
  toRange() {
    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
  }
  toInclusiveRange() {
    if (this.isEmpty) {
      return void 0;
    }
    return new Range(
      this.startLineNumber,
      1,
      this.endLineNumberExclusive - 1,
      1073741824
    );
  }
  toInclusiveRangeOrEmpty() {
    if (this.isEmpty) {
      return new Range(this.startLineNumber, 1, this.startLineNumber, 1);
    }
    return new Range(
      this.startLineNumber,
      1,
      this.endLineNumberExclusive - 1,
      1073741824
    );
  }
  intersects(lineRange) {
    return this.startLineNumber <= lineRange.endLineNumberExclusive && lineRange.startLineNumber <= this.endLineNumberExclusive;
  }
};
_LineRange.compareByStart = compareBy((l) => l.startLineNumber, numberComparator);
var LineRange = _LineRange;

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/mapping.js
init_arrays();
init_assert();
init_errors();
init_range();

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/utils.js
init_arrays();
init_errors();
var ReentrancyBarrier = class {
  constructor() {
    this._isActive = false;
  }
  get isActive() {
    return this._isActive;
  }
  makeExclusive(fn) {
    return (...args) => {
      if (this._isActive) {
        return;
      }
      this._isActive = true;
      try {
        return fn(...args);
      } finally {
        this._isActive = false;
      }
    };
  }
  runExclusively(fn) {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    try {
      fn();
    } finally {
      this._isActive = false;
    }
  }
  runExclusivelyOrThrow(fn) {
    if (this._isActive) {
      throw new BugIndicatingError();
    }
    this._isActive = true;
    try {
      fn();
    } finally {
      this._isActive = false;
    }
  }
};
function* leftJoin(left, right, compare2) {
  const rightQueue = new ArrayQueue(right);
  for (const leftElement of left) {
    rightQueue.takeWhile((rightElement) => CompareResult.isGreaterThan(compare2(leftElement, rightElement)));
    const equals3 = rightQueue.takeWhile((rightElement) => CompareResult.isNeitherLessOrGreaterThan(compare2(leftElement, rightElement)));
    yield { left: leftElement, rights: equals3 || [] };
  }
}
function concatArrays(...arrays) {
  return [].concat(...arrays);
}
function observableConfigValue(key, defaultValue, configurationService) {
  return observableFromEvent((handleChange) => configurationService.onDidChangeConfiguration((e) => {
    if (e.affectsConfiguration(key)) {
      handleChange(e);
    }
  }), () => configurationService.getValue(key) ?? defaultValue);
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/editing.js
init_arrays();
init_range();
var LineRangeEdit = class {
  constructor(range, newLines) {
    this.range = range;
    this.newLines = newLines;
  }
  equals(other) {
    return this.range.equals(other.range) && equals(this.newLines, other.newLines);
  }
  toEdits(modelLineCount) {
    return new LineEdits([this]).toEdits(modelLineCount);
  }
};
var RangeEdit = class {
  constructor(range, newText) {
    this.range = range;
    this.newText = newText;
  }
  equals(other) {
    return Range.equalsRange(this.range, other.range) && this.newText === other.newText;
  }
};
var LineEdits = class {
  constructor(edits) {
    this.edits = edits;
  }
  toEdits(modelLineCount) {
    return this.edits.map((e) => {
      if (e.range.endLineNumberExclusive <= modelLineCount) {
        return {
          range: new Range(e.range.startLineNumber, 1, e.range.endLineNumberExclusive, 1),
          text: e.newLines.map((s) => s + "\n").join("")
        };
      }
      if (e.range.startLineNumber === 1) {
        return {
          range: new Range(1, 1, modelLineCount, Number.MAX_SAFE_INTEGER),
          text: e.newLines.join("\n")
        };
      }
      return {
        range: new Range(
          e.range.startLineNumber - 1,
          Number.MAX_SAFE_INTEGER,
          modelLineCount,
          Number.MAX_SAFE_INTEGER
        ),
        text: e.newLines.map((s) => "\n" + s).join("")
      };
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/rangeUtils.js
init_position();
init_length();
function rangeContainsPosition(range, position) {
  if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
    return false;
  }
  if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
    return false;
  }
  if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
    return false;
  }
  return true;
}
function lengthBetweenPositions(position1, position2) {
  if (position1.lineNumber === position2.lineNumber) {
    return new LengthObj(0, position2.column - position1.column);
  } else {
    return new LengthObj(position2.lineNumber - position1.lineNumber, position2.column - 1);
  }
}
function addLength(position, length) {
  if (length.lineCount === 0) {
    return new Position(position.lineNumber, position.column + length.columnCount);
  } else {
    return new Position(position.lineNumber + length.lineCount, length.columnCount + 1);
  }
}
function rangeIsBeforeOrTouching(range, other) {
  return range.endLineNumber < other.startLineNumber || range.endLineNumber === other.startLineNumber && range.endColumn <= other.startColumn;
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/mapping.js
var LineRangeMapping = class _LineRangeMapping {
  static join(mappings) {
    return mappings.reduce((acc, cur) => acc ? acc.join(cur) : cur, void 0);
  }
  constructor(inputRange, outputRange) {
    this.inputRange = inputRange;
    this.outputRange = outputRange;
  }
  extendInputRange(extendedInputRange) {
    if (!extendedInputRange.containsRange(this.inputRange)) {
      throw new BugIndicatingError();
    }
    const startDelta = extendedInputRange.startLineNumber - this.inputRange.startLineNumber;
    const endDelta = extendedInputRange.endLineNumberExclusive - this.inputRange.endLineNumberExclusive;
    return new _LineRangeMapping(extendedInputRange, new LineRange(
      this.outputRange.startLineNumber + startDelta,
      this.outputRange.lineCount - startDelta + endDelta
    ));
  }
  join(other) {
    return new _LineRangeMapping(
      this.inputRange.join(other.inputRange),
      this.outputRange.join(other.outputRange)
    );
  }
  get resultingDeltaFromOriginalToModified() {
    return this.outputRange.endLineNumberExclusive - this.inputRange.endLineNumberExclusive;
  }
  toString() {
    return `${this.inputRange.toString()} -> ${this.outputRange.toString()}`;
  }
  addOutputLineDelta(delta3) {
    return new _LineRangeMapping(this.inputRange, this.outputRange.delta(delta3));
  }
  addInputLineDelta(delta3) {
    return new _LineRangeMapping(this.inputRange.delta(delta3), this.outputRange);
  }
  reverse() {
    return new _LineRangeMapping(this.outputRange, this.inputRange);
  }
};
var DocumentLineRangeMap = class _DocumentLineRangeMap {
  static betweenOutputs(inputToOutput1, inputToOutput2, inputLineCount) {
    const alignments = MappingAlignment.compute(inputToOutput1, inputToOutput2);
    const mappings = alignments.map(
      (m) => new LineRangeMapping(m.output1Range, m.output2Range)
    );
    return new _DocumentLineRangeMap(mappings, inputLineCount);
  }
  constructor(lineRangeMappings, inputLineCount) {
    this.lineRangeMappings = lineRangeMappings;
    this.inputLineCount = inputLineCount;
    assertFn(() => {
      return checkAdjacentItems(lineRangeMappings, (m1, m2) => m1.inputRange.isBefore(m2.inputRange) && m1.outputRange.isBefore(m2.outputRange) && m2.inputRange.startLineNumber - m1.inputRange.endLineNumberExclusive === m2.outputRange.startLineNumber - m1.outputRange.endLineNumberExclusive);
    });
  }
  project(lineNumber) {
    const lastBefore = findLast(this.lineRangeMappings, (r) => r.inputRange.startLineNumber <= lineNumber);
    if (!lastBefore) {
      return new LineRangeMapping(
        new LineRange(lineNumber, 1),
        new LineRange(lineNumber, 1)
      );
    }
    if (lastBefore.inputRange.contains(lineNumber)) {
      return lastBefore;
    }
    const containingRange = new LineRange(lineNumber, 1);
    const mappedRange = new LineRange(lineNumber + lastBefore.outputRange.endLineNumberExclusive - lastBefore.inputRange.endLineNumberExclusive, 1);
    return new LineRangeMapping(containingRange, mappedRange);
  }
  get outputLineCount() {
    const last = lastOrDefault(this.lineRangeMappings);
    const diff = last ? last.outputRange.endLineNumberExclusive - last.inputRange.endLineNumberExclusive : 0;
    return this.inputLineCount + diff;
  }
  reverse() {
    return new _DocumentLineRangeMap(
      this.lineRangeMappings.map((r) => r.reverse()),
      this.outputLineCount
    );
  }
};
var MappingAlignment = class _MappingAlignment {
  static compute(fromInputToOutput1, fromInputToOutput2) {
    const compareByStartLineNumber = compareBy((d) => d.inputRange.startLineNumber, numberComparator);
    const combinedDiffs = concatArrays(fromInputToOutput1.map((diff) => ({ source: 0, diff })), fromInputToOutput2.map((diff) => ({ source: 1, diff }))).sort(compareBy((d) => d.diff, compareByStartLineNumber));
    const currentDiffs = [new Array(), new Array()];
    const deltaFromBaseToInput = [0, 0];
    const alignments = new Array();
    function pushAndReset(inputRange) {
      const mapping1 = LineRangeMapping.join(currentDiffs[0]) || new LineRangeMapping(inputRange, inputRange.delta(deltaFromBaseToInput[0]));
      const mapping2 = LineRangeMapping.join(currentDiffs[1]) || new LineRangeMapping(inputRange, inputRange.delta(deltaFromBaseToInput[1]));
      alignments.push(new _MappingAlignment(
        currentInputRange,
        mapping1.extendInputRange(currentInputRange).outputRange,
        currentDiffs[0],
        mapping2.extendInputRange(currentInputRange).outputRange,
        currentDiffs[1]
      ));
      currentDiffs[0] = [];
      currentDiffs[1] = [];
    }
    let currentInputRange;
    for (const diff of combinedDiffs) {
      const range = diff.diff.inputRange;
      if (currentInputRange && !currentInputRange.touches(range)) {
        pushAndReset(currentInputRange);
        currentInputRange = void 0;
      }
      deltaFromBaseToInput[diff.source] = diff.diff.resultingDeltaFromOriginalToModified;
      currentInputRange = currentInputRange ? currentInputRange.join(range) : range;
      currentDiffs[diff.source].push(diff.diff);
    }
    if (currentInputRange) {
      pushAndReset(currentInputRange);
    }
    return alignments;
  }
  constructor(inputRange, output1Range, output1LineMappings, output2Range, output2LineMappings) {
    this.inputRange = inputRange;
    this.output1Range = output1Range;
    this.output1LineMappings = output1LineMappings;
    this.output2Range = output2Range;
    this.output2LineMappings = output2LineMappings;
  }
  toString() {
    return `${this.output1Range} <- ${this.inputRange} -> ${this.output2Range}`;
  }
};
var DetailedLineRangeMapping = class _DetailedLineRangeMapping extends LineRangeMapping {
  static join(mappings) {
    return mappings.reduce((acc, cur) => acc ? acc.join(cur) : cur, void 0);
  }
  constructor(inputRange, inputTextModel, outputRange, outputTextModel, rangeMappings) {
    super(inputRange, outputRange);
    this.inputTextModel = inputTextModel;
    this.outputTextModel = outputTextModel;
    this.rangeMappings = rangeMappings || [new RangeMapping(this.inputRange.toRange(), this.outputRange.toRange())];
  }
  addOutputLineDelta(delta3) {
    return new _DetailedLineRangeMapping(
      this.inputRange,
      this.inputTextModel,
      this.outputRange.delta(delta3),
      this.outputTextModel,
      this.rangeMappings.map((d) => d.addOutputLineDelta(delta3))
    );
  }
  addInputLineDelta(delta3) {
    return new _DetailedLineRangeMapping(
      this.inputRange.delta(delta3),
      this.inputTextModel,
      this.outputRange,
      this.outputTextModel,
      this.rangeMappings.map((d) => d.addInputLineDelta(delta3))
    );
  }
  join(other) {
    return new _DetailedLineRangeMapping(
      this.inputRange.join(other.inputRange),
      this.inputTextModel,
      this.outputRange.join(other.outputRange),
      this.outputTextModel
    );
  }
  getLineEdit() {
    return new LineRangeEdit(this.inputRange, this.getOutputLines());
  }
  getReverseLineEdit() {
    return new LineRangeEdit(this.outputRange, this.getInputLines());
  }
  getOutputLines() {
    return this.outputRange.getLines(this.outputTextModel);
  }
  getInputLines() {
    return this.inputRange.getLines(this.inputTextModel);
  }
};
var RangeMapping = class _RangeMapping {
  constructor(inputRange, outputRange) {
    this.inputRange = inputRange;
    this.outputRange = outputRange;
  }
  toString() {
    function rangeToString(range) {
      return `[${range.startLineNumber}:${range.startColumn}, ${range.endLineNumber}:${range.endColumn})`;
    }
    return `${rangeToString(this.inputRange)} -> ${rangeToString(this.outputRange)}`;
  }
  addOutputLineDelta(deltaLines) {
    return new _RangeMapping(this.inputRange, new Range(
      this.outputRange.startLineNumber + deltaLines,
      this.outputRange.startColumn,
      this.outputRange.endLineNumber + deltaLines,
      this.outputRange.endColumn
    ));
  }
  addInputLineDelta(deltaLines) {
    return new _RangeMapping(new Range(
      this.inputRange.startLineNumber + deltaLines,
      this.inputRange.startColumn,
      this.inputRange.endLineNumber + deltaLines,
      this.inputRange.endColumn
    ), this.outputRange);
  }
  reverse() {
    return new _RangeMapping(this.outputRange, this.inputRange);
  }
};
var DocumentRangeMap = class _DocumentRangeMap {
  constructor(rangeMappings, inputLineCount) {
    this.rangeMappings = rangeMappings;
    this.inputLineCount = inputLineCount;
    assertFn(() => checkAdjacentItems(
      rangeMappings,
      (m1, m2) => rangeIsBeforeOrTouching(m1.inputRange, m2.inputRange) && rangeIsBeforeOrTouching(m1.outputRange, m2.outputRange)
    ));
  }
  project(position) {
    const lastBefore = findLast(this.rangeMappings, (r) => r.inputRange.getStartPosition().isBeforeOrEqual(position));
    if (!lastBefore) {
      return new RangeMapping(
        Range.fromPositions(position, position),
        Range.fromPositions(position, position)
      );
    }
    if (rangeContainsPosition(lastBefore.inputRange, position)) {
      return lastBefore;
    }
    const dist = lengthBetweenPositions(lastBefore.inputRange.getEndPosition(), position);
    const outputPos = addLength(lastBefore.outputRange.getEndPosition(), dist);
    return new RangeMapping(Range.fromPositions(position), Range.fromPositions(outputPos));
  }
  projectRange(range) {
    const start = this.project(range.getStartPosition());
    const end = this.project(range.getEndPosition());
    return new RangeMapping(
      start.inputRange.plusRange(end.inputRange),
      start.outputRange.plusRange(end.outputRange)
    );
  }
  get outputLineCount() {
    const last = lastOrDefault(this.rangeMappings);
    const diff = last ? last.outputRange.endLineNumber - last.inputRange.endLineNumber : 0;
    return this.inputLineCount + diff;
  }
  reverse() {
    return new _DocumentRangeMap(
      this.rangeMappings.map((m) => m.reverse()),
      this.outputLineCount
    );
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/diffComputer.js
var MergeDiffComputer = class MergeDiffComputer2 {
  constructor(editorWorkerService, configurationService) {
    this.editorWorkerService = editorWorkerService;
    this.configurationService = configurationService;
    this.mergeAlgorithm = observableConfigValue("mergeEditor.diffAlgorithm", "advanced", this.configurationService).map((v) => v === "smart" ? "legacy" : v === "experimental" ? "advanced" : v);
  }
  async computeDiff(textModel1, textModel2, reader) {
    const diffAlgorithm = this.mergeAlgorithm.read(reader);
    const result = await this.editorWorkerService.computeDiff(textModel1.uri, textModel2.uri, {
      ignoreTrimWhitespace: false,
      maxComputationTimeMs: 0,
      computeMoves: false
    }, diffAlgorithm);
    if (!result) {
      throw new Error("Diff computation failed");
    }
    if (textModel1.isDisposed() || textModel2.isDisposed()) {
      return { diffs: null };
    }
    const changes = result.changes.map((c) => {
      var _a30;
      return new DetailedLineRangeMapping(
        toLineRange(c.originalRange),
        textModel1,
        toLineRange(c.modifiedRange),
        textModel2,
        (_a30 = c.innerChanges) == null ? void 0 : _a30.map((ic) => toRangeMapping(ic))
      );
    });
    assertFn(() => {
      for (const c of changes) {
        const inputRange = c.inputRange;
        const outputRange = c.outputRange;
        const inputTextModel = c.inputTextModel;
        const outputTextModel = c.outputTextModel;
        for (const map of c.rangeMappings) {
          let inputRangesValid = inputRange.startLineNumber - 1 <= map.inputRange.startLineNumber && map.inputRange.endLineNumber <= inputRange.endLineNumberExclusive;
          if (inputRangesValid && map.inputRange.startLineNumber === inputRange.startLineNumber - 1) {
            inputRangesValid = map.inputRange.endColumn >= inputTextModel.getLineMaxColumn(map.inputRange.startLineNumber);
          }
          if (inputRangesValid && map.inputRange.endLineNumber === inputRange.endLineNumberExclusive) {
            inputRangesValid = map.inputRange.endColumn === 1;
          }
          let outputRangesValid = outputRange.startLineNumber - 1 <= map.outputRange.startLineNumber && map.outputRange.endLineNumber <= outputRange.endLineNumberExclusive;
          if (outputRangesValid && map.outputRange.startLineNumber === outputRange.startLineNumber - 1) {
            outputRangesValid = map.outputRange.endColumn >= outputTextModel.getLineMaxColumn(map.outputRange.endLineNumber);
          }
          if (outputRangesValid && map.outputRange.endLineNumber === outputRange.endLineNumberExclusive) {
            outputRangesValid = map.outputRange.endColumn === 1;
          }
          if (!inputRangesValid || !outputRangesValid) {
            return false;
          }
        }
      }
      return changes.length === 0 || changes[0].inputRange.startLineNumber === changes[0].outputRange.startLineNumber && checkAdjacentItems(changes, (m1, m2) => m2.inputRange.startLineNumber - m1.inputRange.endLineNumberExclusive === m2.outputRange.startLineNumber - m1.outputRange.endLineNumberExclusive && m1.inputRange.endLineNumberExclusive < m2.inputRange.startLineNumber && m1.outputRange.endLineNumberExclusive < m2.outputRange.startLineNumber);
    });
    return {
      diffs: changes
    };
  }
};
MergeDiffComputer = __decorate([
  __param(0, IEditorWorkerService),
  __param(1, IConfigurationService)
], MergeDiffComputer);
function toLineRange(range) {
  return new LineRange(range.startLineNumber, range.length);
}
function toRangeMapping(mapping) {
  return new RangeMapping(mapping.originalRange, mapping.modifiedRange);
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/mergeEditorModel.js
init_tslib_es6();
init_arrays();
init_errors();
init_range();
init_language();
init_nls();
init_undoRedo();

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/textModelDiffs.js
init_arrays();
init_errors();
init_lifecycle();
var TextModelDiffs = class extends Disposable {
  get isApplyingChange() {
    return this.barrier.isActive;
  }
  constructor(baseTextModel, textModel, diffComputer) {
    super();
    this.baseTextModel = baseTextModel;
    this.textModel = textModel;
    this.diffComputer = diffComputer;
    this.recomputeCount = 0;
    this._state = observableValue("LiveDiffState", 1);
    this._diffs = observableValue("LiveDiffs", []);
    this.barrier = new ReentrancyBarrier();
    this.isDisposed = false;
    this.isInitializing = true;
    const recomputeSignal = observableSignal("recompute");
    this._register(autorun((reader) => {
      recomputeSignal.read(reader);
      this.recompute(reader);
    }));
    this._register(baseTextModel.onDidChangeContent(this.barrier.makeExclusive(() => {
      recomputeSignal.trigger(void 0);
    })));
    this._register(textModel.onDidChangeContent(this.barrier.makeExclusive(() => {
      recomputeSignal.trigger(void 0);
    })));
    this._register(toDisposable(() => {
      this.isDisposed = true;
    }));
  }
  get state() {
    return this._state;
  }
  get diffs() {
    return this._diffs;
  }
  recompute(reader) {
    this.recomputeCount++;
    const currentRecomputeIdx = this.recomputeCount;
    if (this._state.get() === 1) {
      this.isInitializing = true;
    }
    transaction((tx) => {
      this._state.set(this.isInitializing ? 1 : 3, tx, 0);
    });
    const result = this.diffComputer.computeDiff(this.baseTextModel, this.textModel, reader);
    result.then((result2) => {
      if (this.isDisposed) {
        return;
      }
      if (currentRecomputeIdx !== this.recomputeCount) {
        return;
      }
      transaction((tx) => {
        if (result2.diffs) {
          this._state.set(2, tx, 1);
          this._diffs.set(result2.diffs, tx, 1);
        } else {
          this._state.set(4, tx, 1);
        }
        this.isInitializing = false;
      });
    });
  }
  ensureUpToDate() {
    if (this.state.get() !== 2) {
      throw new BugIndicatingError("Cannot remove diffs when the model is not up to date");
    }
  }
  removeDiffs(diffToRemoves, transaction2, group) {
    this.ensureUpToDate();
    diffToRemoves.sort(compareBy((d) => d.inputRange.startLineNumber, numberComparator));
    diffToRemoves.reverse();
    let diffs = this._diffs.get();
    for (const diffToRemove of diffToRemoves) {
      const len = diffs.length;
      diffs = diffs.filter((d) => d !== diffToRemove);
      if (len === diffs.length) {
        throw new BugIndicatingError();
      }
      this.barrier.runExclusivelyOrThrow(() => {
        const edits = diffToRemove.getReverseLineEdit().toEdits(this.textModel.getLineCount());
        this.textModel.pushEditOperations(null, edits, () => null, group);
      });
      diffs = diffs.map((d) => d.outputRange.isAfter(diffToRemove.outputRange) ? d.addOutputLineDelta(diffToRemove.inputRange.lineCount - diffToRemove.outputRange.lineCount) : d);
    }
    this._diffs.set(diffs, transaction2, 0);
  }
  applyEditRelativeToOriginal(edit, transaction2, group) {
    this.ensureUpToDate();
    const editMapping = new DetailedLineRangeMapping(edit.range, this.baseTextModel, new LineRange(edit.range.startLineNumber, edit.newLines.length), this.textModel);
    let firstAfter = false;
    let delta3 = 0;
    const newDiffs = new Array();
    for (const diff of this.diffs.get()) {
      if (diff.inputRange.touches(edit.range)) {
        throw new BugIndicatingError("Edit must be conflict free.");
      } else if (diff.inputRange.isAfter(edit.range)) {
        if (!firstAfter) {
          firstAfter = true;
          newDiffs.push(editMapping.addOutputLineDelta(delta3));
        }
        newDiffs.push(diff.addOutputLineDelta(edit.newLines.length - edit.range.lineCount));
      } else {
        newDiffs.push(diff);
      }
      if (!firstAfter) {
        delta3 += diff.outputRange.lineCount - diff.inputRange.lineCount;
      }
    }
    if (!firstAfter) {
      firstAfter = true;
      newDiffs.push(editMapping.addOutputLineDelta(delta3));
    }
    this.barrier.runExclusivelyOrThrow(() => {
      const edits = new LineRangeEdit(edit.range.delta(delta3), edit.newLines).toEdits(this.textModel.getLineCount());
      this.textModel.pushEditOperations(null, edits, () => null, group);
    });
    this._diffs.set(newDiffs, transaction2, 0);
  }
  findTouchingDiffs(baseRange) {
    return this.diffs.get().filter((d) => d.inputRange.touches(baseRange));
  }
  getResultLine(lineNumber, reader) {
    let offset = 0;
    const diffs = reader ? this.diffs.read(reader) : this.diffs.get();
    for (const diff of diffs) {
      if (diff.inputRange.contains(lineNumber) || diff.inputRange.endLineNumberExclusive === lineNumber) {
        return diff;
      } else if (diff.inputRange.endLineNumberExclusive < lineNumber) {
        offset = diff.resultingDeltaFromOriginalToModified;
      } else {
        break;
      }
    }
    return lineNumber + offset;
  }
  getResultLineRange(baseRange, reader) {
    let start = this.getResultLine(baseRange.startLineNumber, reader);
    if (typeof start !== "number") {
      start = start.outputRange.startLineNumber;
    }
    let endExclusive = this.getResultLine(baseRange.endLineNumberExclusive, reader);
    if (typeof endExclusive !== "number") {
      endExclusive = endExclusive.outputRange.endLineNumberExclusive;
    }
    return LineRange.fromLineNumbers(start, endExclusive);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/modifiedBaseRange.js
init_arrays();
init_errors();
init_strings();
init_position();
init_range();
var ModifiedBaseRange = class _ModifiedBaseRange {
  static fromDiffs(diffs1, diffs2, baseTextModel, input1TextModel, input2TextModel) {
    const alignments = MappingAlignment.compute(diffs1, diffs2);
    return alignments.map((a) => new _ModifiedBaseRange(
      a.inputRange,
      baseTextModel,
      a.output1Range,
      input1TextModel,
      a.output1LineMappings,
      a.output2Range,
      input2TextModel,
      a.output2LineMappings
    ));
  }
  constructor(baseRange, baseTextModel, input1Range, input1TextModel, input1Diffs, input2Range, input2TextModel, input2Diffs) {
    this.baseRange = baseRange;
    this.baseTextModel = baseTextModel;
    this.input1Range = input1Range;
    this.input1TextModel = input1TextModel;
    this.input1Diffs = input1Diffs;
    this.input2Range = input2Range;
    this.input2TextModel = input2TextModel;
    this.input2Diffs = input2Diffs;
    this.input1CombinedDiff = DetailedLineRangeMapping.join(this.input1Diffs);
    this.input2CombinedDiff = DetailedLineRangeMapping.join(this.input2Diffs);
    this.isEqualChange = equals(this.input1Diffs, this.input2Diffs, (a, b) => a.getLineEdit().equals(b.getLineEdit()));
    this.smartInput1LineRangeEdit = null;
    this.smartInput2LineRangeEdit = null;
    this.dumbInput1LineRangeEdit = null;
    this.dumbInput2LineRangeEdit = null;
    if (this.input1Diffs.length === 0 && this.input2Diffs.length === 0) {
      throw new BugIndicatingError("must have at least one diff");
    }
  }
  getInputRange(inputNumber) {
    return inputNumber === 1 ? this.input1Range : this.input2Range;
  }
  getInputCombinedDiff(inputNumber) {
    return inputNumber === 1 ? this.input1CombinedDiff : this.input2CombinedDiff;
  }
  getInputDiffs(inputNumber) {
    return inputNumber === 1 ? this.input1Diffs : this.input2Diffs;
  }
  get isConflicting() {
    return this.input1Diffs.length > 0 && this.input2Diffs.length > 0;
  }
  get canBeCombined() {
    return this.smartCombineInputs(1) !== void 0;
  }
  get isOrderRelevant() {
    const input1 = this.smartCombineInputs(1);
    const input2 = this.smartCombineInputs(2);
    if (!input1 || !input2) {
      return false;
    }
    return !input1.equals(input2);
  }
  getEditForBase(state) {
    const diffs = [];
    if (state.includesInput1 && this.input1CombinedDiff) {
      diffs.push({ diff: this.input1CombinedDiff, inputNumber: 1 });
    }
    if (state.includesInput2 && this.input2CombinedDiff) {
      diffs.push({ diff: this.input2CombinedDiff, inputNumber: 2 });
    }
    if (diffs.length === 0) {
      return { edit: void 0, effectiveState: ModifiedBaseRangeState.base };
    }
    if (diffs.length === 1) {
      return { edit: diffs[0].diff.getLineEdit(), effectiveState: ModifiedBaseRangeState.base.withInputValue(diffs[0].inputNumber, true, false) };
    }
    if (state.kind !== ModifiedBaseRangeStateKind.both) {
      throw new BugIndicatingError();
    }
    const smartCombinedEdit = state.smartCombination ? this.smartCombineInputs(state.firstInput) : this.dumbCombineInputs(state.firstInput);
    if (smartCombinedEdit) {
      return { edit: smartCombinedEdit, effectiveState: state };
    }
    return {
      edit: diffs[getOtherInputNumber(state.firstInput) - 1].diff.getLineEdit(),
      effectiveState: ModifiedBaseRangeState.base.withInputValue(getOtherInputNumber(state.firstInput), true, false)
    };
  }
  smartCombineInputs(firstInput) {
    if (firstInput === 1 && this.smartInput1LineRangeEdit !== null) {
      return this.smartInput1LineRangeEdit;
    } else if (firstInput === 2 && this.smartInput2LineRangeEdit !== null) {
      return this.smartInput2LineRangeEdit;
    }
    const combinedDiffs = concatArrays(this.input1Diffs.flatMap((diffs) => diffs.rangeMappings.map((diff) => ({ diff, input: 1 }))), this.input2Diffs.flatMap((diffs) => diffs.rangeMappings.map((diff) => ({ diff, input: 2 })))).sort(tieBreakComparators(compareBy((d) => d.diff.inputRange, Range.compareRangesUsingStarts), compareBy((d) => d.input === firstInput ? 1 : 2, numberComparator)));
    const sortedEdits = combinedDiffs.map((d) => {
      const sourceTextModel = d.input === 1 ? this.input1TextModel : this.input2TextModel;
      return new RangeEdit(d.diff.inputRange, sourceTextModel.getValueInRange(d.diff.outputRange));
    });
    const result = editsToLineRangeEdit(this.baseRange, sortedEdits, this.baseTextModel);
    if (firstInput === 1) {
      this.smartInput1LineRangeEdit = result;
    } else {
      this.smartInput2LineRangeEdit = result;
    }
    return result;
  }
  dumbCombineInputs(firstInput) {
    if (firstInput === 1 && this.dumbInput1LineRangeEdit !== null) {
      return this.dumbInput1LineRangeEdit;
    } else if (firstInput === 2 && this.dumbInput2LineRangeEdit !== null) {
      return this.dumbInput2LineRangeEdit;
    }
    let input1Lines = this.input1Range.getLines(this.input1TextModel);
    let input2Lines = this.input2Range.getLines(this.input2TextModel);
    if (firstInput === 2) {
      [input1Lines, input2Lines] = [input2Lines, input1Lines];
    }
    const result = new LineRangeEdit(this.baseRange, input1Lines.concat(input2Lines));
    if (firstInput === 1) {
      this.dumbInput1LineRangeEdit = result;
    } else {
      this.dumbInput2LineRangeEdit = result;
    }
    return result;
  }
};
function editsToLineRangeEdit(range, sortedEdits, textModel) {
  let text = "";
  const startsLineBefore = range.startLineNumber > 1;
  let currentPosition = startsLineBefore ? new Position(
    range.startLineNumber - 1,
    textModel.getLineMaxColumn(range.startLineNumber - 1)
  ) : new Position(range.startLineNumber, 1);
  for (const edit of sortedEdits) {
    const diffStart = edit.range.getStartPosition();
    if (!currentPosition.isBeforeOrEqual(diffStart)) {
      return void 0;
    }
    let originalText2 = textModel.getValueInRange(Range.fromPositions(currentPosition, diffStart));
    if (diffStart.lineNumber > textModel.getLineCount()) {
      originalText2 += "\n";
    }
    text += originalText2;
    text += edit.newText;
    currentPosition = edit.range.getEndPosition();
  }
  const endsLineAfter = range.endLineNumberExclusive <= textModel.getLineCount();
  const end = endsLineAfter ? new Position(range.endLineNumberExclusive, 1) : new Position(
    range.endLineNumberExclusive - 1,
    1073741824
  );
  const originalText = textModel.getValueInRange(Range.fromPositions(currentPosition, end));
  text += originalText;
  const lines = splitLines(text);
  if (startsLineBefore) {
    if (lines[0] !== "") {
      return void 0;
    }
    lines.shift();
  }
  if (endsLineAfter) {
    if (lines[lines.length - 1] !== "") {
      return void 0;
    }
    lines.pop();
  }
  return new LineRangeEdit(range, lines);
}
var ModifiedBaseRangeStateKind;
(function(ModifiedBaseRangeStateKind2) {
  ModifiedBaseRangeStateKind2[ModifiedBaseRangeStateKind2["base"] = 0] = "base";
  ModifiedBaseRangeStateKind2[ModifiedBaseRangeStateKind2["input1"] = 1] = "input1";
  ModifiedBaseRangeStateKind2[ModifiedBaseRangeStateKind2["input2"] = 2] = "input2";
  ModifiedBaseRangeStateKind2[ModifiedBaseRangeStateKind2["both"] = 3] = "both";
  ModifiedBaseRangeStateKind2[ModifiedBaseRangeStateKind2["unrecognized"] = 4] = "unrecognized";
})(ModifiedBaseRangeStateKind || (ModifiedBaseRangeStateKind = {}));
function getOtherInputNumber(inputNumber) {
  return inputNumber === 1 ? 2 : 1;
}
var AbstractModifiedBaseRangeState = class {
  constructor() {
  }
  get includesInput1() {
    return false;
  }
  get includesInput2() {
    return false;
  }
  includesInput(inputNumber) {
    return inputNumber === 1 ? this.includesInput1 : this.includesInput2;
  }
  isInputIncluded(inputNumber) {
    return inputNumber === 1 ? this.includesInput1 : this.includesInput2;
  }
  toggle(inputNumber) {
    return this.withInputValue(inputNumber, !this.includesInput(inputNumber), true);
  }
  getInput(inputNumber) {
    if (!this.isInputIncluded(inputNumber)) {
      return 0;
    }
    return 1;
  }
};
var ModifiedBaseRangeStateBase = class extends AbstractModifiedBaseRangeState {
  get kind() {
    return ModifiedBaseRangeStateKind.base;
  }
  toString() {
    return "base";
  }
  swap() {
    return this;
  }
  withInputValue(inputNumber, value, smartCombination = false) {
    if (inputNumber === 1) {
      return value ? new ModifiedBaseRangeStateInput1() : this;
    } else {
      return value ? new ModifiedBaseRangeStateInput2() : this;
    }
  }
  equals(other) {
    return other.kind === ModifiedBaseRangeStateKind.base;
  }
};
var ModifiedBaseRangeStateInput1 = class extends AbstractModifiedBaseRangeState {
  get kind() {
    return ModifiedBaseRangeStateKind.input1;
  }
  get includesInput1() {
    return true;
  }
  toString() {
    return "1✓";
  }
  swap() {
    return new ModifiedBaseRangeStateInput2();
  }
  withInputValue(inputNumber, value, smartCombination = false) {
    if (inputNumber === 1) {
      return value ? this : new ModifiedBaseRangeStateBase();
    } else {
      return value ? new ModifiedBaseRangeStateBoth(1, smartCombination) : new ModifiedBaseRangeStateInput2();
    }
  }
  equals(other) {
    return other.kind === ModifiedBaseRangeStateKind.input1;
  }
};
var ModifiedBaseRangeStateInput2 = class _ModifiedBaseRangeStateInput2 extends AbstractModifiedBaseRangeState {
  get kind() {
    return ModifiedBaseRangeStateKind.input2;
  }
  get includesInput2() {
    return true;
  }
  toString() {
    return "2✓";
  }
  swap() {
    return new ModifiedBaseRangeStateInput1();
  }
  withInputValue(inputNumber, value, smartCombination = false) {
    if (inputNumber === 2) {
      return value ? this : new ModifiedBaseRangeStateBase();
    } else {
      return value ? new ModifiedBaseRangeStateBoth(2, smartCombination) : new _ModifiedBaseRangeStateInput2();
    }
  }
  equals(other) {
    return other.kind === ModifiedBaseRangeStateKind.input2;
  }
};
var ModifiedBaseRangeStateBoth = class _ModifiedBaseRangeStateBoth extends AbstractModifiedBaseRangeState {
  constructor(firstInput, smartCombination) {
    super();
    this.firstInput = firstInput;
    this.smartCombination = smartCombination;
  }
  get kind() {
    return ModifiedBaseRangeStateKind.both;
  }
  get includesInput1() {
    return true;
  }
  get includesInput2() {
    return true;
  }
  toString() {
    return "2✓";
  }
  swap() {
    return new _ModifiedBaseRangeStateBoth(getOtherInputNumber(this.firstInput), this.smartCombination);
  }
  withInputValue(inputNumber, value, smartCombination = false) {
    if (value) {
      return this;
    }
    return inputNumber === 1 ? new ModifiedBaseRangeStateInput2() : new ModifiedBaseRangeStateInput1();
  }
  equals(other) {
    return other.kind === ModifiedBaseRangeStateKind.both && this.firstInput === other.firstInput && this.smartCombination === other.smartCombination;
  }
  getInput(inputNumber) {
    return inputNumber === this.firstInput ? 1 : 2;
  }
};
var ModifiedBaseRangeStateUnrecognized = class extends AbstractModifiedBaseRangeState {
  get kind() {
    return ModifiedBaseRangeStateKind.unrecognized;
  }
  toString() {
    return "unrecognized";
  }
  swap() {
    return this;
  }
  withInputValue(inputNumber, value, smartCombination = false) {
    if (!value) {
      return this;
    }
    return inputNumber === 1 ? new ModifiedBaseRangeStateInput1() : new ModifiedBaseRangeStateInput2();
  }
  equals(other) {
    return other.kind === ModifiedBaseRangeStateKind.unrecognized;
  }
};
var ModifiedBaseRangeState;
(function(ModifiedBaseRangeState2) {
  ModifiedBaseRangeState2.base = new ModifiedBaseRangeStateBase();
  ModifiedBaseRangeState2.unrecognized = new ModifiedBaseRangeStateUnrecognized();
})(ModifiedBaseRangeState || (ModifiedBaseRangeState = {}));

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/mergeEditorModel.js
var MergeEditorModel = class MergeEditorModel2 extends EditorModel {
  constructor(base, input1, input2, resultTextModel, diffComputer, options, telemetry, languageService, undoRedoService) {
    super();
    this.base = base;
    this.input1 = input1;
    this.input2 = input2;
    this.resultTextModel = resultTextModel;
    this.diffComputer = diffComputer;
    this.options = options;
    this.telemetry = telemetry;
    this.languageService = languageService;
    this.undoRedoService = undoRedoService;
    this.input1TextModelDiffs = this._register(new TextModelDiffs(this.base, this.input1.textModel, this.diffComputer));
    this.input2TextModelDiffs = this._register(new TextModelDiffs(this.base, this.input2.textModel, this.diffComputer));
    this.resultTextModelDiffs = this._register(new TextModelDiffs(this.base, this.resultTextModel, this.diffComputer));
    this.modifiedBaseRanges = derived((reader) => {
      const input1Diffs = this.input1TextModelDiffs.diffs.read(reader);
      const input2Diffs = this.input2TextModelDiffs.diffs.read(reader);
      return ModifiedBaseRange.fromDiffs(input1Diffs, input2Diffs, this.base, this.input1.textModel, this.input2.textModel);
    });
    this.modifiedBaseRangeResultStates = derived((reader) => {
      const map = new Map(this.modifiedBaseRanges.read(reader).map((s) => [
        s,
        new ModifiedBaseRangeData(s)
      ]));
      return map;
    });
    this.resultSnapshot = this.resultTextModel.createSnapshot();
    this.baseInput1Diffs = this.input1TextModelDiffs.diffs;
    this.baseInput2Diffs = this.input2TextModelDiffs.diffs;
    this.baseResultDiffs = this.resultTextModelDiffs.diffs;
    this.input1ResultMapping = derived((reader) => {
      return this.getInputResultMapping(this.baseInput1Diffs.read(reader), this.baseResultDiffs.read(reader), this.input1.textModel.getLineCount());
    });
    this.resultInput1Mapping = derived((reader) => this.input1ResultMapping.read(reader).reverse());
    this.input2ResultMapping = derived((reader) => {
      return this.getInputResultMapping(this.baseInput2Diffs.read(reader), this.baseResultDiffs.read(reader), this.input2.textModel.getLineCount());
    });
    this.resultInput2Mapping = derived((reader) => this.input2ResultMapping.read(reader).reverse());
    this.baseResultMapping = derived((reader) => {
      const map = new DocumentLineRangeMap(this.baseResultDiffs.read(reader), -1);
      return new DocumentLineRangeMap(map.lineRangeMappings.map((m) => m.inputRange.isEmpty || m.outputRange.isEmpty ? new LineRangeMapping(
        m.inputRange.deltaStart(-1),
        m.outputRange.deltaStart(-1)
      ) : m), map.inputLineCount);
    });
    this.resultBaseMapping = derived((reader) => this.baseResultMapping.read(reader).reverse());
    this.diffComputingState = derived((reader) => {
      const states = [
        this.input1TextModelDiffs,
        this.input2TextModelDiffs,
        this.resultTextModelDiffs
      ].map((s) => s.state.read(reader));
      if (states.some((s) => s === 1)) {
        return 1;
      }
      if (states.some((s) => s === 3)) {
        return 3;
      }
      return 2;
    });
    this.inputDiffComputingState = derived((reader) => {
      const states = [
        this.input1TextModelDiffs,
        this.input2TextModelDiffs
      ].map((s) => s.state.read(reader));
      if (states.some((s) => s === 1)) {
        return 1;
      }
      if (states.some((s) => s === 3)) {
        return 3;
      }
      return 2;
    });
    this.isUpToDate = derived((reader) => this.diffComputingState.read(reader) === 2);
    this.onInitialized = waitForState(this.diffComputingState, (state) => state === 2).then(() => {
    });
    this.firstRun = true;
    this.unhandledConflictsCount = derived((reader) => {
      const map = this.modifiedBaseRangeResultStates.read(reader);
      let unhandledCount = 0;
      for (const [_key, value] of map) {
        if (!value.handled.read(reader)) {
          unhandledCount++;
        }
      }
      return unhandledCount;
    });
    this.hasUnhandledConflicts = this.unhandledConflictsCount.map((value) => value > 0);
    this._register(keepAlive(this.modifiedBaseRangeResultStates));
    this._register(keepAlive(this.input1ResultMapping));
    this._register(keepAlive(this.input2ResultMapping));
    const initializePromise = this.initialize();
    this.onInitialized = this.onInitialized.then(async () => {
      await initializePromise;
    });
    initializePromise.then(() => {
      let shouldRecomputeHandledFromAccepted = true;
      this._register(autorunHandleChanges({
        handleChange: (ctx) => {
          if (ctx.didChange(this.modifiedBaseRangeResultStates)) {
            shouldRecomputeHandledFromAccepted = true;
          }
          return ctx.didChange(this.resultTextModelDiffs.diffs) ? ctx.change === 1 : true;
        }
      }, (reader) => {
        const states = this.modifiedBaseRangeResultStates.read(reader);
        if (!this.isUpToDate.read(reader)) {
          return;
        }
        const resultDiffs = this.resultTextModelDiffs.diffs.read(reader);
        transaction((tx) => {
          this.updateBaseRangeAcceptedState(resultDiffs, states, tx);
          if (shouldRecomputeHandledFromAccepted) {
            shouldRecomputeHandledFromAccepted = false;
            for (const [_range, observableState] of states) {
              const state = observableState.accepted.get();
              const handled = !(state.kind === ModifiedBaseRangeStateKind.base || state.kind === ModifiedBaseRangeStateKind.unrecognized);
              observableState.handledInput1.set(handled, tx);
              observableState.handledInput2.set(handled, tx);
            }
          }
        });
      }));
    });
  }
  async initialize() {
    if (this.options.resetResult) {
      await this.reset();
    }
  }
  async reset() {
    await waitForState(this.inputDiffComputingState, (state) => state === 2);
    const states = this.modifiedBaseRangeResultStates.get();
    transaction((tx) => {
      for (const [range, state] of states) {
        let newState;
        let handled = false;
        if (range.input1Diffs.length === 0) {
          newState = ModifiedBaseRangeState.base.withInputValue(2, true);
          handled = true;
        } else if (range.input2Diffs.length === 0) {
          newState = ModifiedBaseRangeState.base.withInputValue(1, true);
          handled = true;
        } else if (range.isEqualChange) {
          newState = ModifiedBaseRangeState.base.withInputValue(1, true);
          handled = true;
        } else {
          newState = ModifiedBaseRangeState.base;
          handled = false;
        }
        state.accepted.set(newState, tx);
        state.computedFromDiffing = false;
        state.previousNonDiffingState = void 0;
        state.handledInput1.set(handled, tx);
        state.handledInput2.set(handled, tx);
      }
      this.resultTextModel.pushEditOperations(null, [{
        range: new Range(1, 1, Number.MAX_SAFE_INTEGER, 1),
        text: this.computeAutoMergedResult()
      }], () => null);
    });
  }
  computeAutoMergedResult() {
    const baseRanges = this.modifiedBaseRanges.get();
    const baseLines = this.base.getLinesContent();
    const input1Lines = this.input1.textModel.getLinesContent();
    const input2Lines = this.input2.textModel.getLinesContent();
    const resultLines = [];
    function appendLinesToResult(source, lineRange) {
      for (let i = lineRange.startLineNumber; i < lineRange.endLineNumberExclusive; i++) {
        resultLines.push(source[i - 1]);
      }
    }
    let baseStartLineNumber = 1;
    for (const baseRange of baseRanges) {
      appendLinesToResult(baseLines, LineRange.fromLineNumbers(baseStartLineNumber, baseRange.baseRange.startLineNumber));
      baseStartLineNumber = baseRange.baseRange.endLineNumberExclusive;
      if (baseRange.input1Diffs.length === 0) {
        appendLinesToResult(input2Lines, baseRange.input2Range);
      } else if (baseRange.input2Diffs.length === 0) {
        appendLinesToResult(input1Lines, baseRange.input1Range);
      } else if (baseRange.isEqualChange) {
        appendLinesToResult(input1Lines, baseRange.input1Range);
      } else {
        appendLinesToResult(baseLines, baseRange.baseRange);
      }
    }
    appendLinesToResult(baseLines, LineRange.fromLineNumbers(baseStartLineNumber, baseLines.length + 1));
    return resultLines.join(this.resultTextModel.getEOL());
  }
  hasBaseRange(baseRange) {
    return this.modifiedBaseRangeResultStates.get().has(baseRange);
  }
  get isApplyingEditInResult() {
    return this.resultTextModelDiffs.isApplyingChange;
  }
  getInputResultMapping(inputLinesDiffs, resultDiffs, inputLineCount) {
    const map = DocumentLineRangeMap.betweenOutputs(inputLinesDiffs, resultDiffs, inputLineCount);
    return new DocumentLineRangeMap(map.lineRangeMappings.map((m) => m.inputRange.isEmpty || m.outputRange.isEmpty ? new LineRangeMapping(
      m.inputRange.deltaStart(-1),
      m.outputRange.deltaStart(-1)
    ) : m), map.inputLineCount);
  }
  translateInputRangeToBase(input, range) {
    const baseInputDiffs = input === 1 ? this.baseInput1Diffs.get() : this.baseInput2Diffs.get();
    const map = new DocumentRangeMap(baseInputDiffs.flatMap((d) => d.rangeMappings), 0).reverse();
    return map.projectRange(range).outputRange;
  }
  translateBaseRangeToInput(input, range) {
    const baseInputDiffs = input === 1 ? this.baseInput1Diffs.get() : this.baseInput2Diffs.get();
    const map = new DocumentRangeMap(baseInputDiffs.flatMap((d) => d.rangeMappings), 0);
    return map.projectRange(range).outputRange;
  }
  getLineRangeInResult(baseRange, reader) {
    return this.resultTextModelDiffs.getResultLineRange(baseRange, reader);
  }
  translateResultRangeToBase(range) {
    const map = new DocumentRangeMap(this.baseResultDiffs.get().flatMap((d) => d.rangeMappings), 0).reverse();
    return map.projectRange(range).outputRange;
  }
  translateBaseRangeToResult(range) {
    const map = new DocumentRangeMap(this.baseResultDiffs.get().flatMap((d) => d.rangeMappings), 0);
    return map.projectRange(range).outputRange;
  }
  findModifiedBaseRangesInRange(rangeInBase) {
    return this.modifiedBaseRanges.get().filter((r) => r.baseRange.intersects(rangeInBase));
  }
  updateBaseRangeAcceptedState(resultDiffs, states, tx) {
    const baseRangeWithStoreAndTouchingDiffs = leftJoin(states, resultDiffs, (baseRange, diff) => baseRange[0].baseRange.touches(diff.inputRange) ? CompareResult.neitherLessOrGreaterThan : LineRange.compareByStart(baseRange[0].baseRange, diff.inputRange));
    for (const row of baseRangeWithStoreAndTouchingDiffs) {
      const newState = this.computeState(row.left[0], row.rights);
      const data = row.left[1];
      const oldState = data.accepted.get();
      if (!oldState.equals(newState)) {
        if (!this.firstRun && !data.computedFromDiffing) {
          data.computedFromDiffing = true;
          data.previousNonDiffingState = oldState;
        }
        data.accepted.set(newState, tx);
      }
    }
    if (this.firstRun) {
      this.firstRun = false;
    }
  }
  computeState(baseRange, conflictingDiffs) {
    if (conflictingDiffs.length === 0) {
      return ModifiedBaseRangeState.base;
    }
    const conflictingEdits = conflictingDiffs.map((d) => d.getLineEdit());
    function editsAgreeWithDiffs(diffs) {
      return equals(conflictingEdits, diffs.map((d) => d.getLineEdit()), (a, b) => a.equals(b));
    }
    if (editsAgreeWithDiffs(baseRange.input1Diffs)) {
      return ModifiedBaseRangeState.base.withInputValue(1, true);
    }
    if (editsAgreeWithDiffs(baseRange.input2Diffs)) {
      return ModifiedBaseRangeState.base.withInputValue(2, true);
    }
    const states = [
      ModifiedBaseRangeState.base.withInputValue(1, true).withInputValue(2, true, true),
      ModifiedBaseRangeState.base.withInputValue(2, true).withInputValue(1, true, true),
      ModifiedBaseRangeState.base.withInputValue(1, true).withInputValue(2, true, false),
      ModifiedBaseRangeState.base.withInputValue(2, true).withInputValue(1, true, false)
    ];
    for (const s of states) {
      const { edit } = baseRange.getEditForBase(s);
      if (edit) {
        const resultRange = this.resultTextModelDiffs.getResultLineRange(baseRange.baseRange);
        const existingLines = resultRange.getLines(this.resultTextModel);
        if (equals(edit.newLines, existingLines, (a, b) => a === b)) {
          return s;
        }
      }
    }
    return ModifiedBaseRangeState.unrecognized;
  }
  getState(baseRange) {
    const existingState = this.modifiedBaseRangeResultStates.get().get(baseRange);
    if (!existingState) {
      throw new BugIndicatingError("object must be from this instance");
    }
    return existingState.accepted;
  }
  setState(baseRange, state, _markInputAsHandled, tx, _pushStackElement = false) {
    if (!this.isUpToDate.get()) {
      throw new BugIndicatingError("Cannot set state while updating");
    }
    const existingState = this.modifiedBaseRangeResultStates.get().get(baseRange);
    if (!existingState) {
      throw new BugIndicatingError("object must be from this instance");
    }
    const conflictingDiffs = this.resultTextModelDiffs.findTouchingDiffs(baseRange.baseRange);
    const group = new UndoRedoGroup();
    if (conflictingDiffs) {
      this.resultTextModelDiffs.removeDiffs(conflictingDiffs, tx, group);
    }
    const { edit, effectiveState } = baseRange.getEditForBase(state);
    existingState.accepted.set(effectiveState, tx);
    existingState.previousNonDiffingState = void 0;
    existingState.computedFromDiffing = false;
    const input1Handled = existingState.handledInput1.get();
    const input2Handled = existingState.handledInput2.get();
    if (!input1Handled || !input2Handled) {
      this.undoRedoService.pushElement(new MarkAsHandledUndoRedoElement(this.resultTextModel.uri, new WeakRef(this), new WeakRef(existingState), input1Handled, input2Handled), group);
    }
    if (edit) {
      this.resultTextModel.pushStackElement();
      this.resultTextModelDiffs.applyEditRelativeToOriginal(edit, tx, group);
      this.resultTextModel.pushStackElement();
    }
    existingState.handledInput1.set(true, tx);
    existingState.handledInput2.set(true, tx);
  }
  resetDirtyConflictsToBase() {
    transaction((tx) => {
      this.resultTextModel.pushStackElement();
      for (const range of this.modifiedBaseRanges.get()) {
        if (this.getState(range).get().kind === ModifiedBaseRangeStateKind.unrecognized) {
          this.setState(range, ModifiedBaseRangeState.base, false, tx, false);
        }
      }
      this.resultTextModel.pushStackElement();
    });
  }
  isHandled(baseRange) {
    return this.modifiedBaseRangeResultStates.get().get(baseRange).handled;
  }
  isInputHandled(baseRange, inputNumber) {
    const state = this.modifiedBaseRangeResultStates.get().get(baseRange);
    return inputNumber === 1 ? state.handledInput1 : state.handledInput2;
  }
  setInputHandled(baseRange, inputNumber, handled, tx) {
    const state = this.modifiedBaseRangeResultStates.get().get(baseRange);
    if (state.handled.get() === handled) {
      return;
    }
    const dataRef = new WeakRef(ModifiedBaseRangeData);
    const modelRef = new WeakRef(this);
    this.undoRedoService.pushElement({
      type: 0,
      resource: this.resultTextModel.uri,
      code: "setInputHandled",
      label: localize("setInputHandled", "Set Input Handled"),
      redo() {
        const model = modelRef.deref();
        const data = dataRef.deref();
        if (model && !model.isDisposed() && data) {
          transaction((tx2) => {
            if (inputNumber === 1) {
              state.handledInput1.set(handled, tx2);
            } else {
              state.handledInput2.set(handled, tx2);
            }
          });
        }
      },
      undo() {
        const model = modelRef.deref();
        const data = dataRef.deref();
        if (model && !model.isDisposed() && data) {
          transaction((tx2) => {
            if (inputNumber === 1) {
              state.handledInput1.set(!handled, tx2);
            } else {
              state.handledInput2.set(!handled, tx2);
            }
          });
        }
      }
    });
    if (inputNumber === 1) {
      state.handledInput1.set(handled, tx);
    } else {
      state.handledInput2.set(handled, tx);
    }
  }
  setHandled(baseRange, handled, tx) {
    const state = this.modifiedBaseRangeResultStates.get().get(baseRange);
    if (state.handled.get() === handled) {
      return;
    }
    state.handledInput1.set(handled, tx);
    state.handledInput2.set(handled, tx);
  }
  setLanguageId(languageId, source) {
    const language2 = this.languageService.createById(languageId);
    this.base.setLanguage(language2, source);
    this.input1.textModel.setLanguage(language2, source);
    this.input2.textModel.setLanguage(language2, source);
    this.resultTextModel.setLanguage(language2, source);
  }
  getInitialResultValue() {
    const chunks = [];
    while (true) {
      const chunk = this.resultSnapshot.read();
      if (chunk === null) {
        break;
      }
      chunks.push(chunk);
    }
    return chunks.join();
  }
  async getResultValueWithConflictMarkers() {
    await waitForState(this.diffComputingState, (state) => state === 2);
    if (this.unhandledConflictsCount.get() === 0) {
      return this.resultTextModel.getValue();
    }
    const resultLines = this.resultTextModel.getLinesContent();
    const input1Lines = this.input1.textModel.getLinesContent();
    const input2Lines = this.input2.textModel.getLinesContent();
    const states = this.modifiedBaseRangeResultStates.get();
    const outputLines = [];
    function appendLinesToResult(source, lineRange) {
      for (let i = lineRange.startLineNumber; i < lineRange.endLineNumberExclusive; i++) {
        outputLines.push(source[i - 1]);
      }
    }
    let resultStartLineNumber = 1;
    for (const [range, state] of states) {
      if (state.handled.get()) {
        continue;
      }
      const resultRange = this.resultTextModelDiffs.getResultLineRange(range.baseRange);
      appendLinesToResult(resultLines, LineRange.fromLineNumbers(resultStartLineNumber, Math.max(resultStartLineNumber, resultRange.startLineNumber)));
      resultStartLineNumber = resultRange.endLineNumberExclusive;
      outputLines.push("<<<<<<<");
      if (state.accepted.get().kind === ModifiedBaseRangeStateKind.unrecognized) {
        appendLinesToResult(resultLines, resultRange);
      } else {
        appendLinesToResult(input1Lines, range.input1Range);
      }
      outputLines.push("=======");
      appendLinesToResult(input2Lines, range.input2Range);
      outputLines.push(">>>>>>>");
    }
    appendLinesToResult(resultLines, LineRange.fromLineNumbers(resultStartLineNumber, resultLines.length + 1));
    return outputLines.join("\n");
  }
  get conflictCount() {
    return arrayCount(this.modifiedBaseRanges.get(), (r) => r.isConflicting);
  }
  get combinableConflictCount() {
    return arrayCount(this.modifiedBaseRanges.get(), (r) => r.isConflicting && r.canBeCombined);
  }
  get conflictsResolvedWithBase() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => r.isConflicting && s.accepted.get().kind === ModifiedBaseRangeStateKind.base);
  }
  get conflictsResolvedWithInput1() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => r.isConflicting && s.accepted.get().kind === ModifiedBaseRangeStateKind.input1);
  }
  get conflictsResolvedWithInput2() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => r.isConflicting && s.accepted.get().kind === ModifiedBaseRangeStateKind.input2);
  }
  get conflictsResolvedWithSmartCombination() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => {
      const state = s.accepted.get();
      return r.isConflicting && state.kind === ModifiedBaseRangeStateKind.both && state.smartCombination;
    });
  }
  get manuallySolvedConflictCountThatEqualNone() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => r.isConflicting && s.accepted.get().kind === ModifiedBaseRangeStateKind.unrecognized);
  }
  get manuallySolvedConflictCountThatEqualSmartCombine() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => {
      const state = s.accepted.get();
      return r.isConflicting && s.computedFromDiffing && state.kind === ModifiedBaseRangeStateKind.both && state.smartCombination;
    });
  }
  get manuallySolvedConflictCountThatEqualInput1() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => {
      const state = s.accepted.get();
      return r.isConflicting && s.computedFromDiffing && state.kind === ModifiedBaseRangeStateKind.input1;
    });
  }
  get manuallySolvedConflictCountThatEqualInput2() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => {
      const state = s.accepted.get();
      return r.isConflicting && s.computedFromDiffing && state.kind === ModifiedBaseRangeStateKind.input2;
    });
  }
  get manuallySolvedConflictCountThatEqualNoneAndStartedWithBase() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => {
      var _a30;
      const state = s.accepted.get();
      return r.isConflicting && state.kind === ModifiedBaseRangeStateKind.unrecognized && ((_a30 = s.previousNonDiffingState) == null ? void 0 : _a30.kind) === ModifiedBaseRangeStateKind.base;
    });
  }
  get manuallySolvedConflictCountThatEqualNoneAndStartedWithInput1() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => {
      var _a30;
      const state = s.accepted.get();
      return r.isConflicting && state.kind === ModifiedBaseRangeStateKind.unrecognized && ((_a30 = s.previousNonDiffingState) == null ? void 0 : _a30.kind) === ModifiedBaseRangeStateKind.input1;
    });
  }
  get manuallySolvedConflictCountThatEqualNoneAndStartedWithInput2() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => {
      var _a30;
      const state = s.accepted.get();
      return r.isConflicting && state.kind === ModifiedBaseRangeStateKind.unrecognized && ((_a30 = s.previousNonDiffingState) == null ? void 0 : _a30.kind) === ModifiedBaseRangeStateKind.input2;
    });
  }
  get manuallySolvedConflictCountThatEqualNoneAndStartedWithBothNonSmart() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => {
      var _a30, _b;
      const state = s.accepted.get();
      return r.isConflicting && state.kind === ModifiedBaseRangeStateKind.unrecognized && ((_a30 = s.previousNonDiffingState) == null ? void 0 : _a30.kind) === ModifiedBaseRangeStateKind.both && !((_b = s.previousNonDiffingState) == null ? void 0 : _b.smartCombination);
    });
  }
  get manuallySolvedConflictCountThatEqualNoneAndStartedWithBothSmart() {
    return arrayCount(this.modifiedBaseRangeResultStates.get().entries(), ([r, s]) => {
      var _a30, _b;
      const state = s.accepted.get();
      return r.isConflicting && state.kind === ModifiedBaseRangeStateKind.unrecognized && ((_a30 = s.previousNonDiffingState) == null ? void 0 : _a30.kind) === ModifiedBaseRangeStateKind.both && ((_b = s.previousNonDiffingState) == null ? void 0 : _b.smartCombination);
    });
  }
};
MergeEditorModel = __decorate([
  __param(7, ILanguageService),
  __param(8, IUndoRedoService)
], MergeEditorModel);
function arrayCount(array, predicate) {
  let count2 = 0;
  for (const value of array) {
    if (predicate(value)) {
      count2++;
    }
  }
  return count2;
}
var ModifiedBaseRangeData = class {
  constructor(baseRange) {
    this.baseRange = baseRange;
    this.accepted = observableValue(`BaseRangeState${this.baseRange.baseRange}`, ModifiedBaseRangeState.base);
    this.handledInput1 = observableValue(`BaseRangeHandledState${this.baseRange.baseRange}.Input1`, false);
    this.handledInput2 = observableValue(`BaseRangeHandledState${this.baseRange.baseRange}.Input2`, false);
    this.computedFromDiffing = false;
    this.previousNonDiffingState = void 0;
    this.handled = derived((reader) => this.handledInput1.read(reader) && this.handledInput2.read(reader));
  }
};
var MarkAsHandledUndoRedoElement = class {
  constructor(resource, mergeEditorModelRef, stateRef, input1Handled, input2Handled) {
    this.resource = resource;
    this.mergeEditorModelRef = mergeEditorModelRef;
    this.stateRef = stateRef;
    this.input1Handled = input1Handled;
    this.input2Handled = input2Handled;
    this.code = "undoMarkAsHandled";
    this.label = localize("undoMarkAsHandled", "Undo Mark As Handled");
    this.type = 0;
  }
  redo() {
    const mergeEditorModel = this.mergeEditorModelRef.deref();
    if (!mergeEditorModel || mergeEditorModel.isDisposed()) {
      return;
    }
    const state = this.stateRef.deref();
    if (!state) {
      return;
    }
    transaction((tx) => {
      state.handledInput1.set(true, tx);
      state.handledInput2.set(true, tx);
    });
  }
  undo() {
    const mergeEditorModel = this.mergeEditorModelRef.deref();
    if (!mergeEditorModel || mergeEditorModel.isDisposed()) {
      return;
    }
    const state = this.stateRef.deref();
    if (!state) {
      return;
    }
    transaction((tx) => {
      state.handledInput1.set(this.input1Handled, tx);
      state.handledInput2.set(this.input2Handled, tx);
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/common/mergeEditor.js
var StorageCloseWithConflicts = "mergeEditorCloseWithConflicts";

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/mergeEditorInputModel.js
var WorkspaceMergeEditorModeFactory_1;
var TempFileMergeEditorModeFactory = class TempFileMergeEditorModeFactory2 {
  constructor(_mergeEditorTelemetry, _instantiationService, _textModelService, _modelService) {
    this._mergeEditorTelemetry = _mergeEditorTelemetry;
    this._instantiationService = _instantiationService;
    this._textModelService = _textModelService;
    this._modelService = _modelService;
  }
  async createInputModel(args) {
    const store = new DisposableStore();
    const [base, result, input1Data, input2Data] = await Promise.all([
      this._textModelService.createModelReference(args.base),
      this._textModelService.createModelReference(args.result),
      toInputData(args.input1, this._textModelService, store),
      toInputData(args.input2, this._textModelService, store)
    ]);
    store.add(base);
    store.add(result);
    const tempResultUri = result.object.textEditorModel.uri.with({ scheme: "merge-result" });
    const temporaryResultModel = this._modelService.createModel("", {
      languageId: result.object.textEditorModel.getLanguageId(),
      onDidChange: Event.None
    }, tempResultUri);
    store.add(temporaryResultModel);
    const mergeDiffComputer = this._instantiationService.createInstance(MergeDiffComputer);
    const model = this._instantiationService.createInstance(MergeEditorModel, base.object.textEditorModel, input1Data, input2Data, temporaryResultModel, mergeDiffComputer, {
      resetResult: true
    }, this._mergeEditorTelemetry);
    store.add(model);
    await model.onInitialized;
    return this._instantiationService.createInstance(TempFileMergeEditorInputModel, model, store, result.object, args.result);
  }
};
TempFileMergeEditorModeFactory = __decorate([
  __param(1, IInstantiationService),
  __param(2, ITextModelService),
  __param(3, IModelService)
], TempFileMergeEditorModeFactory);
var TempFileMergeEditorInputModel = class TempFileMergeEditorInputModel2 extends EditorModel {
  constructor(model, disposable, result, resultUri, textFileService, dialogService, editorService) {
    super();
    this.model = model;
    this.disposable = disposable;
    this.result = result;
    this.resultUri = resultUri;
    this.textFileService = textFileService;
    this.dialogService = dialogService;
    this.editorService = editorService;
    this.savedAltVersionId = observableValue("initialAltVersionId", this.model.resultTextModel.getAlternativeVersionId());
    this.altVersionId = observableFromEvent((e) => this.model.resultTextModel.onDidChangeContent(e), () => this.model.resultTextModel.getAlternativeVersionId());
    this.isDirty = derived((reader) => this.altVersionId.read(reader) !== this.savedAltVersionId.read(reader));
    this.finished = false;
  }
  dispose() {
    this.disposable.dispose();
    super.dispose();
  }
  async accept() {
    const value = await this.model.resultTextModel.getValue();
    this.result.textEditorModel.setValue(value);
    this.savedAltVersionId.set(this.model.resultTextModel.getAlternativeVersionId(), void 0);
    await this.textFileService.save(this.result.textEditorModel.uri);
    this.finished = true;
  }
  async _discard() {
    await this.textFileService.revert(this.model.resultTextModel.uri);
    this.savedAltVersionId.set(this.model.resultTextModel.getAlternativeVersionId(), void 0);
    this.finished = true;
  }
  shouldConfirmClose() {
    return true;
  }
  async confirmClose(inputModels) {
    assertFn(() => inputModels.some((m) => m === this));
    const someDirty = inputModels.some((m) => m.isDirty.get());
    let choice;
    if (someDirty) {
      const isMany = inputModels.length > 1;
      const message = isMany ? localize(
        "messageN",
        "Do you want keep the merge result of {0} files?",
        inputModels.length
      ) : localize(
        "message1",
        "Do you want keep the merge result of {0}?",
        basename2(inputModels[0].model.resultTextModel.uri)
      );
      const hasUnhandledConflicts = inputModels.some((m) => m.model.hasUnhandledConflicts.get());
      const buttons = [
        {
          label: hasUnhandledConflicts ? localize(
            { key: "saveWithConflict", comment: ["&& denotes a mnemonic"] },
            "&&Save With Conflicts"
          ) : localize({ key: "save", comment: ["&& denotes a mnemonic"] }, "&&Save"),
          run: () => 0
        },
        {
          label: localize({ key: "discard", comment: ["&& denotes a mnemonic"] }, "Do&&n't Save"),
          run: () => 1
        }
      ];
      choice = (await this.dialogService.prompt({
        type: severity_default.Info,
        message,
        detail: hasUnhandledConflicts ? isMany ? localize(
          "detailNConflicts",
          "The files contain unhandled conflicts. The merge results will be lost if you don't save them."
        ) : localize(
          "detail1Conflicts",
          "The file contains unhandled conflicts. The merge result will be lost if you don't save it."
        ) : isMany ? localize("detailN", "The merge results will be lost if you don't save them.") : localize("detail1", "The merge result will be lost if you don't save it."),
        buttons,
        cancelButton: {
          run: () => 2
        }
      })).result;
    } else {
      choice = 1;
    }
    if (choice === 0) {
      await Promise.all(inputModels.map((m) => m.accept()));
    } else if (choice === 1) {
      await Promise.all(inputModels.map((m) => m._discard()));
    } else
      ;
    return choice;
  }
  async save(options) {
    if (this.finished) {
      return;
    }
    (async () => {
      const { confirmed } = await this.dialogService.confirm({
        message: localize("saveTempFile.message", "Do you want to accept the merge result?"),
        detail: localize(
          "saveTempFile.detail",
          "This will write the merge result to the original file and close the merge editor."
        ),
        primaryButton: localize(
          { key: "acceptMerge", comment: ["&& denotes a mnemonic"] },
          "&&Accept Merge"
        )
      });
      if (confirmed) {
        await this.accept();
        const editors = this.editorService.findEditors(this.resultUri).filter((e) => e.editor.typeId === "mergeEditor.Input");
        await this.editorService.closeEditors(editors);
      }
    })();
  }
  async revert(options) {
  }
};
TempFileMergeEditorInputModel = __decorate([
  __param(4, ITextFileService),
  __param(5, IDialogService),
  __param(6, IEditorService)
], TempFileMergeEditorInputModel);
var _a18;
var WorkspaceMergeEditorModeFactory = (_a18 = class {
  constructor(_mergeEditorTelemetry, _instantiationService, _textModelService, textFileService) {
    this._mergeEditorTelemetry = _mergeEditorTelemetry;
    this._instantiationService = _instantiationService;
    this._textModelService = _textModelService;
    this.textFileService = textFileService;
  }
  async createInputModel(args) {
    const store = new DisposableStore();
    let resultTextFileModel = void 0;
    const modelListener = store.add(new DisposableStore());
    const handleDidCreate = (model2) => {
      if (isEqual(args.result, model2.resource)) {
        modelListener.clear();
        resultTextFileModel = model2;
      }
    };
    modelListener.add(this.textFileService.files.onDidCreate(handleDidCreate));
    this.textFileService.files.models.forEach(handleDidCreate);
    const [base, result, input1Data, input2Data] = await Promise.all([
      this._textModelService.createModelReference(args.base),
      this._textModelService.createModelReference(args.result),
      toInputData(args.input1, this._textModelService, store),
      toInputData(args.input2, this._textModelService, store)
    ]);
    store.add(base);
    store.add(result);
    if (!resultTextFileModel) {
      throw new BugIndicatingError();
    }
    await resultTextFileModel.save({ source: WorkspaceMergeEditorModeFactory_1.FILE_SAVED_SOURCE });
    const lines = resultTextFileModel.textEditorModel.getLinesContent();
    const hasConflictMarkers = lines.some((l) => l.startsWith(conflictMarkers.start));
    const resetResult = hasConflictMarkers;
    const mergeDiffComputer = this._instantiationService.createInstance(MergeDiffComputer);
    const model = this._instantiationService.createInstance(MergeEditorModel, base.object.textEditorModel, input1Data, input2Data, result.object.textEditorModel, mergeDiffComputer, {
      resetResult
    }, this._mergeEditorTelemetry);
    store.add(model);
    await model.onInitialized;
    return this._instantiationService.createInstance(WorkspaceMergeEditorInputModel, model, store, resultTextFileModel, this._mergeEditorTelemetry);
  }
}, WorkspaceMergeEditorModeFactory_1 = _a18, _a18.FILE_SAVED_SOURCE = SaveSourceRegistry.registerSource("merge-editor.source", localize("merge-editor.source", "Before Resolving Conflicts In Merge Editor")), _a18);
WorkspaceMergeEditorModeFactory = WorkspaceMergeEditorModeFactory_1 = __decorate([
  __param(1, IInstantiationService),
  __param(2, ITextModelService),
  __param(3, ITextFileService)
], WorkspaceMergeEditorModeFactory);
var WorkspaceMergeEditorInputModel = class WorkspaceMergeEditorInputModel2 extends EditorModel {
  constructor(model, disposableStore, resultTextFileModel, telemetry, _dialogService, _storageService) {
    super();
    this.model = model;
    this.disposableStore = disposableStore;
    this.resultTextFileModel = resultTextFileModel;
    this.telemetry = telemetry;
    this._dialogService = _dialogService;
    this._storageService = _storageService;
    this.isDirty = observableFromEvent(Event.any(this.resultTextFileModel.onDidChangeDirty, this.resultTextFileModel.onDidSaveError), () => this.resultTextFileModel.isDirty());
    this.reported = false;
    this.dateTimeOpened = /* @__PURE__ */ new Date();
  }
  dispose() {
    this.disposableStore.dispose();
    super.dispose();
    this.reportClose(false);
  }
  reportClose(accepted) {
    if (!this.reported) {
      const remainingConflictCount = this.model.unhandledConflictsCount.get();
      const durationOpenedMs = (/* @__PURE__ */ new Date()).getTime() - this.dateTimeOpened.getTime();
      this.telemetry.reportMergeEditorClosed({
        durationOpenedSecs: durationOpenedMs / 1e3,
        remainingConflictCount,
        accepted,
        conflictCount: this.model.conflictCount,
        combinableConflictCount: this.model.combinableConflictCount,
        conflictsResolvedWithBase: this.model.conflictsResolvedWithBase,
        conflictsResolvedWithInput1: this.model.conflictsResolvedWithInput1,
        conflictsResolvedWithInput2: this.model.conflictsResolvedWithInput2,
        conflictsResolvedWithSmartCombination: this.model.conflictsResolvedWithSmartCombination,
        manuallySolvedConflictCountThatEqualNone: this.model.manuallySolvedConflictCountThatEqualNone,
        manuallySolvedConflictCountThatEqualSmartCombine: this.model.manuallySolvedConflictCountThatEqualSmartCombine,
        manuallySolvedConflictCountThatEqualInput1: this.model.manuallySolvedConflictCountThatEqualInput1,
        manuallySolvedConflictCountThatEqualInput2: this.model.manuallySolvedConflictCountThatEqualInput2,
        manuallySolvedConflictCountThatEqualNoneAndStartedWithBase: this.model.manuallySolvedConflictCountThatEqualNoneAndStartedWithBase,
        manuallySolvedConflictCountThatEqualNoneAndStartedWithInput1: this.model.manuallySolvedConflictCountThatEqualNoneAndStartedWithInput1,
        manuallySolvedConflictCountThatEqualNoneAndStartedWithInput2: this.model.manuallySolvedConflictCountThatEqualNoneAndStartedWithInput2,
        manuallySolvedConflictCountThatEqualNoneAndStartedWithBothNonSmart: this.model.manuallySolvedConflictCountThatEqualNoneAndStartedWithBothNonSmart,
        manuallySolvedConflictCountThatEqualNoneAndStartedWithBothSmart: this.model.manuallySolvedConflictCountThatEqualNoneAndStartedWithBothSmart
      });
      this.reported = true;
    }
  }
  async accept() {
    this.reportClose(true);
    await this.resultTextFileModel.save();
  }
  get resultUri() {
    return this.resultTextFileModel.resource;
  }
  async save(options) {
    await this.resultTextFileModel.save(options);
  }
  async revert(options) {
    await this.resultTextFileModel.revert(options);
  }
  shouldConfirmClose() {
    return true;
  }
  async confirmClose(inputModels) {
    const isMany = inputModels.length > 1;
    const someDirty = inputModels.some((m) => m.isDirty.get());
    const someUnhandledConflicts = inputModels.some((m) => m.model.hasUnhandledConflicts.get());
    if (someDirty) {
      const message = isMany ? localize(
        "workspace.messageN",
        "Do you want to save the changes you made to {0} files?",
        inputModels.length
      ) : localize(
        "workspace.message1",
        "Do you want to save the changes you made to {0}?",
        basename2(inputModels[0].resultUri)
      );
      const { result } = await this._dialogService.prompt({
        type: severity_default.Info,
        message,
        detail: someUnhandledConflicts ? isMany ? localize(
          "workspace.detailN.unhandled",
          "The files contain unhandled conflicts. Your changes will be lost if you don't save them."
        ) : localize(
          "workspace.detail1.unhandled",
          "The file contains unhandled conflicts. Your changes will be lost if you don't save them."
        ) : isMany ? localize(
          "workspace.detailN.handled",
          "Your changes will be lost if you don't save them."
        ) : localize(
          "workspace.detail1.handled",
          "Your changes will be lost if you don't save them."
        ),
        buttons: [
          {
            label: someUnhandledConflicts ? localize(
              { key: "workspace.saveWithConflict", comment: ["&& denotes a mnemonic"] },
              "&&Save with Conflicts"
            ) : localize({ key: "workspace.save", comment: ["&& denotes a mnemonic"] }, "&&Save"),
            run: () => 0
          },
          {
            label: localize(
              { key: "workspace.doNotSave", comment: ["&& denotes a mnemonic"] },
              "Do&&n't Save"
            ),
            run: () => 1
          }
        ],
        cancelButton: {
          run: () => 2
        }
      });
      return result;
    } else if (someUnhandledConflicts && !this._storageService.getBoolean(StorageCloseWithConflicts, 0, false)) {
      const { confirmed, checkboxChecked } = await this._dialogService.confirm({
        message: isMany ? localize(
          "workspace.messageN.nonDirty",
          "Do you want to close {0} merge editors?",
          inputModels.length
        ) : localize(
          "workspace.message1.nonDirty",
          "Do you want to close the merge editor for {0}?",
          basename2(inputModels[0].resultUri)
        ),
        detail: someUnhandledConflicts ? isMany ? localize(
          "workspace.detailN.unhandled.nonDirty",
          "The files contain unhandled conflicts."
        ) : localize(
          "workspace.detail1.unhandled.nonDirty",
          "The file contains unhandled conflicts."
        ) : void 0,
        primaryButton: someUnhandledConflicts ? localize(
          { key: "workspace.closeWithConflicts", comment: ["&& denotes a mnemonic"] },
          "&&Close with Conflicts"
        ) : localize({ key: "workspace.close", comment: ["&& denotes a mnemonic"] }, "&&Close"),
        checkbox: { label: localize("noMoreWarn", "Don't ask again") }
      });
      if (checkboxChecked) {
        this._storageService.store(StorageCloseWithConflicts, true, 0, 0);
      }
      return confirmed ? 0 : 2;
    } else {
      return 0;
    }
  }
};
WorkspaceMergeEditorInputModel = __decorate([
  __param(4, IDialogService),
  __param(5, IStorageService)
], WorkspaceMergeEditorInputModel);
async function toInputData(data, textModelService, store) {
  const ref = await textModelService.createModelReference(data.uri);
  store.add(ref);
  return {
    textModel: ref.object.textEditorModel,
    title: data.title,
    description: data.description,
    detail: data.detail
  };
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/telemetry.js
init_tslib_es6();
init_telemetry();
var MergeEditorTelemetry = class MergeEditorTelemetry2 {
  constructor(telemetryService) {
    this.telemetryService = telemetryService;
  }
  reportMergeEditorOpened(args) {
    this.telemetryService.publicLog2("mergeEditor.opened", {
      conflictCount: args.conflictCount,
      combinableConflictCount: args.combinableConflictCount,
      baseVisible: args.baseVisible,
      isColumnView: args.isColumnView,
      baseTop: args.baseTop
    });
  }
  reportLayoutChange(args) {
    this.telemetryService.publicLog2("mergeEditor.layoutChanged", {
      baseVisible: args.baseVisible,
      isColumnView: args.isColumnView,
      baseTop: args.baseTop
    });
  }
  reportMergeEditorClosed(args) {
    this.telemetryService.publicLog2("mergeEditor.closed", {
      conflictCount: args.conflictCount,
      combinableConflictCount: args.combinableConflictCount,
      durationOpenedSecs: args.durationOpenedSecs,
      remainingConflictCount: args.remainingConflictCount,
      accepted: args.accepted,
      conflictsResolvedWithBase: args.conflictsResolvedWithBase,
      conflictsResolvedWithInput1: args.conflictsResolvedWithInput1,
      conflictsResolvedWithInput2: args.conflictsResolvedWithInput2,
      conflictsResolvedWithSmartCombination: args.conflictsResolvedWithSmartCombination,
      manuallySolvedConflictCountThatEqualNone: args.manuallySolvedConflictCountThatEqualNone,
      manuallySolvedConflictCountThatEqualSmartCombine: args.manuallySolvedConflictCountThatEqualSmartCombine,
      manuallySolvedConflictCountThatEqualInput1: args.manuallySolvedConflictCountThatEqualInput1,
      manuallySolvedConflictCountThatEqualInput2: args.manuallySolvedConflictCountThatEqualInput2,
      manuallySolvedConflictCountThatEqualNoneAndStartedWithBase: args.manuallySolvedConflictCountThatEqualNoneAndStartedWithBase,
      manuallySolvedConflictCountThatEqualNoneAndStartedWithInput1: args.manuallySolvedConflictCountThatEqualNoneAndStartedWithInput1,
      manuallySolvedConflictCountThatEqualNoneAndStartedWithInput2: args.manuallySolvedConflictCountThatEqualNoneAndStartedWithInput2,
      manuallySolvedConflictCountThatEqualNoneAndStartedWithBothNonSmart: args.manuallySolvedConflictCountThatEqualNoneAndStartedWithBothNonSmart,
      manuallySolvedConflictCountThatEqualNoneAndStartedWithBothSmart: args.manuallySolvedConflictCountThatEqualNoneAndStartedWithBothSmart
    });
  }
  reportAcceptInvoked(inputNumber, otherAccepted) {
    this.telemetryService.publicLog2("mergeEditor.action.accept", {
      otherAccepted,
      isInput1: inputNumber === 1
    });
  }
  reportSmartCombinationInvoked(otherAccepted) {
    this.telemetryService.publicLog2("mergeEditor.action.smartCombination", {
      otherAccepted
    });
  }
  reportRemoveInvoked(inputNumber, otherAccepted) {
    this.telemetryService.publicLog2("mergeEditor.action.remove", {
      otherAccepted,
      isInput1: inputNumber === 1
    });
  }
  reportResetToBaseInvoked() {
    this.telemetryService.publicLog2("mergeEditor.action.resetToBase", {});
  }
  reportNavigationToNextConflict() {
    this.telemetryService.publicLog2("mergeEditor.action.goToNextConflict", {});
  }
  reportNavigationToPreviousConflict() {
    this.telemetryService.publicLog2("mergeEditor.action.goToPreviousConflict", {});
  }
  reportConflictCounterClicked() {
    this.telemetryService.publicLog2("mergeEditor.action.conflictCounterClicked", {});
  }
};
MergeEditorTelemetry = __decorate([
  __param(0, ITelemetryService)
], MergeEditorTelemetry);

// node_modules/vscode/vscode/src/vs/workbench/contrib/mergeEditor/browser/mergeEditorInput.js
var MergeEditorInput_1;
var _a19;
var MergeEditorInput = (_a19 = class extends AbstractTextResourceEditorInput {
  get useWorkingCopy() {
    return this.configurationService.getValue("mergeEditor.useWorkingCopy") ?? false;
  }
  constructor(base, input1, input2, result, _instaService, editorService, textFileService, labelService, fileService, configurationService, filesConfigurationService) {
    super(result, void 0, editorService, textFileService, labelService, fileService, filesConfigurationService);
    this.base = base;
    this.input1 = input1;
    this.input2 = input2;
    this.result = result;
    this._instaService = _instaService;
    this.configurationService = configurationService;
    this.closeHandler = {
      showConfirm: () => {
        var _a30;
        return ((_a30 = this._inputModel) == null ? void 0 : _a30.shouldConfirmClose()) ?? false;
      },
      confirm: async (editors) => {
        assertFn(() => editors.every((e) => e.editor instanceof MergeEditorInput_1));
        const inputModels = editors.map((e) => e.editor._inputModel).filter(isDefined);
        return await this._inputModel.confirmClose(inputModels);
      }
    };
    this.mergeEditorModeFactory = this._instaService.createInstance(this.useWorkingCopy ? TempFileMergeEditorModeFactory : WorkspaceMergeEditorModeFactory, this._instaService.createInstance(MergeEditorTelemetry));
  }
  dispose() {
    super.dispose();
  }
  get typeId() {
    return MergeEditorInput_1.ID;
  }
  get editorId() {
    return DEFAULT_EDITOR_ASSOCIATION.id;
  }
  get capabilities() {
    let capabilities = super.capabilities | 256;
    if (this.useWorkingCopy) {
      capabilities |= 4;
    }
    return capabilities;
  }
  getName() {
    return localize("name", "Merging: {0}", super.getName());
  }
  async resolve() {
    if (!this._inputModel) {
      const inputModel = this._register(await this.mergeEditorModeFactory.createInputModel({
        base: this.base,
        input1: this.input1,
        input2: this.input2,
        result: this.result
      }));
      this._inputModel = inputModel;
      this._register(autorun((reader) => {
        inputModel.isDirty.read(reader);
        this._onDidChangeDirty.fire();
      }));
      await this._inputModel.model.onInitialized;
    }
    return this._inputModel;
  }
  async accept() {
    var _a30;
    await ((_a30 = this._inputModel) == null ? void 0 : _a30.accept());
  }
  async save(group, options) {
    var _a30;
    await ((_a30 = this._inputModel) == null ? void 0 : _a30.save(options));
    return void 0;
  }
  toUntyped() {
    return {
      input1: { resource: this.input1.uri, label: this.input1.title, description: this.input1.description, detail: this.input1.detail },
      input2: { resource: this.input2.uri, label: this.input2.title, description: this.input2.description, detail: this.input2.detail },
      base: { resource: this.base },
      result: { resource: this.result },
      options: {
        override: this.typeId
      }
    };
  }
  matches(otherInput) {
    var _a30, _b;
    if (this === otherInput) {
      return true;
    }
    if (otherInput instanceof MergeEditorInput_1) {
      return isEqual(this.base, otherInput.base) && isEqual(this.input1.uri, otherInput.input1.uri) && isEqual(this.input2.uri, otherInput.input2.uri) && isEqual(this.result, otherInput.result);
    }
    if (isResourceMergeEditorInput(otherInput)) {
      return (this.editorId === ((_a30 = otherInput.options) == null ? void 0 : _a30.override) || ((_b = otherInput.options) == null ? void 0 : _b.override) === void 0) && isEqual(this.base, otherInput.base.resource) && isEqual(this.input1.uri, otherInput.input1.resource) && isEqual(this.input2.uri, otherInput.input2.resource) && isEqual(this.result, otherInput.result.resource);
    }
    return false;
  }
  async revert(group, options) {
    var _a30;
    return (_a30 = this._inputModel) == null ? void 0 : _a30.revert(options);
  }
  isDirty() {
    var _a30;
    return ((_a30 = this._inputModel) == null ? void 0 : _a30.isDirty.get()) ?? false;
  }
  setLanguageId(languageId, source) {
    var _a30;
    (_a30 = this._inputModel) == null ? void 0 : _a30.model.setLanguageId(languageId, source);
  }
}, MergeEditorInput_1 = _a19, _a19.ID = "mergeEditor.Input", _a19);
MergeEditorInput = MergeEditorInput_1 = __decorate([
  __param(4, IInstantiationService),
  __param(5, IEditorService),
  __param(6, ITextFileService),
  __param(7, ILabelService),
  __param(8, IFileService),
  __param(9, IConfigurationService),
  __param(10, IFilesConfigurationService)
], MergeEditorInput);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadEditorTabs.js
init_log();
var MainThreadEditorTabs = class MainThreadEditorTabs2 {
  constructor(extHostContext, _editorGroupsService, _configurationService, _logService, editorService) {
    this._editorGroupsService = _editorGroupsService;
    this._configurationService = _configurationService;
    this._logService = _logService;
    this._dispoables = new DisposableStore();
    this._tabGroupModel = [];
    this._groupLookup = /* @__PURE__ */ new Map();
    this._tabInfoLookup = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostEditorTabs);
    this._dispoables.add(editorService.onDidEditorsChange((event) => {
      try {
        this._updateTabsModel(event);
      } catch {
        this._logService.error("Failed to update model, rebuilding");
        this._createTabsModel();
      }
    }));
    this._dispoables.add(this._editorGroupsService.onDidAddGroup(() => this._createTabsModel()));
    this._dispoables.add(this._editorGroupsService.onDidRemoveGroup(() => this._createTabsModel()));
    this._editorGroupsService.whenReady.then(() => this._createTabsModel());
  }
  dispose() {
    this._groupLookup.clear();
    this._tabInfoLookup.clear();
    this._dispoables.dispose();
  }
  _buildTabObject(group, editor, editorIndex) {
    const editorId = editor.editorId;
    const tab = {
      id: this._generateTabId(editor, group.id),
      label: editor.getName(),
      editorId,
      input: this._editorInputToDto(editor),
      isPinned: group.isSticky(editorIndex),
      isPreview: !group.isPinned(editorIndex),
      isActive: group.isActive(editor),
      isDirty: editor.isDirty()
    };
    return tab;
  }
  _editorInputToDto(editor) {
    if (editor instanceof MergeEditorInput) {
      return {
        kind: 3,
        base: editor.base,
        input1: editor.input1.uri,
        input2: editor.input2.uri,
        result: editor.resource
      };
    }
    if (editor instanceof AbstractTextResourceEditorInput) {
      return {
        kind: 1,
        uri: editor.resource
      };
    }
    if (editor instanceof SideBySideEditorInput && !(editor instanceof DiffEditorInput)) {
      const primaryResource = editor.primary.resource;
      const secondaryResource = editor.secondary.resource;
      if (editor.primary instanceof AbstractTextResourceEditorInput && editor.secondary instanceof AbstractTextResourceEditorInput && isEqual(primaryResource, secondaryResource) && primaryResource && secondaryResource) {
        return {
          kind: 1,
          uri: primaryResource
        };
      }
      return { kind: 0 };
    }
    if (editor instanceof NotebookEditorInput) {
      return {
        kind: 4,
        notebookType: editor.viewType,
        uri: editor.resource
      };
    }
    if (editor instanceof CustomEditorInput) {
      return {
        kind: 6,
        viewType: editor.viewType,
        uri: editor.resource
      };
    }
    if (editor instanceof WebviewInput) {
      return {
        kind: 7,
        viewType: editor.viewType
      };
    }
    if (editor instanceof TerminalEditorInput) {
      return {
        kind: 8
      };
    }
    if (editor instanceof DiffEditorInput) {
      if (editor.modified instanceof AbstractTextResourceEditorInput && editor.original instanceof AbstractTextResourceEditorInput) {
        return {
          kind: 2,
          modified: editor.modified.resource,
          original: editor.original.resource
        };
      }
      if (editor.modified instanceof NotebookEditorInput && editor.original instanceof NotebookEditorInput) {
        return {
          kind: 5,
          notebookType: editor.original.viewType,
          modified: editor.modified.resource,
          original: editor.original.resource
        };
      }
    }
    if (editor instanceof InteractiveEditorInput) {
      return {
        kind: 9,
        uri: editor.resource,
        inputBoxUri: editor.inputResource
      };
    }
    return { kind: 0 };
  }
  _generateTabId(editor, groupId) {
    var _a30, _b;
    let resourceString;
    const resource = EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.BOTH });
    if (resource instanceof URI) {
      resourceString = resource.toString();
    } else {
      resourceString = `${(_a30 = resource == null ? void 0 : resource.primary) == null ? void 0 : _a30.toString()}-${(_b = resource == null ? void 0 : resource.secondary) == null ? void 0 : _b.toString()}`;
    }
    return `${groupId}~${editor.editorId}-${editor.typeId}-${resourceString} `;
  }
  _onDidGroupActivate() {
    const activeGroupId = this._editorGroupsService.activeGroup.id;
    const activeGroup = this._groupLookup.get(activeGroupId);
    if (activeGroup) {
      activeGroup.isActive = true;
      this._proxy.$acceptTabGroupUpdate(activeGroup);
    }
  }
  _onDidTabLabelChange(groupId, editorInput, editorIndex) {
    const tabId = this._generateTabId(editorInput, groupId);
    const tabInfo = this._tabInfoLookup.get(tabId);
    if (tabInfo) {
      tabInfo.tab.label = editorInput.getName();
      this._proxy.$acceptTabOperation({
        groupId,
        index: editorIndex,
        tabDto: tabInfo.tab,
        kind: 2
      });
    } else {
      this._logService.error("Invalid model for label change, rebuilding");
      this._createTabsModel();
    }
  }
  _onDidTabOpen(groupId, editorInput, editorIndex) {
    var _a30;
    const group = this._editorGroupsService.getGroup(groupId);
    const groupInModel = this._groupLookup.get(groupId) !== void 0;
    if (!group || !groupInModel) {
      this._createTabsModel();
      return;
    }
    const tabs = (_a30 = this._groupLookup.get(groupId)) == null ? void 0 : _a30.tabs;
    if (!tabs) {
      return;
    }
    const tabObject = this._buildTabObject(group, editorInput, editorIndex);
    tabs.splice(editorIndex, 0, tabObject);
    this._tabInfoLookup.set(this._generateTabId(editorInput, groupId), { group, editorInput, tab: tabObject });
    this._proxy.$acceptTabOperation({
      groupId,
      index: editorIndex,
      tabDto: tabObject,
      kind: 0
    });
  }
  _onDidTabClose(groupId, editorIndex) {
    var _a30, _b;
    const group = this._editorGroupsService.getGroup(groupId);
    const tabs = (_a30 = this._groupLookup.get(groupId)) == null ? void 0 : _a30.tabs;
    if (!group || !tabs) {
      this._createTabsModel();
      return;
    }
    const removedTab = tabs.splice(editorIndex, 1);
    if (removedTab.length === 0) {
      return;
    }
    this._tabInfoLookup.delete(((_b = removedTab[0]) == null ? void 0 : _b.id) ?? "");
    this._proxy.$acceptTabOperation({
      groupId,
      index: editorIndex,
      tabDto: removedTab[0],
      kind: 1
    });
  }
  _onDidTabActiveChange(groupId, editorIndex) {
    var _a30;
    const tabs = (_a30 = this._groupLookup.get(groupId)) == null ? void 0 : _a30.tabs;
    if (!tabs) {
      return;
    }
    const activeTab = tabs[editorIndex];
    activeTab.isActive = true;
    this._proxy.$acceptTabOperation({
      groupId,
      index: editorIndex,
      tabDto: activeTab,
      kind: 2
    });
  }
  _onDidTabDirty(groupId, editorIndex, editor) {
    const tabId = this._generateTabId(editor, groupId);
    const tabInfo = this._tabInfoLookup.get(tabId);
    if (!tabInfo) {
      this._logService.error("Invalid model for dirty change, rebuilding");
      this._createTabsModel();
      return;
    }
    tabInfo.tab.isDirty = editor.isDirty();
    this._proxy.$acceptTabOperation({
      groupId,
      index: editorIndex,
      tabDto: tabInfo.tab,
      kind: 2
    });
  }
  _onDidTabPinChange(groupId, editorIndex, editor) {
    const tabId = this._generateTabId(editor, groupId);
    const tabInfo = this._tabInfoLookup.get(tabId);
    const group = tabInfo == null ? void 0 : tabInfo.group;
    const tab = tabInfo == null ? void 0 : tabInfo.tab;
    if (!group || !tab) {
      this._logService.error("Invalid model for sticky change, rebuilding");
      this._createTabsModel();
      return;
    }
    tab.isPinned = group.isSticky(editorIndex);
    this._proxy.$acceptTabOperation({
      groupId,
      index: editorIndex,
      tabDto: tab,
      kind: 2
    });
  }
  _onDidTabPreviewChange(groupId, editorIndex, editor) {
    const tabId = this._generateTabId(editor, groupId);
    const tabInfo = this._tabInfoLookup.get(tabId);
    const group = tabInfo == null ? void 0 : tabInfo.group;
    const tab = tabInfo == null ? void 0 : tabInfo.tab;
    if (!group || !tab) {
      this._logService.error("Invalid model for sticky change, rebuilding");
      this._createTabsModel();
      return;
    }
    tab.isPreview = !group.isPinned(editorIndex);
    this._proxy.$acceptTabOperation({
      kind: 2,
      groupId,
      tabDto: tab,
      index: editorIndex
    });
  }
  _onDidTabMove(groupId, editorIndex, oldEditorIndex, editor) {
    var _a30;
    const tabs = (_a30 = this._groupLookup.get(groupId)) == null ? void 0 : _a30.tabs;
    if (!tabs) {
      this._logService.error("Invalid model for move change, rebuilding");
      this._createTabsModel();
      return;
    }
    const removedTab = tabs.splice(oldEditorIndex, 1);
    if (removedTab.length === 0) {
      return;
    }
    tabs.splice(editorIndex, 0, removedTab[0]);
    this._proxy.$acceptTabOperation({
      kind: 3,
      groupId,
      tabDto: removedTab[0],
      index: editorIndex,
      oldIndex: oldEditorIndex
    });
  }
  _createTabsModel() {
    this._tabGroupModel = [];
    this._groupLookup.clear();
    this._tabInfoLookup.clear();
    let tabs = [];
    for (const group of this._editorGroupsService.groups) {
      const currentTabGroupModel = {
        groupId: group.id,
        isActive: group.id === this._editorGroupsService.activeGroup.id,
        viewColumn: editorGroupToColumn(this._editorGroupsService, group),
        tabs: []
      };
      group.editors.forEach((editor, editorIndex) => {
        const tab = this._buildTabObject(group, editor, editorIndex);
        tabs.push(tab);
        this._tabInfoLookup.set(this._generateTabId(editor, group.id), {
          group,
          tab,
          editorInput: editor
        });
      });
      currentTabGroupModel.tabs = tabs;
      this._tabGroupModel.push(currentTabGroupModel);
      this._groupLookup.set(group.id, currentTabGroupModel);
      tabs = [];
    }
    this._proxy.$acceptEditorTabModel(this._tabGroupModel);
  }
  _updateTabsModel(changeEvent) {
    const event = changeEvent.event;
    const groupId = changeEvent.groupId;
    switch (event.kind) {
      case 0:
        if (groupId === this._editorGroupsService.activeGroup.id) {
          this._onDidGroupActivate();
          break;
        } else {
          return;
        }
      case 7:
        if (event.editor !== void 0 && event.editorIndex !== void 0) {
          this._onDidTabLabelChange(groupId, event.editor, event.editorIndex);
          break;
        }
      case 3:
        if (event.editor !== void 0 && event.editorIndex !== void 0) {
          this._onDidTabOpen(groupId, event.editor, event.editorIndex);
          break;
        }
      case 4:
        if (event.editorIndex !== void 0) {
          this._onDidTabClose(groupId, event.editorIndex);
          break;
        }
      case 6:
        if (event.editorIndex !== void 0) {
          this._onDidTabActiveChange(groupId, event.editorIndex);
          break;
        }
      case 11:
        if (event.editorIndex !== void 0 && event.editor !== void 0) {
          this._onDidTabDirty(groupId, event.editorIndex, event.editor);
          break;
        }
      case 10:
        if (event.editorIndex !== void 0 && event.editor !== void 0) {
          this._onDidTabPinChange(groupId, event.editorIndex, event.editor);
          break;
        }
      case 9:
        if (event.editorIndex !== void 0 && event.editor !== void 0) {
          this._onDidTabPreviewChange(groupId, event.editorIndex, event.editor);
          break;
        }
      case 5:
        if (isGroupEditorMoveEvent(event) && event.editor && event.editorIndex !== void 0 && event.oldEditorIndex !== void 0) {
          this._onDidTabMove(groupId, event.editorIndex, event.oldEditorIndex, event.editor);
          break;
        }
      default:
        this._createTabsModel();
    }
  }
  $moveTab(tabId, index, viewColumn, preserveFocus) {
    const groupId = columnToEditorGroup(this._editorGroupsService, this._configurationService, viewColumn);
    const tabInfo = this._tabInfoLookup.get(tabId);
    const tab = tabInfo == null ? void 0 : tabInfo.tab;
    if (!tab) {
      throw new Error(`Attempted to close tab with id ${tabId} which does not exist`);
    }
    let targetGroup;
    const sourceGroup = this._editorGroupsService.getGroup(tabInfo.group.id);
    if (!sourceGroup) {
      return;
    }
    if (this._groupLookup.get(groupId) === void 0) {
      let direction = 3;
      if (viewColumn === SIDE_GROUP) {
        direction = preferredSideBySideGroupDirection(this._configurationService);
      }
      targetGroup = this._editorGroupsService.addGroup(this._editorGroupsService.groups[this._editorGroupsService.groups.length - 1], direction, void 0);
    } else {
      targetGroup = this._editorGroupsService.getGroup(groupId);
    }
    if (!targetGroup) {
      return;
    }
    if (index < 0 || index > targetGroup.editors.length) {
      index = targetGroup.editors.length;
    }
    const editorInput = tabInfo == null ? void 0 : tabInfo.editorInput;
    if (!editorInput) {
      return;
    }
    sourceGroup.moveEditor(editorInput, targetGroup, { index, preserveFocus });
    return;
  }
  async $closeTab(tabIds, preserveFocus) {
    const groups = /* @__PURE__ */ new Map();
    for (const tabId of tabIds) {
      const tabInfo = this._tabInfoLookup.get(tabId);
      const tab = tabInfo == null ? void 0 : tabInfo.tab;
      const group = tabInfo == null ? void 0 : tabInfo.group;
      const editorTab = tabInfo == null ? void 0 : tabInfo.editorInput;
      if (!group || !tab || !tabInfo || !editorTab) {
        continue;
      }
      const groupEditors = groups.get(group);
      if (!groupEditors) {
        groups.set(group, [editorTab]);
      } else {
        groupEditors.push(editorTab);
      }
    }
    const results = [];
    for (const [group, editors] of groups) {
      results.push(await group.closeEditors(editors, { preserveFocus }));
    }
    return results.every((result) => result);
  }
  async $closeGroup(groupIds, preserveFocus) {
    const groupCloseResults = [];
    for (const groupId of groupIds) {
      const group = this._editorGroupsService.getGroup(groupId);
      if (group) {
        groupCloseResults.push(await group.closeAllEditors());
        if (group.count === 0 && this._editorGroupsService.getGroup(group.id)) {
          this._editorGroupsService.removeGroup(group);
        }
      }
    }
    return groupCloseResults.every((result) => result);
  }
};
MainThreadEditorTabs = __decorate([
  extHostNamedCustomer(MainContext.MainThreadEditorTabs),
  __param(1, IEditorGroupsService),
  __param(2, IConfigurationService),
  __param(3, ILogService),
  __param(4, IEditorService)
], MainThreadEditorTabs);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadErrors.js
init_tslib_es6();
init_errors();
init_extHost_protocol();
var MainThreadErrors = class MainThreadErrors2 {
  dispose() {
  }
  $onUnexpectedError(err) {
    if (err && err.$isError) {
      const { name, message, stack } = err;
      err = err.noTelemetry ? new ErrorNoTelemetry() : new Error();
      err.message = message;
      err.name = name;
      err.stack = stack;
    }
    onUnexpectedError(err);
  }
};
MainThreadErrors = __decorate([
  extHostNamedCustomer(MainContext.MainThreadErrors)
], MainThreadErrors);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadExtensionService.js
init_tslib_es6();
init_actions();
init_cancellation();
init_network();
init_uri();
init_nls();
init_commands();
init_remoteAuthorityResolver();
init_extHost_protocol();
var MainThreadExtensionService = class MainThreadExtensionService2 {
  constructor(extHostContext, _extensionService2, _notificationService, _extensionsWorkbenchService, _hostService, _extensionEnablementService, _timerService, _commandService, _environmentService) {
    this._extensionService = _extensionService2;
    this._notificationService = _notificationService;
    this._extensionsWorkbenchService = _extensionsWorkbenchService;
    this._hostService = _hostService;
    this._extensionEnablementService = _extensionEnablementService;
    this._timerService = _timerService;
    this._commandService = _commandService;
    this._environmentService = _environmentService;
    this._extensionHostKind = extHostContext.extensionHostKind;
    const internalExtHostContext = extHostContext;
    this._internalExtensionService = internalExtHostContext.internalExtensionService;
    internalExtHostContext._setExtensionHostProxy(new ExtensionHostProxy(extHostContext.getProxy(ExtHostContext.ExtHostExtensionService)));
    internalExtHostContext._setAllMainProxyIdentifiers(Object.keys(MainContext).map((key) => MainContext[key]));
  }
  dispose() {
  }
  $getExtension(extensionId) {
    return this._extensionService.getExtension(extensionId);
  }
  $activateExtension(extensionId, reason) {
    return this._internalExtensionService._activateById(extensionId, reason);
  }
  async $onWillActivateExtension(extensionId) {
    this._internalExtensionService._onWillActivateExtension(extensionId);
  }
  $onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) {
    this._internalExtensionService._onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason);
  }
  $onExtensionRuntimeError(extensionId, data) {
    const error = new Error();
    error.name = data.name;
    error.message = data.message;
    error.stack = data.stack;
    this._internalExtensionService._onExtensionRuntimeError(extensionId, error);
    console.error(`[${extensionId.value}]${error.message}`);
    console.error(error.stack);
  }
  async $onExtensionActivationError(extensionId, data, missingExtensionDependency) {
    const error = new Error();
    error.name = data.name;
    error.message = data.message;
    error.stack = data.stack;
    this._internalExtensionService._onDidActivateExtensionError(extensionId, error);
    if (missingExtensionDependency) {
      const extension = await this._extensionService.getExtension(extensionId.value);
      if (extension) {
        const local = await this._extensionsWorkbenchService.queryLocal();
        const installedDependency = local.find((i) => areSameExtensions(i.identifier, { id: missingExtensionDependency.dependency }));
        if (installedDependency == null ? void 0 : installedDependency.local) {
          await this._handleMissingInstalledDependency(extension, installedDependency.local);
          return;
        } else {
          await this._handleMissingNotInstalledDependency(extension, missingExtensionDependency.dependency);
          return;
        }
      }
    }
    const isDev = !this._environmentService.isBuilt || this._environmentService.isExtensionDevelopment;
    if (isDev) {
      this._notificationService.error(error);
      return;
    }
    console.error(error.message);
  }
  async _handleMissingInstalledDependency(extension, missingInstalledDependency) {
    const extName = extension.displayName || extension.name;
    if (this._extensionEnablementService.isEnabled(missingInstalledDependency)) {
      this._notificationService.notify({
        severity: severity_default.Error,
        message: localize(
          "reload window",
          "Cannot activate the '{0}' extension because it depends on the '{1}' extension, which is not loaded. Would you like to reload the window to load the extension?",
          extName,
          missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
        ),
        actions: {
          primary: [new Action("reload", localize("reload", "Reload Window"), "", true, () => this._hostService.reload())]
        }
      });
    } else {
      const enablementState = this._extensionEnablementService.getEnablementState(missingInstalledDependency);
      if (enablementState === 4) {
        this._notificationService.notify({
          severity: severity_default.Error,
          message: localize(
            "notSupportedInWorkspace",
            "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is not supported in the current workspace",
            extName,
            missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
          )
        });
      } else if (enablementState === 0) {
        this._notificationService.notify({
          severity: severity_default.Error,
          message: localize(
            "restrictedMode",
            "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is not supported in Restricted Mode",
            extName,
            missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
          ),
          actions: {
            primary: [new Action("manageWorkspaceTrust", localize("manageWorkspaceTrust", "Manage Workspace Trust"), "", true, () => this._commandService.executeCommand("workbench.trust.manage"))]
          }
        });
      } else if (this._extensionEnablementService.canChangeEnablement(missingInstalledDependency)) {
        this._notificationService.notify({
          severity: severity_default.Error,
          message: localize(
            "disabledDep",
            "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is disabled. Would you like to enable the extension and reload the window?",
            extName,
            missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
          ),
          actions: {
            primary: [new Action("enable", localize("enable dep", "Enable and Reload"), "", true, () => this._extensionEnablementService.setEnablement([missingInstalledDependency], enablementState === 6 ? 8 : 9).then(() => this._hostService.reload(), (e) => this._notificationService.error(e)))]
          }
        });
      } else {
        this._notificationService.notify({
          severity: severity_default.Error,
          message: localize(
            "disabledDepNoAction",
            "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is disabled.",
            extName,
            missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
          )
        });
      }
    }
  }
  async _handleMissingNotInstalledDependency(extension, missingDependency) {
    const extName = extension.displayName || extension.name;
    let dependencyExtension = null;
    try {
      dependencyExtension = (await this._extensionsWorkbenchService.getExtensions([{ id: missingDependency }], CancellationToken.None))[0];
    } catch (err) {
    }
    if (dependencyExtension) {
      this._notificationService.notify({
        severity: severity_default.Error,
        message: localize(
          "uninstalledDep",
          "Cannot activate the '{0}' extension because it depends on the '{1}' extension, which is not installed. Would you like to install the extension and reload the window?",
          extName,
          dependencyExtension.displayName
        ),
        actions: {
          primary: [new Action("install", localize("install missing dep", "Install and Reload"), "", true, () => this._extensionsWorkbenchService.install(dependencyExtension).then(() => this._hostService.reload(), (e) => this._notificationService.error(e)))]
        }
      });
    } else {
      this._notificationService.error(localize(
        "unknownDep",
        "Cannot activate the '{0}' extension because it depends on an unknown '{1}' extension.",
        extName,
        missingDependency
      ));
    }
  }
  async $setPerformanceMarks(marks) {
    if (this._extensionHostKind === 1) {
      this._timerService.setPerformanceMarks("localExtHost", marks);
    } else if (this._extensionHostKind === 2) {
      this._timerService.setPerformanceMarks("workerExtHost", marks);
    } else {
      this._timerService.setPerformanceMarks("remoteExtHost", marks);
    }
  }
  async $asBrowserUri(uri) {
    return FileAccess.uriToBrowserUri(URI.revive(uri));
  }
  async $getAllStaticBrowserUris() {
    return Array.from(FileAccess.getRegisteredBrowserUris(), (uri) => [
      uri,
      FileAccess.uriToBrowserUri(uri)
    ]);
  }
};
MainThreadExtensionService = __decorate([
  extHostNamedCustomer(MainContext.MainThreadExtensionService),
  __param(1, IExtensionService),
  __param(2, INotificationService),
  __param(3, IExtensionsWorkbenchService),
  __param(4, IHostService),
  __param(5, IWorkbenchExtensionEnablementService),
  __param(6, ITimerService),
  __param(7, ICommandService),
  __param(8, IWorkbenchEnvironmentService)
], MainThreadExtensionService);
var ExtensionHostProxy = class {
  constructor(_actual) {
    this._actual = _actual;
  }
  async resolveAuthority(remoteAuthority, resolveAttempt) {
    const resolved = reviveResolveAuthorityResult(await this._actual.$resolveAuthority(remoteAuthority, resolveAttempt));
    return resolved;
  }
  async getCanonicalURI(remoteAuthority, uri) {
    const uriComponents = await this._actual.$getCanonicalURI(remoteAuthority, uri);
    return uriComponents ? URI.revive(uriComponents) : uriComponents;
  }
  startExtensionHost(extensionsDelta) {
    return this._actual.$startExtensionHost(extensionsDelta);
  }
  extensionTestsExecute() {
    return this._actual.$extensionTestsExecute();
  }
  activateByEvent(activationEvent, activationKind) {
    return this._actual.$activateByEvent(activationEvent, activationKind);
  }
  activate(extensionId, reason) {
    return this._actual.$activate(extensionId, reason);
  }
  setRemoteEnvironment(env2) {
    return this._actual.$setRemoteEnvironment(env2);
  }
  updateRemoteConnectionData(connectionData) {
    return this._actual.$updateRemoteConnectionData(connectionData);
  }
  deltaExtensions(extensionsDelta) {
    return this._actual.$deltaExtensions(extensionsDelta);
  }
  test_latency(n2) {
    return this._actual.$test_latency(n2);
  }
  test_up(b) {
    return this._actual.$test_up(b);
  }
  test_down(size) {
    return this._actual.$test_down(size);
  }
};
function reviveResolveAuthorityResult(result) {
  if (result.type === "ok") {
    return {
      type: "ok",
      value: {
        ...result.value,
        authority: reviveResolvedAuthority(result.value.authority)
      }
    };
  } else {
    return result;
  }
}
function reviveResolvedAuthority(resolvedAuthority) {
  return {
    ...resolvedAuthority,
    connectTo: reviveConnection(resolvedAuthority.connectTo)
  };
}
function reviveConnection(connection) {
  if (connection.type === 0) {
    return new WebSocketRemoteConnection(connection.host, connection.port);
  }
  return new ManagedRemoteConnection(connection.id);
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadFileSystem.js
init_tslib_es6();
init_event();
init_lifecycle();
init_uri();
init_files();
init_extHost_protocol();
init_buffer();
init_log();
init_configuration();

// node_modules/vscode/vscode/src/vs/workbench/services/files/common/files.js
init_files();
init_instantiation();
var IWorkbenchFileService = refineServiceDecorator(IFileService);

// node_modules/vscode/vscode/src/vs/platform/files/common/watcher.js
init_lifecycle();
init_path();
var _AbstractWatcherClient = class _AbstractWatcherClient extends Disposable {
  constructor(onFileChanges, onLogMessage, verboseLogging, options) {
    super();
    this.onFileChanges = onFileChanges;
    this.onLogMessage = onLogMessage;
    this.verboseLogging = verboseLogging;
    this.options = options;
    this.watcherDisposables = this._register(new MutableDisposable());
    this.requests = void 0;
    this.restartCounter = 0;
  }
  init() {
    const disposables = new DisposableStore();
    this.watcherDisposables.value = disposables;
    this.watcher = this.createWatcher(disposables);
    this.watcher.setVerboseLogging(this.verboseLogging);
    disposables.add(this.watcher.onDidChangeFile((changes) => this.onFileChanges(changes)));
    disposables.add(this.watcher.onDidLogMessage((msg) => this.onLogMessage(msg)));
    disposables.add(this.watcher.onDidError((error) => this.onError(error)));
  }
  onError(error) {
    if (this.options.restartOnError) {
      if (this.restartCounter < _AbstractWatcherClient.MAX_RESTARTS && this.requests) {
        this.error(`restarting watcher after error: ${error}`);
        this.restart(this.requests);
      } else {
        this.error(`gave up attempting to restart watcher after error: ${error}`);
      }
    } else {
      this.error(error);
    }
  }
  restart(requests) {
    this.restartCounter++;
    this.init();
    this.watch(requests);
  }
  async watch(requests) {
    var _a30;
    this.requests = requests;
    await ((_a30 = this.watcher) == null ? void 0 : _a30.watch(requests));
  }
  async setVerboseLogging(verboseLogging) {
    var _a30;
    this.verboseLogging = verboseLogging;
    await ((_a30 = this.watcher) == null ? void 0 : _a30.setVerboseLogging(verboseLogging));
  }
  error(message) {
    this.onLogMessage({ type: "error", message: `[File Watcher (${this.options.type})] ${message}` });
  }
  trace(message) {
    this.onLogMessage({ type: "trace", message: `[File Watcher (${this.options.type})] ${message}` });
  }
  dispose() {
    this.watcher = void 0;
    return super.dispose();
  }
};
_AbstractWatcherClient.MAX_RESTARTS = 5;
var AbstractWatcherClient = _AbstractWatcherClient;
function normalizeWatcherPattern(path, pattern) {
  if (typeof pattern === "string" && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {
    return { base: path, pattern };
  }
  return pattern;
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadFileSystem.js
init_strings();
var MainThreadFileSystem_1;
var MainThreadFileSystem = MainThreadFileSystem_1 = class MainThreadFileSystem2 {
  constructor(extHostContext, _fileService, _contextService, _logService, _configurationService) {
    this._fileService = _fileService;
    this._contextService = _contextService;
    this._logService = _logService;
    this._configurationService = _configurationService;
    this._fileProvider = new DisposableMap();
    this._disposables = new DisposableStore();
    this._watches = new DisposableMap();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostFileSystem);
    const infoProxy = extHostContext.getProxy(ExtHostContext.ExtHostFileSystemInfo);
    for (const entry of _fileService.listCapabilities()) {
      infoProxy.$acceptProviderInfos(URI.from({ scheme: entry.scheme, path: "/dummy" }), entry.capabilities);
    }
    this._disposables.add(_fileService.onDidChangeFileSystemProviderRegistrations((e) => {
      var _a30;
      return infoProxy.$acceptProviderInfos(URI.from({ scheme: e.scheme, path: "/dummy" }), ((_a30 = e.provider) == null ? void 0 : _a30.capabilities) ?? null);
    }));
    this._disposables.add(_fileService.onDidChangeFileSystemProviderCapabilities((e) => infoProxy.$acceptProviderInfos(URI.from({ scheme: e.scheme, path: "/dummy" }), e.provider.capabilities)));
  }
  dispose() {
    this._disposables.dispose();
    this._fileProvider.dispose();
    this._watches.dispose();
  }
  async $registerFileSystemProvider(handle, scheme, capabilities, readonlyMessage) {
    this._fileProvider.set(handle, new RemoteFileSystemProvider(
      this._fileService,
      scheme,
      capabilities,
      readonlyMessage,
      handle,
      this._proxy
    ));
  }
  $unregisterProvider(handle) {
    this._fileProvider.deleteAndDispose(handle);
  }
  $onFileSystemChange(handle, changes) {
    const fileProvider = this._fileProvider.get(handle);
    if (!fileProvider) {
      throw new Error("Unknown file provider");
    }
    fileProvider.$onFileSystemChange(changes);
  }
  $stat(uri) {
    return this._fileService.stat(URI.revive(uri)).then((stat) => {
      return {
        ctime: stat.ctime,
        mtime: stat.mtime,
        size: stat.size,
        permissions: stat.readonly ? FilePermission.Readonly : void 0,
        type: MainThreadFileSystem_1._asFileType(stat)
      };
    }).catch(MainThreadFileSystem_1._handleError);
  }
  $readdir(uri) {
    return this._fileService.resolve(URI.revive(uri), { resolveMetadata: false }).then((stat) => {
      if (!stat.isDirectory) {
        const err = new Error(stat.name);
        err.name = FileSystemProviderErrorCode.FileNotADirectory;
        throw err;
      }
      return !stat.children ? [] : stat.children.map((child) => [child.name, MainThreadFileSystem_1._asFileType(child)]);
    }).catch(MainThreadFileSystem_1._handleError);
  }
  static _asFileType(stat) {
    let res = 0;
    if (stat.isFile) {
      res += FileType.File;
    } else if (stat.isDirectory) {
      res += FileType.Directory;
    }
    if (stat.isSymbolicLink) {
      res += FileType.SymbolicLink;
    }
    return res;
  }
  $readFile(uri) {
    return this._fileService.readFile(URI.revive(uri)).then((file) => file.value).catch(MainThreadFileSystem_1._handleError);
  }
  $writeFile(uri, content) {
    return this._fileService.writeFile(URI.revive(uri), content).then(() => void 0).catch(MainThreadFileSystem_1._handleError);
  }
  $rename(source, target, opts) {
    return this._fileService.move(URI.revive(source), URI.revive(target), opts.overwrite).then(() => void 0).catch(MainThreadFileSystem_1._handleError);
  }
  $copy(source, target, opts) {
    return this._fileService.copy(URI.revive(source), URI.revive(target), opts.overwrite).then(() => void 0).catch(MainThreadFileSystem_1._handleError);
  }
  $mkdir(uri) {
    return this._fileService.createFolder(URI.revive(uri)).then(() => void 0).catch(MainThreadFileSystem_1._handleError);
  }
  $delete(uri, opts) {
    return this._fileService.del(URI.revive(uri), opts).catch(MainThreadFileSystem_1._handleError);
  }
  static _handleError(err) {
    if (err instanceof FileOperationError) {
      switch (err.fileOperationResult) {
        case 1:
          err.name = FileSystemProviderErrorCode.FileNotFound;
          break;
        case 0:
          err.name = FileSystemProviderErrorCode.FileIsADirectory;
          break;
        case 6:
          err.name = FileSystemProviderErrorCode.NoPermissions;
          break;
        case 4:
          err.name = FileSystemProviderErrorCode.FileExists;
          break;
      }
    } else if (err instanceof Error) {
      const code = toFileSystemProviderErrorCode(err);
      if (code !== FileSystemProviderErrorCode.Unknown) {
        err.name = code;
      }
    }
    throw err;
  }
  $ensureActivation(scheme) {
    return this._fileService.activateProvider(scheme);
  }
  async $watch(extensionId, session, resource, unvalidatedOpts) {
    var _a30, _b;
    const uri = URI.revive(resource);
    const workspaceFolder = this._contextService.getWorkspaceFolder(uri);
    const opts = { ...unvalidatedOpts };
    if (opts.recursive) {
      try {
        const stat = await this._fileService.stat(uri);
        if (!stat.isDirectory) {
          opts.recursive = false;
        }
      } catch (error) {
        this._logService.error(`MainThreadFileSystem#$watch(): failed to stat a resource for file watching (extension: ${extensionId}, path: ${uri.toString(true)}, recursive: ${opts.recursive}, session: ${session}): ${error}`);
      }
    }
    if (workspaceFolder && opts.recursive) {
      this._logService.trace(`MainThreadFileSystem#$watch(): ignoring request to start watching because path is inside workspace (extension: ${extensionId}, path: ${uri.toString(true)}, recursive: ${opts.recursive}, session: ${session})`);
      return;
    }
    this._logService.trace(`MainThreadFileSystem#$watch(): request to start watching (extension: ${extensionId}, path: ${uri.toString(true)}, recursive: ${opts.recursive}, session: ${session})`);
    if (opts.recursive) {
      const config = this._configurationService.getValue();
      if ((_a30 = config.files) == null ? void 0 : _a30.watcherExclude) {
        for (const key in config.files.watcherExclude) {
          if (config.files.watcherExclude[key] === true) {
            opts.excludes.push(key);
          }
        }
      }
    } else if (workspaceFolder) {
      const config = this._configurationService.getValue();
      if ((_b = config.files) == null ? void 0 : _b.watcherExclude) {
        for (const key in config.files.watcherExclude) {
          if (config.files.watcherExclude[key] === true) {
            if (!opts.includes) {
              opts.includes = [];
            }
            const includePattern = `${rtrim(key, "/")}/${GLOBSTAR}`;
            opts.includes.push(normalizeWatcherPattern(workspaceFolder.uri.fsPath, includePattern));
          }
        }
      }
      if (!opts.includes || opts.includes.length === 0) {
        this._logService.trace(`MainThreadFileSystem#$watch(): ignoring request to start watching because path is inside workspace and no excludes are configured (extension: ${extensionId}, path: ${uri.toString(true)}, recursive: ${opts.recursive}, session: ${session})`);
        return;
      }
    }
    const subscription = this._fileService.watch(uri, opts);
    this._watches.set(session, subscription);
  }
  $unwatch(session) {
    if (this._watches.has(session)) {
      this._logService.trace(`MainThreadFileSystem#$unwatch(): request to stop watching (session: ${session})`);
      this._watches.deleteAndDispose(session);
    }
  }
};
MainThreadFileSystem = MainThreadFileSystem_1 = __decorate([
  extHostNamedCustomer(MainContext.MainThreadFileSystem),
  __param(1, IWorkbenchFileService),
  __param(2, IWorkspaceContextService),
  __param(3, ILogService),
  __param(4, IConfigurationService)
], MainThreadFileSystem);
var RemoteFileSystemProvider = class _RemoteFileSystemProvider {
  constructor(fileService, scheme, capabilities, readOnlyMessage, _handle4, _proxy10) {
    this.readOnlyMessage = readOnlyMessage;
    this._handle = _handle4;
    this._proxy = _proxy10;
    this._onDidChange = new Emitter();
    this.onDidChangeFile = this._onDidChange.event;
    this.onDidChangeCapabilities = Event.None;
    this.capabilities = capabilities;
    this._registration = fileService.registerProvider(scheme, this);
  }
  dispose() {
    this._registration.dispose();
    this._onDidChange.dispose();
  }
  watch(resource, opts) {
    const session = Math.random();
    this._proxy.$watch(this._handle, session, resource, opts);
    return toDisposable(() => {
      this._proxy.$unwatch(this._handle, session);
    });
  }
  $onFileSystemChange(changes) {
    this._onDidChange.fire(changes.map(_RemoteFileSystemProvider._createFileChange));
  }
  static _createFileChange(dto) {
    return { resource: URI.revive(dto.resource), type: dto.type };
  }
  stat(resource) {
    return this._proxy.$stat(this._handle, resource).then(void 0, (err) => {
      throw err;
    });
  }
  readFile(resource) {
    return this._proxy.$readFile(this._handle, resource).then((buffer) => buffer.buffer);
  }
  writeFile(resource, content, opts) {
    return this._proxy.$writeFile(this._handle, resource, VSBuffer.wrap(content), opts);
  }
  delete(resource, opts) {
    return this._proxy.$delete(this._handle, resource, opts);
  }
  mkdir(resource) {
    return this._proxy.$mkdir(this._handle, resource);
  }
  readdir(resource) {
    return this._proxy.$readdir(this._handle, resource);
  }
  rename(resource, target, opts) {
    return this._proxy.$rename(this._handle, resource, target, opts);
  }
  copy(resource, target, opts) {
    return this._proxy.$copy(this._handle, resource, target, opts);
  }
  open(resource, opts) {
    return this._proxy.$open(this._handle, resource, opts);
  }
  close(fd) {
    return this._proxy.$close(this._handle, fd);
  }
  read(fd, pos, data, offset, length) {
    return this._proxy.$read(this._handle, fd, pos, length).then((readData) => {
      data.set(readData.buffer, offset);
      return readData.byteLength;
    });
  }
  write(fd, pos, data, offset, length) {
    return this._proxy.$write(this._handle, fd, pos, VSBuffer.wrap(data).slice(offset, offset + length));
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadFileSystemEventService.js
init_tslib_es6();
init_lifecycle();
init_files();
init_extHost_protocol();
init_nls();
init_progress();
init_async();
init_cancellation();
init_actions2();
init_log();
init_environment();
var MainThreadFileSystemEventService_1;
var _a20;
var MainThreadFileSystemEventService = (_a20 = class {
  constructor(extHostContext, fileService, workingCopyFileService, bulkEditService, progressService, dialogService, storageService, logService, envService, uriIdentService) {
    this._listener = new DisposableStore();
    const proxy = extHostContext.getProxy(ExtHostContext.ExtHostFileSystemEventService);
    this._listener.add(fileService.onDidFilesChange((event) => {
      proxy.$onFileEvent({
        created: event.rawAdded,
        changed: event.rawUpdated,
        deleted: event.rawDeleted
      });
    }));
    const fileOperationParticipant = new class {
      async participate(files, operation, undoInfo, timeout2, token) {
        if (undoInfo == null ? void 0 : undoInfo.isUndoing) {
          return;
        }
        const cts = new CancellationTokenSource(token);
        const timer = setTimeout(() => cts.cancel(), timeout2);
        const data = await progressService.withProgress({
          location: 15,
          title: this._progressLabel(operation),
          cancellable: true,
          delay: Math.min(timeout2 / 2, 3e3)
        }, () => {
          const onWillEvent = proxy.$onWillRunFileOperation(operation, files, timeout2, cts.token);
          return raceCancellation(onWillEvent, cts.token);
        }, () => {
          cts.cancel();
        }).finally(() => {
          cts.dispose();
          clearTimeout(timer);
        });
        if (!data || data.edit.edits.length === 0) {
          return;
        }
        const needsConfirmation = data.edit.edits.some((edit) => {
          var _a30;
          return (_a30 = edit.metadata) == null ? void 0 : _a30.needsConfirmation;
        });
        let showPreview = storageService.getBoolean(MainThreadFileSystemEventService_1.MementoKeyAdditionalEdits, 0);
        if (envService.extensionTestsLocationURI) {
          showPreview = false;
        }
        if (showPreview === void 0) {
          let message;
          if (data.extensionNames.length === 1) {
            if (operation === 0) {
              message = localize(
                "ask.1.create",
                "Extension '{0}' wants to make refactoring changes with this file creation",
                data.extensionNames[0]
              );
            } else if (operation === 3) {
              message = localize(
                "ask.1.copy",
                "Extension '{0}' wants to make refactoring changes with this file copy",
                data.extensionNames[0]
              );
            } else if (operation === 2) {
              message = localize(
                "ask.1.move",
                "Extension '{0}' wants to make refactoring changes with this file move",
                data.extensionNames[0]
              );
            } else {
              message = localize(
                "ask.1.delete",
                "Extension '{0}' wants to make refactoring changes with this file deletion",
                data.extensionNames[0]
              );
            }
          } else {
            if (operation === 0) {
              message = localize(
                { key: "ask.N.create", comment: ['{0} is a number, e.g "3 extensions want..."'] },
                "{0} extensions want to make refactoring changes with this file creation",
                data.extensionNames.length
              );
            } else if (operation === 3) {
              message = localize(
                { key: "ask.N.copy", comment: ['{0} is a number, e.g "3 extensions want..."'] },
                "{0} extensions want to make refactoring changes with this file copy",
                data.extensionNames.length
              );
            } else if (operation === 2) {
              message = localize(
                { key: "ask.N.move", comment: ['{0} is a number, e.g "3 extensions want..."'] },
                "{0} extensions want to make refactoring changes with this file move",
                data.extensionNames.length
              );
            } else {
              message = localize(
                { key: "ask.N.delete", comment: ['{0} is a number, e.g "3 extensions want..."'] },
                "{0} extensions want to make refactoring changes with this file deletion",
                data.extensionNames.length
              );
            }
          }
          if (needsConfirmation) {
            const { confirmed } = await dialogService.confirm({
              type: severity_default.Info,
              message,
              primaryButton: localize("preview", "Show &&Preview"),
              cancelButton: localize("cancel", "Skip Changes")
            });
            showPreview = true;
            if (!confirmed) {
              return;
            }
          } else {
            let Choice;
            (function(Choice2) {
              Choice2[Choice2["OK"] = 0] = "OK";
              Choice2[Choice2["Preview"] = 1] = "Preview";
              Choice2[Choice2["Cancel"] = 2] = "Cancel";
            })(Choice || (Choice = {}));
            const { result, checkboxChecked } = await dialogService.prompt({
              type: severity_default.Info,
              message,
              buttons: [
                {
                  label: localize({ key: "ok", comment: ["&& denotes a mnemonic"] }, "&&OK"),
                  run: () => Choice.OK
                },
                {
                  label: localize({ key: "preview", comment: ["&& denotes a mnemonic"] }, "Show &&Preview"),
                  run: () => Choice.Preview
                }
              ],
              cancelButton: {
                label: localize("cancel", "Skip Changes"),
                run: () => Choice.Cancel
              },
              checkbox: { label: localize("again", "Don't ask again") }
            });
            if (result === Choice.Cancel) {
              return;
            }
            showPreview = result === Choice.Preview;
            if (checkboxChecked) {
              storageService.store(MainThreadFileSystemEventService_1.MementoKeyAdditionalEdits, showPreview, 0, 0);
            }
          }
        }
        logService.info("[onWill-handler] applying additional workspace edit from extensions", data.extensionNames);
        await bulkEditService.apply(reviveWorkspaceEditDto(data.edit, uriIdentService), { undoRedoGroupId: undoInfo == null ? void 0 : undoInfo.undoRedoGroupId, showPreview });
      }
      _progressLabel(operation) {
        switch (operation) {
          case 0:
            return localize("msg-create", "Running 'File Create' participants...");
          case 2:
            return localize("msg-rename", "Running 'File Rename' participants...");
          case 3:
            return localize("msg-copy", "Running 'File Copy' participants...");
          case 1:
            return localize("msg-delete", "Running 'File Delete' participants...");
          case 4:
            return localize("msg-write", "Running 'File Write' participants...");
        }
      }
    }();
    this._listener.add(workingCopyFileService.addFileOperationParticipant(fileOperationParticipant));
    this._listener.add(workingCopyFileService.onDidRunWorkingCopyFileOperation((e) => proxy.$onDidRunFileOperation(e.operation, e.files)));
  }
  dispose() {
    this._listener.dispose();
  }
}, MainThreadFileSystemEventService_1 = _a20, _a20.MementoKeyAdditionalEdits = `file.particpants.additionalEdits`, _a20);
MainThreadFileSystemEventService = MainThreadFileSystemEventService_1 = __decorate([
  extHostCustomer,
  __param(1, IFileService),
  __param(2, IWorkingCopyFileService),
  __param(3, IBulkEditService),
  __param(4, IProgressService),
  __param(5, IDialogService),
  __param(6, IStorageService),
  __param(7, ILogService),
  __param(8, IEnvironmentService),
  __param(9, IUriIdentityService)
], MainThreadFileSystemEventService);
registerAction2(class ResetMemento extends Action2 {
  constructor() {
    super({
      id: "files.participants.resetChoice",
      title: {
        value: localize("label", "Reset choice for 'File operation needs preview'"),
        original: `Reset choice for 'File operation needs preview'`
      },
      f1: true
    });
  }
  run(accessor) {
    accessor.get(IStorageService).remove(MainThreadFileSystemEventService.MementoKeyAdditionalEdits, 0);
  }
});

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadKeytar.js
init_tslib_es6();
init_extHost_protocol();
var MainThreadKeytar = class MainThreadKeytar2 {
  constructor(_extHostContext, _credentialsService) {
    this._credentialsService = _credentialsService;
  }
  async $getPassword(service, account) {
    return this._credentialsService.getPassword(service, account);
  }
  async $setPassword(service, account, password) {
    return this._credentialsService.setPassword(service, account, password);
  }
  async $deletePassword(service, account) {
    return this._credentialsService.deletePassword(service, account);
  }
  async $findPassword(service) {
    return this._credentialsService.findPassword(service);
  }
  async $findCredentials(service) {
    return this._credentialsService.findCredentials(service);
  }
  dispose() {
  }
};
MainThreadKeytar = __decorate([
  extHostNamedCustomer(MainContext.MainThreadKeytar),
  __param(1, ICredentialsService)
], MainThreadKeytar);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadLanguageFeatures.js
init_tslib_es6();
init_errors();
init_event();
init_lifecycle();
init_objects();
init_uri();
init_language();
init_languageConfigurationRegistry();
init_languageFeatures();

// node_modules/vscode/vscode/src/vs/workbench/api/common/shared/dataTransferCache.js
init_arrays();
init_buffer();
var DataTransferFileCache = class {
  constructor() {
    this.requestIdPool = 0;
    this.dataTransferFiles = /* @__PURE__ */ new Map();
  }
  add(dataTransfer) {
    const requestId = this.requestIdPool++;
    this.dataTransferFiles.set(requestId, coalesce(Array.from(dataTransfer, ([, item]) => item.asFile())));
    return {
      id: requestId,
      dispose: () => {
        this.dataTransferFiles.delete(requestId);
      }
    };
  }
  async resolveFileData(requestId, dataItemId) {
    const files = this.dataTransferFiles.get(requestId);
    if (!files) {
      throw new Error("No data transfer found");
    }
    const file = files.find((file2) => file2.id === dataItemId);
    if (!file) {
      throw new Error("No matching file found in data transfer");
    }
    return VSBuffer.wrap(await file.data());
  }
  dispose() {
    this.dataTransferFiles.clear();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/callHierarchy/common/callHierarchy.js
init_cancellation();
init_uri();
init_position();
init_arrays();
init_errors();
init_lifecycle();
init_commands();
init_types();
init_model2();
init_resolverService();
var CallHierarchyProviderRegistry = new LanguageFeatureRegistry();
var CallHierarchyModel = class _CallHierarchyModel {
  static async create(model, position, token) {
    const [provider] = CallHierarchyProviderRegistry.ordered(model);
    if (!provider) {
      return void 0;
    }
    const session = await provider.prepareCallHierarchy(model, position, token);
    if (!session) {
      return void 0;
    }
    return new _CallHierarchyModel(
      session.roots.reduce((p, c) => p + c._sessionId, ""),
      provider,
      session.roots,
      new RefCountedDisposable(session)
    );
  }
  constructor(id, provider, roots, ref) {
    this.id = id;
    this.provider = provider;
    this.roots = roots;
    this.ref = ref;
    this.root = roots[0];
  }
  dispose() {
    this.ref.release();
  }
  fork(item) {
    const that = this;
    return new class extends _CallHierarchyModel {
      constructor() {
        super(that.id, that.provider, [item], that.ref.acquire());
      }
    }();
  }
  async resolveIncomingCalls(item, token) {
    try {
      const result = await this.provider.provideIncomingCalls(item, token);
      if (isNonEmptyArray(result)) {
        return result;
      }
    } catch (e) {
      onUnexpectedExternalError(e);
    }
    return [];
  }
  async resolveOutgoingCalls(item, token) {
    try {
      const result = await this.provider.provideOutgoingCalls(item, token);
      if (isNonEmptyArray(result)) {
        return result;
      }
    } catch (e) {
      onUnexpectedExternalError(e);
    }
    return [];
  }
};
var _models = /* @__PURE__ */ new Map();
CommandsRegistry.registerCommand("_executePrepareCallHierarchy", async (accessor, ...args) => {
  const [resource, position] = args;
  assertType(URI.isUri(resource));
  assertType(Position.isIPosition(position));
  const modelService = accessor.get(IModelService);
  let textModel = modelService.getModel(resource);
  let textModelReference;
  if (!textModel) {
    const textModelService = accessor.get(ITextModelService);
    const result = await textModelService.createModelReference(resource);
    textModel = result.object.textEditorModel;
    textModelReference = result;
  }
  try {
    const model = await CallHierarchyModel.create(textModel, position, CancellationToken.None);
    if (!model) {
      return [];
    }
    _models.set(model.id, model);
    _models.forEach((value, key, map) => {
      if (map.size > 10) {
        value.dispose();
        _models.delete(key);
      }
    });
    return [model.root];
  } finally {
    textModelReference == null ? void 0 : textModelReference.dispose();
  }
});
function isCallHierarchyItemDto(obj) {
  return true;
}
CommandsRegistry.registerCommand("_executeProvideIncomingCalls", async (_accessor, ...args) => {
  const [item] = args;
  assertType(isCallHierarchyItemDto());
  const model = _models.get(item._sessionId);
  if (!model) {
    return void 0;
  }
  return model.resolveIncomingCalls(item, CancellationToken.None);
});
CommandsRegistry.registerCommand("_executeProvideOutgoingCalls", async (_accessor, ...args) => {
  const [item] = args;
  assertType(isCallHierarchyItemDto());
  const model = _models.get(item._sessionId);
  if (!model) {
    return void 0;
  }
  return model.resolveOutgoingCalls(item, CancellationToken.None);
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/search/common/search.js
init_errors();
init_cancellation();
init_files();
init_range();
init_types();
init_contextkey();
init_strings();
init_arrays();
var WorkspaceSymbolProviderRegistry;
(function(WorkspaceSymbolProviderRegistry2) {
  const _supports = [];
  function register(provider) {
    let support = provider;
    if (support) {
      _supports.push(support);
    }
    return {
      dispose() {
        if (support) {
          const idx = _supports.indexOf(support);
          if (idx >= 0) {
            _supports.splice(idx, 1);
            support = void 0;
          }
        }
      }
    };
  }
  WorkspaceSymbolProviderRegistry2.register = register;
  function all() {
    return _supports.slice(0);
  }
  WorkspaceSymbolProviderRegistry2.all = all;
})(WorkspaceSymbolProviderRegistry || (WorkspaceSymbolProviderRegistry = {}));
var SearchUIState;
(function(SearchUIState2) {
  SearchUIState2[SearchUIState2["Idle"] = 0] = "Idle";
  SearchUIState2[SearchUIState2["Searching"] = 1] = "Searching";
  SearchUIState2[SearchUIState2["SlowSearch"] = 2] = "SlowSearch";
})(SearchUIState || (SearchUIState = {}));
var SearchStateKey = new RawContextKey("searchState", SearchUIState.Idle);

// node_modules/vscode/vscode/src/vs/workbench/contrib/typeHierarchy/common/typeHierarchy.js
init_range();
init_cancellation();
init_uri();
init_position();
init_arrays();
init_errors();
init_lifecycle();
init_commands();
init_types();
init_model2();
init_resolverService();
var TypeHierarchyProviderRegistry = new LanguageFeatureRegistry();
var TypeHierarchyModel = class _TypeHierarchyModel {
  static async create(model, position, token) {
    const [provider] = TypeHierarchyProviderRegistry.ordered(model);
    if (!provider) {
      return void 0;
    }
    const session = await provider.prepareTypeHierarchy(model, position, token);
    if (!session) {
      return void 0;
    }
    return new _TypeHierarchyModel(
      session.roots.reduce((p, c) => p + c._sessionId, ""),
      provider,
      session.roots,
      new RefCountedDisposable(session)
    );
  }
  constructor(id, provider, roots, ref) {
    this.id = id;
    this.provider = provider;
    this.roots = roots;
    this.ref = ref;
    this.root = roots[0];
  }
  dispose() {
    this.ref.release();
  }
  fork(item) {
    const that = this;
    return new class extends _TypeHierarchyModel {
      constructor() {
        super(that.id, that.provider, [item], that.ref.acquire());
      }
    }();
  }
  async provideSupertypes(item, token) {
    try {
      const result = await this.provider.provideSupertypes(item, token);
      if (isNonEmptyArray(result)) {
        return result;
      }
    } catch (e) {
      onUnexpectedExternalError(e);
    }
    return [];
  }
  async provideSubtypes(item, token) {
    try {
      const result = await this.provider.provideSubtypes(item, token);
      if (isNonEmptyArray(result)) {
        return result;
      }
    } catch (e) {
      onUnexpectedExternalError(e);
    }
    return [];
  }
};
var _models2 = /* @__PURE__ */ new Map();
CommandsRegistry.registerCommand("_executePrepareTypeHierarchy", async (accessor, ...args) => {
  const [resource, position] = args;
  assertType(URI.isUri(resource));
  assertType(Position.isIPosition(position));
  const modelService = accessor.get(IModelService);
  let textModel = modelService.getModel(resource);
  let textModelReference;
  if (!textModel) {
    const textModelService = accessor.get(ITextModelService);
    const result = await textModelService.createModelReference(resource);
    textModel = result.object.textEditorModel;
    textModelReference = result;
  }
  try {
    const model = await TypeHierarchyModel.create(textModel, position, CancellationToken.None);
    if (!model) {
      return [];
    }
    _models2.set(model.id, model);
    _models2.forEach((value, key, map) => {
      if (map.size > 10) {
        value.dispose();
        _models2.delete(key);
      }
    });
    return [model.root];
  } finally {
    textModelReference == null ? void 0 : textModelReference.dispose();
  }
});
function isTypeHierarchyItemDto(obj) {
  const item = obj;
  return typeof obj === "object" && typeof item.name === "string" && typeof item.kind === "number" && URI.isUri(item.uri) && Range.isIRange(item.range) && Range.isIRange(item.selectionRange);
}
CommandsRegistry.registerCommand("_executeProvideSupertypes", async (_accessor, ...args) => {
  const [item] = args;
  assertType(isTypeHierarchyItemDto(item));
  const model = _models2.get(item._sessionId);
  if (!model) {
    return void 0;
  }
  return model.provideSupertypes(item, CancellationToken.None);
});
CommandsRegistry.registerCommand("_executeProvideSubtypes", async (_accessor, ...args) => {
  const [item] = args;
  assertType(isTypeHierarchyItemDto(item));
  const model = _models2.get(item._sessionId);
  if (!model) {
    return void 0;
  }
  return model.provideSubtypes(item, CancellationToken.None);
});

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadLanguageFeatures.js
init_extHost_protocol();
var MainThreadLanguageFeatures_1;
var MainThreadLanguageFeatures = MainThreadLanguageFeatures_1 = class MainThreadLanguageFeatures2 extends Disposable {
  constructor(extHostContext, _languageService, _languageConfigurationService, _languageFeaturesService, _uriIdentService) {
    super();
    this._languageService = _languageService;
    this._languageConfigurationService = _languageConfigurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._uriIdentService = _uriIdentService;
    this._registrations = this._register(new DisposableMap());
    this._pasteEditProviders = /* @__PURE__ */ new Map();
    this._documentOnDropEditProviders = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostLanguageFeatures);
    if (this._languageService) {
      const updateAllWordDefinitions = () => {
        const wordDefinitionDtos = [];
        for (const languageId of _languageService.getRegisteredLanguageIds()) {
          const wordDefinition = this._languageConfigurationService.getLanguageConfiguration(languageId).getWordDefinition();
          wordDefinitionDtos.push({
            languageId,
            regexSource: wordDefinition.source,
            regexFlags: wordDefinition.flags
          });
        }
        this._proxy.$setWordDefinitions(wordDefinitionDtos);
      };
      this._languageConfigurationService.onDidChange((e) => {
        if (!e.languageId) {
          updateAllWordDefinitions();
        } else {
          const wordDefinition = this._languageConfigurationService.getLanguageConfiguration(e.languageId).getWordDefinition();
          this._proxy.$setWordDefinitions([{
            languageId: e.languageId,
            regexSource: wordDefinition.source,
            regexFlags: wordDefinition.flags
          }]);
        }
      });
      updateAllWordDefinitions();
    }
  }
  $unregister(handle) {
    this._registrations.deleteAndDispose(handle);
  }
  static _reviveLocationDto(data) {
    if (!data) {
      return data;
    } else if (Array.isArray(data)) {
      data.forEach((l) => MainThreadLanguageFeatures_1._reviveLocationDto(l));
      return data;
    } else {
      data.uri = URI.revive(data.uri);
      return data;
    }
  }
  static _reviveLocationLinkDto(data) {
    if (!data) {
      return data;
    } else if (Array.isArray(data)) {
      data.forEach((l) => MainThreadLanguageFeatures_1._reviveLocationLinkDto(l));
      return data;
    } else {
      data.uri = URI.revive(data.uri);
      return data;
    }
  }
  static _reviveWorkspaceSymbolDto(data) {
    if (!data) {
      return data;
    } else if (Array.isArray(data)) {
      data.forEach(MainThreadLanguageFeatures_1._reviveWorkspaceSymbolDto);
      return data;
    } else {
      data.location = MainThreadLanguageFeatures_1._reviveLocationDto(data.location);
      return data;
    }
  }
  static _reviveCodeActionDto(data, uriIdentService) {
    data == null ? void 0 : data.forEach((code) => reviveWorkspaceEditDto(code.edit, uriIdentService));
    return data;
  }
  static _reviveLinkDTO(data) {
    if (data.url && typeof data.url !== "string") {
      data.url = URI.revive(data.url);
    }
    return data;
  }
  static _reviveCallHierarchyItemDto(data) {
    if (data) {
      data.uri = URI.revive(data.uri);
    }
    return data;
  }
  static _reviveTypeHierarchyItemDto(data) {
    if (data) {
      data.uri = URI.revive(data.uri);
    }
    return data;
  }
  $registerDocumentSymbolProvider(handle, selector, displayName) {
    this._registrations.set(handle, this._languageFeaturesService.documentSymbolProvider.register(selector, {
      displayName,
      provideDocumentSymbols: (model, token) => {
        return this._proxy.$provideDocumentSymbols(handle, model.uri, token);
      }
    }));
  }
  $registerCodeLensSupport(handle, selector, eventHandle) {
    const provider = {
      provideCodeLenses: async (model, token) => {
        const listDto = await this._proxy.$provideCodeLenses(handle, model.uri, token);
        if (!listDto) {
          return void 0;
        }
        return {
          lenses: listDto.lenses,
          dispose: () => listDto.cacheId && this._proxy.$releaseCodeLenses(handle, listDto.cacheId)
        };
      },
      resolveCodeLens: async (model, codeLens, token) => {
        const result = await this._proxy.$resolveCodeLens(handle, codeLens, token);
        if (!result) {
          return void 0;
        }
        return {
          ...result,
          range: model.validateRange(result.range)
        };
      }
    };
    if (typeof eventHandle === "number") {
      const emitter = new Emitter();
      this._registrations.set(eventHandle, emitter);
      provider.onDidChange = emitter.event;
    }
    this._registrations.set(handle, this._languageFeaturesService.codeLensProvider.register(selector, provider));
  }
  $emitCodeLensEvent(eventHandle, event) {
    const obj = this._registrations.get(eventHandle);
    if (obj instanceof Emitter) {
      obj.fire(event);
    }
  }
  $registerDefinitionSupport(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.definitionProvider.register(selector, {
      provideDefinition: (model, position, token) => {
        return this._proxy.$provideDefinition(handle, model.uri, position, token).then(MainThreadLanguageFeatures_1._reviveLocationLinkDto);
      }
    }));
  }
  $registerDeclarationSupport(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.declarationProvider.register(selector, {
      provideDeclaration: (model, position, token) => {
        return this._proxy.$provideDeclaration(handle, model.uri, position, token).then(MainThreadLanguageFeatures_1._reviveLocationLinkDto);
      }
    }));
  }
  $registerImplementationSupport(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.implementationProvider.register(selector, {
      provideImplementation: (model, position, token) => {
        return this._proxy.$provideImplementation(handle, model.uri, position, token).then(MainThreadLanguageFeatures_1._reviveLocationLinkDto);
      }
    }));
  }
  $registerTypeDefinitionSupport(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.typeDefinitionProvider.register(selector, {
      provideTypeDefinition: (model, position, token) => {
        return this._proxy.$provideTypeDefinition(handle, model.uri, position, token).then(MainThreadLanguageFeatures_1._reviveLocationLinkDto);
      }
    }));
  }
  $registerHoverProvider(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.hoverProvider.register(selector, {
      provideHover: (model, position, token) => {
        return this._proxy.$provideHover(handle, model.uri, position, token);
      }
    }));
  }
  $registerEvaluatableExpressionProvider(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.evaluatableExpressionProvider.register(selector, {
      provideEvaluatableExpression: (model, position, token) => {
        return this._proxy.$provideEvaluatableExpression(handle, model.uri, position, token);
      }
    }));
  }
  $registerInlineValuesProvider(handle, selector, eventHandle) {
    const provider = {
      provideInlineValues: (model, viewPort, context, token) => {
        return this._proxy.$provideInlineValues(handle, model.uri, viewPort, context, token);
      }
    };
    if (typeof eventHandle === "number") {
      const emitter = new Emitter();
      this._registrations.set(eventHandle, emitter);
      provider.onDidChangeInlineValues = emitter.event;
    }
    this._registrations.set(handle, this._languageFeaturesService.inlineValuesProvider.register(selector, provider));
  }
  $emitInlineValuesEvent(eventHandle, event) {
    const obj = this._registrations.get(eventHandle);
    if (obj instanceof Emitter) {
      obj.fire(event);
    }
  }
  $registerDocumentHighlightProvider(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.documentHighlightProvider.register(selector, {
      provideDocumentHighlights: (model, position, token) => {
        return this._proxy.$provideDocumentHighlights(handle, model.uri, position, token);
      }
    }));
  }
  $registerLinkedEditingRangeProvider(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.linkedEditingRangeProvider.register(selector, {
      provideLinkedEditingRanges: async (model, position, token) => {
        const res = await this._proxy.$provideLinkedEditingRanges(handle, model.uri, position, token);
        if (res) {
          return {
            ranges: res.ranges,
            wordPattern: res.wordPattern ? MainThreadLanguageFeatures_1._reviveRegExp(res.wordPattern) : void 0
          };
        }
        return void 0;
      }
    }));
  }
  $registerReferenceSupport(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.referenceProvider.register(selector, {
      provideReferences: (model, position, context, token) => {
        return this._proxy.$provideReferences(handle, model.uri, position, context, token).then(MainThreadLanguageFeatures_1._reviveLocationDto);
      }
    }));
  }
  $registerQuickFixSupport(handle, selector, metadata, displayName, supportsResolve) {
    const provider = {
      provideCodeActions: async (model, rangeOrSelection, context, token) => {
        const listDto = await this._proxy.$provideCodeActions(handle, model.uri, rangeOrSelection, context, token);
        if (!listDto) {
          return void 0;
        }
        return {
          actions: MainThreadLanguageFeatures_1._reviveCodeActionDto(listDto.actions, this._uriIdentService),
          dispose: () => {
            if (typeof listDto.cacheId === "number") {
              this._proxy.$releaseCodeActions(handle, listDto.cacheId);
            }
          }
        };
      },
      providedCodeActionKinds: metadata.providedKinds,
      documentation: metadata.documentation,
      displayName
    };
    if (supportsResolve) {
      provider.resolveCodeAction = async (codeAction, token) => {
        const resolved = await this._proxy.$resolveCodeAction(handle, codeAction.cacheId, token);
        if (resolved.edit) {
          codeAction.edit = reviveWorkspaceEditDto(resolved.edit, this._uriIdentService);
        }
        if (resolved.command) {
          codeAction.command = resolved.command;
        }
        return codeAction;
      };
    }
    this._registrations.set(handle, this._languageFeaturesService.codeActionProvider.register(selector, provider));
  }
  $registerPasteEditProvider(handle, selector, id, metadata) {
    const provider = new MainThreadPasteEditProvider(handle, this._proxy, id, metadata, this._uriIdentService);
    this._pasteEditProviders.set(handle, provider);
    this._registrations.set(handle, combinedDisposable(this._languageFeaturesService.documentPasteEditProvider.register(selector, provider), toDisposable(() => this._pasteEditProviders.delete(handle))));
  }
  $resolvePasteFileData(handle, requestId, dataId) {
    const provider = this._pasteEditProviders.get(handle);
    if (!provider) {
      throw new Error("Could not find provider");
    }
    return provider.resolveFileData(requestId, dataId);
  }
  $registerDocumentFormattingSupport(handle, selector, extensionId, displayName) {
    this._registrations.set(handle, this._languageFeaturesService.documentFormattingEditProvider.register(selector, {
      extensionId,
      displayName,
      provideDocumentFormattingEdits: (model, options, token) => {
        return this._proxy.$provideDocumentFormattingEdits(handle, model.uri, options, token);
      }
    }));
  }
  $registerRangeFormattingSupport(handle, selector, extensionId, displayName, supportsRanges) {
    this._registrations.set(handle, this._languageFeaturesService.documentRangeFormattingEditProvider.register(selector, {
      extensionId,
      displayName,
      provideDocumentRangeFormattingEdits: (model, range, options, token) => {
        return this._proxy.$provideDocumentRangeFormattingEdits(handle, model.uri, range, options, token);
      },
      provideDocumentRangesFormattingEdits: !supportsRanges ? void 0 : (model, ranges, options, token) => {
        return this._proxy.$provideDocumentRangesFormattingEdits(handle, model.uri, ranges, options, token);
      }
    }));
  }
  $registerOnTypeFormattingSupport(handle, selector, autoFormatTriggerCharacters, extensionId) {
    this._registrations.set(handle, this._languageFeaturesService.onTypeFormattingEditProvider.register(selector, {
      extensionId,
      autoFormatTriggerCharacters,
      provideOnTypeFormattingEdits: (model, position, ch, options, token) => {
        return this._proxy.$provideOnTypeFormattingEdits(handle, model.uri, position, ch, options, token);
      }
    }));
  }
  $registerNavigateTypeSupport(handle, supportsResolve) {
    let lastResultId;
    const provider = {
      provideWorkspaceSymbols: async (search, token) => {
        const result = await this._proxy.$provideWorkspaceSymbols(handle, search, token);
        if (lastResultId !== void 0) {
          this._proxy.$releaseWorkspaceSymbols(handle, lastResultId);
        }
        lastResultId = result.cacheId;
        return MainThreadLanguageFeatures_1._reviveWorkspaceSymbolDto(result.symbols);
      }
    };
    if (supportsResolve) {
      provider.resolveWorkspaceSymbol = async (item, token) => {
        const resolvedItem = await this._proxy.$resolveWorkspaceSymbol(handle, item, token);
        return resolvedItem && MainThreadLanguageFeatures_1._reviveWorkspaceSymbolDto(resolvedItem);
      };
    }
    this._registrations.set(handle, WorkspaceSymbolProviderRegistry.register(provider));
  }
  $registerRenameSupport(handle, selector, supportResolveLocation) {
    this._registrations.set(handle, this._languageFeaturesService.renameProvider.register(selector, {
      provideRenameEdits: (model, position, newName, token) => {
        return this._proxy.$provideRenameEdits(handle, model.uri, position, newName, token).then((data) => reviveWorkspaceEditDto(data, this._uriIdentService));
      },
      resolveRenameLocation: supportResolveLocation ? (model, position, token) => this._proxy.$resolveRenameLocation(handle, model.uri, position, token) : void 0
    }));
  }
  $registerDocumentSemanticTokensProvider(handle, selector, legend, eventHandle) {
    let event = void 0;
    if (typeof eventHandle === "number") {
      const emitter = new Emitter();
      this._registrations.set(eventHandle, emitter);
      event = emitter.event;
    }
    this._registrations.set(handle, this._languageFeaturesService.documentSemanticTokensProvider.register(selector, new MainThreadDocumentSemanticTokensProvider(this._proxy, handle, legend, event)));
  }
  $emitDocumentSemanticTokensEvent(eventHandle) {
    const obj = this._registrations.get(eventHandle);
    if (obj instanceof Emitter) {
      obj.fire(void 0);
    }
  }
  $registerDocumentRangeSemanticTokensProvider(handle, selector, legend) {
    this._registrations.set(handle, this._languageFeaturesService.documentRangeSemanticTokensProvider.register(selector, new MainThreadDocumentRangeSemanticTokensProvider(this._proxy, handle, legend)));
  }
  static _inflateSuggestDto(defaultRange, data, extensionId) {
    const label = data["a"];
    const commandId = data["o"];
    const commandIdent = data["n"];
    const commitChars = data["k"];
    return {
      label,
      extensionId,
      kind: data["b"] ?? 9,
      tags: data["m"],
      detail: data["c"],
      documentation: data["d"],
      sortText: data["e"],
      filterText: data["f"],
      preselect: data["g"],
      insertText: data["h"] ?? (typeof label === "string" ? label : label.label),
      range: data["j"] ?? defaultRange,
      insertTextRules: data["i"],
      commitCharacters: commitChars ? Array.from(commitChars) : void 0,
      additionalTextEdits: data["l"],
      command: commandId ? {
        $ident: commandIdent,
        id: commandId,
        title: "",
        arguments: commandIdent ? [commandIdent] : data["p"]
      } : void 0,
      _id: data.x
    };
  }
  $registerCompletionsProvider(handle, selector, triggerCharacters, supportsResolveDetails, extensionId) {
    const provider = {
      triggerCharacters,
      _debugDisplayName: `${extensionId.value}(${triggerCharacters.join("")})`,
      provideCompletionItems: async (model, position, context, token) => {
        const result = await this._proxy.$provideCompletionItems(handle, model.uri, position, context, token);
        if (!result) {
          return result;
        }
        return {
          suggestions: result["b"].map(
            (d) => MainThreadLanguageFeatures_1._inflateSuggestDto(result["a"], d, extensionId)
          ),
          incomplete: result["c"] || false,
          duration: result["d"],
          dispose: () => {
            if (typeof result.x === "number") {
              this._proxy.$releaseCompletionItems(handle, result.x);
            }
          }
        };
      }
    };
    if (supportsResolveDetails) {
      provider.resolveCompletionItem = (suggestion, token) => {
        return this._proxy.$resolveCompletionItem(handle, suggestion._id, token).then((result) => {
          if (!result) {
            return suggestion;
          }
          const newSuggestion = MainThreadLanguageFeatures_1._inflateSuggestDto(suggestion.range, result, extensionId);
          return mixin(suggestion, newSuggestion, true);
        });
      };
    }
    this._registrations.set(handle, this._languageFeaturesService.completionProvider.register(selector, provider));
  }
  $registerInlineCompletionsSupport(handle, selector, supportsHandleEvents, extensionId, yieldsToExtensionIds) {
    const provider = {
      provideInlineCompletions: async (model, position, context, token) => {
        return this._proxy.$provideInlineCompletions(handle, model.uri, position, context, token);
      },
      handleItemDidShow: async (completions, item, updatedInsertText) => {
        if (supportsHandleEvents) {
          await this._proxy.$handleInlineCompletionDidShow(handle, completions.pid, item.idx, updatedInsertText);
        }
      },
      handlePartialAccept: async (completions, item, acceptedCharacters) => {
        if (supportsHandleEvents) {
          await this._proxy.$handleInlineCompletionPartialAccept(handle, completions.pid, item.idx, acceptedCharacters);
        }
      },
      freeInlineCompletions: (completions) => {
        this._proxy.$freeInlineCompletionsList(handle, completions.pid);
      },
      groupId: extensionId,
      yieldsToGroupIds: yieldsToExtensionIds,
      toString() {
        return `InlineCompletionsProvider(${extensionId})`;
      }
    };
    this._registrations.set(handle, this._languageFeaturesService.inlineCompletionsProvider.register(selector, provider));
  }
  $registerSignatureHelpProvider(handle, selector, metadata) {
    this._registrations.set(handle, this._languageFeaturesService.signatureHelpProvider.register(selector, {
      signatureHelpTriggerCharacters: metadata.triggerCharacters,
      signatureHelpRetriggerCharacters: metadata.retriggerCharacters,
      provideSignatureHelp: async (model, position, token, context) => {
        const result = await this._proxy.$provideSignatureHelp(handle, model.uri, position, context, token);
        if (!result) {
          return void 0;
        }
        return {
          value: result,
          dispose: () => {
            this._proxy.$releaseSignatureHelp(handle, result.id);
          }
        };
      }
    }));
  }
  $registerInlayHintsProvider(handle, selector, supportsResolve, eventHandle, displayName) {
    const provider = {
      displayName,
      provideInlayHints: async (model, range, token) => {
        const result = await this._proxy.$provideInlayHints(handle, model.uri, range, token);
        if (!result) {
          return;
        }
        return {
          hints: revive(result.hints),
          dispose: () => {
            if (result.cacheId) {
              this._proxy.$releaseInlayHints(handle, result.cacheId);
            }
          }
        };
      }
    };
    if (supportsResolve) {
      provider.resolveInlayHint = async (hint, token) => {
        const dto = hint;
        if (!dto.cacheId) {
          return hint;
        }
        const result = await this._proxy.$resolveInlayHint(handle, dto.cacheId, token);
        if (token.isCancellationRequested) {
          throw new CancellationError();
        }
        if (!result) {
          return hint;
        }
        return {
          ...hint,
          tooltip: result.tooltip,
          label: revive(result.label)
        };
      };
    }
    if (typeof eventHandle === "number") {
      const emitter = new Emitter();
      this._registrations.set(eventHandle, emitter);
      provider.onDidChangeInlayHints = emitter.event;
    }
    this._registrations.set(handle, this._languageFeaturesService.inlayHintsProvider.register(selector, provider));
  }
  $emitInlayHintsEvent(eventHandle) {
    const obj = this._registrations.get(eventHandle);
    if (obj instanceof Emitter) {
      obj.fire(void 0);
    }
  }
  $registerDocumentLinkProvider(handle, selector, supportsResolve) {
    const provider = {
      provideLinks: (model, token) => {
        return this._proxy.$provideDocumentLinks(handle, model.uri, token).then((dto) => {
          if (!dto) {
            return void 0;
          }
          return {
            links: dto.links.map(MainThreadLanguageFeatures_1._reviveLinkDTO),
            dispose: () => {
              if (typeof dto.cacheId === "number") {
                this._proxy.$releaseDocumentLinks(handle, dto.cacheId);
              }
            }
          };
        });
      }
    };
    if (supportsResolve) {
      provider.resolveLink = (link, token) => {
        const dto = link;
        if (!dto.cacheId) {
          return link;
        }
        return this._proxy.$resolveDocumentLink(handle, dto.cacheId, token).then((obj) => {
          return obj && MainThreadLanguageFeatures_1._reviveLinkDTO(obj);
        });
      };
    }
    this._registrations.set(handle, this._languageFeaturesService.linkProvider.register(selector, provider));
  }
  $registerDocumentColorProvider(handle, selector) {
    const proxy = this._proxy;
    this._registrations.set(handle, this._languageFeaturesService.colorProvider.register(selector, {
      provideDocumentColors: (model, token) => {
        return proxy.$provideDocumentColors(handle, model.uri, token).then((documentColors) => {
          return documentColors.map((documentColor) => {
            const [red, green, blue, alpha] = documentColor.color;
            const color2 = {
              red,
              green,
              blue,
              alpha
            };
            return {
              color: color2,
              range: documentColor.range
            };
          });
        });
      },
      provideColorPresentations: (model, colorInfo, token) => {
        return proxy.$provideColorPresentations(handle, model.uri, {
          color: [colorInfo.color.red, colorInfo.color.green, colorInfo.color.blue, colorInfo.color.alpha],
          range: colorInfo.range
        }, token);
      }
    }));
  }
  $registerFoldingRangeProvider(handle, selector, extensionId, eventHandle) {
    const provider = {
      id: extensionId.value,
      provideFoldingRanges: (model, context, token) => {
        return this._proxy.$provideFoldingRanges(handle, model.uri, context, token);
      }
    };
    if (typeof eventHandle === "number") {
      const emitter = new Emitter();
      this._registrations.set(eventHandle, emitter);
      provider.onDidChange = emitter.event;
    }
    this._registrations.set(handle, this._languageFeaturesService.foldingRangeProvider.register(selector, provider));
  }
  $emitFoldingRangeEvent(eventHandle, event) {
    const obj = this._registrations.get(eventHandle);
    if (obj instanceof Emitter) {
      obj.fire(event);
    }
  }
  $registerSelectionRangeProvider(handle, selector) {
    this._registrations.set(handle, this._languageFeaturesService.selectionRangeProvider.register(selector, {
      provideSelectionRanges: (model, positions, token) => {
        return this._proxy.$provideSelectionRanges(handle, model.uri, positions, token);
      }
    }));
  }
  $registerCallHierarchyProvider(handle, selector) {
    this._registrations.set(handle, CallHierarchyProviderRegistry.register(selector, {
      prepareCallHierarchy: async (document2, position, token) => {
        const items = await this._proxy.$prepareCallHierarchy(handle, document2.uri, position, token);
        if (!items || items.length === 0) {
          return void 0;
        }
        return {
          dispose: () => {
            for (const item of items) {
              this._proxy.$releaseCallHierarchy(handle, item._sessionId);
            }
          },
          roots: items.map(MainThreadLanguageFeatures_1._reviveCallHierarchyItemDto)
        };
      },
      provideOutgoingCalls: async (item, token) => {
        const outgoing = await this._proxy.$provideCallHierarchyOutgoingCalls(handle, item._sessionId, item._itemId, token);
        if (!outgoing) {
          return outgoing;
        }
        outgoing.forEach((value) => {
          value.to = MainThreadLanguageFeatures_1._reviveCallHierarchyItemDto(value.to);
        });
        return outgoing;
      },
      provideIncomingCalls: async (item, token) => {
        const incoming = await this._proxy.$provideCallHierarchyIncomingCalls(handle, item._sessionId, item._itemId, token);
        if (!incoming) {
          return incoming;
        }
        incoming.forEach((value) => {
          value.from = MainThreadLanguageFeatures_1._reviveCallHierarchyItemDto(value.from);
        });
        return incoming;
      }
    }));
  }
  static _reviveRegExp(regExp) {
    return new RegExp(regExp.pattern, regExp.flags);
  }
  static _reviveIndentationRule(indentationRule) {
    return {
      decreaseIndentPattern: MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.decreaseIndentPattern),
      increaseIndentPattern: MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.increaseIndentPattern),
      indentNextLinePattern: indentationRule.indentNextLinePattern ? MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.indentNextLinePattern) : void 0,
      unIndentedLinePattern: indentationRule.unIndentedLinePattern ? MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.unIndentedLinePattern) : void 0
    };
  }
  static _reviveOnEnterRule(onEnterRule) {
    return {
      beforeText: MainThreadLanguageFeatures_1._reviveRegExp(onEnterRule.beforeText),
      afterText: onEnterRule.afterText ? MainThreadLanguageFeatures_1._reviveRegExp(onEnterRule.afterText) : void 0,
      previousLineText: onEnterRule.previousLineText ? MainThreadLanguageFeatures_1._reviveRegExp(onEnterRule.previousLineText) : void 0,
      action: onEnterRule.action
    };
  }
  static _reviveOnEnterRules(onEnterRules) {
    return onEnterRules.map(MainThreadLanguageFeatures_1._reviveOnEnterRule);
  }
  $setLanguageConfiguration(handle, languageId, _configuration) {
    const configuration = {
      comments: _configuration.comments,
      brackets: _configuration.brackets,
      wordPattern: _configuration.wordPattern ? MainThreadLanguageFeatures_1._reviveRegExp(_configuration.wordPattern) : void 0,
      indentationRules: _configuration.indentationRules ? MainThreadLanguageFeatures_1._reviveIndentationRule(_configuration.indentationRules) : void 0,
      onEnterRules: _configuration.onEnterRules ? MainThreadLanguageFeatures_1._reviveOnEnterRules(_configuration.onEnterRules) : void 0,
      autoClosingPairs: void 0,
      surroundingPairs: void 0,
      __electricCharacterSupport: void 0
    };
    if (_configuration.autoClosingPairs) {
      configuration.autoClosingPairs = _configuration.autoClosingPairs;
    } else if (_configuration.__characterPairSupport) {
      configuration.autoClosingPairs = _configuration.__characterPairSupport.autoClosingPairs;
    }
    if (_configuration.__electricCharacterSupport && _configuration.__electricCharacterSupport.docComment) {
      configuration.__electricCharacterSupport = {
        docComment: {
          open: _configuration.__electricCharacterSupport.docComment.open,
          close: _configuration.__electricCharacterSupport.docComment.close
        }
      };
    }
    if (this._languageService.isRegisteredLanguageId(languageId)) {
      this._registrations.set(handle, this._languageConfigurationService.register(languageId, configuration, 100));
    }
  }
  $registerTypeHierarchyProvider(handle, selector) {
    this._registrations.set(handle, TypeHierarchyProviderRegistry.register(selector, {
      prepareTypeHierarchy: async (document2, position, token) => {
        const items = await this._proxy.$prepareTypeHierarchy(handle, document2.uri, position, token);
        if (!items) {
          return void 0;
        }
        return {
          dispose: () => {
            for (const item of items) {
              this._proxy.$releaseTypeHierarchy(handle, item._sessionId);
            }
          },
          roots: items.map(MainThreadLanguageFeatures_1._reviveTypeHierarchyItemDto)
        };
      },
      provideSupertypes: async (item, token) => {
        const supertypes = await this._proxy.$provideTypeHierarchySupertypes(handle, item._sessionId, item._itemId, token);
        if (!supertypes) {
          return supertypes;
        }
        return supertypes.map(MainThreadLanguageFeatures_1._reviveTypeHierarchyItemDto);
      },
      provideSubtypes: async (item, token) => {
        const subtypes = await this._proxy.$provideTypeHierarchySubtypes(handle, item._sessionId, item._itemId, token);
        if (!subtypes) {
          return subtypes;
        }
        return subtypes.map(MainThreadLanguageFeatures_1._reviveTypeHierarchyItemDto);
      }
    }));
  }
  $registerDocumentOnDropEditProvider(handle, selector, id, metadata) {
    const provider = new MainThreadDocumentOnDropEditProvider(handle, this._proxy, id, metadata, this._uriIdentService);
    this._documentOnDropEditProviders.set(handle, provider);
    this._registrations.set(handle, combinedDisposable(this._languageFeaturesService.documentOnDropEditProvider.register(selector, provider), toDisposable(() => this._documentOnDropEditProviders.delete(handle))));
  }
  async $resolveDocumentOnDropFileData(handle, requestId, dataId) {
    const provider = this._documentOnDropEditProviders.get(handle);
    if (!provider) {
      throw new Error("Could not find provider");
    }
    return provider.resolveDocumentOnDropFileData(requestId, dataId);
  }
  $registerMappedEditsProvider(handle, selector) {
    const provider = new MainThreadMappedEditsProvider(handle, this._proxy, this._uriIdentService);
    this._registrations.set(handle, this._languageFeaturesService.mappedEditsProvider.register(selector, provider));
  }
};
MainThreadLanguageFeatures = MainThreadLanguageFeatures_1 = __decorate([
  extHostNamedCustomer(MainContext.MainThreadLanguageFeatures),
  __param(1, ILanguageService),
  __param(2, ILanguageConfigurationService),
  __param(3, ILanguageFeaturesService),
  __param(4, IUriIdentityService)
], MainThreadLanguageFeatures);
var MainThreadPasteEditProvider = class MainThreadPasteEditProvider2 {
  constructor(_handle4, _proxy10, id, metadata, _uriIdentService) {
    this._handle = _handle4;
    this._proxy = _proxy10;
    this._uriIdentService = _uriIdentService;
    this.dataTransfers = new DataTransferFileCache();
    this.id = id;
    this.copyMimeTypes = metadata.copyMimeTypes;
    this.pasteMimeTypes = metadata.pasteMimeTypes;
    if (metadata.supportsCopy) {
      this.prepareDocumentPaste = async (model, selections, dataTransfer, token) => {
        const dataTransferDto = await DataTransfer2.from(dataTransfer);
        if (token.isCancellationRequested) {
          return void 0;
        }
        const newDataTransfer = await this._proxy.$prepareDocumentPaste(_handle4, model.uri, selections, dataTransferDto, token);
        if (!newDataTransfer) {
          return void 0;
        }
        const dataTransferOut = new VSDataTransfer();
        for (const [type, item] of newDataTransfer.items) {
          dataTransferOut.replace(type, createStringDataTransferItem(item.asString));
        }
        return dataTransferOut;
      };
    }
    if (metadata.supportsPaste) {
      this.provideDocumentPasteEdits = async (model, selections, dataTransfer, token) => {
        const request = this.dataTransfers.add(dataTransfer);
        try {
          const dataTransferDto = await DataTransfer2.from(dataTransfer);
          if (token.isCancellationRequested) {
            return;
          }
          const result = await this._proxy.$providePasteEdits(this._handle, request.id, model.uri, selections, dataTransferDto, token);
          if (!result) {
            return;
          }
          return {
            ...result,
            additionalEdit: result.additionalEdit ? reviveWorkspaceEditDto(result.additionalEdit, this._uriIdentService, (dataId) => this.resolveFileData(request.id, dataId)) : void 0
          };
        } finally {
          request.dispose();
        }
      };
    }
  }
  resolveFileData(requestId, dataId) {
    return this.dataTransfers.resolveFileData(requestId, dataId);
  }
};
MainThreadPasteEditProvider = __decorate([
  __param(4, IUriIdentityService)
], MainThreadPasteEditProvider);
var MainThreadDocumentOnDropEditProvider = class MainThreadDocumentOnDropEditProvider2 {
  constructor(_handle4, _proxy10, id, metadata, _uriIdentService) {
    this._handle = _handle4;
    this._proxy = _proxy10;
    this._uriIdentService = _uriIdentService;
    this.dataTransfers = new DataTransferFileCache();
    this.id = id;
    this.dropMimeTypes = (metadata == null ? void 0 : metadata.dropMimeTypes) ?? ["*/*"];
  }
  async provideDocumentOnDropEdits(model, position, dataTransfer, token) {
    const request = this.dataTransfers.add(dataTransfer);
    try {
      const dataTransferDto = await DataTransfer2.from(dataTransfer);
      if (token.isCancellationRequested) {
        return;
      }
      const edit = await this._proxy.$provideDocumentOnDropEdits(this._handle, request.id, model.uri, position, dataTransferDto, token);
      if (!edit) {
        return;
      }
      return {
        ...edit,
        additionalEdit: reviveWorkspaceEditDto(edit.additionalEdit, this._uriIdentService, (dataId) => this.resolveDocumentOnDropFileData(request.id, dataId))
      };
    } finally {
      request.dispose();
    }
  }
  resolveDocumentOnDropFileData(requestId, dataId) {
    return this.dataTransfers.resolveFileData(requestId, dataId);
  }
};
MainThreadDocumentOnDropEditProvider = __decorate([
  __param(4, IUriIdentityService)
], MainThreadDocumentOnDropEditProvider);
var MainThreadDocumentSemanticTokensProvider = class {
  constructor(_proxy10, _handle4, _legend, onDidChange) {
    this._proxy = _proxy10;
    this._handle = _handle4;
    this._legend = _legend;
    this.onDidChange = onDidChange;
  }
  releaseDocumentSemanticTokens(resultId) {
    if (resultId) {
      this._proxy.$releaseDocumentSemanticTokens(this._handle, parseInt(resultId, 10));
    }
  }
  getLegend() {
    return this._legend;
  }
  async provideDocumentSemanticTokens(model, lastResultId, token) {
    const nLastResultId = lastResultId ? parseInt(lastResultId, 10) : 0;
    const encodedDto = await this._proxy.$provideDocumentSemanticTokens(this._handle, model.uri, nLastResultId, token);
    if (!encodedDto) {
      return null;
    }
    if (token.isCancellationRequested) {
      return null;
    }
    const dto = decodeSemanticTokensDto(encodedDto);
    if (dto.type === "full") {
      return {
        resultId: String(dto.id),
        data: dto.data
      };
    }
    return {
      resultId: String(dto.id),
      edits: dto.deltas
    };
  }
};
var MainThreadDocumentRangeSemanticTokensProvider = class {
  constructor(_proxy10, _handle4, _legend) {
    this._proxy = _proxy10;
    this._handle = _handle4;
    this._legend = _legend;
  }
  getLegend() {
    return this._legend;
  }
  async provideDocumentRangeSemanticTokens(model, range, token) {
    const encodedDto = await this._proxy.$provideDocumentRangeSemanticTokens(this._handle, model.uri, range, token);
    if (!encodedDto) {
      return null;
    }
    if (token.isCancellationRequested) {
      return null;
    }
    const dto = decodeSemanticTokensDto(encodedDto);
    if (dto.type === "full") {
      return {
        resultId: String(dto.id),
        data: dto.data
      };
    }
    throw new Error(`Unexpected`);
  }
};
var MainThreadMappedEditsProvider = class {
  constructor(_handle4, _proxy10, _uriService) {
    this._handle = _handle4;
    this._proxy = _proxy10;
    this._uriService = _uriService;
  }
  async provideMappedEdits(document2, codeBlocks, context, token) {
    const res = await this._proxy.$provideMappedEdits(this._handle, document2.uri, codeBlocks, context, token);
    return res ? reviveWorkspaceEditDto(res, this._uriService) : null;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadLanguages.js
init_tslib_es6();
init_uri();
init_language();
init_model2();
init_extHost_protocol();
init_range();
init_resolverService();
init_lifecycle();
var MainThreadLanguages = class MainThreadLanguages2 {
  constructor(_extHostContext, _languageService, _modelService, _resolverService, _languageStatusService) {
    this._languageService = _languageService;
    this._modelService = _modelService;
    this._resolverService = _resolverService;
    this._languageStatusService = _languageStatusService;
    this._disposables = new DisposableStore();
    this._status = new DisposableMap();
    this._proxy = _extHostContext.getProxy(ExtHostContext.ExtHostLanguages);
    this._proxy.$acceptLanguageIds(_languageService.getRegisteredLanguageIds());
    this._disposables.add(_languageService.onDidChange((_) => {
      this._proxy.$acceptLanguageIds(_languageService.getRegisteredLanguageIds());
    }));
  }
  dispose() {
    this._disposables.dispose();
    this._status.dispose();
  }
  async $changeLanguage(resource, languageId) {
    if (!this._languageService.isRegisteredLanguageId(languageId)) {
      return Promise.reject(new Error(`Unknown language id: ${languageId}`));
    }
    const uri = URI.revive(resource);
    const ref = await this._resolverService.createModelReference(uri);
    try {
      ref.object.textEditorModel.setLanguage(this._languageService.createById(languageId));
    } finally {
      ref.dispose();
    }
  }
  async $tokensAtPosition(resource, position) {
    const uri = URI.revive(resource);
    const model = this._modelService.getModel(uri);
    if (!model) {
      return void 0;
    }
    model.tokenization.tokenizeIfCheap(position.lineNumber);
    const tokens = model.tokenization.getLineTokens(position.lineNumber);
    const idx = tokens.findTokenIndexAtOffset(position.column - 1);
    return {
      type: tokens.getStandardTokenType(idx),
      range: new Range(
        position.lineNumber,
        1 + tokens.getStartOffset(idx),
        position.lineNumber,
        1 + tokens.getEndOffset(idx)
      )
    };
  }
  $setLanguageStatus(handle, status2) {
    var _a30;
    (_a30 = this._status.get(handle)) == null ? void 0 : _a30.dispose();
    this._status.set(handle, this._languageStatusService.addStatus(status2));
  }
  $removeLanguageStatus(handle) {
    var _a30;
    (_a30 = this._status.get(handle)) == null ? void 0 : _a30.dispose();
  }
};
MainThreadLanguages = __decorate([
  extHostNamedCustomer(MainContext.MainThreadLanguages),
  __param(1, ILanguageService),
  __param(2, IModelService),
  __param(3, ITextModelService),
  __param(4, ILanguageStatusService)
], MainThreadLanguages);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadLogService.js
init_tslib_es6();
init_log();
init_lifecycle();
init_extHost_protocol();
init_uri();
init_commands();
init_environment();
var MainThreadLoggerService = class MainThreadLoggerService2 {
  constructor(extHostContext, loggerService) {
    this.loggerService = loggerService;
    this.disposables = new DisposableStore();
    const proxy = extHostContext.getProxy(ExtHostContext.ExtHostLogLevelServiceShape);
    this.disposables.add(loggerService.onDidChangeLogLevel((arg) => {
      if (isLogLevel(arg)) {
        proxy.$setLogLevel(arg);
      } else {
        proxy.$setLogLevel(arg[1], arg[0]);
      }
    }));
  }
  $log(file, messages) {
    const logger = this.loggerService.getLogger(URI.revive(file));
    if (!logger) {
      throw new Error("Create the logger before logging");
    }
    for (const [level, message] of messages) {
      log(logger, level, message);
    }
  }
  async $createLogger(file, options) {
    this.loggerService.createLogger(URI.revive(file), options);
  }
  async $registerLogger(logResource) {
    this.loggerService.registerLogger({
      ...logResource,
      resource: URI.revive(logResource.resource)
    });
  }
  async $deregisterLogger(resource) {
    this.loggerService.deregisterLogger(URI.revive(resource));
  }
  async $setVisibility(resource, visible) {
    this.loggerService.setVisibility(URI.revive(resource), visible);
  }
  $flush(file) {
    const logger = this.loggerService.getLogger(URI.revive(file));
    if (!logger) {
      throw new Error("Create the logger before flushing");
    }
    logger.flush();
  }
  dispose() {
    this.disposables.dispose();
  }
};
MainThreadLoggerService = __decorate([
  extHostNamedCustomer(MainContext.MainThreadLogger),
  __param(1, ILoggerService)
], MainThreadLoggerService);
CommandsRegistry.registerCommand("_extensionTests.setLogLevel", function(accessor, level) {
  const loggerService = accessor.get(ILoggerService);
  const environmentService = accessor.get(IEnvironmentService);
  if (environmentService.isExtensionDevelopment && !!environmentService.extensionTestsLocationURI) {
    const logLevel = parseLogLevel(level);
    if (logLevel !== void 0) {
      loggerService.setLogLevel(logLevel);
    }
  }
});
CommandsRegistry.registerCommand("_extensionTests.getLogLevel", function(accessor) {
  const logService = accessor.get(ILogService);
  return LogLevelToString(logService.getLevel());
});

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadMessageService.js
init_tslib_es6();
init_nls();
init_actions();
init_extHost_protocol();
init_event();
var MainThreadMessageService = class MainThreadMessageService2 {
  constructor(extHostContext, _notificationService, _dialogService) {
    this._notificationService = _notificationService;
    this._dialogService = _dialogService;
  }
  dispose() {
  }
  $showMessage(severity, message, options, commands) {
    if (options.modal) {
      return this._showModalMessage(severity, message, options.detail, commands, options.useCustom);
    } else {
      return this._showMessage(severity, message, commands, options);
    }
  }
  _showMessage(severity, message, commands, options) {
    return new Promise((resolve) => {
      const primaryActions = commands.map((command) => toAction({
        id: `_extension_message_handle_${command.handle}`,
        label: command.title,
        enabled: true,
        run: () => {
          resolve(command.handle);
          return Promise.resolve();
        }
      }));
      let source;
      if (options.source) {
        source = {
          label: localize("extensionSource", "{0} (Extension)", options.source.label),
          id: options.source.identifier.value
        };
      }
      if (!source) {
        source = localize("defaultSource", "Extension");
      }
      const secondaryActions = [];
      const messageHandle = this._notificationService.notify({
        severity,
        message,
        actions: { primary: primaryActions, secondary: secondaryActions },
        source
      });
      Event.once(messageHandle.onDidClose)(() => {
        resolve(void 0);
      });
    });
  }
  async _showModalMessage(severity, message, detail, commands, useCustom) {
    const buttons = [];
    let cancelButton = void 0;
    for (const command of commands) {
      const button = {
        label: command.title,
        run: () => command.handle
      };
      if (command.isCloseAffordance) {
        cancelButton = button;
      } else {
        buttons.push(button);
      }
    }
    if (!cancelButton) {
      if (buttons.length > 0) {
        cancelButton = {
          label: localize("cancel", "Cancel"),
          run: () => void 0
        };
      } else {
        cancelButton = {
          label: localize({ key: "ok", comment: ["&& denotes a mnemonic"] }, "&&OK"),
          run: () => void 0
        };
      }
    }
    const { result } = await this._dialogService.prompt({
      type: severity,
      message,
      detail,
      buttons,
      cancelButton,
      custom: useCustom
    });
    return result;
  }
};
MainThreadMessageService = __decorate([
  extHostNamedCustomer(MainContext.MainThreadMessageService),
  __param(1, INotificationService),
  __param(2, IDialogService)
], MainThreadMessageService);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadManagedSockets.js
init_tslib_es6();
init_event();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/platform/remote/common/managedSocket.js
init_buffer();
init_event();
init_lifecycle();
var makeRawSocketHeaders = (path, query, deubgLabel) => {
  const buffer = new Uint8Array(16);
  for (let i = 0; i < 16; i++) {
    buffer[i] = Math.round(Math.random() * 256);
  }
  const nonce = encodeBase64(VSBuffer.wrap(buffer));
  const headers = [
    `GET ws://localhost${path}?${query}&skipWebSocketFrames=true HTTP/1.1`,
    `Connection: Upgrade`,
    `Upgrade: websocket`,
    `Sec-WebSocket-Key: ${nonce}`
  ];
  return headers.join("\r\n") + "\r\n\r\n";
};
var socketRawEndHeaderSequence = VSBuffer.fromString("\r\n\r\n");
async function connectManagedSocket(socket, path, query, debugLabel, half) {
  socket.write(VSBuffer.fromString(makeRawSocketHeaders(path, query)));
  const d = new DisposableStore();
  try {
    return await new Promise((resolve, reject) => {
      let dataSoFar;
      d.add(socket.onData((d_1) => {
        if (!dataSoFar) {
          dataSoFar = d_1;
        } else {
          dataSoFar = VSBuffer.concat([dataSoFar, d_1], dataSoFar.byteLength + d_1.byteLength);
        }
        const index = dataSoFar.indexOf(socketRawEndHeaderSequence);
        if (index === -1) {
          return;
        }
        resolve(socket);
        socket.pauseData();
        const rest = dataSoFar.slice(index + socketRawEndHeaderSequence.byteLength);
        if (rest.byteLength) {
          half.onData.fire(rest);
        }
      }));
      d.add(socket.onClose((err) => reject(err ?? new Error("socket closed"))));
      d.add(socket.onEnd(() => reject(new Error("socket ended"))));
    });
  } catch (e) {
    socket.dispose();
    throw e;
  } finally {
    d.dispose();
  }
}
var ManagedSocket2 = class extends Disposable {
  constructor(debugLabel, half) {
    super();
    this.debugLabel = debugLabel;
    this.pausableDataEmitter = this._register(new PauseableEmitter());
    this.onData = (...args) => {
      if (this.pausableDataEmitter.isPaused) {
        queueMicrotask(() => this.pausableDataEmitter.resume());
      }
      return this.pausableDataEmitter.event(...args);
    };
    this.didDisposeEmitter = this._register(new Emitter());
    this.onDidDispose = this.didDisposeEmitter.event;
    this.ended = false;
    this._register(half.onData);
    this._register(half.onData.event((data) => this.pausableDataEmitter.fire(data)));
    this.onClose = this._register(half.onClose).event;
    this.onEnd = this._register(half.onEnd).event;
  }
  pauseData() {
    this.pausableDataEmitter.pause();
  }
  drain() {
    return Promise.resolve();
  }
  end() {
    this.ended = true;
    this.closeRemote();
  }
  traceSocketEvent(type, data) {
    SocketDiagnostics.traceSocketEvent(this, this.debugLabel, type, data);
  }
  dispose() {
    if (!this.ended) {
      this.closeRemote();
    }
    this.didDisposeEmitter.fire();
    super.dispose();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadManagedSockets.js
init_extHost_protocol();
var MainThreadManagedSockets = class MainThreadManagedSockets2 extends Disposable {
  constructor(extHostContext, _remoteSocketFactoryService) {
    super();
    this._remoteSocketFactoryService = _remoteSocketFactoryService;
    this._registrations = /* @__PURE__ */ new Map();
    this._remoteSockets = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostManagedSockets);
  }
  async $registerSocketFactory(socketFactoryId) {
    const that = this;
    const socketFactory = new class {
      supports(connectTo) {
        return connectTo.id === socketFactoryId;
      }
      connect(connectTo, path, query, debugLabel) {
        return new Promise((resolve, reject) => {
          if (connectTo.id !== socketFactoryId) {
            return reject(new Error("Invalid connectTo"));
          }
          const factoryId = connectTo.id;
          that._proxy.$openRemoteSocket(factoryId).then((socketId) => {
            const half = {
              onClose: new Emitter(),
              onData: new Emitter(),
              onEnd: new Emitter()
            };
            that._remoteSockets.set(socketId, half);
            MainThreadManagedSocket.connect(socketId, that._proxy, path, query, debugLabel, half).then((socket) => {
              socket.onDidDispose(() => that._remoteSockets.delete(socketId));
              resolve(socket);
            }, (err) => {
              that._remoteSockets.delete(socketId);
              reject(err);
            });
          }).catch(reject);
        });
      }
    }();
    this._registrations.set(socketFactoryId, this._remoteSocketFactoryService.register(1, socketFactory));
  }
  async $unregisterSocketFactory(socketFactoryId) {
    var _a30;
    (_a30 = this._registrations.get(socketFactoryId)) == null ? void 0 : _a30.dispose();
  }
  $onDidManagedSocketHaveData(socketId, data) {
    var _a30;
    (_a30 = this._remoteSockets.get(socketId)) == null ? void 0 : _a30.onData.fire(data);
  }
  $onDidManagedSocketClose(socketId, error) {
    var _a30;
    (_a30 = this._remoteSockets.get(socketId)) == null ? void 0 : _a30.onClose.fire({
      type: 0,
      error: error ? new Error(error) : void 0,
      hadError: !!error
    });
    this._remoteSockets.delete(socketId);
  }
  $onDidManagedSocketEnd(socketId) {
    var _a30;
    (_a30 = this._remoteSockets.get(socketId)) == null ? void 0 : _a30.onEnd.fire();
  }
};
MainThreadManagedSockets = __decorate([
  extHostNamedCustomer(MainContext.MainThreadManagedSockets),
  __param(1, IRemoteSocketFactoryService)
], MainThreadManagedSockets);
var MainThreadManagedSocket = class _MainThreadManagedSocket extends ManagedSocket2 {
  static connect(socketId, proxy, path, query, debugLabel, half) {
    const socket = new _MainThreadManagedSocket(socketId, proxy, debugLabel, half);
    return connectManagedSocket(socket, path, query, debugLabel, half);
  }
  constructor(socketId, proxy, debugLabel, half) {
    super(debugLabel, half);
    this.socketId = socketId;
    this.proxy = proxy;
  }
  write(buffer) {
    this.proxy.$remoteSocketWrite(this.socketId, buffer);
  }
  closeRemote() {
    this.proxy.$remoteSocketEnd(this.socketId);
  }
  drain() {
    return this.proxy.$remoteSocketDrain(this.socketId);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadOutputService.js
init_tslib_es6();
init_platform2();
init_extHost_protocol();
init_uri();
init_lifecycle();
init_event();
init_types();
var MainThreadOutputService_1;
var _a21;
var MainThreadOutputService = (_a21 = class extends Disposable {
  constructor(extHostContext, outputService, viewsService) {
    super();
    this._outputService = outputService;
    this._viewsService = viewsService;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostOutputService);
    const setVisibleChannel = () => {
      const visibleChannel = this._viewsService.isViewVisible(OUTPUT_VIEW_ID) ? this._outputService.getActiveChannel() : void 0;
      this._proxy.$setVisibleChannel(visibleChannel ? visibleChannel.id : null);
    };
    this._register(Event.any(this._outputService.onActiveOutputChannel, Event.filter(this._viewsService.onDidChangeViewVisibility, ({ id }) => id === OUTPUT_VIEW_ID))(() => setVisibleChannel()));
    setVisibleChannel();
  }
  async $register(label, file, languageId, extensionId) {
    const idCounter = (MainThreadOutputService_1._extensionIdPool.get(extensionId) || 0) + 1;
    MainThreadOutputService_1._extensionIdPool.set(extensionId, idCounter);
    const id = `extension-output-${extensionId}-#${idCounter}-${label}`;
    const resource = URI.revive(file);
    Registry.as(Extensions3.OutputChannels).registerChannel({ id, label, file: resource, log: false, languageId, extensionId });
    this._register(toDisposable(() => this.$dispose(id)));
    return id;
  }
  async $update(channelId, mode, till) {
    const channel = this._getChannel(channelId);
    if (channel) {
      if (mode === OutputChannelUpdateMode.Append) {
        channel.update(mode);
      } else if (isNumber(till)) {
        channel.update(mode, till);
      }
    }
  }
  async $reveal(channelId, preserveFocus) {
    const channel = this._getChannel(channelId);
    if (channel) {
      this._outputService.showChannel(channel.id, preserveFocus);
    }
  }
  async $close(channelId) {
    if (this._viewsService.isViewVisible(OUTPUT_VIEW_ID)) {
      const activeChannel = this._outputService.getActiveChannel();
      if (activeChannel && channelId === activeChannel.id) {
        this._viewsService.closeView(OUTPUT_VIEW_ID);
      }
    }
  }
  async $dispose(channelId) {
    const channel = this._getChannel(channelId);
    channel == null ? void 0 : channel.dispose();
  }
  _getChannel(channelId) {
    return this._outputService.getChannel(channelId);
  }
}, MainThreadOutputService_1 = _a21, _a21._extensionIdPool = /* @__PURE__ */ new Map(), _a21);
MainThreadOutputService = MainThreadOutputService_1 = __decorate([
  extHostNamedCustomer(MainContext.MainThreadOutputService),
  __param(1, IOutputService),
  __param(2, IViewsService)
], MainThreadOutputService);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadProgress.js
init_tslib_es6();
init_progress();
init_extHost_protocol();
init_actions();
init_commands();
init_nls();
var ManageExtensionAction = class extends Action {
  constructor(extensionId, label, commandService) {
    super(extensionId, label, void 0, true, () => {
      return commandService.executeCommand("_extensions.manage", extensionId);
    });
  }
};
var MainThreadProgress = class MainThreadProgress2 {
  constructor(extHostContext, progressService, _commandService) {
    this._commandService = _commandService;
    this._progress = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostProgress);
    this._progressService = progressService;
  }
  dispose() {
    this._progress.forEach((handle) => handle.resolve());
    this._progress.clear();
  }
  async $startProgress(handle, options, extensionId) {
    const task = this._createTask(handle);
    if (options.location === 15 && extensionId) {
      const notificationOptions = {
        ...options,
        location: 15,
        secondaryActions: [new ManageExtensionAction(extensionId, localize("manageExtension", "Manage Extension"), this._commandService)]
      };
      options = notificationOptions;
    }
    this._progressService.withProgress(options, task, () => this._proxy.$acceptProgressCanceled(handle));
  }
  $progressReport(handle, message) {
    const entry = this._progress.get(handle);
    entry == null ? void 0 : entry.progress.report(message);
  }
  $progressEnd(handle) {
    const entry = this._progress.get(handle);
    if (entry) {
      entry.resolve();
      this._progress.delete(handle);
    }
  }
  _createTask(handle) {
    return (progress) => {
      return new Promise((resolve) => {
        this._progress.set(handle, { resolve, progress });
      });
    };
  }
};
MainThreadProgress = __decorate([
  extHostNamedCustomer(MainContext.MainThreadProgress),
  __param(1, IProgressService),
  __param(2, ICommandService)
], MainThreadProgress);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadQuickDiff.js
init_tslib_es6();
init_cancellation();
init_lifecycle();
init_uri();
init_extHost_protocol();
var MainThreadQuickDiff = class MainThreadQuickDiff2 {
  constructor(extHostContext, quickDiffService) {
    this.quickDiffService = quickDiffService;
    this.providers = /* @__PURE__ */ new Map();
    this.providerDisposables = /* @__PURE__ */ new Map();
    this.proxy = extHostContext.getProxy(ExtHostContext.ExtHostQuickDiff);
  }
  async $registerQuickDiffProvider(handle, selector, label, rootUri) {
    const provider = {
      label,
      rootUri: URI.revive(rootUri),
      selector,
      isSCM: false,
      getOriginalResource: async (uri) => {
        return URI.revive(await this.proxy.$provideOriginalResource(handle, uri, new CancellationTokenSource().token));
      }
    };
    this.providers.set(handle, provider);
    const disposable = this.quickDiffService.addQuickDiffProvider(provider);
    this.providerDisposables.set(handle, disposable);
  }
  async $unregisterQuickDiffProvider(handle) {
    if (this.providers.has(handle)) {
      this.providers.delete(handle);
    }
    if (this.providerDisposables.has(handle)) {
      this.providerDisposables.delete(handle);
    }
  }
  dispose() {
    this.providers.clear();
    dispose(this.providerDisposables.values());
    this.providerDisposables.clear();
  }
};
MainThreadQuickDiff = __decorate([
  extHostNamedCustomer(MainContext.MainThreadQuickDiff),
  __param(1, IQuickDiffService)
], MainThreadQuickDiff);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadQuickOpen.js
init_tslib_es6();
init_extHost_protocol();
init_uri();
function reviveIconPathUris(iconPath) {
  iconPath.dark = URI.revive(iconPath.dark);
  if (iconPath.light) {
    iconPath.light = URI.revive(iconPath.light);
  }
}
var MainThreadQuickOpen = class MainThreadQuickOpen2 {
  constructor(extHostContext, quickInputService) {
    this._items = {};
    this.sessions = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostQuickOpen);
    this._quickInputService = quickInputService;
  }
  dispose() {
  }
  $show(instance, options, token) {
    const contents = new Promise((resolve, reject) => {
      this._items[instance] = { resolve, reject };
    });
    options = {
      ...options,
      onDidFocus: (el) => {
        if (el) {
          this._proxy.$onItemSelected(el.handle);
        }
      }
    };
    if (options.canPickMany) {
      return this._quickInputService.pick(contents, options, token).then((items) => {
        if (items) {
          return items.map((item) => item.handle);
        }
        return void 0;
      });
    } else {
      return this._quickInputService.pick(contents, options, token).then((item) => {
        if (item) {
          return item.handle;
        }
        return void 0;
      });
    }
  }
  $setItems(instance, items) {
    if (this._items[instance]) {
      this._items[instance].resolve(items);
      delete this._items[instance];
    }
    return Promise.resolve();
  }
  $setError(instance, error) {
    if (this._items[instance]) {
      this._items[instance].reject(error);
      delete this._items[instance];
    }
    return Promise.resolve();
  }
  $input(options, validateInput, token) {
    const inputOptions = /* @__PURE__ */ Object.create(null);
    if (options) {
      inputOptions.title = options.title;
      inputOptions.password = options.password;
      inputOptions.placeHolder = options.placeHolder;
      inputOptions.valueSelection = options.valueSelection;
      inputOptions.prompt = options.prompt;
      inputOptions.value = options.value;
      inputOptions.ignoreFocusLost = options.ignoreFocusOut;
    }
    if (validateInput) {
      inputOptions.validateInput = (value) => {
        return this._proxy.$validateInput(value);
      };
    }
    return this._quickInputService.input(inputOptions, token);
  }
  $createOrUpdate(params) {
    const sessionId = params.id;
    let session = this.sessions.get(sessionId);
    if (!session) {
      const input2 = params.type === "quickPick" ? this._quickInputService.createQuickPick() : this._quickInputService.createInputBox();
      input2.onDidAccept(() => {
        this._proxy.$onDidAccept(sessionId);
      });
      input2.onDidTriggerButton((button) => {
        this._proxy.$onDidTriggerButton(sessionId, button.handle);
      });
      input2.onDidChangeValue((value) => {
        this._proxy.$onDidChangeValue(sessionId, value);
      });
      input2.onDidHide(() => {
        this._proxy.$onDidHide(sessionId);
      });
      if (params.type === "quickPick") {
        const quickpick = input2;
        quickpick.onDidChangeActive((items) => {
          this._proxy.$onDidChangeActive(sessionId, items.map((item) => item.handle));
        });
        quickpick.onDidChangeSelection((items) => {
          this._proxy.$onDidChangeSelection(sessionId, items.map((item) => item.handle));
        });
        quickpick.onDidTriggerItemButton((e) => {
          this._proxy.$onDidTriggerItemButton(sessionId, e.item.handle, e.button.handle);
        });
      }
      session = {
        input: input2,
        handlesToItems: /* @__PURE__ */ new Map()
      };
      this.sessions.set(sessionId, session);
    }
    const { input, handlesToItems } = session;
    for (const param in params) {
      if (param === "id" || param === "type") {
        continue;
      }
      if (param === "visible") {
        if (params.visible) {
          input.show();
        } else {
          input.hide();
        }
      } else if (param === "items") {
        handlesToItems.clear();
        params[param].forEach((item) => {
          if (item.type === "separator") {
            return;
          }
          if (item.buttons) {
            item.buttons = item.buttons.map((button) => {
              if (button.iconPath) {
                reviveIconPathUris(button.iconPath);
              }
              return button;
            });
          }
          handlesToItems.set(item.handle, item);
        });
        input[param] = params[param];
      } else if (param === "activeItems" || param === "selectedItems") {
        input[param] = params[param].filter((handle) => handlesToItems.has(handle)).map((handle) => handlesToItems.get(handle));
      } else if (param === "buttons") {
        input[param] = params.buttons.map((button) => {
          if (button.handle === -1) {
            return this._quickInputService.backButton;
          }
          if (button.iconPath) {
            reviveIconPathUris(button.iconPath);
          }
          return button;
        });
      } else {
        input[param] = params[param];
      }
    }
    return Promise.resolve(void 0);
  }
  $dispose(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.input.dispose();
      this.sessions.delete(sessionId);
    }
    return Promise.resolve(void 0);
  }
};
MainThreadQuickOpen = __decorate([
  extHostNamedCustomer(MainContext.MainThreadQuickOpen),
  __param(1, IQuickInputService)
], MainThreadQuickOpen);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadRemoteConnectionData.js
init_tslib_es6();
init_extHost_protocol();
init_remoteAuthorityResolver();
init_lifecycle();
var MainThreadRemoteConnectionData = class MainThreadRemoteConnectionData2 extends Disposable {
  constructor(extHostContext, _environmentService, remoteAuthorityResolverService) {
    super();
    this._environmentService = _environmentService;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostExtensionService);
    const remoteAuthority = this._environmentService.remoteAuthority;
    if (remoteAuthority) {
      this._register(remoteAuthorityResolverService.onDidChangeConnectionData(() => {
        const connectionData = remoteAuthorityResolverService.getConnectionData(remoteAuthority);
        if (connectionData) {
          this._proxy.$updateRemoteConnectionData(connectionData);
        }
      }));
    }
  }
};
MainThreadRemoteConnectionData = __decorate([
  extHostCustomer,
  __param(1, IWorkbenchEnvironmentService),
  __param(2, IRemoteAuthorityResolverService)
], MainThreadRemoteConnectionData);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadSaveParticipant.js
init_tslib_es6();
init_model();
init_nls();
init_instantiation();
init_extHost_protocol();
init_async();
var ExtHostSaveParticipant = class {
  constructor(extHostContext) {
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostDocumentSaveParticipant);
  }
  async participate(editorModel, env2, _progress, token) {
    if (!editorModel.textEditorModel || !shouldSynchronizeModel(editorModel.textEditorModel)) {
      return void 0;
    }
    const p = new Promise((resolve, reject) => {
      setTimeout(() => reject(new Error(localize("timeout.onWillSave", "Aborted onWillSaveTextDocument-event after 1750ms"))), 1750);
      this._proxy.$participateInSave(editorModel.resource, env2.reason).then((values) => {
        if (!values.every((success) => success)) {
          return Promise.reject(new Error("listener failed"));
        }
        return void 0;
      }).then(resolve, reject);
    });
    return raceCancellationError(p, token);
  }
};
var SaveParticipant = class SaveParticipant2 {
  constructor(extHostContext, instantiationService, _textFileService) {
    this._textFileService = _textFileService;
    this._saveParticipantDisposable = this._textFileService.files.addSaveParticipant(instantiationService.createInstance(ExtHostSaveParticipant, extHostContext));
  }
  dispose() {
    this._saveParticipantDisposable.dispose();
  }
};
SaveParticipant = __decorate([
  extHostCustomer,
  __param(1, IInstantiationService),
  __param(2, ITextFileService)
], SaveParticipant);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadEditSessionIdentityParticipant.js
init_tslib_es6();
init_nls();
init_instantiation();
init_async();
init_editSessions();
init_extHost_protocol();
var ExtHostEditSessionIdentityCreateParticipant = class {
  constructor(extHostContext) {
    this.timeout = 1e4;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostWorkspace);
  }
  async participate(workspaceFolder, token) {
    const p = new Promise((resolve, reject) => {
      setTimeout(() => reject(new Error(localize(
        "timeout.onWillCreateEditSessionIdentity",
        "Aborted onWillCreateEditSessionIdentity-event after 10000ms"
      ))), this.timeout);
      this._proxy.$onWillCreateEditSessionIdentity(workspaceFolder.uri, token, this.timeout).then(resolve, reject);
    });
    return raceCancellationError(p, token);
  }
};
var EditSessionIdentityCreateParticipant = class EditSessionIdentityCreateParticipant2 {
  constructor(extHostContext, instantiationService, _editSessionIdentityService) {
    this._editSessionIdentityService = _editSessionIdentityService;
    this._saveParticipantDisposable = this._editSessionIdentityService.addEditSessionIdentityCreateParticipant(instantiationService.createInstance(ExtHostEditSessionIdentityCreateParticipant, extHostContext));
  }
  dispose() {
    this._saveParticipantDisposable.dispose();
  }
};
EditSessionIdentityCreateParticipant = __decorate([
  extHostCustomer,
  __param(1, IInstantiationService),
  __param(2, IEditSessionIdentityService)
], EditSessionIdentityCreateParticipant);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadSCM.js
init_tslib_es6();
init_uri();
init_event();
init_lifecycle();
init_extHost_protocol();

// node_modules/monaco-editor/esm/vs/base/common/sequence.js
init_event();
var Sequence = class {
  constructor() {
    this.elements = [];
    this._onDidSplice = new Emitter();
    this.onDidSplice = this._onDidSplice.event;
  }
  splice(start, deleteCount, toInsert = []) {
    this.elements.splice(start, deleteCount, ...toInsert);
    this._onDidSplice.fire({ start, deleteCount, toInsert });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadSCM.js
init_cancellation();
init_themables();
var MainThreadSCMResourceGroup = class {
  get hideWhenEmpty() {
    return !!this.features.hideWhenEmpty;
  }
  constructor(sourceControlHandle, handle, provider, features, label, id) {
    this.sourceControlHandle = sourceControlHandle;
    this.handle = handle;
    this.provider = provider;
    this.features = features;
    this.label = label;
    this.id = id;
    this.elements = [];
    this._onDidSplice = new Emitter();
    this.onDidSplice = this._onDidSplice.event;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  toJSON() {
    return {
      $mid: 4,
      sourceControlHandle: this.sourceControlHandle,
      groupHandle: this.handle
    };
  }
  splice(start, deleteCount, toInsert) {
    this.elements.splice(start, deleteCount, ...toInsert);
    this._onDidSplice.fire({ start, deleteCount, toInsert });
  }
  $updateGroup(features) {
    this.features = { ...this.features, ...features };
    this._onDidChange.fire();
  }
  $updateGroupLabel(label) {
    this.label = label;
    this._onDidChange.fire();
  }
};
var MainThreadSCMResource = class {
  constructor(proxy, sourceControlHandle, groupHandle, handle, sourceUri, resourceGroup, decorations, contextValue, command) {
    this.proxy = proxy;
    this.sourceControlHandle = sourceControlHandle;
    this.groupHandle = groupHandle;
    this.handle = handle;
    this.sourceUri = sourceUri;
    this.resourceGroup = resourceGroup;
    this.decorations = decorations;
    this.contextValue = contextValue;
    this.command = command;
  }
  open(preserveFocus) {
    return this.proxy.$executeResourceCommand(this.sourceControlHandle, this.groupHandle, this.handle, preserveFocus);
  }
  toJSON() {
    return {
      $mid: 3,
      sourceControlHandle: this.sourceControlHandle,
      groupHandle: this.groupHandle,
      handle: this.handle
    };
  }
};
var _MainThreadSCMProvider = class _MainThreadSCMProvider {
  get id() {
    return this._id;
  }
  get handle() {
    return this._handle;
  }
  get label() {
    return this._label;
  }
  get rootUri() {
    return this._rootUri;
  }
  get inputBoxDocumentUri() {
    return this._inputBoxDocumentUri;
  }
  get contextValue() {
    return this._contextValue;
  }
  get commitTemplate() {
    return this.features.commitTemplate || "";
  }
  get acceptInputCommand() {
    return this.features.acceptInputCommand;
  }
  get actionButton() {
    return this.features.actionButton ?? void 0;
  }
  get statusBarCommands() {
    return this.features.statusBarCommands;
  }
  get count() {
    return this.features.count;
  }
  get onDidChangeStatusBarCommands() {
    return this._onDidChangeStatusBarCommands.event;
  }
  constructor(proxy, _handle4, _contextValue, _label, _rootUri, _inputBoxDocumentUri, _quickDiffService) {
    this.proxy = proxy;
    this._handle = _handle4;
    this._contextValue = _contextValue;
    this._label = _label;
    this._rootUri = _rootUri;
    this._inputBoxDocumentUri = _inputBoxDocumentUri;
    this._quickDiffService = _quickDiffService;
    this._id = `scm${_MainThreadSCMProvider.ID_HANDLE++}`;
    this.groups = new Sequence();
    this._groupsByHandle = /* @__PURE__ */ Object.create(null);
    this._onDidChangeResources = new Emitter();
    this.onDidChangeResources = this._onDidChangeResources.event;
    this.features = {};
    this._onDidChangeCommitTemplate = new Emitter();
    this.onDidChangeCommitTemplate = this._onDidChangeCommitTemplate.event;
    this._onDidChangeStatusBarCommands = new Emitter();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this.isSCM = true;
  }
  $updateSourceControl(features) {
    this.features = { ...this.features, ...features };
    this._onDidChange.fire();
    if (typeof features.commitTemplate !== "undefined") {
      this._onDidChangeCommitTemplate.fire(this.commitTemplate);
    }
    if (typeof features.statusBarCommands !== "undefined") {
      this._onDidChangeStatusBarCommands.fire(this.statusBarCommands);
    }
    if (features.hasQuickDiffProvider && !this._quickDiff) {
      this._quickDiff = this._quickDiffService.addQuickDiffProvider({
        label: features.quickDiffLabel ?? this.label,
        rootUri: this.rootUri,
        isSCM: this.isSCM,
        getOriginalResource: (uri) => this.getOriginalResource(uri)
      });
    } else if (features.hasQuickDiffProvider === false && this._quickDiff) {
      this._quickDiff.dispose();
      this._quickDiff = void 0;
    }
  }
  $registerGroups(_groups) {
    const groups = _groups.map(([handle, id, label, features]) => {
      const group = new MainThreadSCMResourceGroup(this.handle, handle, this, features, label, id);
      this._groupsByHandle[handle] = group;
      return group;
    });
    this.groups.splice(this.groups.elements.length, 0, groups);
  }
  $updateGroup(handle, features) {
    const group = this._groupsByHandle[handle];
    if (!group) {
      return;
    }
    group.$updateGroup(features);
  }
  $updateGroupLabel(handle, label) {
    const group = this._groupsByHandle[handle];
    if (!group) {
      return;
    }
    group.$updateGroupLabel(label);
  }
  $spliceGroupResourceStates(splices) {
    for (const [groupHandle, groupSlices] of splices) {
      const group = this._groupsByHandle[groupHandle];
      if (!group) {
        console.warn(`SCM group ${groupHandle} not found in provider ${this.label}`);
        continue;
      }
      groupSlices.reverse();
      for (const [start, deleteCount, rawResources] of groupSlices) {
        const resources = rawResources.map((rawResource) => {
          const [handle, sourceUri, icons, tooltip, strikeThrough, faded, contextValue, command] = rawResource;
          const [light, dark] = icons;
          const icon = ThemeIcon.isThemeIcon(light) ? light : URI.revive(light);
          const iconDark = (ThemeIcon.isThemeIcon(dark) ? dark : URI.revive(dark)) || icon;
          const decorations = {
            icon,
            iconDark,
            tooltip,
            strikeThrough,
            faded
          };
          return new MainThreadSCMResource(
            this.proxy,
            this.handle,
            groupHandle,
            handle,
            URI.revive(sourceUri),
            group,
            decorations,
            contextValue || void 0,
            command
          );
        });
        group.splice(start, deleteCount, resources);
      }
    }
    this._onDidChangeResources.fire();
  }
  $unregisterGroup(handle) {
    const group = this._groupsByHandle[handle];
    if (!group) {
      return;
    }
    delete this._groupsByHandle[handle];
    this.groups.splice(this.groups.elements.indexOf(group), 1);
    this._onDidChangeResources.fire();
  }
  async getOriginalResource(uri) {
    if (!this.features.hasQuickDiffProvider) {
      return null;
    }
    const result = await this.proxy.$provideOriginalResource(this.handle, uri, CancellationToken.None);
    return result && URI.revive(result);
  }
  toJSON() {
    return {
      $mid: 5,
      handle: this.handle
    };
  }
  dispose() {
    var _a30;
    (_a30 = this._quickDiff) == null ? void 0 : _a30.dispose();
  }
};
_MainThreadSCMProvider.ID_HANDLE = 0;
var MainThreadSCMProvider = _MainThreadSCMProvider;
var MainThreadSCM = class MainThreadSCM2 {
  constructor(extHostContext, scmService, scmViewService, quickDiffService) {
    this.scmService = scmService;
    this.scmViewService = scmViewService;
    this.quickDiffService = quickDiffService;
    this._repositories = /* @__PURE__ */ new Map();
    this._repositoryDisposables = /* @__PURE__ */ new Map();
    this._disposables = new DisposableStore();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostSCM);
  }
  dispose() {
    dispose(this._repositories.values());
    this._repositories.clear();
    dispose(this._repositoryDisposables.values());
    this._repositoryDisposables.clear();
    this._disposables.dispose();
  }
  $registerSourceControl(handle, id, label, rootUri, inputBoxDocumentUri) {
    const provider = new MainThreadSCMProvider(
      this._proxy,
      handle,
      id,
      label,
      rootUri ? URI.revive(rootUri) : void 0,
      URI.revive(inputBoxDocumentUri),
      this.quickDiffService
    );
    const repository = this.scmService.registerSCMProvider(provider);
    this._repositories.set(handle, repository);
    const disposable = combinedDisposable(Event.filter(this.scmViewService.onDidFocusRepository, (r) => r === repository)((_) => this._proxy.$setSelectedSourceControl(handle)), repository.input.onDidChange(({ value }) => this._proxy.$onInputBoxValueChange(handle, value)));
    if (this.scmViewService.focusedRepository === repository) {
      setTimeout(() => this._proxy.$setSelectedSourceControl(handle), 0);
    }
    if (repository.input.value) {
      setTimeout(() => this._proxy.$onInputBoxValueChange(handle, repository.input.value), 0);
    }
    this._repositoryDisposables.set(handle, disposable);
  }
  $updateSourceControl(handle, features) {
    const repository = this._repositories.get(handle);
    if (!repository) {
      return;
    }
    const provider = repository.provider;
    provider.$updateSourceControl(features);
  }
  $unregisterSourceControl(handle) {
    const repository = this._repositories.get(handle);
    if (!repository) {
      return;
    }
    this._repositoryDisposables.get(handle).dispose();
    this._repositoryDisposables.delete(handle);
    repository.dispose();
    this._repositories.delete(handle);
  }
  $registerGroups(sourceControlHandle, groups, splices) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    const provider = repository.provider;
    provider.$registerGroups(groups);
    provider.$spliceGroupResourceStates(splices);
  }
  $updateGroup(sourceControlHandle, groupHandle, features) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    const provider = repository.provider;
    provider.$updateGroup(groupHandle, features);
  }
  $updateGroupLabel(sourceControlHandle, groupHandle, label) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    const provider = repository.provider;
    provider.$updateGroupLabel(groupHandle, label);
  }
  $spliceResourceStates(sourceControlHandle, splices) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    const provider = repository.provider;
    provider.$spliceGroupResourceStates(splices);
  }
  $unregisterGroup(sourceControlHandle, handle) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    const provider = repository.provider;
    provider.$unregisterGroup(handle);
  }
  $setInputBoxValue(sourceControlHandle, value) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    repository.input.setValue(value, false);
  }
  $setInputBoxPlaceholder(sourceControlHandle, placeholder) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    repository.input.placeholder = placeholder;
  }
  $setInputBoxEnablement(sourceControlHandle, enabled) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    repository.input.enabled = enabled;
  }
  $setInputBoxVisibility(sourceControlHandle, visible) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    repository.input.visible = visible;
  }
  $showValidationMessage(sourceControlHandle, message, type) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    repository.input.showValidationMessage(message, type);
  }
  $setValidationProviderIsEnabled(sourceControlHandle, enabled) {
    const repository = this._repositories.get(sourceControlHandle);
    if (!repository) {
      return;
    }
    if (enabled) {
      repository.input.validateInput = async (value, pos) => {
        const result = await this._proxy.$validateInput(sourceControlHandle, value, pos);
        return result && { message: result[0], type: result[1] };
      };
    } else {
      repository.input.validateInput = async () => void 0;
    }
  }
};
MainThreadSCM = __decorate([
  extHostNamedCustomer(MainContext.MainThreadSCM),
  __param(1, ISCMService),
  __param(2, ISCMViewService),
  __param(3, IQuickDiffService)
], MainThreadSCM);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadSearch.js
init_tslib_es6();
init_cancellation();
init_lifecycle();
init_uri();
init_configuration();
init_telemetry();
init_extHost_protocol();
var MainThreadSearch = class MainThreadSearch2 {
  constructor(extHostContext, _searchService, _telemetryService, _configurationService) {
    this._searchService = _searchService;
    this._telemetryService = _telemetryService;
    this._searchProvider = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostSearch);
    this._proxy.$enableExtensionHostSearch();
  }
  dispose() {
    this._searchProvider.forEach((value) => value.dispose());
    this._searchProvider.clear();
  }
  $registerTextSearchProvider(handle, scheme) {
    this._searchProvider.set(handle, new RemoteSearchProvider(
      this._searchService,
      1,
      scheme,
      handle,
      this._proxy
    ));
  }
  $registerFileSearchProvider(handle, scheme) {
    this._searchProvider.set(handle, new RemoteSearchProvider(
      this._searchService,
      0,
      scheme,
      handle,
      this._proxy
    ));
  }
  $unregisterProvider(handle) {
    dispose(this._searchProvider.get(handle));
    this._searchProvider.delete(handle);
  }
  $handleFileMatch(handle, session, data) {
    const provider = this._searchProvider.get(handle);
    if (!provider) {
      throw new Error("Got result for unknown provider");
    }
    provider.handleFindMatch(session, data);
  }
  $handleTextMatch(handle, session, data) {
    const provider = this._searchProvider.get(handle);
    if (!provider) {
      throw new Error("Got result for unknown provider");
    }
    provider.handleFindMatch(session, data);
  }
  $handleTelemetry(eventName, data) {
    this._telemetryService.publicLog(eventName, data);
  }
};
MainThreadSearch = __decorate([
  extHostNamedCustomer(MainContext.MainThreadSearch),
  __param(1, ISearchService),
  __param(2, ITelemetryService),
  __param(3, IConfigurationService)
], MainThreadSearch);
var _SearchOperation = class _SearchOperation {
  constructor(progress, id = ++_SearchOperation._idPool, matches = /* @__PURE__ */ new Map()) {
    this.progress = progress;
    this.id = id;
    this.matches = matches;
  }
  addMatch(match) {
    var _a30;
    const existingMatch = this.matches.get(match.resource.toString());
    if (existingMatch) {
      if (existingMatch.results && match.results) {
        existingMatch.results.push(...match.results);
      }
    } else {
      this.matches.set(match.resource.toString(), match);
    }
    (_a30 = this.progress) == null ? void 0 : _a30.call(this, match);
  }
};
_SearchOperation._idPool = 0;
var SearchOperation = _SearchOperation;
var RemoteSearchProvider = class {
  constructor(searchService, type, _scheme, _handle4, _proxy10) {
    this._scheme = _scheme;
    this._handle = _handle4;
    this._proxy = _proxy10;
    this._registrations = new DisposableStore();
    this._searches = /* @__PURE__ */ new Map();
    this._registrations.add(searchService.registerSearchResultProvider(this._scheme, type, this));
  }
  dispose() {
    this._registrations.dispose();
  }
  fileSearch(query, token = CancellationToken.None) {
    return this.doSearch(query, void 0, token);
  }
  textSearch(query, onProgress, token = CancellationToken.None) {
    return this.doSearch(query, onProgress, token);
  }
  doSearch(query, onProgress, token = CancellationToken.None) {
    if (!query.folderQueries.length) {
      throw new Error("Empty folderQueries");
    }
    const search = new SearchOperation(onProgress);
    this._searches.set(search.id, search);
    const searchP = query.type === 1 ? this._proxy.$provideFileSearchResults(this._handle, search.id, query, token) : this._proxy.$provideTextSearchResults(this._handle, search.id, query, token);
    return Promise.resolve(searchP).then((result) => {
      this._searches.delete(search.id);
      return { results: Array.from(search.matches.values()), stats: result.stats, limitHit: result.limitHit, messages: result.messages };
    }, (err) => {
      this._searches.delete(search.id);
      return Promise.reject(err);
    });
  }
  clearCache(cacheKey) {
    return Promise.resolve(this._proxy.$clearCache(cacheKey));
  }
  handleFindMatch(session, dataOrUri) {
    const searchOp = this._searches.get(session);
    if (!searchOp) {
      return;
    }
    dataOrUri.forEach((result) => {
      if (result.results) {
        searchOp.addMatch({
          resource: URI.revive(result.resource),
          results: result.results
        });
      } else {
        searchOp.addMatch({
          resource: URI.revive(result)
        });
      }
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadStatusBar.js
init_tslib_es6();
init_extHost_protocol();
init_lifecycle();
var MainThreadStatusBar = class MainThreadStatusBar2 {
  constructor(extHostContext, statusbarService) {
    this.statusbarService = statusbarService;
    this._store = new DisposableStore();
    const proxy = extHostContext.getProxy(ExtHostContext.ExtHostStatusBar);
    const entries = [];
    for (const [entryId, item] of statusbarService.getEntries()) {
      entries.push(asDto(entryId, item));
    }
    proxy.$acceptStaticEntries(entries);
    this._store.add(statusbarService.onDidChange((e) => {
      if (e.added) {
        proxy.$acceptStaticEntries([asDto(e.added[0], e.added[1])]);
      }
    }));
    function asDto(entryId, item) {
      return {
        entryId,
        name: item.entry.name,
        text: item.entry.text,
        tooltip: item.entry.tooltip,
        command: typeof item.entry.command === "string" ? item.entry.command : typeof item.entry.command === "object" ? item.entry.command.id : void 0,
        priority: item.priority,
        alignLeft: item.alignment === 0,
        accessibilityInformation: item.entry.ariaLabel ? { label: item.entry.ariaLabel, role: item.entry.role } : void 0
      };
    }
  }
  dispose() {
    this._store.dispose();
  }
  $setEntry(entryId, id, extensionId, name, text, tooltip, command, color2, backgroundColor, alignLeft, priority, accessibilityInformation) {
    const kind = this.statusbarService.setOrUpdateEntry(entryId, id, extensionId, name, text, tooltip, command, color2, backgroundColor, alignLeft, priority, accessibilityInformation);
    if (kind === 0) {
      this._store.add(toDisposable(() => this.statusbarService.unsetEntry(entryId)));
    }
  }
  $disposeEntry(entryId) {
    this.statusbarService.unsetEntry(entryId);
  }
};
MainThreadStatusBar = __decorate([
  extHostNamedCustomer(MainContext.MainThreadStatusBar),
  __param(1, IExtensionStatusBarItemService)
], MainThreadStatusBar);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadStorage.js
init_tslib_es6();
init_extHost_protocol();
init_lifecycle();
init_platform();

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionStorageMigration.js
init_errors();
init_environment();
init_files();
init_log();
async function migrateExtensionStorage(fromExtensionId, toExtensionId, global2, instantionService) {
  return instantionService.invokeFunction(async (serviceAccessor) => {
    const environmentService = serviceAccessor.get(IEnvironmentService);
    const userDataProfilesService = serviceAccessor.get(IUserDataProfilesService);
    const extensionStorageService = serviceAccessor.get(IExtensionStorageService);
    const storageService = serviceAccessor.get(IStorageService);
    const uriIdentityService = serviceAccessor.get(IUriIdentityService);
    const fileService = serviceAccessor.get(IFileService);
    const workspaceContextService = serviceAccessor.get(IWorkspaceContextService);
    const logService = serviceAccessor.get(ILogService);
    const storageMigratedKey = `extensionStorage.migrate.${fromExtensionId}-${toExtensionId}`;
    const migrateLowerCaseStorageKey = fromExtensionId.toLowerCase() === toExtensionId.toLowerCase() ? `extension.storage.migrateFromLowerCaseKey.${fromExtensionId.toLowerCase()}` : void 0;
    if (fromExtensionId === toExtensionId) {
      return;
    }
    const getExtensionStorageLocation = (extensionId, global3) => {
      if (global3) {
        return uriIdentityService.extUri.joinPath(userDataProfilesService.defaultProfile.globalStorageHome, extensionId.toLowerCase());
      }
      return uriIdentityService.extUri.joinPath(environmentService.workspaceStorageHome, workspaceContextService.getWorkspace().id, extensionId);
    };
    const storageScope = global2 ? 0 : 1;
    if (!storageService.getBoolean(storageMigratedKey, storageScope, false) && !(migrateLowerCaseStorageKey && storageService.getBoolean(migrateLowerCaseStorageKey, storageScope, false))) {
      logService.info(`Migrating ${global2 ? "global" : "workspace"} extension storage from ${fromExtensionId} to ${toExtensionId}...`);
      const value = extensionStorageService.getExtensionState(fromExtensionId, global2);
      if (value) {
        extensionStorageService.setExtensionState(toExtensionId, value, global2);
        extensionStorageService.setExtensionState(fromExtensionId, void 0, global2);
      }
      const fromPath = getExtensionStorageLocation(fromExtensionId, global2);
      const toPath = getExtensionStorageLocation(toExtensionId, global2);
      if (!uriIdentityService.extUri.isEqual(fromPath, toPath)) {
        try {
          await fileService.move(fromPath, toPath, true);
        } catch (error) {
          if (error.code !== FileSystemProviderErrorCode.FileNotFound) {
            logService.info(`Error while migrating ${global2 ? "global" : "workspace"} file storage from '${fromExtensionId}' to '${toExtensionId}'`, getErrorMessage(error));
          }
        }
      }
      logService.info(`Migrated ${global2 ? "global" : "workspace"} extension storage from ${fromExtensionId} to ${toExtensionId}`);
      storageService.store(storageMigratedKey, true, storageScope, 1);
    }
  });
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadStorage.js
init_instantiation();
init_log();
var MainThreadStorage = class MainThreadStorage2 {
  constructor(extHostContext, _extensionStorageService, _storageService, _instantiationService, _logService) {
    this._extensionStorageService = _extensionStorageService;
    this._storageService = _storageService;
    this._instantiationService = _instantiationService;
    this._logService = _logService;
    this._storageListener = new DisposableStore();
    this._sharedStorageKeysToWatch = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostStorage);
    this._storageListener.add(this._storageService.onDidChangeValue(0, void 0, this._storageListener)((e) => {
      if (this._sharedStorageKeysToWatch.has(e.key)) {
        const rawState = this._extensionStorageService.getExtensionStateRaw(e.key, true);
        if (typeof rawState === "string") {
          this._proxy.$acceptValue(true, e.key, rawState);
        }
      }
    }));
  }
  dispose() {
    this._storageListener.dispose();
  }
  async $initializeExtensionStorage(shared, extensionId) {
    await this.checkAndMigrateExtensionStorage(extensionId, shared);
    if (shared) {
      this._sharedStorageKeysToWatch.set(extensionId, true);
    }
    return this._extensionStorageService.getExtensionStateRaw(extensionId, shared);
  }
  async $setValue(shared, key, value) {
    this._extensionStorageService.setExtensionState(key, value, shared);
  }
  $registerExtensionStorageKeysToSync(extension, keys) {
    this._extensionStorageService.setKeysForSync(extension, keys);
  }
  async checkAndMigrateExtensionStorage(extensionId, shared) {
    try {
      let sourceExtensionId = this._extensionStorageService.getSourceExtensionToMigrate(extensionId);
      if (!sourceExtensionId && isWeb && extensionId !== extensionId.toLowerCase()) {
        sourceExtensionId = extensionId.toLowerCase();
      }
      if (sourceExtensionId) {
        if (isWeb && sourceExtensionId !== sourceExtensionId.toLowerCase() && this._extensionStorageService.getExtensionState(sourceExtensionId.toLowerCase(), shared) && !this._extensionStorageService.getExtensionState(sourceExtensionId, shared)) {
          sourceExtensionId = sourceExtensionId.toLowerCase();
        }
        await migrateExtensionStorage(sourceExtensionId, extensionId, shared, this._instantiationService);
      }
    } catch (error) {
      this._logService.error(error);
    }
  }
};
MainThreadStorage = __decorate([
  extHostNamedCustomer(MainContext.MainThreadStorage),
  __param(1, IExtensionStorageService),
  __param(2, IStorageService),
  __param(3, IInstantiationService),
  __param(4, ILogService)
], MainThreadStorage);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTelemetry.js
init_tslib_es6();
init_lifecycle();
init_configuration();
init_environment();
init_telemetry();
init_telemetryUtils();
init_extHost_protocol();
var MainThreadTelemetry_1;
var _a22;
var MainThreadTelemetry = (_a22 = class extends Disposable {
  constructor(extHostContext, _telemetryService, _configurationService, _environmentService, _productService) {
    super();
    this._telemetryService = _telemetryService;
    this._configurationService = _configurationService;
    this._environmentService = _environmentService;
    this._productService = _productService;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostTelemetry);
    if (supportsTelemetry(this._productService, this._environmentService)) {
      this._register(this._configurationService.onDidChangeConfiguration((e) => {
        if (e.affectsConfiguration(TELEMETRY_SETTING_ID) || e.affectsConfiguration(TELEMETRY_OLD_SETTING_ID)) {
          this._proxy.$onDidChangeTelemetryLevel(this.telemetryLevel);
        }
      }));
    }
    this._proxy.$initializeTelemetryLevel(this.telemetryLevel, supportsTelemetry(this._productService, this._environmentService), this._productService.enabledTelemetryLevels);
  }
  get telemetryLevel() {
    if (!supportsTelemetry(this._productService, this._environmentService)) {
      return 0;
    }
    return this._telemetryService.telemetryLevel;
  }
  $publicLog(eventName, data = /* @__PURE__ */ Object.create(null)) {
    data[MainThreadTelemetry_1._name] = true;
    this._telemetryService.publicLog(eventName, data);
  }
  $publicLog2(eventName, data) {
    this.$publicLog(eventName, data);
  }
}, MainThreadTelemetry_1 = _a22, _a22._name = "pluginHostTelemetry", _a22);
MainThreadTelemetry = MainThreadTelemetry_1 = __decorate([
  extHostNamedCustomer(MainContext.MainThreadTelemetry),
  __param(1, ITelemetryService),
  __param(2, IConfigurationService),
  __param(3, IEnvironmentService),
  __param(4, IProductService)
], MainThreadTelemetry);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTerminalService.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
init_uri();
init_instantiation();
init_log();

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/browser/terminalProcessExtHostProxy.js
init_tslib_es6();
init_event();
init_lifecycle();
var TerminalProcessExtHostProxy = class TerminalProcessExtHostProxy2 extends Disposable {
  get onProcessReady() {
    return this._onProcessReady.event;
  }
  constructor(instanceId, _cols, _rows, _terminalService) {
    super();
    this.instanceId = instanceId;
    this._cols = _cols;
    this._rows = _rows;
    this._terminalService = _terminalService;
    this.id = 0;
    this.shouldPersist = false;
    this._onProcessData = this._register(new Emitter());
    this.onProcessData = this._onProcessData.event;
    this._onProcessReady = this._register(new Emitter());
    this._onStart = this._register(new Emitter());
    this.onStart = this._onStart.event;
    this._onInput = this._register(new Emitter());
    this.onInput = this._onInput.event;
    this._onBinary = this._register(new Emitter());
    this.onBinary = this._onBinary.event;
    this._onResize = this._register(new Emitter());
    this.onResize = this._onResize.event;
    this._onAcknowledgeDataEvent = this._register(new Emitter());
    this.onAcknowledgeDataEvent = this._onAcknowledgeDataEvent.event;
    this._onShutdown = this._register(new Emitter());
    this.onShutdown = this._onShutdown.event;
    this._onRequestInitialCwd = this._register(new Emitter());
    this.onRequestInitialCwd = this._onRequestInitialCwd.event;
    this._onRequestCwd = this._register(new Emitter());
    this.onRequestCwd = this._onRequestCwd.event;
    this._onDidChangeProperty = this._register(new Emitter());
    this.onDidChangeProperty = this._onDidChangeProperty.event;
    this._onProcessExit = this._register(new Emitter());
    this.onProcessExit = this._onProcessExit.event;
    this._pendingInitialCwdRequests = [];
    this._pendingCwdRequests = [];
  }
  emitData(data) {
    this._onProcessData.fire(data);
  }
  emitTitle(title) {
    this._onDidChangeProperty.fire({ type: "title", value: title });
  }
  emitReady(pid, cwd2) {
    this._onProcessReady.fire({ pid, cwd: cwd2, windowsPty: void 0 });
  }
  emitProcessProperty({ type, value }) {
    switch (type) {
      case "cwd":
        this.emitCwd(value);
        break;
      case "initialCwd":
        this.emitInitialCwd(value);
        break;
      case "title":
        this.emitTitle(value);
        break;
      case "overrideDimensions":
        this.emitOverrideDimensions(value);
        break;
      case "resolvedShellLaunchConfig":
        this.emitResolvedShellLaunchConfig(value);
        break;
    }
  }
  emitExit(exitCode) {
    this._onProcessExit.fire(exitCode);
    this.dispose();
  }
  emitOverrideDimensions(dimensions) {
    this._onDidChangeProperty.fire({ type: "overrideDimensions", value: dimensions });
  }
  emitResolvedShellLaunchConfig(shellLaunchConfig) {
    this._onDidChangeProperty.fire({ type: "resolvedShellLaunchConfig", value: shellLaunchConfig });
  }
  emitInitialCwd(initialCwd) {
    while (this._pendingInitialCwdRequests.length > 0) {
      this._pendingInitialCwdRequests.pop()(initialCwd);
    }
  }
  emitCwd(cwd2) {
    while (this._pendingCwdRequests.length > 0) {
      this._pendingCwdRequests.pop()(cwd2);
    }
  }
  async start() {
    return this._terminalService.requestStartExtensionTerminal(this, this._cols, this._rows);
  }
  shutdown(immediate) {
    this._onShutdown.fire(immediate);
  }
  input(data) {
    this._onInput.fire(data);
  }
  resize(cols, rows) {
    this._onResize.fire({ cols, rows });
  }
  clearBuffer() {
  }
  acknowledgeDataEvent() {
  }
  async setUnicodeVersion(version) {
  }
  async processBinary(data) {
    this._onBinary.fire(data);
  }
  getInitialCwd() {
    return new Promise((resolve) => {
      this._onRequestInitialCwd.fire();
      this._pendingInitialCwdRequests.push(resolve);
    });
  }
  getCwd() {
    return new Promise((resolve) => {
      this._onRequestCwd.fire();
      this._pendingCwdRequests.push(resolve);
    });
  }
  async refreshProperty(type) {
  }
  async updateProperty(type, value) {
  }
};
TerminalProcessExtHostProxy = __decorate([
  __param(3, ITerminalService)
], TerminalProcessExtHostProxy);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTerminalService.js
init_platform();
init_async();
var MainThreadTerminalService = class MainThreadTerminalService2 {
  constructor(_extHostContext, _terminalService, _terminalLinkProviderService, _terminalQuickFixService, _instantiationService, _environmentVariableService, _logService, _terminalProfileResolverService, remoteAgentService, _terminalGroupService, _terminalEditorService, _terminalProfileService) {
    this._extHostContext = _extHostContext;
    this._terminalService = _terminalService;
    this._terminalLinkProviderService = _terminalLinkProviderService;
    this._terminalQuickFixService = _terminalQuickFixService;
    this._instantiationService = _instantiationService;
    this._environmentVariableService = _environmentVariableService;
    this._logService = _logService;
    this._terminalProfileResolverService = _terminalProfileResolverService;
    this._terminalGroupService = _terminalGroupService;
    this._terminalEditorService = _terminalEditorService;
    this._terminalProfileService = _terminalProfileService;
    this._store = new DisposableStore();
    this._extHostTerminals = /* @__PURE__ */ new Map();
    this._terminalProcessProxies = /* @__PURE__ */ new Map();
    this._profileProviders = /* @__PURE__ */ new Map();
    this._quickFixProviders = /* @__PURE__ */ new Map();
    this._dataEventTracker = new MutableDisposable();
    this._sendCommandEventListener = new MutableDisposable();
    this._os = OS;
    this._proxy = _extHostContext.getProxy(ExtHostContext.ExtHostTerminalService);
    this._store.add(_terminalService.onDidCreateInstance((instance) => {
      this._onTerminalOpened(instance);
      this._onInstanceDimensionsChanged(instance);
    }));
    this._store.add(_terminalService.onDidDisposeInstance((instance) => this._onTerminalDisposed(instance)));
    this._store.add(_terminalService.onDidReceiveProcessId((instance) => this._onTerminalProcessIdReady(instance)));
    this._store.add(_terminalService.onDidChangeInstanceDimensions((instance) => this._onInstanceDimensionsChanged(instance)));
    this._store.add(_terminalService.onDidMaximumDimensionsChange((instance) => this._onInstanceMaximumDimensionsChanged(instance)));
    this._store.add(_terminalService.onDidRequestStartExtensionTerminal((e) => this._onRequestStartExtensionTerminal(e)));
    this._store.add(_terminalService.onDidChangeActiveInstance((instance) => this._onActiveTerminalChanged(instance ? instance.instanceId : null)));
    this._store.add(_terminalService.onDidChangeInstanceTitle((instance) => instance && this._onTitleChanged(instance.instanceId, instance.title)));
    this._store.add(_terminalService.onDidInputInstanceData((instance) => this._proxy.$acceptTerminalInteraction(instance.instanceId)));
    this._store.add(_terminalService.onDidChangeSelection((instance) => this._proxy.$acceptTerminalSelection(instance.instanceId, instance.selection)));
    for (const instance of this._terminalService.instances) {
      this._onTerminalOpened(instance);
      instance.processReady.then(() => this._onTerminalProcessIdReady(instance));
    }
    const activeInstance = this._terminalService.activeInstance;
    if (activeInstance) {
      this._proxy.$acceptActiveTerminalChanged(activeInstance.instanceId);
    }
    if (this._environmentVariableService.collections.size > 0) {
      const collectionAsArray = [...this._environmentVariableService.collections.entries()];
      const serializedCollections = collectionAsArray.map((e) => {
        return [e[0], serializeEnvironmentVariableCollection(e[1].map)];
      });
      this._proxy.$initEnvironmentVariableCollections(serializedCollections);
    }
    remoteAgentService.getEnvironment().then(async (env2) => {
      this._os = (env2 == null ? void 0 : env2.os) || OS;
      this._updateDefaultProfile();
    });
    this._store.add(this._terminalProfileService.onDidChangeAvailableProfiles(() => this._updateDefaultProfile()));
  }
  dispose() {
    var _a30;
    this._store.dispose();
    (_a30 = this._linkProvider) == null ? void 0 : _a30.dispose();
    for (const provider of this._profileProviders.values()) {
      provider.dispose();
    }
    for (const provider of this._quickFixProviders.values()) {
      provider.dispose();
    }
  }
  async _updateDefaultProfile() {
    const remoteAuthority = this._extHostContext.remoteAuthority ?? void 0;
    const defaultProfile = this._terminalProfileResolverService.getDefaultProfile({ remoteAuthority, os: this._os });
    const defaultAutomationProfile = this._terminalProfileResolverService.getDefaultProfile({ remoteAuthority, os: this._os, allowAutomationShell: true });
    this._proxy.$acceptDefaultProfile(...await Promise.all([defaultProfile, defaultAutomationProfile]));
  }
  async _getTerminalInstance(id) {
    if (typeof id === "string") {
      return this._extHostTerminals.get(id);
    }
    return this._terminalService.getInstanceFromId(id);
  }
  async $createTerminal(extHostTerminalId, launchConfig) {
    const shellLaunchConfig = {
      name: launchConfig.name,
      executable: launchConfig.shellPath,
      args: launchConfig.shellArgs,
      cwd: typeof launchConfig.cwd === "string" ? launchConfig.cwd : URI.revive(launchConfig.cwd),
      icon: launchConfig.icon,
      color: launchConfig.color,
      initialText: launchConfig.initialText,
      waitOnExit: launchConfig.waitOnExit,
      ignoreConfigurationCwd: true,
      env: launchConfig.env,
      strictEnv: launchConfig.strictEnv,
      hideFromUser: launchConfig.hideFromUser,
      customPtyImplementation: launchConfig.isExtensionCustomPtyTerminal ? (id, cols, rows) => new TerminalProcessExtHostProxy(id, cols, rows, this._terminalService) : void 0,
      extHostTerminalId,
      isFeatureTerminal: launchConfig.isFeatureTerminal,
      isExtensionOwnedTerminal: launchConfig.isExtensionOwnedTerminal,
      useShellEnvironment: launchConfig.useShellEnvironment,
      isTransient: launchConfig.isTransient
    };
    const terminal = Promises.withAsyncBody(async (r) => {
      const terminal2 = await this._terminalService.createTerminal({
        config: shellLaunchConfig,
        location: await this._deserializeParentTerminal(launchConfig.location)
      });
      r(terminal2);
    });
    this._extHostTerminals.set(extHostTerminalId, terminal);
    const terminalInstance = await terminal;
    this._store.add(terminalInstance.onDisposed(() => {
      this._extHostTerminals.delete(extHostTerminalId);
    }));
  }
  async _deserializeParentTerminal(location2) {
    if (typeof location2 === "object" && "parentTerminal" in location2) {
      const parentTerminal = await this._extHostTerminals.get(location2.parentTerminal.toString());
      return parentTerminal ? { parentTerminal } : void 0;
    }
    return location2;
  }
  async $show(id, preserveFocus) {
    const terminalInstance = await this._getTerminalInstance(id);
    if (terminalInstance) {
      this._terminalService.setActiveInstance(terminalInstance);
      if (terminalInstance.target === TerminalLocation2.Editor) {
        await this._terminalEditorService.revealActiveEditor(preserveFocus);
      } else {
        await this._terminalGroupService.showPanel(!preserveFocus);
      }
    }
  }
  async $hide(id) {
    const instanceToHide = await this._getTerminalInstance(id);
    const activeInstance = this._terminalService.activeInstance;
    if (activeInstance && activeInstance.instanceId === (instanceToHide == null ? void 0 : instanceToHide.instanceId) && activeInstance.target !== TerminalLocation2.Editor) {
      this._terminalGroupService.hidePanel();
    }
  }
  async $dispose(id) {
    var _a30;
    (_a30 = await this._getTerminalInstance(id)) == null ? void 0 : _a30.dispose(TerminalExitReason2.Extension);
  }
  async $sendText(id, text, addNewLine) {
    const instance = await this._getTerminalInstance(id);
    await (instance == null ? void 0 : instance.sendText(text, addNewLine));
  }
  $sendProcessExit(terminalId, exitCode) {
    var _a30;
    (_a30 = this._terminalProcessProxies.get(terminalId)) == null ? void 0 : _a30.emitExit(exitCode);
  }
  $startSendingDataEvents() {
    if (!this._dataEventTracker.value) {
      this._dataEventTracker.value = this._instantiationService.createInstance(TerminalDataEventTracker, (id, data) => {
        this._onTerminalData(id, data);
      });
      for (const instance of this._terminalService.instances) {
        for (const data of instance.initialDataEvents || []) {
          this._onTerminalData(instance.instanceId, data);
        }
      }
    }
  }
  $stopSendingDataEvents() {
    this._dataEventTracker.clear();
  }
  $startSendingCommandEvents() {
    this._logService.info("$startSendingCommandEvents");
    if (this._sendCommandEventListener.value) {
      return;
    }
    const multiplexer = this._terminalService.onInstanceCapabilityEvent(2, (capability) => capability.onCommandFinished);
    multiplexer.event((e) => {
      this._onDidExecuteCommand(e.instance.instanceId, {
        commandLine: e.data.command,
        cwd: e.data.cwd,
        exitCode: e.data.exitCode,
        output: e.data.getOutput()
      });
    });
    this._sendCommandEventListener.value = multiplexer;
  }
  $stopSendingCommandEvents() {
    this._logService.info("$stopSendingCommandEvents");
    this._sendCommandEventListener.clear();
  }
  $startLinkProvider() {
    var _a30;
    (_a30 = this._linkProvider) == null ? void 0 : _a30.dispose();
    this._linkProvider = this._terminalLinkProviderService.registerLinkProvider(new ExtensionTerminalLinkProvider(this._proxy));
  }
  $stopLinkProvider() {
    var _a30;
    (_a30 = this._linkProvider) == null ? void 0 : _a30.dispose();
    this._linkProvider = void 0;
  }
  $registerProcessSupport(isSupported) {
    this._terminalService.registerProcessSupport(isSupported);
  }
  $registerProfileProvider(id, extensionIdentifier) {
    this._profileProviders.set(id, this._terminalProfileService.registerTerminalProfileProvider(extensionIdentifier, id, {
      createContributedTerminalProfile: async (options) => {
        return this._proxy.$createContributedProfileTerminal(id, options);
      }
    }));
  }
  $unregisterProfileProvider(id) {
    var _a30;
    (_a30 = this._profileProviders.get(id)) == null ? void 0 : _a30.dispose();
    this._profileProviders.delete(id);
  }
  async $registerQuickFixProvider(id, extensionId) {
    this._quickFixProviders.set(id, this._terminalQuickFixService.registerQuickFixProvider(id, {
      provideTerminalQuickFixes: async (terminalCommand, lines, options, token) => {
        var _a30;
        if (token.isCancellationRequested) {
          return;
        }
        if (((_a30 = options.outputMatcher) == null ? void 0 : _a30.length) && options.outputMatcher.length > 40) {
          options.outputMatcher.length = 40;
          this._logService.warn("Cannot exceed output matcher length of 40");
        }
        const commandLineMatch = terminalCommand.command.match(options.commandLineMatcher);
        if (!commandLineMatch || !lines) {
          return;
        }
        const outputMatcher = options.outputMatcher;
        let outputMatch;
        if (outputMatcher) {
          outputMatch = getOutputMatchForLines(lines, outputMatcher);
        }
        if (!outputMatch) {
          return;
        }
        const matchResult = { commandLineMatch, outputMatch, commandLine: terminalCommand.command };
        if (matchResult) {
          const result = await this._proxy.$provideTerminalQuickFixes(id, matchResult, token);
          if (result && Array.isArray(result)) {
            return result.map((r) => parseQuickFix(id, extensionId, r));
          } else if (result) {
            return parseQuickFix(id, extensionId, result);
          }
        }
        return;
      }
    }));
  }
  $unregisterQuickFixProvider(id) {
    var _a30;
    (_a30 = this._quickFixProviders.get(id)) == null ? void 0 : _a30.dispose();
    this._quickFixProviders.delete(id);
  }
  _onActiveTerminalChanged(terminalId) {
    this._proxy.$acceptActiveTerminalChanged(terminalId);
  }
  _onTerminalData(terminalId, data) {
    this._proxy.$acceptTerminalProcessData(terminalId, data);
  }
  _onDidExecuteCommand(terminalId, command) {
    this._proxy.$acceptDidExecuteCommand(terminalId, command);
  }
  _onTitleChanged(terminalId, name) {
    this._proxy.$acceptTerminalTitleChange(terminalId, name);
  }
  _onTerminalDisposed(terminalInstance) {
    this._proxy.$acceptTerminalClosed(terminalInstance.instanceId, terminalInstance.exitCode, terminalInstance.exitReason ?? TerminalExitReason2.Unknown);
  }
  _onTerminalOpened(terminalInstance) {
    const extHostTerminalId = terminalInstance.shellLaunchConfig.extHostTerminalId;
    const shellLaunchConfigDto = {
      name: terminalInstance.shellLaunchConfig.name,
      executable: terminalInstance.shellLaunchConfig.executable,
      args: terminalInstance.shellLaunchConfig.args,
      cwd: terminalInstance.shellLaunchConfig.cwd,
      env: terminalInstance.shellLaunchConfig.env,
      hideFromUser: terminalInstance.shellLaunchConfig.hideFromUser
    };
    this._proxy.$acceptTerminalOpened(terminalInstance.instanceId, extHostTerminalId, terminalInstance.title, shellLaunchConfigDto);
  }
  _onTerminalProcessIdReady(terminalInstance) {
    if (terminalInstance.processId === void 0) {
      return;
    }
    this._proxy.$acceptTerminalProcessId(terminalInstance.instanceId, terminalInstance.processId);
  }
  _onInstanceDimensionsChanged(instance) {
    this._proxy.$acceptTerminalDimensions(instance.instanceId, instance.cols, instance.rows);
  }
  _onInstanceMaximumDimensionsChanged(instance) {
    this._proxy.$acceptTerminalMaximumDimensions(instance.instanceId, instance.maxCols, instance.maxRows);
  }
  _onRequestStartExtensionTerminal(request) {
    const proxy = request.proxy;
    this._terminalProcessProxies.set(proxy.instanceId, proxy);
    const initialDimensions = request.cols && request.rows ? {
      columns: request.cols,
      rows: request.rows
    } : void 0;
    this._proxy.$startExtensionTerminal(proxy.instanceId, initialDimensions).then(request.callback);
    proxy.onInput((data) => this._proxy.$acceptProcessInput(proxy.instanceId, data));
    proxy.onShutdown((immediate) => this._proxy.$acceptProcessShutdown(proxy.instanceId, immediate));
    proxy.onRequestCwd(() => this._proxy.$acceptProcessRequestCwd(proxy.instanceId));
    proxy.onRequestInitialCwd(() => this._proxy.$acceptProcessRequestInitialCwd(proxy.instanceId));
  }
  $sendProcessData(terminalId, data) {
    var _a30;
    (_a30 = this._terminalProcessProxies.get(terminalId)) == null ? void 0 : _a30.emitData(data);
  }
  $sendProcessReady(terminalId, pid, cwd2, windowsPty) {
    var _a30;
    (_a30 = this._terminalProcessProxies.get(terminalId)) == null ? void 0 : _a30.emitReady(pid, cwd2, windowsPty);
  }
  $sendProcessProperty(terminalId, property) {
    var _a30;
    if (property.type === "title") {
      const instance = this._terminalService.getInstanceFromId(terminalId);
      instance == null ? void 0 : instance.rename(property.value);
    }
    (_a30 = this._terminalProcessProxies.get(terminalId)) == null ? void 0 : _a30.emitProcessProperty(property);
  }
  $setEnvironmentVariableCollection(extensionIdentifier, persistent, collection, descriptionMap) {
    if (collection) {
      const translatedCollection = {
        persistent,
        map: deserializeEnvironmentVariableCollection(collection),
        descriptionMap: deserializeEnvironmentDescriptionMap(descriptionMap)
      };
      this._environmentVariableService.set(extensionIdentifier, translatedCollection);
    } else {
      this._environmentVariableService.delete(extensionIdentifier);
    }
  }
};
MainThreadTerminalService = __decorate([
  extHostNamedCustomer(MainContext.MainThreadTerminalService),
  __param(1, ITerminalService),
  __param(2, ITerminalLinkProviderService),
  __param(3, ITerminalQuickFixService),
  __param(4, IInstantiationService),
  __param(5, IEnvironmentVariableService),
  __param(6, ILogService),
  __param(7, ITerminalProfileResolverService),
  __param(8, IRemoteAgentService),
  __param(9, ITerminalGroupService),
  __param(10, ITerminalEditorService),
  __param(11, ITerminalProfileService)
], MainThreadTerminalService);
var TerminalDataEventTracker = class TerminalDataEventTracker2 extends Disposable {
  constructor(_callback, _terminalService) {
    super();
    this._callback = _callback;
    this._terminalService = _terminalService;
    this._register(this._bufferer = new TerminalDataBufferer(this._callback));
    for (const instance of this._terminalService.instances) {
      this._registerInstance(instance);
    }
    this._register(this._terminalService.onDidCreateInstance((instance) => this._registerInstance(instance)));
    this._register(this._terminalService.onDidDisposeInstance((instance) => this._bufferer.stopBuffering(instance.instanceId)));
  }
  _registerInstance(instance) {
    this._register(this._bufferer.startBuffering(instance.instanceId, instance.onData));
  }
};
TerminalDataEventTracker = __decorate([
  __param(1, ITerminalService)
], TerminalDataEventTracker);
var ExtensionTerminalLinkProvider = class {
  constructor(_proxy10) {
    this._proxy = _proxy10;
  }
  async provideLinks(instance, line) {
    const proxy = this._proxy;
    const extHostLinks = await proxy.$provideLinks(instance.instanceId, line);
    return extHostLinks.map((dto) => ({
      id: dto.id,
      startIndex: dto.startIndex,
      length: dto.length,
      label: dto.label,
      activate: () => proxy.$activateLink(instance.instanceId, dto.id)
    }));
  }
};
function getOutputMatchForLines(lines, outputMatcher) {
  const match = lines.join("\n").match(outputMatcher.lineMatcher);
  return match ? { regexMatch: match, outputLines: lines } : void 0;
}
function parseQuickFix(id, source, fix) {
  let type = TerminalQuickFixType.TerminalCommand;
  if ("uri" in fix) {
    fix.uri = URI.revive(fix.uri);
    type = TerminalQuickFixType.Opener;
  } else if ("id" in fix) {
    type = TerminalQuickFixType.VscodeCommand;
  }
  return { id, type, source, ...fix };
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTheming.js
init_tslib_es6();
init_extHost_protocol();
init_themeService();
var MainThreadTheming = class MainThreadTheming2 {
  constructor(extHostContext, themeService) {
    this._themeService = themeService;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostTheming);
    this._themeChangeListener = this._themeService.onDidColorThemeChange((e) => {
      this._proxy.$onColorThemeChange(this._themeService.getColorTheme().type);
    });
    this._proxy.$onColorThemeChange(this._themeService.getColorTheme().type);
  }
  dispose() {
    this._themeChangeListener.dispose();
  }
};
MainThreadTheming = __decorate([
  extHostNamedCustomer(MainContext.MainThreadTheming),
  __param(1, IThemeService)
], MainThreadTheming);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTreeViews.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
init_arrays();
init_types();
init_platform2();
init_log();
var MainThreadTreeViews = class MainThreadTreeViews2 extends Disposable {
  constructor(extHostContext, viewsService, notificationService, extensionService, logService) {
    super();
    this.viewsService = viewsService;
    this.notificationService = notificationService;
    this.extensionService = extensionService;
    this.logService = logService;
    this._dataProviders = /* @__PURE__ */ new Map();
    this._dndControllers = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostTreeViews);
  }
  async $registerTreeViewDataProvider(treeViewId, options) {
    this.logService.trace("MainThreadTreeViews#$registerTreeViewDataProvider", treeViewId, options);
    this.extensionService.whenInstalledExtensionsRegistered().then(() => {
      const dataProvider = new TreeViewDataProvider(treeViewId, this._proxy, this.notificationService);
      this._dataProviders.set(treeViewId, dataProvider);
      const dndController = options.hasHandleDrag || options.hasHandleDrop ? new TreeViewDragAndDropController(
        treeViewId,
        options.dropMimeTypes,
        options.dragMimeTypes,
        options.hasHandleDrag,
        this._proxy
      ) : void 0;
      const viewer = this.getTreeView(treeViewId);
      if (viewer) {
        viewer.showCollapseAllAction = options.showCollapseAll;
        viewer.canSelectMany = options.canSelectMany;
        viewer.manuallyManageCheckboxes = options.manuallyManageCheckboxes;
        viewer.dragAndDropController = dndController;
        if (dndController) {
          this._dndControllers.set(treeViewId, dndController);
        }
        viewer.dataProvider = dataProvider;
        this.registerListeners(treeViewId, viewer);
        this._proxy.$setVisible(treeViewId, viewer.visible);
      } else {
        this.notificationService.error("No view is registered with id: " + treeViewId);
      }
    });
  }
  $reveal(treeViewId, itemInfo, options) {
    this.logService.trace("MainThreadTreeViews#$reveal", treeViewId, itemInfo == null ? void 0 : itemInfo.item, itemInfo == null ? void 0 : itemInfo.parentChain, options);
    return this.viewsService.openView(treeViewId, options.focus).then(() => {
      const viewer = this.getTreeView(treeViewId);
      if (viewer && itemInfo) {
        return this.reveal(viewer, this._dataProviders.get(treeViewId), itemInfo.item, itemInfo.parentChain, options);
      }
      return void 0;
    });
  }
  $refresh(treeViewId, itemsToRefreshByHandle) {
    this.logService.trace("MainThreadTreeViews#$refresh", treeViewId, itemsToRefreshByHandle);
    const viewer = this.getTreeView(treeViewId);
    const dataProvider = this._dataProviders.get(treeViewId);
    if (viewer && dataProvider) {
      const itemsToRefresh = dataProvider.getItemsToRefresh(itemsToRefreshByHandle);
      return viewer.refresh(itemsToRefresh.length ? itemsToRefresh : void 0);
    }
    return Promise.resolve();
  }
  $setMessage(treeViewId, message) {
    this.logService.trace("MainThreadTreeViews#$setMessage", treeViewId, message.toString());
    const viewer = this.getTreeView(treeViewId);
    if (viewer) {
      viewer.message = message;
    }
  }
  $setTitle(treeViewId, title, description) {
    this.logService.trace("MainThreadTreeViews#$setTitle", treeViewId, title, description);
    const viewer = this.getTreeView(treeViewId);
    if (viewer) {
      viewer.title = title;
      viewer.description = description;
    }
  }
  $setBadge(treeViewId, badge) {
    this.logService.trace("MainThreadTreeViews#$setBadge", treeViewId, badge == null ? void 0 : badge.value, badge == null ? void 0 : badge.tooltip);
    const viewer = this.getTreeView(treeViewId);
    if (viewer) {
      viewer.badge = badge;
    }
  }
  $resolveDropFileData(destinationViewId, requestId, dataItemId) {
    const controller = this._dndControllers.get(destinationViewId);
    if (!controller) {
      throw new Error("Unknown tree");
    }
    return controller.resolveDropFileData(requestId, dataItemId);
  }
  async $disposeTree(treeViewId) {
    const viewer = this.getTreeView(treeViewId);
    if (viewer) {
      viewer.dataProvider = void 0;
    }
  }
  async reveal(treeView, dataProvider, itemIn, parentChain, options) {
    options = options ? options : { select: false, focus: false };
    const select = isUndefinedOrNull(options.select) ? false : options.select;
    const focus = isUndefinedOrNull(options.focus) ? false : options.focus;
    let expand = Math.min(isNumber(options.expand) ? options.expand : options.expand === true ? 1 : 0, 3);
    if (dataProvider.isEmpty()) {
      await treeView.refresh();
    }
    for (const parent of parentChain) {
      const parentItem = dataProvider.getItem(parent.handle);
      if (parentItem) {
        await treeView.expand(parentItem);
      }
    }
    const item = dataProvider.getItem(itemIn.handle);
    if (item) {
      await treeView.reveal(item);
      if (select) {
        treeView.setSelection([item]);
      }
      if (focus === false) {
        treeView.setFocus();
      } else if (focus) {
        treeView.setFocus(item);
      }
      let itemsToExpand = [item];
      for (; itemsToExpand.length > 0 && expand > 0; expand--) {
        await treeView.expand(itemsToExpand);
        itemsToExpand = itemsToExpand.reduce((result, itemValue) => {
          const item2 = dataProvider.getItem(itemValue.handle);
          if (item2 && item2.children && item2.children.length) {
            result.push(...item2.children);
          }
          return result;
        }, []);
      }
    }
  }
  registerListeners(treeViewId, treeView) {
    this._register(treeView.onDidExpandItem((item) => this._proxy.$setExpanded(treeViewId, item.handle, true)));
    this._register(treeView.onDidCollapseItem((item) => this._proxy.$setExpanded(treeViewId, item.handle, false)));
    this._register(treeView.onDidChangeSelectionAndFocus((items) => this._proxy.$setSelectionAndFocus(treeViewId, items.selection.map(({ handle }) => handle), items.focus.handle)));
    this._register(treeView.onDidChangeVisibility((isVisible) => this._proxy.$setVisible(treeViewId, isVisible)));
    this._register(treeView.onDidChangeCheckboxState((items) => {
      this._proxy.$changeCheckboxState(treeViewId, items.map((item) => {
        var _a30;
        return { treeItemHandle: item.handle, newState: ((_a30 = item.checkbox) == null ? void 0 : _a30.isChecked) ?? false };
      }));
    }));
  }
  getTreeView(treeViewId) {
    const viewDescriptor = Registry.as(Extensions5.ViewsRegistry).getView(treeViewId);
    return viewDescriptor ? viewDescriptor.treeView : null;
  }
  dispose() {
    this._dataProviders.forEach((dataProvider, treeViewId) => {
      const treeView = this.getTreeView(treeViewId);
      if (treeView) {
        treeView.dataProvider = void 0;
      }
    });
    this._dataProviders.clear();
    this._dndControllers.clear();
    super.dispose();
  }
};
MainThreadTreeViews = __decorate([
  extHostNamedCustomer(MainContext.MainThreadTreeViews),
  __param(1, IViewsService),
  __param(2, INotificationService),
  __param(3, IExtensionService),
  __param(4, ILogService)
], MainThreadTreeViews);
var TreeViewDragAndDropController = class {
  constructor(treeViewId, dropMimeTypes, dragMimeTypes, hasWillDrop, _proxy10) {
    this.treeViewId = treeViewId;
    this.dropMimeTypes = dropMimeTypes;
    this.dragMimeTypes = dragMimeTypes;
    this.hasWillDrop = hasWillDrop;
    this._proxy = _proxy10;
    this.dataTransfersCache = new DataTransferFileCache();
  }
  async handleDrop(dataTransfer, targetTreeItem, token, operationUuid, sourceTreeId, sourceTreeItemHandles) {
    const request = this.dataTransfersCache.add(dataTransfer);
    try {
      const dataTransferDto = await DataTransfer2.from(dataTransfer);
      if (token.isCancellationRequested) {
        return;
      }
      return await this._proxy.$handleDrop(this.treeViewId, request.id, dataTransferDto, targetTreeItem == null ? void 0 : targetTreeItem.handle, token, operationUuid, sourceTreeId, sourceTreeItemHandles);
    } finally {
      request.dispose();
    }
  }
  async handleDrag(sourceTreeItemHandles, operationUuid, token) {
    if (!this.hasWillDrop) {
      return;
    }
    const additionalDataTransferDTO = await this._proxy.$handleDrag(this.treeViewId, sourceTreeItemHandles, operationUuid, token);
    if (!additionalDataTransferDTO) {
      return;
    }
    const additionalDataTransfer = new VSDataTransfer();
    additionalDataTransferDTO.items.forEach(([type, item]) => {
      additionalDataTransfer.replace(type, createStringDataTransferItem(item.asString));
    });
    return additionalDataTransfer;
  }
  resolveDropFileData(requestId, dataItemId) {
    return this.dataTransfersCache.resolveFileData(requestId, dataItemId);
  }
};
var TreeViewDataProvider = class {
  constructor(treeViewId, _proxy10, notificationService) {
    this.treeViewId = treeViewId;
    this._proxy = _proxy10;
    this.notificationService = notificationService;
    this.itemsMap = /* @__PURE__ */ new Map();
    this.hasResolve = this._proxy.$hasResolve(this.treeViewId);
  }
  getChildren(treeItem) {
    return this._proxy.$getChildren(this.treeViewId, treeItem ? treeItem.handle : void 0).then((children) => this.postGetChildren(children), (err) => {
      if (!NoTreeViewError.is(err)) {
        this.notificationService.error(err);
      }
      return [];
    });
  }
  getItemsToRefresh(itemsToRefreshByHandle) {
    const itemsToRefresh = [];
    if (itemsToRefreshByHandle) {
      for (const treeItemHandle of Object.keys(itemsToRefreshByHandle)) {
        const currentTreeItem = this.getItem(treeItemHandle);
        if (currentTreeItem) {
          const treeItem = itemsToRefreshByHandle[treeItemHandle];
          this.updateTreeItem(currentTreeItem, treeItem);
          if (treeItemHandle === treeItem.handle) {
            itemsToRefresh.push(currentTreeItem);
          } else {
            this.itemsMap.delete(treeItemHandle);
            this.itemsMap.set(currentTreeItem.handle, currentTreeItem);
            const parent = treeItem.parentHandle ? this.itemsMap.get(treeItem.parentHandle) : null;
            if (parent) {
              itemsToRefresh.push(parent);
            }
          }
        }
      }
    }
    return itemsToRefresh;
  }
  getItem(treeItemHandle) {
    return this.itemsMap.get(treeItemHandle);
  }
  isEmpty() {
    return this.itemsMap.size === 0;
  }
  async postGetChildren(elements) {
    if (elements === void 0) {
      return void 0;
    }
    const result = [];
    const hasResolve = await this.hasResolve;
    if (elements) {
      for (const element of elements) {
        const resolvable = new ResolvableTreeItem(element, hasResolve ? (token) => {
          return this._proxy.$resolve(this.treeViewId, element.handle, token);
        } : void 0);
        this.itemsMap.set(element.handle, resolvable);
        result.push(resolvable);
      }
    }
    return result;
  }
  updateTreeItem(current, treeItem) {
    treeItem.children = treeItem.children ? treeItem.children : void 0;
    if (current) {
      const properties = distinct([
        ...Object.keys(current instanceof ResolvableTreeItem ? current.asTreeItem() : current),
        ...Object.keys(treeItem)
      ]);
      for (const property of properties) {
        current[property] = treeItem[property];
      }
      if (current instanceof ResolvableTreeItem) {
        current.resetResolve();
      }
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadDownloadService.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
init_uri();
var MainThreadDownloadService = class MainThreadDownloadService2 extends Disposable {
  constructor(extHostContext, downloadService) {
    super();
    this.downloadService = downloadService;
  }
  $download(uri, to) {
    return this.downloadService.download(URI.revive(uri), URI.revive(to));
  }
};
MainThreadDownloadService = __decorate([
  extHostNamedCustomer(MainContext.MainThreadDownloadService),
  __param(1, IDownloadService)
], MainThreadDownloadService);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadUrls.js
init_tslib_es6();
init_extHost_protocol();
init_extensions();
var ExtensionUrlHandler = class {
  constructor(proxy, handle, extensionId, extensionDisplayName) {
    this.proxy = proxy;
    this.handle = handle;
    this.extensionId = extensionId;
    this.extensionDisplayName = extensionDisplayName;
  }
  handleURL(uri, options) {
    if (!ExtensionIdentifier.equals(this.extensionId, uri.authority)) {
      return Promise.resolve(false);
    }
    return Promise.resolve(this.proxy.$handleExternalUri(this.handle, uri)).then(() => true);
  }
};
var MainThreadUrls = class MainThreadUrls2 {
  constructor(context, urlService, extensionUrlHandler) {
    this.urlService = urlService;
    this.extensionUrlHandler = extensionUrlHandler;
    this.handlers = /* @__PURE__ */ new Map();
    this.proxy = context.getProxy(ExtHostContext.ExtHostUrls);
  }
  $registerUriHandler(handle, extensionId, extensionDisplayName) {
    const handler = new ExtensionUrlHandler(this.proxy, handle, extensionId, extensionDisplayName);
    const disposable = this.urlService.registerHandler(handler);
    this.handlers.set(handle, { extensionId, disposable });
    this.extensionUrlHandler.registerExtensionHandler(extensionId, handler);
    return Promise.resolve(void 0);
  }
  $unregisterUriHandler(handle) {
    const tuple = this.handlers.get(handle);
    if (!tuple) {
      return Promise.resolve(void 0);
    }
    const { extensionId, disposable } = tuple;
    this.extensionUrlHandler.unregisterExtensionHandler(extensionId);
    this.handlers.delete(handle);
    disposable.dispose();
    return Promise.resolve(void 0);
  }
  async $createAppUri(uri) {
    return this.urlService.create(uri);
  }
  dispose() {
    this.handlers.forEach(({ disposable }) => disposable.dispose());
    this.handlers.clear();
  }
};
MainThreadUrls = __decorate([
  extHostNamedCustomer(MainContext.MainThreadUrls),
  __param(1, IURLService),
  __param(2, IExtensionUrlHandler)
], MainThreadUrls);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadUriOpeners.js
init_tslib_es6();
init_actions();
init_errors();
init_lifecycle();
init_network();
init_nls();
init_opener();
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/workbench/contrib/externalUriOpener/common/contributedOpeners.js
init_tslib_es6();
init_lifecycle();
var ContributedExternalUriOpenersStore_1;
var _a23;
var ContributedExternalUriOpenersStore = (_a23 = class extends Disposable {
  constructor(storageService, _extensionService2) {
    super();
    this._extensionService = _extensionService2;
    this._openers = /* @__PURE__ */ new Map();
    this._memento = new Memento(ContributedExternalUriOpenersStore_1.STORAGE_ID, storageService);
    this._mementoObject = this._memento.getMemento(0, 1);
    for (const [id, value] of Object.entries(this._mementoObject || {})) {
      this.add(id, value.extensionId, { isCurrentlyRegistered: false });
    }
    this.invalidateOpenersOnExtensionsChanged();
    this._register(this._extensionService.onDidChangeExtensions(() => this.invalidateOpenersOnExtensionsChanged()));
    this._register(this._extensionService.onDidChangeExtensionsStatus(() => this.invalidateOpenersOnExtensionsChanged()));
  }
  didRegisterOpener(id, extensionId) {
    this.add(id, extensionId, {
      isCurrentlyRegistered: true
    });
  }
  add(id, extensionId, options) {
    const existing = this._openers.get(id);
    if (existing) {
      existing.isCurrentlyRegistered = existing.isCurrentlyRegistered || options.isCurrentlyRegistered;
      return;
    }
    const entry = {
      extensionId,
      isCurrentlyRegistered: options.isCurrentlyRegistered
    };
    this._openers.set(id, entry);
    this._mementoObject[id] = entry;
    this._memento.saveMemento();
    this.updateSchema();
  }
  delete(id) {
    this._openers.delete(id);
    delete this._mementoObject[id];
    this._memento.saveMemento();
    this.updateSchema();
  }
  async invalidateOpenersOnExtensionsChanged() {
    await this._extensionService.whenInstalledExtensionsRegistered();
    const registeredExtensions = this._extensionService.extensions;
    for (const [id, entry] of this._openers) {
      const extension = registeredExtensions.find((r) => r.identifier.value === entry.extensionId);
      if (extension) {
        if (!this._extensionService.canRemoveExtension(extension)) {
          if (!entry.isCurrentlyRegistered) {
            this.delete(id);
          }
        }
      } else {
        this.delete(id);
      }
    }
  }
  updateSchema() {
    const ids = [];
    const descriptions = [];
    for (const [id, entry] of this._openers) {
      ids.push(id);
      descriptions.push(entry.extensionId);
    }
    updateContributedOpeners(ids, descriptions);
  }
}, ContributedExternalUriOpenersStore_1 = _a23, _a23.STORAGE_ID = "externalUriOpeners", _a23);
ContributedExternalUriOpenersStore = ContributedExternalUriOpenersStore_1 = __decorate([
  __param(0, IStorageService),
  __param(1, IExtensionService)
], ContributedExternalUriOpenersStore);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadUriOpeners.js
var MainThreadUriOpeners = class MainThreadUriOpeners2 extends Disposable {
  constructor(context, storageService, externalUriOpenerService, extensionService, openerService, notificationService) {
    super();
    this.extensionService = extensionService;
    this.openerService = openerService;
    this.notificationService = notificationService;
    this._registeredOpeners = /* @__PURE__ */ new Map();
    this.proxy = context.getProxy(ExtHostContext.ExtHostUriOpeners);
    this._register(externalUriOpenerService.registerExternalOpenerProvider(this));
    this._contributedExternalUriOpenersStore = this._register(new ContributedExternalUriOpenersStore(storageService, extensionService));
  }
  async *getOpeners(targetUri) {
    if (targetUri.scheme !== Schemas.http && targetUri.scheme !== Schemas.https) {
      return;
    }
    await this.extensionService.activateByEvent(`onOpenExternalUri:${targetUri.scheme}`);
    for (const [id, openerMetadata] of this._registeredOpeners) {
      if (openerMetadata.schemes.has(targetUri.scheme)) {
        yield this.createOpener(id, openerMetadata);
      }
    }
  }
  createOpener(id, metadata) {
    return {
      id,
      label: metadata.label,
      canOpen: (uri, token) => {
        return this.proxy.$canOpenUri(id, uri, token);
      },
      openExternalUri: async (uri, ctx, token) => {
        try {
          await this.proxy.$openUri(id, { resolvedUri: uri, sourceUri: ctx.sourceUri }, token);
        } catch (e) {
          if (!isCancellationError(e)) {
            const openDefaultAction = new Action("default", localize("openerFailedUseDefault", "Open using default opener"), void 0, void 0, async () => {
              await this.openerService.open(uri, {
                allowTunneling: false,
                allowContributedOpeners: defaultExternalUriOpenerId
              });
            });
            openDefaultAction.tooltip = uri.toString();
            this.notificationService.notify({
              severity: Severity.Error,
              message: localize({
                key: "openerFailedMessage",
                comment: ["{0} is the id of the opener. {1} is the url being opened."]
              }, "Could not open uri with '{0}': {1}", id, e.toString()),
              actions: {
                primary: [
                  openDefaultAction
                ]
              }
            });
          }
        }
        return true;
      }
    };
  }
  async $registerUriOpener(id, schemes, extensionId, label) {
    if (this._registeredOpeners.has(id)) {
      throw new Error(`Opener with id '${id}' already registered`);
    }
    this._registeredOpeners.set(id, {
      schemes: new Set(schemes),
      label,
      extensionId
    });
    this._contributedExternalUriOpenersStore.didRegisterOpener(id, extensionId.value);
  }
  async $unregisterUriOpener(id) {
    this._registeredOpeners.delete(id);
    this._contributedExternalUriOpenersStore.delete(id);
  }
  dispose() {
    super.dispose();
    this._registeredOpeners.clear();
  }
};
MainThreadUriOpeners = __decorate([
  extHostNamedCustomer(MainContext.MainThreadUriOpeners),
  __param(1, IStorageService),
  __param(2, IExternalUriOpenerService),
  __param(3, IExtensionService),
  __param(4, IOpenerService),
  __param(5, INotificationService)
], MainThreadUriOpeners);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadWindow.js
init_tslib_es6();
init_event();
init_lifecycle();
init_uri();
init_opener();
init_extHost_protocol();
var MainThreadWindow = class MainThreadWindow2 {
  constructor(extHostContext, hostService, openerService, userActivityService) {
    this.hostService = hostService;
    this.openerService = openerService;
    this.userActivityService = userActivityService;
    this.disposables = new DisposableStore();
    this.proxy = extHostContext.getProxy(ExtHostContext.ExtHostWindow);
    Event.latch(hostService.onDidChangeFocus)(this.proxy.$onDidChangeWindowFocus, this.proxy, this.disposables);
    userActivityService.onDidChangeIsActive(this.proxy.$onDidChangeWindowActive, this.proxy, this.disposables);
  }
  dispose() {
    this.disposables.dispose();
  }
  $getInitialState() {
    return Promise.resolve({
      isFocused: this.hostService.hasFocus,
      isActive: this.userActivityService.isActive
    });
  }
  async $openUri(uriComponents, uriString, options) {
    const uri = URI.from(uriComponents);
    let target;
    if (uriString && URI.parse(uriString).toString() === uri.toString()) {
      target = uriString;
    } else {
      target = uri;
    }
    return this.openerService.open(target, {
      openExternal: true,
      allowTunneling: options.allowTunneling,
      allowContributedOpeners: options.allowContributedOpeners
    });
  }
  async $asExternalUri(uriComponents, options) {
    const result = await this.openerService.resolveExternalUri(URI.revive(uriComponents), options);
    return result.resolved;
  }
};
MainThreadWindow = __decorate([
  extHostNamedCustomer(MainContext.MainThreadWindow),
  __param(1, IHostService),
  __param(2, IOpenerService),
  __param(3, IUserActivityService)
], MainThreadWindow);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadWebviewManager.js
init_tslib_es6();
init_lifecycle();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadCustomEditors.js
init_tslib_es6();
init_dom();
init_async();
init_cancellation();
init_errors();
init_event();
init_lifecycle();
init_network();
init_path();
init_resources();
init_uri();
init_uuid();
init_nls();
init_files();
init_instantiation();
init_undoRedo();
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/workbench/contrib/customEditor/common/customTextEditorModel.js
init_tslib_es6();
init_event();
init_lifecycle();
init_resources();
init_resolverService();
var CustomTextEditorModel_1;
var CustomTextEditorModel = CustomTextEditorModel_1 = class CustomTextEditorModel2 extends Disposable {
  static async create(instantiationService, viewType, resource) {
    return instantiationService.invokeFunction(async (accessor) => {
      const textModelResolverService = accessor.get(ITextModelService);
      const model = await textModelResolverService.createModelReference(resource);
      return instantiationService.createInstance(CustomTextEditorModel_1, viewType, resource, model);
    });
  }
  constructor(viewType, _resource, _model, textFileService) {
    super();
    this.viewType = viewType;
    this._resource = _resource;
    this._model = _model;
    this.textFileService = textFileService;
    this._onDidChangeOrphaned = this._register(new Emitter());
    this.onDidChangeOrphaned = this._onDidChangeOrphaned.event;
    this._onDidChangeReadonly = this._register(new Emitter());
    this.onDidChangeReadonly = this._onDidChangeReadonly.event;
    this._onDidChangeDirty = this._register(new Emitter());
    this.onDidChangeDirty = this._onDidChangeDirty.event;
    this._onDidChangeContent = this._register(new Emitter());
    this.onDidChangeContent = this._onDidChangeContent.event;
    this._register(_model);
    this._textFileModel = this.textFileService.files.get(_resource);
    if (this._textFileModel) {
      this._register(this._textFileModel.onDidChangeOrphaned(() => this._onDidChangeOrphaned.fire()));
      this._register(this._textFileModel.onDidChangeReadonly(() => this._onDidChangeReadonly.fire()));
    }
    this._register(this.textFileService.files.onDidChangeDirty((e) => {
      if (isEqual(this.resource, e.resource)) {
        this._onDidChangeDirty.fire();
        this._onDidChangeContent.fire();
      }
    }));
  }
  get resource() {
    return this._resource;
  }
  isReadonly() {
    return this._model.object.isReadonly();
  }
  get backupId() {
    return void 0;
  }
  isDirty() {
    return this.textFileService.isDirty(this.resource);
  }
  isOrphaned() {
    var _a30;
    return !!((_a30 = this._textFileModel) == null ? void 0 : _a30.hasState(4));
  }
  async revert(options) {
    return this.textFileService.revert(this.resource, options);
  }
  saveCustomEditor(options) {
    return this.textFileService.save(this.resource, options);
  }
  async saveCustomEditorAs(resource, targetResource, options) {
    return !!await this.textFileService.saveAs(resource, targetResource, options);
  }
};
CustomTextEditorModel = CustomTextEditorModel_1 = __decorate([
  __param(3, ITextFileService)
], CustomTextEditorModel);

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/resourceWorkingCopy.js
init_tslib_es6();
init_async();
init_event();
init_lifecycle();
init_files();
var ResourceWorkingCopy = class ResourceWorkingCopy2 extends Disposable {
  constructor(resource, fileService) {
    super();
    this.resource = resource;
    this.fileService = fileService;
    this._onDidChangeOrphaned = this._register(new Emitter());
    this.onDidChangeOrphaned = this._onDidChangeOrphaned.event;
    this.orphaned = false;
    this._onWillDispose = this._register(new Emitter());
    this.onWillDispose = this._onWillDispose.event;
    this.disposed = false;
    this._register(this.fileService.onDidFilesChange((e) => this.onDidFilesChange(e)));
  }
  isOrphaned() {
    return this.orphaned;
  }
  async onDidFilesChange(e) {
    let fileEventImpactsUs = false;
    let newInOrphanModeGuess;
    if (this.orphaned) {
      const fileWorkingCopyResourceAdded = e.contains(this.resource, 1);
      if (fileWorkingCopyResourceAdded) {
        newInOrphanModeGuess = false;
        fileEventImpactsUs = true;
      }
    } else {
      const fileWorkingCopyResourceDeleted = e.contains(this.resource, 2);
      if (fileWorkingCopyResourceDeleted) {
        newInOrphanModeGuess = true;
        fileEventImpactsUs = true;
      }
    }
    if (fileEventImpactsUs && this.orphaned !== newInOrphanModeGuess) {
      let newInOrphanModeValidated = false;
      if (newInOrphanModeGuess) {
        await timeout(100);
        if (this.isDisposed()) {
          newInOrphanModeValidated = true;
        } else {
          const exists = await this.fileService.exists(this.resource);
          newInOrphanModeValidated = !exists;
        }
      }
      if (this.orphaned !== newInOrphanModeValidated && !this.isDisposed()) {
        this.setOrphaned(newInOrphanModeValidated);
      }
    }
  }
  setOrphaned(orphaned) {
    if (this.orphaned !== orphaned) {
      this.orphaned = orphaned;
      this._onDidChangeOrphaned.fire();
    }
  }
  isDisposed() {
    return this.disposed;
  }
  dispose() {
    this.disposed = true;
    this.orphaned = false;
    this._onWillDispose.fire();
    super.dispose();
  }
  isModified() {
    return this.isDirty();
  }
};
ResourceWorkingCopy = __decorate([
  __param(1, IFileService)
], ResourceWorkingCopy);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadCustomEditors.js
var MainThreadCustomEditorModel_1;
var MainThreadCustomEditors = class MainThreadCustomEditors2 extends Disposable {
  constructor(context, mainThreadWebview, mainThreadWebviewPanels, extensionService, storageService, workingCopyService, workingCopyFileService, _customEditorService, _editorGroupService, _editorService, _instantiationService, _webviewWorkbenchService) {
    super();
    this.mainThreadWebview = mainThreadWebview;
    this.mainThreadWebviewPanels = mainThreadWebviewPanels;
    this._customEditorService = _customEditorService;
    this._editorGroupService = _editorGroupService;
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._webviewWorkbenchService = _webviewWorkbenchService;
    this._editorProviders = this._register(new DisposableMap());
    this._editorRenameBackups = /* @__PURE__ */ new Map();
    this._webviewOriginStore = new ExtensionKeyedWebviewOriginStore("mainThreadCustomEditors.origins", storageService);
    this._proxyCustomEditors = context.getProxy(ExtHostContext.ExtHostCustomEditors);
    this._register(workingCopyFileService.registerWorkingCopyProvider((editorResource) => {
      const matchedWorkingCopies = [];
      for (const workingCopy of workingCopyService.workingCopies) {
        if (workingCopy instanceof MainThreadCustomEditorModel) {
          if (isEqualOrParent(editorResource, workingCopy.editorResource)) {
            matchedWorkingCopies.push(workingCopy);
          }
        }
      }
      return matchedWorkingCopies;
    }));
    this._register(_webviewWorkbenchService.registerResolver({
      canResolve: (webview) => {
        if (webview instanceof CustomEditorInput) {
          extensionService.activateByEvent(`onCustomEditor:${webview.viewType}`);
        }
        return false;
      },
      resolveWebview: () => {
        throw new Error("not implemented");
      }
    }));
    this._register(workingCopyFileService.onWillRunWorkingCopyFileOperation(async (e) => this.onWillRunWorkingCopyFileOperation(e)));
  }
  $registerTextEditorProvider(extensionData, viewType, options, capabilities, serializeBuffersForPostMessage) {
    this.registerEditorProvider(1, reviveWebviewExtension(extensionData), viewType, options, capabilities, true, serializeBuffersForPostMessage);
  }
  $registerCustomEditorProvider(extensionData, viewType, options, supportsMultipleEditorsPerDocument, serializeBuffersForPostMessage) {
    this.registerEditorProvider(0, reviveWebviewExtension(extensionData), viewType, options, {}, supportsMultipleEditorsPerDocument, serializeBuffersForPostMessage);
  }
  registerEditorProvider(modelType, extension, viewType, options, capabilities, supportsMultipleEditorsPerDocument, serializeBuffersForPostMessage) {
    if (this._editorProviders.has(viewType)) {
      throw new Error(`Provider for ${viewType} already registered`);
    }
    const disposables = new DisposableStore();
    disposables.add(this._customEditorService.registerCustomEditorCapabilities(viewType, {
      supportsMultipleEditorsPerDocument
    }));
    disposables.add(this._webviewWorkbenchService.registerResolver({
      canResolve: (webviewInput) => {
        return webviewInput instanceof CustomEditorInput && webviewInput.viewType === viewType;
      },
      resolveWebview: async (webviewInput, cancellation) => {
        const handle = generateUuid();
        const resource = webviewInput.resource;
        webviewInput.webview.origin = this._webviewOriginStore.getOrigin(viewType, extension.id);
        this.mainThreadWebviewPanels.addWebviewInput(handle, webviewInput, { serializeBuffersForPostMessage });
        webviewInput.webview.options = options;
        webviewInput.webview.extension = extension;
        let backupId = webviewInput.backupId;
        if (webviewInput.oldResource && !webviewInput.backupId) {
          const backup = this._editorRenameBackups.get(webviewInput.oldResource.toString());
          backupId = backup == null ? void 0 : backup.backupId;
          this._editorRenameBackups.delete(webviewInput.oldResource.toString());
        }
        let modelRef;
        try {
          modelRef = await this.getOrCreateCustomEditorModel(modelType, resource, viewType, { backupId }, cancellation);
        } catch (error) {
          onUnexpectedError(error);
          webviewInput.webview.setHtml(this.mainThreadWebview.getWebviewResolvedFailedContent(viewType));
          return;
        }
        if (cancellation.isCancellationRequested) {
          modelRef.dispose();
          return;
        }
        webviewInput.webview.onDidDispose(() => {
          if (modelRef.object.isDirty()) {
            const sub = modelRef.object.onDidChangeDirty(() => {
              if (!modelRef.object.isDirty()) {
                sub.dispose();
                modelRef.dispose();
              }
            });
            return;
          }
          modelRef.dispose();
        });
        if (capabilities.supportsMove) {
          webviewInput.onMove(async (newResource) => {
            const oldModel = modelRef;
            modelRef = await this.getOrCreateCustomEditorModel(modelType, newResource, viewType, {}, CancellationToken.None);
            this._proxyCustomEditors.$onMoveCustomEditor(handle, newResource, viewType);
            oldModel.dispose();
          });
        }
        try {
          await this._proxyCustomEditors.$resolveCustomEditor(resource, handle, viewType, {
            title: webviewInput.getTitle(),
            contentOptions: webviewInput.webview.contentOptions,
            options: webviewInput.webview.options,
            active: webviewInput === this._editorService.activeEditor
          }, editorGroupToColumn(this._editorGroupService, webviewInput.group || 0), cancellation);
        } catch (error) {
          onUnexpectedError(error);
          webviewInput.webview.setHtml(this.mainThreadWebview.getWebviewResolvedFailedContent(viewType));
          modelRef.dispose();
          return;
        }
      }
    }));
    this._editorProviders.set(viewType, disposables);
  }
  $unregisterEditorProvider(viewType) {
    if (!this._editorProviders.has(viewType)) {
      throw new Error(`No provider for ${viewType} registered`);
    }
    this._editorProviders.deleteAndDispose(viewType);
    this._customEditorService.models.disposeAllModelsForView(viewType);
  }
  async getOrCreateCustomEditorModel(modelType, resource, viewType, options, cancellation) {
    const existingModel = this._customEditorService.models.tryRetain(resource, viewType);
    if (existingModel) {
      return existingModel;
    }
    switch (modelType) {
      case 1: {
        const model = CustomTextEditorModel.create(this._instantiationService, viewType, resource);
        return this._customEditorService.models.add(resource, viewType, model);
      }
      case 0: {
        const model = MainThreadCustomEditorModel.create(this._instantiationService, this._proxyCustomEditors, viewType, resource, options, () => {
          return Array.from(this.mainThreadWebviewPanels.webviewInputs).filter((editor) => editor instanceof CustomEditorInput && isEqual(editor.resource, resource));
        }, cancellation);
        return this._customEditorService.models.add(resource, viewType, model);
      }
    }
  }
  async $onDidEdit(resourceComponents, viewType, editId, label) {
    const model = await this.getCustomEditorModel(resourceComponents, viewType);
    model.pushEdit(editId, label);
  }
  async $onContentChange(resourceComponents, viewType) {
    const model = await this.getCustomEditorModel(resourceComponents, viewType);
    model.changeContent();
  }
  async getCustomEditorModel(resourceComponents, viewType) {
    const resource = URI.revive(resourceComponents);
    const model = await this._customEditorService.models.get(resource, viewType);
    if (!model || !(model instanceof MainThreadCustomEditorModel)) {
      throw new Error("Could not find model for webview editor");
    }
    return model;
  }
  async onWillRunWorkingCopyFileOperation(e) {
    if (e.operation !== 2) {
      return;
    }
    e.waitUntil((async () => {
      const models = [];
      for (const file of e.files) {
        if (file.source) {
          models.push(...await this._customEditorService.models.getAllModels(file.source));
        }
      }
      for (const model of models) {
        if (model instanceof MainThreadCustomEditorModel && model.isDirty()) {
          const workingCopy = await model.backup(CancellationToken.None);
          if (workingCopy.meta) {
            this._editorRenameBackups.set(model.editorResource.toString(), workingCopy.meta);
          }
        }
      }
    })());
  }
};
MainThreadCustomEditors = __decorate([
  __param(3, IExtensionService),
  __param(4, IStorageService),
  __param(5, IWorkingCopyService),
  __param(6, IWorkingCopyFileService),
  __param(7, ICustomEditorService),
  __param(8, IEditorGroupsService),
  __param(9, IEditorService),
  __param(10, IInstantiationService),
  __param(11, IWebviewWorkbenchService)
], MainThreadCustomEditors);
var HotExitState;
(function(HotExitState2) {
  (function(Type) {
    Type[Type["Allowed"] = 0] = "Allowed";
    Type[Type["NotAllowed"] = 1] = "NotAllowed";
    Type[Type["Pending"] = 2] = "Pending";
  })(HotExitState2.Type || (HotExitState2.Type = {}));
  HotExitState2.Allowed = Object.freeze({ type: 0 });
  HotExitState2.NotAllowed = Object.freeze({ type: 1 });
  class Pending {
    constructor(operation) {
      this.operation = operation;
      this.type = 2;
    }
  }
  HotExitState2.Pending = Pending;
})(HotExitState || (HotExitState = {}));
var MainThreadCustomEditorModel = MainThreadCustomEditorModel_1 = class MainThreadCustomEditorModel2 extends ResourceWorkingCopy {
  static async create(instantiationService, proxy, viewType, resource, options, getEditors, cancellation) {
    const editors = getEditors();
    let untitledDocumentData;
    if (editors.length !== 0) {
      untitledDocumentData = editors[0].untitledDocumentData;
    }
    const { editable } = await proxy.$createCustomDocument(resource, viewType, options.backupId, untitledDocumentData, cancellation);
    return instantiationService.createInstance(MainThreadCustomEditorModel_1, proxy, viewType, resource, !!options.backupId, editable, !!untitledDocumentData, getEditors);
  }
  constructor(_proxy10, _viewType3, _editorResource, fromBackup, _editable, startDirty, _getEditors, _fileDialogService, fileService, _labelService, _undoService, _environmentService, workingCopyService, _pathService, extensionService) {
    super(MainThreadCustomEditorModel_1.toWorkingCopyResource(_viewType3, _editorResource), fileService);
    this._proxy = _proxy10;
    this._viewType = _viewType3;
    this._editorResource = _editorResource;
    this._editable = _editable;
    this._getEditors = _getEditors;
    this._fileDialogService = _fileDialogService;
    this._labelService = _labelService;
    this._undoService = _undoService;
    this._environmentService = _environmentService;
    this._pathService = _pathService;
    this._fromBackup = false;
    this._hotExitState = HotExitState.Allowed;
    this._currentEditIndex = -1;
    this._savePoint = -1;
    this._edits = [];
    this._isDirtyFromContentChange = false;
    this.typeId = NO_TYPE_ID;
    this._onDidChangeDirty = this._register(new Emitter());
    this.onDidChangeDirty = this._onDidChangeDirty.event;
    this._onDidChangeContent = this._register(new Emitter());
    this.onDidChangeContent = this._onDidChangeContent.event;
    this._onDidSave = this._register(new Emitter());
    this.onDidSave = this._onDidSave.event;
    this.onDidChangeReadonly = Event.None;
    this._fromBackup = fromBackup;
    if (_editable) {
      this._register(workingCopyService.registerWorkingCopy(this));
      this._register(extensionService.onWillStop((e) => {
        if (!this.isDirty()) {
          return;
        }
        e.veto((async () => {
          const didSave = await this.save();
          if (!didSave) {
            return true;
          }
          return false;
        })(), localize("vetoExtHostRestart", "Custom editor '{0}' could not be saved.", this.name));
      }));
    }
    if (startDirty) {
      this._isDirtyFromContentChange = true;
    }
  }
  get editorResource() {
    return this._editorResource;
  }
  dispose() {
    if (this._editable) {
      this._undoService.removeElements(this._editorResource);
    }
    this._proxy.$disposeCustomDocument(this._editorResource, this._viewType);
    super.dispose();
  }
  static toWorkingCopyResource(viewType, resource) {
    const authority = viewType.replace(/[^a-z0-9\-_]/gi, "-");
    const path = `/${multibyteAwareBtoa(resource.with({ query: null, fragment: null }).toString(true))}`;
    return URI.from({
      scheme: Schemas.vscodeCustomEditor,
      authority,
      path,
      query: JSON.stringify(resource.toJSON())
    });
  }
  get name() {
    return basename(this._labelService.getUriLabel(this._editorResource));
  }
  get capabilities() {
    return this.isUntitled() ? 2 : 0;
  }
  isDirty() {
    if (this._isDirtyFromContentChange) {
      return true;
    }
    if (this._edits.length > 0) {
      return this._savePoint !== this._currentEditIndex;
    }
    return this._fromBackup;
  }
  isUntitled() {
    return this._editorResource.scheme === Schemas.untitled;
  }
  isReadonly() {
    return !this._editable;
  }
  get viewType() {
    return this._viewType;
  }
  get backupId() {
    return this._backupId;
  }
  pushEdit(editId, label) {
    if (!this._editable) {
      throw new Error("Document is not editable");
    }
    this.change(() => {
      this.spliceEdits(editId);
      this._currentEditIndex = this._edits.length - 1;
    });
    this._undoService.pushElement({
      type: 0,
      resource: this._editorResource,
      label: label ?? localize("defaultEditLabel", "Edit"),
      code: "undoredo.customEditorEdit",
      undo: () => this.undo(),
      redo: () => this.redo()
    });
  }
  changeContent() {
    this.change(() => {
      this._isDirtyFromContentChange = true;
    });
  }
  async undo() {
    if (!this._editable) {
      return;
    }
    if (this._currentEditIndex < 0) {
      return;
    }
    const undoneEdit = this._edits[this._currentEditIndex];
    this.change(() => {
      --this._currentEditIndex;
    });
    await this._proxy.$undo(this._editorResource, this.viewType, undoneEdit, this.isDirty());
  }
  async redo() {
    if (!this._editable) {
      return;
    }
    if (this._currentEditIndex >= this._edits.length - 1) {
      return;
    }
    const redoneEdit = this._edits[this._currentEditIndex + 1];
    this.change(() => {
      ++this._currentEditIndex;
    });
    await this._proxy.$redo(this._editorResource, this.viewType, redoneEdit, this.isDirty());
  }
  spliceEdits(editToInsert) {
    const start = this._currentEditIndex + 1;
    const toRemove = this._edits.length - this._currentEditIndex;
    const removedEdits = typeof editToInsert === "number" ? this._edits.splice(start, toRemove, editToInsert) : this._edits.splice(start, toRemove);
    if (removedEdits.length) {
      this._proxy.$disposeEdits(this._editorResource, this._viewType, removedEdits);
    }
  }
  change(makeEdit) {
    const wasDirty = this.isDirty();
    makeEdit();
    this._onDidChangeContent.fire();
    if (this.isDirty() !== wasDirty) {
      this._onDidChangeDirty.fire();
    }
  }
  async revert(options) {
    if (!this._editable) {
      return;
    }
    if (this._currentEditIndex === this._savePoint && !this._isDirtyFromContentChange && !this._fromBackup) {
      return;
    }
    if (!(options == null ? void 0 : options.soft)) {
      this._proxy.$revert(this._editorResource, this.viewType, CancellationToken.None);
    }
    this.change(() => {
      this._isDirtyFromContentChange = false;
      this._fromBackup = false;
      this._currentEditIndex = this._savePoint;
      this.spliceEdits();
    });
  }
  async save(options) {
    const result = !!await this.saveCustomEditor(options);
    if (result) {
      this._onDidSave.fire({ reason: options == null ? void 0 : options.reason, source: options == null ? void 0 : options.source });
    }
    return result;
  }
  async saveCustomEditor(options) {
    var _a30;
    if (!this._editable) {
      return void 0;
    }
    if (this.isUntitled()) {
      const targetUri = await this.suggestUntitledSavePath(options);
      if (!targetUri) {
        return void 0;
      }
      await this.saveCustomEditorAs(this._editorResource, targetUri, options);
      return targetUri;
    }
    const savePromise = createCancelablePromise((token) => this._proxy.$onSave(this._editorResource, this.viewType, token));
    (_a30 = this._ongoingSave) == null ? void 0 : _a30.cancel();
    this._ongoingSave = savePromise;
    try {
      await savePromise;
      if (this._ongoingSave === savePromise) {
        this.change(() => {
          this._isDirtyFromContentChange = false;
          this._savePoint = this._currentEditIndex;
          this._fromBackup = false;
        });
      }
    } finally {
      if (this._ongoingSave === savePromise) {
        this._ongoingSave = void 0;
      }
    }
    return this._editorResource;
  }
  suggestUntitledSavePath(options) {
    if (!this.isUntitled()) {
      throw new Error("Resource is not untitled");
    }
    const remoteAuthority = this._environmentService.remoteAuthority;
    const localResource = toLocalResource(this._editorResource, remoteAuthority, this._pathService.defaultUriScheme);
    return this._fileDialogService.pickFileToSave(localResource, options == null ? void 0 : options.availableFileSystems);
  }
  async saveCustomEditorAs(resource, targetResource, _options3) {
    if (this._editable) {
      await createCancelablePromise((token) => this._proxy.$onSaveAs(this._editorResource, this.viewType, targetResource, token));
      this.change(() => {
        this._savePoint = this._currentEditIndex;
      });
      return true;
    } else {
      await this.fileService.copy(resource, targetResource, false);
      return true;
    }
  }
  async backup(token) {
    const editors = this._getEditors();
    if (!editors.length) {
      throw new Error("No editors found for resource, cannot back up");
    }
    const primaryEditor = editors[0];
    const backupMeta = {
      viewType: this.viewType,
      editorResource: this._editorResource,
      backupId: "",
      extension: primaryEditor.extension ? {
        id: primaryEditor.extension.id.value,
        location: primaryEditor.extension.location
      } : void 0,
      webview: {
        origin: primaryEditor.webview.origin,
        options: primaryEditor.webview.options,
        state: primaryEditor.webview.state
      }
    };
    const backupData = {
      meta: backupMeta
    };
    if (!this._editable) {
      return backupData;
    }
    if (this._hotExitState.type === 2) {
      this._hotExitState.operation.cancel();
    }
    const pendingState = new HotExitState.Pending(createCancelablePromise((token2) => this._proxy.$backup(this._editorResource.toJSON(), this.viewType, token2)));
    this._hotExitState = pendingState;
    token.onCancellationRequested(() => {
      pendingState.operation.cancel();
    });
    let errorMessage = "";
    try {
      const backupId = await pendingState.operation;
      if (this._hotExitState === pendingState) {
        this._hotExitState = HotExitState.Allowed;
        backupData.meta.backupId = backupId;
        this._backupId = backupId;
      }
    } catch (e) {
      if (isCancellationError(e)) {
        throw e;
      }
      if (this._hotExitState === pendingState) {
        this._hotExitState = HotExitState.NotAllowed;
      }
      if (e.message) {
        errorMessage = e.message;
      }
    }
    if (this._hotExitState === HotExitState.Allowed) {
      return backupData;
    }
    throw new Error(`Cannot back up in this state: ${errorMessage}`);
  }
};
MainThreadCustomEditorModel = MainThreadCustomEditorModel_1 = __decorate([
  __param(7, IFileDialogService),
  __param(8, IFileService),
  __param(9, ILabelService),
  __param(10, IUndoRedoService),
  __param(11, IWorkbenchEnvironmentService),
  __param(12, IWorkingCopyService),
  __param(13, IPathService),
  __param(14, IExtensionService)
], MainThreadCustomEditorModel);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadWebviewPanels.js
init_tslib_es6();
init_errors();
init_event();
init_lifecycle();
init_uri();
init_uuid();
init_configuration();
init_telemetry();
init_extHost_protocol();
var WebviewInputStore = class {
  constructor() {
    this._handlesToInputs = /* @__PURE__ */ new Map();
    this._inputsToHandles = /* @__PURE__ */ new Map();
  }
  add(handle, input) {
    this._handlesToInputs.set(handle, input);
    this._inputsToHandles.set(input, handle);
  }
  getHandleForInput(input) {
    return this._inputsToHandles.get(input);
  }
  getInputForHandle(handle) {
    return this._handlesToInputs.get(handle);
  }
  delete(handle) {
    const input = this.getInputForHandle(handle);
    this._handlesToInputs.delete(handle);
    if (input) {
      this._inputsToHandles.delete(input);
    }
  }
  get size() {
    return this._handlesToInputs.size;
  }
  [Symbol.iterator]() {
    return this._handlesToInputs.values();
  }
};
var WebviewViewTypeTransformer = class {
  constructor(prefix) {
    this.prefix = prefix;
  }
  fromExternal(viewType) {
    return this.prefix + viewType;
  }
  toExternal(viewType) {
    return viewType.startsWith(this.prefix) ? viewType.substr(this.prefix.length) : void 0;
  }
};
var MainThreadWebviewPanels = class MainThreadWebviewPanels2 extends Disposable {
  constructor(context, _mainThreadWebviews, _configurationService, _editorGroupService, _editorService, extensionService, storageService, _telemetryService, _webviewWorkbenchService) {
    super();
    this._mainThreadWebviews = _mainThreadWebviews;
    this._configurationService = _configurationService;
    this._editorGroupService = _editorGroupService;
    this._editorService = _editorService;
    this._telemetryService = _telemetryService;
    this._webviewWorkbenchService = _webviewWorkbenchService;
    this.webviewPanelViewType = new WebviewViewTypeTransformer("mainThreadWebview-");
    this._webviewInputs = new WebviewInputStore();
    this._revivers = this._register(new DisposableMap());
    this.webviewOriginStore = new ExtensionKeyedWebviewOriginStore("mainThreadWebviewPanel.origins", storageService);
    this._proxy = context.getProxy(ExtHostContext.ExtHostWebviewPanels);
    this._register(Event.any(_editorService.onDidActiveEditorChange, _editorService.onDidVisibleEditorsChange, _editorGroupService.onDidAddGroup, _editorGroupService.onDidRemoveGroup, _editorGroupService.onDidMoveGroup)(() => {
      this.updateWebviewViewStates(this._editorService.activeEditor);
    }));
    this._register(_webviewWorkbenchService.onDidChangeActiveWebviewEditor((input) => {
      this.updateWebviewViewStates(input);
    }));
    this._register(_webviewWorkbenchService.registerResolver({
      canResolve: (webview) => {
        const viewType = this.webviewPanelViewType.toExternal(webview.viewType);
        if (typeof viewType === "string") {
          extensionService.activateByEvent(`onWebviewPanel:${viewType}`);
        }
        return false;
      },
      resolveWebview: () => {
        throw new Error("not implemented");
      }
    }));
  }
  get webviewInputs() {
    return this._webviewInputs;
  }
  addWebviewInput(handle, input, options) {
    this._webviewInputs.add(handle, input);
    this._mainThreadWebviews.addWebview(handle, input.webview, options);
    input.webview.onDidDispose(() => {
      this._proxy.$onDidDisposeWebviewPanel(handle).finally(() => {
        this._webviewInputs.delete(handle);
      });
    });
  }
  $createWebviewPanel(extensionData, handle, viewType, initData, showOptions) {
    const targetGroup = this.getTargetGroupFromShowOptions(showOptions);
    const mainThreadShowOptions = showOptions ? {
      preserveFocus: !!showOptions.preserveFocus,
      group: targetGroup
    } : {};
    const extension = reviveWebviewExtension(extensionData);
    const origin = this.webviewOriginStore.getOrigin(viewType, extension.id);
    const webview = this._webviewWorkbenchService.openWebview({
      origin,
      providedViewType: viewType,
      title: initData.title,
      options: reviveWebviewOptions(initData.panelOptions),
      contentOptions: reviveWebviewContentOptions(initData.webviewOptions),
      extension
    }, this.webviewPanelViewType.fromExternal(viewType), initData.title, mainThreadShowOptions);
    this.addWebviewInput(handle, webview, { serializeBuffersForPostMessage: initData.serializeBuffersForPostMessage });
    const payload = {
      extensionId: extension.id.value,
      viewType
    };
    this._telemetryService.publicLog2("webviews:createWebviewPanel", payload);
  }
  $disposeWebview(handle) {
    const webview = this.tryGetWebviewInput(handle);
    if (!webview) {
      return;
    }
    webview.dispose();
  }
  $setTitle(handle, value) {
    var _a30;
    (_a30 = this.tryGetWebviewInput(handle)) == null ? void 0 : _a30.setName(value);
  }
  $setIconPath(handle, value) {
    const webview = this.tryGetWebviewInput(handle);
    if (webview) {
      webview.iconPath = reviveWebviewIcon(value);
    }
  }
  $reveal(handle, showOptions) {
    const webview = this.tryGetWebviewInput(handle);
    if (!webview || webview.isDisposed()) {
      return;
    }
    const targetGroup = this.getTargetGroupFromShowOptions(showOptions);
    this._webviewWorkbenchService.revealWebview(webview, targetGroup, !!showOptions.preserveFocus);
  }
  getTargetGroupFromShowOptions(showOptions) {
    if (typeof showOptions.viewColumn === "undefined" || showOptions.viewColumn === ACTIVE_GROUP || this._editorGroupService.count === 1 && this._editorGroupService.activeGroup.isEmpty) {
      return ACTIVE_GROUP;
    }
    if (showOptions.viewColumn === SIDE_GROUP) {
      return SIDE_GROUP;
    }
    if (showOptions.viewColumn >= 0) {
      const groupInColumn = this._editorGroupService.getGroups(2)[showOptions.viewColumn];
      if (groupInColumn) {
        return groupInColumn.id;
      }
      const newGroup = this._editorGroupService.findGroup({ location: 1 });
      if (newGroup) {
        const direction = preferredSideBySideGroupDirection(this._configurationService);
        return this._editorGroupService.addGroup(newGroup, direction);
      }
    }
    return ACTIVE_GROUP;
  }
  $registerSerializer(viewType, options) {
    if (this._revivers.has(viewType)) {
      throw new Error(`Reviver for ${viewType} already registered`);
    }
    this._revivers.set(viewType, this._webviewWorkbenchService.registerResolver({
      canResolve: (webviewInput) => {
        return webviewInput.viewType === this.webviewPanelViewType.fromExternal(viewType);
      },
      resolveWebview: async (webviewInput) => {
        const viewType2 = this.webviewPanelViewType.toExternal(webviewInput.viewType);
        if (!viewType2) {
          webviewInput.webview.setHtml(this._mainThreadWebviews.getWebviewResolvedFailedContent(webviewInput.viewType));
          return;
        }
        const handle = generateUuid();
        this.addWebviewInput(handle, webviewInput, options);
        let state = void 0;
        if (webviewInput.webview.state) {
          try {
            state = JSON.parse(webviewInput.webview.state);
          } catch (e) {
            console.error("Could not load webview state", e, webviewInput.webview.state);
          }
        }
        try {
          await this._proxy.$deserializeWebviewPanel(handle, viewType2, {
            title: webviewInput.getTitle(),
            state,
            panelOptions: webviewInput.webview.options,
            webviewOptions: webviewInput.webview.contentOptions,
            active: webviewInput === this._editorService.activeEditor
          }, editorGroupToColumn(this._editorGroupService, webviewInput.group || 0));
        } catch (error) {
          onUnexpectedError(error);
          webviewInput.webview.setHtml(this._mainThreadWebviews.getWebviewResolvedFailedContent(viewType2));
        }
      }
    }));
  }
  $unregisterSerializer(viewType) {
    if (!this._revivers.has(viewType)) {
      throw new Error(`No reviver for ${viewType} registered`);
    }
    this._revivers.deleteAndDispose(viewType);
  }
  updateWebviewViewStates(activeEditorInput) {
    if (!this._webviewInputs.size) {
      return;
    }
    const viewStates = {};
    const updateViewStatesForInput = (group, topLevelInput, editorInput) => {
      if (!(editorInput instanceof WebviewInput)) {
        return;
      }
      editorInput.updateGroup(group.id);
      const handle = this._webviewInputs.getHandleForInput(editorInput);
      if (handle) {
        viewStates[handle] = {
          visible: topLevelInput === group.activeEditor,
          active: editorInput === activeEditorInput,
          position: editorGroupToColumn(this._editorGroupService, group.id)
        };
      }
    };
    for (const group of this._editorGroupService.groups) {
      for (const input of group.editors) {
        if (input instanceof DiffEditorInput) {
          updateViewStatesForInput(group, input, input.primary);
          updateViewStatesForInput(group, input, input.secondary);
        } else {
          updateViewStatesForInput(group, input, input);
        }
      }
    }
    if (Object.keys(viewStates).length) {
      this._proxy.$onDidChangeWebviewPanelViewStates(viewStates);
    }
  }
  tryGetWebviewInput(handle) {
    return this._webviewInputs.getInputForHandle(handle);
  }
};
MainThreadWebviewPanels = __decorate([
  __param(2, IConfigurationService),
  __param(3, IEditorGroupsService),
  __param(4, IEditorService),
  __param(5, IExtensionService),
  __param(6, IStorageService),
  __param(7, ITelemetryService),
  __param(8, IWebviewWorkbenchService)
], MainThreadWebviewPanels);
function reviveWebviewIcon(value) {
  if (!value) {
    return void 0;
  }
  return {
    light: URI.revive(value.light),
    dark: URI.revive(value.dark)
  };
}
function reviveWebviewOptions(panelOptions) {
  return {
    enableFindWidget: panelOptions.enableFindWidget,
    retainContextWhenHidden: panelOptions.retainContextWhenHidden
  };
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadWebviewViews.js
init_tslib_es6();
init_errors();
init_lifecycle();
init_uuid();
init_extHost_protocol();
init_telemetry();
var MainThreadWebviewsViews = class MainThreadWebviewsViews2 extends Disposable {
  constructor(context, mainThreadWebviews, _telemetryService, _webviewViewService) {
    super();
    this.mainThreadWebviews = mainThreadWebviews;
    this._telemetryService = _telemetryService;
    this._webviewViewService = _webviewViewService;
    this._webviewViews = this._register(new DisposableMap());
    this._webviewViewProviders = this._register(new DisposableMap());
    this._proxy = context.getProxy(ExtHostContext.ExtHostWebviewViews);
  }
  $setWebviewViewTitle(handle, value) {
    const webviewView = this.getWebviewView(handle);
    webviewView.title = value;
  }
  $setWebviewViewDescription(handle, value) {
    const webviewView = this.getWebviewView(handle);
    webviewView.description = value;
  }
  $setWebviewViewBadge(handle, badge) {
    const webviewView = this.getWebviewView(handle);
    webviewView.badge = badge;
  }
  $show(handle, preserveFocus) {
    const webviewView = this.getWebviewView(handle);
    webviewView.show(preserveFocus);
  }
  $registerWebviewViewProvider(extensionData, viewType, options) {
    if (this._webviewViewProviders.has(viewType)) {
      throw new Error(`View provider for ${viewType} already registered`);
    }
    const extension = reviveWebviewExtension(extensionData);
    const registration = this._webviewViewService.register(viewType, {
      resolve: async (webviewView, cancellation) => {
        const handle = generateUuid();
        this._webviewViews.set(handle, webviewView);
        this.mainThreadWebviews.addWebview(handle, webviewView.webview, { serializeBuffersForPostMessage: options.serializeBuffersForPostMessage });
        let state = void 0;
        if (webviewView.webview.state) {
          try {
            state = JSON.parse(webviewView.webview.state);
          } catch (e) {
            console.error("Could not load webview state", e, webviewView.webview.state);
          }
        }
        webviewView.webview.extension = extension;
        if (options) {
          webviewView.webview.options = options;
        }
        webviewView.onDidChangeVisibility((visible) => {
          this._proxy.$onDidChangeWebviewViewVisibility(handle, visible);
        });
        webviewView.onDispose(() => {
          this._proxy.$disposeWebviewView(handle);
          this._webviewViews.deleteAndDispose(handle);
        });
        this._telemetryService.publicLog2("webviews:createWebviewView", {
          extensionId: extension.id.value,
          id: viewType
        });
        try {
          await this._proxy.$resolveWebviewView(handle, viewType, webviewView.title, state, cancellation);
        } catch (error) {
          onUnexpectedError(error);
          webviewView.webview.setHtml(this.mainThreadWebviews.getWebviewResolvedFailedContent(viewType));
        }
      }
    });
    this._webviewViewProviders.set(viewType, registration);
  }
  $unregisterWebviewViewProvider(viewType) {
    if (!this._webviewViewProviders.has(viewType)) {
      throw new Error(`No view provider for ${viewType} registered`);
    }
    this._webviewViewProviders.deleteAndDispose(viewType);
  }
  getWebviewView(handle) {
    const webviewView = this._webviewViews.get(handle);
    if (!webviewView) {
      throw new Error("unknown webview view");
    }
    return webviewView;
  }
};
MainThreadWebviewsViews = __decorate([
  __param(2, ITelemetryService),
  __param(3, IWebviewViewService)
], MainThreadWebviewsViews);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadWebviewManager.js
init_extHost_protocol();
var MainThreadWebviewManager = class MainThreadWebviewManager2 extends Disposable {
  constructor(context, instantiationService) {
    super();
    const webviews = this._register(instantiationService.createInstance(MainThreadWebviews, context));
    context.set(MainContext.MainThreadWebviews, webviews);
    const webviewPanels = this._register(instantiationService.createInstance(MainThreadWebviewPanels, context, webviews));
    context.set(MainContext.MainThreadWebviewPanels, webviewPanels);
    const customEditors = this._register(instantiationService.createInstance(MainThreadCustomEditors, context, webviews, webviewPanels));
    context.set(MainContext.MainThreadCustomEditors, customEditors);
    const webviewViews = this._register(instantiationService.createInstance(MainThreadWebviewsViews, context, webviews));
    context.set(MainContext.MainThreadWebviewViews, webviewViews);
  }
};
MainThreadWebviewManager = __decorate([
  extHostCustomer,
  __param(1, IInstantiationService)
], MainThreadWebviewManager);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadWorkspace.js
init_tslib_es6();
init_errors();
init_lifecycle();
init_platform();
init_uri();
init_nls();
init_environment();
init_files();
init_instantiation();
init_extHost_protocol();
init_editSessions();
init_arrays();
var MainThreadWorkspace = class MainThreadWorkspace2 {
  constructor(extHostContext, _searchService, _contextService, _editSessionIdentityService, _canonicalUriService, _editorService, _workspaceEditingService, _notificationService, _requestService, _instantiationService, _labelService, _environmentService, fileService, _workspaceTrustManagementService, _workspaceTrustRequestService) {
    this._searchService = _searchService;
    this._contextService = _contextService;
    this._editSessionIdentityService = _editSessionIdentityService;
    this._canonicalUriService = _canonicalUriService;
    this._editorService = _editorService;
    this._workspaceEditingService = _workspaceEditingService;
    this._notificationService = _notificationService;
    this._requestService = _requestService;
    this._instantiationService = _instantiationService;
    this._labelService = _labelService;
    this._environmentService = _environmentService;
    this._workspaceTrustManagementService = _workspaceTrustManagementService;
    this._workspaceTrustRequestService = _workspaceTrustRequestService;
    this._toDispose = new DisposableStore();
    this._activeCancelTokens = /* @__PURE__ */ Object.create(null);
    this._queryBuilder = this._instantiationService.createInstance(QueryBuilder);
    this.registeredEditSessionProviders = /* @__PURE__ */ new Map();
    this.registeredCanonicalUriProviders = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostWorkspace);
    const workspace = this._contextService.getWorkspace();
    if (workspace.configuration && !isNative && !fileService.hasProvider(workspace.configuration)) {
      this._proxy.$initializeWorkspace(this.getWorkspaceData(workspace), this.isWorkspaceTrusted());
    } else {
      this._contextService.getCompleteWorkspace().then((workspace2) => this._proxy.$initializeWorkspace(this.getWorkspaceData(workspace2), this.isWorkspaceTrusted()));
    }
    this._contextService.onDidChangeWorkspaceFolders(this._onDidChangeWorkspace, this, this._toDispose);
    this._contextService.onDidChangeWorkbenchState(this._onDidChangeWorkspace, this, this._toDispose);
    this._workspaceTrustManagementService.onDidChangeTrust(this._onDidGrantWorkspaceTrust, this, this._toDispose);
  }
  dispose() {
    this._toDispose.dispose();
    for (const requestId in this._activeCancelTokens) {
      const tokenSource = this._activeCancelTokens[requestId];
      tokenSource.cancel();
    }
  }
  $updateWorkspaceFolders(extensionName, index, deleteCount, foldersToAdd) {
    const workspaceFoldersToAdd = foldersToAdd.map((f) => ({ uri: URI.revive(f.uri), name: f.name }));
    this._notificationService.status(this.getStatusMessage(extensionName, workspaceFoldersToAdd.length, deleteCount), { hideAfter: 10 * 1e3 });
    return this._workspaceEditingService.updateFolders(index, deleteCount, workspaceFoldersToAdd, true);
  }
  getStatusMessage(extensionName, addCount, removeCount) {
    let message;
    const wantsToAdd = addCount > 0;
    const wantsToDelete = removeCount > 0;
    if (wantsToAdd && !wantsToDelete) {
      if (addCount === 1) {
        message = localize(
          "folderStatusMessageAddSingleFolder",
          "Extension '{0}' added 1 folder to the workspace",
          extensionName
        );
      } else {
        message = localize(
          "folderStatusMessageAddMultipleFolders",
          "Extension '{0}' added {1} folders to the workspace",
          extensionName,
          addCount
        );
      }
    } else if (wantsToDelete && !wantsToAdd) {
      if (removeCount === 1) {
        message = localize(
          "folderStatusMessageRemoveSingleFolder",
          "Extension '{0}' removed 1 folder from the workspace",
          extensionName
        );
      } else {
        message = localize(
          "folderStatusMessageRemoveMultipleFolders",
          "Extension '{0}' removed {1} folders from the workspace",
          extensionName,
          removeCount
        );
      }
    } else {
      message = localize(
        "folderStatusChangeFolder",
        "Extension '{0}' changed folders of the workspace",
        extensionName
      );
    }
    return message;
  }
  _onDidChangeWorkspace() {
    this._proxy.$acceptWorkspaceData(this.getWorkspaceData(this._contextService.getWorkspace()));
  }
  getWorkspaceData(workspace) {
    if (this._contextService.getWorkbenchState() === 1) {
      return null;
    }
    return {
      configuration: workspace.configuration || void 0,
      isUntitled: workspace.configuration ? isUntitledWorkspace(workspace.configuration, this._environmentService) : false,
      folders: workspace.folders,
      id: workspace.id,
      name: this._labelService.getWorkspaceLabel(workspace),
      transient: workspace.transient
    };
  }
  $startFileSearch(includePattern, _includeFolder, excludePatternOrDisregardExcludes, maxResults, token) {
    const includeFolder = URI.revive(_includeFolder);
    const workspace = this._contextService.getWorkspace();
    const query = this._queryBuilder.file(includeFolder ? [includeFolder] : workspace.folders, {
      maxResults: maxResults ?? void 0,
      disregardExcludeSettings: excludePatternOrDisregardExcludes === false || void 0,
      disregardSearchExcludeSettings: true,
      disregardIgnoreFiles: true,
      includePattern: includePattern ?? void 0,
      excludePattern: typeof excludePatternOrDisregardExcludes === "string" ? excludePatternOrDisregardExcludes : void 0,
      _reason: "startFileSearch"
    });
    return this._searchService.fileSearch(query, token).then((result) => {
      return result.results.map((m) => m.resource);
    }, (err) => {
      if (!isCancellationError(err)) {
        return Promise.reject(err);
      }
      return null;
    });
  }
  $startTextSearch(pattern, _folder, options, requestId, token) {
    const folder = URI.revive(_folder);
    const workspace = this._contextService.getWorkspace();
    const folders = folder ? [folder] : workspace.folders.map((folder2) => folder2.uri);
    const query = this._queryBuilder.text(pattern, folders, options);
    query._reason = "startTextSearch";
    const onProgress = (p) => {
      if (p.results) {
        this._proxy.$handleTextSearchResult(p, requestId);
      }
    };
    const search = this._searchService.textSearch(query, token, onProgress).then((result) => {
      return { limitHit: result.limitHit };
    }, (err) => {
      if (!isCancellationError(err)) {
        return Promise.reject(err);
      }
      return null;
    });
    return search;
  }
  $checkExists(folders, includes2, token) {
    return this._instantiationService.invokeFunction((accessor) => checkGlobFileExists(accessor, folders, includes2, token));
  }
  async $save(uriComponents, options) {
    const uri = URI.revive(uriComponents);
    const editors = [...this._editorService.findEditors(uri, { supportSideBySide: SideBySideEditor.PRIMARY })];
    const result = await this._editorService.save(editors, {
      reason: 1,
      saveAs: options.saveAs,
      force: !options.saveAs
    });
    return firstOrDefault(this._saveResultToUris(result));
  }
  _saveResultToUris(result) {
    if (!result.success) {
      return [];
    }
    return coalesce(result.editors.map(
      (editor) => EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY })
    ));
  }
  $saveAll(includeUntitled) {
    return this._editorService.saveAll({ includeUntitled }).then((res) => res.success);
  }
  $resolveProxy(url) {
    return this._requestService.resolveProxy(url);
  }
  $requestWorkspaceTrust(options) {
    return this._workspaceTrustRequestService.requestWorkspaceTrust(options);
  }
  isWorkspaceTrusted() {
    return this._workspaceTrustManagementService.isWorkspaceTrusted();
  }
  _onDidGrantWorkspaceTrust() {
    this._proxy.$onDidGrantWorkspaceTrust();
  }
  $registerEditSessionIdentityProvider(handle, scheme) {
    const disposable = this._editSessionIdentityService.registerEditSessionIdentityProvider({
      scheme,
      getEditSessionIdentifier: async (workspaceFolder, token) => {
        return this._proxy.$getEditSessionIdentifier(workspaceFolder.uri, token);
      },
      provideEditSessionIdentityMatch: async (workspaceFolder, identity1, identity2, token) => {
        return this._proxy.$provideEditSessionIdentityMatch(workspaceFolder.uri, identity1, identity2, token);
      }
    });
    this.registeredEditSessionProviders.set(handle, disposable);
    this._toDispose.add(disposable);
  }
  $unregisterEditSessionIdentityProvider(handle) {
    const disposable = this.registeredEditSessionProviders.get(handle);
    disposable == null ? void 0 : disposable.dispose();
    this.registeredEditSessionProviders.delete(handle);
  }
  $registerCanonicalUriProvider(handle, scheme) {
    const disposable = this._canonicalUriService.registerCanonicalUriProvider({
      scheme,
      provideCanonicalUri: async (uri, targetScheme, token) => {
        const result = await this._proxy.$provideCanonicalUri(uri, targetScheme, token);
        if (result) {
          return URI.revive(result);
        }
        return result;
      }
    });
    this.registeredCanonicalUriProviders.set(handle, disposable);
    this._toDispose.add(disposable);
  }
  $unregisterCanonicalUriProvider(handle) {
    const disposable = this.registeredCanonicalUriProviders.get(handle);
    disposable == null ? void 0 : disposable.dispose();
    this.registeredCanonicalUriProviders.delete(handle);
  }
};
MainThreadWorkspace = __decorate([
  extHostNamedCustomer(MainContext.MainThreadWorkspace),
  __param(1, ISearchService),
  __param(2, IWorkspaceContextService),
  __param(3, IEditSessionIdentityService),
  __param(4, ICanonicalUriService),
  __param(5, IEditorService),
  __param(6, IWorkspaceEditingService),
  __param(7, INotificationService),
  __param(8, IRequestService),
  __param(9, IInstantiationService),
  __param(10, ILabelService),
  __param(11, IEnvironmentService),
  __param(12, IFileService),
  __param(13, IWorkspaceTrustManagementService),
  __param(14, IWorkspaceTrustRequestService)
], MainThreadWorkspace);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadComments.js
init_tslib_es6();
init_event();
init_lifecycle();
init_uri();
init_uuid();
init_range();
init_platform2();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsView.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/media/panel.css.js
var css = ".comments-panel .comments-panel-container{height:100%}.comments-panel .comments-panel-container .hidden{display:none}.comments-panel .comments-panel-container .tree-container{height:100%}.comments-panel .comments-panel-container .tree-container.hidden{display:none;visibility:hidden}.comments-panel .comments-panel-container .tree-container .comment-thread-container{display:block}.comments-panel .comments-panel-container .tree-container .comment-thread-container div{overflow:hidden}.comments-panel .comments-panel-container .tree-container .comment-thread-container .comment-metadata-container,.comments-panel .comments-panel-container .tree-container .comment-thread-container .comment-snippet-container,.comments-panel .comments-panel-container .tree-container .resource-container{display:flex;overflow:hidden;text-overflow:ellipsis}.comments-panel .count,.comments-panel .user{padding-right:5px}.comments-panel .comments-panel-container .tree-container .comment-thread-container .icon{min-width:fit-content;padding-right:5px;padding-top:4px}.comments-panel .comments-panel-container .tree-container .comment-thread-container .comment-metadata-container .user,.comments-panel .comments-panel-container .tree-container .comment-thread-container .comment-snippet-container .count{min-width:fit-content}.comments-panel .comments-panel-container .tree-container .comment-thread-container .comment-snippet-container .text{display:flex;flex:1;min-width:0}.comments-panel .comments-panel-container .tree-container .comment-thread-container .reply-detail,.comments-panel .comments-panel-container .tree-container .comment-thread-container .timestamp{display:block;font-size:.9em;opacity:.8;overflow:hidden;padding-right:5px;text-overflow:ellipsis}.comments-panel .comments-panel-container .tree-container .comment-thread-container .text *{margin:0;max-width:500px;overflow:hidden;padding-right:5px;text-overflow:ellipsis}.comments-panel .comments-panel-container .tree-container .comment-thread-container .range{opacity:.8}.comments-panel .comments-panel-container .tree-container .comment-thread-container .comment-snippet-container .text code{font-family:var(--monaco-monospace-font)}.comments-panel .comments-panel-container .tree-container .comment-thread-container .separator{opacity:.8;padding-right:5px}.comments-panel .comments-panel-container .message-box-container{height:inherit;line-height:22px;padding-left:20px}.comments-panel .comments-panel-container .tree-container .count-badge-wrapper{margin-left:10px}.comments-panel .comments-panel-container .tree-container .comment-thread-container .comment-metadata-container,.comments-panel .comments-panel-container .tree-container .comment-thread-container .comment-snippet-container{line-height:22px;margin-right:5px}.comments-panel .comments-panel-container .tree-container .comment-thread-container .comment-snippet-container{padding-left:16px}.comments-panel .hide{display:none}";
n(css, {});

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsView.js
init_nls();
init_dom();
init_resources();
init_editorBrowser();
init_instantiation();
init_themeService();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/common/commentModel.js
init_uri();
init_arrays();
init_nls();
var CommentNode = class {
  constructor(owner, threadId, resource, comment, range, threadState) {
    this.replies = [];
    this.owner = owner;
    this.threadId = threadId;
    this.comment = comment;
    this.resource = resource;
    this.range = range;
    this.isRoot = false;
    this.threadState = threadState;
  }
  hasReply() {
    return this.replies && this.replies.length !== 0;
  }
};
var ResourceWithCommentThreads = class _ResourceWithCommentThreads {
  constructor(owner, resource, commentThreads) {
    this.owner = owner;
    this.id = resource.toString();
    this.resource = resource;
    this.commentThreads = commentThreads.filter((thread) => thread.comments && thread.comments.length).map(
      (thread) => _ResourceWithCommentThreads.createCommentNode(owner, resource, thread)
    );
  }
  static createCommentNode(owner, resource, commentThread) {
    const { threadId, comments, range } = commentThread;
    const commentNodes = comments.map((comment) => new CommentNode(owner, threadId, resource, comment, range, commentThread.state));
    if (commentNodes.length > 1) {
      commentNodes[0].replies = commentNodes.slice(1, commentNodes.length);
    }
    commentNodes[0].isRoot = true;
    return commentNodes[0];
  }
};
var CommentsModel = class _CommentsModel {
  constructor() {
    this.resourceCommentThreads = [];
    this.commentThreadsMap = /* @__PURE__ */ new Map();
  }
  updateResourceCommentThreads() {
    this.resourceCommentThreads = [...this.commentThreadsMap.values()].flat();
    this.resourceCommentThreads.sort((a, b) => {
      return a.resource.toString() > b.resource.toString() ? 1 : -1;
    });
  }
  setCommentThreads(owner, commentThreads) {
    this.commentThreadsMap.set(owner, this.groupByResource(owner, commentThreads));
    this.updateResourceCommentThreads();
  }
  deleteCommentsByOwner(owner) {
    if (owner) {
      this.commentThreadsMap.set(owner, []);
    } else {
      this.commentThreadsMap.clear();
    }
    this.updateResourceCommentThreads();
  }
  updateCommentThreads(event) {
    const { owner, removed, changed, added } = event;
    const threadsForOwner = this.commentThreadsMap.get(owner) || [];
    removed.forEach((thread) => {
      const matchingResourceIndex = threadsForOwner.findIndex((resourceData) => resourceData.id === thread.resource);
      const matchingResourceData = matchingResourceIndex >= 0 ? threadsForOwner[matchingResourceIndex] : void 0;
      const index = (matchingResourceData == null ? void 0 : matchingResourceData.commentThreads.findIndex((commentThread) => commentThread.threadId === thread.threadId)) ?? 0;
      if (index >= 0) {
        matchingResourceData == null ? void 0 : matchingResourceData.commentThreads.splice(index, 1);
      }
      if ((matchingResourceData == null ? void 0 : matchingResourceData.commentThreads.length) === 0) {
        threadsForOwner.splice(matchingResourceIndex, 1);
      }
    });
    changed.forEach((thread) => {
      const matchingResourceIndex = threadsForOwner.findIndex((resourceData) => resourceData.id === thread.resource);
      const matchingResourceData = threadsForOwner[matchingResourceIndex];
      const index = matchingResourceData.commentThreads.findIndex((commentThread) => commentThread.threadId === thread.threadId);
      if (index >= 0) {
        matchingResourceData.commentThreads[index] = ResourceWithCommentThreads.createCommentNode(owner, URI.parse(matchingResourceData.id), thread);
      } else if (thread.comments && thread.comments.length) {
        matchingResourceData.commentThreads.push(ResourceWithCommentThreads.createCommentNode(owner, URI.parse(matchingResourceData.id), thread));
      }
    });
    added.forEach((thread) => {
      const existingResource = threadsForOwner.filter((resourceWithThreads) => resourceWithThreads.resource.toString() === thread.resource);
      if (existingResource.length) {
        const resource = existingResource[0];
        if (thread.comments && thread.comments.length) {
          resource.commentThreads.push(ResourceWithCommentThreads.createCommentNode(owner, resource.resource, thread));
        }
      } else {
        threadsForOwner.push(new ResourceWithCommentThreads(owner, URI.parse(thread.resource), [thread]));
      }
    });
    this.commentThreadsMap.set(owner, threadsForOwner);
    this.updateResourceCommentThreads();
    return removed.length > 0 || changed.length > 0 || added.length > 0;
  }
  hasCommentThreads() {
    return !!this.resourceCommentThreads.length;
  }
  getMessage() {
    if (!this.resourceCommentThreads.length) {
      return localize("noComments", "There are no comments in this workspace yet.");
    } else {
      return "";
    }
  }
  groupByResource(owner, commentThreads) {
    const resourceCommentThreads = [];
    const commentThreadsByResource = /* @__PURE__ */ new Map();
    for (const group of groupBy(commentThreads, _CommentsModel._compareURIs)) {
      commentThreadsByResource.set(group[0].resource, new ResourceWithCommentThreads(owner, URI.parse(group[0].resource), group));
    }
    commentThreadsByResource.forEach((v, i, m) => {
      resourceCommentThreads.push(v);
    });
    return resourceCommentThreads;
  }
  static _compareURIs(a, b) {
    const resourceA = a.resource.toString();
    const resourceB = b.resource.toString();
    if (resourceA < resourceB) {
      return -1;
    } else if (resourceA > resourceB) {
      return 1;
    } else {
      return 0;
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsView.js
init_commands();
init_colorRegistry();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsTreeViewer.js
init_tslib_es6();
init_dom();
init_nls();
init_lifecycle();
init_opener();
init_configuration();
init_contextkey();
init_themeService();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/timestamp.js
init_dom();
init_lifecycle();
init_platform();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/common/commentsConfiguration.js
var COMMENTS_SECTION = "comments";

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/timestamp.js
var TimestampWidget = class extends Disposable {
  constructor(configurationService, container, timeStamp) {
    super();
    this.configurationService = configurationService;
    this._date = append(container, $("span.timestamp"));
    this._date.style.display = "none";
    this._useRelativeTime = this.useRelativeTimeSetting;
    this.setTimestamp(timeStamp);
  }
  get useRelativeTimeSetting() {
    return this.configurationService.getValue(COMMENTS_SECTION).useRelativeTime;
  }
  async setTimestamp(timestamp) {
    if (timestamp !== this._timestamp || this.useRelativeTimeSetting !== this._useRelativeTime) {
      this.updateDate(timestamp);
    }
    this._timestamp = timestamp;
    this._useRelativeTime = this.useRelativeTimeSetting;
  }
  updateDate(timestamp) {
    if (!timestamp) {
      this._date.textContent = "";
      this._date.style.display = "none";
    } else if (timestamp !== this._timestamp || this.useRelativeTimeSetting !== this._useRelativeTime) {
      this._date.style.display = "";
      let textContent;
      let tooltip;
      if (this.useRelativeTimeSetting) {
        textContent = this.getRelative(timestamp);
        tooltip = this.getDateString(timestamp);
      } else {
        textContent = this.getDateString(timestamp);
      }
      this._date.textContent = textContent;
      if (tooltip) {
        this._date.title = tooltip;
      }
    }
  }
  getRelative(date) {
    return fromNow(date, true, true);
  }
  getDateString(date) {
    return date.toLocaleString(language);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsTreeViewer.js
init_codicons();
init_themables();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentColors.js
init_languages();
init_nls();
init_colorRegistry();
var resolvedCommentViewIcon = registerColor("commentsView.resolvedIcon", { dark: disabledForeground, light: disabledForeground, hcDark: contrastBorder, hcLight: contrastBorder }, localize("resolvedCommentIcon", "Icon color for resolved comments."));
var unresolvedCommentViewIcon = registerColor("commentsView.unresolvedIcon", { dark: listFocusOutline, light: listFocusOutline, hcDark: contrastBorder, hcLight: contrastBorder }, localize("unresolvedCommentIcon", "Icon color for unresolved comments."));
var resolvedCommentBorder = registerColor("editorCommentsWidget.resolvedBorder", { dark: resolvedCommentViewIcon, light: resolvedCommentViewIcon, hcDark: contrastBorder, hcLight: contrastBorder }, localize(
  "resolvedCommentBorder",
  "Color of borders and arrow for resolved comments."
));
var unresolvedCommentBorder = registerColor("editorCommentsWidget.unresolvedBorder", { dark: unresolvedCommentViewIcon, light: unresolvedCommentViewIcon, hcDark: contrastBorder, hcLight: contrastBorder }, localize(
  "unresolvedCommentBorder",
  "Color of borders and arrow for unresolved comments."
));
registerColor("editorCommentsWidget.rangeBackground", { dark: transparent(unresolvedCommentBorder, 0.1), light: transparent(unresolvedCommentBorder, 0.1), hcDark: transparent(unresolvedCommentBorder, 0.1), hcLight: transparent(unresolvedCommentBorder, 0.1) }, localize("commentThreadRangeBackground", "Color of background for comment ranges."));
registerColor("editorCommentsWidget.rangeActiveBackground", { dark: transparent(unresolvedCommentBorder, 0.1), light: transparent(unresolvedCommentBorder, 0.1), hcDark: transparent(unresolvedCommentBorder, 0.1), hcLight: transparent(unresolvedCommentBorder, 0.1) }, localize(
  "commentThreadActiveRangeBackground",
  "Color of background for currently selected or hovered comment range."
));
var commentThreadStateBorderColors = /* @__PURE__ */ new Map([
  [CommentThreadState.Unresolved, unresolvedCommentBorder],
  [CommentThreadState.Resolved, resolvedCommentBorder]
]);
var commentThreadStateIconColors = /* @__PURE__ */ new Map([
  [CommentThreadState.Unresolved, unresolvedCommentViewIcon],
  [CommentThreadState.Resolved, resolvedCommentViewIcon]
]);
var commentThreadStateColorVar = "--comment-thread-state-color";
var commentViewThreadStateColorVar = "--comment-view-thread-state-color";
var commentThreadStateBackgroundColorVar = "--comment-thread-state-background-color";
function getCommentThreadStateColor(state, theme, map) {
  const colorId = state !== void 0 ? map.get(state) : void 0;
  return colorId !== void 0 ? theme.getColor(colorId) : void 0;
}
function getCommentThreadStateBorderColor(state, theme) {
  return getCommentThreadStateColor(state, theme, commentThreadStateBorderColors);
}
function getCommentThreadStateIconColor(state, theme) {
  return getCommentThreadStateColor(state, theme, commentThreadStateIconColors);
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsTreeViewer.js
init_languages();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsFilterOptions.js
init_filters();
init_strings();
var _FilterOptions = class _FilterOptions {
  constructor(filter2, showResolved, showUnresolved) {
    this.filter = filter2;
    this.showResolved = true;
    this.showUnresolved = true;
    filter2 = filter2.trim();
    this.showResolved = showResolved;
    this.showUnresolved = showUnresolved;
    const negate = filter2.startsWith("!");
    this.textFilter = { text: (negate ? ltrim(filter2, "!") : filter2).trim(), negate };
  }
};
_FilterOptions._filter = matchesFuzzy2;
_FilterOptions._messageFilter = matchesFuzzy;
var FilterOptions = _FilterOptions;

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsTreeViewer.js
init_resources();
var COMMENTS_VIEW_ID = "workbench.panel.comments";
var COMMENTS_VIEW_STORAGE_ID = "Comments";
var COMMENTS_VIEW_TITLE = localize("comments.view.title", "Comments");
var _CommentsModelVirualDelegate = class _CommentsModelVirualDelegate {
  getHeight(element) {
    if (element instanceof CommentNode && element.hasReply()) {
      return 44;
    }
    return 22;
  }
  getTemplateId(element) {
    if (element instanceof ResourceWithCommentThreads) {
      return _CommentsModelVirualDelegate.RESOURCE_ID;
    }
    if (element instanceof CommentNode) {
      return _CommentsModelVirualDelegate.COMMENT_ID;
    }
    return "";
  }
};
_CommentsModelVirualDelegate.RESOURCE_ID = "resource-with-comments";
_CommentsModelVirualDelegate.COMMENT_ID = "comment-node";
var CommentsModelVirualDelegate = _CommentsModelVirualDelegate;
var ResourceWithCommentsRenderer = class {
  constructor(labels) {
    this.labels = labels;
    this.templateId = "resource-with-comments";
  }
  renderTemplate(container) {
    const labelContainer = append(container, $(".resource-container"));
    const resourceLabel = this.labels.create(labelContainer);
    return { resourceLabel };
  }
  renderElement(node, index, templateData, height) {
    templateData.resourceLabel.setFile(node.element.resource);
  }
  disposeTemplate(templateData) {
    templateData.resourceLabel.dispose();
  }
};
var CommentNodeRenderer = class CommentNodeRenderer2 {
  constructor(openerService, configurationService, themeService) {
    this.openerService = openerService;
    this.configurationService = configurationService;
    this.themeService = themeService;
    this.templateId = "comment-node";
  }
  renderTemplate(container) {
    const threadContainer = append(container, $(".comment-thread-container"));
    const metadataContainer = append(threadContainer, $(".comment-metadata-container"));
    const threadMetadata = {
      icon: append(metadataContainer, $(".icon")),
      userNames: append(metadataContainer, $(".user")),
      timestamp: new TimestampWidget(
        this.configurationService,
        append(metadataContainer, $(".timestamp-container"))
      ),
      separator: append(metadataContainer, $(".separator")),
      commentPreview: append(metadataContainer, $(".text")),
      range: append(metadataContainer, $(".range"))
    };
    threadMetadata.separator.innerText = "·";
    const snippetContainer = append(threadContainer, $(".comment-snippet-container"));
    const repliesMetadata = {
      container: snippetContainer,
      icon: append(snippetContainer, $(".icon")),
      count: append(snippetContainer, $(".count")),
      lastReplyDetail: append(snippetContainer, $(".reply-detail")),
      separator: append(snippetContainer, $(".separator")),
      timestamp: new TimestampWidget(
        this.configurationService,
        append(snippetContainer, $(".timestamp-container"))
      )
    };
    repliesMetadata.separator.innerText = "·";
    repliesMetadata.icon.classList.add(...ThemeIcon.asClassNameArray(Codicon.indent));
    const disposables = [threadMetadata.timestamp, repliesMetadata.timestamp];
    return { threadMetadata, repliesMetadata, disposables };
  }
  getCountString(commentCount) {
    if (commentCount > 1) {
      return localize("commentsCount", "{0} comments", commentCount);
    } else {
      return localize("commentCount", "1 comment");
    }
  }
  getRenderedComment(commentBody, disposables) {
    const renderedComment = renderMarkdown(commentBody, {
      inline: true,
      actionHandler: {
        callback: (link) => openLinkFromMarkdown(this.openerService, link, commentBody.isTrusted),
        disposables
      }
    });
    const images = renderedComment.element.getElementsByTagName("img");
    for (let i = 0; i < images.length; i++) {
      const image = images[i];
      const textDescription = $("");
      textDescription.textContent = image.alt ? localize("imageWithLabel", "Image: {0}", image.alt) : localize("image", "Image");
      image.parentNode.replaceChild(textDescription, image);
    }
    return renderedComment;
  }
  getIcon(threadState) {
    if (threadState === CommentThreadState.Unresolved) {
      return Codicon.commentUnresolved;
    } else {
      return Codicon.comment;
    }
  }
  renderElement(node, index, templateData, height) {
    const commentCount = node.element.replies.length + 1;
    templateData.threadMetadata.icon.classList.remove(...Array.from(templateData.threadMetadata.icon.classList.values()).filter((value) => value.startsWith("codicon")));
    templateData.threadMetadata.icon.classList.add(...ThemeIcon.asClassNameArray(this.getIcon(node.element.threadState)));
    if (node.element.threadState !== void 0) {
      const color2 = this.getCommentThreadWidgetStateColor(node.element.threadState, this.themeService.getColorTheme());
      templateData.threadMetadata.icon.style.setProperty(commentViewThreadStateColorVar, `${color2}`);
      templateData.threadMetadata.icon.style.color = `var(${commentViewThreadStateColorVar})`;
    }
    templateData.threadMetadata.userNames.textContent = node.element.comment.userName;
    templateData.threadMetadata.timestamp.setTimestamp(node.element.comment.timestamp ? new Date(node.element.comment.timestamp) : void 0);
    const originalComment = node.element;
    templateData.threadMetadata.commentPreview.innerText = "";
    templateData.threadMetadata.commentPreview.style.height = "22px";
    if (typeof originalComment.comment.body === "string") {
      templateData.threadMetadata.commentPreview.innerText = originalComment.comment.body;
    } else {
      const disposables = new DisposableStore();
      templateData.disposables.push(disposables);
      const renderedComment = this.getRenderedComment(originalComment.comment.body, disposables);
      templateData.disposables.push(renderedComment);
      templateData.threadMetadata.commentPreview.appendChild(renderedComment.element.firstElementChild ?? renderedComment.element);
      templateData.threadMetadata.commentPreview.title = renderedComment.element.textContent ?? "";
    }
    if (node.element.range) {
      if (node.element.range.startLineNumber === node.element.range.endLineNumber) {
        templateData.threadMetadata.range.textContent = localize("commentLine", "[Ln {0}]", node.element.range.startLineNumber);
      } else {
        templateData.threadMetadata.range.textContent = localize(
          "commentRange",
          "[Ln {0}-{1}]",
          node.element.range.startLineNumber,
          node.element.range.endLineNumber
        );
      }
    }
    if (!node.element.hasReply()) {
      templateData.repliesMetadata.container.style.display = "none";
      return;
    }
    templateData.repliesMetadata.container.style.display = "";
    templateData.repliesMetadata.count.textContent = this.getCountString(commentCount);
    const lastComment = node.element.replies[node.element.replies.length - 1].comment;
    templateData.repliesMetadata.lastReplyDetail.textContent = localize("lastReplyFrom", "Last reply from {0}", lastComment.userName);
    templateData.repliesMetadata.timestamp.setTimestamp(lastComment.timestamp ? new Date(lastComment.timestamp) : void 0);
  }
  getCommentThreadWidgetStateColor(state, theme) {
    return state !== void 0 ? getCommentThreadStateIconColor(state, theme) : void 0;
  }
  disposeTemplate(templateData) {
    templateData.disposables.forEach((disposeable) => disposeable.dispose());
  }
};
CommentNodeRenderer = __decorate([
  __param(0, IOpenerService),
  __param(1, IConfigurationService),
  __param(2, IThemeService)
], CommentNodeRenderer);
var Filter = class {
  constructor(options) {
    this.options = options;
  }
  filter(element, parentVisibility) {
    if (this.options.filter === "" && this.options.showResolved && this.options.showUnresolved) {
      return 1;
    }
    if (element instanceof ResourceWithCommentThreads) {
      return this.filterResourceMarkers(element);
    } else {
      return this.filterCommentNode(element, parentVisibility);
    }
  }
  filterResourceMarkers(resourceMarkers) {
    if (this.options.textFilter.text && !this.options.textFilter.negate) {
      const uriMatches = FilterOptions._filter(this.options.textFilter.text, basename2(resourceMarkers.resource));
      if (uriMatches) {
        return { visibility: true, data: { type: 0, uriMatches: uriMatches || [] } };
      }
    }
    return 2;
  }
  filterCommentNode(comment, parentVisibility) {
    const matchesResolvedState = comment.threadState === void 0 || this.options.showResolved && CommentThreadState.Resolved === comment.threadState || this.options.showUnresolved && CommentThreadState.Unresolved === comment.threadState;
    if (!matchesResolvedState) {
      return false;
    }
    if (!this.options.textFilter.text) {
      return true;
    }
    const textMatches = FilterOptions._messageFilter(this.options.textFilter.text, typeof comment.comment.body === "string" ? comment.comment.body : comment.comment.body.value) || FilterOptions._messageFilter(this.options.textFilter.text, comment.comment.userName) || comment.replies.map((reply) => {
      return FilterOptions._messageFilter(this.options.textFilter.text, reply.comment.userName) || FilterOptions._messageFilter(this.options.textFilter.text, typeof reply.comment.body === "string" ? reply.comment.body : reply.comment.body.value);
    }).filter((value) => !!value).flat();
    if (textMatches.length && !this.options.textFilter.negate) {
      return { visibility: true, data: { type: 1, textMatches } };
    }
    if (textMatches.length && this.options.textFilter.negate && parentVisibility === 2) {
      return false;
    }
    if (textMatches.length === 0 && this.options.textFilter.negate && parentVisibility === 2) {
      return true;
    }
    return parentVisibility;
  }
};
var CommentsList = class CommentsList2 extends WorkbenchObjectTree {
  constructor(labels, container, options, contextKeyService, listService, themeService, instantiationService, configurationService) {
    const delegate = new CommentsModelVirualDelegate();
    const renderers = [
      instantiationService.createInstance(ResourceWithCommentsRenderer, labels),
      instantiationService.createInstance(CommentNodeRenderer)
    ];
    super("CommentsTree", container, delegate, renderers, {
      accessibilityProvider: options.accessibilityProvider,
      identityProvider: {
        getId: (element) => {
          if (element instanceof CommentsModel) {
            return "root";
          }
          if (element instanceof ResourceWithCommentThreads) {
            return `${element.owner}-${element.id}`;
          }
          if (element instanceof CommentNode) {
            return `${element.owner}-${element.resource.toString()}-${element.threadId}-${element.comment.uniqueIdInThread}` + (element.isRoot ? "-root" : "");
          }
          return "";
        }
      },
      expandOnlyOnTwistieClick: (element) => {
        if (element instanceof CommentsModel || element instanceof ResourceWithCommentThreads) {
          return false;
        }
        return true;
      },
      collapseByDefault: false,
      overrideStyles: options.overrideStyles,
      filter: options.filter,
      findWidgetEnabled: false
    }, instantiationService, contextKeyService, listService, configurationService);
  }
  filterComments() {
    this.refilter();
  }
  getVisibleItemCount() {
    let filtered = 0;
    const root = this.getNode();
    for (const resourceNode of root.children) {
      for (const commentNode of resourceNode.children) {
        if (commentNode.visible && resourceNode.visible) {
          filtered++;
        }
      }
    }
    return filtered;
  }
};
CommentsList = __decorate([
  __param(3, IContextKeyService),
  __param(4, IListService),
  __param(5, IThemeService),
  __param(6, IInstantiationService),
  __param(7, IConfigurationService)
], CommentsList);

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsView.js
init_configuration();
init_contextkey();
init_opener();
init_telemetry();
init_actions2();
init_codicons();
init_textModel();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/comments.js
init_contextkey();
var CommentsViewFilterFocusContextKey = new RawContextKey("commentsFilterFocus", false);

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsViewActions.js
init_lifecycle();
init_nls();
init_contextkey();
init_event();
init_actions2();
var CONTEXT_KEY_SHOW_RESOLVED = new RawContextKey("commentsView.showResolvedFilter", true);
var CONTEXT_KEY_SHOW_UNRESOLVED = new RawContextKey("commentsView.showUnResolvedFilter", true);
var CommentsFilters = class extends Disposable {
  constructor(options, contextKeyService) {
    super();
    this.contextKeyService = contextKeyService;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._showUnresolved = CONTEXT_KEY_SHOW_UNRESOLVED.bindTo(this.contextKeyService);
    this._showResolved = CONTEXT_KEY_SHOW_RESOLVED.bindTo(this.contextKeyService);
    this._showResolved.set(options.showResolved);
    this._showUnresolved.set(options.showUnresolved);
  }
  get showUnresolved() {
    return !!this._showUnresolved.get();
  }
  set showUnresolved(showUnresolved) {
    if (this._showUnresolved.get() !== showUnresolved) {
      this._showUnresolved.set(showUnresolved);
      this._onDidChange.fire({ showUnresolved: true });
    }
  }
  get showResolved() {
    return !!this._showResolved.get();
  }
  set showResolved(showResolved) {
    if (this._showResolved.get() !== showResolved) {
      this._showResolved.set(showResolved);
      this._onDidChange.fire({ showResolved: true });
    }
  }
};
registerAction2(class extends ViewAction {
  constructor() {
    super({
      id: "commentsFocusViewFromFilter",
      title: localize("focusCommentsList", "Focus Comments view"),
      keybinding: {
        when: CommentsViewFilterFocusContextKey,
        weight: 200,
        primary: 2048 | 18
      },
      viewId: COMMENTS_VIEW_ID
    });
  }
  async runInView(serviceAccessor, commentsView) {
    commentsView.focus();
  }
});
registerAction2(class extends ViewAction {
  constructor() {
    super({
      id: "commentsClearFilterText",
      title: localize("commentsClearFilterText", "Clear filter text"),
      keybinding: {
        when: CommentsViewFilterFocusContextKey,
        weight: 200,
        primary: 9
      },
      viewId: COMMENTS_VIEW_ID
    });
  }
  async runInView(serviceAccessor, commentsView) {
    commentsView.clearFilterText();
  }
});
registerAction2(class extends ViewAction {
  constructor() {
    super({
      id: "commentsFocusFilter",
      title: localize("focusCommentsFilter", "Focus comments filter"),
      keybinding: {
        when: FocusedViewContext.isEqualTo(COMMENTS_VIEW_ID),
        weight: 200,
        primary: 2048 | 36
      },
      viewId: COMMENTS_VIEW_ID
    });
  }
  async runInView(serviceAccessor, commentsView) {
    commentsView.focusFilter();
  }
});
registerAction2(class extends ViewAction {
  constructor() {
    super({
      id: `workbench.actions.${COMMENTS_VIEW_ID}.toggleUnResolvedComments`,
      title: localize("toggle unresolved", "Toggle Unresolved Comments"),
      category: localize("comments", "Comments"),
      toggled: {
        condition: CONTEXT_KEY_SHOW_UNRESOLVED,
        title: localize("unresolved", "Show Unresolved")
      },
      menu: {
        id: viewFilterSubmenu,
        group: "1_filter",
        when: ContextKeyExpr.equals("view", COMMENTS_VIEW_ID),
        order: 1
      },
      viewId: COMMENTS_VIEW_ID
    });
  }
  async runInView(serviceAccessor, view) {
    view.filters.showUnresolved = !view.filters.showUnresolved;
  }
});
registerAction2(class extends ViewAction {
  constructor() {
    super({
      id: `workbench.actions.${COMMENTS_VIEW_ID}.toggleResolvedComments`,
      title: localize("toggle resolved", "Toggle Resolved Comments"),
      category: localize("comments", "Comments"),
      toggled: {
        condition: CONTEXT_KEY_SHOW_RESOLVED,
        title: localize("resolved", "Show Resolved")
      },
      menu: {
        id: viewFilterSubmenu,
        group: "1_filter",
        when: ContextKeyExpr.equals("view", COMMENTS_VIEW_ID),
        order: 1
      },
      viewId: COMMENTS_VIEW_ID
    });
  }
  async runInView(serviceAccessor, view) {
    view.filters.showResolved = !view.filters.showResolved;
  }
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsView.js
init_languages();
init_lifecycle();
init_iterator();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsController.js
init_tslib_es6();
init_actions();
init_arrays();
init_async();
init_errors();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/media/review.css.js
var css2 = '.review-widget{position:absolute;width:100%}.monaco-editor .review-widget{background-color:var(--vscode-peekViewResult-background)}.review-widget .hidden{display:none!important}.review-widget .body{overflow:hidden}.review-widget .body .review-comment{display:flex;padding:8px 16px 8px 20px}@keyframes monaco-review-widget-focus{0%{background:var(--vscode-peekViewResult-selectionBackground)}to{background:transparent}}.review-widget .body .review-comment.focus{animation:monaco-review-widget-focus 3s ease 0s}.review-widget .body .review-comment .comment-actions{margin-left:auto}.review-widget .body .review-comment .comment-actions .monaco-toolbar{height:22px}.review-widget .body .review-comment .comment-title .comment-header-info{overflow:hidden;text-overflow:ellipsis}.review-widget .body .review-comment .comment-title{display:flex;width:100%}.review-widget .body .review-comment .comment-title .action-label.codicon{line-height:18px}.review-widget .body .review-comment .comment-title .monaco-dropdown .toolbar-toggle-more{height:18px;line-height:18px;vertical-align:middle;width:16px}.review-widget .body .comment-body blockquote{border-left-style:solid;border-left-width:5px;margin:0 7px 0 5px;padding:0 16px 0 10px}.review-widget .body .review-comment .avatar-container{margin-top:4px!important}.review-widget .body .review-comment .avatar-container img.avatar{border-radius:3px;border-style:none;display:inline-block;height:28px;line-height:1;overflow:hidden;vertical-align:middle;width:28px}.review-widget .body .comment-reactions .monaco-text-button{background-color:transparent;border:1px solid grey;border-radius:3px;margin:0 7px 0 0;width:30px}.review-widget .body .review-comment .review-comment-contents{overflow:hidden;padding-left:20px;user-select:text;-webkit-user-select:text;width:100%}.review-widget .body pre{word-wrap:normal;overflow:auto;white-space:pre}.review-widget .body .review-comment .review-comment-contents .author{line-height:22px}.review-widget .body .review-comment .review-comment-contents .isPending{font-style:italic;line-height:22px;margin:0 5px;padding:0 2px}.review-widget .body .review-comment .review-comment-contents .timestamp{line-height:22px;margin:0 5px;padding:0 2px}.review-widget .body .review-comment .review-comment-contents .comment-body .comment-body-plainstring{white-space:pre-wrap}.review-widget .body .review-comment .review-comment-contents .comment-body{padding-top:4px}.review-widget .body .review-comment .review-comment-contents .comment-body-max-height{max-height:20em}.review-widget .body .review-comment .review-comment-contents .comment-reactions{margin-top:8px;min-height:25px}.review-widget .body .review-comment .review-comment-contents .comment-reactions .action-item .action-label{display:flex;font-size:12px;padding:1px 4px;text-align:center;white-space:pre}.review-widget .body .review-comment .review-comment-contents .comment-reactions .action-item .action-label .reaction-icon{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-position:0;background-repeat:no-repeat;background-size:14px;display:inline-block;margin-right:4px;width:14px}.review-widget .body .review-comment .review-comment-contents .comment-reactions .action-item .action-label .reaction-label{line-height:20px;margin-right:4px}.review-widget .body .review-comment .review-comment-contents .comment-reactions .action-item a.action-label.toolbar-toggle-pickReactions{background-position:50%;background-repeat:no-repeat;background-size:16px;border:none;display:none;font-size:16px;height:16px;margin-top:3px;width:26px}.review-widget .body .review-comment .review-comment-contents .comment-reactions:hover .action-item a.action-label.toolbar-toggle-pickReactions{background-size:16px;display:inline-block}.review-widget .body .review-comment .comment-title .action-label{background-position:50%;background-repeat:no-repeat;background-size:16px;display:block;height:16px;line-height:16px}.review-widget .body .review-comment .review-comment-contents .comment-reactions .action-item a.action-label{border:1px solid}.review-widget .body .review-comment .review-comment-contents .comment-reactions .action-item a.action-label.disabled{opacity:.6}.review-widget .body .review-comment .review-comment-contents .comment-reactions .action-item a.action-label.active:hover{background-color:var(--vscode-statusBarItem-hoverBackground)}.review-widget .body .review-comment .review-comment-contents .comment-reactions .action-item a.action-label:active{background-color:var(--vscode-statusBarItem-activeBackground);border:1px solid transparent}.review-widget .body .review-comment .review-comment-contents a{cursor:pointer}.review-widget .body .comment-body p,.review-widget .body .comment-body ul{margin:8px 0}.review-widget .body .comment-body p:first-child,.review-widget .body .comment-body ul:first-child{margin-top:0}.review-widget .body .comment-body p:last-child,.review-widget .body.comment-body ul:last-child{margin-bottom:0}.review-widget .body .comment-body ul{padding-left:20px}.review-widget .body .comment-body li>p{margin-bottom:0}.review-widget .body .comment-body li>ul{margin-top:0}.review-widget .body .comment-body code{border-radius:3px;padding:0 .4em}.review-widget .body .comment-body span{white-space:pre}.review-widget .body .comment-body img{max-width:100%}.review-widget .body .comment-form{margin:8px 20px}.review-widget .validation-error{word-wrap:break-word;box-sizing:border-box;display:inline-block;font-size:12px;line-height:17px;margin-left:-1px;margin-top:-1px;min-height:34px;overflow:hidden;padding:.4em;text-align:left;width:100%}.review-widget .body .comment-additional-actions{margin:10px 20px}.review-widget .body .comment-additional-actions .section-separator{border-top:1px solid var(--vscode-menu-separatorBackground);margin:10px 0 14px}.review-widget .body .comment-additional-actions .button-bar{display:flex;white-space:nowrap}.review-widget .body .comment-additional-actions .monaco-button,.review-widget .body .comment-additional-actions .monaco-button-dropdown,.review-widget .body .comment-additional-actions .monaco-text-button{display:flex;width:auto}.review-widget .body .comment-additional-actions .button-bar>.monaco-button-dropdown,.review-widget .body .comment-additional-actions .button-bar>.monaco-text-button{margin:0 10px 0 0}.review-widget .body .comment-additional-actions .button-bar .monaco-text-button{padding:4px 10px}.review-widget .body .comment-additional-actions .codicon-drop-down-button{align-items:center}.review-widget .body .monaco-editor{color:var(--vscode-editor-foreground)}.review-widget .body .comment-form.expand .review-thread-reply-button{display:none}.review-widget .body .comment-form.expand .form-actions,.review-widget .body .comment-form.expand .monaco-editor{box-sizing:content-box;display:block}.review-widget .body .comment-form .review-thread-reply-button{background-color:var(--vscode-peekViewTitle-background);border:0;border-radius:0;box-sizing:border-box;color:var(--vscode-editor-foreground);display:block;font-family:var(--monaco-monospace-font);font-size:inherit;font-weight:600;line-height:20px;outline:1px solid transparent;padding:6px 12px;resize:vertical;text-align:left;white-space:nowrap;width:100%}.review-widget .body .comment-form .review-thread-reply-button:focus{outline-style:solid;outline-width:1px}.review-widget .body .comment-form .monaco-editor,.review-widget .body .comment-form .monaco-editor .monaco-editor-background,.review-widget .body .edit-container .monaco-editor .monaco-editor-background{background-color:var(--vscode-peekViewTitle-background)}.review-widget .body .comment-form .monaco-editor,.review-widget .body .edit-container .monaco-editor{border:0;border-radius:3px;box-sizing:content-box;max-height:500px;min-height:90px;padding:6px 0 6px 12px;width:100%}.review-widget .body .comment-form .form-actions,.review-widget .body .comment-form .monaco-editor{display:none}.review-widget .body .comment-form .form-actions,.review-widget .body .edit-container .form-actions{margin:10px 0;overflow:auto}.review-widget .body .edit-container .form-actions{padding-top:10px}.review-widget .body .edit-textarea{height:90px;margin:5px 12px 10px 0}.review-widget .body .comment-form .monaco-text-button,.review-widget .body .edit-container .monaco-text-button{margin-left:5px;padding:4px 10px;width:auto}.review-widget .body .form-actions .monaco-text-button{float:right}.review-widget .head{box-sizing:border-box;display:flex;height:100%}.review-widget .head .review-title{cursor:default;display:inline-block;font-size:13px;margin-left:20px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.review-widget .head .review-title .dirname:not(:empty){font-size:.9em;margin-left:.5em}.review-widget .head .review-actions{flex:1;padding-right:2px;text-align:right}.review-widget .head .review-actions>.monaco-action-bar{display:inline-block}.review-widget .head .review-actions>.monaco-action-bar,.review-widget .head .review-actions>.monaco-action-bar>.actions-container{height:100%}.review-widget .action-item{margin-left:4px;min-height:20px;min-width:18px}.review-widget .head .review-actions>.monaco-action-bar .action-label{background-position:50%;background-repeat:no-repeat;line-height:inherit;margin:0}.review-widget .head .review-actions>.monaco-action-bar .action-label.codicon{margin:0}.review-widget>.body{border-top:1px solid;position:relative}.monaco-editor .comment-range-glyph{cursor:pointer;margin-left:10px;width:4px!important;z-index:10}div.preview.inline .monaco-editor .comment-range-glyph{display:none!important}.monaco-editor .comment-diff-added{border-left-style:solid;border-left-width:3px}.monaco-editor .comment-diff-added,.monaco-editor .comment-range-glyph.multiline-add{border-left-color:var(--vscode-editorGutter-commentRangeForeground)}.monaco-editor .comment-diff-added:before,.monaco-editor .comment-range-glyph.line-hover:before,.monaco-editor .comment-thread-unresolved:before,.monaco-editor .comment-thread:before{background:var(--vscode-editorGutter-commentRangeForeground)}.monaco-editor .comment-thread-range{background-color:var(--vscode-editorCommentsWidget-rangeBackground)}.monaco-editor .comment-thread-range-current{background-color:var(--vscode-editorCommentsWidget-rangeActiveBackground)}.monaco-editor .margin-view-overlays .comment-range-glyph.comment-thread,.monaco-editor .margin-view-overlays .comment-range-glyph.comment-thread-unresolved,.monaco-editor .margin-view-overlays .comment-range-glyph.line-hover{margin-left:13px}.monaco-editor .comment-range-glyph.comment-thread-unresolved:before,.monaco-editor .comment-range-glyph.comment-thread:before,.monaco-editor .margin-view-overlays .comment-range-glyph.line-hover:before,.monaco-editor .margin-view-overlays>div:hover>.comment-range-glyph.comment-diff-added:before{align-items:center;color:var(--vscode-editorGutter-commentGlyphForeground);display:flex;flex-direction:row;height:100%;justify-content:center;left:-6px;position:absolute;text-align:center;width:9px;z-index:10}.monaco-editor .comment-range-glyph.comment-thread-unresolved:before{color:var(--vscode-editorGutter-commentUnresolvedGlyphForeground)}.monaco-editor .margin-view-overlays .comment-range-glyph.multiline-add{border-left-style:dotted;border-left-width:3px;height:16px;margin-top:2px}.monaco-editor .margin-view-overlays .comment-range-glyph.line-hover:before,.monaco-editor .margin-view-overlays>div:hover>.comment-range-glyph.comment-diff-added:before{border-radius:3px;content:"\\ea60";font-family:codicon;margin-left:-5px;padding-left:1px;width:18px!important}.monaco-editor .comment-range-glyph.comment-thread,.monaco-editor .comment-range-glyph.comment-thread-unresolved{z-index:20}.monaco-editor .comment-range-glyph.comment-thread-unresolved:before,.monaco-editor .comment-range-glyph.comment-thread:before{border-radius:3px;font-family:codicon;font-size:13px;line-height:100%;margin-left:-5px;padding-left:1px;padding-top:1px;width:18px!important;z-index:20}.monaco-editor .comment-range-glyph.comment-thread:before{content:"\\ea6b"}.monaco-editor .comment-range-glyph.comment-thread-unresolved:before{content:"\\ec0a"}.monaco-editor.inline-comment .margin-view-overlays .codicon-folding-collapsed,.monaco-editor.inline-comment .margin-view-overlays .codicon-folding-expanded{margin-left:11px}.monaco-editor.inline-comment .margin-view-overlays .dirty-diff-glyph{margin-left:25px}';
n(css2, {});

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsController.js
init_codeEditorService();
init_range();
init_editorCommon();
init_textModel();
init_languages();
init_nls();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentGlyphWidget.js
init_nls();
init_color();
init_model();
init_textModel();
init_colorRegistry();
init_themeService();
init_languages();
var overviewRulerCommentingRangeForeground = registerColor("editorGutter.commentRangeForeground", { dark: opaque(listInactiveSelectionBackground, editorBackground), light: darken(opaque(listInactiveSelectionBackground, editorBackground), 0.05), hcDark: Color2.white, hcLight: Color2.black }, localize(
  "editorGutterCommentRangeForeground",
  "Editor gutter decoration color for commenting ranges. This color should be opaque."
));
var overviewRulerCommentForeground = registerColor("editorOverviewRuler.commentForeground", { dark: overviewRulerCommentingRangeForeground, light: overviewRulerCommentingRangeForeground, hcDark: overviewRulerCommentingRangeForeground, hcLight: overviewRulerCommentingRangeForeground }, localize(
  "editorOverviewRuler.commentForeground",
  "Editor overview ruler decoration color for resolved comments. This color should be opaque."
));
var overviewRulerCommentUnresolvedForeground = registerColor("editorOverviewRuler.commentUnresolvedForeground", { dark: overviewRulerCommentForeground, light: overviewRulerCommentForeground, hcDark: overviewRulerCommentForeground, hcLight: overviewRulerCommentForeground }, localize(
  "editorOverviewRuler.commentUnresolvedForeground",
  "Editor overview ruler decoration color for unresolved comments. This color should be opaque."
));
var editorGutterCommentGlyphForeground = registerColor("editorGutter.commentGlyphForeground", { dark: editorForeground, light: editorForeground, hcDark: Color2.black, hcLight: Color2.white }, localize(
  "editorGutterCommentGlyphForeground",
  "Editor gutter decoration color for commenting glyphs."
));
registerColor("editorGutter.commentUnresolvedGlyphForeground", { dark: editorGutterCommentGlyphForeground, light: editorGutterCommentGlyphForeground, hcDark: editorGutterCommentGlyphForeground, hcLight: editorGutterCommentGlyphForeground }, localize(
  "editorGutterCommentUnresolvedGlyphForeground",
  "Editor gutter decoration color for commenting glyphs for unresolved comment threads."
));
var _CommentGlyphWidget = class _CommentGlyphWidget {
  constructor(editor, lineNumber) {
    this._commentsOptions = this.createDecorationOptions();
    this._editor = editor;
    this._commentsDecorations = this._editor.createDecorationsCollection();
    this.setLineNumber(lineNumber);
  }
  createDecorationOptions() {
    const unresolved = this._threadState === CommentThreadState.Unresolved;
    const decorationOptions = {
      description: _CommentGlyphWidget.description,
      isWholeLine: true,
      overviewRuler: {
        color: themeColorFromId(unresolved ? overviewRulerCommentUnresolvedForeground : overviewRulerCommentForeground),
        position: OverviewRulerLane.Center
      },
      collapseOnReplaceEdit: true,
      linesDecorationsClassName: `comment-range-glyph comment-thread${unresolved ? "-unresolved" : ""}`
    };
    return ModelDecorationOptions.createDynamic(decorationOptions);
  }
  setThreadState(state) {
    if (this._threadState !== state) {
      this._threadState = state;
      this._commentsOptions = this.createDecorationOptions();
      this._updateDecorations();
    }
  }
  _updateDecorations() {
    const commentsDecorations = [{
      range: {
        startLineNumber: this._lineNumber,
        startColumn: 1,
        endLineNumber: this._lineNumber,
        endColumn: 1
      },
      options: this._commentsOptions
    }];
    this._commentsDecorations.set(commentsDecorations);
  }
  setLineNumber(lineNumber) {
    this._lineNumber = lineNumber;
    this._updateDecorations();
  }
  getPosition() {
    const range = this._commentsDecorations.length > 0 ? this._commentsDecorations.getRange(0) : null;
    return {
      position: {
        lineNumber: range ? range.endLineNumber : this._lineNumber,
        column: 1
      },
      preference: [0]
    };
  }
  dispose() {
    this._commentsDecorations.clear();
  }
};
_CommentGlyphWidget.description = "comment-glyph-widget";
var CommentGlyphWidget = _CommentGlyphWidget;

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadZoneWidget.js
init_tslib_es6();
init_color();
init_event();
init_lifecycle();
init_range();
init_languages();
init_contextkey();
init_instantiation();
init_themeService();
init_editorOptions();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadWidget.js
init_tslib_es6();
init_dom();
init_event();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentReply.js
init_tslib_es6();
init_dom();
init_lifecycle();
init_uri();
init_uuid();
init_language();
init_model2();
init_nls();
init_configuration();
init_colorRegistry();
init_themeService();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentFormActions.js
init_lifecycle();
var CommentFormActions = class {
  constructor(container, actionHandler, maxActions) {
    this.container = container;
    this.actionHandler = actionHandler;
    this.maxActions = maxActions;
    this._buttonElements = [];
    this._toDispose = new DisposableStore();
    this._actions = [];
  }
  setActions(menu, hasOnlySecondaryActions = false) {
    this._toDispose.clear();
    this._buttonElements.forEach((b) => b.remove());
    this._buttonElements = [];
    const groups = menu.getActions({ shouldForwardArgs: true });
    let isPrimary = !hasOnlySecondaryActions;
    for (const group of groups) {
      const [, actions] = group;
      this._actions = actions;
      for (const action of actions) {
        const button = new Button(this.container, { secondary: !isPrimary, ...defaultButtonStyles });
        isPrimary = false;
        this._buttonElements.push(button.element);
        this._toDispose.add(button);
        this._toDispose.add(button.onDidClick(() => this.actionHandler(action)));
        button.enabled = action.enabled;
        button.label = action.label;
        if (this.maxActions !== void 0 && this._buttonElements.length >= this.maxActions) {
          console.warn(`An extension has contributed more than the allowable number of actions to a comments menu.`);
          return;
        }
      }
    }
  }
  triggerDefaultAction() {
    if (this._actions.length) {
      const lastAction = this._actions[0];
      if (lastAction.enabled) {
        return this.actionHandler(lastAction);
      }
    }
  }
  dispose() {
    this._toDispose.dispose();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/common/commentContextKeys.js
init_nls();
init_contextkey();
var CommentContextKeys;
(function(CommentContextKeys2) {
  CommentContextKeys2.commentThreadIsEmpty = new RawContextKey(
    "commentThreadIsEmpty",
    false,
    { type: "boolean", description: localize("commentThreadIsEmpty", "Set when the comment thread has no comments") }
  );
  CommentContextKeys2.commentIsEmpty = new RawContextKey("commentIsEmpty", false, { type: "boolean", description: localize("commentIsEmpty", "Set when the comment has no input") });
  CommentContextKeys2.commentContext = new RawContextKey("comment", void 0, { type: "string", description: localize("comment", "The context value of the comment") });
  CommentContextKeys2.commentThreadContext = new RawContextKey("commentThread", void 0, { type: "string", description: localize("commentThread", "The context value of the comment thread") });
  CommentContextKeys2.commentControllerContext = new RawContextKey(
    "commentController",
    void 0,
    { type: "string", description: localize(
      "commentController",
      "The comment controller id associated with a comment thread"
    ) }
  );
})(CommentContextKeys || (CommentContextKeys = {}));

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/simpleCommentEditor.js
init_tslib_es6();
init_editorExtensions();
init_codeEditorService();
init_contextkey();
init_instantiation();
init_commands();
init_themeService();
init_languageConfigurationRegistry();
init_languageFeatures();
var ctxCommentEditorFocused = new RawContextKey("commentEditorFocused", false);
var SimpleCommentEditor = class SimpleCommentEditor2 extends CodeEditorWidget {
  constructor(domElement, options, scopedContextKeyService, parentThread, instantiationService, codeEditorService, commandService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
    const codeEditorWidgetOptions = {
      contributions: [
        { id: MenuPreventer.ID, ctor: MenuPreventer, instantiation: 2 },
        { id: ContextMenuController.ID, ctor: ContextMenuController, instantiation: 2 },
        { id: SuggestController.ID, ctor: SuggestController, instantiation: 0 },
        { id: SnippetController2.ID, ctor: SnippetController2, instantiation: 4 },
        { id: TabCompletionController.ID, ctor: TabCompletionController, instantiation: 0 }
      ]
    };
    super(domElement, options, codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, scopedContextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
    this._commentEditorFocused = ctxCommentEditorFocused.bindTo(scopedContextKeyService);
    this._commentEditorEmpty = CommentContextKeys.commentIsEmpty.bindTo(scopedContextKeyService);
    this._commentEditorEmpty.set(!this.getValue());
    this._parentThread = parentThread;
    this._register(this.onDidFocusEditorWidget((_) => this._commentEditorFocused.set(true)));
    this._register(this.onDidChangeModelContent((e) => this._commentEditorEmpty.set(!this.getValue())));
    this._register(this.onDidBlurEditorWidget((_) => this._commentEditorFocused.reset()));
  }
  getParentThread() {
    return this._parentThread;
  }
  _getActions() {
    return EditorExtensionsRegistry.getEditorActions();
  }
  static getEditorOptions(configurationService) {
    return {
      wordWrap: "on",
      glyphMargin: false,
      lineNumbers: "off",
      folding: false,
      selectOnLineNumbers: false,
      scrollbar: {
        vertical: "visible",
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false
      },
      overviewRulerLanes: 2,
      lineDecorationsWidth: 0,
      scrollBeyondLastLine: false,
      renderLineHighlight: "none",
      fixedOverflowWidgets: true,
      acceptSuggestionOnEnter: "smart",
      minimap: {
        enabled: false
      },
      autoClosingBrackets: configurationService.getValue("editor.autoClosingBrackets"),
      quickSuggestions: false,
      accessibilitySupport: configurationService.getValue("editor.accessibilitySupport")
    };
  }
};
SimpleCommentEditor = __decorate([
  __param(4, IInstantiationService),
  __param(5, ICodeEditorService),
  __param(6, ICommandService),
  __param(7, IThemeService),
  __param(8, INotificationService),
  __param(9, IAccessibilityService),
  __param(10, ILanguageConfigurationService),
  __param(11, ILanguageFeaturesService)
], SimpleCommentEditor);

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentReply.js
var COMMENT_SCHEME = "comment";
var INMEM_MODEL_ID = 0;
var COMMENTEDITOR_DECORATION_KEY = "commenteditordecoration";
var CommentReply = class CommentReply2 extends Disposable {
  constructor(owner, container, _commentThread, _scopedInstatiationService, _contextKeyService, _commentMenus, _commentOptions, _pendingComment, _parentThread, _actionRunDelegate, commentService, languageService, modelService, themeService, configurationService) {
    super();
    this.owner = owner;
    this._commentThread = _commentThread;
    this._scopedInstatiationService = _scopedInstatiationService;
    this._contextKeyService = _contextKeyService;
    this._commentMenus = _commentMenus;
    this._commentOptions = _commentOptions;
    this._pendingComment = _pendingComment;
    this._parentThread = _parentThread;
    this._actionRunDelegate = _actionRunDelegate;
    this.commentService = commentService;
    this.languageService = languageService;
    this.modelService = modelService;
    this.themeService = themeService;
    this._commentThreadDisposables = [];
    this.form = append(container, $(".comment-form"));
    this.commentEditor = this._register(this._scopedInstatiationService.createInstance(SimpleCommentEditor, this.form, SimpleCommentEditor.getEditorOptions(configurationService), _contextKeyService, this._parentThread));
    this.commentEditorIsEmpty = CommentContextKeys.commentIsEmpty.bindTo(this._contextKeyService);
    this.commentEditorIsEmpty.set(!this._pendingComment);
    const hasExistingComments = this._commentThread.comments && this._commentThread.comments.length > 0;
    const modeId = generateUuid() + "-" + (hasExistingComments ? this._commentThread.threadId : ++INMEM_MODEL_ID);
    const params = JSON.stringify({
      extensionId: this._commentThread.extensionId,
      commentThreadId: this._commentThread.threadId
    });
    let resource = URI.parse(
      `${COMMENT_SCHEME}://${this._commentThread.extensionId}/commentinput-${modeId}.md?${params}`
    );
    const commentController = this.commentService.getCommentController(owner);
    if (commentController) {
      resource = resource.with({ authority: commentController.id });
    }
    const model = this.modelService.createModel(this._pendingComment || "", this.languageService.createByFilepathOrFirstLine(resource), resource, false);
    this._register(model);
    this.commentEditor.setModel(model);
    this._register(this.commentEditor.getModel().onDidChangeContent(() => {
      var _a30;
      this.setCommentEditorDecorations();
      (_a30 = this.commentEditorIsEmpty) == null ? void 0 : _a30.set(!this.commentEditor.getValue());
    }));
    this.createTextModelListener(this.commentEditor, this.form);
    this.setCommentEditorDecorations();
    if (hasExistingComments) {
      this.createReplyButton(this.commentEditor, this.form);
    } else if (this._commentThread.comments && this._commentThread.comments.length === 0) {
      this.expandReplyArea();
    }
    this._error = append(this.form, $(".validation-error.hidden"));
    const formActions = append(this.form, $(".form-actions"));
    this._formActions = append(formActions, $(".other-actions"));
    this.createCommentWidgetFormActions(this._formActions, model);
    this._editorActions = append(formActions, $(".editor-actions"));
    this.createCommentWidgetEditorActions(this._editorActions, model);
  }
  updateCommentThread(commentThread) {
    const isReplying = this.commentEditor.hasTextFocus();
    if (!this._reviewThreadReplyButton) {
      this.createReplyButton(this.commentEditor, this.form);
    }
    if (this._commentThread.comments && this._commentThread.comments.length === 0) {
      this.expandReplyArea();
    }
    if (isReplying) {
      this.commentEditor.focus();
    }
  }
  getPendingComment() {
    const model = this.commentEditor.getModel();
    if (model && model.getValueLength() > 0) {
      return model.getValue();
    }
    return void 0;
  }
  layout(widthInPixel) {
    this.commentEditor.layout({ height: 5 * 18, width: widthInPixel - 54 });
  }
  focusIfNeeded() {
    if (!this._commentThread.comments || !this._commentThread.comments.length) {
      this.commentEditor.focus();
    } else if (this.commentEditor.getModel().getValueLength() > 0) {
      this.expandReplyArea();
    }
  }
  focusCommentEditor() {
    this.commentEditor.focus();
  }
  expandReplyAreaAndFocusCommentEditor() {
    this.expandReplyArea();
    this.commentEditor.focus();
  }
  isCommentEditorFocused() {
    return this.commentEditor.hasWidgetFocus();
  }
  getCommentModel() {
    return this.commentEditor.getModel();
  }
  updateCanReply() {
    if (!this._commentThread.canReply) {
      this.form.style.display = "none";
    } else {
      this.form.style.display = "block";
    }
  }
  async submitComment() {
    var _a30;
    return (_a30 = this._commentFormActions) == null ? void 0 : _a30.triggerDefaultAction();
  }
  setCommentEditorDecorations() {
    var _a30, _b, _c;
    const model = this.commentEditor.getModel();
    if (model) {
      const valueLength = model.getValueLength();
      const hasExistingComments = this._commentThread.comments && this._commentThread.comments.length > 0;
      const placeholder = valueLength > 0 ? "" : hasExistingComments ? ((_a30 = this._commentOptions) == null ? void 0 : _a30.placeHolder) || localize("reply", "Reply...") : ((_b = this._commentOptions) == null ? void 0 : _b.placeHolder) || localize("newComment", "Type a new comment");
      const decorations = [{
        range: {
          startLineNumber: 0,
          endLineNumber: 0,
          startColumn: 0,
          endColumn: 1
        },
        renderOptions: {
          after: {
            contentText: placeholder,
            color: `${(_c = resolveColorValue(editorForeground, this.themeService.getColorTheme())) == null ? void 0 : _c.transparent(0.4)}`
          }
        }
      }];
      this.commentEditor.setDecorationsByType("review-zone-widget", COMMENTEDITOR_DECORATION_KEY, decorations);
    }
  }
  createTextModelListener(commentEditor, commentForm) {
    this._commentThreadDisposables.push(commentEditor.onDidFocusEditorWidget(() => {
      this._commentThread.input = {
        uri: commentEditor.getModel().uri,
        value: commentEditor.getValue()
      };
      this.commentService.setActiveCommentThread(this._commentThread);
    }));
    this._commentThreadDisposables.push(commentEditor.getModel().onDidChangeContent(() => {
      const modelContent = commentEditor.getValue();
      if (this._commentThread.input && this._commentThread.input.uri === commentEditor.getModel().uri && this._commentThread.input.value !== modelContent) {
        const newInput = this._commentThread.input;
        newInput.value = modelContent;
        this._commentThread.input = newInput;
      }
      this.commentService.setActiveCommentThread(this._commentThread);
    }));
    this._commentThreadDisposables.push(this._commentThread.onDidChangeInput((input) => {
      const thread = this._commentThread;
      const model = commentEditor.getModel();
      if (thread.input && model && thread.input.uri !== model.uri) {
        return;
      }
      if (!input) {
        return;
      }
      if (commentEditor.getValue() !== input.value) {
        commentEditor.setValue(input.value);
        if (input.value === "") {
          this._pendingComment = "";
          commentForm.classList.remove("expand");
          commentEditor.getDomNode().style.outline = "";
          this._error.textContent = "";
          this._error.classList.add("hidden");
        }
      }
    }));
  }
  createCommentWidgetFormActions(container, model) {
    const menu = this._commentMenus.getCommentThreadActions(this._contextKeyService);
    this._register(menu);
    this._register(menu.onDidChange(() => {
      this._commentFormActions.setActions(menu);
    }));
    this._commentFormActions = new CommentFormActions(container, async (action) => {
      var _a30;
      (_a30 = this._actionRunDelegate) == null ? void 0 : _a30.call(this);
      action.run({
        thread: this._commentThread,
        text: this.commentEditor.getValue(),
        $mid: 9
      });
      this.hideReplyArea();
    });
    this._register(this._commentFormActions);
    this._commentFormActions.setActions(menu);
  }
  createCommentWidgetEditorActions(container, model) {
    const editorMenu = this._commentMenus.getCommentEditorActions(this._contextKeyService);
    this._register(editorMenu);
    this._register(editorMenu.onDidChange(() => {
      this._commentEditorActions.setActions(editorMenu);
    }));
    this._commentEditorActions = new CommentFormActions(container, async (action) => {
      var _a30;
      (_a30 = this._actionRunDelegate) == null ? void 0 : _a30.call(this);
      action.run({
        thread: this._commentThread,
        text: this.commentEditor.getValue(),
        $mid: 9
      });
      this.focusCommentEditor();
    });
    this._register(this._commentEditorActions);
    this._commentEditorActions.setActions(editorMenu, true);
  }
  get isReplyExpanded() {
    return this.form.classList.contains("expand");
  }
  expandReplyArea() {
    if (!this.isReplyExpanded) {
      this.form.classList.add("expand");
      this.commentEditor.focus();
      this.commentEditor.layout();
    }
  }
  clearAndExpandReplyArea() {
    if (!this.isReplyExpanded) {
      this.commentEditor.setValue("");
      this.expandReplyArea();
    }
  }
  hideReplyArea() {
    this.commentEditor.getDomNode().style.outline = "";
    this.commentEditor.setValue("");
    this._pendingComment = "";
    this.form.classList.remove("expand");
    this._error.textContent = "";
    this._error.classList.add("hidden");
  }
  createReplyButton(commentEditor, commentForm) {
    var _a30, _b;
    this._reviewThreadReplyButton = append(commentForm, $(`button.review-thread-reply-button.${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`));
    this._reviewThreadReplyButton.title = ((_a30 = this._commentOptions) == null ? void 0 : _a30.prompt) || localize("reply", "Reply...");
    this._reviewThreadReplyButton.textContent = ((_b = this._commentOptions) == null ? void 0 : _b.prompt) || localize("reply", "Reply...");
    this._register(addDisposableListener(this._reviewThreadReplyButton, "click", (_) => this.clearAndExpandReplyArea()));
    this._register(addDisposableListener(this._reviewThreadReplyButton, "focus", (_) => this.clearAndExpandReplyArea()));
    commentEditor.onDidBlurEditorWidget(() => {
      if (commentEditor.getModel().getValueLength() === 0 && commentForm.classList.contains("expand")) {
        commentForm.classList.remove("expand");
      }
    });
  }
};
CommentReply = __decorate([
  __param(10, ICommentService),
  __param(11, ILanguageService),
  __param(12, IModelService),
  __param(13, IThemeService),
  __param(14, IConfigurationService)
], CommentReply);

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadBody.js
init_tslib_es6();
init_dom();
init_nls();
init_lifecycle();
init_languages();
init_event();
init_keyboardEvent();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentNode.js
init_tslib_es6();
init_nls();
init_dom();
init_languages();
init_actions();
init_lifecycle();
init_uri();
init_model2();
init_language();
init_instantiation();
init_selection();
init_event();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/reactionsAction.js
init_nls();
init_dom();
init_actions();
init_uri();
var _ToggleReactionsAction = class _ToggleReactionsAction extends Action {
  constructor(toggleDropdownMenu, title) {
    super(_ToggleReactionsAction.ID, title || localize("pickReactions", "Pick Reactions..."), "toggle-reactions", true);
    this._menuActions = [];
    this.toggleDropdownMenu = toggleDropdownMenu;
  }
  run() {
    this.toggleDropdownMenu();
    return Promise.resolve(true);
  }
  get menuActions() {
    return this._menuActions;
  }
  set menuActions(actions) {
    this._menuActions = actions;
  }
};
_ToggleReactionsAction.ID = "toolbar.toggle.pickReactions";
var ToggleReactionsAction = _ToggleReactionsAction;
var ReactionActionViewItem = class extends ActionViewItem {
  constructor(action) {
    super(null, action, {});
  }
  updateLabel() {
    if (!this.label) {
      return;
    }
    const action = this.action;
    if (action.class) {
      this.label.classList.add(action.class);
    }
    if (!action.icon) {
      const reactionLabel = append(this.label, $("span.reaction-label"));
      reactionLabel.innerText = action.label;
    } else {
      const reactionIcon = append(this.label, $(".reaction-icon"));
      const uri = URI.revive(action.icon);
      reactionIcon.style.backgroundImage = asCSSUrl(uri);
      reactionIcon.title = action.label;
    }
    if (action.count) {
      const reactionCount = append(this.label, $("span.reaction-count"));
      reactionCount.innerText = `${action.count}`;
    }
  }
  getTooltip() {
    const action = this.action;
    const toggleMessage = action.enabled ? localize("comment.toggleableReaction", "Toggle reaction, ") : "";
    if (action.count === void 0) {
      return localize({
        key: "comment.reactionLabelNone",
        comment: [
          "This is a tooltip for an emoji button so that the current user can toggle their reaction to a comment.",
          `The first arg is localized message "Toggle reaction" or empty if the user doesn't have permission to toggle the reaction, the second is the name of the reaction.`
        ]
      }, "{0}{1} reaction", toggleMessage, action.label);
    } else if (action.count === 1) {
      return localize({
        key: "comment.reactionLabelOne",
        comment: [
          'This is a tooltip for an emoji that is a "reaction" to a comment where the count of the reactions is 1.',
          "The emoji is also a button so that the current user can also toggle their own emoji reaction.",
          `The first arg is localized message "Toggle reaction" or empty if the user doesn't have permission to toggle the reaction, the second is the name of the reaction.`
        ]
      }, "{0}1 reaction with {1}", toggleMessage, action.label);
    } else if (action.count > 1) {
      return localize({
        key: "comment.reactionLabelMany",
        comment: [
          'This is a tooltip for an emoji that is a "reaction" to a comment where the count of the reactions is greater than 1.',
          "The emoji is also a button so that the current user can also toggle their own emoji reaction.",
          `The first arg is localized message "Toggle reaction" or empty if the user doesn't have permission to toggle the reaction, the second is number of users who have reacted with that reaction, and the third is the name of the reaction.`
        ]
      }, "{0}{1} reactions with {2}", toggleMessage, action.count, action.label);
    }
    return void 0;
  }
};
var _ReactionAction = class _ReactionAction extends Action {
  constructor(id, label = "", cssClass = "", enabled = true, actionCallback, icon, count2) {
    super(_ReactionAction.ID, label, cssClass, enabled, actionCallback);
    this.icon = icon;
    this.count = count2;
  }
};
_ReactionAction.ID = "toolbar.toggle.reaction";
var ReactionAction = _ReactionAction;

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentNode.js
init_actions2();
init_contextkey();
init_codicons();
init_themables();
init_configuration();
init_network();
init_mouseEvent();
var CommentsActionRunner = class extends ActionRunner {
  async runAction(action, context) {
    await action.run(...context);
  }
};
var CommentNode2 = class CommentNode3 extends Disposable {
  get domNode() {
    return this._domNode;
  }
  constructor(commentThread, comment, pendingEdit, owner, resource, parentThread, markdownRenderer, instantiationService, commentService, modelService, languageService, notificationService, contextMenuService, contextKeyService, configurationService) {
    var _a30;
    super();
    this.commentThread = commentThread;
    this.comment = comment;
    this.pendingEdit = pendingEdit;
    this.owner = owner;
    this.resource = resource;
    this.parentThread = parentThread;
    this.markdownRenderer = markdownRenderer;
    this.instantiationService = instantiationService;
    this.commentService = commentService;
    this.modelService = modelService;
    this.languageService = languageService;
    this.notificationService = notificationService;
    this.contextMenuService = contextMenuService;
    this.configurationService = configurationService;
    this._editAction = null;
    this._commentEditContainer = null;
    this._commentEditor = null;
    this._commentEditorDisposables = [];
    this._commentEditorModel = null;
    this._commentFormActions = null;
    this._commentEditorActions = null;
    this._onDidClick = new Emitter();
    this.isEditing = false;
    this._domNode = $("div.review-comment");
    this._contextKeyService = contextKeyService.createScoped(this._domNode);
    this._commentContextValue = CommentContextKeys.commentContext.bindTo(this._contextKeyService);
    if (this.comment.contextValue) {
      this._commentContextValue.set(this.comment.contextValue);
    }
    this._commentMenus = this.commentService.getCommentMenus(this.owner);
    this._domNode.tabIndex = -1;
    const avatar = append(this._domNode, $("div.avatar-container"));
    if (comment.userIconPath) {
      const img = append(avatar, $("img.avatar"));
      img.src = FileAccess.uriToBrowserUri(URI.revive(comment.userIconPath)).toString(true);
      img.onerror = (_) => img.remove();
    }
    this._commentDetailsContainer = append(this._domNode, $(".review-comment-contents"));
    this.createHeader(this._commentDetailsContainer);
    this._body = document.createElement(`div`);
    this._body.classList.add("comment-body", MOUSE_CURSOR_TEXT_CSS_CLASS_NAME);
    if (((_a30 = configurationService.getValue(COMMENTS_SECTION)) == null ? void 0 : _a30.maxHeight) !== false) {
      this._body.classList.add("comment-body-max-height");
    }
    this.createScroll(this._commentDetailsContainer, this._body);
    this.updateCommentBody(this.comment.body);
    if (this.comment.commentReactions && this.comment.commentReactions.length && this.comment.commentReactions.filter((reaction) => !!reaction.count).length) {
      this.createReactionsContainer(this._commentDetailsContainer);
    }
    this._domNode.setAttribute("aria-label", `${comment.userName}, ${this.commentBodyValue}`);
    this._domNode.setAttribute("role", "treeitem");
    this._clearTimeout = null;
    this._register(addDisposableListener(this._domNode, EventType.CLICK, () => this.isEditing || this._onDidClick.fire(this)));
    this._register(addDisposableListener(this._domNode, EventType.CONTEXT_MENU, (e) => {
      return this.onContextMenu(e);
    }));
    if (pendingEdit) {
      this.switchToEditMode();
    }
  }
  createScroll(container, body) {
    this._scrollable = new Scrollable({
      forceIntegerValues: true,
      smoothScrollDuration: 125,
      scheduleAtNextAnimationFrame: (cb) => scheduleAtNextAnimationFrame(cb)
    });
    this._scrollableElement = this._register(new SmoothScrollableElement(body, {
      horizontal: 3,
      vertical: 3
    }, this._scrollable));
    this._register(this._scrollableElement.onScroll((e) => {
      if (e.scrollLeftChanged) {
        body.scrollLeft = e.scrollLeft;
      }
      if (e.scrollTopChanged) {
        body.scrollTop = e.scrollTop;
      }
    }));
    const onDidScrollViewContainer = this._register(new DomEmitter(body, "scroll")).event;
    this._register(onDidScrollViewContainer((_) => {
      const position = this._scrollableElement.getScrollPosition();
      const scrollLeft = Math.abs(body.scrollLeft - position.scrollLeft) <= 1 ? void 0 : body.scrollLeft;
      const scrollTop = Math.abs(body.scrollTop - position.scrollTop) <= 1 ? void 0 : body.scrollTop;
      if (scrollLeft !== void 0 || scrollTop !== void 0) {
        this._scrollableElement.setScrollPosition({ scrollLeft, scrollTop });
      }
    }));
    container.appendChild(this._scrollableElement.getDomNode());
  }
  updateCommentBody(body) {
    this._body.innerText = "";
    this._md = void 0;
    this._plainText = void 0;
    if (typeof body === "string") {
      this._plainText = append(this._body, $(".comment-body-plainstring"));
      this._plainText.innerText = body;
    } else {
      this._md = this.markdownRenderer.render(body).element;
      this._body.appendChild(this._md);
    }
  }
  get onDidClick() {
    return this._onDidClick.event;
  }
  createTimestamp(container) {
    this._timestamp = append(container, $("span.timestamp-container"));
    this.updateTimestamp(this.comment.timestamp);
  }
  updateTimestamp(raw) {
    var _a30;
    if (!this._timestamp) {
      return;
    }
    const timestamp = raw !== void 0 ? new Date(raw) : void 0;
    if (!timestamp) {
      (_a30 = this._timestampWidget) == null ? void 0 : _a30.dispose();
    } else {
      if (!this._timestampWidget) {
        this._timestampWidget = new TimestampWidget(this.configurationService, this._timestamp, timestamp);
        this._register(this._timestampWidget);
      } else {
        this._timestampWidget.setTimestamp(timestamp);
      }
    }
  }
  createHeader(commentDetailsContainer) {
    const header = append(commentDetailsContainer, $(`div.comment-title.${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`));
    const infoContainer = append(header, $("comment-header-info"));
    const author = append(infoContainer, $("strong.author"));
    author.innerText = this.comment.userName;
    this.createTimestamp(infoContainer);
    this._isPendingLabel = append(infoContainer, $("span.isPending"));
    if (this.comment.label) {
      this._isPendingLabel.innerText = this.comment.label;
    } else {
      this._isPendingLabel.innerText = "";
    }
    this._actionsToolbarContainer = append(header, $(".comment-actions.hidden"));
    this.createActionsToolbar();
  }
  getToolbarActions(menu) {
    const contributedActions = menu.getActions({ shouldForwardArgs: true });
    const primary = [];
    const secondary = [];
    const result = { primary, secondary };
    fillInActions(contributedActions, result, false, (g) => /^inline/.test(g));
    return result;
  }
  get commentNodeContext() {
    return [
      {
        thread: this.commentThread,
        commentUniqueId: this.comment.uniqueIdInThread,
        $mid: 10
      },
      {
        commentControlHandle: this.commentThread.controllerHandle,
        commentThreadHandle: this.commentThread.commentThreadHandle,
        $mid: 7
      }
    ];
  }
  createToolbar() {
    this.toolbar = new ToolBar(this._actionsToolbarContainer, this.contextMenuService, {
      actionViewItemProvider: (action) => {
        if (action.id === ToggleReactionsAction.ID) {
          return new DropdownMenuActionViewItem(action, action.menuActions, this.contextMenuService, {
            actionViewItemProvider: (action2) => this.actionViewItemProvider(action2),
            actionRunner: this.actionRunner,
            classNames: ["toolbar-toggle-pickReactions", ...ThemeIcon.asClassNameArray(Codicon.reactions)],
            anchorAlignmentProvider: () => 1
          });
        }
        return this.actionViewItemProvider(action);
      },
      orientation: 0
    });
    this.toolbar.context = this.commentNodeContext;
    this.toolbar.actionRunner = new CommentsActionRunner();
    this.registerActionBarListeners(this._actionsToolbarContainer);
    this._register(this.toolbar);
  }
  createActionsToolbar() {
    const actions = [];
    const hasReactionHandler = this.commentService.hasReactionHandler(this.owner);
    if (hasReactionHandler) {
      const toggleReactionAction = this.createReactionPicker(this.comment.commentReactions || []);
      actions.push(toggleReactionAction);
    }
    const menu = this._commentMenus.getCommentTitleActions(this.comment, this._contextKeyService);
    this._register(menu);
    this._register(menu.onDidChange((e) => {
      const { primary: primary2, secondary: secondary2 } = this.getToolbarActions(menu);
      if (!this.toolbar && (primary2.length || secondary2.length)) {
        this.createToolbar();
      }
      this.toolbar.setActions(primary2, secondary2);
    }));
    const { primary, secondary } = this.getToolbarActions(menu);
    actions.push(...primary);
    if (actions.length || secondary.length) {
      this.createToolbar();
      this.toolbar.setActions(actions, secondary);
    }
  }
  actionViewItemProvider(action) {
    let options = {};
    if (action.id === ToggleReactionsAction.ID) {
      options = { label: false, icon: true };
    } else {
      options = { label: false, icon: true };
    }
    if (action.id === ReactionAction.ID) {
      const item = new ReactionActionViewItem(action);
      return item;
    } else if (action instanceof MenuItemAction) {
      return this.instantiationService.createInstance(MenuEntryActionViewItem, action, void 0);
    } else if (action instanceof SubmenuItemAction) {
      return this.instantiationService.createInstance(SubmenuEntryActionViewItem, action, void 0);
    } else {
      const item = new ActionViewItem({}, action, options);
      return item;
    }
  }
  async submitComment() {
    if (this._commentEditor && this._commentFormActions) {
      this._commentFormActions.triggerDefaultAction();
    }
  }
  createReactionPicker(reactionGroup) {
    const toggleReactionAction = this._register(new ToggleReactionsAction(() => {
      toggleReactionActionViewItem == null ? void 0 : toggleReactionActionViewItem.show();
    }, localize("commentToggleReaction", "Toggle Reaction")));
    let reactionMenuActions = [];
    if (reactionGroup && reactionGroup.length) {
      reactionMenuActions = reactionGroup.map((reaction) => {
        return new Action(
          `reaction.command.${reaction.label}`,
          `${reaction.label}`,
          "",
          true,
          async () => {
            try {
              await this.commentService.toggleReaction(this.owner, this.resource, this.commentThread, this.comment, reaction);
            } catch (e) {
              const error = e.message ? localize(
                "commentToggleReactionError",
                "Toggling the comment reaction failed: {0}.",
                e.message
              ) : localize(
                "commentToggleReactionDefaultError",
                "Toggling the comment reaction failed"
              );
              this.notificationService.error(error);
            }
          }
        );
      });
    }
    toggleReactionAction.menuActions = reactionMenuActions;
    const toggleReactionActionViewItem = new DropdownMenuActionViewItem(
      toggleReactionAction,
      toggleReactionAction.menuActions,
      this.contextMenuService,
      {
        actionViewItemProvider: (action) => {
          if (action.id === ToggleReactionsAction.ID) {
            return toggleReactionActionViewItem;
          }
          return this.actionViewItemProvider(action);
        },
        actionRunner: this.actionRunner,
        classNames: "toolbar-toggle-pickReactions",
        anchorAlignmentProvider: () => 1
      }
    );
    return toggleReactionAction;
  }
  createReactionsContainer(commentDetailsContainer) {
    this._reactionActionsContainer = append(commentDetailsContainer, $("div.comment-reactions"));
    this._reactionsActionBar = new ActionBar(this._reactionActionsContainer, {
      actionViewItemProvider: (action) => {
        if (action.id === ToggleReactionsAction.ID) {
          return new DropdownMenuActionViewItem(action, action.menuActions, this.contextMenuService, {
            actionViewItemProvider: (action2) => this.actionViewItemProvider(action2),
            actionRunner: this.actionRunner,
            classNames: ["toolbar-toggle-pickReactions", ...ThemeIcon.asClassNameArray(Codicon.reactions)],
            anchorAlignmentProvider: () => 1
          });
        }
        return this.actionViewItemProvider(action);
      }
    });
    this._register(this._reactionsActionBar);
    const hasReactionHandler = this.commentService.hasReactionHandler(this.owner);
    if (hasReactionHandler) {
      const toggleReactionAction = this.createReactionPicker(this.comment.commentReactions || []);
      this._reactionsActionBar.push(toggleReactionAction, { label: false, icon: true });
    }
  }
  get commentBodyValue() {
    return typeof this.comment.body === "string" ? this.comment.body : this.comment.body.value;
  }
  createCommentEditor(editContainer) {
    const container = append(editContainer, $(".edit-textarea"));
    this._commentEditor = this.instantiationService.createInstance(SimpleCommentEditor, container, SimpleCommentEditor.getEditorOptions(this.configurationService), this._contextKeyService, this.parentThread);
    const resource = URI.parse(`comment:commentinput-${this.comment.uniqueIdInThread}-${Date.now()}.md`);
    this._commentEditorModel = this.modelService.createModel("", this.languageService.createByFilepathOrFirstLine(resource), resource, false);
    this._commentEditor.setModel(this._commentEditorModel);
    this._commentEditor.setValue(this.pendingEdit ?? this.commentBodyValue);
    this.pendingEdit = void 0;
    this._commentEditor.layout({ width: container.clientWidth - 14, height: 90 });
    this._commentEditor.focus();
    scheduleAtNextAnimationFrame(() => {
      this._commentEditor.layout({ width: container.clientWidth - 14, height: 90 });
      this._commentEditor.focus();
    });
    const lastLine = this._commentEditorModel.getLineCount();
    const lastColumn = this._commentEditorModel.getLineContent(lastLine).length + 1;
    this._commentEditor.setSelection(new Selection2(lastLine, lastColumn, lastLine, lastColumn));
    const commentThread = this.commentThread;
    commentThread.input = {
      uri: this._commentEditor.getModel().uri,
      value: this.commentBodyValue
    };
    this.commentService.setActiveCommentThread(commentThread);
    this._commentEditorDisposables.push(this._commentEditor.onDidFocusEditorWidget(() => {
      commentThread.input = {
        uri: this._commentEditor.getModel().uri,
        value: this.commentBodyValue
      };
      this.commentService.setActiveCommentThread(commentThread);
    }));
    this._commentEditorDisposables.push(this._commentEditor.onDidChangeModelContent((e) => {
      if (commentThread.input && this._commentEditor && this._commentEditor.getModel().uri === commentThread.input.uri) {
        const newVal = this._commentEditor.getValue();
        if (newVal !== commentThread.input.value) {
          const input = commentThread.input;
          input.value = newVal;
          commentThread.input = input;
          this.commentService.setActiveCommentThread(commentThread);
        }
      }
    }));
    this._register(this._commentEditor);
    this._register(this._commentEditorModel);
  }
  getPendingEdit() {
    var _a30;
    const model = (_a30 = this._commentEditor) == null ? void 0 : _a30.getModel();
    if (model && model.getValueLength() > 0) {
      return model.getValue();
    }
    return void 0;
  }
  removeCommentEditor() {
    var _a30;
    this.isEditing = false;
    if (this._editAction) {
      this._editAction.enabled = true;
    }
    this._body.classList.remove("hidden");
    (_a30 = this._commentEditorModel) == null ? void 0 : _a30.dispose();
    this._commentEditorDisposables.forEach((dispose2) => dispose2.dispose());
    this._commentEditorDisposables = [];
    if (this._commentEditor) {
      this._commentEditor.dispose();
      this._commentEditor = null;
    }
    this._commentEditContainer.remove();
  }
  layout() {
    var _a30;
    (_a30 = this._commentEditor) == null ? void 0 : _a30.layout();
    const scrollWidth = this._body.scrollWidth;
    const width = getContentWidth(this._body);
    const scrollHeight = this._body.scrollHeight;
    const height = getContentHeight(this._body) + 4;
    this._scrollableElement.setScrollDimensions({ width, scrollWidth, height, scrollHeight });
  }
  switchToEditMode() {
    if (this.isEditing) {
      return;
    }
    this.isEditing = true;
    this._body.classList.add("hidden");
    this._commentEditContainer = append(this._commentDetailsContainer, $(".edit-container"));
    this.createCommentEditor(this._commentEditContainer);
    const formActions = append(this._commentEditContainer, $(".form-actions"));
    const otherActions = append(formActions, $(".other-actions"));
    this.createCommentWidgetFormActions(otherActions);
    const editorActions = append(formActions, $(".editor-actions"));
    this.createCommentWidgetEditorActions(editorActions);
  }
  createCommentWidgetFormActions(container) {
    const menus = this.commentService.getCommentMenus(this.owner);
    const menu = menus.getCommentActions(this.comment, this._contextKeyService);
    this._register(menu);
    this._register(menu.onDidChange(() => {
      var _a30;
      (_a30 = this._commentFormActions) == null ? void 0 : _a30.setActions(menu);
    }));
    this._commentFormActions = new CommentFormActions(container, (action) => {
      const text = this._commentEditor.getValue();
      action.run({
        thread: this.commentThread,
        commentUniqueId: this.comment.uniqueIdInThread,
        text,
        $mid: 11
      });
      this.removeCommentEditor();
    });
    this._register(this._commentFormActions);
    this._commentFormActions.setActions(menu);
  }
  createCommentWidgetEditorActions(container) {
    const menus = this.commentService.getCommentMenus(this.owner);
    const menu = menus.getCommentEditorActions(this._contextKeyService);
    this._register(menu);
    this._register(menu.onDidChange(() => {
      var _a30;
      (_a30 = this._commentEditorActions) == null ? void 0 : _a30.setActions(menu);
    }));
    this._commentEditorActions = new CommentFormActions(container, (action) => {
      var _a30;
      const text = this._commentEditor.getValue();
      action.run({
        thread: this.commentThread,
        commentUniqueId: this.comment.uniqueIdInThread,
        text,
        $mid: 11
      });
      (_a30 = this._commentEditor) == null ? void 0 : _a30.focus();
    });
    this._register(this._commentEditorActions);
    this._commentEditorActions.setActions(menu, true);
  }
  setFocus(focused, visible = false) {
    var _a30;
    if (focused) {
      this._domNode.focus();
      this._actionsToolbarContainer.classList.remove("hidden");
      this._actionsToolbarContainer.classList.add("tabfocused");
      this._domNode.tabIndex = 0;
      if (this.comment.mode === CommentMode.Editing) {
        (_a30 = this._commentEditor) == null ? void 0 : _a30.focus();
      }
    } else {
      if (this._actionsToolbarContainer.classList.contains("tabfocused") && !this._actionsToolbarContainer.classList.contains("mouseover")) {
        this._actionsToolbarContainer.classList.add("hidden");
        this._domNode.tabIndex = -1;
      }
      this._actionsToolbarContainer.classList.remove("tabfocused");
    }
  }
  registerActionBarListeners(actionsContainer) {
    this._register(addDisposableListener(this._domNode, "mouseenter", () => {
      actionsContainer.classList.remove("hidden");
      actionsContainer.classList.add("mouseover");
    }));
    this._register(addDisposableListener(this._domNode, "mouseleave", () => {
      if (actionsContainer.classList.contains("mouseover") && !actionsContainer.classList.contains("tabfocused")) {
        actionsContainer.classList.add("hidden");
      }
      actionsContainer.classList.remove("mouseover");
    }));
  }
  update(newComment) {
    var _a30, _b;
    if (newComment.body !== this.comment.body) {
      this.updateCommentBody(newComment.body);
    }
    const isChangingMode = newComment.mode !== void 0 && newComment.mode !== this.comment.mode;
    this.comment = newComment;
    if (isChangingMode) {
      if (newComment.mode === CommentMode.Editing) {
        this.switchToEditMode();
      } else {
        this.removeCommentEditor();
      }
    }
    if (newComment.label) {
      this._isPendingLabel.innerText = newComment.label;
    } else {
      this._isPendingLabel.innerText = "";
    }
    (_a30 = this._reactionActionsContainer) == null ? void 0 : _a30.remove();
    (_b = this._reactionsActionBar) == null ? void 0 : _b.clear();
    if (this.comment.commentReactions && this.comment.commentReactions.some((reaction) => !!reaction.count)) {
      this.createReactionsContainer(this._commentDetailsContainer);
    }
    if (this.comment.contextValue) {
      this._commentContextValue.set(this.comment.contextValue);
    } else {
      this._commentContextValue.reset();
    }
    if (this.comment.timestamp) {
      this.updateTimestamp(this.comment.timestamp);
    }
  }
  onContextMenu(e) {
    const event = new StandardMouseEvent(e);
    this.contextMenuService.showContextMenu({
      getAnchor: () => event,
      menuId: MenuId.CommentThreadCommentContext,
      menuActionOptions: { shouldForwardArgs: true },
      contextKeyService: this._contextKeyService,
      actionRunner: new CommentsActionRunner(),
      getActionsContext: () => {
        return this.commentNodeContext;
      }
    });
  }
  focus() {
    this.domNode.focus();
    if (!this._clearTimeout) {
      this.domNode.classList.add("focus");
      this._clearTimeout = setTimeout(() => {
        this.domNode.classList.remove("focus");
      }, 3e3);
    }
  }
};
CommentNode2 = __decorate([
  __param(7, IInstantiationService),
  __param(8, ICommentService),
  __param(9, IModelService),
  __param(10, ILanguageService),
  __param(11, INotificationService),
  __param(12, IContextMenuService),
  __param(13, IContextKeyService),
  __param(14, IConfigurationService)
], CommentNode2);
function fillInActions(groups, target, useAlternativeActions, isPrimaryGroup = (group) => group === "navigation") {
  for (const tuple of groups) {
    let [group, actions] = tuple;
    if (useAlternativeActions) {
      actions = actions.map((a) => a instanceof MenuItemAction && !!a.alt ? a.alt : a);
    }
    if (isPrimaryGroup(group)) {
      const to = Array.isArray(target) ? target : target.primary;
      to.unshift(...actions);
    } else {
      const to = Array.isArray(target) ? target : target.secondary;
      if (to.length > 0) {
        to.push(new Separator());
      }
      to.push(...actions);
    }
  }
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadBody.js
init_opener();
init_language();
var CommentThreadBody = class CommentThreadBody2 extends Disposable {
  get length() {
    return this._commentThread.comments ? this._commentThread.comments.length : 0;
  }
  get activeComment() {
    return this._commentElements.filter((node) => node.isEditing)[0];
  }
  constructor(owner, parentResourceUri, container, _options3, _commentThread, _pendingEdits, _scopedInstatiationService, _parentCommentThreadWidget, commentService, openerService, languageService) {
    super();
    this.owner = owner;
    this.parentResourceUri = parentResourceUri;
    this.container = container;
    this._options = _options3;
    this._commentThread = _commentThread;
    this._pendingEdits = _pendingEdits;
    this._scopedInstatiationService = _scopedInstatiationService;
    this._parentCommentThreadWidget = _parentCommentThreadWidget;
    this.commentService = commentService;
    this.openerService = openerService;
    this.languageService = languageService;
    this._commentElements = [];
    this._focusedComment = void 0;
    this._onDidResize = new Emitter();
    this.onDidResize = this._onDidResize.event;
    this._commentDisposable = /* @__PURE__ */ new Map();
    this._register(addDisposableListener(container, EventType.FOCUS_IN, (e) => {
      this.commentService.setActiveCommentThread(this._commentThread);
    }));
    this._markdownRenderer = this._register(new MarkdownRenderer(this._options, this.languageService, this.openerService));
  }
  focus() {
    this._commentsElement.focus();
  }
  display() {
    this._commentsElement = append(this.container, $("div.comments-container"));
    this._commentsElement.setAttribute("role", "presentation");
    this._commentsElement.tabIndex = 0;
    this._updateAriaLabel();
    this._register(addDisposableListener(this._commentsElement, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(16) || event.equals(18)) {
        const moveFocusWithinBounds = (change) => {
          if (this._focusedComment === void 0 && change >= 0) {
            return 0;
          }
          if (this._focusedComment === void 0 && change < 0) {
            return this._commentElements.length - 1;
          }
          const newIndex = this._focusedComment + change;
          return Math.min(Math.max(0, newIndex), this._commentElements.length - 1);
        };
        this._setFocusedComment(event.equals(16) ? moveFocusWithinBounds(-1) : moveFocusWithinBounds(1));
      }
    }));
    this._commentElements = [];
    if (this._commentThread.comments) {
      for (const comment of this._commentThread.comments) {
        const newCommentNode = this.createNewCommentNode(comment);
        this._commentElements.push(newCommentNode);
        this._commentsElement.appendChild(newCommentNode.domNode);
        if (comment.mode === CommentMode.Editing) {
          newCommentNode.switchToEditMode();
        }
      }
    }
    this._resizeObserver = new MutationObserver(this._refresh.bind(this));
    this._resizeObserver.observe(this.container, {
      attributes: true,
      childList: true,
      characterData: true,
      subtree: true
    });
  }
  _refresh() {
    const dimensions = getClientArea(this.container);
    this._onDidResize.fire(dimensions);
  }
  getDimensions() {
    return getClientArea(this.container);
  }
  layout() {
    this._commentElements.forEach((element) => {
      element.layout();
    });
  }
  getPendingEdits() {
    const pendingEdits = {};
    this._commentElements.forEach((element) => {
      if (element.isEditing) {
        const pendingEdit = element.getPendingEdit();
        if (pendingEdit) {
          pendingEdits[element.comment.uniqueIdInThread] = pendingEdit;
        }
      }
    });
    return pendingEdits;
  }
  getCommentCoords(commentUniqueId) {
    const matchedNode = this._commentElements.filter((commentNode) => commentNode.comment.uniqueIdInThread === commentUniqueId);
    if (matchedNode && matchedNode.length) {
      const commentThreadCoords = getDomNodePagePosition(this._commentElements[0].domNode);
      const commentCoords = getDomNodePagePosition(matchedNode[0].domNode);
      return {
        thread: commentThreadCoords,
        comment: commentCoords
      };
    }
    return;
  }
  updateCommentThread(commentThread) {
    var _a30;
    const oldCommentsLen = this._commentElements.length;
    const newCommentsLen = commentThread.comments ? commentThread.comments.length : 0;
    const commentElementsToDel = [];
    const commentElementsToDelIndex = [];
    for (let i = 0; i < oldCommentsLen; i++) {
      const comment = this._commentElements[i].comment;
      const newComment = commentThread.comments ? commentThread.comments.filter((c) => c.uniqueIdInThread === comment.uniqueIdInThread) : [];
      if (newComment.length) {
        this._commentElements[i].update(newComment[0]);
      } else {
        commentElementsToDelIndex.push(i);
        commentElementsToDel.push(this._commentElements[i]);
      }
    }
    for (let i = commentElementsToDel.length - 1; i >= 0; i--) {
      const commentToDelete = commentElementsToDel[i];
      (_a30 = this._commentDisposable.get(commentToDelete)) == null ? void 0 : _a30.dispose();
      this._commentDisposable.delete(commentToDelete);
      this._commentElements.splice(commentElementsToDelIndex[i], 1);
      this._commentsElement.removeChild(commentToDelete.domNode);
    }
    let lastCommentElement = null;
    const newCommentNodeList = [];
    const newCommentsInEditMode = [];
    for (let i = newCommentsLen - 1; i >= 0; i--) {
      const currentComment = commentThread.comments[i];
      const oldCommentNode = this._commentElements.filter((commentNode) => commentNode.comment.uniqueIdInThread === currentComment.uniqueIdInThread);
      if (oldCommentNode.length) {
        lastCommentElement = oldCommentNode[0].domNode;
        newCommentNodeList.unshift(oldCommentNode[0]);
      } else {
        const newElement = this.createNewCommentNode(currentComment);
        newCommentNodeList.unshift(newElement);
        if (lastCommentElement) {
          this._commentsElement.insertBefore(newElement.domNode, lastCommentElement);
          lastCommentElement = newElement.domNode;
        } else {
          this._commentsElement.appendChild(newElement.domNode);
          lastCommentElement = newElement.domNode;
        }
        if (currentComment.mode === CommentMode.Editing) {
          newElement.switchToEditMode();
          newCommentsInEditMode.push(newElement);
        }
      }
    }
    this._commentThread = commentThread;
    this._commentElements = newCommentNodeList;
    if (newCommentsInEditMode.length) {
      const lastIndex = this._commentElements.indexOf(newCommentsInEditMode[newCommentsInEditMode.length - 1]);
      this._focusedComment = lastIndex;
    }
    this._updateAriaLabel();
    this._setFocusedComment(this._focusedComment);
  }
  _updateAriaLabel() {
    var _a30, _b, _c;
    if (this._commentThread.isDocumentCommentThread()) {
      if (this._commentThread.range) {
        this._commentsElement.ariaLabel = localize(
          "commentThreadAria.withRange",
          "Comment thread with {0} comments on lines {1} through {2}. {3}.",
          (_a30 = this._commentThread.comments) == null ? void 0 : _a30.length,
          this._commentThread.range.startLineNumber,
          this._commentThread.range.endLineNumber,
          this._commentThread.label
        );
      } else {
        this._commentsElement.ariaLabel = localize(
          "commentThreadAria.document",
          "Comment thread with {0} comments on the entire document. {1}.",
          (_b = this._commentThread.comments) == null ? void 0 : _b.length,
          this._commentThread.label
        );
      }
    } else {
      this._commentsElement.ariaLabel = localize(
        "commentThreadAria",
        "Comment thread with {0} comments. {1}.",
        (_c = this._commentThread.comments) == null ? void 0 : _c.length,
        this._commentThread.label
      );
    }
  }
  _setFocusedComment(value) {
    var _a30;
    if (this._focusedComment !== void 0) {
      (_a30 = this._commentElements[this._focusedComment]) == null ? void 0 : _a30.setFocus(false);
    }
    if (this._commentElements.length === 0 || value === void 0) {
      this._focusedComment = void 0;
    } else {
      this._focusedComment = Math.min(value, this._commentElements.length - 1);
      this._commentElements[this._focusedComment].setFocus(true);
    }
  }
  createNewCommentNode(comment) {
    const newCommentNode = this._scopedInstatiationService.createInstance(CommentNode2, this._commentThread, comment, this._pendingEdits ? this._pendingEdits[comment.uniqueIdInThread] : void 0, this.owner, this.parentResourceUri, this._parentCommentThreadWidget, this._markdownRenderer);
    this._register(newCommentNode);
    this._commentDisposable.set(newCommentNode, newCommentNode.onDidClick((clickedNode) => this._setFocusedComment(this._commentElements.findIndex((commentNode) => commentNode.comment.uniqueIdInThread === clickedNode.comment.uniqueIdInThread))));
    return newCommentNode;
  }
  dispose() {
    super.dispose();
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
    this._commentDisposable.forEach((v) => v.dispose());
  }
};
CommentThreadBody = __decorate([
  __param(8, ICommentService),
  __param(9, IOpenerService),
  __param(10, ILanguageService)
], CommentThreadBody);

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadHeader.js
init_dom();
init_actions();
init_codicons();
init_lifecycle();
init_strings();
init_nls();
init_themables();
init_mouseEvent();
var collapseIcon = registerIcon("review-comment-collapse", Codicon.chevronUp, localize("collapseIcon", "Icon to collapse a review comment."));
var COLLAPSE_ACTION_CLASS = "expand-review-action " + ThemeIcon.asClassName(collapseIcon);
var CommentThreadHeader = class extends Disposable {
  constructor(container, _delegate, _commentMenus, _commentThread, _contextKeyService, instantiationService, _contextMenuService) {
    super();
    this._delegate = _delegate;
    this._commentMenus = _commentMenus;
    this._commentThread = _commentThread;
    this._contextKeyService = _contextKeyService;
    this.instantiationService = instantiationService;
    this._contextMenuService = _contextMenuService;
    this._headElement = $(".head");
    container.appendChild(this._headElement);
    this._fillHead();
  }
  _fillHead() {
    const titleElement = append(this._headElement, $(".review-title"));
    this._headingLabel = append(titleElement, $("span.filename"));
    this.createThreadLabel();
    const actionsContainer = append(this._headElement, $(".review-actions"));
    this._actionbarWidget = new ActionBar(actionsContainer, {
      actionViewItemProvider: createActionViewItem.bind(void 0, this.instantiationService)
    });
    this._register(this._actionbarWidget);
    this._collapseAction = new Action("review.expand", localize("label.collapse", "Collapse"), COLLAPSE_ACTION_CLASS, true, () => this._delegate.collapse());
    const menu = this._commentMenus.getCommentThreadTitleActions(this._contextKeyService);
    this.setActionBarActions(menu);
    this._register(menu);
    this._register(menu.onDidChange((e) => {
      this.setActionBarActions(menu);
    }));
    this._register(addDisposableListener(this._headElement, EventType.CONTEXT_MENU, (e) => {
      return this.onContextMenu(e);
    }));
    this._actionbarWidget.context = this._commentThread;
  }
  setActionBarActions(menu) {
    const groups = menu.getActions({ shouldForwardArgs: true }).reduce((r, [, actions]) => [...r, ...actions], []);
    this._actionbarWidget.clear();
    this._actionbarWidget.push([...groups, this._collapseAction], { label: false, icon: true });
  }
  updateCommentThread(commentThread) {
    this._commentThread = commentThread;
    this._actionbarWidget.context = this._commentThread;
    this.createThreadLabel();
  }
  createThreadLabel() {
    let label;
    label = this._commentThread.label;
    if (label === void 0) {
      if (!(this._commentThread.comments && this._commentThread.comments.length)) {
        label = localize("startThread", "Start discussion");
      }
    }
    if (label) {
      this._headingLabel.textContent = escape(label);
      this._headingLabel.setAttribute("aria-label", label);
    }
  }
  updateHeight(headHeight) {
    this._headElement.style.height = `${headHeight}px`;
    this._headElement.style.lineHeight = this._headElement.style.height;
  }
  onContextMenu(e) {
    const actions = this._commentMenus.getCommentThreadTitleContextActions(this._contextKeyService).getActions({ shouldForwardArgs: true }).map((value) => value[1]).flat();
    if (!actions.length) {
      return;
    }
    const event = new StandardMouseEvent(e);
    this._contextMenuService.showContextMenu({
      getAnchor: () => event,
      getActions: () => actions,
      actionRunner: new ActionRunner(),
      getActionsContext: () => {
        return {
          commentControlHandle: this._commentThread.controllerHandle,
          commentThreadHandle: this._commentThread.commentThreadHandle,
          $mid: 7
        };
      }
    });
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadAdditionalActions.js
init_dom();
init_lifecycle();
var CommentThreadAdditionalActions = class extends Disposable {
  constructor(container, _commentThread, _contextKeyService, _commentMenus, _actionRunDelegate) {
    super();
    this._commentThread = _commentThread;
    this._contextKeyService = _contextKeyService;
    this._commentMenus = _commentMenus;
    this._actionRunDelegate = _actionRunDelegate;
    this._container = append(container, $(".comment-additional-actions"));
    append(this._container, $(".section-separator"));
    this._buttonBar = append(this._container, $(".button-bar"));
    this._createAdditionalActions(this._buttonBar);
  }
  _showMenu() {
    var _a30;
    (_a30 = this._container) == null ? void 0 : _a30.classList.remove("hidden");
  }
  _hideMenu() {
    var _a30;
    (_a30 = this._container) == null ? void 0 : _a30.classList.add("hidden");
  }
  _enableDisableMenu(menu) {
    const groups = menu.getActions({ shouldForwardArgs: true });
    for (const group of groups) {
      const [, actions] = group;
      for (const action of actions) {
        if (action.enabled) {
          this._showMenu();
          return;
        }
        for (const subAction of action.actions ?? []) {
          if (subAction.enabled) {
            this._showMenu();
            return;
          }
        }
      }
    }
    this._hideMenu();
  }
  _createAdditionalActions(container) {
    const menu = this._commentMenus.getCommentThreadAdditionalActions(this._contextKeyService);
    this._register(menu);
    this._register(menu.onDidChange(() => {
      this._commentFormActions.setActions(menu, true);
      this._enableDisableMenu(menu);
    }));
    this._commentFormActions = new CommentFormActions(container, async (action) => {
      var _a30;
      (_a30 = this._actionRunDelegate) == null ? void 0 : _a30.call(this);
      action.run({
        thread: this._commentThread,
        $mid: 8
      });
    }, 4);
    this._register(this._commentFormActions);
    this._commentFormActions.setActions(menu, true);
    this._enableDisableMenu(menu);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadWidget.js
init_colorRegistry();

// node_modules/vscode/vscode/src/vs/workbench/browser/actions/widgetNavigationCommands.js
init_tslib_es6();
init_contextkey();
init_keybindingsRegistry();
init_lifecycle();
init_platform2();
var NavigableContainerManager_1;
function handleFocusEventsGroup(group, handler) {
  const focusedIndices = /* @__PURE__ */ new Set();
  return combinedDisposable(...group.map((events, index) => combinedDisposable(events.onDidFocus(() => {
    if (!focusedIndices.size) {
      handler(true);
    }
    focusedIndices.add(index);
  }), events.onDidBlur(() => {
    focusedIndices.delete(index);
    if (!focusedIndices.size) {
      handler(false);
    }
  }))));
}
var NavigableContainerFocusedContextKey = new RawContextKey("navigableContainerFocused", false);
var _a24;
var NavigableContainerManager = (_a24 = class {
  constructor(contextKeyService) {
    this.containers = /* @__PURE__ */ new Set();
    this.focused = NavigableContainerFocusedContextKey.bindTo(contextKeyService);
    NavigableContainerManager_1.INSTANCE = this;
  }
  dispose() {
    this.containers.clear();
    this.focused.reset();
    NavigableContainerManager_1.INSTANCE = void 0;
  }
  static register(container) {
    const instance = this.INSTANCE;
    if (!instance) {
      return Disposable.None;
    }
    instance.containers.add(container);
    return combinedDisposable(handleFocusEventsGroup(container.focusNotifiers, (isFocus) => {
      if (isFocus) {
        instance.focused.set(true);
        instance.lastContainer = container;
      } else if (instance.lastContainer === container) {
        instance.focused.set(false);
        instance.lastContainer = void 0;
      }
    }), toDisposable(() => {
      instance.containers.delete(container);
      if (instance.lastContainer === container) {
        instance.focused.set(false);
        instance.lastContainer = void 0;
      }
    }));
  }
  static getActive() {
    var _a30;
    return (_a30 = this.INSTANCE) == null ? void 0 : _a30.lastContainer;
  }
}, NavigableContainerManager_1 = _a24, _a24);
NavigableContainerManager = NavigableContainerManager_1 = __decorate([
  __param(0, IContextKeyService)
], NavigableContainerManager);
function registerNavigableContainer(container) {
  return NavigableContainerManager.register(container);
}
Registry.as(Extensions.Workbench).registerWorkbenchContribution(NavigableContainerManager, 1);
var _a25;
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "widgetNavigation.focusPrevious",
  weight: 200,
  when: ContextKeyExpr.and(NavigableContainerFocusedContextKey, ContextKeyExpr.or((_a25 = WorkbenchListFocusContextKey) == null ? void 0 : _a25.negate(), WorkbenchListScrollAtTopContextKey)),
  primary: 2048 | 16,
  handler: () => {
    const activeContainer = NavigableContainerManager.getActive();
    activeContainer == null ? void 0 : activeContainer.focusPreviousWidget();
  }
});
var _a26;
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "widgetNavigation.focusNext",
  weight: 200,
  when: ContextKeyExpr.and(NavigableContainerFocusedContextKey, ContextKeyExpr.or(
    (_a26 = WorkbenchListFocusContextKey) == null ? void 0 : _a26.negate(),
    WorkbenchListScrollAtBottomContextKey
  )),
  primary: 2048 | 18,
  handler: () => {
    const activeContainer = NavigableContainerManager.getActive();
    activeContainer == null ? void 0 : activeContainer.focusNextWidget();
  }
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadWidget.js
var CommentThreadWidget = class CommentThreadWidget2 extends Disposable {
  get commentThread() {
    return this._commentThread;
  }
  constructor(container, _owner, _parentResourceUri, _contextKeyService, _scopedInstatiationService, _commentThread, _pendingComment, _pendingEdits, _markdownOptions, _commentOptions, _containerDelegate, commentService, contextMenuService) {
    super();
    this.container = container;
    this._owner = _owner;
    this._parentResourceUri = _parentResourceUri;
    this._contextKeyService = _contextKeyService;
    this._scopedInstatiationService = _scopedInstatiationService;
    this._commentThread = _commentThread;
    this._pendingComment = _pendingComment;
    this._pendingEdits = _pendingEdits;
    this._markdownOptions = _markdownOptions;
    this._commentOptions = _commentOptions;
    this._containerDelegate = _containerDelegate;
    this.commentService = commentService;
    this._commentThreadDisposables = [];
    this._onDidResize = new Emitter();
    this.onDidResize = this._onDidResize.event;
    this._threadIsEmpty = CommentContextKeys.commentThreadIsEmpty.bindTo(this._contextKeyService);
    this._threadIsEmpty.set(!_commentThread.comments || !_commentThread.comments.length);
    this._commentMenus = this.commentService.getCommentMenus(this._owner);
    this._header = new CommentThreadHeader(container, {
      collapse: this.collapse.bind(this)
    }, this._commentMenus, this._commentThread, this._contextKeyService, this._scopedInstatiationService, contextMenuService);
    this._header.updateCommentThread(this._commentThread);
    const bodyElement = $(".body");
    container.appendChild(bodyElement);
    const tracker = this._register(trackFocus(bodyElement));
    this._register(registerNavigableContainer({
      focusNotifiers: [tracker],
      focusNextWidget: () => {
        var _a30, _b;
        if (!((_a30 = this._commentReply) == null ? void 0 : _a30.isCommentEditorFocused())) {
          (_b = this._commentReply) == null ? void 0 : _b.expandReplyAreaAndFocusCommentEditor();
        }
      },
      focusPreviousWidget: () => {
        var _a30, _b;
        if (((_a30 = this._commentReply) == null ? void 0 : _a30.isCommentEditorFocused()) && ((_b = this._commentThread.comments) == null ? void 0 : _b.length)) {
          this._body.focus();
        }
      }
    }));
    this._body = this._scopedInstatiationService.createInstance(CommentThreadBody, this._owner, this._parentResourceUri, bodyElement, this._markdownOptions, this._commentThread, this._pendingEdits, this._scopedInstatiationService, this);
    this._register(this._body);
    this._styleElement = createStyleSheet(this.container);
    this._commentThreadContextValue = CommentContextKeys.commentThreadContext.bindTo(this._contextKeyService);
    this._commentThreadContextValue.set(_commentThread.contextValue);
    const commentControllerKey = CommentContextKeys.commentControllerContext.bindTo(this._contextKeyService);
    const controller = this.commentService.getCommentController(this._owner);
    if (controller == null ? void 0 : controller.contextValue) {
      commentControllerKey.set(controller.contextValue);
    }
    this.currentThreadListeners();
  }
  updateCurrentThread(hasMouse, hasFocus) {
    if (hasMouse || hasFocus) {
      this.commentService.setCurrentCommentThread(this.commentThread);
    } else {
      this.commentService.setCurrentCommentThread(void 0);
    }
  }
  currentThreadListeners() {
    let hasMouse = false;
    let hasFocus = false;
    this._register(addDisposableListener(this.container, EventType.MOUSE_ENTER, (e) => {
      if (e.toElement === this.container) {
        hasMouse = true;
        this.updateCurrentThread(hasMouse, hasFocus);
      }
    }, true));
    this._register(addDisposableListener(this.container, EventType.MOUSE_LEAVE, (e) => {
      if (e.fromElement === this.container) {
        hasMouse = false;
        this.updateCurrentThread(hasMouse, hasFocus);
      }
    }, true));
    this._register(addDisposableListener(this.container, EventType.FOCUS_IN, () => {
      hasFocus = true;
      this.updateCurrentThread(hasMouse, hasFocus);
    }, true));
    this._register(addDisposableListener(this.container, EventType.FOCUS_OUT, () => {
      hasFocus = false;
      this.updateCurrentThread(hasMouse, hasFocus);
    }, true));
  }
  updateCommentThread(commentThread) {
    var _a30;
    this._commentThread = commentThread;
    dispose(this._commentThreadDisposables);
    this._commentThreadDisposables = [];
    this._bindCommentThreadListeners();
    this._body.updateCommentThread(commentThread);
    this._threadIsEmpty.set(!this._body.length);
    this._header.updateCommentThread(commentThread);
    (_a30 = this._commentReply) == null ? void 0 : _a30.updateCommentThread(commentThread);
    if (this._commentThread.contextValue) {
      this._commentThreadContextValue.set(this._commentThread.contextValue);
    } else {
      this._commentThreadContextValue.reset();
    }
  }
  display(lineHeight) {
    const headHeight = Math.ceil(lineHeight * 1.2);
    this._header.updateHeight(headHeight);
    this._body.display();
    if (this._commentThread.canReply) {
      this._createCommentForm();
    }
    this._createAdditionalActions();
    this._register(this._body.onDidResize((dimension) => {
      this._refresh(dimension);
    }));
    if (this._commentThread.canReply && this._commentReply) {
      this._commentReply.focusIfNeeded();
    }
    this._bindCommentThreadListeners();
  }
  _refresh(dimension) {
    this._body.layout();
    this._onDidResize.fire(dimension);
  }
  dispose() {
    super.dispose();
    this.updateCurrentThread(false, false);
  }
  _bindCommentThreadListeners() {
    this._commentThreadDisposables.push(this._commentThread.onDidChangeCanReply(() => {
      if (this._commentReply) {
        this._commentReply.updateCanReply();
      } else {
        if (this._commentThread.canReply) {
          this._createCommentForm();
        }
      }
    }));
    this._commentThreadDisposables.push(this._commentThread.onDidChangeComments(async (_) => {
      await this.updateCommentThread(this._commentThread);
    }));
    this._commentThreadDisposables.push(this._commentThread.onDidChangeLabel((_) => {
      this._header.createThreadLabel();
    }));
  }
  _createCommentForm() {
    this._commentReply = this._scopedInstatiationService.createInstance(CommentReply, this._owner, this._body.container, this._commentThread, this._scopedInstatiationService, this._contextKeyService, this._commentMenus, this._commentOptions, this._pendingComment, this, this._containerDelegate.actionRunner);
    this._register(this._commentReply);
  }
  _createAdditionalActions() {
    this._additionalActions = this._scopedInstatiationService.createInstance(CommentThreadAdditionalActions, this._body.container, this._commentThread, this._contextKeyService, this._commentMenus, this._containerDelegate.actionRunner);
    this._register(this._additionalActions);
  }
  getCommentCoords(commentUniqueId) {
    return this._body.getCommentCoords(commentUniqueId);
  }
  getPendingEdits() {
    return this._body.getPendingEdits();
  }
  getPendingComment() {
    if (this._commentReply) {
      return this._commentReply.getPendingComment();
    }
    return void 0;
  }
  getDimensions() {
    return this._body.getDimensions();
  }
  layout(widthInPixel) {
    var _a30;
    this._body.layout();
    if (widthInPixel !== void 0) {
      (_a30 = this._commentReply) == null ? void 0 : _a30.layout(widthInPixel);
    }
  }
  focusCommentEditor() {
    var _a30;
    (_a30 = this._commentReply) == null ? void 0 : _a30.focusCommentEditor();
  }
  focus() {
    this._body.focus();
  }
  async submitComment() {
    var _a30, _b, _c;
    const activeComment = this._body.activeComment;
    if (activeComment) {
      return activeComment.submitComment();
    } else if ((((_b = (_a30 = this._commentReply) == null ? void 0 : _a30.getPendingComment()) == null ? void 0 : _b.length) ?? 0) > 0) {
      return (_c = this._commentReply) == null ? void 0 : _c.submitComment();
    }
  }
  collapse() {
    this._containerDelegate.collapse();
  }
  applyTheme(theme, fontInfo) {
    var _a30, _b, _c, _d;
    const content = [];
    content.push(`.monaco-editor .review-widget > .body { border-top: 1px solid var(${commentThreadStateColorVar}) }`);
    content.push(`.monaco-editor .review-widget > .head { background-color: var(${commentThreadStateBackgroundColorVar}) }`);
    const linkColor = theme.getColor(textLinkForeground);
    if (linkColor) {
      content.push(`.review-widget .body .comment-body a { color: ${linkColor} }`);
    }
    const linkActiveColor = theme.getColor(textLinkActiveForeground);
    if (linkActiveColor) {
      content.push(`.review-widget .body .comment-body a:hover, a:active { color: ${linkActiveColor} }`);
    }
    const focusColor = theme.getColor(focusBorder);
    if (focusColor) {
      content.push(`.review-widget .body .comment-body a:focus { outline: 1px solid ${focusColor}; }`);
      content.push(`.review-widget .body .monaco-editor.focused { outline: 1px solid ${focusColor}; }`);
    }
    const blockQuoteBackground = theme.getColor(textBlockQuoteBackground);
    if (blockQuoteBackground) {
      content.push(`.review-widget .body .review-comment blockquote { background: ${blockQuoteBackground}; }`);
    }
    const blockQuoteBOrder = theme.getColor(textBlockQuoteBorder);
    if (blockQuoteBOrder) {
      content.push(`.review-widget .body .review-comment blockquote { border-color: ${blockQuoteBOrder}; }`);
    }
    const border = theme.getColor(PANEL_BORDER);
    if (border) {
      content.push(`.review-widget .body .review-comment .review-comment-contents .comment-reactions .action-item a.action-label { border-color: ${border}; }`);
    }
    const hcBorder = theme.getColor(contrastBorder);
    if (hcBorder) {
      content.push(`.review-widget .body .comment-form .review-thread-reply-button { outline-color: ${hcBorder}; }`);
      content.push(`.review-widget .body .monaco-editor { outline: 1px solid ${hcBorder}; }`);
    }
    const errorBorder = theme.getColor(inputValidationErrorBorder);
    if (errorBorder) {
      content.push(`.review-widget .validation-error { border: 1px solid ${errorBorder}; }`);
    }
    const errorBackground = theme.getColor(inputValidationErrorBackground);
    if (errorBackground) {
      content.push(`.review-widget .validation-error { background: ${errorBackground}; }`);
    }
    const errorForeground = theme.getColor(inputValidationErrorForeground);
    if (errorForeground) {
      content.push(`.review-widget .body .comment-form .validation-error { color: ${errorForeground}; }`);
    }
    const fontFamilyVar = "--comment-thread-editor-font-family";
    const fontSizeVar = "--comment-thread-editor-font-size";
    const fontWeightVar = "--comment-thread-editor-font-weight";
    (_a30 = this.container) == null ? void 0 : _a30.style.setProperty(fontFamilyVar, fontInfo.fontFamily);
    (_b = this.container) == null ? void 0 : _b.style.setProperty(fontSizeVar, `${fontInfo.fontSize}px`);
    (_c = this.container) == null ? void 0 : _c.style.setProperty(fontWeightVar, fontInfo.fontWeight);
    content.push(`.review-widget .body code {
			font-family: var(${fontFamilyVar});
			font-weight: var(${fontWeightVar});
		}`);
    this._styleElement.textContent = content.join("\n");
    (_d = this._commentReply) == null ? void 0 : _d.setCommentEditorDecorations();
  }
};
CommentThreadWidget = __decorate([
  __param(11, ICommentService),
  __param(12, IContextMenuService)
], CommentThreadWidget);

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadZoneWidget.js
init_configuration();
function getCommentThreadWidgetStateColor(thread, theme) {
  return getCommentThreadStateBorderColor(thread, theme) ?? theme.getColor(peekViewBorder);
}
function parseMouseDownInfoFromEvent(e) {
  const range = e.target.range;
  if (!range) {
    return null;
  }
  if (!e.event.leftButton) {
    return null;
  }
  if (e.target.type !== 4) {
    return null;
  }
  const data = e.target.detail;
  const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;
  if (gutterOffsetX > 20) {
    return null;
  }
  return { lineNumber: range.startLineNumber };
}
function isMouseUpEventDragFromMouseDown(mouseDownInfo, e) {
  if (!mouseDownInfo) {
    return null;
  }
  const { lineNumber } = mouseDownInfo;
  const range = e.target.range;
  if (!range) {
    return null;
  }
  return lineNumber;
}
var ReviewZoneWidget = class ReviewZoneWidget2 extends ZoneWidget {
  get owner() {
    return this._owner;
  }
  get commentThread() {
    return this._commentThread;
  }
  get expanded() {
    return this._isExpanded;
  }
  constructor(editor, _owner, _commentThread, _pendingComment, _pendingEdits, instantiationService, themeService, commentService, contextKeyService, configurationService) {
    super(editor, { keepEditorSelection: true, isAccessible: true });
    this._owner = _owner;
    this._commentThread = _commentThread;
    this._pendingComment = _pendingComment;
    this._pendingEdits = _pendingEdits;
    this.themeService = themeService;
    this.commentService = commentService;
    this.configurationService = configurationService;
    this._onDidClose = new Emitter();
    this._onDidCreateThread = new Emitter();
    this._globalToDispose = new DisposableStore();
    this._commentThreadDisposables = [];
    this._contextKeyService = contextKeyService.createScoped(this.domNode);
    this._scopedInstantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));
    const controller = this.commentService.getCommentController(this._owner);
    if (controller) {
      this._commentOptions = controller.options;
    }
    this._initialCollapsibleState = _commentThread.initialCollapsibleState;
    this._isExpanded = _commentThread.initialCollapsibleState === CommentThreadCollapsibleState.Expanded;
    this._commentThreadDisposables = [];
    this.create();
    this._globalToDispose.add(this.themeService.onDidColorThemeChange(this._applyTheme, this));
    this._globalToDispose.add(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(49)) {
        this._applyTheme(this.themeService.getColorTheme());
      }
    }));
    this._applyTheme(this.themeService.getColorTheme());
  }
  get onDidClose() {
    return this._onDidClose.event;
  }
  get onDidCreateThread() {
    return this._onDidCreateThread.event;
  }
  getPosition() {
    if (this.position) {
      return this.position;
    }
    if (this._commentGlyph) {
      return this._commentGlyph.getPosition().position ?? void 0;
    }
    return void 0;
  }
  revealRange() {
  }
  reveal(commentUniqueId, focus = false) {
    if (!this._isExpanded) {
      this.show(this.arrowPosition(this._commentThread.range), 2);
    }
    if (commentUniqueId !== void 0) {
      const height = this.editor.getLayoutInfo().height;
      const coords = this._commentThreadWidget.getCommentCoords(commentUniqueId);
      if (coords) {
        let scrollTop = 1;
        if (this._commentThread.range) {
          const commentThreadCoords = coords.thread;
          const commentCoords = coords.comment;
          scrollTop = this.editor.getTopForLineNumber(this._commentThread.range.startLineNumber) - height / 2 + commentCoords.top - commentThreadCoords.top;
        }
        this.editor.setScrollTop(scrollTop);
        return;
      }
    }
    this.editor.revealRangeInCenter(this._commentThread.range ?? new Range(1, 1, 1, 1));
    if (focus) {
      this._commentThreadWidget.focus();
    }
  }
  getPendingComments() {
    return {
      newComment: this._commentThreadWidget.getPendingComment(),
      edits: this._commentThreadWidget.getPendingEdits()
    };
  }
  _fillContainer(container) {
    this.setCssClass("review-widget");
    this._commentThreadWidget = this._scopedInstantiationService.createInstance(CommentThreadWidget, container, this._owner, this.editor.getModel().uri, this._contextKeyService, this._scopedInstantiationService, this._commentThread, this._pendingComment, this._pendingEdits, { editor: this.editor, codeBlockFontSize: "", codeBlockFontFamily: this.configurationService.getValue("editor").fontFamily || EDITOR_FONT_DEFAULTS.fontFamily }, this._commentOptions, {
      actionRunner: () => {
        if (!this._commentThread.comments || !this._commentThread.comments.length) {
          const newPosition = this.getPosition();
          if (newPosition) {
            const originalRange = this._commentThread.range;
            if (!originalRange) {
              return;
            }
            let range;
            if (newPosition.lineNumber !== originalRange.endLineNumber) {
              const distance = newPosition.lineNumber - originalRange.endLineNumber;
              range = new Range(
                originalRange.startLineNumber + distance,
                originalRange.startColumn,
                originalRange.endLineNumber + distance,
                originalRange.endColumn
              );
            } else {
              range = new Range(
                originalRange.startLineNumber,
                originalRange.startColumn,
                originalRange.endLineNumber,
                originalRange.endColumn
              );
            }
            this.commentService.updateCommentThreadTemplate(this.owner, this._commentThread.commentThreadHandle, range);
          }
        }
      },
      collapse: () => {
        this.collapse();
      }
    });
    this._disposables.add(this._commentThreadWidget);
  }
  arrowPosition(range) {
    if (!range) {
      return void 0;
    }
    return { lineNumber: range.endLineNumber, column: range.endLineNumber === range.startLineNumber ? (range.startColumn + range.endColumn + 1) / 2 : 1 };
  }
  deleteCommentThread() {
    this.dispose();
    this.commentService.disposeCommentThread(this.owner, this._commentThread.threadId);
  }
  collapse() {
    this._commentThread.collapsibleState = CommentThreadCollapsibleState.Collapsed;
  }
  expand() {
    this._commentThread.collapsibleState = CommentThreadCollapsibleState.Expanded;
  }
  getGlyphPosition() {
    if (this._commentGlyph) {
      return this._commentGlyph.getPosition().position.lineNumber;
    }
    return 0;
  }
  toggleExpand() {
    if (this._isExpanded) {
      this._commentThread.collapsibleState = CommentThreadCollapsibleState.Collapsed;
    } else {
      this._commentThread.collapsibleState = CommentThreadCollapsibleState.Expanded;
    }
  }
  async update(commentThread) {
    var _a30;
    if (this._commentThread !== commentThread) {
      this._commentThreadDisposables.forEach((disposable) => disposable.dispose());
      this._commentThread = commentThread;
      this._commentThreadDisposables = [];
      this.bindCommentThreadListeners();
    }
    this._commentThreadWidget.updateCommentThread(commentThread);
    const lineNumber = ((_a30 = this._commentThread.range) == null ? void 0 : _a30.endLineNumber) ?? 1;
    let shouldMoveWidget = false;
    if (this._commentGlyph) {
      this._commentGlyph.setThreadState(commentThread.state);
      if (this._commentGlyph.getPosition().position.lineNumber !== lineNumber) {
        shouldMoveWidget = true;
        this._commentGlyph.setLineNumber(lineNumber);
      }
    }
    if (shouldMoveWidget && this._isExpanded) {
      this.show(this.arrowPosition(this._commentThread.range), 2);
    }
    if (this._commentThread.collapsibleState === CommentThreadCollapsibleState.Expanded) {
      this.show(this.arrowPosition(this._commentThread.range), 2);
    } else {
      this.hide();
    }
  }
  _onWidth(widthInPixel) {
    this._commentThreadWidget.layout(widthInPixel);
  }
  _doLayout(heightInPixel, widthInPixel) {
    this._commentThreadWidget.layout(widthInPixel);
  }
  display(range) {
    if (range) {
      this._commentGlyph = new CommentGlyphWidget(this.editor, (range == null ? void 0 : range.endLineNumber) ?? -1);
      this._commentGlyph.setThreadState(this._commentThread.state);
    }
    this._commentThreadWidget.display(this.editor.getOption(65));
    this._disposables.add(this._commentThreadWidget.onDidResize((dimension) => {
      this._refresh(dimension);
    }));
    if (this._commentThread.collapsibleState === CommentThreadCollapsibleState.Expanded || range === void 0) {
      this.show(this.arrowPosition(range), 2);
    }
    if (this._commentThread.canReply && this._commentThread.isTemplate && (!this._commentThread.comments || this._commentThread.comments.length === 0)) {
      this.reveal();
    }
    this.bindCommentThreadListeners();
  }
  bindCommentThreadListeners() {
    this._commentThreadDisposables.push(this._commentThread.onDidChangeComments(async (_) => {
      await this.update(this._commentThread);
    }));
    this._commentThreadDisposables.push(this._commentThread.onDidChangeRange((range) => {
      var _a30;
      const lineNumber = ((_a30 = this._commentThread.range) == null ? void 0 : _a30.startLineNumber) ?? 1;
      let shouldMoveWidget = false;
      if (this._commentGlyph) {
        if (this._commentGlyph.getPosition().position.lineNumber !== lineNumber) {
          shouldMoveWidget = true;
          this._commentGlyph.setLineNumber(lineNumber);
        }
      }
      if (shouldMoveWidget && this._isExpanded) {
        this.show(this.arrowPosition(this._commentThread.range), 2);
      }
    }));
    this._commentThreadDisposables.push(this._commentThread.onDidChangeCollapsibleState((state) => {
      if (state === CommentThreadCollapsibleState.Expanded && !this._isExpanded) {
        this.show(this.arrowPosition(this._commentThread.range), 2);
        return;
      }
      if (state === CommentThreadCollapsibleState.Collapsed && this._isExpanded) {
        this.hide();
        return;
      }
    }));
    if (this._initialCollapsibleState === void 0) {
      const onDidChangeInitialCollapsibleState = this._commentThread.onDidChangeInitialCollapsibleState((state) => {
        this._initialCollapsibleState = this._commentThread.range ? state : CommentThreadCollapsibleState.Expanded;
        this._commentThread.collapsibleState = this._initialCollapsibleState;
        onDidChangeInitialCollapsibleState.dispose();
      });
      this._commentThreadDisposables.push(onDidChangeInitialCollapsibleState);
    }
    this._commentThreadDisposables.push(this._commentThread.onDidChangeState(() => {
      var _a30, _b;
      const borderColor = getCommentThreadWidgetStateColor(this._commentThread.state, this.themeService.getColorTheme()) || Color2.transparent;
      this.style({
        frameColor: borderColor,
        arrowColor: borderColor
      });
      (_a30 = this.container) == null ? void 0 : _a30.style.setProperty(commentThreadStateColorVar, `${borderColor}`);
      (_b = this.container) == null ? void 0 : _b.style.setProperty(commentThreadStateBackgroundColorVar, `${borderColor.transparent(0.1)}`);
    }));
  }
  async submitComment() {
    return this._commentThreadWidget.submitComment();
  }
  _refresh(dimensions) {
    var _a30;
    if (dimensions.height === 0 && dimensions.width === 0) {
      this.commentThread.collapsibleState = CommentThreadCollapsibleState.Collapsed;
      return;
    }
    if (this._isExpanded) {
      this._commentThreadWidget.layout();
      const headHeight = Math.ceil(this.editor.getOption(65) * 1.2);
      const lineHeight = this.editor.getOption(65);
      const arrowHeight = Math.round(lineHeight / 3);
      const frameThickness = Math.round(lineHeight / 9) * 2;
      const computedLinesNumber = Math.ceil((headHeight + dimensions.height + arrowHeight + frameThickness + 8) / lineHeight);
      if (((_a30 = this._viewZone) == null ? void 0 : _a30.heightInLines) === computedLinesNumber) {
        return;
      }
      const currentPosition = this.getPosition();
      if (this._viewZone && currentPosition && currentPosition.lineNumber !== this._viewZone.afterLineNumber && this._viewZone.afterLineNumber !== 0) {
        this._viewZone.afterLineNumber = currentPosition.lineNumber;
      }
      if (!this._commentThread.comments || !this._commentThread.comments.length) {
        this._commentThreadWidget.focusCommentEditor();
      }
      this._relayout(computedLinesNumber);
    }
  }
  _applyTheme(theme) {
    const borderColor = getCommentThreadWidgetStateColor(this._commentThread.state, this.themeService.getColorTheme()) || Color2.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor
    });
    const fontInfo = this.editor.getOption(49);
    this._commentThreadWidget.applyTheme(theme, fontInfo);
  }
  show(rangeOrPos, heightInLines) {
    this._isExpanded = true;
    super.show(rangeOrPos ?? new Range(0, 0, 0, 0), heightInLines);
    this._commentThread.collapsibleState = CommentThreadCollapsibleState.Expanded;
    this._refresh(this._commentThreadWidget.getDimensions());
  }
  hide() {
    if (this._isExpanded) {
      this._isExpanded = false;
      if (this.editor.hasWidgetFocus()) {
        this.editor.focus();
      }
      if (!this._commentThread.comments || !this._commentThread.comments.length) {
        this.deleteCommentThread();
      }
    }
    super.hide();
  }
  dispose() {
    super.dispose();
    if (this._commentGlyph) {
      this._commentGlyph.dispose();
      this._commentGlyph = void 0;
    }
    this._globalToDispose.dispose();
    this._commentThreadDisposables.forEach((global2) => global2.dispose());
    this._onDidClose.fire(void 0);
  }
};
ReviewZoneWidget = __decorate([
  __param(5, IInstantiationService),
  __param(6, IThemeService),
  __param(7, ICommentService),
  __param(8, IContextKeyService),
  __param(9, IConfigurationService)
], ReviewZoneWidget);

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsController.js
init_configuration();
init_event();
init_contextkey();

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentThreadRangeDecorator.js
init_lifecycle();
init_languages();
init_textModel();
var CommentThreadRangeDecoration = class {
  get id() {
    return this._decorationId;
  }
  set id(id) {
    this._decorationId = id;
  }
  constructor(range, options) {
    this.range = range;
    this.options = options;
  }
};
var _CommentThreadRangeDecorator = class _CommentThreadRangeDecorator extends Disposable {
  constructor(commentService) {
    super();
    this.decorationIds = [];
    this.activeDecorationIds = [];
    this.threadCollapseStateListeners = [];
    const decorationOptions = {
      description: _CommentThreadRangeDecorator.description,
      isWholeLine: false,
      zIndex: 20,
      className: "comment-thread-range",
      shouldFillLineOnLineBreak: true
    };
    this.decorationOptions = ModelDecorationOptions.createDynamic(decorationOptions);
    const activeDecorationOptions = {
      description: _CommentThreadRangeDecorator.description,
      isWholeLine: false,
      zIndex: 20,
      className: "comment-thread-range-current",
      shouldFillLineOnLineBreak: true
    };
    this.activeDecorationOptions = ModelDecorationOptions.createDynamic(activeDecorationOptions);
    this._register(commentService.onDidChangeCurrentCommentThread((thread) => {
      this.updateCurrent(thread);
    }));
    this._register(commentService.onDidUpdateCommentThreads(() => {
      this.updateCurrent(void 0);
    }));
  }
  updateCurrent(thread) {
    var _a30, _b, _c;
    if (!this.editor || (thread == null ? void 0 : thread.resource) && ((_a30 = thread.resource) == null ? void 0 : _a30.toString()) !== ((_b = this.editor.getModel()) == null ? void 0 : _b.uri.toString())) {
      return;
    }
    (_c = this.currentThreadCollapseStateListener) == null ? void 0 : _c.dispose();
    const newDecoration = [];
    if (thread) {
      const range = thread.range;
      if (range && !(range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn)) {
        if (thread.collapsibleState === CommentThreadCollapsibleState.Expanded) {
          this.currentThreadCollapseStateListener = thread.onDidChangeCollapsibleState((state) => {
            if (state === CommentThreadCollapsibleState.Collapsed) {
              this.updateCurrent(void 0);
            }
          });
          newDecoration.push(new CommentThreadRangeDecoration(range, this.activeDecorationOptions));
        }
      }
    }
    this.editor.changeDecorations((changeAccessor) => {
      this.activeDecorationIds = changeAccessor.deltaDecorations(this.activeDecorationIds, newDecoration);
      newDecoration.forEach((decoration, index) => decoration.id = this.decorationIds[index]);
    });
  }
  update(editor, commentInfos) {
    const model = editor == null ? void 0 : editor.getModel();
    if (!editor || !model) {
      return;
    }
    dispose(this.threadCollapseStateListeners);
    this.editor = editor;
    const commentThreadRangeDecorations = [];
    for (const info of commentInfos) {
      info.threads.forEach((thread) => {
        if (thread.isDisposed) {
          return;
        }
        const range = thread.range;
        if (!range || range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
          return;
        }
        this.threadCollapseStateListeners.push(thread.onDidChangeCollapsibleState(() => {
          this.update(editor, commentInfos);
        }));
        if (thread.collapsibleState === CommentThreadCollapsibleState.Collapsed) {
          return;
        }
        commentThreadRangeDecorations.push(new CommentThreadRangeDecoration(range, this.decorationOptions));
      });
    }
    editor.changeDecorations((changeAccessor) => {
      this.decorationIds = changeAccessor.deltaDecorations(this.decorationIds, commentThreadRangeDecorations);
      commentThreadRangeDecorations.forEach((decoration, index) => decoration.id = this.decorationIds[index]);
    });
  }
  dispose() {
    var _a30;
    dispose(this.threadCollapseStateListeners);
    (_a30 = this.currentThreadCollapseStateListener) == null ? void 0 : _a30.dispose();
    super.dispose();
  }
};
_CommentThreadRangeDecorator.description = "comment-thread-range-decorator";
var CommentThreadRangeDecorator = _CommentThreadRangeDecorator;

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsController.js
var ID = "editor.contrib.review";
var CommentingRangeDecoration = class {
  get id() {
    return this._decorationId;
  }
  set id(id) {
    this._decorationId = id;
  }
  get range() {
    return {
      startLineNumber: this._startLineNumber,
      startColumn: 1,
      endLineNumber: this._endLineNumber,
      endColumn: 1
    };
  }
  constructor(_editor, _ownerId, _extensionId, _label, _range, options, commentingRangesInfo, isHover = false) {
    this._editor = _editor;
    this._ownerId = _ownerId;
    this._extensionId = _extensionId;
    this._label = _label;
    this._range = _range;
    this.options = options;
    this.commentingRangesInfo = commentingRangesInfo;
    this.isHover = isHover;
    this._startLineNumber = _range.startLineNumber;
    this._endLineNumber = _range.endLineNumber;
  }
  getCommentAction() {
    return {
      extensionId: this._extensionId,
      label: this._label,
      ownerId: this._ownerId,
      commentingRangesInfo: this.commentingRangesInfo
    };
  }
  getOriginalRange() {
    return this._range;
  }
  getActiveRange() {
    return this.id ? this._editor.getModel().getDecorationRange(this.id) : void 0;
  }
};
var _CommentingRangeDecorator = class _CommentingRangeDecorator {
  constructor() {
    this.commentingRangeDecorations = [];
    this.decorationIds = [];
    this._lastHover = -1;
    this._onDidChangeDecorationsCount = new Emitter();
    this.onDidChangeDecorationsCount = this._onDidChangeDecorationsCount.event;
    const decorationOptions = {
      description: _CommentingRangeDecorator.description,
      isWholeLine: true,
      linesDecorationsClassName: "comment-range-glyph comment-diff-added"
    };
    this.decorationOptions = ModelDecorationOptions.createDynamic(decorationOptions);
    const hoverDecorationOptions = {
      description: _CommentingRangeDecorator.description,
      isWholeLine: true,
      linesDecorationsClassName: `comment-range-glyph line-hover`
    };
    this.hoverDecorationOptions = ModelDecorationOptions.createDynamic(hoverDecorationOptions);
    const multilineDecorationOptions = {
      description: _CommentingRangeDecorator.description,
      isWholeLine: true,
      linesDecorationsClassName: `comment-range-glyph multiline-add`
    };
    this.multilineDecorationOptions = ModelDecorationOptions.createDynamic(multilineDecorationOptions);
  }
  updateHover(hoverLine) {
    if (this._editor && this._infos && hoverLine !== this._lastHover) {
      this._doUpdate(this._editor, this._infos, hoverLine);
    }
    this._lastHover = hoverLine ?? -1;
  }
  updateSelection(cursorLine, range = new Range(0, 0, 0, 0)) {
    this._lastSelection = range.isEmpty() ? void 0 : range;
    this._lastSelectionCursor = range.isEmpty() ? void 0 : cursorLine;
    if (this._editor && this._infos) {
      this._doUpdate(this._editor, this._infos, cursorLine, range);
    }
  }
  update(editor, commentInfos, cursorLine, range) {
    if (editor) {
      this._editor = editor;
      this._infos = commentInfos;
      this._doUpdate(editor, commentInfos, cursorLine, range);
    }
  }
  _lineHasThread(editor, lineRange) {
    var _a30;
    return (_a30 = editor.getDecorationsInRange(lineRange)) == null ? void 0 : _a30.find((decoration) => decoration.options.description === CommentGlyphWidget.description);
  }
  _doUpdate(editor, commentInfos, emphasisLine = -1, selectionRange = this._lastSelection) {
    const model = editor.getModel();
    if (!model) {
      return;
    }
    emphasisLine = this._lastSelectionCursor ?? emphasisLine;
    const commentingRangeDecorations = [];
    for (const info of commentInfos) {
      info.commentingRanges.ranges.forEach((range) => {
        const rangeObject = new Range(
          range.startLineNumber,
          range.startColumn,
          range.endLineNumber,
          range.endColumn
        );
        let intersectingSelectionRange = selectionRange ? rangeObject.intersectRanges(selectionRange) : void 0;
        if (selectionRange && emphasisLine >= 0 && intersectingSelectionRange && !(intersectingSelectionRange.startLineNumber === intersectingSelectionRange.endLineNumber && emphasisLine === intersectingSelectionRange.startLineNumber)) {
          let intersectingEmphasisRange;
          if (emphasisLine <= intersectingSelectionRange.startLineNumber) {
            intersectingEmphasisRange = intersectingSelectionRange.collapseToStart();
            intersectingSelectionRange = new Range(
              intersectingSelectionRange.startLineNumber + 1,
              1,
              intersectingSelectionRange.endLineNumber,
              1
            );
          } else {
            intersectingEmphasisRange = new Range(
              intersectingSelectionRange.endLineNumber,
              1,
              intersectingSelectionRange.endLineNumber,
              1
            );
            intersectingSelectionRange = new Range(
              intersectingSelectionRange.startLineNumber,
              1,
              intersectingSelectionRange.endLineNumber - 1,
              1
            );
          }
          commentingRangeDecorations.push(new CommentingRangeDecoration(
            editor,
            info.owner,
            info.extensionId,
            info.label,
            intersectingSelectionRange,
            this.multilineDecorationOptions,
            info.commentingRanges,
            true
          ));
          if (!this._lineHasThread(editor, intersectingEmphasisRange)) {
            commentingRangeDecorations.push(new CommentingRangeDecoration(
              editor,
              info.owner,
              info.extensionId,
              info.label,
              intersectingEmphasisRange,
              this.hoverDecorationOptions,
              info.commentingRanges,
              true
            ));
          }
          const beforeRangeEndLine = Math.min(intersectingEmphasisRange.startLineNumber, intersectingSelectionRange.startLineNumber) - 1;
          const hasBeforeRange = rangeObject.startLineNumber <= beforeRangeEndLine;
          const afterRangeStartLine = Math.max(intersectingEmphasisRange.endLineNumber, intersectingSelectionRange.endLineNumber) + 1;
          const hasAfterRange = rangeObject.endLineNumber >= afterRangeStartLine;
          if (hasBeforeRange) {
            const beforeRange = new Range(range.startLineNumber, 1, beforeRangeEndLine, 1);
            commentingRangeDecorations.push(new CommentingRangeDecoration(
              editor,
              info.owner,
              info.extensionId,
              info.label,
              beforeRange,
              this.decorationOptions,
              info.commentingRanges,
              true
            ));
          }
          if (hasAfterRange) {
            const afterRange = new Range(afterRangeStartLine, 1, range.endLineNumber, 1);
            commentingRangeDecorations.push(new CommentingRangeDecoration(
              editor,
              info.owner,
              info.extensionId,
              info.label,
              afterRange,
              this.decorationOptions,
              info.commentingRanges,
              true
            ));
          }
        } else if (rangeObject.startLineNumber <= emphasisLine && emphasisLine <= rangeObject.endLineNumber) {
          if (rangeObject.startLineNumber < emphasisLine) {
            const beforeRange = new Range(range.startLineNumber, 1, emphasisLine - 1, 1);
            commentingRangeDecorations.push(new CommentingRangeDecoration(
              editor,
              info.owner,
              info.extensionId,
              info.label,
              beforeRange,
              this.decorationOptions,
              info.commentingRanges,
              true
            ));
          }
          const emphasisRange = new Range(emphasisLine, 1, emphasisLine, 1);
          if (!this._lineHasThread(editor, emphasisRange)) {
            commentingRangeDecorations.push(new CommentingRangeDecoration(
              editor,
              info.owner,
              info.extensionId,
              info.label,
              emphasisRange,
              this.hoverDecorationOptions,
              info.commentingRanges,
              true
            ));
          }
          if (emphasisLine < rangeObject.endLineNumber) {
            const afterRange = new Range(emphasisLine + 1, 1, range.endLineNumber, 1);
            commentingRangeDecorations.push(new CommentingRangeDecoration(
              editor,
              info.owner,
              info.extensionId,
              info.label,
              afterRange,
              this.decorationOptions,
              info.commentingRanges,
              true
            ));
          }
        } else {
          commentingRangeDecorations.push(new CommentingRangeDecoration(
            editor,
            info.owner,
            info.extensionId,
            info.label,
            range,
            this.decorationOptions,
            info.commentingRanges
          ));
        }
      });
    }
    editor.changeDecorations((accessor) => {
      this.decorationIds = accessor.deltaDecorations(this.decorationIds, commentingRangeDecorations);
      commentingRangeDecorations.forEach((decoration, index) => decoration.id = this.decorationIds[index]);
    });
    const rangesDifference = this.commentingRangeDecorations.length - commentingRangeDecorations.length;
    this.commentingRangeDecorations = commentingRangeDecorations;
    if (rangesDifference) {
      this._onDidChangeDecorationsCount.fire(this.commentingRangeDecorations.length);
    }
  }
  getMatchedCommentAction(commentRange) {
    var _a30;
    if (commentRange === void 0) {
      const foundInfos = (_a30 = this._infos) == null ? void 0 : _a30.filter((info) => info.commentingRanges.fileComments);
      if (foundInfos) {
        return foundInfos.map((foundInfo) => {
          return {
            ownerId: foundInfo.owner,
            extensionId: foundInfo.extensionId,
            label: foundInfo.label,
            commentingRangesInfo: foundInfo.commentingRanges
          };
        });
      }
      return [];
    }
    const foundHoverActions = /* @__PURE__ */ new Map();
    for (const decoration of this.commentingRangeDecorations) {
      const range = decoration.getActiveRange();
      if (range && (range.startLineNumber <= commentRange.startLineNumber || commentRange.endLineNumber <= range.endLineNumber)) {
        const action = decoration.getCommentAction();
        const alreadyFoundInfo = foundHoverActions.get(action.ownerId);
        if ((alreadyFoundInfo == null ? void 0 : alreadyFoundInfo.action.commentingRangesInfo) === action.commentingRangesInfo) {
          const newRange = new Range(
            range.startLineNumber < alreadyFoundInfo.range.startLineNumber ? range.startLineNumber : alreadyFoundInfo.range.startLineNumber,
            range.startColumn < alreadyFoundInfo.range.startColumn ? range.startColumn : alreadyFoundInfo.range.startColumn,
            range.endLineNumber > alreadyFoundInfo.range.endLineNumber ? range.endLineNumber : alreadyFoundInfo.range.endLineNumber,
            range.endColumn > alreadyFoundInfo.range.endColumn ? range.endColumn : alreadyFoundInfo.range.endColumn
          );
          foundHoverActions.set(action.ownerId, { range: newRange, action });
        } else {
          foundHoverActions.set(action.ownerId, { range, action });
        }
      }
    }
    return Array.from(foundHoverActions.values()).filter((action) => {
      return action.range.startLineNumber <= commentRange.startLineNumber && commentRange.endLineNumber <= action.range.endLineNumber;
    }).map((actions) => actions.action);
  }
  dispose() {
    this.commentingRangeDecorations = [];
  }
};
_CommentingRangeDecorator.description = "commenting-range-decorator";
var CommentingRangeDecorator = _CommentingRangeDecorator;
var ActiveCursorHasCommentingRange = new RawContextKey("activeCursorHasCommentingRange", false, {
  description: localize(
    "hasCommentingRange",
    "Whether the position at the active cursor has a commenting range"
  ),
  type: "boolean"
});
var CommentController = class CommentController2 {
  constructor(editor, commentService, instantiationService, codeEditorService, contextMenuService, quickInputService, viewsService, configurationService, contextKeyService, editorService) {
    this.commentService = commentService;
    this.instantiationService = instantiationService;
    this.codeEditorService = codeEditorService;
    this.contextMenuService = contextMenuService;
    this.quickInputService = quickInputService;
    this.viewsService = viewsService;
    this.configurationService = configurationService;
    this.editorService = editorService;
    this.globalToDispose = new DisposableStore();
    this.localToDispose = new DisposableStore();
    this.mouseDownInfo = null;
    this._commentingRangeSpaceReserved = false;
    this._emptyThreadsToAddQueue = [];
    this._editorDisposables = [];
    this._commentInfos = [];
    this._commentWidgets = [];
    this._pendingNewCommentCache = {};
    this._pendingEditsCache = {};
    this._computePromise = null;
    this._activeCursorHasCommentingRange = ActiveCursorHasCommentingRange.bindTo(contextKeyService);
    if (editor instanceof EmbeddedCodeEditorWidget) {
      return;
    }
    this.editor = editor;
    this._commentingRangeDecorator = new CommentingRangeDecorator();
    this.globalToDispose.add(this._commentingRangeDecorator.onDidChangeDecorationsCount((count2) => {
      if (count2 === 0) {
        this.clearEditorListeners();
      } else if (this._editorDisposables.length === 0) {
        this.registerEditorListeners();
      }
    }));
    this.globalToDispose.add(this._commentThreadRangeDecorator = new CommentThreadRangeDecorator(this.commentService));
    this.globalToDispose.add(this.commentService.onDidDeleteDataProvider((ownerId) => {
      if (ownerId) {
        delete this._pendingNewCommentCache[ownerId];
        delete this._pendingEditsCache[ownerId];
      } else {
        this._pendingNewCommentCache = {};
        this._pendingEditsCache = {};
      }
      this.beginCompute();
    }));
    this.globalToDispose.add(this.commentService.onDidSetDataProvider((_) => this.beginCompute()));
    this.globalToDispose.add(this.commentService.onDidUpdateCommentingRanges((_) => this.beginCompute()));
    this.globalToDispose.add(this.commentService.onDidSetResourceCommentInfos((e) => {
      const editorURI = this.editor && this.editor.hasModel() && this.editor.getModel().uri;
      if (editorURI && editorURI.toString() === e.resource.toString()) {
        this.setComments(e.commentInfos.filter((commentInfo) => commentInfo !== null));
      }
    }));
    this.globalToDispose.add(this.commentService.onDidChangeCommentingEnabled((e) => {
      if (e) {
        this.registerEditorListeners();
        this.beginCompute();
      } else {
        this.tryUpdateReservedSpace();
        this.clearEditorListeners();
        this._commentingRangeDecorator.update(this.editor, []);
        this._commentThreadRangeDecorator.update(this.editor, []);
        dispose(this._commentWidgets);
        this._commentWidgets = [];
      }
    }));
    this.globalToDispose.add(this.editor.onDidChangeModel((_) => this.onModelChanged()));
    this.globalToDispose.add(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("diffEditor.renderSideBySide")) {
        this.beginCompute();
      }
    }));
    this.onModelChanged();
    this.codeEditorService.registerDecorationType("comment-controller", COMMENTEDITOR_DECORATION_KEY, {});
    this.beginCompute();
  }
  registerEditorListeners() {
    this._editorDisposables = [];
    if (!this.editor) {
      return;
    }
    this._editorDisposables.push(this.editor.onMouseMove((e) => this.onEditorMouseMove(e)));
    this._editorDisposables.push(this.editor.onDidChangeCursorPosition((e) => this.onEditorChangeCursorPosition(e.position)));
    this._editorDisposables.push(this.editor.onDidFocusEditorWidget(() => {
      var _a30;
      return this.onEditorChangeCursorPosition(((_a30 = this.editor) == null ? void 0 : _a30.getPosition()) ?? null);
    }));
    this._editorDisposables.push(this.editor.onDidChangeCursorSelection((e) => this.onEditorChangeCursorSelection(e)));
    this._editorDisposables.push(this.editor.onDidBlurEditorWidget(() => this.onEditorChangeCursorSelection()));
  }
  clearEditorListeners() {
    dispose(this._editorDisposables);
    this._editorDisposables = [];
  }
  onEditorMouseMove(e) {
    var _a30;
    const position = (_a30 = e.target.position) == null ? void 0 : _a30.lineNumber;
    if (e.event.leftButton.valueOf() && position && this.mouseDownInfo) {
      this._commentingRangeDecorator.updateSelection(position, new Range(this.mouseDownInfo.lineNumber, 1, position, 1));
    } else {
      this._commentingRangeDecorator.updateHover(position);
    }
  }
  onEditorChangeCursorSelection(e) {
    var _a30, _b;
    const position = (_b = (_a30 = this.editor) == null ? void 0 : _a30.getPosition()) == null ? void 0 : _b.lineNumber;
    if (position) {
      this._commentingRangeDecorator.updateSelection(position, e == null ? void 0 : e.selection);
    }
  }
  onEditorChangeCursorPosition(e) {
    var _a30;
    const decorations = e ? (_a30 = this.editor) == null ? void 0 : _a30.getDecorationsInRange(Range.fromPositions(e, { column: -1, lineNumber: e.lineNumber })) : void 0;
    let hasCommentingRange = false;
    if (decorations) {
      for (const decoration of decorations) {
        if (decoration.options.description === CommentGlyphWidget.description) {
          hasCommentingRange = false;
          break;
        } else if (decoration.options.description === CommentingRangeDecorator.description) {
          hasCommentingRange = true;
        }
      }
    }
    this._activeCursorHasCommentingRange.set(hasCommentingRange);
  }
  isEditorInlineOriginal(testEditor) {
    if (this.configurationService.getValue("diffEditor.renderSideBySide")) {
      return false;
    }
    const foundEditor = this.editorService.visibleTextEditorControls.find((editor) => {
      if (editor.getEditorType() === EditorType.IDiffEditor) {
        const diffEditor = editor;
        return diffEditor.getOriginalEditor() === testEditor;
      }
      return false;
    });
    return !!foundEditor;
  }
  beginCompute() {
    this._computePromise = createCancelablePromise((token) => {
      const editorURI = this.editor && this.editor.hasModel() && this.editor.getModel().uri;
      if (editorURI) {
        return this.commentService.getDocumentComments(editorURI);
      }
      return Promise.resolve([]);
    });
    return this._computePromise.then((commentInfos) => {
      this.setComments(coalesce(commentInfos));
      this._computePromise = null;
    }, (error) => console.log(error));
  }
  beginComputeCommentingRanges() {
    if (this._computeCommentingRangeScheduler) {
      if (this._computeCommentingRangePromise) {
        this._computeCommentingRangePromise.cancel();
        this._computeCommentingRangePromise = null;
      }
      this._computeCommentingRangeScheduler.trigger(() => {
        const editorURI = this.editor && this.editor.hasModel() && this.editor.getModel().uri;
        if (editorURI) {
          return this.commentService.getDocumentComments(editorURI);
        }
        return Promise.resolve([]);
      }).then((commentInfos) => {
        var _a30, _b, _c;
        if (this.commentService.isCommentingEnabled) {
          const meaningfulCommentInfos = coalesce(commentInfos);
          this._commentingRangeDecorator.update(this.editor, meaningfulCommentInfos, (_b = (_a30 = this.editor) == null ? void 0 : _a30.getPosition()) == null ? void 0 : _b.lineNumber, ((_c = this.editor) == null ? void 0 : _c.getSelection()) ?? void 0);
        }
      }, (err) => {
        onUnexpectedError(err);
        return null;
      });
    }
  }
  static get(editor) {
    return editor.getContribution(ID);
  }
  revealCommentThread(threadId, commentUniqueId, fetchOnceIfNotExist) {
    const commentThreadWidget = this._commentWidgets.filter((widget) => widget.commentThread.threadId === threadId);
    if (commentThreadWidget.length === 1) {
      commentThreadWidget[0].reveal(commentUniqueId);
    } else if (fetchOnceIfNotExist) {
      if (this._computePromise) {
        this._computePromise.then((_) => {
          this.revealCommentThread(threadId, commentUniqueId, false);
        });
      } else {
        this.beginCompute().then((_) => {
          this.revealCommentThread(threadId, commentUniqueId, false);
        });
      }
    }
  }
  collapseAll() {
    for (const widget of this._commentWidgets) {
      widget.collapse();
    }
  }
  expandAll() {
    for (const widget of this._commentWidgets) {
      widget.expand();
    }
  }
  expandUnresolved() {
    for (const widget of this._commentWidgets) {
      if (widget.commentThread.state === CommentThreadState.Unresolved) {
        widget.expand();
      }
    }
  }
  nextCommentThread() {
    this._findNearestCommentThread();
  }
  _findNearestCommentThread(reverse) {
    var _a30;
    if (!this._commentWidgets.length || !((_a30 = this.editor) == null ? void 0 : _a30.hasModel())) {
      return;
    }
    const after = this.editor.getSelection().getEndPosition();
    const sortedWidgets = this._commentWidgets.sort((a, b) => {
      if (reverse) {
        const temp = a;
        a = b;
        b = temp;
      }
      if (a.commentThread.range === void 0) {
        return -1;
      }
      if (b.commentThread.range === void 0) {
        return 1;
      }
      if (a.commentThread.range.startLineNumber < b.commentThread.range.startLineNumber) {
        return -1;
      }
      if (a.commentThread.range.startLineNumber > b.commentThread.range.startLineNumber) {
        return 1;
      }
      if (a.commentThread.range.startColumn < b.commentThread.range.startColumn) {
        return -1;
      }
      if (a.commentThread.range.startColumn > b.commentThread.range.startColumn) {
        return 1;
      }
      return 0;
    });
    const idx = findFirstInSorted(sortedWidgets, (widget) => {
      var _a31, _b, _c, _d;
      const lineValueOne = reverse ? after.lineNumber : ((_a31 = widget.commentThread.range) == null ? void 0 : _a31.startLineNumber) ?? 0;
      const lineValueTwo = reverse ? ((_b = widget.commentThread.range) == null ? void 0 : _b.startLineNumber) ?? 0 : after.lineNumber;
      const columnValueOne = reverse ? after.column : ((_c = widget.commentThread.range) == null ? void 0 : _c.startColumn) ?? 0;
      const columnValueTwo = reverse ? ((_d = widget.commentThread.range) == null ? void 0 : _d.startColumn) ?? 0 : after.column;
      if (lineValueOne > lineValueTwo) {
        return true;
      }
      if (lineValueOne < lineValueTwo) {
        return false;
      }
      if (columnValueOne > columnValueTwo) {
        return true;
      }
      return false;
    });
    let nextWidget;
    if (idx === this._commentWidgets.length) {
      nextWidget = this._commentWidgets[0];
    } else {
      nextWidget = sortedWidgets[idx];
    }
    this.editor.setSelection(nextWidget.commentThread.range ?? new Range(1, 1, 1, 1));
    nextWidget.reveal(void 0, true);
  }
  previousCommentThread() {
    this._findNearestCommentThread(true);
  }
  dispose() {
    this.globalToDispose.dispose();
    this.localToDispose.dispose();
    dispose(this._editorDisposables);
    dispose(this._commentWidgets);
    this.editor = null;
  }
  onModelChanged() {
    this.localToDispose.clear();
    this.removeCommentWidgetsAndStoreCache();
    if (!this.editor) {
      return;
    }
    this.localToDispose.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
    this.localToDispose.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
    if (this._editorDisposables.length) {
      this.clearEditorListeners();
      this.registerEditorListeners();
    }
    this._computeCommentingRangeScheduler = new Delayer(200);
    this.localToDispose.add({
      dispose: () => {
        var _a30;
        (_a30 = this._computeCommentingRangeScheduler) == null ? void 0 : _a30.cancel();
        this._computeCommentingRangeScheduler = null;
      }
    });
    this.localToDispose.add(this.editor.onDidChangeModelContent(async () => {
      this.beginComputeCommentingRanges();
    }));
    this.localToDispose.add(this.commentService.onDidUpdateCommentThreads(async (e) => {
      const editorURI = this.editor && this.editor.hasModel() && this.editor.getModel().uri;
      if (!editorURI || !this.commentService.isCommentingEnabled) {
        return;
      }
      if (this._computePromise) {
        await this._computePromise;
      }
      const commentInfo = this._commentInfos.filter((info) => info.owner === e.owner);
      if (!commentInfo || !commentInfo.length) {
        return;
      }
      const added = e.added.filter((thread) => thread.resource && thread.resource.toString() === editorURI.toString());
      const removed = e.removed.filter((thread) => thread.resource && thread.resource.toString() === editorURI.toString());
      const changed = e.changed.filter((thread) => thread.resource && thread.resource.toString() === editorURI.toString());
      removed.forEach((thread) => {
        const matchedZones = this._commentWidgets.filter((zoneWidget) => zoneWidget.owner === e.owner && zoneWidget.commentThread.threadId === thread.threadId && zoneWidget.commentThread.threadId !== "");
        if (matchedZones.length) {
          const matchedZone = matchedZones[0];
          const index = this._commentWidgets.indexOf(matchedZone);
          this._commentWidgets.splice(index, 1);
          matchedZone.dispose();
        }
        const infosThreads = this._commentInfos.filter((info) => info.owner === e.owner)[0].threads;
        for (let i = 0; i < infosThreads.length; i++) {
          if (infosThreads[i] === thread) {
            infosThreads.splice(i, 1);
            i--;
          }
        }
      });
      changed.forEach((thread) => {
        const matchedZones = this._commentWidgets.filter((zoneWidget) => zoneWidget.owner === e.owner && zoneWidget.commentThread.threadId === thread.threadId);
        if (matchedZones.length) {
          const matchedZone = matchedZones[0];
          matchedZone.update(thread);
          this.openCommentsView(thread);
        }
      });
      added.forEach((thread) => {
        const matchedZones = this._commentWidgets.filter((zoneWidget) => zoneWidget.owner === e.owner && zoneWidget.commentThread.threadId === thread.threadId);
        if (matchedZones.length) {
          return;
        }
        const matchedNewCommentThreadZones = this._commentWidgets.filter((zoneWidget) => zoneWidget.owner === e.owner && zoneWidget.commentThread.commentThreadHandle === -1 && Range.equalsRange(zoneWidget.commentThread.range, thread.range));
        if (matchedNewCommentThreadZones.length) {
          matchedNewCommentThreadZones[0].update(thread);
          return;
        }
        const pendingCommentText = this._pendingNewCommentCache[e.owner] && this._pendingNewCommentCache[e.owner][thread.threadId];
        const pendingEdits = this._pendingEditsCache[e.owner] && this._pendingEditsCache[e.owner][thread.threadId];
        this.displayCommentThread(e.owner, thread, pendingCommentText, pendingEdits);
        this._commentInfos.filter((info) => info.owner === e.owner)[0].threads.push(thread);
        this.tryUpdateReservedSpace();
      });
      this._commentThreadRangeDecorator.update(this.editor, commentInfo);
    }));
    this.beginCompute();
  }
  async openCommentsView(thread) {
    var _a30;
    if (thread.comments && thread.comments.length > 0) {
      if (this.configurationService.getValue(COMMENTS_SECTION).openView === "file") {
        return this.viewsService.openView(COMMENTS_VIEW_ID);
      } else if (this.configurationService.getValue(COMMENTS_SECTION).openView === "firstFile") {
        const hasShownView = (_a30 = this.viewsService.getViewWithId(COMMENTS_VIEW_ID)) == null ? void 0 : _a30.hasRendered;
        if (!hasShownView) {
          return this.viewsService.openView(COMMENTS_VIEW_ID);
        }
      }
    }
    return void 0;
  }
  displayCommentThread(owner, thread, pendingComment, pendingEdits) {
    if (!this.editor) {
      return;
    }
    if (this.isEditorInlineOriginal(this.editor)) {
      return;
    }
    const zoneWidget = this.instantiationService.createInstance(ReviewZoneWidget, this.editor, owner, thread, pendingComment, pendingEdits);
    zoneWidget.display(thread.range);
    this._commentWidgets.push(zoneWidget);
    this.openCommentsView(thread);
  }
  onEditorMouseDown(e) {
    this.mouseDownInfo = parseMouseDownInfoFromEvent(e);
  }
  onEditorMouseUp(e) {
    const matchedLineNumber = isMouseUpEventDragFromMouseDown(this.mouseDownInfo, e);
    this.mouseDownInfo = null;
    if (!this.editor || matchedLineNumber === null || !e.target.element) {
      return;
    }
    const mouseUpIsOnDecorator = e.target.element.className.indexOf("comment-range-glyph") >= 0;
    const lineNumber = e.target.position.lineNumber;
    let range;
    let selection;
    if (matchedLineNumber !== lineNumber) {
      if (matchedLineNumber > lineNumber) {
        selection = new Range(
          matchedLineNumber,
          this.editor.getModel().getLineLength(matchedLineNumber) + 1,
          lineNumber,
          1
        );
      } else {
        selection = new Range(
          matchedLineNumber,
          1,
          lineNumber,
          this.editor.getModel().getLineLength(lineNumber) + 1
        );
      }
    } else if (mouseUpIsOnDecorator) {
      selection = this.editor.getSelection();
    }
    if (selection && selection.startLineNumber <= lineNumber && lineNumber <= selection.endLineNumber) {
      range = selection;
      this.editor.setSelection(new Range(selection.endLineNumber, 1, selection.endLineNumber, 1));
    } else if (mouseUpIsOnDecorator) {
      range = new Range(lineNumber, 1, lineNumber, 1);
    }
    if (range) {
      this.addOrToggleCommentAtLine(range, e);
    }
  }
  async addOrToggleCommentAtLine(commentRange, e) {
    if (!this._addInProgress) {
      this._addInProgress = true;
      const existingCommentsAtLine = this._commentWidgets.filter((widget) => widget.getGlyphPosition() === (commentRange ? commentRange.endLineNumber : 0));
      if (existingCommentsAtLine.length) {
        const allExpanded = existingCommentsAtLine.every((widget) => widget.expanded);
        existingCommentsAtLine.forEach(allExpanded ? (widget) => widget.collapse() : (widget) => widget.expand());
        this.processNextThreadToAdd();
        return;
      } else {
        this.addCommentAtLine(commentRange, e);
      }
    } else {
      this._emptyThreadsToAddQueue.push([commentRange, e]);
    }
  }
  processNextThreadToAdd() {
    this._addInProgress = false;
    const info = this._emptyThreadsToAddQueue.shift();
    if (info) {
      this.addOrToggleCommentAtLine(info[0], info[1]);
    }
  }
  addCommentAtLine(range, e) {
    var _a30;
    const newCommentInfos = this._commentingRangeDecorator.getMatchedCommentAction(range);
    if (!newCommentInfos.length || !((_a30 = this.editor) == null ? void 0 : _a30.hasModel())) {
      this._addInProgress = false;
      return Promise.resolve();
    }
    if (newCommentInfos.length > 1) {
      if (e && range) {
        this.contextMenuService.showContextMenu({
          getAnchor: () => e.event,
          getActions: () => this.getContextMenuActions(newCommentInfos, range),
          getActionsContext: () => newCommentInfos.length ? newCommentInfos[0] : void 0,
          onHide: () => {
            this._addInProgress = false;
          }
        });
        return Promise.resolve();
      } else {
        const picks = this.getCommentProvidersQuickPicks(newCommentInfos);
        return this.quickInputService.pick(picks, { placeHolder: localize("pickCommentService", "Select Comment Provider"), matchOnDescription: true }).then((pick) => {
          if (!pick) {
            return;
          }
          const commentInfos = newCommentInfos.filter((info) => info.ownerId === pick.id);
          if (commentInfos.length) {
            const { ownerId } = commentInfos[0];
            this.addCommentAtLine2(range, ownerId);
          }
        }).then(() => {
          this._addInProgress = false;
        });
      }
    } else {
      const { ownerId } = newCommentInfos[0];
      this.addCommentAtLine2(range, ownerId);
    }
    return Promise.resolve();
  }
  getCommentProvidersQuickPicks(commentInfos) {
    const picks = commentInfos.map((commentInfo) => {
      const { ownerId, extensionId, label } = commentInfo;
      return {
        label: label || extensionId,
        id: ownerId
      };
    });
    return picks;
  }
  getContextMenuActions(commentInfos, commentRange) {
    const actions = [];
    commentInfos.forEach((commentInfo) => {
      const { ownerId, extensionId, label } = commentInfo;
      actions.push(new Action("addCommentThread", `${label || extensionId}`, void 0, true, () => {
        this.addCommentAtLine2(commentRange, ownerId);
        return Promise.resolve();
      }));
    });
    return actions;
  }
  addCommentAtLine2(range, ownerId) {
    if (!this.editor) {
      return;
    }
    this.commentService.createCommentThreadTemplate(ownerId, this.editor.getModel().uri, range);
    this.processNextThreadToAdd();
    return;
  }
  getExistingCommentEditorOptions(editor) {
    const lineDecorationsWidth = editor.getOption(64);
    let extraEditorClassName = [];
    const configuredExtraClassName = editor.getRawOptions().extraEditorClassName;
    if (configuredExtraClassName) {
      extraEditorClassName = configuredExtraClassName.split(" ");
    }
    return { lineDecorationsWidth, extraEditorClassName };
  }
  getWithoutCommentsEditorOptions(editor, extraEditorClassName, startingLineDecorationsWidth) {
    let lineDecorationsWidth = startingLineDecorationsWidth;
    const inlineCommentPos = extraEditorClassName.findIndex((name) => name === "inline-comment");
    if (inlineCommentPos >= 0) {
      extraEditorClassName.splice(inlineCommentPos, 1);
    }
    const options = editor.getOptions();
    if (options.get(42) && options.get(108) !== "never") {
      lineDecorationsWidth += 11;
    }
    lineDecorationsWidth -= 24;
    return { extraEditorClassName, lineDecorationsWidth };
  }
  getWithCommentsEditorOptions(editor, extraEditorClassName, startingLineDecorationsWidth) {
    let lineDecorationsWidth = startingLineDecorationsWidth;
    const options = editor.getOptions();
    if (options.get(42) && options.get(108) !== "never") {
      lineDecorationsWidth -= 11;
    }
    lineDecorationsWidth += 24;
    extraEditorClassName.push("inline-comment");
    return { lineDecorationsWidth, extraEditorClassName };
  }
  updateEditorLayoutOptions(editor, extraEditorClassName, lineDecorationsWidth) {
    editor.updateOptions({
      extraEditorClassName: extraEditorClassName.join(" "),
      lineDecorationsWidth
    });
  }
  tryUpdateReservedSpace() {
    if (!this.editor) {
      return;
    }
    const hasCommentsOrRanges = this._commentInfos.some((info) => {
      const hasRanges = Boolean(info.commentingRanges && (Array.isArray(info.commentingRanges) ? info.commentingRanges : info.commentingRanges.ranges).length);
      return hasRanges || info.threads.length > 0;
    });
    if (hasCommentsOrRanges && !this._commentingRangeSpaceReserved && this.commentService.isCommentingEnabled) {
      this._commentingRangeSpaceReserved = true;
      const { lineDecorationsWidth, extraEditorClassName } = this.getExistingCommentEditorOptions(this.editor);
      const newOptions = this.getWithCommentsEditorOptions(this.editor, extraEditorClassName, lineDecorationsWidth);
      this.updateEditorLayoutOptions(this.editor, newOptions.extraEditorClassName, newOptions.lineDecorationsWidth);
    } else if ((!hasCommentsOrRanges || !this.commentService.isCommentingEnabled) && this._commentingRangeSpaceReserved) {
      this._commentingRangeSpaceReserved = false;
      const { lineDecorationsWidth, extraEditorClassName } = this.getExistingCommentEditorOptions(this.editor);
      const newOptions = this.getWithoutCommentsEditorOptions(this.editor, extraEditorClassName, lineDecorationsWidth);
      this.updateEditorLayoutOptions(this.editor, newOptions.extraEditorClassName, newOptions.lineDecorationsWidth);
    }
  }
  setComments(commentInfos) {
    if (!this.editor || !this.commentService.isCommentingEnabled) {
      return;
    }
    this._commentInfos = commentInfos;
    this.tryUpdateReservedSpace();
    this.removeCommentWidgetsAndStoreCache();
    this._commentInfos.forEach((info) => {
      const providerCacheStore = this._pendingNewCommentCache[info.owner];
      const providerEditsCacheStore = this._pendingEditsCache[info.owner];
      info.threads = info.threads.filter((thread) => !thread.isDisposed);
      info.threads.forEach((thread) => {
        let pendingComment = void 0;
        if (providerCacheStore) {
          pendingComment = providerCacheStore[thread.threadId];
        }
        let pendingEdits = void 0;
        if (providerEditsCacheStore) {
          pendingEdits = providerEditsCacheStore[thread.threadId];
        }
        if (pendingComment || pendingEdits) {
          thread.collapsibleState = CommentThreadCollapsibleState.Expanded;
        }
        this.displayCommentThread(info.owner, thread, pendingComment, pendingEdits);
      });
    });
    this._commentingRangeDecorator.update(this.editor, this._commentInfos);
    this._commentThreadRangeDecorator.update(this.editor, this._commentInfos);
  }
  closeWidget() {
    var _a30;
    (_a30 = this._commentWidgets) == null ? void 0 : _a30.forEach((widget) => widget.hide());
    if (this.editor) {
      this.editor.focus();
      this.editor.revealRangeInCenter(this.editor.getSelection());
    }
  }
  removeCommentWidgetsAndStoreCache() {
    if (this._commentWidgets) {
      this._commentWidgets.forEach((zone) => {
        const pendingComments = zone.getPendingComments();
        const pendingNewComment = pendingComments.newComment;
        const providerNewCommentCacheStore = this._pendingNewCommentCache[zone.owner];
        let lastCommentBody;
        if (zone.commentThread.comments && zone.commentThread.comments.length) {
          const lastComment = zone.commentThread.comments[zone.commentThread.comments.length - 1];
          if (typeof lastComment.body === "string") {
            lastCommentBody = lastComment.body;
          } else {
            lastCommentBody = lastComment.body.value;
          }
        }
        if (pendingNewComment && pendingNewComment !== lastCommentBody) {
          if (!providerNewCommentCacheStore) {
            this._pendingNewCommentCache[zone.owner] = {};
          }
          this._pendingNewCommentCache[zone.owner][zone.commentThread.threadId] = pendingNewComment;
        } else {
          if (providerNewCommentCacheStore) {
            delete providerNewCommentCacheStore[zone.commentThread.threadId];
          }
        }
        const pendingEdits = pendingComments.edits;
        const providerEditsCacheStore = this._pendingEditsCache[zone.owner];
        if (Object.keys(pendingEdits).length > 0) {
          if (!providerEditsCacheStore) {
            this._pendingEditsCache[zone.owner] = {};
          }
          this._pendingEditsCache[zone.owner][zone.commentThread.threadId] = pendingEdits;
        } else if (providerEditsCacheStore) {
          delete providerEditsCacheStore[zone.commentThread.threadId];
        }
        zone.dispose();
      });
    }
    this._commentWidgets = [];
  }
};
CommentController = __decorate([
  __param(1, ICommentService),
  __param(2, IInstantiationService),
  __param(3, ICodeEditorService),
  __param(4, IContextMenuService),
  __param(5, IQuickInputService),
  __param(6, IViewsService),
  __param(7, IConfigurationService),
  __param(8, IContextKeyService),
  __param(9, IEditorService)
], CommentController);

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentsView.js
init_range();
var CONTEXT_KEY_HAS_COMMENTS = new RawContextKey("commentsView.hasComments", false);
var CONTEXT_KEY_SOME_COMMENTS_EXPANDED = new RawContextKey("commentsView.someCommentsExpanded", false);
var VIEW_STORAGE_ID = "commentsViewState";
function createResourceCommentsIterator(model) {
  return Iterable.map(model.resourceCommentThreads, (m) => {
    const CommentNodeIt = Iterable.from(m.commentThreads);
    const children = Iterable.map(CommentNodeIt, (r) => ({ element: r }));
    return { element: m, children };
  });
}
var CommentsPanel = class CommentsPanel2 extends FilterViewPane {
  constructor(options, instantiationService, viewDescriptorService, editorService, configurationService, contextKeyService, contextMenuService, keybindingService, openerService, themeService, commentService, telemetryService, uriIdentityService, activityService, storageService) {
    const stateMemento = new Memento(VIEW_STORAGE_ID, storageService);
    const viewState = stateMemento.getMemento(1, 1);
    super({
      ...options,
      filterOptions: {
        placeholder: localize("comments.filter.placeholder", "Filter (e.g. text, author)"),
        ariaLabel: localize("comments.filter.ariaLabel", "Filter comments"),
        history: viewState["filterHistory"] || [],
        text: viewState["filter"] || "",
        focusContextKey: CommentsViewFilterFocusContextKey.key
      }
    }, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
    this.editorService = editorService;
    this.commentService = commentService;
    this.uriIdentityService = uriIdentityService;
    this.activityService = activityService;
    this.totalComments = 0;
    this.totalUnresolved = 0;
    this.activity = this._register(new MutableDisposable());
    this.currentHeight = 0;
    this.currentWidth = 0;
    this.cachedFilterStats = void 0;
    this.onDidChangeVisibility = this.onDidChangeBodyVisibility;
    this.hasCommentsContextKey = CONTEXT_KEY_HAS_COMMENTS.bindTo(contextKeyService);
    this.someCommentsExpandedContextKey = CONTEXT_KEY_SOME_COMMENTS_EXPANDED.bindTo(contextKeyService);
    this.stateMemento = stateMemento;
    this.viewState = viewState;
    this.filters = this._register(new CommentsFilters({
      showResolved: this.viewState["showResolved"] !== false,
      showUnresolved: this.viewState["showUnresolved"] !== false
    }, this.contextKeyService));
    this.filter = new Filter(new FilterOptions(
      this.filterWidget.getFilterText(),
      this.filters.showResolved,
      this.filters.showUnresolved
    ));
    this._register(this.filters.onDidChange((event) => {
      if (event.showResolved || event.showUnresolved) {
        this.updateFilter();
      }
    }));
    this._register(this.filterWidget.onDidChangeFilterText(() => this.updateFilter()));
  }
  updateBadge(unresolved) {
    if (unresolved === this.totalUnresolved) {
      return;
    }
    this.totalUnresolved = unresolved;
    const message = localize("totalUnresolvedComments", "{0} Unresolved Comments", this.totalUnresolved);
    this.activity.value = this.activityService.showViewActivity(this.id, { badge: new NumberBadge(this.totalUnresolved, () => message) });
  }
  saveState() {
    this.viewState["filter"] = this.filterWidget.getFilterText();
    this.viewState["filterHistory"] = this.filterWidget.getHistory();
    this.viewState["showResolved"] = this.filters.showResolved;
    this.viewState["showUnresolved"] = this.filters.showUnresolved;
    this.stateMemento.saveMemento();
    super.saveState();
  }
  render() {
    super.render();
    this._register(registerNavigableContainer({
      focusNotifiers: [this, this.filterWidget],
      focusNextWidget: () => {
        if (this.filterWidget.hasFocus()) {
          this.focus();
        }
      },
      focusPreviousWidget: () => {
        if (!this.filterWidget.hasFocus()) {
          this.focusFilter();
        }
      }
    }));
  }
  focusFilter() {
    this.filterWidget.focus();
  }
  clearFilterText() {
    this.filterWidget.setFilterText("");
  }
  getFilterStats() {
    var _a30;
    if (!this.cachedFilterStats) {
      this.cachedFilterStats = {
        total: this.totalComments,
        filtered: ((_a30 = this.tree) == null ? void 0 : _a30.getVisibleItemCount()) ?? 0
      };
    }
    return this.cachedFilterStats;
  }
  updateFilter() {
    var _a30;
    this.filter.options = new FilterOptions(
      this.filterWidget.getFilterText(),
      this.filters.showResolved,
      this.filters.showUnresolved
    );
    (_a30 = this.tree) == null ? void 0 : _a30.filterComments();
    this.cachedFilterStats = void 0;
    const { total, filtered } = this.getFilterStats();
    this.filterWidget.updateBadge(total === filtered || total === 0 ? void 0 : localize("showing filtered results", "Showing {0} of {1}", filtered, total));
    this.filterWidget.checkMoreFilters(!this.filters.showResolved || !this.filters.showUnresolved);
  }
  renderBody(container) {
    super.renderBody(container);
    container.classList.add("comments-panel");
    const domContainer = append(container, $(".comments-panel-container"));
    this.treeContainer = append(domContainer, $(".tree-container"));
    this.treeContainer.classList.add("file-icon-themable-tree", "show-file-icons");
    this.commentsModel = new CommentsModel();
    this.cachedFilterStats = void 0;
    this.createTree();
    this.createMessageBox(domContainer);
    this._register(this.commentService.onDidSetAllCommentThreads(this.onAllCommentsChanged, this));
    this._register(this.commentService.onDidUpdateCommentThreads(this.onCommentsUpdated, this));
    this._register(this.commentService.onDidDeleteDataProvider(this.onDataProviderDeleted, this));
    const styleElement = createStyleSheet(container);
    this.applyStyles(styleElement);
    this._register(this.themeService.onDidColorThemeChange((_) => this.applyStyles(styleElement)));
    this._register(this.onDidChangeBodyVisibility((visible) => {
      if (visible) {
        this.refresh();
      }
    }));
    this.renderComments();
  }
  focus() {
    if (this.tree && this.tree.getHTMLElement() === document.activeElement) {
      return;
    }
    if (!this.commentsModel.hasCommentThreads() && this.messageBoxContainer) {
      this.messageBoxContainer.focus();
    } else if (this.tree) {
      this.tree.domFocus();
    }
  }
  applyStyles(styleElement) {
    const content = [];
    const theme = this.themeService.getColorTheme();
    const linkColor = theme.getColor(textLinkForeground);
    if (linkColor) {
      content.push(`.comments-panel .comments-panel-container a { color: ${linkColor}; }`);
    }
    const linkActiveColor = theme.getColor(textLinkActiveForeground);
    if (linkActiveColor) {
      content.push(`.comments-panel .comments-panel-container a:hover, a:active { color: ${linkActiveColor}; }`);
    }
    const focusColor = theme.getColor(focusBorder);
    if (focusColor) {
      content.push(`.comments-panel .comments-panel-container a:focus { outline-color: ${focusColor}; }`);
    }
    const codeTextForegroundColor = theme.getColor(textPreformatForeground);
    if (codeTextForegroundColor) {
      content.push(`.comments-panel .comments-panel-container .text code { color: ${codeTextForegroundColor}; }`);
    }
    styleElement.textContent = content.join("\n");
  }
  async renderComments() {
    var _a30;
    this.treeContainer.classList.toggle("hidden", !this.commentsModel.hasCommentThreads());
    this.renderMessage();
    await ((_a30 = this.tree) == null ? void 0 : _a30.setChildren(null, createResourceCommentsIterator(this.commentsModel)));
  }
  collapseAll() {
    if (this.tree) {
      this.tree.collapseAll();
      this.tree.setSelection([]);
      this.tree.setFocus([]);
      this.tree.domFocus();
      this.tree.focusFirst();
    }
  }
  expandAll() {
    if (this.tree) {
      this.tree.expandAll();
      this.tree.setSelection([]);
      this.tree.setFocus([]);
      this.tree.domFocus();
      this.tree.focusFirst();
    }
  }
  get hasRendered() {
    return !!this.tree;
  }
  layoutBodyContent(height = this.currentHeight, width = this.currentWidth) {
    var _a30;
    if (this.messageBoxContainer) {
      this.messageBoxContainer.style.height = `${height}px`;
    }
    (_a30 = this.tree) == null ? void 0 : _a30.layout(height, width);
    this.currentHeight = height;
    this.currentWidth = width;
  }
  createMessageBox(parent) {
    this.messageBoxContainer = append(parent, $(".message-box-container"));
    this.messageBoxContainer.setAttribute("tabIndex", "0");
  }
  renderMessage() {
    this.messageBoxContainer.textContent = this.commentsModel.getMessage();
    this.messageBoxContainer.classList.toggle("hidden", this.commentsModel.hasCommentThreads());
  }
  createTree() {
    this.treeLabels = this._register(this.instantiationService.createInstance(ResourceLabels, this));
    this.tree = this._register(this.instantiationService.createInstance(CommentsList, this.treeLabels, this.treeContainer, {
      overrideStyles: { listBackground: this.getBackgroundColor() },
      selectionNavigation: true,
      filter: this.filter,
      keyboardNavigationLabelProvider: {
        getKeyboardNavigationLabel: (item) => {
          return void 0;
        }
      },
      accessibilityProvider: {
        getAriaLabel(element) {
          if (element instanceof CommentsModel) {
            return localize("rootCommentsLabel", "Comments for current workspace");
          }
          if (element instanceof ResourceWithCommentThreads) {
            return localize(
              "resourceWithCommentThreadsLabel",
              "Comments in {0}, full path {1}",
              basename2(element.resource),
              element.resource.fsPath
            );
          }
          if (element instanceof CommentNode) {
            if (element.range) {
              return localize(
                "resourceWithCommentLabel",
                "Comment from ${0} at line {1} column {2} in {3}, source: {4}",
                element.comment.userName,
                element.range.startLineNumber,
                element.range.startColumn,
                basename2(element.resource),
                typeof element.comment.body === "string" ? element.comment.body : element.comment.body.value
              );
            } else {
              return localize(
                "resourceWithCommentLabelFile",
                "Comment from ${0} in {1}, source: {2}",
                element.comment.userName,
                basename2(element.resource),
                typeof element.comment.body === "string" ? element.comment.body : element.comment.body.value
              );
            }
          }
          return "";
        },
        getWidgetAriaLabel() {
          return COMMENTS_VIEW_TITLE;
        }
      }
    }));
    this._register(this.tree.onDidOpen((e) => {
      this.openFile(e.element, e.editorOptions.pinned, e.editorOptions.preserveFocus, e.sideBySide);
    }));
    this._register(this.tree.onDidChangeModel(() => {
      this.updateSomeCommentsExpanded();
    }));
    this._register(this.tree.onDidChangeCollapseState(() => {
      this.updateSomeCommentsExpanded();
    }));
  }
  openFile(element, pinned, preserveFocus, sideBySide) {
    if (!element) {
      return false;
    }
    if (!(element instanceof ResourceWithCommentThreads || element instanceof CommentNode)) {
      return false;
    }
    if (!this.commentService.isCommentingEnabled) {
      this.commentService.enableCommenting(true);
    }
    const range = element instanceof ResourceWithCommentThreads ? element.commentThreads[0].range : element.range;
    const activeEditor = this.editorService.activeTextEditorControl;
    const currentActiveResources = isDiffEditor(activeEditor) ? [activeEditor.getOriginalEditor(), activeEditor.getModifiedEditor()] : activeEditor ? [activeEditor] : [];
    for (const editor of currentActiveResources) {
      const model = editor.getModel();
      if (model instanceof TextModel && this.uriIdentityService.extUri.isEqual(element.resource, model.uri)) {
        const threadToReveal2 = element instanceof ResourceWithCommentThreads ? element.commentThreads[0].threadId : element.threadId;
        const commentToReveal2 = element instanceof ResourceWithCommentThreads ? element.commentThreads[0].comment.uniqueIdInThread : element.comment.uniqueIdInThread;
        if (threadToReveal2 && isCodeEditor(editor)) {
          const controller = CommentController.get(editor);
          controller == null ? void 0 : controller.revealCommentThread(threadToReveal2, commentToReveal2, true);
        }
        return true;
      }
    }
    const threadToReveal = element instanceof ResourceWithCommentThreads ? element.commentThreads[0].threadId : element.threadId;
    const commentToReveal = element instanceof ResourceWithCommentThreads ? element.commentThreads[0].comment : element.comment;
    this.editorService.openEditor({
      resource: element.resource,
      options: {
        pinned,
        preserveFocus,
        selection: range ?? new Range(1, 1, 1, 1)
      }
    }, sideBySide ? SIDE_GROUP : ACTIVE_GROUP).then((editor) => {
      if (editor) {
        const control = editor.getControl();
        if (threadToReveal && isCodeEditor(control)) {
          const controller = CommentController.get(control);
          controller == null ? void 0 : controller.revealCommentThread(threadToReveal, commentToReveal.uniqueIdInThread, true);
        }
      }
    });
    return true;
  }
  async refresh() {
    var _a30;
    if (!this.tree) {
      return;
    }
    if (this.isVisible()) {
      this.hasCommentsContextKey.set(this.commentsModel.hasCommentThreads());
      this.treeContainer.classList.toggle("hidden", !this.commentsModel.hasCommentThreads());
      this.cachedFilterStats = void 0;
      this.renderMessage();
      (_a30 = this.tree) == null ? void 0 : _a30.setChildren(null, createResourceCommentsIterator(this.commentsModel));
      if (this.tree.getSelection().length === 0 && this.commentsModel.hasCommentThreads()) {
        const firstComment = this.commentsModel.resourceCommentThreads[0].commentThreads[0];
        if (firstComment) {
          this.tree.setFocus([firstComment]);
          this.tree.setSelection([firstComment]);
        }
      }
    }
  }
  onAllCommentsChanged(e) {
    this.cachedFilterStats = void 0;
    this.commentsModel.setCommentThreads(e.ownerId, e.commentThreads);
    this.totalComments += e.commentThreads.length;
    let unresolved = 0;
    for (const thread of e.commentThreads) {
      if (thread.state === CommentThreadState.Unresolved) {
        unresolved++;
      }
    }
    this.updateBadge(unresolved);
    this.refresh();
  }
  onCommentsUpdated(e) {
    this.cachedFilterStats = void 0;
    const didUpdate = this.commentsModel.updateCommentThreads(e);
    this.totalComments += e.added.length;
    this.totalComments -= e.removed.length;
    let unresolved = 0;
    for (const resource of this.commentsModel.resourceCommentThreads) {
      for (const thread of resource.commentThreads) {
        if (thread.threadState === CommentThreadState.Unresolved) {
          unresolved++;
        }
      }
    }
    this.updateBadge(unresolved);
    if (didUpdate) {
      this.refresh();
    }
  }
  onDataProviderDeleted(owner) {
    this.cachedFilterStats = void 0;
    this.commentsModel.deleteCommentsByOwner(owner);
    this.totalComments = 0;
    this.refresh();
  }
  updateSomeCommentsExpanded() {
    this.someCommentsExpandedContextKey.set(this.isSomeCommentsExpanded());
  }
  areAllCommentsExpanded() {
    if (!this.tree) {
      return false;
    }
    const navigator = this.tree.navigate();
    while (navigator.next()) {
      if (this.tree.isCollapsed(navigator.current())) {
        return false;
      }
    }
    return true;
  }
  isSomeCommentsExpanded() {
    if (!this.tree) {
      return false;
    }
    const navigator = this.tree.navigate();
    while (navigator.next()) {
      if (!this.tree.isCollapsed(navigator.current())) {
        return true;
      }
    }
    return false;
  }
};
CommentsPanel = __decorate([
  __param(1, IInstantiationService),
  __param(2, IViewDescriptorService),
  __param(3, IEditorService),
  __param(4, IConfigurationService),
  __param(5, IContextKeyService),
  __param(6, IContextMenuService),
  __param(7, IKeybindingService),
  __param(8, IOpenerService),
  __param(9, IThemeService),
  __param(10, ICommentService),
  __param(11, ITelemetryService),
  __param(12, IUriIdentityService),
  __param(13, IActivityService),
  __param(14, IStorageService)
], CommentsPanel);
CommandsRegistry.registerCommand({
  id: "workbench.action.focusCommentsPanel",
  handler: async (accessor) => {
    const viewsService = accessor.get(IViewsService);
    viewsService.openView(COMMENTS_VIEW_ID, true);
  }
});
registerAction2(class Collapse extends ViewAction {
  constructor() {
    super({
      viewId: COMMENTS_VIEW_ID,
      id: "comments.collapse",
      title: localize("collapseAll", "Collapse All"),
      f1: false,
      icon: Codicon.collapseAll,
      menu: {
        id: MenuId.ViewTitle,
        group: "navigation",
        when: ContextKeyExpr.and(ContextKeyExpr.and(ContextKeyExpr.equals("view", COMMENTS_VIEW_ID), CONTEXT_KEY_HAS_COMMENTS), CONTEXT_KEY_SOME_COMMENTS_EXPANDED),
        order: 100
      }
    });
  }
  runInView(_accessor, view) {
    view.collapseAll();
  }
});
registerAction2(class Expand extends ViewAction {
  constructor() {
    super({
      viewId: COMMENTS_VIEW_ID,
      id: "comments.expand",
      title: localize("expandAll", "Expand All"),
      f1: false,
      icon: Codicon.expandAll,
      menu: {
        id: MenuId.ViewTitle,
        group: "navigation",
        when: ContextKeyExpr.and(ContextKeyExpr.and(ContextKeyExpr.equals("view", COMMENTS_VIEW_ID), CONTEXT_KEY_HAS_COMMENTS), ContextKeyExpr.not(CONTEXT_KEY_SOME_COMMENTS_EXPANDED.key)),
        order: 100
      }
    });
  }
  runInView(_accessor, view) {
    view.expandAll();
  }
});

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadComments.js
init_extHost_protocol();
init_descriptors();
init_codicons();
init_nls();
init_network();
var MainThreadCommentThread = class {
  get input() {
    return this._input;
  }
  set input(value) {
    this._input = value;
    this._onDidChangeInput.fire(value);
  }
  get onDidChangeInput() {
    return this._onDidChangeInput.event;
  }
  get label() {
    return this._label;
  }
  set label(label) {
    this._label = label;
    this._onDidChangeLabel.fire(this._label);
  }
  get contextValue() {
    return this._contextValue;
  }
  set contextValue(context) {
    this._contextValue = context;
  }
  get comments() {
    return this._comments;
  }
  set comments(newComments) {
    this._comments = newComments;
    this._onDidChangeComments.fire(this._comments);
  }
  get onDidChangeComments() {
    return this._onDidChangeComments.event;
  }
  set range(range) {
    this._range = range;
    this._onDidChangeRange.fire(this._range);
  }
  get range() {
    return this._range;
  }
  get onDidChangeCanReply() {
    return this._onDidChangeCanReply.event;
  }
  set canReply(state) {
    this._canReply = state;
    this._onDidChangeCanReply.fire(this._canReply);
  }
  get canReply() {
    return this._canReply;
  }
  get collapsibleState() {
    return this._collapsibleState;
  }
  set collapsibleState(newState) {
    this._collapsibleState = newState;
    this._onDidChangeCollapsibleState.fire(this._collapsibleState);
  }
  get initialCollapsibleState() {
    return this._initialCollapsibleState;
  }
  set initialCollapsibleState(initialCollapsibleState) {
    this._initialCollapsibleState = initialCollapsibleState;
    if (this.collapsibleState === void 0) {
      this.collapsibleState = this.initialCollapsibleState;
    }
    this._onDidChangeInitialCollapsibleState.fire(initialCollapsibleState);
  }
  get isDisposed() {
    return this._isDisposed;
  }
  isDocumentCommentThread() {
    return this._range === void 0 || Range.isIRange(this._range);
  }
  get state() {
    return this._state;
  }
  set state(newState) {
    this._state = newState;
    this._onDidChangeState.fire(this._state);
  }
  get isTemplate() {
    return this._isTemplate;
  }
  constructor(commentThreadHandle, controllerHandle, extensionId, threadId, resource, _range, _canReply, _isTemplate) {
    this.commentThreadHandle = commentThreadHandle;
    this.controllerHandle = controllerHandle;
    this.extensionId = extensionId;
    this.threadId = threadId;
    this.resource = resource;
    this._range = _range;
    this._canReply = _canReply;
    this._isTemplate = _isTemplate;
    this._onDidChangeInput = new Emitter();
    this._onDidChangeLabel = new Emitter();
    this.onDidChangeLabel = this._onDidChangeLabel.event;
    this._onDidChangeComments = new Emitter();
    this._onDidChangeCanReply = new Emitter();
    this._onDidChangeRange = new Emitter();
    this.onDidChangeRange = this._onDidChangeRange.event;
    this._onDidChangeCollapsibleState = new Emitter();
    this.onDidChangeCollapsibleState = this._onDidChangeCollapsibleState.event;
    this._onDidChangeInitialCollapsibleState = new Emitter();
    this.onDidChangeInitialCollapsibleState = this._onDidChangeInitialCollapsibleState.event;
    this._onDidChangeState = new Emitter();
    this.onDidChangeState = this._onDidChangeState.event;
    this._isDisposed = false;
    if (_isTemplate) {
      this.comments = [];
    }
  }
  batchUpdate(changes) {
    const modified = (value) => Object.prototype.hasOwnProperty.call(changes, value);
    if (modified("range")) {
      this._range = changes.range;
    }
    if (modified("label")) {
      this._label = changes.label;
    }
    if (modified("contextValue")) {
      this._contextValue = changes.contextValue === null ? void 0 : changes.contextValue;
    }
    if (modified("comments")) {
      this._comments = changes.comments;
    }
    if (modified("collapseState")) {
      this.initialCollapsibleState = changes.collapseState;
    }
    if (modified("canReply")) {
      this.canReply = changes.canReply;
    }
    if (modified("state")) {
      this.state = changes.state;
    }
    if (modified("isTemplate")) {
      this._isTemplate = changes.isTemplate;
    }
  }
  dispose() {
    this._isDisposed = true;
    this._onDidChangeCollapsibleState.dispose();
    this._onDidChangeComments.dispose();
    this._onDidChangeInput.dispose();
    this._onDidChangeLabel.dispose();
    this._onDidChangeRange.dispose();
    this._onDidChangeState.dispose();
  }
  toJSON() {
    return {
      $mid: 7,
      commentControlHandle: this.controllerHandle,
      commentThreadHandle: this.commentThreadHandle
    };
  }
};
var MainThreadCommentController = class {
  get handle() {
    return this._handle;
  }
  get id() {
    return this._id;
  }
  get contextValue() {
    return this._id;
  }
  get proxy() {
    return this._proxy;
  }
  get label() {
    return this._label;
  }
  get reactions() {
    return this._reactions;
  }
  set reactions(reactions) {
    this._reactions = reactions;
  }
  get options() {
    return this._features.options;
  }
  get features() {
    return this._features;
  }
  constructor(_proxy10, _commentService, _handle4, _uniqueId, _id, _label, _features) {
    this._proxy = _proxy10;
    this._commentService = _commentService;
    this._handle = _handle4;
    this._uniqueId = _uniqueId;
    this._id = _id;
    this._label = _label;
    this._features = _features;
    this._threads = /* @__PURE__ */ new Map();
  }
  updateFeatures(features) {
    this._features = features;
  }
  createCommentThread(extensionId, commentThreadHandle, threadId, resource, range, isTemplate) {
    const thread = new MainThreadCommentThread(commentThreadHandle, this.handle, extensionId, threadId, URI.revive(resource).toString(), range, true, isTemplate);
    this._threads.set(commentThreadHandle, thread);
    if (thread.isDocumentCommentThread()) {
      this._commentService.updateComments(this._uniqueId, {
        added: [thread],
        removed: [],
        changed: []
      });
    } else {
      this._commentService.updateNotebookComments(this._uniqueId, {
        added: [thread],
        removed: [],
        changed: []
      });
    }
    return thread;
  }
  updateCommentThread(commentThreadHandle, threadId, resource, changes) {
    const thread = this.getKnownThread(commentThreadHandle);
    thread.batchUpdate(changes);
    if (thread.isDocumentCommentThread()) {
      this._commentService.updateComments(this._uniqueId, {
        added: [],
        removed: [],
        changed: [thread]
      });
    } else {
      this._commentService.updateNotebookComments(this._uniqueId, {
        added: [],
        removed: [],
        changed: [thread]
      });
    }
  }
  deleteCommentThread(commentThreadHandle) {
    const thread = this.getKnownThread(commentThreadHandle);
    this._threads.delete(commentThreadHandle);
    thread.dispose();
    if (thread.isDocumentCommentThread()) {
      this._commentService.updateComments(this._uniqueId, {
        added: [],
        removed: [thread],
        changed: []
      });
    } else {
      this._commentService.updateNotebookComments(this._uniqueId, {
        added: [],
        removed: [thread],
        changed: []
      });
    }
  }
  deleteCommentThreadMain(commentThreadId) {
    this._threads.forEach((thread) => {
      if (thread.threadId === commentThreadId) {
        this._proxy.$deleteCommentThread(this._handle, thread.commentThreadHandle);
      }
    });
  }
  updateInput(input) {
    const thread = this.activeCommentThread;
    if (thread && thread.input) {
      const commentInput = thread.input;
      commentInput.value = input;
      thread.input = commentInput;
    }
  }
  updateCommentingRanges() {
    this._commentService.updateCommentingRanges(this._uniqueId);
  }
  getKnownThread(commentThreadHandle) {
    const thread = this._threads.get(commentThreadHandle);
    if (!thread) {
      throw new Error("unknown thread");
    }
    return thread;
  }
  async getDocumentComments(resource, token) {
    if (resource.scheme === Schemas.vscodeNotebookCell) {
      return {
        owner: this._uniqueId,
        label: this.label,
        threads: [],
        commentingRanges: {
          resource,
          ranges: [],
          fileComments: false
        }
      };
    }
    const ret = [];
    for (const thread of [...this._threads.keys()]) {
      const commentThread = this._threads.get(thread);
      if (commentThread.resource === resource.toString()) {
        ret.push(commentThread);
      }
    }
    const commentingRanges = await this._proxy.$provideCommentingRanges(this.handle, resource, token);
    return {
      owner: this._uniqueId,
      label: this.label,
      threads: ret,
      commentingRanges: {
        resource,
        ranges: (commentingRanges == null ? void 0 : commentingRanges.ranges) || [],
        fileComments: commentingRanges == null ? void 0 : commentingRanges.fileComments
      }
    };
  }
  async getNotebookComments(resource, token) {
    if (resource.scheme !== Schemas.vscodeNotebookCell) {
      return {
        owner: this._uniqueId,
        label: this.label,
        threads: []
      };
    }
    const ret = [];
    for (const thread of [...this._threads.keys()]) {
      const commentThread = this._threads.get(thread);
      if (commentThread.resource === resource.toString()) {
        ret.push(commentThread);
      }
    }
    return {
      owner: this._uniqueId,
      label: this.label,
      threads: ret
    };
  }
  async toggleReaction(uri, thread, comment, reaction, token) {
    return this._proxy.$toggleReaction(this._handle, thread.commentThreadHandle, uri, comment, reaction);
  }
  getAllComments() {
    const ret = [];
    for (const thread of [...this._threads.keys()]) {
      ret.push(this._threads.get(thread));
    }
    return ret;
  }
  createCommentThreadTemplate(resource, range) {
    this._proxy.$createCommentThreadTemplate(this.handle, resource, range);
  }
  async updateCommentThreadTemplate(threadHandle, range) {
    await this._proxy.$updateCommentThreadTemplate(this.handle, threadHandle, range);
  }
  toJSON() {
    return {
      $mid: 6,
      handle: this.handle
    };
  }
};
var commentsViewIcon = registerIcon("comments-view-icon", Codicon.commentDiscussion, localize("commentsViewIcon", "View icon of the comments view."));
var MainThreadComments = class MainThreadComments2 extends Disposable {
  constructor(extHostContext, _commentService, _viewsService, _viewDescriptorService) {
    super();
    this._commentService = _commentService;
    this._viewsService = _viewsService;
    this._viewDescriptorService = _viewDescriptorService;
    this._handlers = /* @__PURE__ */ new Map();
    this._commentControllers = /* @__PURE__ */ new Map();
    this._activeCommentThreadDisposables = this._register(new DisposableStore());
    this._openViewListener = null;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostComments);
    this._commentService.unregisterCommentController();
    this._register(this._commentService.onDidChangeActiveCommentThread(async (thread) => {
      const handle = thread.controllerHandle;
      const controller = this._commentControllers.get(handle);
      if (!controller) {
        return;
      }
      this._activeCommentThreadDisposables.clear();
      this._activeCommentThread = thread;
      controller.activeCommentThread = this._activeCommentThread;
    }));
  }
  $registerCommentController(handle, id, label) {
    const providerId = generateUuid();
    this._handlers.set(handle, providerId);
    const provider = new MainThreadCommentController(this._proxy, this._commentService, handle, providerId, id, label, {});
    this._commentService.registerCommentController(providerId, provider);
    this._commentControllers.set(handle, provider);
    const commentsPanelAlreadyConstructed = !!this._viewDescriptorService.getViewDescriptorById(COMMENTS_VIEW_ID);
    if (!commentsPanelAlreadyConstructed) {
      this.registerView(commentsPanelAlreadyConstructed);
    }
    this.registerViewListeners(commentsPanelAlreadyConstructed);
    this._commentService.setWorkspaceComments(String(handle), []);
  }
  $unregisterCommentController(handle) {
    const providerId = this._handlers.get(handle);
    this._handlers.delete(handle);
    this._commentControllers.delete(handle);
    if (typeof providerId !== "string") {
      return;
    } else {
      this._commentService.unregisterCommentController(providerId);
    }
  }
  $updateCommentControllerFeatures(handle, features) {
    const provider = this._commentControllers.get(handle);
    if (!provider) {
      return void 0;
    }
    provider.updateFeatures(features);
  }
  $createCommentThread(handle, commentThreadHandle, threadId, resource, range, extensionId, isTemplate) {
    const provider = this._commentControllers.get(handle);
    if (!provider) {
      return void 0;
    }
    return provider.createCommentThread(extensionId.value, commentThreadHandle, threadId, resource, range, isTemplate);
  }
  $updateCommentThread(handle, commentThreadHandle, threadId, resource, changes) {
    const provider = this._commentControllers.get(handle);
    if (!provider) {
      return void 0;
    }
    return provider.updateCommentThread(commentThreadHandle, threadId, resource, changes);
  }
  $deleteCommentThread(handle, commentThreadHandle) {
    const provider = this._commentControllers.get(handle);
    if (!provider) {
      return;
    }
    return provider.deleteCommentThread(commentThreadHandle);
  }
  $updateCommentingRanges(handle) {
    const provider = this._commentControllers.get(handle);
    if (!provider) {
      return;
    }
    provider.updateCommentingRanges();
  }
  registerView(commentsViewAlreadyRegistered) {
    if (!commentsViewAlreadyRegistered) {
      const VIEW_CONTAINER2 = Registry.as(Extensions5.ViewContainersRegistry).registerViewContainer({
        id: COMMENTS_VIEW_ID,
        title: COMMENTS_VIEW_TITLE,
        ctorDescriptor: new SyncDescriptor(
          ViewPaneContainer,
          [COMMENTS_VIEW_ID, { mergeViewWithContainerWhenSingleView: true }]
        ),
        storageId: COMMENTS_VIEW_STORAGE_ID,
        hideIfEmpty: true,
        icon: commentsViewIcon,
        order: 10
      }, 1);
      Registry.as(Extensions5.ViewsRegistry).registerViews([{
        id: COMMENTS_VIEW_ID,
        name: COMMENTS_VIEW_TITLE,
        canToggleVisibility: false,
        ctorDescriptor: new SyncDescriptor(CommentsPanel),
        canMoveView: true,
        containerIcon: commentsViewIcon,
        focusCommand: {
          id: "workbench.action.focusCommentsPanel"
        }
      }], VIEW_CONTAINER2);
    }
  }
  setComments() {
    [...this._commentControllers.keys()].forEach((handle) => {
      const threads = this._commentControllers.get(handle).getAllComments();
      if (threads.length) {
        const providerId = this.getHandler(handle);
        this._commentService.setWorkspaceComments(providerId, threads);
      }
    });
  }
  registerViewOpenedListener() {
    if (!this._openViewListener) {
      this._openViewListener = this._viewsService.onDidChangeViewVisibility((e) => {
        if (e.id === COMMENTS_VIEW_ID && e.visible) {
          this.setComments();
          if (this._openViewListener) {
            this._openViewListener.dispose();
            this._openViewListener = null;
          }
        }
      });
    }
  }
  registerViewListeners(commentsPanelAlreadyConstructed) {
    if (!commentsPanelAlreadyConstructed) {
      this.registerViewOpenedListener();
    }
    this._register(this._viewDescriptorService.onDidChangeContainer((e) => {
      if (e.views.find((view) => view.id === COMMENTS_VIEW_ID)) {
        this.setComments();
        this.registerViewOpenedListener();
      }
    }));
    this._register(this._viewDescriptorService.onDidChangeContainerLocation((e) => {
      const commentsContainer = this._viewDescriptorService.getViewContainerByViewId(COMMENTS_VIEW_ID);
      if (e.viewContainer.id === (commentsContainer == null ? void 0 : commentsContainer.id)) {
        this.setComments();
        this.registerViewOpenedListener();
      }
    }));
  }
  getHandler(handle) {
    if (!this._handlers.has(handle)) {
      throw new Error("Unknown handler");
    }
    return this._handlers.get(handle);
  }
};
MainThreadComments = __decorate([
  extHostNamedCustomer(MainContext.MainThreadComments),
  __param(1, ICommentService),
  __param(2, IViewsService),
  __param(3, IViewDescriptorService)
], MainThreadComments);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebook.js
init_tslib_es6();
init_buffer();
init_cancellation();
init_event();
init_lifecycle();
init_stopwatch();
init_types();
init_commands();
init_log();

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebookDto.js
var NotebookDto;
(function(NotebookDto2) {
  function toNotebookOutputItemDto(item) {
    return {
      mime: item.mime,
      valueBytes: item.data
    };
  }
  NotebookDto2.toNotebookOutputItemDto = toNotebookOutputItemDto;
  function toNotebookOutputDto(output) {
    return {
      outputId: output.outputId,
      metadata: output.metadata,
      items: output.outputs.map(toNotebookOutputItemDto)
    };
  }
  NotebookDto2.toNotebookOutputDto = toNotebookOutputDto;
  function toNotebookCellDataDto(cell) {
    return {
      cellKind: cell.cellKind,
      language: cell.language,
      mime: cell.mime,
      source: cell.source,
      internalMetadata: cell.internalMetadata,
      metadata: cell.metadata,
      outputs: cell.outputs.map(toNotebookOutputDto)
    };
  }
  NotebookDto2.toNotebookCellDataDto = toNotebookCellDataDto;
  function toNotebookDataDto(data) {
    return {
      metadata: data.metadata,
      cells: data.cells.map(toNotebookCellDataDto)
    };
  }
  NotebookDto2.toNotebookDataDto = toNotebookDataDto;
  function fromNotebookOutputItemDto(item) {
    return {
      mime: item.mime,
      data: item.valueBytes
    };
  }
  NotebookDto2.fromNotebookOutputItemDto = fromNotebookOutputItemDto;
  function fromNotebookOutputDto(output) {
    return {
      outputId: output.outputId,
      metadata: output.metadata,
      outputs: output.items.map(fromNotebookOutputItemDto)
    };
  }
  NotebookDto2.fromNotebookOutputDto = fromNotebookOutputDto;
  function fromNotebookCellDataDto(cell) {
    return {
      cellKind: cell.cellKind,
      language: cell.language,
      mime: cell.mime,
      source: cell.source,
      outputs: cell.outputs.map(fromNotebookOutputDto),
      metadata: cell.metadata,
      internalMetadata: cell.internalMetadata
    };
  }
  NotebookDto2.fromNotebookCellDataDto = fromNotebookCellDataDto;
  function fromNotebookDataDto(data) {
    return {
      metadata: data.metadata,
      cells: data.cells.map(fromNotebookCellDataDto)
    };
  }
  NotebookDto2.fromNotebookDataDto = fromNotebookDataDto;
  function toNotebookCellDto(cell) {
    return {
      handle: cell.handle,
      uri: cell.uri,
      source: cell.textBuffer.getLinesContent(),
      eol: cell.textBuffer.getEOL(),
      language: cell.language,
      cellKind: cell.cellKind,
      outputs: cell.outputs.map(toNotebookOutputDto),
      metadata: cell.metadata,
      internalMetadata: cell.internalMetadata
    };
  }
  NotebookDto2.toNotebookCellDto = toNotebookCellDto;
  function fromCellExecuteUpdateDto(data) {
    if (data.editType === CellExecutionUpdateType.Output) {
      return {
        editType: data.editType,
        cellHandle: data.cellHandle,
        append: data.append,
        outputs: data.outputs.map(fromNotebookOutputDto)
      };
    } else if (data.editType === CellExecutionUpdateType.OutputItems) {
      return {
        editType: data.editType,
        append: data.append,
        outputId: data.outputId,
        items: data.items.map(fromNotebookOutputItemDto)
      };
    } else {
      return data;
    }
  }
  NotebookDto2.fromCellExecuteUpdateDto = fromCellExecuteUpdateDto;
  function fromCellExecuteCompleteDto(data) {
    return data;
  }
  NotebookDto2.fromCellExecuteCompleteDto = fromCellExecuteCompleteDto;
  function fromCellEditOperationDto(edit) {
    if (edit.editType === 1) {
      return {
        editType: edit.editType,
        index: edit.index,
        count: edit.count,
        cells: edit.cells.map(fromNotebookCellDataDto)
      };
    } else {
      return edit;
    }
  }
  NotebookDto2.fromCellEditOperationDto = fromCellEditOperationDto;
})(NotebookDto || (NotebookDto = {}));

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebook.js
init_proxyIdentifier();
init_extHost_protocol();
var MainThreadNotebooks = class MainThreadNotebooks2 {
  constructor(extHostContext, _notebookService, _cellStatusBarService, _logService) {
    this._notebookService = _notebookService;
    this._cellStatusBarService = _cellStatusBarService;
    this._logService = _logService;
    this._disposables = new DisposableStore();
    this._notebookSerializer = /* @__PURE__ */ new Map();
    this._notebookCellStatusBarRegistrations = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebook);
  }
  dispose() {
    this._disposables.dispose();
    dispose(this._notebookSerializer.values());
  }
  $registerNotebookSerializer(handle, extension, viewType, options, data) {
    const disposables = new DisposableStore();
    disposables.add(this._notebookService.registerNotebookSerializer(viewType, extension, {
      options,
      dataToNotebook: async (data2) => {
        const sw = new StopWatch();
        let result;
        if (data2.byteLength === 0 && viewType === "interactive") {
          result = NotebookDto.fromNotebookDataDto({ cells: [], metadata: {} });
        } else {
          const dto = await this._proxy.$dataToNotebook(handle, data2, CancellationToken.None);
          result = NotebookDto.fromNotebookDataDto(dto.value);
        }
        this._logService.trace(`[NotebookSerializer] dataToNotebook DONE after ${sw.elapsed()}ms`, {
          viewType,
          extensionId: extension.id.value
        });
        return result;
      },
      notebookToData: (data2) => {
        const sw = new StopWatch();
        const result = this._proxy.$notebookToData(handle, new SerializableObjectWithBuffers(NotebookDto.toNotebookDataDto(data2)), CancellationToken.None);
        this._logService.trace(`[NotebookSerializer] notebookToData DONE after ${sw.elapsed()}`, {
          viewType,
          extensionId: extension.id.value
        });
        return result;
      },
      save: async (uri, versionId, options2, token) => {
        const stat = await this._proxy.$saveNotebook(handle, uri, versionId, options2, token);
        return {
          ...stat,
          children: void 0,
          resource: uri
        };
      }
    }));
    if (data) {
      disposables.add(this._notebookService.registerContributedNotebookType(viewType, data));
    }
    this._notebookSerializer.set(handle, disposables);
    this._logService.trace("[NotebookSerializer] registered notebook serializer", {
      viewType,
      extensionId: extension.id.value
    });
  }
  $unregisterNotebookSerializer(handle) {
    var _a30;
    (_a30 = this._notebookSerializer.get(handle)) == null ? void 0 : _a30.dispose();
    this._notebookSerializer.delete(handle);
  }
  $emitCellStatusBarEvent(eventHandle) {
    const emitter = this._notebookCellStatusBarRegistrations.get(eventHandle);
    if (emitter instanceof Emitter) {
      emitter.fire(void 0);
    }
  }
  async $registerNotebookCellStatusBarItemProvider(handle, eventHandle, viewType) {
    const that = this;
    const provider = {
      async provideCellStatusBarItems(uri, index, token) {
        const result = await that._proxy.$provideNotebookCellStatusBarItems(handle, uri, index, token);
        return {
          items: (result == null ? void 0 : result.items) ?? [],
          dispose() {
            if (result) {
              that._proxy.$releaseNotebookCellStatusBarItems(result.cacheId);
            }
          }
        };
      },
      viewType
    };
    if (typeof eventHandle === "number") {
      const emitter = new Emitter();
      this._notebookCellStatusBarRegistrations.set(eventHandle, emitter);
      provider.onDidChangeStatusBarItems = emitter.event;
    }
    const disposable = this._cellStatusBarService.registerCellStatusBarItemProvider(provider);
    this._notebookCellStatusBarRegistrations.set(handle, disposable);
  }
  async $unregisterNotebookCellStatusBarItemProvider(handle, eventHandle) {
    const unregisterThing = (handle2) => {
      var _a30;
      const entry = this._notebookCellStatusBarRegistrations.get(handle2);
      if (entry) {
        (_a30 = this._notebookCellStatusBarRegistrations.get(handle2)) == null ? void 0 : _a30.dispose();
        this._notebookCellStatusBarRegistrations.delete(handle2);
      }
    };
    unregisterThing(handle);
    if (typeof eventHandle === "number") {
      unregisterThing(eventHandle);
    }
  }
};
MainThreadNotebooks = __decorate([
  extHostNamedCustomer(MainContext.MainThreadNotebook),
  __param(1, INotebookService),
  __param(2, INotebookCellStatusBarService),
  __param(3, ILogService)
], MainThreadNotebooks);
CommandsRegistry.registerCommand("_executeDataToNotebook", async (accessor, ...args) => {
  const [notebookType, bytes] = args;
  assertType(typeof notebookType === "string", "string");
  assertType(bytes instanceof VSBuffer, "VSBuffer");
  const notebookService = accessor.get(INotebookService);
  const info = await notebookService.withNotebookDataProvider(notebookType);
  if (!(info instanceof SimpleNotebookProviderInfo)) {
    return;
  }
  const dto = await info.serializer.dataToNotebook(bytes);
  return new SerializableObjectWithBuffers(NotebookDto.toNotebookDataDto(dto));
});
CommandsRegistry.registerCommand("_executeNotebookToData", async (accessor, ...args) => {
  const [notebookType, dto] = args;
  assertType(typeof notebookType === "string", "string");
  assertType(typeof dto === "object");
  const notebookService = accessor.get(INotebookService);
  const info = await notebookService.withNotebookDataProvider(notebookType);
  if (!(info instanceof SimpleNotebookProviderInfo)) {
    return;
  }
  const data = NotebookDto.fromNotebookDataDto(dto.value);
  const bytes = await info.serializer.notebookToData(data);
  return bytes;
});

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebookKernels.js
init_tslib_es6();
init_arrays();
init_cancellation();
init_errors();
init_event();
init_lifecycle();
init_uri();
init_language();
init_extHost_protocol();
var MainThreadKernel = class {
  get preloadUris() {
    return this.preloads.map((p) => p.uri);
  }
  get preloadProvides() {
    return this.preloads.map((p) => p.provides).flat();
  }
  constructor(data, _languageService) {
    var _a30;
    this._languageService = _languageService;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this.id = data.id;
    this.viewType = data.notebookType;
    this.extension = data.extensionId;
    this.implementsInterrupt = data.supportsInterrupt ?? false;
    this.label = data.label;
    this.description = data.description;
    this.detail = data.detail;
    this.supportedLanguages = isNonEmptyArray(data.supportedLanguages) ? data.supportedLanguages : _languageService.getRegisteredLanguageIds();
    this.implementsExecutionOrder = data.supportsExecutionOrder ?? false;
    this.localResourceRoot = URI.revive(data.extensionLocation);
    this.preloads = ((_a30 = data.preloads) == null ? void 0 : _a30.map((u) => ({ uri: URI.revive(u.uri), provides: u.provides }))) ?? [];
  }
  update(data) {
    const event = /* @__PURE__ */ Object.create(null);
    if (data.label !== void 0) {
      this.label = data.label;
      event.label = true;
    }
    if (data.description !== void 0) {
      this.description = data.description;
      event.description = true;
    }
    if (data.detail !== void 0) {
      this.detail = data.detail;
      event.detail = true;
    }
    if (data.supportedLanguages !== void 0) {
      this.supportedLanguages = isNonEmptyArray(data.supportedLanguages) ? data.supportedLanguages : this._languageService.getRegisteredLanguageIds();
      event.supportedLanguages = true;
    }
    if (data.supportsExecutionOrder !== void 0) {
      this.implementsExecutionOrder = data.supportsExecutionOrder;
      event.hasExecutionOrder = true;
    }
    if (data.supportsInterrupt !== void 0) {
      this.implementsInterrupt = data.supportsInterrupt;
      event.hasInterruptHandler = true;
    }
    this._onDidChange.fire(event);
  }
};
var MainThreadKernelDetectionTask = class {
  constructor(notebookType) {
    this.notebookType = notebookType;
  }
};
var MainThreadNotebookKernels = class MainThreadNotebookKernels2 {
  constructor(extHostContext, _languageService, _notebookKernelService, _notebookExecutionStateService, _notebookService, notebookEditorService) {
    this._languageService = _languageService;
    this._notebookKernelService = _notebookKernelService;
    this._notebookExecutionStateService = _notebookExecutionStateService;
    this._notebookService = _notebookService;
    this._editors = new DisposableMap();
    this._disposables = new DisposableStore();
    this._kernels = /* @__PURE__ */ new Map();
    this._kernelDetectionTasks = /* @__PURE__ */ new Map();
    this._kernelSourceActionProviders = /* @__PURE__ */ new Map();
    this._kernelSourceActionProvidersEventRegistrations = /* @__PURE__ */ new Map();
    this._executions = /* @__PURE__ */ new Map();
    this._notebookExecutions = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebookKernels);
    notebookEditorService.listNotebookEditors().forEach(this._onEditorAdd, this);
    notebookEditorService.onDidAddNotebookEditor(this._onEditorAdd, this, this._disposables);
    notebookEditorService.onDidRemoveNotebookEditor(this._onEditorRemove, this, this._disposables);
    this._disposables.add(toDisposable(() => {
      this._executions.forEach((e) => {
        e.complete({});
      });
      this._notebookExecutions.forEach((e) => e.complete());
    }));
    this._disposables.add(this._notebookExecutionStateService.onDidChangeExecution((e) => {
      var _a30;
      if (e.type === NotebookExecutionType.cell) {
        this._proxy.$cellExecutionChanged(e.notebook, e.cellHandle, (_a30 = e.changed) == null ? void 0 : _a30.state);
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
    for (const [, registration] of this._kernels.values()) {
      registration.dispose();
    }
    for (const [, registration] of this._kernelDetectionTasks.values()) {
      registration.dispose();
    }
    for (const [, registration] of this._kernelSourceActionProviders.values()) {
      registration.dispose();
    }
    this._editors.dispose();
  }
  _onEditorAdd(editor) {
    const ipcListener = editor.onDidReceiveMessage((e) => {
      if (!editor.hasModel()) {
        return;
      }
      const { selected } = this._notebookKernelService.getMatchingKernel(editor.textModel);
      if (!selected) {
        return;
      }
      for (const [handle, candidate] of this._kernels) {
        if (candidate[0] === selected) {
          this._proxy.$acceptKernelMessageFromRenderer(handle, editor.getId(), e.message);
          break;
        }
      }
    });
    this._editors.set(editor, ipcListener);
  }
  _onEditorRemove(editor) {
    this._editors.deleteAndDispose(editor);
  }
  async $postMessage(handle, editorId, message) {
    const tuple = this._kernels.get(handle);
    if (!tuple) {
      throw new Error("kernel already disposed");
    }
    const [kernel] = tuple;
    let didSend = false;
    for (const [editor] of this._editors) {
      if (!editor.hasModel()) {
        continue;
      }
      if (this._notebookKernelService.getMatchingKernel(editor.textModel).selected !== kernel) {
        continue;
      }
      if (editorId === void 0) {
        editor.postMessage(message);
        didSend = true;
      } else if (editor.getId() === editorId) {
        editor.postMessage(message);
        didSend = true;
        break;
      }
    }
    return didSend;
  }
  async $addKernel(handle, data) {
    const that = this;
    const kernel = new class extends MainThreadKernel {
      async executeNotebookCellsRequest(uri, handles) {
        await that._proxy.$executeCells(handle, uri, handles);
      }
      async cancelNotebookCellExecution(uri, handles) {
        await that._proxy.$cancelCells(handle, uri, handles);
      }
    }(data, this._languageService);
    const listener = this._notebookKernelService.onDidChangeSelectedNotebooks((e) => {
      if (e.oldKernel === kernel.id) {
        this._proxy.$acceptNotebookAssociation(handle, e.notebook, false);
      } else if (e.newKernel === kernel.id) {
        this._proxy.$acceptNotebookAssociation(handle, e.notebook, true);
      }
    });
    const registration = this._notebookKernelService.registerKernel(kernel);
    this._kernels.set(handle, [kernel, combinedDisposable(listener, registration)]);
  }
  $updateKernel(handle, data) {
    const tuple = this._kernels.get(handle);
    if (tuple) {
      tuple[0].update(data);
    }
  }
  $removeKernel(handle) {
    const tuple = this._kernels.get(handle);
    if (tuple) {
      tuple[1].dispose();
      this._kernels.delete(handle);
    }
  }
  $updateNotebookPriority(handle, notebook, value) {
    const tuple = this._kernels.get(handle);
    if (tuple) {
      this._notebookKernelService.updateKernelNotebookAffinity(tuple[0], URI.revive(notebook), value);
    }
  }
  $createExecution(handle, controllerId, rawUri, cellHandle) {
    var _a30;
    const uri = URI.revive(rawUri);
    const notebook = this._notebookService.getNotebookTextModel(uri);
    if (!notebook) {
      throw new Error(`Notebook not found: ${uri.toString()}`);
    }
    const kernel = this._notebookKernelService.getMatchingKernel(notebook);
    if (!kernel.selected || kernel.selected.id !== controllerId) {
      throw new Error(`Kernel is not selected: ${(_a30 = kernel.selected) == null ? void 0 : _a30.id} !== ${controllerId}`);
    }
    const execution = this._notebookExecutionStateService.createCellExecution(uri, cellHandle);
    execution.confirm();
    this._executions.set(handle, execution);
  }
  $updateExecution(handle, data) {
    const updates = data.value;
    try {
      const execution = this._executions.get(handle);
      execution == null ? void 0 : execution.update(updates.map(NotebookDto.fromCellExecuteUpdateDto));
    } catch (e) {
      onUnexpectedError(e);
    }
  }
  $completeExecution(handle, data) {
    try {
      const execution = this._executions.get(handle);
      execution == null ? void 0 : execution.complete(NotebookDto.fromCellExecuteCompleteDto(data.value));
    } catch (e) {
      onUnexpectedError(e);
    } finally {
      this._executions.delete(handle);
    }
  }
  $createNotebookExecution(handle, controllerId, rawUri) {
    var _a30;
    const uri = URI.revive(rawUri);
    const notebook = this._notebookService.getNotebookTextModel(uri);
    if (!notebook) {
      throw new Error(`Notebook not found: ${uri.toString()}`);
    }
    const kernel = this._notebookKernelService.getMatchingKernel(notebook);
    if (!kernel.selected || kernel.selected.id !== controllerId) {
      throw new Error(`Kernel is not selected: ${(_a30 = kernel.selected) == null ? void 0 : _a30.id} !== ${controllerId}`);
    }
    const execution = this._notebookExecutionStateService.createExecution(uri);
    execution.confirm();
    this._notebookExecutions.set(handle, execution);
  }
  $beginNotebookExecution(handle) {
    try {
      const execution = this._notebookExecutions.get(handle);
      execution == null ? void 0 : execution.begin();
    } catch (e) {
      onUnexpectedError(e);
    }
  }
  $completeNotebookExecution(handle) {
    try {
      const execution = this._notebookExecutions.get(handle);
      execution == null ? void 0 : execution.complete();
    } catch (e) {
      onUnexpectedError(e);
    } finally {
      this._notebookExecutions.delete(handle);
    }
  }
  async $addKernelDetectionTask(handle, notebookType) {
    const kernelDetectionTask = new MainThreadKernelDetectionTask(notebookType);
    const registration = this._notebookKernelService.registerNotebookKernelDetectionTask(kernelDetectionTask);
    this._kernelDetectionTasks.set(handle, [kernelDetectionTask, registration]);
  }
  $removeKernelDetectionTask(handle) {
    const tuple = this._kernelDetectionTasks.get(handle);
    if (tuple) {
      tuple[1].dispose();
      this._kernelDetectionTasks.delete(handle);
    }
  }
  async $addKernelSourceActionProvider(handle, eventHandle, notebookType) {
    const kernelSourceActionProvider = {
      viewType: notebookType,
      provideKernelSourceActions: async () => {
        const actions = await this._proxy.$provideKernelSourceActions(handle, CancellationToken.None);
        return actions.map((action) => {
          let documentation = action.documentation;
          if (action.documentation && typeof action.documentation !== "string") {
            documentation = URI.revive(action.documentation);
          }
          return {
            label: action.label,
            command: action.command,
            description: action.description,
            detail: action.detail,
            documentation
          };
        });
      }
    };
    if (typeof eventHandle === "number") {
      const emitter = new Emitter();
      this._kernelSourceActionProvidersEventRegistrations.set(eventHandle, emitter);
      kernelSourceActionProvider.onDidChangeSourceActions = emitter.event;
    }
    const registration = this._notebookKernelService.registerKernelSourceActionProvider(notebookType, kernelSourceActionProvider);
    this._kernelSourceActionProviders.set(handle, [kernelSourceActionProvider, registration]);
  }
  $removeKernelSourceActionProvider(handle, eventHandle) {
    const tuple = this._kernelSourceActionProviders.get(handle);
    if (tuple) {
      tuple[1].dispose();
      this._kernelSourceActionProviders.delete(handle);
    }
    if (typeof eventHandle === "number") {
      this._kernelSourceActionProvidersEventRegistrations.delete(eventHandle);
    }
  }
  $emitNotebookKernelSourceActionsChangeEvent(eventHandle) {
    const emitter = this._kernelSourceActionProvidersEventRegistrations.get(eventHandle);
    if (emitter instanceof Emitter) {
      emitter.fire(void 0);
    }
  }
};
MainThreadNotebookKernels = __decorate([
  extHostNamedCustomer(MainContext.MainThreadNotebookKernels),
  __param(1, ILanguageService),
  __param(2, INotebookKernelService),
  __param(3, INotebookExecutionStateService),
  __param(4, INotebookService),
  __param(5, INotebookEditorService)
], MainThreadNotebookKernels);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebookDocumentsAndEditors.js
init_tslib_es6();
init_lifecycle();
init_instantiation();
init_log();

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebookDocuments.js
init_tslib_es6();
init_lifecycle();
init_map();
init_uri();
init_notebookCommon();
init_extHost_protocol();
init_proxyIdentifier();
var MainThreadNotebookDocuments = class MainThreadNotebookDocuments2 {
  constructor(extHostContext, _notebookEditorModelResolverService, _uriIdentityService) {
    this._notebookEditorModelResolverService = _notebookEditorModelResolverService;
    this._uriIdentityService = _uriIdentityService;
    this._disposables = new DisposableStore();
    this._documentEventListenersMapping = new ResourceMap();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebookDocuments);
    this._modelReferenceCollection = new BoundModelReferenceCollection(this._uriIdentityService.extUri);
    this._disposables.add(this._notebookEditorModelResolverService.onDidChangeDirty((model) => this._proxy.$acceptDirtyStateChanged(model.resource, model.isDirty())));
    this._disposables.add(this._notebookEditorModelResolverService.onDidSaveNotebook((e) => this._proxy.$acceptModelSaved(e)));
    this._disposables.add(_notebookEditorModelResolverService.onWillFailWithConflict((e) => {
      this._modelReferenceCollection.remove(e.resource);
    }));
  }
  dispose() {
    this._disposables.dispose();
    this._modelReferenceCollection.dispose();
    dispose(this._documentEventListenersMapping.values());
  }
  handleNotebooksAdded(notebooks) {
    for (const textModel of notebooks) {
      const disposableStore = new DisposableStore();
      disposableStore.add(textModel.onDidChangeContent((event) => {
        const eventDto = {
          versionId: event.versionId,
          rawEvents: []
        };
        for (const e of event.rawEvents) {
          switch (e.kind) {
            case NotebookCellsChangeType.ModelChange:
              eventDto.rawEvents.push({
                kind: e.kind,
                changes: e.changes.map((diff) => [diff[0], diff[1], diff[2].map((cell) => NotebookDto.toNotebookCellDto(cell))])
              });
              break;
            case NotebookCellsChangeType.Move:
              eventDto.rawEvents.push({
                kind: e.kind,
                index: e.index,
                length: e.length,
                newIdx: e.newIdx
              });
              break;
            case NotebookCellsChangeType.Output:
              eventDto.rawEvents.push({
                kind: e.kind,
                index: e.index,
                outputs: e.outputs.map(NotebookDto.toNotebookOutputDto)
              });
              break;
            case NotebookCellsChangeType.OutputItem:
              eventDto.rawEvents.push({
                kind: e.kind,
                index: e.index,
                outputId: e.outputId,
                outputItems: e.outputItems.map(NotebookDto.toNotebookOutputItemDto),
                append: e.append
              });
              break;
            case NotebookCellsChangeType.ChangeCellLanguage:
            case NotebookCellsChangeType.ChangeCellContent:
            case NotebookCellsChangeType.ChangeCellMetadata:
            case NotebookCellsChangeType.ChangeCellInternalMetadata:
              eventDto.rawEvents.push(e);
              break;
          }
        }
        const hasDocumentMetadataChangeEvent = event.rawEvents.find((e) => e.kind === NotebookCellsChangeType.ChangeDocumentMetadata);
        this._proxy.$acceptModelChanged(textModel.uri, new SerializableObjectWithBuffers(eventDto), this._notebookEditorModelResolverService.isDirty(textModel.uri), hasDocumentMetadataChangeEvent ? textModel.metadata : void 0);
      }));
      this._documentEventListenersMapping.set(textModel.uri, disposableStore);
    }
  }
  handleNotebooksRemoved(uris) {
    var _a30;
    for (const uri of uris) {
      (_a30 = this._documentEventListenersMapping.get(uri)) == null ? void 0 : _a30.dispose();
      this._documentEventListenersMapping.delete(uri);
    }
  }
  async $tryCreateNotebook(options) {
    const ref = await this._notebookEditorModelResolverService.resolve({ untitledResource: void 0 }, options.viewType);
    ref.object.notebook.onWillDispose(() => {
      ref.dispose();
    });
    this._proxy.$acceptDirtyStateChanged(ref.object.resource, true);
    if (options.content) {
      const data = NotebookDto.fromNotebookDataDto(options.content);
      ref.object.notebook.reset(data.cells, data.metadata, ref.object.notebook.transientOptions);
    }
    return ref.object.resource;
  }
  async $tryOpenNotebook(uriComponents) {
    const uri = URI.revive(uriComponents);
    const ref = await this._notebookEditorModelResolverService.resolve(uri, void 0);
    this._modelReferenceCollection.add(uri, ref);
    return uri;
  }
  async $trySaveNotebook(uriComponents) {
    const uri = URI.revive(uriComponents);
    const ref = await this._notebookEditorModelResolverService.resolve(uri);
    const saveResult = await ref.object.save();
    ref.dispose();
    return saveResult;
  }
};
MainThreadNotebookDocuments = __decorate([
  __param(1, INotebookEditorModelResolverService),
  __param(2, IUriIdentityService)
], MainThreadNotebookDocuments);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebookEditors.js
init_tslib_es6();
init_lifecycle();
init_objects();
init_uri();
init_configuration();
init_extHost_protocol();
var MainThreadNotebook = class {
  constructor(editor, disposables) {
    this.editor = editor;
    this.disposables = disposables;
  }
  dispose() {
    this.disposables.dispose();
  }
};
var MainThreadNotebookEditors = class MainThreadNotebookEditors2 {
  constructor(extHostContext, _editorService, _notebookEditorService, _editorGroupService, _configurationService) {
    this._editorService = _editorService;
    this._notebookEditorService = _notebookEditorService;
    this._editorGroupService = _editorGroupService;
    this._configurationService = _configurationService;
    this._disposables = new DisposableStore();
    this._mainThreadEditors = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebookEditors);
    this._editorService.onDidActiveEditorChange(() => this._updateEditorViewColumns(), this, this._disposables);
    this._editorGroupService.onDidRemoveGroup(() => this._updateEditorViewColumns(), this, this._disposables);
    this._editorGroupService.onDidMoveGroup(() => this._updateEditorViewColumns(), this, this._disposables);
  }
  dispose() {
    this._disposables.dispose();
    dispose(this._mainThreadEditors.values());
  }
  handleEditorsAdded(editors) {
    for (const editor of editors) {
      const editorDisposables = new DisposableStore();
      editorDisposables.add(editor.onDidChangeVisibleRanges(() => {
        this._proxy.$acceptEditorPropertiesChanged(editor.getId(), { visibleRanges: { ranges: editor.visibleRanges } });
      }));
      editorDisposables.add(editor.onDidChangeSelection(() => {
        this._proxy.$acceptEditorPropertiesChanged(editor.getId(), { selections: { selections: editor.getSelections() } });
      }));
      const wrapper = new MainThreadNotebook(editor, editorDisposables);
      this._mainThreadEditors.set(editor.getId(), wrapper);
    }
  }
  handleEditorsRemoved(editorIds) {
    var _a30;
    for (const id of editorIds) {
      (_a30 = this._mainThreadEditors.get(id)) == null ? void 0 : _a30.dispose();
      this._mainThreadEditors.delete(id);
    }
  }
  _updateEditorViewColumns() {
    const result = /* @__PURE__ */ Object.create(null);
    for (const editorPane of this._editorService.visibleEditorPanes) {
      const candidate = getNotebookEditorFromEditorPane(editorPane);
      if (candidate && this._mainThreadEditors.has(candidate.getId())) {
        result[candidate.getId()] = editorGroupToColumn(this._editorGroupService, editorPane.group);
      }
    }
    if (!equals2(result, this._currentViewColumnInfo)) {
      this._currentViewColumnInfo = result;
      this._proxy.$acceptEditorViewColumns(result);
    }
  }
  async $tryShowNotebookDocument(resource, viewType, options) {
    const editorOptions = {
      cellSelections: options.selections,
      preserveFocus: options.preserveFocus,
      pinned: options.pinned,
      activation: options.preserveFocus ? EditorActivation.RESTORE : void 0,
      override: viewType
    };
    const editorPane = await this._editorService.openEditor({ resource: URI.revive(resource), options: editorOptions }, columnToEditorGroup(this._editorGroupService, this._configurationService, options.position));
    const notebookEditor = getNotebookEditorFromEditorPane(editorPane);
    if (notebookEditor) {
      return notebookEditor.getId();
    } else {
      throw new Error(`Notebook Editor creation failure for document ${JSON.stringify(resource)}`);
    }
  }
  async $tryRevealRange(id, range, revealType) {
    const editor = this._notebookEditorService.getNotebookEditor(id);
    if (!editor) {
      return;
    }
    const notebookEditor = editor;
    if (!notebookEditor.hasModel()) {
      return;
    }
    if (range.start >= notebookEditor.getLength()) {
      return;
    }
    const cell = notebookEditor.cellAt(range.start);
    switch (revealType) {
      case NotebookEditorRevealType.Default:
        return notebookEditor.revealCellRangeInView(range);
      case NotebookEditorRevealType.InCenter:
        return notebookEditor.revealInCenter(cell);
      case NotebookEditorRevealType.InCenterIfOutsideViewport:
        return notebookEditor.revealInCenterIfOutsideViewport(cell);
      case NotebookEditorRevealType.AtTop:
        return notebookEditor.revealInViewAtTop(cell);
    }
  }
  $trySetSelections(id, ranges) {
    const editor = this._notebookEditorService.getNotebookEditor(id);
    if (!editor) {
      return;
    }
    editor.setSelections(ranges);
    if (ranges.length) {
      editor.setFocus({ start: ranges[0].start, end: ranges[0].start + 1 });
    }
  }
};
MainThreadNotebookEditors = __decorate([
  __param(1, IEditorService),
  __param(2, INotebookEditorService),
  __param(3, IEditorGroupsService),
  __param(4, IConfigurationService)
], MainThreadNotebookEditors);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebookDocumentsAndEditors.js
init_extHost_protocol();
init_proxyIdentifier();
var MainThreadNotebooksAndEditors_1;
var NotebookAndEditorState = class {
  static delta(before, after) {
    if (!before) {
      return {
        addedDocuments: [...after.documents],
        removedDocuments: [],
        addedEditors: [...after.textEditors.values()],
        removedEditors: [],
        visibleEditors: [...after.visibleEditors].map((editor) => editor[0])
      };
    }
    const documentDelta = diffSets(before.documents, after.documents);
    const editorDelta = diffMaps(before.textEditors, after.textEditors);
    const newActiveEditor = before.activeEditor !== after.activeEditor ? after.activeEditor : void 0;
    const visibleEditorDelta = diffMaps(before.visibleEditors, after.visibleEditors);
    return {
      addedDocuments: documentDelta.added,
      removedDocuments: documentDelta.removed.map((e) => e.uri),
      addedEditors: editorDelta.added,
      removedEditors: editorDelta.removed.map((removed) => removed.getId()),
      newActiveEditor,
      visibleEditors: visibleEditorDelta.added.length === 0 && visibleEditorDelta.removed.length === 0 ? void 0 : [...after.visibleEditors].map((editor) => editor[0])
    };
  }
  constructor(documents, textEditors, activeEditor, visibleEditors) {
    this.documents = documents;
    this.textEditors = textEditors;
    this.activeEditor = activeEditor;
    this.visibleEditors = visibleEditors;
  }
};
var MainThreadNotebooksAndEditors = MainThreadNotebooksAndEditors_1 = class MainThreadNotebooksAndEditors2 {
  constructor(extHostContext, instantiationService, _notebookService, _notebookEditorService, _editorService, _editorGroupService, _logService) {
    this._notebookService = _notebookService;
    this._notebookEditorService = _notebookEditorService;
    this._editorService = _editorService;
    this._editorGroupService = _editorGroupService;
    this._logService = _logService;
    this._disposables = new DisposableStore();
    this._editorListeners = new DisposableMap();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebook);
    this._mainThreadNotebooks = instantiationService.createInstance(MainThreadNotebookDocuments, extHostContext);
    this._mainThreadEditors = instantiationService.createInstance(MainThreadNotebookEditors, extHostContext);
    extHostContext.set(MainContext.MainThreadNotebookDocuments, this._mainThreadNotebooks);
    extHostContext.set(MainContext.MainThreadNotebookEditors, this._mainThreadEditors);
    this._notebookService.onWillAddNotebookDocument(() => this._updateState(), this, this._disposables);
    this._notebookService.onDidRemoveNotebookDocument(() => this._updateState(), this, this._disposables);
    this._editorService.onDidActiveEditorChange(() => this._updateState(), this, this._disposables);
    this._editorService.onDidVisibleEditorsChange(() => this._updateState(), this, this._disposables);
    this._notebookEditorService.onDidAddNotebookEditor(this._handleEditorAdd, this, this._disposables);
    this._notebookEditorService.onDidRemoveNotebookEditor(this._handleEditorRemove, this, this._disposables);
    this._updateState();
  }
  dispose() {
    this._mainThreadNotebooks.dispose();
    this._mainThreadEditors.dispose();
    this._disposables.dispose();
    this._editorListeners.dispose();
  }
  _handleEditorAdd(editor) {
    this._editorListeners.set(editor.getId(), combinedDisposable(editor.onDidChangeModel(() => this._updateState()), editor.onDidFocusWidget(() => this._updateState(editor))));
    this._updateState();
  }
  _handleEditorRemove(editor) {
    this._editorListeners.deleteAndDispose(editor.getId());
    this._updateState();
  }
  _updateState(focusedEditor) {
    const editors = /* @__PURE__ */ new Map();
    const visibleEditorsMap = /* @__PURE__ */ new Map();
    for (const editor of this._notebookEditorService.listNotebookEditors()) {
      if (editor.hasModel()) {
        editors.set(editor.getId(), editor);
      }
    }
    const activeNotebookEditor = getNotebookEditorFromEditorPane(this._editorService.activeEditorPane);
    let activeEditor = null;
    if (activeNotebookEditor) {
      activeEditor = activeNotebookEditor.getId();
    } else if (focusedEditor == null ? void 0 : focusedEditor.textModel) {
      activeEditor = focusedEditor.getId();
    }
    if (activeEditor && !editors.has(activeEditor)) {
      this._logService.trace("MainThreadNotebooksAndEditors#_updateState: active editor is not in editors list", activeEditor, editors.keys());
      activeEditor = null;
    }
    for (const editorPane of this._editorService.visibleEditorPanes) {
      const notebookEditor = getNotebookEditorFromEditorPane(editorPane);
      if ((notebookEditor == null ? void 0 : notebookEditor.hasModel()) && editors.has(notebookEditor.getId())) {
        visibleEditorsMap.set(notebookEditor.getId(), notebookEditor);
      }
    }
    const newState = new NotebookAndEditorState(new Set(this._notebookService.listNotebookDocuments()), editors, activeEditor, visibleEditorsMap);
    this._onDelta(NotebookAndEditorState.delta(this._currentState, newState));
    this._currentState = newState;
  }
  _onDelta(delta3) {
    if (MainThreadNotebooksAndEditors_1._isDeltaEmpty(delta3)) {
      return;
    }
    const dto = {
      removedDocuments: delta3.removedDocuments,
      removedEditors: delta3.removedEditors,
      newActiveEditor: delta3.newActiveEditor,
      visibleEditors: delta3.visibleEditors,
      addedDocuments: delta3.addedDocuments.map(MainThreadNotebooksAndEditors_1._asModelAddData),
      addedEditors: delta3.addedEditors.map(this._asEditorAddData, this)
    };
    this._proxy.$acceptDocumentAndEditorsDelta(new SerializableObjectWithBuffers(dto));
    this._mainThreadEditors.handleEditorsRemoved(delta3.removedEditors);
    this._mainThreadNotebooks.handleNotebooksRemoved(delta3.removedDocuments);
    this._mainThreadNotebooks.handleNotebooksAdded(delta3.addedDocuments);
    this._mainThreadEditors.handleEditorsAdded(delta3.addedEditors);
  }
  static _isDeltaEmpty(delta3) {
    if (delta3.addedDocuments !== void 0 && delta3.addedDocuments.length > 0) {
      return false;
    }
    if (delta3.removedDocuments !== void 0 && delta3.removedDocuments.length > 0) {
      return false;
    }
    if (delta3.addedEditors !== void 0 && delta3.addedEditors.length > 0) {
      return false;
    }
    if (delta3.removedEditors !== void 0 && delta3.removedEditors.length > 0) {
      return false;
    }
    if (delta3.visibleEditors !== void 0 && delta3.visibleEditors.length > 0) {
      return false;
    }
    if (delta3.newActiveEditor !== void 0) {
      return false;
    }
    return true;
  }
  static _asModelAddData(e) {
    return {
      viewType: e.viewType,
      uri: e.uri,
      metadata: e.metadata,
      versionId: e.versionId,
      cells: e.cells.map(NotebookDto.toNotebookCellDto)
    };
  }
  _asEditorAddData(add) {
    const pane = this._editorService.visibleEditorPanes.find((pane2) => getNotebookEditorFromEditorPane(pane2) === add);
    return {
      id: add.getId(),
      documentUri: add.textModel.uri,
      selections: add.getSelections(),
      visibleRanges: add.visibleRanges,
      viewColumn: pane && editorGroupToColumn(this._editorGroupService, pane.group)
    };
  }
};
MainThreadNotebooksAndEditors = MainThreadNotebooksAndEditors_1 = __decorate([
  extHostCustomer,
  __param(1, IInstantiationService),
  __param(2, INotebookService),
  __param(3, INotebookEditorService),
  __param(4, IEditorService),
  __param(5, IEditorGroupsService),
  __param(6, ILogService)
], MainThreadNotebooksAndEditors);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebookRenderers.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
var MainThreadNotebookRenderers = class MainThreadNotebookRenderers2 extends Disposable {
  constructor(extHostContext, messaging) {
    super();
    this.messaging = messaging;
    this.proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebookRenderers);
    this._register(messaging.onShouldPostMessage((e) => {
      this.proxy.$postRendererMessage(e.editorId, e.rendererId, e.message);
    }));
  }
  $postMessage(editorId, rendererId, message) {
    return this.messaging.receiveMessage(editorId, rendererId, message);
  }
};
MainThreadNotebookRenderers = __decorate([
  extHostNamedCustomer(MainContext.MainThreadNotebookRenderers),
  __param(1, INotebookRendererMessagingService)
], MainThreadNotebookRenderers);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebookSaveParticipant.js
init_tslib_es6();
init_nls();
init_instantiation();
init_extHost_protocol();
init_async();

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookEditorModel.js
init_buffer();
init_errors();
init_event();
init_lifecycle();
init_network();
init_objects();
init_notebookCommon();
var NotebookFileWorkingCopyModel = class extends Disposable {
  constructor(_notebookModel, _notebookService, _configurationService) {
    super();
    this._notebookModel = _notebookModel;
    this._notebookService = _notebookService;
    this._configurationService = _configurationService;
    this._onDidChangeContent = this._register(new Emitter());
    this.onDidChangeContent = this._onDidChangeContent.event;
    this.configuration = void 0;
    this.onWillDispose = _notebookModel.onWillDispose.bind(_notebookModel);
    this._register(_notebookModel.onDidChangeContent((e) => {
      for (const rawEvent of e.rawEvents) {
        if (rawEvent.kind === NotebookCellsChangeType.Initialize) {
          continue;
        }
        if (rawEvent.transient) {
          continue;
        }
        this._onDidChangeContent.fire({
          isRedoing: false,
          isUndoing: false,
          isInitial: false
        });
        break;
      }
    }));
    if (_notebookModel.uri.scheme === Schemas.vscodeRemote) {
      this.configuration = {
        backupDelay: 1e4
      };
      if (this._configurationService.getValue(NotebookSetting.remoteSaving)) {
        this.save = async (options, token) => {
          const serializer = await this.getNotebookSerializer();
          if (token.isCancellationRequested) {
            throw new CancellationError();
          }
          const stat = await serializer.save(this._notebookModel.uri, this._notebookModel.versionId, options, token);
          return stat;
        };
      }
    }
  }
  dispose() {
    this._notebookModel.dispose();
    super.dispose();
  }
  get notebookModel() {
    return this._notebookModel;
  }
  async snapshot(token) {
    const serializer = await this.getNotebookSerializer();
    const data = {
      metadata: filter(this._notebookModel.metadata, (key) => !serializer.options.transientDocumentMetadata[key]),
      cells: []
    };
    for (const cell of this._notebookModel.cells) {
      const cellData = {
        cellKind: cell.cellKind,
        language: cell.language,
        mime: cell.mime,
        source: cell.getValue(),
        outputs: [],
        internalMetadata: cell.internalMetadata
      };
      cellData.outputs = !serializer.options.transientOutputs ? cell.outputs : [];
      cellData.metadata = filter(cell.metadata, (key) => !serializer.options.transientCellMetadata[key]);
      data.cells.push(cellData);
    }
    const bytes = await serializer.notebookToData(data);
    if (token.isCancellationRequested) {
      throw new CancellationError();
    }
    return bufferToStream(bytes);
  }
  async update(stream, token) {
    const serializer = await this.getNotebookSerializer();
    const bytes = await streamToBuffer(stream);
    const data = await serializer.dataToNotebook(bytes);
    if (token.isCancellationRequested) {
      throw new CancellationError();
    }
    this._notebookModel.reset(data.cells, data.metadata, serializer.options);
  }
  async getNotebookSerializer() {
    const info = await this._notebookService.withNotebookDataProvider(this.notebookModel.viewType);
    if (!(info instanceof SimpleNotebookProviderInfo)) {
      throw new Error("CANNOT open file notebook with this provider");
    }
    return info.serializer;
  }
  get versionId() {
    return this._notebookModel.alternativeVersionId;
  }
  pushStackElement() {
    this._notebookModel.pushStackElement("save", void 0, void 0);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadNotebookSaveParticipant.js
var ExtHostNotebookDocumentSaveParticipant2 = class {
  constructor(extHostContext) {
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebookDocumentSaveParticipant);
  }
  async participate(workingCopy, env2, _progress, token) {
    if (!workingCopy.model || !(workingCopy.model instanceof NotebookFileWorkingCopyModel)) {
      return void 0;
    }
    let _warningTimeout;
    const p = new Promise((resolve, reject) => {
      _warningTimeout = setTimeout(() => reject(new Error(localize(
        "timeout.onWillSave",
        "Aborted onWillSaveNotebookDocument-event after 1750ms"
      ))), 1750);
      this._proxy.$participateInSave(workingCopy.resource, env2.reason, token).then((_) => {
        clearTimeout(_warningTimeout);
        return void 0;
      }).then(resolve, reject);
    });
    return raceCancellationError(p, token);
  }
};
var SaveParticipant3 = class SaveParticipant4 {
  constructor(extHostContext, instantiationService, workingCopyFileService) {
    this.workingCopyFileService = workingCopyFileService;
    this._saveParticipantDisposable = this.workingCopyFileService.addSaveParticipant(instantiationService.createInstance(ExtHostNotebookDocumentSaveParticipant2, extHostContext));
  }
  dispose() {
    this._saveParticipantDisposable.dispose();
  }
};
SaveParticipant3 = __decorate([
  extHostCustomer,
  __param(1, IInstantiationService),
  __param(2, IWorkingCopyFileService)
], SaveParticipant3);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadInteractive.js
init_tslib_es6();
init_lifecycle();
init_modesRegistry();
init_extHost_protocol();
var MainThreadInteractive = class MainThreadInteractive2 {
  constructor(extHostContext, interactiveDocumentService) {
    this._disposables = new DisposableStore();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostInteractive);
    this._disposables.add(interactiveDocumentService.onWillAddInteractiveDocument((e) => {
      this._proxy.$willAddInteractiveDocument(e.inputUri, "\n", PLAINTEXT_LANGUAGE_ID, e.notebookUri);
    }));
    this._disposables.add(interactiveDocumentService.onWillRemoveInteractiveDocument((e) => {
      this._proxy.$willRemoveInteractiveDocument(e.inputUri, e.notebookUri);
    }));
  }
  dispose() {
    this._disposables.dispose();
  }
};
MainThreadInteractive = __decorate([
  extHostNamedCustomer(MainContext.MainThreadInteractive),
  __param(1, IInteractiveDocumentService)
], MainThreadInteractive);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadInlineChat.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
var MainThreadInlineChat = class MainThreadInlineChat2 {
  constructor(extHostContext, _inlineChatService, _uriIdentService) {
    this._inlineChatService = _inlineChatService;
    this._uriIdentService = _uriIdentService;
    this._registrations = new DisposableMap();
    this._progresses = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostInlineChat);
  }
  dispose() {
    this._registrations.dispose();
  }
  async $registerInteractiveEditorProvider(handle, label, debugName, supportsFeedback) {
    const unreg = this._inlineChatService.addProvider({
      debugName,
      label,
      prepareInlineChatSession: async (model, range, token) => {
        const session = await this._proxy.$prepareSession(handle, model.uri, range, token);
        if (!session) {
          return void 0;
        }
        return {
          ...session,
          dispose: () => {
            this._proxy.$releaseSession(handle, session.id);
          }
        };
      },
      provideResponse: async (item, request, progress, token) => {
        this._progresses.set(request.requestId, progress);
        try {
          const result = await this._proxy.$provideResponse(handle, item, request, token);
          if ((result == null ? void 0 : result.type) === "bulkEdit") {
            result.edits = reviveWorkspaceEditDto(result.edits, this._uriIdentService);
          }
          return result;
        } finally {
          this._progresses.delete(request.requestId);
        }
      },
      handleInlineChatResponseFeedback: !supportsFeedback ? void 0 : async (session, response, kind) => {
        this._proxy.$handleFeedback(handle, session.id, response.id, kind);
      }
    });
    this._registrations.set(handle, unreg);
  }
  async $handleProgressChunk(requestId, chunk) {
    var _a30;
    (_a30 = this._progresses.get(requestId)) == null ? void 0 : _a30.report(chunk);
  }
  async $unregisterInteractiveEditorProvider(handle) {
    this._registrations.deleteAndDispose(handle);
  }
};
MainThreadInlineChat = __decorate([
  extHostNamedCustomer(MainContext.MainThreadInlineChat),
  __param(1, IInlineChatService),
  __param(2, IUriIdentityService)
], MainThreadInlineChat);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadChat.js
init_tslib_es6();
init_async();
init_event();
init_lifecycle();
init_uri();
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/workbench/contrib/chat/common/chatModel.js
init_event();
init_htmlContent();
init_lifecycle();
var _ChatRequestModel = class _ChatRequestModel {
  get id() {
    return this._id;
  }
  get providerRequestId() {
    return this._providerRequestId;
  }
  get username() {
    return this.session.requesterUsername;
  }
  get avatarIconUri() {
    return this.session.requesterAvatarIconUri;
  }
  constructor(session, message, _providerRequestId) {
    this.session = session;
    this.message = message;
    this._providerRequestId = _providerRequestId;
    this._id = "request_" + _ChatRequestModel.nextId++;
  }
  setProviderRequestId(providerRequestId) {
    this._providerRequestId = providerRequestId;
  }
};
_ChatRequestModel.nextId = 0;
var ChatRequestModel = _ChatRequestModel;
var Response = class {
  get onDidChangeValue() {
    return this._onDidChangeValue.event;
  }
  get value() {
    return this._responseData;
  }
  constructor(value) {
    this._onDidChangeValue = new Emitter();
    this._responseData = Array.isArray(value) ? value : [value];
    this._responseParts = Array.isArray(value) ? value.map((v) => "value" in v ? { string: v } : { treeData: v }) : [{ string: value }];
    this._responseRepr = this._responseParts.map((part) => {
      if (isCompleteInteractiveProgressTreeData(part)) {
        return "";
      }
      return part.string.value;
    }).join("\n");
  }
  asString() {
    return this._responseRepr;
  }
  updateContent(responsePart, quiet) {
    var _a30;
    if (typeof responsePart === "string" || isMarkdownString(responsePart)) {
      const responsePartLength = this._responseParts.length - 1;
      const lastResponsePart = this._responseParts[responsePartLength];
      if (lastResponsePart.isPlaceholder === true || isCompleteInteractiveProgressTreeData(lastResponsePart)) {
        this._responseParts.push({ string: typeof responsePart === "string" ? new MarkdownString(responsePart) : responsePart });
      } else {
        if (isMarkdownString(responsePart)) {
          this._responseParts[responsePartLength] = { string: new MarkdownString(lastResponsePart.string.value + responsePart.value, responsePart) };
        } else {
          this._responseParts[responsePartLength] = { string: new MarkdownString(lastResponsePart.string.value + responsePart, lastResponsePart.string) };
        }
      }
      this._updateRepr(quiet);
    } else if ("placeholder" in responsePart) {
      const responsePosition = this._responseParts.push({ string: new MarkdownString(responsePart.placeholder), isPlaceholder: true }) - 1;
      this._updateRepr(quiet);
      (_a30 = responsePart.resolvedContent) == null ? void 0 : _a30.then((content) => {
        if (typeof content === "string") {
          this._responseParts[responsePosition] = { string: new MarkdownString(content), isPlaceholder: true };
          this._updateRepr(quiet);
        } else if (content.treeData) {
          this._responseParts[responsePosition] = { treeData: content.treeData };
          this._updateRepr(quiet);
        }
      });
    } else if (isCompleteInteractiveProgressTreeData(responsePart)) {
      this._responseParts.push(responsePart);
      this._updateRepr(quiet);
    }
  }
  _updateRepr(quiet) {
    this._responseData = this._responseParts.map((part) => {
      if (isCompleteInteractiveProgressTreeData(part)) {
        return part.treeData;
      } else if (part.isPlaceholder) {
        return { ...part.string, isPlaceholder: true };
      }
      return part.string;
    });
    this._responseRepr = this._responseParts.map((part) => {
      if (isCompleteInteractiveProgressTreeData(part)) {
        return "";
      }
      return part.string.value;
    }).join("\n\n");
    if (!quiet) {
      this._onDidChangeValue.fire();
    }
  }
};
var _ChatResponseModel = class _ChatResponseModel extends Disposable {
  get id() {
    return this._id;
  }
  get providerResponseId() {
    return this._providerResponseId;
  }
  get isComplete() {
    return this._isComplete;
  }
  get isCanceled() {
    return this._isCanceled;
  }
  get vote() {
    return this._vote;
  }
  get followups() {
    return this._followups;
  }
  get response() {
    return this._response;
  }
  get errorDetails() {
    return this._errorDetails;
  }
  get providerId() {
    return this.session.providerId;
  }
  get username() {
    return this.session.responderUsername;
  }
  get avatarIconUri() {
    return this.session.responderAvatarIconUri;
  }
  constructor(_response, session, _isComplete = false, _isCanceled = false, _vote, _providerResponseId, _errorDetails, _followups) {
    super();
    this.session = session;
    this._isComplete = _isComplete;
    this._isCanceled = _isCanceled;
    this._vote = _vote;
    this._providerResponseId = _providerResponseId;
    this._errorDetails = _errorDetails;
    this._followups = _followups;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._response = new Response(_response);
    this._register(this._response.onDidChangeValue(() => this._onDidChange.fire()));
    this._id = "response_" + _ChatResponseModel.nextId++;
  }
  updateContent(responsePart, quiet) {
    this._response.updateContent(responsePart, quiet);
  }
  setProviderResponseId(providerResponseId) {
    this._providerResponseId = providerResponseId;
  }
  setErrorDetails(errorDetails) {
    this._errorDetails = errorDetails;
    this._onDidChange.fire();
  }
  complete() {
    this._isComplete = true;
    this._onDidChange.fire();
  }
  cancel() {
    this._isComplete = true;
    this._isCanceled = true;
    this._onDidChange.fire();
  }
  setFollowups(followups) {
    this._followups = followups;
    this._onDidChange.fire();
  }
  setVote(vote) {
    this._vote = vote;
    this._onDidChange.fire();
  }
};
_ChatResponseModel.nextId = 0;
var ChatResponseModel = _ChatResponseModel;
var _ChatWelcomeMessageModel = class _ChatWelcomeMessageModel {
  get id() {
    return this._id;
  }
  constructor(session, content) {
    this.session = session;
    this.content = content;
    this._id = "welcome_" + _ChatWelcomeMessageModel.nextId++;
  }
  get username() {
    return this.session.responderUsername;
  }
  get avatarIconUri() {
    return this.session.responderAvatarIconUri;
  }
};
_ChatWelcomeMessageModel.nextId = 0;
var ChatWelcomeMessageModel = _ChatWelcomeMessageModel;
function isCompleteInteractiveProgressTreeData(item) {
  return typeof item === "object" && !!item && "treeData" in item;
}

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadChat.js
var MainThreadChat = class MainThreadChat2 extends Disposable {
  constructor(extHostContext, _chatService, _chatWidgetService, chatContribService) {
    super();
    this._chatService = _chatService;
    this._chatWidgetService = _chatWidgetService;
    this.chatContribService = chatContribService;
    this._providerRegistrations = this._register(new DisposableMap());
    this._activeRequestProgressCallbacks = /* @__PURE__ */ new Map();
    this._stateEmitters = /* @__PURE__ */ new Map();
    this._responsePartHandlePool = 0;
    this._activeResponsePartPromises = /* @__PURE__ */ new Map();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostChat);
    this._register(this._chatService.onDidPerformUserAction((e) => {
      this._proxy.$onDidPerformUserAction(e);
    }));
  }
  $transferChatSession(sessionId, toWorkspace) {
    const sessionIdStr = this._chatService.getSessionId(sessionId);
    if (!sessionIdStr) {
      throw new Error(`Failed to transfer session. Unknown session provider ID: ${sessionId}`);
    }
    const widget = this._chatWidgetService.getWidgetBySessionId(sessionIdStr);
    const inputValue = (widget == null ? void 0 : widget.inputEditor.getValue()) ?? "";
    this._chatService.transferChatSession({ sessionId: sessionIdStr, inputValue }, URI.revive(toWorkspace));
  }
  async $registerChatProvider(handle, id) {
    const registration = this.chatContribService.registeredProviders.find((staticProvider) => staticProvider.id === id);
    if (!registration) {
      throw new Error(`Provider ${id} must be declared in the package.json.`);
    }
    const unreg = this._chatService.registerProvider({
      id,
      displayName: registration.label,
      prepareSession: async (initialState, token) => {
        const session = await this._proxy.$prepareChat(handle, initialState, token);
        if (!session) {
          return void 0;
        }
        const responderAvatarIconUri = session.responderAvatarIconUri ? URI.revive(session.responderAvatarIconUri) : registration.extensionIcon;
        const emitter = new Emitter();
        this._stateEmitters.set(session.id, emitter);
        return {
          id: session.id,
          requesterUsername: session.requesterUsername,
          requesterAvatarIconUri: URI.revive(session.requesterAvatarIconUri),
          responderUsername: session.responderUsername,
          responderAvatarIconUri,
          inputPlaceholder: session.inputPlaceholder,
          onDidChangeState: emitter.event,
          dispose: () => {
            emitter.dispose();
            this._stateEmitters.delete(session.id);
            this._proxy.$releaseSession(session.id);
          }
        };
      },
      resolveRequest: async (session, context, token) => {
        const dto = await this._proxy.$resolveRequest(handle, session.id, context, token);
        return {
          session,
          ...dto
        };
      },
      provideReply: async (request, progress, token) => {
        const id2 = `${handle}_${request.session.id}`;
        this._activeRequestProgressCallbacks.set(id2, progress);
        try {
          const requestDto = {
            message: request.message,
            variables: request.variables
          };
          const dto = await this._proxy.$provideReply(handle, request.session.id, requestDto, token);
          return {
            session: request.session,
            ...dto
          };
        } finally {
          this._activeRequestProgressCallbacks.delete(id2);
        }
      },
      provideWelcomeMessage: (token) => {
        return this._proxy.$provideWelcomeMessage(handle, token);
      },
      provideSlashCommands: (session, token) => {
        return this._proxy.$provideSlashCommands(handle, session.id, token);
      },
      provideFollowups: (session, token) => {
        return this._proxy.$provideFollowups(handle, session.id, token);
      },
      removeRequest: (session, requestId) => {
        return this._proxy.$removeRequest(handle, session.id, requestId);
      }
    });
    this._providerRegistrations.set(handle, unreg);
  }
  async $acceptResponseProgress(handle, sessionId, progress, responsePartHandle) {
    var _a30, _b;
    const id = `${handle}_${sessionId}`;
    if ("placeholder" in progress) {
      const responsePartId = `${id}_${++this._responsePartHandlePool}`;
      const deferredContentPromise = new DeferredPromise();
      this._activeResponsePartPromises.set(responsePartId, deferredContentPromise);
      (_a30 = this._activeRequestProgressCallbacks.get(id)) == null ? void 0 : _a30({ ...progress, resolvedContent: deferredContentPromise.p });
      return this._responsePartHandlePool;
    } else if (responsePartHandle) {
      const responsePartId = `${id}_${responsePartHandle}`;
      const deferredContentPromise = this._activeResponsePartPromises.get(responsePartId);
      if (deferredContentPromise && isCompleteInteractiveProgressTreeData(progress)) {
        const withRevivedUris = revive(progress);
        deferredContentPromise.complete(withRevivedUris);
        this._activeResponsePartPromises.delete(responsePartId);
      } else if (deferredContentPromise && "content" in progress) {
        deferredContentPromise.complete(progress.content);
        this._activeResponsePartPromises.delete(responsePartId);
      }
      return;
    }
    if (isCompleteInteractiveProgressTreeData(progress)) {
      return;
    }
    (_b = this._activeRequestProgressCallbacks.get(id)) == null ? void 0 : _b(progress);
  }
  async $acceptChatState(sessionId, state) {
    var _a30;
    (_a30 = this._stateEmitters.get(sessionId)) == null ? void 0 : _a30.fire(state);
  }
  $addRequest(context) {
    this._chatService.addRequest(context);
  }
  async $sendRequestToProvider(providerId, message) {
    const widget = await this._chatWidgetService.revealViewForProvider(providerId);
    if (widget && widget.viewModel) {
      this._chatService.sendRequestToProvider(widget.viewModel.sessionId, message);
    }
  }
  async $unregisterChatProvider(handle) {
    this._providerRegistrations.deleteAndDispose(handle);
  }
};
MainThreadChat = __decorate([
  extHostNamedCustomer(MainContext.MainThreadChat),
  __param(1, IChatService),
  __param(2, IChatWidgetService),
  __param(3, IChatContributionService)
], MainThreadChat);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTask.js
init_tslib_es6();
init_nls();
init_uri();
init_uuid();
init_types();
init_platform();

// node_modules/vscode/vscode/src/vs/workbench/contrib/tasks/common/tasks.js
init_nls();
init_types();
init_resources();
init_objects();

// node_modules/vscode/vscode/src/vs/workbench/contrib/tasks/common/taskDefinitionRegistry.js
init_nls();
init_types();
init_objects();
init_contextkey();
init_event();
var taskDefinitionSchema = {
  type: "object",
  additionalProperties: false,
  properties: {
    type: {
      type: "string",
      description: localize(
        "TaskDefinition.description",
        "The actual task type. Please note that types starting with a '$' are reserved for internal usage."
      )
    },
    required: {
      type: "array",
      items: {
        type: "string"
      }
    },
    properties: {
      type: "object",
      description: localize("TaskDefinition.properties", "Additional properties of the task type"),
      additionalProperties: {
        $ref: "http://json-schema.org/draft-07/schema#"
      }
    },
    when: {
      type: "string",
      markdownDescription: localize(
        "TaskDefinition.when",
        "Condition which must be true to enable this type of task. Consider using `shellExecutionSupported`, `processExecutionSupported`, and `customExecutionSupported` as appropriate for this task definition. See the [API documentation](https://code.visualstudio.com/api/extension-guides/task-provider#when-clause) for more information."
      ),
      default: ""
    }
  }
};
var Configuration2;
(function(Configuration3) {
  function from(value, extensionId, messageCollector) {
    if (!value) {
      return void 0;
    }
    const taskType = isString(value.type) ? value.type : void 0;
    if (!taskType || taskType.length === 0) {
      messageCollector.error(localize(
        "TaskTypeConfiguration.noType",
        "The task type configuration is missing the required 'taskType' property"
      ));
      return void 0;
    }
    const required = [];
    if (Array.isArray(value.required)) {
      for (const element of value.required) {
        if (isString(element)) {
          required.push(element);
        }
      }
    }
    return {
      extensionId: extensionId.value,
      taskType,
      required,
      properties: value.properties ? deepClone(value.properties) : {},
      when: value.when ? ContextKeyExpr.deserialize(value.when) : void 0
    };
  }
  Configuration3.from = from;
})(Configuration2 || (Configuration2 = {}));
var taskDefinitionsExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "taskDefinitions",
  activationEventsGenerator: (contributions, result) => {
    for (const task of contributions) {
      if (task.type) {
        result.push(`onTaskType:${task.type}`);
      }
    }
  },
  jsonSchema: {
    description: localize("TaskDefinitionExtPoint", "Contributes task kinds"),
    type: "array",
    items: taskDefinitionSchema
  }
});
var TaskDefinitionRegistryImpl = class {
  constructor() {
    this._onDefinitionsChanged = new Emitter();
    this.onDefinitionsChanged = this._onDefinitionsChanged.event;
    this.taskTypes = /* @__PURE__ */ Object.create(null);
    this.readyPromise = new Promise((resolve, reject) => {
      taskDefinitionsExtPoint.setHandler((extensions, delta3) => {
        this._schema = void 0;
        try {
          for (const extension of delta3.removed) {
            const taskTypes = extension.value;
            for (const taskType of taskTypes) {
              if (this.taskTypes && taskType.type && this.taskTypes[taskType.type]) {
                delete this.taskTypes[taskType.type];
              }
            }
          }
          for (const extension of delta3.added) {
            const taskTypes = extension.value;
            for (const taskType of taskTypes) {
              const type = Configuration2.from(taskType, extension.description.identifier, extension.collector);
              if (type) {
                this.taskTypes[type.taskType] = type;
              }
            }
          }
          if (delta3.removed.length > 0 || delta3.added.length > 0) {
            this._onDefinitionsChanged.fire();
          }
        } catch (error) {
        }
        resolve(void 0);
      });
    });
  }
  onReady() {
    return this.readyPromise;
  }
  get(key) {
    return this.taskTypes[key];
  }
  all() {
    return Object.keys(this.taskTypes).map((key) => this.taskTypes[key]);
  }
  getJsonSchema() {
    if (this._schema === void 0) {
      const schemas = [];
      for (const definition of this.all()) {
        const schema = {
          type: "object",
          additionalProperties: false
        };
        if (definition.required.length > 0) {
          schema.required = definition.required.slice(0);
        }
        if (definition.properties !== void 0) {
          schema.properties = deepClone(definition.properties);
        } else {
          schema.properties = /* @__PURE__ */ Object.create(null);
        }
        schema.properties.type = {
          type: "string",
          enum: [definition.taskType]
        };
        schemas.push(schema);
      }
      this._schema = { oneOf: schemas };
    }
    return this._schema;
  }
};
var TaskDefinitionRegistry = new TaskDefinitionRegistryImpl();

// node_modules/vscode/vscode/src/vs/workbench/contrib/tasks/common/tasks.js
var USER_TASKS_GROUP_KEY = "settings";
var CUSTOMIZED_TASK_TYPE = "$customized";
var CommandOptions;
(function(CommandOptions2) {
  CommandOptions2.defaults = { cwd: "${workspaceFolder}" };
})(CommandOptions || (CommandOptions = {}));
var RevealKind;
(function(RevealKind2) {
  RevealKind2[RevealKind2["Always"] = 1] = "Always";
  RevealKind2[RevealKind2["Silent"] = 2] = "Silent";
  RevealKind2[RevealKind2["Never"] = 3] = "Never";
})(RevealKind || (RevealKind = {}));
(function(RevealKind2) {
  function fromString(value) {
    switch (value.toLowerCase()) {
      case "always":
        return RevealKind2.Always;
      case "silent":
        return RevealKind2.Silent;
      case "never":
        return RevealKind2.Never;
      default:
        return RevealKind2.Always;
    }
  }
  RevealKind2.fromString = fromString;
})(RevealKind || (RevealKind = {}));
var RevealProblemKind;
(function(RevealProblemKind2) {
  RevealProblemKind2[RevealProblemKind2["Never"] = 1] = "Never";
  RevealProblemKind2[RevealProblemKind2["OnProblem"] = 2] = "OnProblem";
  RevealProblemKind2[RevealProblemKind2["Always"] = 3] = "Always";
})(RevealProblemKind || (RevealProblemKind = {}));
(function(RevealProblemKind2) {
  function fromString(value) {
    switch (value.toLowerCase()) {
      case "always":
        return RevealProblemKind2.Always;
      case "never":
        return RevealProblemKind2.Never;
      case "onproblem":
        return RevealProblemKind2.OnProblem;
      default:
        return RevealProblemKind2.OnProblem;
    }
  }
  RevealProblemKind2.fromString = fromString;
})(RevealProblemKind || (RevealProblemKind = {}));
var PanelKind;
(function(PanelKind2) {
  PanelKind2[PanelKind2["Shared"] = 1] = "Shared";
  PanelKind2[PanelKind2["Dedicated"] = 2] = "Dedicated";
  PanelKind2[PanelKind2["New"] = 3] = "New";
})(PanelKind || (PanelKind = {}));
(function(PanelKind2) {
  function fromString(value) {
    switch (value.toLowerCase()) {
      case "shared":
        return PanelKind2.Shared;
      case "dedicated":
        return PanelKind2.Dedicated;
      case "new":
        return PanelKind2.New;
      default:
        return PanelKind2.Shared;
    }
  }
  PanelKind2.fromString = fromString;
})(PanelKind || (PanelKind = {}));
var PresentationOptions;
(function(PresentationOptions2) {
  PresentationOptions2.defaults = {
    echo: true,
    reveal: RevealKind.Always,
    revealProblems: RevealProblemKind.Never,
    focus: false,
    panel: PanelKind.Shared,
    showReuseMessage: true,
    clear: false
  };
})(PresentationOptions || (PresentationOptions = {}));
var RuntimeType;
(function(RuntimeType2) {
  RuntimeType2[RuntimeType2["Shell"] = 1] = "Shell";
  RuntimeType2[RuntimeType2["Process"] = 2] = "Process";
  RuntimeType2[RuntimeType2["CustomExecution"] = 3] = "CustomExecution";
})(RuntimeType || (RuntimeType = {}));
(function(RuntimeType2) {
  function fromString(value) {
    switch (value.toLowerCase()) {
      case "shell":
        return RuntimeType2.Shell;
      case "process":
        return RuntimeType2.Process;
      case "customExecution":
        return RuntimeType2.CustomExecution;
      default:
        return RuntimeType2.Process;
    }
  }
  RuntimeType2.fromString = fromString;
  function toString(value) {
    switch (value) {
      case RuntimeType2.Shell:
        return "shell";
      case RuntimeType2.Process:
        return "process";
      case RuntimeType2.CustomExecution:
        return "customExecution";
      default:
        return "process";
    }
  }
  RuntimeType2.toString = toString;
})(RuntimeType || (RuntimeType = {}));
var TaskSourceKind;
(function(TaskSourceKind2) {
  TaskSourceKind2.Workspace = "workspace";
  TaskSourceKind2.Extension = "extension";
  TaskSourceKind2.InMemory = "inMemory";
  TaskSourceKind2.WorkspaceFile = "workspaceFile";
  TaskSourceKind2.User = "user";
  function toConfigurationTarget(kind) {
    switch (kind) {
      case TaskSourceKind2.User:
        return 2;
      case TaskSourceKind2.WorkspaceFile:
        return 5;
      default:
        return 6;
    }
  }
  TaskSourceKind2.toConfigurationTarget = toConfigurationTarget;
})(TaskSourceKind || (TaskSourceKind = {}));
var RunOnOptions;
(function(RunOnOptions2) {
  RunOnOptions2[RunOnOptions2["default"] = 1] = "default";
  RunOnOptions2[RunOnOptions2["folderOpen"] = 2] = "folderOpen";
})(RunOnOptions || (RunOnOptions = {}));
var RunOptions;
(function(RunOptions2) {
  RunOptions2.defaults = { reevaluateOnRerun: true, runOn: RunOnOptions.default, instanceLimit: 1 };
})(RunOptions || (RunOptions = {}));
var CommonTask = class {
  constructor(id, label, type, runOptions, configurationProperties, source) {
    this._label = "";
    this._id = id;
    if (label) {
      this._label = label;
    }
    if (type) {
      this.type = type;
    }
    this.runOptions = runOptions;
    this.configurationProperties = configurationProperties;
    this._source = source;
  }
  getDefinition(useSource) {
    return void 0;
  }
  getMapKey() {
    return this._id;
  }
  getRecentlyUsedKey() {
    return void 0;
  }
  getCommonTaskId() {
    const key = { folder: this.getFolderId(), id: this._id };
    return JSON.stringify(key);
  }
  clone() {
    return this.fromObject(Object.assign({}, this));
  }
  getWorkspaceFolder() {
    return void 0;
  }
  getWorkspaceFileName() {
    return void 0;
  }
  getTelemetryKind() {
    return "unknown";
  }
  matches(key, compareId = false) {
    if (key === void 0) {
      return false;
    }
    if (isString(key)) {
      return key === this._label || key === this.configurationProperties.identifier || compareId && key === this._id;
    }
    const identifier = this.getDefinition(true);
    return identifier !== void 0 && identifier._key === key._key;
  }
  getQualifiedLabel() {
    const workspaceFolder = this.getWorkspaceFolder();
    if (workspaceFolder) {
      return `${this._label} (${workspaceFolder.name})`;
    } else {
      return this._label;
    }
  }
  getTaskExecution() {
    const result = {
      id: this._id,
      task: this
    };
    return result;
  }
  addTaskLoadMessages(messages) {
    if (this._taskLoadMessages === void 0) {
      this._taskLoadMessages = [];
    }
    if (messages) {
      this._taskLoadMessages = this._taskLoadMessages.concat(messages);
    }
  }
  get taskLoadMessages() {
    return this._taskLoadMessages;
  }
};
var CustomTask = class _CustomTask extends CommonTask {
  constructor(id, source, label, type, command, hasDefinedMatchers, runOptions, configurationProperties) {
    super(id, label, void 0, runOptions, configurationProperties, source);
    this.command = {};
    this._source = source;
    this.hasDefinedMatchers = hasDefinedMatchers;
    if (command) {
      this.command = command;
    }
  }
  clone() {
    return new _CustomTask(
      this._id,
      this._source,
      this._label,
      this.type,
      this.command,
      this.hasDefinedMatchers,
      this.runOptions,
      this.configurationProperties
    );
  }
  customizes() {
    if (this._source && this._source.customizes) {
      return this._source.customizes;
    }
    return void 0;
  }
  getDefinition(useSource = false) {
    if (useSource && this._source.customizes !== void 0) {
      return this._source.customizes;
    } else {
      let type;
      const commandRuntime = this.command ? this.command.runtime : void 0;
      switch (commandRuntime) {
        case RuntimeType.Shell:
          type = "shell";
          break;
        case RuntimeType.Process:
          type = "process";
          break;
        case RuntimeType.CustomExecution:
          type = "customExecution";
          break;
        case void 0:
          type = "$composite";
          break;
        default:
          throw new Error("Unexpected task runtime");
      }
      const result = {
        type,
        _key: this._id,
        id: this._id
      };
      return result;
    }
  }
  static is(value) {
    return value instanceof _CustomTask;
  }
  getMapKey() {
    const workspaceFolder = this._source.config.workspaceFolder;
    return workspaceFolder ? `${workspaceFolder.uri.toString()}|${this._id}|${this.instance}` : `${this._id}|${this.instance}`;
  }
  getFolderId() {
    var _a30;
    return this._source.kind === TaskSourceKind.User ? USER_TASKS_GROUP_KEY : (_a30 = this._source.config.workspaceFolder) == null ? void 0 : _a30.uri.toString();
  }
  getCommonTaskId() {
    return this._source.customizes ? super.getCommonTaskId() : this.getRecentlyUsedKey() ?? super.getCommonTaskId();
  }
  getRecentlyUsedKey() {
    const workspaceFolder = this.getFolderId();
    if (!workspaceFolder) {
      return void 0;
    }
    let id = this.configurationProperties.identifier;
    if (this._source.kind !== TaskSourceKind.Workspace) {
      id += this._source.kind;
    }
    const key = { type: CUSTOMIZED_TASK_TYPE, folder: workspaceFolder, id };
    return JSON.stringify(key);
  }
  getWorkspaceFolder() {
    return this._source.config.workspaceFolder;
  }
  getWorkspaceFileName() {
    return this._source.config.workspace && this._source.config.workspace.configuration ? basename2(this._source.config.workspace.configuration) : void 0;
  }
  getTelemetryKind() {
    if (this._source.customizes) {
      return "workspace>extension";
    } else {
      return "workspace";
    }
  }
  fromObject(object) {
    return new _CustomTask(
      object._id,
      object._source,
      object._label,
      object.type,
      object.command,
      object.hasDefinedMatchers,
      object.runOptions,
      object.configurationProperties
    );
  }
};
var ConfiguringTask = class _ConfiguringTask extends CommonTask {
  constructor(id, source, label, type, configures, runOptions, configurationProperties) {
    super(id, label, type, runOptions, configurationProperties, source);
    this._source = source;
    this.configures = configures;
  }
  static is(value) {
    return value instanceof _ConfiguringTask;
  }
  fromObject(object) {
    return object;
  }
  getDefinition() {
    return this.configures;
  }
  getWorkspaceFileName() {
    return this._source.config.workspace && this._source.config.workspace.configuration ? basename2(this._source.config.workspace.configuration) : void 0;
  }
  getWorkspaceFolder() {
    return this._source.config.workspaceFolder;
  }
  getFolderId() {
    var _a30;
    return this._source.kind === TaskSourceKind.User ? USER_TASKS_GROUP_KEY : (_a30 = this._source.config.workspaceFolder) == null ? void 0 : _a30.uri.toString();
  }
  getRecentlyUsedKey() {
    const workspaceFolder = this.getFolderId();
    if (!workspaceFolder) {
      return void 0;
    }
    let id = this.configurationProperties.identifier;
    if (this._source.kind !== TaskSourceKind.Workspace) {
      id += this._source.kind;
    }
    const key = { type: CUSTOMIZED_TASK_TYPE, folder: workspaceFolder, id };
    return JSON.stringify(key);
  }
};
var ContributedTask = class _ContributedTask extends CommonTask {
  constructor(id, source, label, type, defines, command, hasDefinedMatchers, runOptions, configurationProperties) {
    super(id, label, type, runOptions, configurationProperties, source);
    this.defines = defines;
    this.hasDefinedMatchers = hasDefinedMatchers;
    this.command = command;
    this.icon = configurationProperties.icon;
    this.hide = configurationProperties.hide;
  }
  clone() {
    return new _ContributedTask(
      this._id,
      this._source,
      this._label,
      this.type,
      this.defines,
      this.command,
      this.hasDefinedMatchers,
      this.runOptions,
      this.configurationProperties
    );
  }
  getDefinition() {
    return this.defines;
  }
  static is(value) {
    return value instanceof _ContributedTask;
  }
  getMapKey() {
    const workspaceFolder = this._source.workspaceFolder;
    return workspaceFolder ? `${this._source.scope.toString()}|${workspaceFolder.uri.toString()}|${this._id}|${this.instance}` : `${this._source.scope.toString()}|${this._id}|${this.instance}`;
  }
  getFolderId() {
    if (this._source.scope === 3 && this._source.workspaceFolder) {
      return this._source.workspaceFolder.uri.toString();
    }
    return void 0;
  }
  getRecentlyUsedKey() {
    const key = { type: "contributed", scope: this._source.scope, id: this._id };
    key.folder = this.getFolderId();
    return JSON.stringify(key);
  }
  getWorkspaceFolder() {
    return this._source.workspaceFolder;
  }
  getTelemetryKind() {
    return "extension";
  }
  fromObject(object) {
    return new _ContributedTask(
      object._id,
      object._source,
      object._label,
      object.type,
      object.defines,
      object.command,
      object.hasDefinedMatchers,
      object.runOptions,
      object.configurationProperties
    );
  }
};
var KeyedTaskIdentifier;
(function(KeyedTaskIdentifier2) {
  function sortedStringify(literal) {
    const keys = Object.keys(literal).sort();
    let result = "";
    for (const key of keys) {
      let stringified = literal[key];
      if (stringified instanceof Object) {
        stringified = sortedStringify(stringified);
      } else if (typeof stringified === "string") {
        stringified = stringified.replace(/,/g, ",,");
      }
      result += key + "," + stringified + ",";
    }
    return result;
  }
  function create(value) {
    const resultKey = sortedStringify(value);
    const result = { _key: resultKey, type: value.taskType };
    Object.assign(result, value);
    return result;
  }
  KeyedTaskIdentifier2.create = create;
})(KeyedTaskIdentifier || (KeyedTaskIdentifier = {}));
var TaskDefinition;
(function(TaskDefinition2) {
  function createTaskIdentifier(external, reporter) {
    const definition = TaskDefinitionRegistry.get(external.type);
    if (definition === void 0) {
      const copy = deepClone(external);
      delete copy._key;
      return KeyedTaskIdentifier.create(copy);
    }
    const literal = /* @__PURE__ */ Object.create(null);
    literal.type = definition.taskType;
    const required = /* @__PURE__ */ new Set();
    definition.required.forEach((element) => required.add(element));
    const properties = definition.properties;
    for (const property of Object.keys(properties)) {
      const value = external[property];
      if (value !== void 0 && value !== null) {
        literal[property] = value;
      } else if (required.has(property)) {
        const schema = properties[property];
        if (schema.default !== void 0) {
          literal[property] = deepClone(schema.default);
        } else {
          switch (schema.type) {
            case "boolean":
              literal[property] = false;
              break;
            case "number":
            case "integer":
              literal[property] = 0;
              break;
            case "string":
              literal[property] = "";
              break;
            default:
              reporter.error(localize(
                "TaskDefinition.missingRequiredProperty",
                "Error: the task identifier '{0}' is missing the required property '{1}'. The task identifier will be ignored.",
                JSON.stringify(external, void 0, 0),
                property
              ));
              return void 0;
          }
        }
      }
    }
    return KeyedTaskIdentifier.create(literal);
  }
  TaskDefinition2.createTaskIdentifier = createTaskIdentifier;
})(TaskDefinition || (TaskDefinition = {}));

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTask.js
init_extHost_protocol();
init_errors();
var TaskExecutionDTO;
(function(TaskExecutionDTO2) {
  function from(value) {
    return {
      id: value.id,
      task: TaskDTO2.from(value.task)
    };
  }
  TaskExecutionDTO2.from = from;
})(TaskExecutionDTO || (TaskExecutionDTO = {}));
var TaskProcessStartedDTO;
(function(TaskProcessStartedDTO2) {
  function from(value, processId) {
    return {
      id: value.id,
      processId
    };
  }
  TaskProcessStartedDTO2.from = from;
})(TaskProcessStartedDTO || (TaskProcessStartedDTO = {}));
var TaskProcessEndedDTO;
(function(TaskProcessEndedDTO2) {
  function from(value, exitCode) {
    return {
      id: value.id,
      exitCode
    };
  }
  TaskProcessEndedDTO2.from = from;
})(TaskProcessEndedDTO || (TaskProcessEndedDTO = {}));
var TaskDefinitionDTO2;
(function(TaskDefinitionDTO3) {
  function from(value) {
    const result = Object.assign(/* @__PURE__ */ Object.create(null), value);
    delete result._key;
    return result;
  }
  TaskDefinitionDTO3.from = from;
  function to(value, executeOnly) {
    let result = TaskDefinition.createTaskIdentifier(value, console);
    if (result === void 0 && executeOnly) {
      result = {
        _key: generateUuid(),
        type: "$executeOnly"
      };
    }
    return result;
  }
  TaskDefinitionDTO3.to = to;
})(TaskDefinitionDTO2 || (TaskDefinitionDTO2 = {}));
var TaskPresentationOptionsDTO2;
(function(TaskPresentationOptionsDTO3) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return Object.assign(/* @__PURE__ */ Object.create(null), value);
  }
  TaskPresentationOptionsDTO3.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return PresentationOptions.defaults;
    }
    return Object.assign(/* @__PURE__ */ Object.create(null), PresentationOptions.defaults, value);
  }
  TaskPresentationOptionsDTO3.to = to;
})(TaskPresentationOptionsDTO2 || (TaskPresentationOptionsDTO2 = {}));
var RunOptionsDTO;
(function(RunOptionsDTO2) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return Object.assign(/* @__PURE__ */ Object.create(null), value);
  }
  RunOptionsDTO2.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return RunOptions.defaults;
    }
    return Object.assign(/* @__PURE__ */ Object.create(null), RunOptions.defaults, value);
  }
  RunOptionsDTO2.to = to;
})(RunOptionsDTO || (RunOptionsDTO = {}));
var ProcessExecutionOptionsDTO2;
(function(ProcessExecutionOptionsDTO3) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return {
      cwd: value.cwd,
      env: value.env
    };
  }
  ProcessExecutionOptionsDTO3.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return CommandOptions.defaults;
    }
    return {
      cwd: value.cwd || CommandOptions.defaults.cwd,
      env: value.env
    };
  }
  ProcessExecutionOptionsDTO3.to = to;
})(ProcessExecutionOptionsDTO2 || (ProcessExecutionOptionsDTO2 = {}));
var ProcessExecutionDTO2;
(function(ProcessExecutionDTO3) {
  function is(value) {
    const candidate = value;
    return candidate && !!candidate.process;
  }
  ProcessExecutionDTO3.is = is;
  function from(value) {
    const process = isString(value.name) ? value.name : value.name.value;
    const args = value.args ? value.args.map((value2) => isString(value2) ? value2 : value2.value) : [];
    const result = {
      process,
      args
    };
    if (value.options) {
      result.options = ProcessExecutionOptionsDTO2.from(value.options);
    }
    return result;
  }
  ProcessExecutionDTO3.from = from;
  function to(value) {
    const result = {
      runtime: RuntimeType.Process,
      name: value.process,
      args: value.args,
      presentation: void 0
    };
    result.options = ProcessExecutionOptionsDTO2.to(value.options);
    return result;
  }
  ProcessExecutionDTO3.to = to;
})(ProcessExecutionDTO2 || (ProcessExecutionDTO2 = {}));
var ShellExecutionOptionsDTO2;
(function(ShellExecutionOptionsDTO3) {
  function from(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    const result = {
      cwd: value.cwd || CommandOptions.defaults.cwd,
      env: value.env
    };
    if (value.shell) {
      result.executable = value.shell.executable;
      result.shellArgs = value.shell.args;
      result.shellQuoting = value.shell.quoting;
    }
    return result;
  }
  ShellExecutionOptionsDTO3.from = from;
  function to(value) {
    if (value === void 0 || value === null) {
      return void 0;
    }
    const result = {
      cwd: value.cwd,
      env: value.env
    };
    if (value.executable) {
      result.shell = {
        executable: value.executable
      };
      if (value.shellArgs) {
        result.shell.args = value.shellArgs;
      }
      if (value.shellQuoting) {
        result.shell.quoting = value.shellQuoting;
      }
    }
    return result;
  }
  ShellExecutionOptionsDTO3.to = to;
})(ShellExecutionOptionsDTO2 || (ShellExecutionOptionsDTO2 = {}));
var ShellExecutionDTO2;
(function(ShellExecutionDTO3) {
  function is(value) {
    const candidate = value;
    return candidate && (!!candidate.commandLine || !!candidate.command);
  }
  ShellExecutionDTO3.is = is;
  function from(value) {
    const result = {};
    if (value.name && isString(value.name) && (value.args === void 0 || value.args === null || value.args.length === 0)) {
      result.commandLine = value.name;
    } else {
      result.command = value.name;
      result.args = value.args;
    }
    if (value.options) {
      result.options = ShellExecutionOptionsDTO2.from(value.options);
    }
    return result;
  }
  ShellExecutionDTO3.from = from;
  function to(value) {
    const result = {
      runtime: RuntimeType.Shell,
      name: value.commandLine ? value.commandLine : value.command,
      args: value.args,
      presentation: void 0
    };
    if (value.options) {
      result.options = ShellExecutionOptionsDTO2.to(value.options);
    }
    return result;
  }
  ShellExecutionDTO3.to = to;
})(ShellExecutionDTO2 || (ShellExecutionDTO2 = {}));
var CustomExecutionDTO2;
(function(CustomExecutionDTO3) {
  function is(value) {
    const candidate = value;
    return candidate && candidate.customExecution === "customExecution";
  }
  CustomExecutionDTO3.is = is;
  function from(value) {
    return {
      customExecution: "customExecution"
    };
  }
  CustomExecutionDTO3.from = from;
  function to(value) {
    return {
      runtime: RuntimeType.CustomExecution,
      presentation: void 0
    };
  }
  CustomExecutionDTO3.to = to;
})(CustomExecutionDTO2 || (CustomExecutionDTO2 = {}));
var TaskSourceDTO;
(function(TaskSourceDTO2) {
  function from(value) {
    const result = {
      label: value.label
    };
    if (value.kind === TaskSourceKind.Extension) {
      result.extensionId = value.extension;
      if (value.workspaceFolder) {
        result.scope = value.workspaceFolder.uri;
      } else {
        result.scope = value.scope;
      }
    } else if (value.kind === TaskSourceKind.Workspace) {
      result.extensionId = "$core";
      result.scope = value.config.workspaceFolder ? value.config.workspaceFolder.uri : 1;
    }
    return result;
  }
  TaskSourceDTO2.from = from;
  function to(value, workspace) {
    let scope;
    let workspaceFolder;
    if (value.scope === void 0 || typeof value.scope === "number" && value.scope !== 1) {
      if (workspace.getWorkspace().folders.length === 0) {
        scope = 1;
        workspaceFolder = void 0;
      } else {
        scope = 3;
        workspaceFolder = workspace.getWorkspace().folders[0];
      }
    } else if (typeof value.scope === "number") {
      scope = value.scope;
    } else {
      scope = 3;
      workspaceFolder = workspace.getWorkspaceFolder(URI.revive(value.scope)) ?? void 0;
    }
    const result = {
      kind: TaskSourceKind.Extension,
      label: value.label,
      extension: value.extensionId,
      scope,
      workspaceFolder
    };
    return result;
  }
  TaskSourceDTO2.to = to;
})(TaskSourceDTO || (TaskSourceDTO = {}));
var TaskHandleDTO;
(function(TaskHandleDTO2) {
  function is(value) {
    const candidate = value;
    return candidate && isString(candidate.id) && !!candidate.workspaceFolder;
  }
  TaskHandleDTO2.is = is;
})(TaskHandleDTO || (TaskHandleDTO = {}));
var TaskDTO2;
(function(TaskDTO3) {
  function from(task) {
    if (task === void 0 || task === null || !CustomTask.is(task) && !ContributedTask.is(task) && !ConfiguringTask.is(task)) {
      return void 0;
    }
    const result = {
      _id: task._id,
      name: task.configurationProperties.name,
      definition: TaskDefinitionDTO2.from(task.getDefinition(true)),
      source: TaskSourceDTO.from(task._source),
      execution: void 0,
      presentationOptions: !ConfiguringTask.is(task) && task.command ? TaskPresentationOptionsDTO2.from(task.command.presentation) : void 0,
      isBackground: task.configurationProperties.isBackground,
      problemMatchers: [],
      hasDefinedMatchers: ContributedTask.is(task) ? task.hasDefinedMatchers : false,
      runOptions: RunOptionsDTO.from(task.runOptions)
    };
    result.group = TaskGroupDTO2.from(task.configurationProperties.group);
    if (task.configurationProperties.detail) {
      result.detail = task.configurationProperties.detail;
    }
    if (!ConfiguringTask.is(task) && task.command) {
      switch (task.command.runtime) {
        case RuntimeType.Process:
          result.execution = ProcessExecutionDTO2.from(task.command);
          break;
        case RuntimeType.Shell:
          result.execution = ShellExecutionDTO2.from(task.command);
          break;
        case RuntimeType.CustomExecution:
          result.execution = CustomExecutionDTO2.from(task.command);
          break;
      }
    }
    if (task.configurationProperties.problemMatchers) {
      for (const matcher of task.configurationProperties.problemMatchers) {
        if (isString(matcher)) {
          result.problemMatchers.push(matcher);
        }
      }
    }
    return result;
  }
  TaskDTO3.from = from;
  function to(task, workspace, executeOnly, icon, hide) {
    if (!task || typeof task.name !== "string") {
      return void 0;
    }
    let command;
    if (task.execution) {
      if (ShellExecutionDTO2.is(task.execution)) {
        command = ShellExecutionDTO2.to(task.execution);
      } else if (ProcessExecutionDTO2.is(task.execution)) {
        command = ProcessExecutionDTO2.to(task.execution);
      } else if (CustomExecutionDTO2.is(task.execution)) {
        command = CustomExecutionDTO2.to(task.execution);
      }
    }
    if (!command) {
      return void 0;
    }
    command.presentation = TaskPresentationOptionsDTO2.to(task.presentationOptions);
    const source = TaskSourceDTO.to(task.source, workspace);
    const label = localize("task.label", "{0}: {1}", source.label, task.name);
    const definition = TaskDefinitionDTO2.to(task.definition, executeOnly);
    const id = CustomExecutionDTO2.is(task.execution) && task._id ? task._id : `${task.source.extensionId}.${definition._key}`;
    const result = new ContributedTask(
      id,
      source,
      label,
      definition.type,
      definition,
      command,
      task.hasDefinedMatchers,
      RunOptionsDTO.to(task.runOptions),
      {
        name: task.name,
        identifier: label,
        group: task.group,
        isBackground: !!task.isBackground,
        problemMatchers: task.problemMatchers.slice(),
        detail: task.detail,
        icon,
        hide
      }
    );
    return result;
  }
  TaskDTO3.to = to;
})(TaskDTO2 || (TaskDTO2 = {}));
var TaskGroupDTO2;
(function(TaskGroupDTO3) {
  function from(value) {
    if (value === void 0) {
      return void 0;
    }
    return {
      _id: typeof value === "string" ? value : value._id,
      isDefault: typeof value === "string" ? false : typeof value.isDefault === "string" ? false : value.isDefault
    };
  }
  TaskGroupDTO3.from = from;
})(TaskGroupDTO2 || (TaskGroupDTO2 = {}));
var TaskFilterDTO2;
(function(TaskFilterDTO3) {
  function from(value) {
    return value;
  }
  TaskFilterDTO3.from = from;
  function to(value) {
    return value;
  }
  TaskFilterDTO3.to = to;
})(TaskFilterDTO2 || (TaskFilterDTO2 = {}));
var MainThreadTask = class MainThreadTask2 {
  constructor(extHostContext, _taskService, _workspaceContextServer, _configurationResolverService) {
    this._taskService = _taskService;
    this._workspaceContextServer = _workspaceContextServer;
    this._configurationResolverService = _configurationResolverService;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostTask);
    this._providers = /* @__PURE__ */ new Map();
    this._taskService.onDidStateChange(async (event) => {
      var _a30;
      const task = event.__task;
      if (event.kind === "start") {
        const execution = TaskExecutionDTO.from(task.getTaskExecution());
        let resolvedDefinition = execution.task.definition;
        if (((_a30 = execution.task) == null ? void 0 : _a30.execution) && CustomExecutionDTO2.is(execution.task.execution) && event.resolvedVariables) {
          const dictionary = {};
          for (const [key, value] of event.resolvedVariables.entries()) {
            dictionary[key] = value;
          }
          resolvedDefinition = await this._configurationResolverService.resolveAnyAsync(task.getWorkspaceFolder(), execution.task.definition, dictionary);
        }
        this._proxy.$onDidStartTask(execution, event.terminalId, resolvedDefinition);
      } else if (event.kind === "processStarted") {
        this._proxy.$onDidStartTaskProcess(TaskProcessStartedDTO.from(task.getTaskExecution(), event.processId));
      } else if (event.kind === "processEnded") {
        this._proxy.$onDidEndTaskProcess(TaskProcessEndedDTO.from(task.getTaskExecution(), event.exitCode));
      } else if (event.kind === "end") {
        this._proxy.$OnDidEndTask(TaskExecutionDTO.from(task.getTaskExecution()));
      }
    });
  }
  dispose() {
    for (const value of this._providers.values()) {
      value.disposable.dispose();
    }
    this._providers.clear();
  }
  $createTaskId(taskDTO) {
    return new Promise((resolve, reject) => {
      const task = TaskDTO2.to(taskDTO, this._workspaceContextServer, true);
      if (task) {
        resolve(task._id);
      } else {
        reject(new Error("Task could not be created from DTO"));
      }
    });
  }
  $registerTaskProvider(handle, type) {
    const provider = {
      provideTasks: (validTypes) => {
        return Promise.resolve(this._proxy.$provideTasks(handle, validTypes)).then((value) => {
          const tasks = [];
          for (const dto of value.tasks) {
            const task = TaskDTO2.to(dto, this._workspaceContextServer, true);
            if (task) {
              tasks.push(task);
            } else {
              console.error(`Task System: can not convert task: ${JSON.stringify(dto.definition, void 0, 0)}. Task will be dropped`);
            }
          }
          return {
            tasks,
            extension: value.extension
          };
        });
      },
      resolveTask: (task) => {
        const dto = TaskDTO2.from(task);
        if (dto) {
          dto.name = dto.name === void 0 ? "" : dto.name;
          return Promise.resolve(this._proxy.$resolveTask(handle, dto)).then((resolvedTask) => {
            if (resolvedTask) {
              return TaskDTO2.to(resolvedTask, this._workspaceContextServer, true, task.configurationProperties.icon, task.configurationProperties.hide);
            }
            return void 0;
          });
        }
        return Promise.resolve(void 0);
      }
    };
    const disposable = this._taskService.registerTaskProvider(provider, type);
    this._providers.set(handle, { disposable, provider });
    return Promise.resolve(void 0);
  }
  $unregisterTaskProvider(handle) {
    const provider = this._providers.get(handle);
    if (provider) {
      provider.disposable.dispose();
      this._providers.delete(handle);
    }
    return Promise.resolve(void 0);
  }
  $fetchTasks(filter2) {
    return this._taskService.tasks(TaskFilterDTO2.to(filter2)).then((tasks) => {
      const result = [];
      for (const task of tasks) {
        const item = TaskDTO2.from(task);
        if (item) {
          result.push(item);
        }
      }
      return result;
    });
  }
  getWorkspace(value) {
    var _a30;
    let workspace;
    if (typeof value === "string") {
      workspace = value;
    } else {
      const workspaceObject = this._workspaceContextServer.getWorkspace();
      const uri = URI.revive(value);
      if (((_a30 = workspaceObject.configuration) == null ? void 0 : _a30.toString()) === uri.toString()) {
        workspace = workspaceObject;
      } else {
        workspace = this._workspaceContextServer.getWorkspaceFolder(uri);
      }
    }
    return workspace;
  }
  async $getTaskExecution(value) {
    if (TaskHandleDTO.is(value)) {
      const workspace = this.getWorkspace(value.workspaceFolder);
      if (workspace) {
        const task = await this._taskService.getTask(workspace, value.id, true);
        if (task) {
          return {
            id: task._id,
            task: TaskDTO2.from(task)
          };
        }
        throw new Error("Task not found");
      } else {
        throw new Error("No workspace folder");
      }
    } else {
      const task = TaskDTO2.to(value, this._workspaceContextServer, true);
      return {
        id: task._id,
        task: TaskDTO2.from(task)
      };
    }
  }
  $executeTask(value) {
    return new Promise((resolve, reject) => {
      if (TaskHandleDTO.is(value)) {
        const workspace = this.getWorkspace(value.workspaceFolder);
        if (workspace) {
          this._taskService.getTask(workspace, value.id, true).then((task) => {
            if (!task) {
              reject(new Error("Task not found"));
            } else {
              const result = {
                id: value.id,
                task: TaskDTO2.from(task)
              };
              this._taskService.run(task).then((summary) => {
                if ((summary == null ? void 0 : summary.exitCode) === void 0 || summary.exitCode !== 0) {
                  this._proxy.$OnDidEndTask(result);
                }
              }, (reason) => {
              });
              resolve(result);
            }
          }, (_error) => {
            reject(new Error("Task not found"));
          });
        } else {
          reject(new Error("No workspace folder"));
        }
      } else {
        const task = TaskDTO2.to(value, this._workspaceContextServer, true);
        this._taskService.run(task).then(void 0, (reason) => {
        });
        const result = {
          id: task._id,
          task: TaskDTO2.from(task)
        };
        resolve(result);
      }
    });
  }
  $customExecutionComplete(id, result) {
    return new Promise((resolve, reject) => {
      this._taskService.getActiveTasks().then((tasks) => {
        for (const task of tasks) {
          if (id === task._id) {
            this._taskService.extensionCallbackTaskComplete(task, result).then((value) => {
              resolve(void 0);
            }, (error) => {
              reject(error);
            });
            return;
          }
        }
        reject(new Error("Task to mark as complete not found"));
      });
    });
  }
  $terminateTask(id) {
    return new Promise((resolve, reject) => {
      this._taskService.getActiveTasks().then((tasks) => {
        for (const task of tasks) {
          if (id === task._id) {
            this._taskService.terminate(task).then((value) => {
              resolve(void 0);
            }, (error) => {
              reject(void 0);
            });
            return;
          }
        }
        reject(new ErrorNoTelemetry("Task to terminate not found"));
      });
    });
  }
  $registerTaskSystem(key, info) {
    let platform$1;
    switch (info.platform) {
      case "Web":
        platform$1 = 0;
        break;
      case "win32":
        platform$1 = 3;
        break;
      case "darwin":
        platform$1 = 1;
        break;
      case "linux":
        platform$1 = 2;
        break;
      default:
        platform$1 = platform;
    }
    this._taskService.registerTaskSystem(key, {
      platform: platform$1,
      uriProvider: (path) => {
        return URI.from({ scheme: info.scheme, authority: info.authority, path });
      },
      context: this._extHostContext,
      resolveVariables: (workspaceFolder, toResolve, target) => {
        const vars = [];
        toResolve.variables.forEach((item) => vars.push(item));
        return Promise.resolve(this._proxy.$resolveVariables(workspaceFolder.uri, { process: toResolve.process, variables: vars })).then((values) => {
          const partiallyResolvedVars = Array.from(Object.values(values.variables));
          return new Promise((resolve, reject) => {
            this._configurationResolverService.resolveWithInteraction(workspaceFolder, partiallyResolvedVars, "tasks", void 0, target).then((resolvedVars) => {
              if (!resolvedVars) {
                resolve(void 0);
              }
              const result = {
                process: void 0,
                variables: /* @__PURE__ */ new Map()
              };
              for (let i = 0; i < partiallyResolvedVars.length; i++) {
                const variableName = vars[i].substring(2, vars[i].length - 1);
                if (resolvedVars && values.variables[vars[i]] === vars[i]) {
                  const resolved = resolvedVars.get(variableName);
                  if (typeof resolved === "string") {
                    result.variables.set(variableName, resolved);
                  }
                } else {
                  result.variables.set(variableName, partiallyResolvedVars[i]);
                }
              }
              if (isString(values.process)) {
                result.process = values.process;
              }
              resolve(result);
            }, (reason) => {
              reject(reason);
            });
          });
        });
      },
      findExecutable: (command, cwd2, paths) => {
        return this._proxy.$findExecutable(command, cwd2, paths);
      }
    });
  }
  async $registerSupportedExecutions(custom, shell, process) {
    return this._taskService.registerSupportedExecutions(custom, shell, process);
  }
};
MainThreadTask = __decorate([
  extHostNamedCustomer(MainContext.MainThreadTask),
  __param(1, ITaskService),
  __param(2, IWorkspaceContextService),
  __param(3, IConfigurationResolverService)
], MainThreadTask);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadLabelService.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
var MainThreadLabelService = class MainThreadLabelService2 extends Disposable {
  constructor(_, _labelService) {
    super();
    this._labelService = _labelService;
    this._resourceLabelFormatters = this._register(new DisposableMap());
  }
  $registerResourceLabelFormatter(handle, formatter) {
    formatter.priority = true;
    const disposable = this._labelService.registerCachedFormatter(formatter);
    this._resourceLabelFormatters.set(handle, disposable);
  }
  $unregisterResourceLabelFormatter(handle) {
    this._resourceLabelFormatters.deleteAndDispose(handle);
  }
};
MainThreadLabelService = __decorate([
  extHostNamedCustomer(MainContext.MainThreadLabelService),
  __param(1, ILabelService)
], MainThreadLabelService);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTunnelService.js
init_tslib_es6();
init_nls();
init_extHost_protocol();
init_lifecycle();
init_configuration();
init_log();
init_platform2();
init_configurationRegistry();
init_contextkey();

// node_modules/vscode/vscode/src/vs/workbench/services/remote/common/tunnelModel.js
init_tslib_es6();
init_nls();
init_arrays();
init_event();
init_hash();
init_lifecycle();
init_uri();
init_configuration();
init_log();
init_remoteAuthorityResolver();
init_cancellation();
init_types();
init_objects();
init_contextkey();
var MISMATCH_LOCAL_PORT_COOLDOWN = 10 * 1e3;
var TUNNELS_TO_RESTORE = "remote.tunnels.toRestore";
var ACTIVATION_EVENT = "onTunnel";
var forwardedPortsViewEnabled = new RawContextKey(
  "forwardedPortsViewEnabled",
  false,
  localize("tunnel.forwardedPortsViewEnabled", "Whether the Ports view is enabled.")
);
function parseAddress(address) {
  var _a30;
  const matches = address.match(/^([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*:)?([0-9]+)$/);
  if (!matches) {
    return void 0;
  }
  return { host: ((_a30 = matches[1]) == null ? void 0 : _a30.substring(0, matches[1].length - 1)) || "localhost", port: Number(matches[2]) };
}
var TunnelCloseReason;
(function(TunnelCloseReason2) {
  TunnelCloseReason2["Other"] = "Other";
  TunnelCloseReason2["User"] = "User";
  TunnelCloseReason2["AutoForwardEnd"] = "AutoForwardEnd";
})(TunnelCloseReason || (TunnelCloseReason = {}));
var TunnelSource;
(function(TunnelSource2) {
  TunnelSource2[TunnelSource2["User"] = 0] = "User";
  TunnelSource2[TunnelSource2["Auto"] = 1] = "Auto";
  TunnelSource2[TunnelSource2["Extension"] = 2] = "Extension";
})(TunnelSource || (TunnelSource = {}));
var UserTunnelSource = {
  source: TunnelSource.User,
  description: localize("tunnel.source.user", "User Forwarded")
};
var AutoTunnelSource = {
  source: TunnelSource.Auto,
  description: localize("tunnel.source.auto", "Auto Forwarded")
};
function mapHasAddress(map, host, port) {
  const initialAddress = map.get(makeAddress(host, port));
  if (initialAddress) {
    return initialAddress;
  }
  if (isLocalhost(host)) {
    for (const testHost of LOCALHOST_ADDRESSES) {
      const testAddress = makeAddress(testHost, port);
      if (map.has(testAddress)) {
        return map.get(testAddress);
      }
    }
  } else if (isAllInterfaces(host)) {
    for (const testHost of ALL_INTERFACES_ADDRESSES) {
      const testAddress = makeAddress(testHost, port);
      if (map.has(testAddress)) {
        return map.get(testAddress);
      }
    }
  }
  return void 0;
}
function mapHasAddressLocalhostOrAllInterfaces(map, host, port) {
  const originalAddress = mapHasAddress(map, host, port);
  if (originalAddress) {
    return originalAddress;
  }
  const otherHost = isAllInterfaces(host) ? "localhost" : isLocalhost(host) ? "0.0.0.0" : void 0;
  if (otherHost) {
    return mapHasAddress(map, otherHost, port);
  }
  return void 0;
}
function makeAddress(host, port) {
  return host + ":" + port;
}
var OnPortForward;
(function(OnPortForward2) {
  OnPortForward2["Notify"] = "notify";
  OnPortForward2["OpenBrowser"] = "openBrowser";
  OnPortForward2["OpenBrowserOnce"] = "openBrowserOnce";
  OnPortForward2["OpenPreview"] = "openPreview";
  OnPortForward2["Silent"] = "silent";
  OnPortForward2["Ignore"] = "ignore";
})(OnPortForward || (OnPortForward = {}));
function isCandidatePort(candidate) {
  return candidate && "host" in candidate && typeof candidate.host === "string" && "port" in candidate && typeof candidate.port === "number" && (!("detail" in candidate) || typeof candidate.detail === "string") && (!("pid" in candidate) || typeof candidate.pid === "string");
}
var _PortsAttributes = class _PortsAttributes extends Disposable {
  constructor(configurationService) {
    super();
    this.configurationService = configurationService;
    this.portsAttributes = [];
    this._onDidChangeAttributes = new Emitter();
    this.onDidChangeAttributes = this._onDidChangeAttributes.event;
    this._register(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(_PortsAttributes.SETTING) || e.affectsConfiguration(_PortsAttributes.DEFAULTS)) {
        this.updateAttributes();
      }
    }));
    this.updateAttributes();
  }
  updateAttributes() {
    this.portsAttributes = this.readSetting();
    this._onDidChangeAttributes.fire();
  }
  getAttributes(port, host, commandLine) {
    let index = this.findNextIndex(port, host, commandLine, this.portsAttributes, 0);
    const attributes = {
      label: void 0,
      onAutoForward: void 0,
      elevateIfNeeded: void 0,
      requireLocalPort: void 0,
      protocol: void 0
    };
    while (index >= 0) {
      const found = this.portsAttributes[index];
      if (found.key === port) {
        attributes.onAutoForward = found.onAutoForward ?? attributes.onAutoForward;
        attributes.elevateIfNeeded = found.elevateIfNeeded !== void 0 ? found.elevateIfNeeded : attributes.elevateIfNeeded;
        attributes.label = found.label ?? attributes.label;
        attributes.requireLocalPort = found.requireLocalPort;
        attributes.protocol = found.protocol;
      } else {
        attributes.onAutoForward = attributes.onAutoForward ?? found.onAutoForward;
        attributes.elevateIfNeeded = attributes.elevateIfNeeded !== void 0 ? attributes.elevateIfNeeded : found.elevateIfNeeded;
        attributes.label = attributes.label ?? found.label;
        attributes.requireLocalPort = attributes.requireLocalPort !== void 0 ? attributes.requireLocalPort : void 0;
        attributes.protocol = attributes.protocol ?? found.protocol;
      }
      index = this.findNextIndex(port, host, commandLine, this.portsAttributes, index + 1);
    }
    if (attributes.onAutoForward !== void 0 || attributes.elevateIfNeeded !== void 0 || attributes.label !== void 0 || attributes.requireLocalPort !== void 0 || attributes.protocol !== void 0) {
      return attributes;
    }
    return this.getOtherAttributes();
  }
  hasStartEnd(value) {
    return value.start !== void 0 && value.end !== void 0;
  }
  hasHostAndPort(value) {
    return value.host !== void 0 && value.port !== void 0 && isString(value.host) && isNumber(value.port);
  }
  findNextIndex(port, host, commandLine, attributes, fromIndex) {
    if (fromIndex >= attributes.length) {
      return -1;
    }
    const shouldUseHost = !isLocalhost(host) && !isAllInterfaces(host);
    const sliced = attributes.slice(fromIndex);
    const foundIndex = sliced.findIndex((value) => {
      if (isNumber(value.key)) {
        return shouldUseHost ? false : value.key === port;
      } else if (this.hasStartEnd(value.key)) {
        return shouldUseHost ? false : port >= value.key.start && port <= value.key.end;
      } else if (this.hasHostAndPort(value.key)) {
        return port === value.key.port && host === value.key.host;
      } else {
        return commandLine ? value.key.test(commandLine) : false;
      }
    });
    return foundIndex >= 0 ? foundIndex + fromIndex : -1;
  }
  readSetting() {
    const settingValue = this.configurationService.getValue(_PortsAttributes.SETTING);
    if (!settingValue || !isObject(settingValue)) {
      return [];
    }
    const attributes = [];
    for (const attributesKey in settingValue) {
      if (attributesKey === void 0) {
        continue;
      }
      const setting = settingValue[attributesKey];
      let key = void 0;
      if (Number(attributesKey)) {
        key = Number(attributesKey);
      } else if (isString(attributesKey)) {
        if (_PortsAttributes.RANGE.test(attributesKey)) {
          const match = attributesKey.match(_PortsAttributes.RANGE);
          key = { start: Number(match[1]), end: Number(match[2]) };
        } else if (_PortsAttributes.HOST_AND_PORT.test(attributesKey)) {
          const match = attributesKey.match(_PortsAttributes.HOST_AND_PORT);
          key = { host: match[1], port: Number(match[2]) };
        } else {
          let regTest = void 0;
          try {
            regTest = RegExp(attributesKey);
          } catch (e) {
          }
          if (regTest) {
            key = regTest;
          }
        }
      }
      if (!key) {
        continue;
      }
      attributes.push({
        key,
        elevateIfNeeded: setting.elevateIfNeeded,
        onAutoForward: setting.onAutoForward,
        label: setting.label,
        requireLocalPort: setting.requireLocalPort,
        protocol: setting.protocol
      });
    }
    const defaults = this.configurationService.getValue(_PortsAttributes.DEFAULTS);
    if (defaults) {
      this.defaultPortAttributes = {
        elevateIfNeeded: defaults.elevateIfNeeded,
        label: defaults.label,
        onAutoForward: defaults.onAutoForward,
        requireLocalPort: defaults.requireLocalPort,
        protocol: defaults.protocol
      };
    }
    return this.sortAttributes(attributes);
  }
  sortAttributes(attributes) {
    function getVal(item, thisRef) {
      if (isNumber(item.key)) {
        return item.key;
      } else if (thisRef.hasStartEnd(item.key)) {
        return item.key.start;
      } else if (thisRef.hasHostAndPort(item.key)) {
        return item.key.port;
      } else {
        return Number.MAX_VALUE;
      }
    }
    return attributes.sort((a, b) => {
      return getVal(a, this) - getVal(b, this);
    });
  }
  getOtherAttributes() {
    return this.defaultPortAttributes;
  }
  static providedActionToAction(providedAction) {
    switch (providedAction) {
      case ProvidedOnAutoForward.Notify:
        return OnPortForward.Notify;
      case ProvidedOnAutoForward.OpenBrowser:
        return OnPortForward.OpenBrowser;
      case ProvidedOnAutoForward.OpenBrowserOnce:
        return OnPortForward.OpenBrowserOnce;
      case ProvidedOnAutoForward.OpenPreview:
        return OnPortForward.OpenPreview;
      case ProvidedOnAutoForward.Silent:
        return OnPortForward.Silent;
      case ProvidedOnAutoForward.Ignore:
        return OnPortForward.Ignore;
      default:
        return void 0;
    }
  }
  async addAttributes(port, attributes, target) {
    const settingValue = this.configurationService.inspect(_PortsAttributes.SETTING);
    const remoteValue = settingValue.userRemoteValue;
    let newRemoteValue;
    if (!remoteValue || !isObject(remoteValue)) {
      newRemoteValue = {};
    } else {
      newRemoteValue = deepClone(remoteValue);
    }
    if (!newRemoteValue[`${port}`]) {
      newRemoteValue[`${port}`] = {};
    }
    for (const attribute in attributes) {
      newRemoteValue[`${port}`][attribute] = attributes[attribute];
    }
    return this.configurationService.updateValue(_PortsAttributes.SETTING, newRemoteValue, target);
  }
};
_PortsAttributes.SETTING = "remote.portsAttributes";
_PortsAttributes.DEFAULTS = "remote.otherPortsAttributes";
_PortsAttributes.RANGE = /^(\d+)\-(\d+)$/;
_PortsAttributes.HOST_AND_PORT = /^([a-z0-9\-]+):(\d{1,5})$/;
var PortsAttributes = _PortsAttributes;
var TunnelModel = class TunnelModel2 extends Disposable {
  constructor(tunnelService, storageService, configurationService, environmentService, remoteAuthorityResolverService, workspaceContextService, logService, dialogService, extensionService, contextKeyService) {
    super();
    this.tunnelService = tunnelService;
    this.storageService = storageService;
    this.configurationService = configurationService;
    this.environmentService = environmentService;
    this.remoteAuthorityResolverService = remoteAuthorityResolverService;
    this.workspaceContextService = workspaceContextService;
    this.logService = logService;
    this.dialogService = dialogService;
    this.extensionService = extensionService;
    this.contextKeyService = contextKeyService;
    this.inProgress = /* @__PURE__ */ new Map();
    this._onForwardPort = new Emitter();
    this.onForwardPort = this._onForwardPort.event;
    this._onClosePort = new Emitter();
    this.onClosePort = this._onClosePort.event;
    this._onPortName = new Emitter();
    this.onPortName = this._onPortName.event;
    this._onCandidatesChanged = new Emitter();
    this.onCandidatesChanged = this._onCandidatesChanged.event;
    this._onEnvironmentTunnelsSet = new Emitter();
    this.onEnvironmentTunnelsSet = this._onEnvironmentTunnelsSet.event;
    this._environmentTunnelsSet = false;
    this.restoreListener = void 0;
    this.restoreComplete = false;
    this.onRestoreComplete = new Emitter();
    this.unrestoredExtensionTunnels = /* @__PURE__ */ new Map();
    this.sessionCachedProperties = /* @__PURE__ */ new Map();
    this.portAttributesProviders = [];
    this.mismatchCooldown = /* @__PURE__ */ new Date();
    this.configPortsAttributes = new PortsAttributes(configurationService);
    this.tunnelRestoreValue = this.getTunnelRestoreValue();
    this._register(this.configPortsAttributes.onDidChangeAttributes(this.updateAttributes, this));
    this.forwarded = /* @__PURE__ */ new Map();
    this.remoteTunnels = /* @__PURE__ */ new Map();
    this.tunnelService.tunnels.then(async (tunnels) => {
      var _a30;
      const attributes = await this.getAttributes(tunnels.map((tunnel) => {
        return { port: tunnel.tunnelRemotePort, host: tunnel.tunnelRemoteHost };
      }));
      for (const tunnel of tunnels) {
        if (tunnel.localAddress) {
          const key = makeAddress(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);
          const matchingCandidate = mapHasAddressLocalhostOrAllInterfaces(this._candidates ?? /* @__PURE__ */ new Map(), tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);
          this.forwarded.set(key, {
            remotePort: tunnel.tunnelRemotePort,
            remoteHost: tunnel.tunnelRemoteHost,
            localAddress: tunnel.localAddress,
            protocol: ((_a30 = attributes == null ? void 0 : attributes.get(tunnel.tunnelRemotePort)) == null ? void 0 : _a30.protocol) ?? TunnelProtocol.Http,
            localUri: await this.makeLocalUri(tunnel.localAddress, attributes == null ? void 0 : attributes.get(tunnel.tunnelRemotePort)),
            localPort: tunnel.tunnelLocalPort,
            runningProcess: matchingCandidate == null ? void 0 : matchingCandidate.detail,
            hasRunningProcess: !!matchingCandidate,
            pid: matchingCandidate == null ? void 0 : matchingCandidate.pid,
            privacy: tunnel.privacy,
            source: UserTunnelSource
          });
          this.remoteTunnels.set(key, tunnel);
        }
      }
    });
    this.detected = /* @__PURE__ */ new Map();
    this._register(this.tunnelService.onTunnelOpened(async (tunnel) => {
      var _a30;
      const key = makeAddress(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);
      if (!mapHasAddressLocalhostOrAllInterfaces(this.forwarded, tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort) && !mapHasAddressLocalhostOrAllInterfaces(this.detected, tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort) && !mapHasAddressLocalhostOrAllInterfaces(this.inProgress, tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort) && tunnel.localAddress) {
        const matchingCandidate = mapHasAddressLocalhostOrAllInterfaces(this._candidates ?? /* @__PURE__ */ new Map(), tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);
        const attributes = (_a30 = await this.getAttributes([{ port: tunnel.tunnelRemotePort, host: tunnel.tunnelRemoteHost }])) == null ? void 0 : _a30.get(tunnel.tunnelRemotePort);
        this.forwarded.set(key, {
          remoteHost: tunnel.tunnelRemoteHost,
          remotePort: tunnel.tunnelRemotePort,
          localAddress: tunnel.localAddress,
          protocol: (attributes == null ? void 0 : attributes.protocol) ?? TunnelProtocol.Http,
          localUri: await this.makeLocalUri(tunnel.localAddress, attributes),
          localPort: tunnel.tunnelLocalPort,
          closeable: true,
          runningProcess: matchingCandidate == null ? void 0 : matchingCandidate.detail,
          hasRunningProcess: !!matchingCandidate,
          pid: matchingCandidate == null ? void 0 : matchingCandidate.pid,
          privacy: tunnel.privacy,
          source: UserTunnelSource
        });
      }
      await this.storeForwarded();
      this.remoteTunnels.set(key, tunnel);
      this._onForwardPort.fire(this.forwarded.get(key));
    }));
    this._register(this.tunnelService.onTunnelClosed((address) => {
      return this.onTunnelClosed(address, TunnelCloseReason.Other);
    }));
    this.checkExtensionActivationEvents();
  }
  extensionHasActivationEvent() {
    if (this.extensionService.extensions.find((extension) => {
      var _a30;
      return (_a30 = extension.activationEvents) == null ? void 0 : _a30.includes(ACTIVATION_EVENT);
    })) {
      this.contextKeyService.createKey(forwardedPortsViewEnabled.key, true);
      return true;
    }
    return false;
  }
  checkExtensionActivationEvents() {
    if (this.extensionHasActivationEvent()) {
      return;
    }
    const activationDisposable = this._register(this.extensionService.onDidRegisterExtensions(() => {
      if (this.extensionHasActivationEvent()) {
        activationDisposable.dispose();
      }
    }));
  }
  async onTunnelClosed(address, reason) {
    const key = makeAddress(address.host, address.port);
    if (this.forwarded.has(key)) {
      this.forwarded.delete(key);
      await this.storeForwarded();
      this._onClosePort.fire(address);
    }
  }
  makeLocalUri(localAddress, attributes) {
    if (localAddress.startsWith("http")) {
      return URI.parse(localAddress);
    }
    const protocol = (attributes == null ? void 0 : attributes.protocol) ?? "http";
    return URI.parse(`${protocol}://${localAddress}`);
  }
  async getStorageKey() {
    const workspace = this.workspaceContextService.getWorkspace();
    const workspaceHash = workspace.configuration ? hash(workspace.configuration.path) : workspace.folders.length > 0 ? hash(workspace.folders[0].uri.path) : void 0;
    if (workspaceHash === void 0) {
      this.logService.debug("Could not get workspace hash for forwarded ports storage key.");
      return void 0;
    }
    return `${TUNNELS_TO_RESTORE}.${this.environmentService.remoteAuthority}.${workspaceHash}`;
  }
  async getTunnelRestoreValue() {
    const deprecatedValue = this.storageService.get(TUNNELS_TO_RESTORE, 1);
    if (deprecatedValue) {
      this.storageService.remove(TUNNELS_TO_RESTORE, 1);
      await this.storeForwarded();
      return deprecatedValue;
    }
    const storageKey = await this.getStorageKey();
    if (!storageKey) {
      return void 0;
    }
    return this.storageService.get(storageKey, 0);
  }
  async restoreForwarded() {
    if (this.configurationService.getValue("remote.restoreForwardedPorts")) {
      const tunnelRestoreValue = await this.tunnelRestoreValue;
      if (tunnelRestoreValue && tunnelRestoreValue !== this.knownPortsRestoreValue) {
        const tunnels = JSON.parse(tunnelRestoreValue) ?? [];
        this.logService.trace(`ForwardedPorts: (TunnelModel) restoring ports ${tunnels.map((tunnel) => tunnel.remotePort).join(", ")}`);
        for (const tunnel of tunnels) {
          const alreadyForwarded = mapHasAddressLocalhostOrAllInterfaces(this.detected, tunnel.remoteHost, tunnel.remotePort);
          if (tunnel.source.source !== TunnelSource.Extension && !alreadyForwarded || tunnel.source.source === TunnelSource.Extension && alreadyForwarded) {
            await this.doForward({
              remote: { host: tunnel.remoteHost, port: tunnel.remotePort },
              local: tunnel.localPort,
              name: tunnel.name,
              privacy: tunnel.privacy,
              elevateIfNeeded: true,
              source: tunnel.source
            });
          } else if (tunnel.source.source === TunnelSource.Extension && !alreadyForwarded) {
            this.unrestoredExtensionTunnels.set(makeAddress(tunnel.remoteHost, tunnel.remotePort), tunnel);
          }
        }
      }
    }
    this.restoreComplete = true;
    this.onRestoreComplete.fire();
    if (!this.restoreListener) {
      const key = await this.getStorageKey();
      this.restoreListener = this._register(new DisposableStore());
      this.restoreListener.add(this.storageService.onDidChangeValue(0, void 0, this.restoreListener)(async (e) => {
        if (e.key === key) {
          this.tunnelRestoreValue = Promise.resolve(this.storageService.get(key, 0));
          await this.restoreForwarded();
        }
      }));
    }
  }
  async storeForwarded() {
    if (this.configurationService.getValue("remote.restoreForwardedPorts")) {
      const valueToStore = JSON.stringify(Array.from(this.forwarded.values()));
      if (valueToStore !== this.knownPortsRestoreValue) {
        this.knownPortsRestoreValue = valueToStore;
        const key = await this.getStorageKey();
        if (key) {
          this.storageService.store(key, this.knownPortsRestoreValue, 0, 0);
        }
      }
    }
  }
  async showPortMismatchModalIfNeeded(tunnel, expectedLocal, attributes) {
    if (!tunnel.tunnelLocalPort || !(attributes == null ? void 0 : attributes.requireLocalPort)) {
      return;
    }
    if (tunnel.tunnelLocalPort === expectedLocal) {
      return;
    }
    const newCooldown = /* @__PURE__ */ new Date();
    if (this.mismatchCooldown.getTime() + MISMATCH_LOCAL_PORT_COOLDOWN > newCooldown.getTime()) {
      return;
    }
    this.mismatchCooldown = newCooldown;
    const mismatchString = localize(
      "remote.localPortMismatch.single",
      "Local port {0} could not be used for forwarding to remote port {1}.\n\nThis usually happens when there is already another process using local port {0}.\n\nPort number {2} has been used instead.",
      expectedLocal,
      tunnel.tunnelRemotePort,
      tunnel.tunnelLocalPort
    );
    return this.dialogService.info(mismatchString);
  }
  async forward(tunnelProperties, attributes) {
    if (!this.restoreComplete && this.environmentService.remoteAuthority) {
      await Event.toPromise(this.onRestoreComplete.event);
    }
    return this.doForward(tunnelProperties, attributes);
  }
  async doForward(tunnelProperties, attributes) {
    var _a30;
    await this.extensionService.activateByEvent(ACTIVATION_EVENT);
    const existingTunnel = mapHasAddressLocalhostOrAllInterfaces(this.forwarded, tunnelProperties.remote.host, tunnelProperties.remote.port);
    attributes = attributes ?? (attributes !== null ? (_a30 = await this.getAttributes([tunnelProperties.remote])) == null ? void 0 : _a30.get(tunnelProperties.remote.port) : void 0);
    const localPort = tunnelProperties.local !== void 0 ? tunnelProperties.local : tunnelProperties.remote.port;
    let noTunnelValue;
    if (!existingTunnel) {
      const authority = this.environmentService.remoteAuthority;
      const addressProvider = authority ? {
        getAddress: async () => {
          return (await this.remoteAuthorityResolverService.resolveAuthority(authority)).authority;
        }
      } : void 0;
      const key = makeAddress(tunnelProperties.remote.host, tunnelProperties.remote.port);
      this.inProgress.set(key, true);
      tunnelProperties = this.mergeCachedAndUnrestoredProperties(key, tunnelProperties);
      const tunnel = await this.tunnelService.openTunnel(addressProvider, tunnelProperties.remote.host, tunnelProperties.remote.port, void 0, localPort, !tunnelProperties.elevateIfNeeded ? attributes == null ? void 0 : attributes.elevateIfNeeded : tunnelProperties.elevateIfNeeded, tunnelProperties.privacy, attributes == null ? void 0 : attributes.protocol);
      if (typeof tunnel === "string") {
        noTunnelValue = tunnel;
      } else if (tunnel && tunnel.localAddress) {
        const matchingCandidate = mapHasAddressLocalhostOrAllInterfaces(this._candidates ?? /* @__PURE__ */ new Map(), tunnelProperties.remote.host, tunnelProperties.remote.port);
        const protocol = tunnel.protocol ? tunnel.protocol === TunnelProtocol.Https ? TunnelProtocol.Https : TunnelProtocol.Http : (attributes == null ? void 0 : attributes.protocol) ?? TunnelProtocol.Http;
        const newForward = {
          remoteHost: tunnel.tunnelRemoteHost,
          remotePort: tunnel.tunnelRemotePort,
          localPort: tunnel.tunnelLocalPort,
          name: (attributes == null ? void 0 : attributes.label) ?? tunnelProperties.name,
          closeable: true,
          localAddress: tunnel.localAddress,
          protocol,
          localUri: await this.makeLocalUri(tunnel.localAddress, attributes),
          runningProcess: matchingCandidate == null ? void 0 : matchingCandidate.detail,
          hasRunningProcess: !!matchingCandidate,
          pid: matchingCandidate == null ? void 0 : matchingCandidate.pid,
          source: tunnelProperties.source ?? UserTunnelSource,
          privacy: tunnel.privacy
        };
        this.forwarded.set(key, newForward);
        this.remoteTunnels.set(key, tunnel);
        this.inProgress.delete(key);
        await this.storeForwarded();
        await this.showPortMismatchModalIfNeeded(tunnel, localPort, attributes);
        this._onForwardPort.fire(newForward);
        return tunnel;
      }
      this.inProgress.delete(key);
    } else {
      return this.mergeAttributesIntoExistingTunnel(existingTunnel, tunnelProperties, attributes);
    }
    return noTunnelValue;
  }
  mergeCachedAndUnrestoredProperties(key, tunnelProperties) {
    const map = this.unrestoredExtensionTunnels.has(key) ? this.unrestoredExtensionTunnels : this.sessionCachedProperties.has(key) ? this.sessionCachedProperties : void 0;
    if (map) {
      const updateProps = map.get(key);
      map.delete(key);
      if (updateProps) {
        tunnelProperties.name = updateProps.name ?? tunnelProperties.name;
        tunnelProperties.local = ("local" in updateProps ? updateProps.local : "localPort" in updateProps ? updateProps.localPort : void 0) ?? tunnelProperties.local;
        tunnelProperties.privacy = updateProps.privacy ?? tunnelProperties.privacy;
      }
    }
    return tunnelProperties;
  }
  async mergeAttributesIntoExistingTunnel(existingTunnel, tunnelProperties, attributes) {
    const newName = (attributes == null ? void 0 : attributes.label) ?? tunnelProperties.name;
    let MergedAttributeAction;
    (function(MergedAttributeAction2) {
      MergedAttributeAction2[MergedAttributeAction2["None"] = 0] = "None";
      MergedAttributeAction2[MergedAttributeAction2["Fire"] = 1] = "Fire";
      MergedAttributeAction2[MergedAttributeAction2["Reopen"] = 2] = "Reopen";
    })(MergedAttributeAction || (MergedAttributeAction = {}));
    let mergedAction = MergedAttributeAction.None;
    if (newName !== existingTunnel.name) {
      existingTunnel.name = newName;
      mergedAction = MergedAttributeAction.Fire;
    }
    if (((attributes == null ? void 0 : attributes.protocol) || existingTunnel.protocol !== TunnelProtocol.Http) && (attributes == null ? void 0 : attributes.protocol) !== existingTunnel.protocol) {
      tunnelProperties.source = existingTunnel.source;
      mergedAction = MergedAttributeAction.Reopen;
    }
    if (tunnelProperties.privacy && existingTunnel.privacy !== tunnelProperties.privacy) {
      mergedAction = MergedAttributeAction.Reopen;
    }
    switch (mergedAction) {
      case MergedAttributeAction.Fire: {
        this._onForwardPort.fire();
        break;
      }
      case MergedAttributeAction.Reopen: {
        await this.close(existingTunnel.remoteHost, existingTunnel.remotePort, TunnelCloseReason.User);
        await this.doForward(tunnelProperties, attributes);
      }
    }
    return mapHasAddressLocalhostOrAllInterfaces(this.remoteTunnels, tunnelProperties.remote.host, tunnelProperties.remote.port);
  }
  async name(host, port, name) {
    const existingForwarded = mapHasAddressLocalhostOrAllInterfaces(this.forwarded, host, port);
    const key = makeAddress(host, port);
    if (existingForwarded) {
      existingForwarded.name = name;
      await this.storeForwarded();
      this._onPortName.fire({ host, port });
      return;
    } else if (this.detected.has(key)) {
      this.detected.get(key).name = name;
      this._onPortName.fire({ host, port });
    }
  }
  async close(host, port, reason) {
    const key = makeAddress(host, port);
    const oldTunnel = this.forwarded.get(key);
    if (reason === TunnelCloseReason.AutoForwardEnd && oldTunnel && oldTunnel.source.source === TunnelSource.Auto) {
      this.sessionCachedProperties.set(key, {
        local: oldTunnel.localPort,
        name: oldTunnel.name,
        privacy: oldTunnel.privacy
      });
    }
    await this.tunnelService.closeTunnel(host, port);
    return this.onTunnelClosed({ host, port }, reason);
  }
  address(host, port) {
    var _a30;
    const key = makeAddress(host, port);
    return (_a30 = this.forwarded.get(key) || this.detected.get(key)) == null ? void 0 : _a30.localAddress;
  }
  get environmentTunnelsSet() {
    return this._environmentTunnelsSet;
  }
  addEnvironmentTunnels(tunnels) {
    if (tunnels) {
      for (const tunnel of tunnels) {
        const matchingCandidate = mapHasAddressLocalhostOrAllInterfaces(this._candidates ?? /* @__PURE__ */ new Map(), tunnel.remoteAddress.host, tunnel.remoteAddress.port);
        const localAddress = typeof tunnel.localAddress === "string" ? tunnel.localAddress : makeAddress(tunnel.localAddress.host, tunnel.localAddress.port);
        this.detected.set(makeAddress(tunnel.remoteAddress.host, tunnel.remoteAddress.port), {
          remoteHost: tunnel.remoteAddress.host,
          remotePort: tunnel.remoteAddress.port,
          localAddress,
          protocol: TunnelProtocol.Http,
          localUri: this.makeLocalUri(localAddress),
          closeable: false,
          runningProcess: matchingCandidate == null ? void 0 : matchingCandidate.detail,
          hasRunningProcess: !!matchingCandidate,
          pid: matchingCandidate == null ? void 0 : matchingCandidate.pid,
          privacy: TunnelPrivacyId.ConstantPrivate,
          source: {
            source: TunnelSource.Extension,
            description: localize("tunnel.staticallyForwarded", "Statically Forwarded")
          }
        });
        this.tunnelService.setEnvironmentTunnel(tunnel.remoteAddress.host, tunnel.remoteAddress.port, localAddress, TunnelPrivacyId.ConstantPrivate, TunnelProtocol.Http);
      }
    }
    this._environmentTunnelsSet = true;
    this._onEnvironmentTunnelsSet.fire();
    this._onForwardPort.fire();
  }
  setCandidateFilter(filter2) {
    this._candidateFilter = filter2;
  }
  async setCandidates(candidates) {
    let processedCandidates = candidates;
    if (this._candidateFilter) {
      processedCandidates = await this._candidateFilter(candidates);
    }
    const removedCandidates = this.updateInResponseToCandidates(processedCandidates);
    this.logService.trace(`ForwardedPorts: (TunnelModel) removed candidates ${Array.from(removedCandidates.values()).map((candidate) => candidate.port).join(", ")}`);
    this._onCandidatesChanged.fire(removedCandidates);
  }
  updateInResponseToCandidates(candidates) {
    const removedCandidates = this._candidates ?? /* @__PURE__ */ new Map();
    const candidatesMap = /* @__PURE__ */ new Map();
    this._candidates = candidatesMap;
    candidates.forEach((value) => {
      const addressKey = makeAddress(value.host, value.port);
      candidatesMap.set(addressKey, {
        host: value.host,
        port: value.port,
        detail: value.detail,
        pid: value.pid
      });
      if (removedCandidates.has(addressKey)) {
        removedCandidates.delete(addressKey);
      }
      const forwardedValue = mapHasAddressLocalhostOrAllInterfaces(this.forwarded, value.host, value.port);
      if (forwardedValue) {
        forwardedValue.runningProcess = value.detail;
        forwardedValue.hasRunningProcess = true;
        forwardedValue.pid = value.pid;
      }
    });
    removedCandidates.forEach((_value, key) => {
      const parsedAddress = parseAddress(key);
      if (!parsedAddress) {
        return;
      }
      const forwardedValue = mapHasAddressLocalhostOrAllInterfaces(this.forwarded, parsedAddress.host, parsedAddress.port);
      if (forwardedValue) {
        forwardedValue.runningProcess = void 0;
        forwardedValue.hasRunningProcess = false;
        forwardedValue.pid = void 0;
      }
      const detectedValue = mapHasAddressLocalhostOrAllInterfaces(this.detected, parsedAddress.host, parsedAddress.port);
      if (detectedValue) {
        detectedValue.runningProcess = void 0;
        detectedValue.hasRunningProcess = false;
        detectedValue.pid = void 0;
      }
    });
    return removedCandidates;
  }
  get candidates() {
    return this._candidates ? Array.from(this._candidates.values()) : [];
  }
  get candidatesOrUndefined() {
    return this._candidates ? this.candidates : void 0;
  }
  async updateAttributes() {
    const tunnels = Array.from(this.forwarded.values());
    const allAttributes = await this.getAttributes(tunnels.map((tunnel) => {
      return { port: tunnel.remotePort, host: tunnel.remoteHost };
    }), false);
    if (!allAttributes) {
      return;
    }
    for (const forwarded of tunnels) {
      const attributes = allAttributes.get(forwarded.remotePort);
      if (((attributes == null ? void 0 : attributes.protocol) || forwarded.protocol !== TunnelProtocol.Http) && (attributes == null ? void 0 : attributes.protocol) !== forwarded.protocol) {
        await this.doForward({
          remote: { host: forwarded.remoteHost, port: forwarded.remotePort },
          local: forwarded.localPort,
          name: forwarded.name,
          source: forwarded.source
        }, attributes);
      }
      if (!attributes) {
        continue;
      }
      if (attributes.label && attributes.label !== forwarded.name) {
        await this.name(forwarded.remoteHost, forwarded.remotePort, attributes.label);
      }
    }
  }
  async getAttributes(forwardedPorts, checkProviders = true) {
    const matchingCandidates = /* @__PURE__ */ new Map();
    const pidToPortsMapping = /* @__PURE__ */ new Map();
    forwardedPorts.forEach((forwardedPort) => {
      var _a30;
      const matchingCandidate = mapHasAddressLocalhostOrAllInterfaces(this._candidates ?? /* @__PURE__ */ new Map(), LOCALHOST_ADDRESSES[0], forwardedPort.port) ?? forwardedPort;
      if (matchingCandidate) {
        matchingCandidates.set(forwardedPort.port, matchingCandidate);
        const pid = isCandidatePort(matchingCandidate) ? matchingCandidate.pid : void 0;
        if (!pidToPortsMapping.has(pid)) {
          pidToPortsMapping.set(pid, []);
        }
        (_a30 = pidToPortsMapping.get(pid)) == null ? void 0 : _a30.push(forwardedPort.port);
      }
    });
    const configAttributes = /* @__PURE__ */ new Map();
    forwardedPorts.forEach((forwardedPort) => {
      var _a30;
      const attributes = this.configPortsAttributes.getAttributes(forwardedPort.port, forwardedPort.host, (_a30 = matchingCandidates.get(forwardedPort.port)) == null ? void 0 : _a30.detail);
      if (attributes) {
        configAttributes.set(forwardedPort.port, attributes);
      }
    });
    if (this.portAttributesProviders.length === 0 || !checkProviders) {
      return configAttributes.size > 0 ? configAttributes : void 0;
    }
    const allProviderResults = await Promise.all(flatten(this.portAttributesProviders.map((provider) => {
      return Array.from(pidToPortsMapping.entries()).map((entry) => {
        const portGroup = entry[1];
        const matchingCandidate = matchingCandidates.get(portGroup[0]);
        return provider.providePortAttributes(portGroup, matchingCandidate == null ? void 0 : matchingCandidate.pid, matchingCandidate == null ? void 0 : matchingCandidate.detail, new CancellationTokenSource().token);
      });
    })));
    const providedAttributes = /* @__PURE__ */ new Map();
    allProviderResults.forEach((attributes) => attributes.forEach((attribute) => {
      if (attribute) {
        providedAttributes.set(attribute.port, attribute);
      }
    }));
    if (!configAttributes && !providedAttributes) {
      return void 0;
    }
    const mergedAttributes = /* @__PURE__ */ new Map();
    forwardedPorts.forEach((forwardedPorts2) => {
      const config = configAttributes.get(forwardedPorts2.port);
      const provider = providedAttributes.get(forwardedPorts2.port);
      mergedAttributes.set(forwardedPorts2.port, {
        elevateIfNeeded: config == null ? void 0 : config.elevateIfNeeded,
        label: config == null ? void 0 : config.label,
        onAutoForward: (config == null ? void 0 : config.onAutoForward) ?? PortsAttributes.providedActionToAction(provider == null ? void 0 : provider.autoForwardAction),
        requireLocalPort: config == null ? void 0 : config.requireLocalPort,
        protocol: config == null ? void 0 : config.protocol
      });
    });
    return mergedAttributes;
  }
  addAttributesProvider(provider) {
    this.portAttributesProviders.push(provider);
  }
};
TunnelModel.__decorator = __decorate([
  debounce(1e3)
], TunnelModel.prototype, "storeForwarded", null);
TunnelModel = __decorate([
  __param(0, ITunnelService),
  __param(1, IStorageService),
  __param(2, IConfigurationService),
  __param(3, IWorkbenchEnvironmentService),
  __param(4, IRemoteAuthorityResolverService),
  __param(5, IWorkspaceContextService),
  __param(6, ILogService),
  __param(7, IDialogService),
  __param(8, IExtensionService),
  __param(9, IContextKeyService)
], TunnelModel);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTunnelService.js
var MainThreadTunnelService = class MainThreadTunnelService2 extends Disposable {
  constructor(extHostContext, remoteExplorerService, tunnelService, notificationService, configurationService, logService, remoteAgentService, contextKeyService) {
    super();
    this.remoteExplorerService = remoteExplorerService;
    this.tunnelService = tunnelService;
    this.notificationService = notificationService;
    this.configurationService = configurationService;
    this.logService = logService;
    this.remoteAgentService = remoteAgentService;
    this.contextKeyService = contextKeyService;
    this.elevateionRetry = false;
    this.portsAttributesProviders = /* @__PURE__ */ new Map();
    this._alreadyRegistered = false;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostTunnelService);
    this._register(tunnelService.onTunnelOpened(() => this._proxy.$onDidTunnelsChange()));
    this._register(tunnelService.onTunnelClosed(() => this._proxy.$onDidTunnelsChange()));
  }
  processFindingEnabled() {
    return (!!this.configurationService.getValue(PORT_AUTO_FORWARD_SETTING) || this.tunnelService.hasTunnelProvider) && this.configurationService.getValue(PORT_AUTO_SOURCE_SETTING) !== PORT_AUTO_SOURCE_SETTING_OUTPUT;
  }
  async $setRemoteTunnelService(processId) {
    this.remoteExplorerService.namedProcesses.set(processId, "Code Extension Host");
    if (this.remoteExplorerService.portsFeaturesEnabled) {
      this._proxy.$registerCandidateFinder(this.processFindingEnabled());
    } else {
      this._register(this.remoteExplorerService.onEnabledPortsFeatures(() => this._proxy.$registerCandidateFinder(this.configurationService.getValue(PORT_AUTO_FORWARD_SETTING))));
    }
    this._register(this.configurationService.onDidChangeConfiguration(async (e) => {
      if (e.affectsConfiguration(PORT_AUTO_FORWARD_SETTING) || e.affectsConfiguration(PORT_AUTO_SOURCE_SETTING)) {
        return this._proxy.$registerCandidateFinder(this.processFindingEnabled());
      }
    }));
    this._register(this.tunnelService.onAddedTunnelProvider(() => {
      return this._proxy.$registerCandidateFinder(this.processFindingEnabled());
    }));
  }
  async $registerPortsAttributesProvider(selector, providerHandle) {
    this.portsAttributesProviders.set(providerHandle, selector);
    if (!this._alreadyRegistered) {
      this.remoteExplorerService.tunnelModel.addAttributesProvider(this);
      this._alreadyRegistered = true;
    }
  }
  async $unregisterPortsAttributesProvider(providerHandle) {
    this.portsAttributesProviders.delete(providerHandle);
  }
  async providePortAttributes(ports, pid, commandLine, token) {
    if (this.portsAttributesProviders.size === 0) {
      return [];
    }
    const appropriateHandles = Array.from(this.portsAttributesProviders.entries()).filter((entry) => {
      const selector = entry[1];
      const portRange = typeof selector.portRange === "number" ? [selector.portRange, selector.portRange + 1] : selector.portRange;
      const portInRange = portRange ? ports.some((port) => portRange[0] <= port && port < portRange[1]) : true;
      const commandMatches = !selector.commandPattern || commandLine && commandLine.match(selector.commandPattern);
      return portInRange && commandMatches;
    }).map((entry) => entry[0]);
    if (appropriateHandles.length === 0) {
      return [];
    }
    return this._proxy.$providePortAttributes(appropriateHandles, ports, pid, commandLine, token);
  }
  async $openTunnel(tunnelOptions, source) {
    const tunnel = await this.remoteExplorerService.forward({
      remote: tunnelOptions.remoteAddress,
      local: tunnelOptions.localAddressPort,
      name: tunnelOptions.label,
      source: {
        source: TunnelSource.Extension,
        description: source
      },
      elevateIfNeeded: false
    });
    if (!tunnel || typeof tunnel === "string") {
      return void 0;
    }
    if (!this.elevateionRetry && tunnelOptions.localAddressPort !== void 0 && tunnel.tunnelLocalPort !== void 0 && this.tunnelService.isPortPrivileged(tunnelOptions.localAddressPort) && tunnel.tunnelLocalPort !== tunnelOptions.localAddressPort && this.tunnelService.canElevate) {
      this.elevationPrompt(tunnelOptions, tunnel, source);
    }
    return TunnelDtoConverter.fromServiceTunnel(tunnel);
  }
  async elevationPrompt(tunnelOptions, tunnel, source) {
    return this.notificationService.prompt(Severity.Info, localize(
      "remote.tunnel.openTunnel",
      "The extension {0} has forwarded port {1}. You'll need to run as superuser to use port {2} locally.",
      source,
      tunnelOptions.remoteAddress.port,
      tunnelOptions.localAddressPort
    ), [{
      label: localize(
        "remote.tunnelsView.elevationButton",
        "Use Port {0} as Sudo...",
        tunnel.tunnelRemotePort
      ),
      run: async () => {
        this.elevateionRetry = true;
        await this.remoteExplorerService.close({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort }, TunnelCloseReason.Other);
        await this.remoteExplorerService.forward({
          remote: tunnelOptions.remoteAddress,
          local: tunnelOptions.localAddressPort,
          name: tunnelOptions.label,
          source: {
            source: TunnelSource.Extension,
            description: source
          },
          elevateIfNeeded: true
        });
        this.elevateionRetry = false;
      }
    }]);
  }
  async $closeTunnel(remote) {
    return this.remoteExplorerService.close(remote, TunnelCloseReason.Other);
  }
  async $getTunnels() {
    return (await this.tunnelService.tunnels).map((tunnel) => {
      return {
        remoteAddress: { port: tunnel.tunnelRemotePort, host: tunnel.tunnelRemoteHost },
        localAddress: tunnel.localAddress,
        privacy: tunnel.privacy,
        protocol: tunnel.protocol
      };
    });
  }
  async $onFoundNewCandidates(candidates) {
    this.remoteExplorerService.onFoundNewCandidates(candidates);
  }
  async $setTunnelProvider(features) {
    const tunnelProvider = {
      forwardPort: (tunnelOptions, tunnelCreationOptions) => {
        const forward = this._proxy.$forwardPort(tunnelOptions, tunnelCreationOptions);
        return forward.then((tunnelOrError) => {
          if (!tunnelOrError) {
            return void 0;
          } else if (typeof tunnelOrError === "string") {
            return tunnelOrError;
          }
          const tunnel = tunnelOrError;
          this.logService.trace(`ForwardedPorts: (MainThreadTunnelService) New tunnel established by tunnel provider: ${tunnel == null ? void 0 : tunnel.remoteAddress.host}:${tunnel == null ? void 0 : tunnel.remoteAddress.port}`);
          return {
            tunnelRemotePort: tunnel.remoteAddress.port,
            tunnelRemoteHost: tunnel.remoteAddress.host,
            localAddress: typeof tunnel.localAddress === "string" ? tunnel.localAddress : makeAddress(tunnel.localAddress.host, tunnel.localAddress.port),
            tunnelLocalPort: typeof tunnel.localAddress !== "string" ? tunnel.localAddress.port : void 0,
            public: tunnel.public,
            privacy: tunnel.privacy,
            protocol: tunnel.protocol ?? TunnelProtocol.Http,
            dispose: async (silent) => {
              this.logService.trace(`ForwardedPorts: (MainThreadTunnelService) Closing tunnel from tunnel provider: ${tunnel == null ? void 0 : tunnel.remoteAddress.host}:${tunnel == null ? void 0 : tunnel.remoteAddress.port}`);
              return this._proxy.$closeTunnel({ host: tunnel.remoteAddress.host, port: tunnel.remoteAddress.port }, silent);
            }
          };
        });
      }
    };
    if (features) {
      this.tunnelService.setTunnelFeatures(features);
    }
    this.tunnelService.setTunnelProvider(tunnelProvider);
    this.contextKeyService.createKey(forwardedPortsViewEnabled.key, true);
  }
  async $setCandidateFilter() {
    this.remoteExplorerService.setCandidateFilter((candidates) => {
      return this._proxy.$applyCandidateFilter(candidates);
    });
  }
  async $setCandidatePortSource(source) {
    this.remoteAgentService.getEnvironment().then(() => {
      switch (source) {
        case CandidatePortSource.None: {
          Registry.as(Extensions2.Configuration).registerDefaultConfigurations([{ overrides: { "remote.autoForwardPorts": false } }]);
          break;
        }
        case CandidatePortSource.Output: {
          Registry.as(Extensions2.Configuration).registerDefaultConfigurations([{ overrides: { "remote.autoForwardPortsSource": PORT_AUTO_SOURCE_SETTING_OUTPUT } }]);
          break;
        }
      }
    }).catch(() => {
    });
  }
};
MainThreadTunnelService = __decorate([
  extHostNamedCustomer(MainContext.MainThreadTunnelService),
  __param(1, IRemoteExplorerService),
  __param(2, ITunnelService),
  __param(3, INotificationService),
  __param(4, IConfigurationService),
  __param(5, ILogService),
  __param(6, IRemoteAgentService),
  __param(7, IContextKeyService)
], MainThreadTunnelService);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadAuthentication.js
init_tslib_es6();
init_lifecycle();
init_nls();

// node_modules/vscode/vscode/src/vs/workbench/services/authentication/browser/authenticationService.js
init_types();
init_nls();
init_actions2();
init_commands();
init_contextkey();
function getAuthenticationProviderActivationEvent(id) {
  return `onAuthenticationRequest:${id}`;
}
function readAccountUsages(storageService, providerId, accountName) {
  const accountKey = `${providerId}-${accountName}-usages`;
  const storedUsages = storageService.get(accountKey, -1);
  let usages = [];
  if (storedUsages) {
    try {
      usages = JSON.parse(storedUsages);
    } catch (e) {
    }
  }
  return usages;
}
function removeAccountUsage(storageService, providerId, accountName) {
  const accountKey = `${providerId}-${accountName}-usages`;
  storageService.remove(accountKey, -1);
}
function addAccountUsage(storageService, providerId, accountName, extensionId, extensionName) {
  const accountKey = `${providerId}-${accountName}-usages`;
  const usages = readAccountUsages(storageService, providerId, accountName);
  const existingUsageIndex = usages.findIndex((usage) => usage.extensionId === extensionId);
  if (existingUsageIndex > -1) {
    usages.splice(existingUsageIndex, 1, {
      extensionId,
      extensionName,
      lastUsed: Date.now()
    });
  } else {
    usages.push({
      extensionId,
      extensionName,
      lastUsed: Date.now()
    });
  }
  storageService.store(accountKey, JSON.stringify(usages), -1, 1);
}
function readAllowedExtensions(storageService, providerId, accountName) {
  let trustedExtensions = [];
  try {
    const trustedExtensionSrc = storageService.get(`${providerId}-${accountName}`, -1);
    if (trustedExtensionSrc) {
      trustedExtensions = JSON.parse(trustedExtensionSrc);
    }
  } catch (err) {
  }
  return trustedExtensions;
}
CommandsRegistry.registerCommand("workbench.getCodeExchangeProxyEndpoints", function(accessor, _) {
  var _a30;
  const environmentService = accessor.get(IBrowserWorkbenchEnvironmentService);
  return (_a30 = environmentService.options) == null ? void 0 : _a30.codeExchangeProxyEndpoints;
});
MenuRegistry.appendMenuItem(MenuId.AccountsContext, {
  command: {
    id: "noAuthenticationProviders",
    title: localize("authentication.Placeholder", "No accounts requested yet..."),
    precondition: ContextKeyExpr.false()
  }
});

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadAuthentication.js
init_extHost_protocol();
init_telemetry();
var MainThreadAuthenticationProvider = class extends Disposable {
  constructor(_proxy10, id, label, supportsMultipleAccounts, notificationService, storageService, quickInputService, dialogService) {
    super();
    this._proxy = _proxy10;
    this.id = id;
    this.label = label;
    this.supportsMultipleAccounts = supportsMultipleAccounts;
    this.notificationService = notificationService;
    this.storageService = storageService;
    this.quickInputService = quickInputService;
    this.dialogService = dialogService;
  }
  manageTrustedExtensions(accountName) {
    const allowedExtensions = readAllowedExtensions(this.storageService, this.id, accountName);
    if (!allowedExtensions.length) {
      this.dialogService.info(localize("noTrustedExtensions", "This account has not been used by any extensions."));
      return;
    }
    const quickPick = this.quickInputService.createQuickPick();
    quickPick.canSelectMany = true;
    quickPick.customButton = true;
    quickPick.customLabel = localize("manageTrustedExtensions.cancel", "Cancel");
    const usages = readAccountUsages(this.storageService, this.id, accountName);
    const items = allowedExtensions.map((extension) => {
      const usage = usages.find((usage2) => extension.id === usage2.extensionId);
      return {
        label: extension.name,
        description: usage ? localize(
          { key: "accountLastUsedDate", comment: ['The placeholder {0} is a string with time information, such as "3 days ago"'] },
          "Last used this account {0}",
          fromNow(usage.lastUsed, true)
        ) : localize("notUsed", "Has not used this account"),
        extension
      };
    });
    quickPick.items = items;
    quickPick.selectedItems = items.filter((item) => item.extension.allowed === void 0 || item.extension.allowed);
    quickPick.title = localize("manageTrustedExtensions", "Manage Trusted Extensions");
    quickPick.placeholder = localize("manageExtensions", "Choose which extensions can access this account");
    quickPick.onDidAccept(() => {
      const updatedAllowedList = quickPick.items.map((i) => i.extension);
      this.storageService.store(`${this.id}-${accountName}`, JSON.stringify(updatedAllowedList), -1, 0);
      quickPick.dispose();
    });
    quickPick.onDidChangeSelection((changed) => {
      quickPick.items.forEach((item) => {
        if (item.extension) {
          item.extension.allowed = false;
        }
      });
      changed.forEach((item) => item.extension.allowed = true);
    });
    quickPick.onDidHide(() => {
      quickPick.dispose();
    });
    quickPick.onDidCustom(() => {
      quickPick.hide();
    });
    quickPick.show();
  }
  async removeAccountSessions(accountName, sessions) {
    const accountUsages = readAccountUsages(this.storageService, this.id, accountName);
    const { confirmed } = await this.dialogService.confirm({
      type: severity_default.Info,
      message: accountUsages.length ? localize(
        "signOutMessage",
        "The account '{0}' has been used by: \n\n{1}\n\n Sign out from these extensions?",
        accountName,
        accountUsages.map((usage) => usage.extensionName).join("\n")
      ) : localize("signOutMessageSimple", "Sign out of '{0}'?", accountName),
      primaryButton: localize({ key: "signOut", comment: ["&& denotes a mnemonic"] }, "&&Sign Out")
    });
    if (confirmed) {
      const removeSessionPromises = sessions.map((session) => this.removeSession(session.id));
      await Promise.all(removeSessionPromises);
      removeAccountUsage(this.storageService, this.id, accountName);
      this.storageService.remove(`${this.id}-${accountName}`, -1);
    }
  }
  async getSessions(scopes) {
    return this._proxy.$getSessions(this.id, scopes);
  }
  createSession(scopes, options) {
    return this._proxy.$createSession(this.id, scopes, options);
  }
  async removeSession(sessionId) {
    await this._proxy.$removeSession(this.id, sessionId);
    this.notificationService.info(localize("signedOut", "Successfully signed out."));
  }
};
var MainThreadAuthentication = class MainThreadAuthentication2 extends Disposable {
  constructor(extHostContext, authenticationService, dialogService, storageService, notificationService, quickInputService, extensionService, telemetryService) {
    super();
    this.authenticationService = authenticationService;
    this.dialogService = dialogService;
    this.storageService = storageService;
    this.notificationService = notificationService;
    this.quickInputService = quickInputService;
    this.extensionService = extensionService;
    this.telemetryService = telemetryService;
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostAuthentication);
    this._register(this.authenticationService.onDidChangeSessions((e) => {
      this._proxy.$onDidChangeAuthenticationSessions(e.providerId, e.label);
    }));
    this._proxy.$setProviders(this.authenticationService.declaredProviders);
    this._register(this.authenticationService.onDidChangeDeclaredProviders((e) => {
      this._proxy.$setProviders(e);
    }));
  }
  async $registerAuthenticationProvider(id, label, supportsMultipleAccounts) {
    const provider = new MainThreadAuthenticationProvider(
      this._proxy,
      id,
      label,
      supportsMultipleAccounts,
      this.notificationService,
      this.storageService,
      this.quickInputService,
      this.dialogService
    );
    this.authenticationService.registerAuthenticationProvider(id, provider);
  }
  $unregisterAuthenticationProvider(id) {
    this.authenticationService.unregisterAuthenticationProvider(id);
  }
  $ensureProvider(id) {
    return this.extensionService.activateByEvent(getAuthenticationProviderActivationEvent(id), 1);
  }
  $sendDidChangeSessions(id, event) {
    this.authenticationService.sessionsUpdate(id, event);
  }
  $removeSession(providerId, sessionId) {
    return this.authenticationService.removeSession(providerId, sessionId);
  }
  async loginPrompt(providerName, extensionName, recreatingSession, detail) {
    const message = recreatingSession ? localize(
      "confirmRelogin",
      "The extension '{0}' wants you to sign in again using {1}.",
      extensionName,
      providerName
    ) : localize(
      "confirmLogin",
      "The extension '{0}' wants to sign in using {1}.",
      extensionName,
      providerName
    );
    const { confirmed } = await this.dialogService.confirm({
      type: severity_default.Info,
      message,
      detail,
      primaryButton: localize({ key: "allow", comment: ["&& denotes a mnemonic"] }, "&&Allow")
    });
    return confirmed;
  }
  async doGetSession(providerId, scopes, extensionId, extensionName, options) {
    const sessions = await this.authenticationService.getSessions(providerId, scopes, true);
    const supportsMultipleAccounts = this.authenticationService.supportsMultipleAccounts(providerId);
    if (options.forceNewSession && options.createIfNone) {
      throw new Error("Invalid combination of options. Please remove one of the following: forceNewSession, createIfNone");
    }
    if (options.forceNewSession && options.silent) {
      throw new Error("Invalid combination of options. Please remove one of the following: forceNewSession, silent");
    }
    if (options.createIfNone && options.silent) {
      throw new Error("Invalid combination of options. Please remove one of the following: createIfNone, silent");
    }
    if (!options.forceNewSession && sessions.length) {
      if (supportsMultipleAccounts) {
        if (options.clearSessionPreference) {
          this.authenticationService.removeSessionPreference(providerId, extensionId, scopes);
        } else {
          const existingSessionPreference = this.authenticationService.getSessionPreference(providerId, extensionId, scopes);
          if (existingSessionPreference) {
            const matchingSession = sessions.find((session) => session.id === existingSessionPreference);
            if (matchingSession && this.authenticationService.isAccessAllowed(providerId, matchingSession.account.label, extensionId)) {
              return matchingSession;
            }
          }
        }
      } else if (this.authenticationService.isAccessAllowed(providerId, sessions[0].account.label, extensionId)) {
        return sessions[0];
      }
    }
    if (options.createIfNone || options.forceNewSession) {
      const providerName = this.authenticationService.getLabel(providerId);
      const detail = typeof options.forceNewSession === "object" ? options.forceNewSession.detail : void 0;
      const recreatingSession = !!(options.forceNewSession && sessions.length);
      const isAllowed = await this.loginPrompt(providerName, extensionName, recreatingSession, detail);
      if (!isAllowed) {
        throw new Error("User did not consent to login.");
      }
      let session;
      if ((sessions == null ? void 0 : sessions.length) && !options.forceNewSession && supportsMultipleAccounts) {
        session = await this.authenticationService.selectSession(providerId, extensionId, extensionName, scopes, sessions);
      } else {
        let sessionToRecreate;
        if (typeof options.forceNewSession === "object" && options.forceNewSession.sessionToRecreate) {
          sessionToRecreate = options.forceNewSession.sessionToRecreate;
        } else {
          const sessionIdToRecreate = this.authenticationService.getSessionPreference(providerId, extensionId, scopes);
          sessionToRecreate = sessionIdToRecreate ? sessions.find((session2) => session2.id === sessionIdToRecreate) : void 0;
        }
        session = await this.authenticationService.createSession(providerId, scopes, { activateImmediate: true, sessionToRecreate });
      }
      this.authenticationService.updateAllowedExtension(providerId, session.account.label, extensionId, extensionName, true);
      this.authenticationService.updateSessionPreference(providerId, extensionId, session);
      return session;
    }
    const validSession = sessions.find((session) => this.authenticationService.isAccessAllowed(providerId, session.account.label, extensionId));
    if (validSession) {
      if (!this.authenticationService.getSessionPreference(providerId, extensionId, scopes)) {
        if (this.storageService.get(`${extensionName}-${providerId}`, -1)) {
          this.storageService.remove(`${extensionName}-${providerId}`, -1);
        }
        this.authenticationService.updateAllowedExtension(providerId, validSession.account.label, extensionId, extensionName, true);
        this.authenticationService.updateSessionPreference(providerId, extensionId, validSession);
      }
      return validSession;
    }
    if (!options.silent) {
      sessions.length ? this.authenticationService.requestSessionAccess(providerId, extensionId, extensionName, scopes, sessions) : await this.authenticationService.requestNewSession(providerId, scopes, extensionId, extensionName);
    }
    return void 0;
  }
  async $getSession(providerId, scopes, extensionId, extensionName, options) {
    const session = await this.doGetSession(providerId, scopes, extensionId, extensionName, options);
    if (session) {
      this.sendProviderUsageTelemetry(extensionId, providerId);
      addAccountUsage(this.storageService, providerId, session.account.label, extensionId, extensionName);
    }
    return session;
  }
  async $getSessions(providerId, scopes, extensionId, extensionName) {
    const sessions = await this.authenticationService.getSessions(providerId, [...scopes], true);
    const accessibleSessions = sessions.filter((s) => this.authenticationService.isAccessAllowed(providerId, s.account.label, extensionId));
    if (accessibleSessions.length) {
      this.sendProviderUsageTelemetry(extensionId, providerId);
      for (const session of accessibleSessions) {
        addAccountUsage(this.storageService, providerId, session.account.label, extensionId, extensionName);
      }
    }
    return accessibleSessions;
  }
  sendProviderUsageTelemetry(extensionId, providerId) {
    this.telemetryService.publicLog2("authentication.providerUsage", { providerId, extensionId });
  }
};
MainThreadAuthentication = __decorate([
  extHostNamedCustomer(MainContext.MainThreadAuthentication),
  __param(1, IAuthenticationService),
  __param(2, IDialogService),
  __param(3, IStorageService),
  __param(4, INotificationService),
  __param(5, IQuickInputService),
  __param(6, IExtensionService),
  __param(7, ITelemetryService)
], MainThreadAuthentication);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTimeline.js
init_tslib_es6();
init_event();
init_log();
init_extHost_protocol();
var MainThreadTimeline = class MainThreadTimeline2 {
  constructor(context, logService, _timelineService) {
    this.logService = logService;
    this._timelineService = _timelineService;
    this._providerEmitters = /* @__PURE__ */ new Map();
    this._proxy = context.getProxy(ExtHostContext.ExtHostTimeline);
  }
  $registerTimelineProvider(provider) {
    this.logService.trace(`MainThreadTimeline#registerTimelineProvider: id=${provider.id}`);
    const proxy = this._proxy;
    const emitters = this._providerEmitters;
    let onDidChange = emitters.get(provider.id);
    if (onDidChange === void 0) {
      onDidChange = new Emitter();
      emitters.set(provider.id, onDidChange);
    }
    this._timelineService.registerTimelineProvider({
      ...provider,
      onDidChange: onDidChange.event,
      async provideTimeline(uri, options, token) {
        return revive(await proxy.$getTimeline(provider.id, uri, options, token));
      },
      dispose() {
        emitters.delete(provider.id);
        onDidChange == null ? void 0 : onDidChange.dispose();
      }
    });
  }
  $unregisterTimelineProvider(id) {
    this.logService.trace(`MainThreadTimeline#unregisterTimelineProvider: id=${id}`);
    this._timelineService.unregisterTimelineProvider(id);
  }
  $emitTimelineChangeEvent(e) {
    var _a30;
    this.logService.trace(`MainThreadTimeline#emitChangeEvent: id=${e.id}, uri=${(_a30 = e.uri) == null ? void 0 : _a30.toString(true)}`);
    const emitter = this._providerEmitters.get(e.id);
    emitter == null ? void 0 : emitter.fire(e);
  }
  dispose() {
  }
};
MainThreadTimeline = __decorate([
  extHostNamedCustomer(MainContext.MainThreadTimeline),
  __param(1, ILogService),
  __param(2, ITimelineService)
], MainThreadTimeline);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTesting.js
init_tslib_es6();
init_lifecycle();
init_uri();
init_range();

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/observableValue.js
init_event();
init_lifecycle();
var MutableObservableValue = class _MutableObservableValue extends Disposable {
  get value() {
    return this._value;
  }
  set value(v) {
    if (v !== this._value) {
      this._value = v;
      this.changeEmitter.fire(v);
    }
  }
  static stored(stored, defaultValue) {
    const o = new _MutableObservableValue(stored.get(defaultValue));
    o.onDidChange((value) => stored.store(value));
    return o;
  }
  constructor(_value) {
    super();
    this._value = _value;
    this.changeEmitter = this._register(new Emitter());
    this.onDidChange = this.changeEmitter.event;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testCoverage.js
init_cancellation();
var TestCoverage2 = class {
  constructor(accessor) {
    this.accessor = accessor;
  }
  async getAllFiles(token = CancellationToken.None) {
    if (!this.fileCoverage) {
      this.fileCoverage = this.accessor.provideFileCoverage(token);
    }
    try {
      return await this.fileCoverage;
    } catch (e) {
      this.fileCoverage = void 0;
      throw e;
    }
  }
  async getUri(uri, token = CancellationToken.None) {
    const files = await this.getAllFiles(token);
    return files.find((f) => f.uri.toString() === uri.toString());
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testResult.js
init_async();
init_buffer();
init_event();
init_lazy();
init_platform();
init_strings();
init_nls();

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/getComputedState.js
init_iterator();

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testingStates.js
var statePriority = {
  [2]: 6,
  [6]: 5,
  [4]: 4,
  [1]: 3,
  [3]: 2,
  [0]: 0,
  [5]: 1
};
Object.entries(statePriority).reduce((acc, [stateStr, priority]) => {
  const state = Number(stateStr);
  acc[state] = { statusNode: true, state, priority };
  return acc;
}, {});
var cmpPriority = (a, b) => statePriority[b] - statePriority[a];
var maxPriority = (...states) => {
  switch (states.length) {
    case 0:
      return 0;
    case 1:
      return states[0];
    case 2:
      return statePriority[states[0]] > statePriority[states[1]] ? states[0] : states[1];
    default: {
      let max = states[0];
      for (let i = 1; i < states.length; i++) {
        if (statePriority[max] < statePriority[states[i]]) {
          max = states[i];
        }
      }
      return max;
    }
  }
};
var statesInOrder = Object.keys(statePriority).map((s) => Number(s)).sort(cmpPriority);
var terminalStatePriorities = {
  [3]: 0,
  [5]: 1,
  [4]: 2,
  [6]: 3
};
var makeEmptyCounts = () => {
  return new Uint32Array(statesInOrder.length);
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/getComputedState.js
var isDurationAccessor = (accessor) => "getOwnDuration" in accessor;
var getComputedState = (accessor, node, force = false) => {
  let computed = accessor.getCurrentComputedState(node);
  if (computed === void 0 || force) {
    computed = accessor.getOwnState(node) ?? 0;
    let childrenCount = 0;
    const stateMap = makeEmptyCounts();
    for (const child of accessor.getChildren(node)) {
      const childComputed = getComputedState(accessor, child);
      childrenCount++;
      stateMap[childComputed]++;
      computed = childComputed === 5 && computed === 0 ? 5 : maxPriority(computed, childComputed);
    }
    if (childrenCount > LARGE_NODE_THRESHOLD) {
      largeNodeChildrenStates.set(node, stateMap);
    }
    accessor.setComputedState(node, computed);
  }
  return computed;
};
var getComputedDuration = (accessor, node, force = false) => {
  let computed = accessor.getCurrentComputedDuration(node);
  if (computed === void 0 || force) {
    const own = accessor.getOwnDuration(node);
    if (own !== void 0) {
      computed = own;
    } else {
      computed = void 0;
      for (const child of accessor.getChildren(node)) {
        const d = getComputedDuration(accessor, child);
        if (d !== void 0) {
          computed = (computed || 0) + d;
        }
      }
    }
    accessor.setComputedDuration(node, computed);
  }
  return computed;
};
var LARGE_NODE_THRESHOLD = 64;
var largeNodeChildrenStates = /* @__PURE__ */ new WeakMap();
var refreshComputedState = (accessor, node, explicitNewComputedState, refreshDuration = true) => {
  const oldState = accessor.getCurrentComputedState(node);
  const oldPriority = statePriority[oldState];
  const newState = explicitNewComputedState ?? getComputedState(accessor, node, true);
  const newPriority = statePriority[newState];
  const toUpdate = /* @__PURE__ */ new Set();
  if (newPriority !== oldPriority) {
    accessor.setComputedState(node, newState);
    toUpdate.add(node);
    let moveFromState = oldState;
    let moveToState = newState;
    for (const parent of accessor.getParents(node)) {
      const lnm = largeNodeChildrenStates.get(parent);
      if (lnm) {
        lnm[moveFromState]--;
        lnm[moveToState]++;
      }
      const prev = accessor.getCurrentComputedState(parent);
      if (newPriority > oldPriority) {
        if (prev !== void 0 && statePriority[prev] >= newPriority) {
          break;
        }
        if (lnm && lnm[moveToState] > 1) {
          break;
        }
        accessor.setComputedState(parent, newState);
        toUpdate.add(parent);
      } else {
        if (prev === void 0 || statePriority[prev] > oldPriority) {
          break;
        }
        if (lnm && lnm[moveFromState] > 0) {
          break;
        }
        moveToState = getComputedState(accessor, parent, true);
        accessor.setComputedState(parent, moveToState);
        toUpdate.add(parent);
      }
      moveFromState = prev;
    }
  }
  if (isDurationAccessor(accessor) && refreshDuration) {
    for (const parent of Iterable.concat(Iterable.single(node), accessor.getParents(node))) {
      const oldDuration = accessor.getCurrentComputedDuration(parent);
      const newDuration = getComputedDuration(accessor, parent, true);
      if (oldDuration === newDuration) {
        break;
      }
      accessor.setComputedDuration(parent, newDuration);
      toUpdate.add(parent);
    }
  }
  return toUpdate;
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testResult.js
({
  buffers: [],
  length: 0,
  onDidWriteData: Event.None,
  endPromise: Promise.resolve(),
  getRange: () => VSBuffer.alloc(0),
  getRangeIter: () => []
});
var TaskRawOutput = class {
  constructor() {
    this.writeDataEmitter = new Emitter();
    this.endDeferred = new DeferredPromise();
    this.offset = 0;
    this.onDidWriteData = this.writeDataEmitter.event;
    this.endPromise = this.endDeferred.p;
    this.buffers = [];
  }
  get length() {
    return this.offset;
  }
  getRange(start, length) {
    const buf = VSBuffer.alloc(length);
    let bufLastWrite = 0;
    for (const chunk of this.getRangeIter(start, length)) {
      buf.buffer.set(chunk.buffer, bufLastWrite);
      bufLastWrite += chunk.byteLength;
    }
    return bufLastWrite < length ? buf.slice(0, bufLastWrite) : buf;
  }
  *getRangeIter(start, length) {
    let soFar = 0;
    let internalLastRead = 0;
    for (const b of this.buffers) {
      if (internalLastRead + b.byteLength <= start) {
        internalLastRead += b.byteLength;
        continue;
      }
      const bstart = Math.max(0, start - internalLastRead);
      const bend = Math.min(b.byteLength, bstart + length - soFar);
      yield b.slice(bstart, bend);
      soFar += bend - bstart;
      internalLastRead += b.byteLength;
      if (soFar === length) {
        break;
      }
    }
  }
  append(data, marker) {
    const offset = this.offset;
    let length = data.byteLength;
    if (marker === void 0) {
      this.push(data);
      return { offset, length };
    }
    const start = VSBuffer.fromString(getMarkCode(marker, true));
    const end = VSBuffer.fromString(getMarkCode(marker, false));
    length += start.byteLength + end.byteLength;
    this.push(start);
    let trimLen = data.byteLength;
    for (; trimLen > 0; trimLen--) {
      const last = data.buffer[trimLen - 1];
      if (last !== 13 && last !== 10) {
        break;
      }
    }
    this.push(data.slice(0, trimLen));
    this.push(end);
    this.push(data.slice(trimLen));
    return { offset, length };
  }
  push(data) {
    if (data.byteLength === 0) {
      return;
    }
    this.buffers.push(data);
    this.writeDataEmitter.fire(data);
    this.offset += data.byteLength;
  }
  end() {
    this.endDeferred.complete();
  }
};
var getMarkCode = (marker, start) => `\x1B]633;SetMark;Id=${getMarkId(marker, start)};Hidden\x07`;
var itemToNode = (controllerId, item, parent) => ({
  controllerId,
  expand: 0,
  item: { ...item },
  children: [],
  tasks: [],
  ownComputedState: 0,
  computedState: 0
});
var LiveTestResult = class {
  get completedAt() {
    return this._completedAt;
  }
  get tests() {
    return this.testById.values();
  }
  constructor(id, persist, request) {
    this.id = id;
    this.persist = persist;
    this.request = request;
    this.completeEmitter = new Emitter();
    this.newTaskEmitter = new Emitter();
    this.endTaskEmitter = new Emitter();
    this.changeEmitter = new Emitter();
    this.testById = /* @__PURE__ */ new Map();
    this.testMarkerCounter = 0;
    this.startedAt = Date.now();
    this.onChange = this.changeEmitter.event;
    this.onComplete = this.completeEmitter.event;
    this.onNewTask = this.newTaskEmitter.event;
    this.onEndTask = this.endTaskEmitter.event;
    this.tasks = [];
    this.name = localize("runFinished", "Test run at {0}", (/* @__PURE__ */ new Date()).toLocaleString(language));
    this.counts = makeEmptyCounts();
    this.computedStateAccessor = {
      getOwnState: (i) => i.ownComputedState,
      getCurrentComputedState: (i) => i.computedState,
      setComputedState: (i, s) => i.computedState = s,
      getChildren: (i) => i.children,
      getParents: (i) => {
        const { testById: testByExtId } = this;
        return function* () {
          const parentId = TestId.fromString(i.item.extId).parentId;
          if (parentId) {
            for (const id2 of parentId.idsToRoot()) {
              yield testByExtId.get(id2.toString());
            }
          }
        }();
      }
    };
    this.doSerialize = new Lazy(() => ({
      id: this.id,
      completedAt: this.completedAt,
      tasks: this.tasks.map((t) => ({ id: t.id, name: t.name })),
      name: this.name,
      request: this.request,
      items: [...this.testById.values()].map(TestResultItem.serializeWithoutMessages)
    }));
    this.doSerializeWithMessages = new Lazy(() => ({
      id: this.id,
      completedAt: this.completedAt,
      tasks: this.tasks.map((t) => ({ id: t.id, name: t.name })),
      name: this.name,
      request: this.request,
      items: [...this.testById.values()].map(TestResultItem.serialize)
    }));
  }
  getStateById(extTestId) {
    return this.testById.get(extTestId);
  }
  appendOutput(output, taskId, location2, testId) {
    const preview = output.byteLength > 100 ? output.slice(0, 100).toString() + "…" : output.toString();
    let marker;
    if (testId || location2) {
      marker = this.testMarkerCounter++;
    }
    const index = this.mustGetTaskIndex(taskId);
    const task = this.tasks[index];
    const { offset, length } = task.output.append(output, marker);
    const message = {
      location: location2,
      message: removeAnsiEscapeCodes(preview),
      offset,
      length,
      marker,
      type: 1
    };
    const test = testId && this.testById.get(testId);
    if (test) {
      test.tasks[index].messages.push(message);
      this.changeEmitter.fire({ item: test, result: this, reason: 2, message });
    } else {
      task.otherMessages.push(message);
    }
  }
  addTask(task) {
    this.tasks.push({ ...task, coverage: new MutableObservableValue(void 0), otherMessages: [], output: new TaskRawOutput() });
    for (const test of this.tests) {
      test.tasks.push({ duration: void 0, messages: [], state: 0 });
    }
    this.newTaskEmitter.fire(this.tasks.length - 1);
  }
  addTestChainToRun(controllerId, chain) {
    let parent = this.testById.get(chain[0].extId);
    if (!parent) {
      parent = this.addTestToRun(controllerId, chain[0], null);
    }
    for (let i = 1; i < chain.length; i++) {
      parent = this.addTestToRun(controllerId, chain[i], parent.item.extId);
    }
    return void 0;
  }
  updateState(testId, taskId, state, duration) {
    const entry = this.testById.get(testId);
    if (!entry) {
      return;
    }
    const index = this.mustGetTaskIndex(taskId);
    const oldTerminalStatePrio = terminalStatePriorities[entry.tasks[index].state];
    const newTerminalStatePrio = terminalStatePriorities[state];
    if (oldTerminalStatePrio !== void 0 && (newTerminalStatePrio === void 0 || newTerminalStatePrio < oldTerminalStatePrio)) {
      return;
    }
    this.fireUpdateAndRefresh(entry, index, state, duration);
  }
  appendMessage(testId, taskId, message) {
    const entry = this.testById.get(testId);
    if (!entry) {
      return;
    }
    entry.tasks[this.mustGetTaskIndex(taskId)].messages.push(message);
    this.changeEmitter.fire({ item: entry, result: this, reason: 2, message });
  }
  markTaskComplete(taskId) {
    const index = this.mustGetTaskIndex(taskId);
    const task = this.tasks[index];
    task.running = false;
    task.output.end();
    this.setAllToState(0, taskId, (t) => t.state === 1 || t.state === 2);
    this.endTaskEmitter.fire(index);
  }
  markComplete() {
    if (this._completedAt !== void 0) {
      throw new Error("cannot complete a test result multiple times");
    }
    for (const task of this.tasks) {
      if (task.running) {
        this.markTaskComplete(task.id);
      }
    }
    this._completedAt = Date.now();
    this.completeEmitter.fire();
  }
  markRetired(testIds) {
    for (const [id, test] of this.testById) {
      if (!test.retired && (!testIds || testIds.hasKeyOrParent(TestId.fromString(id).path))) {
        test.retired = true;
        this.changeEmitter.fire({ reason: 0, item: test, result: this });
      }
    }
  }
  toJSON() {
    return this.completedAt && this.persist ? this.doSerialize.value : void 0;
  }
  toJSONWithMessages() {
    return this.completedAt && this.persist ? this.doSerializeWithMessages.value : void 0;
  }
  setAllToState(state, taskId, when) {
    const index = this.mustGetTaskIndex(taskId);
    for (const test of this.testById.values()) {
      if (when(test.tasks[index], test)) {
        this.fireUpdateAndRefresh(test, index, state);
      }
    }
  }
  fireUpdateAndRefresh(entry, taskIndex, newState, newOwnDuration) {
    const previousOwnComputed = entry.ownComputedState;
    const previousOwnDuration = entry.ownDuration;
    const changeEvent = {
      item: entry,
      result: this,
      reason: 1,
      previousState: previousOwnComputed,
      previousOwnDuration
    };
    entry.tasks[taskIndex].state = newState;
    if (newOwnDuration !== void 0) {
      entry.tasks[taskIndex].duration = newOwnDuration;
      entry.ownDuration = Math.max(entry.ownDuration || 0, newOwnDuration);
    }
    const newOwnComputed = maxPriority(...entry.tasks.map((t) => t.state));
    if (newOwnComputed === previousOwnComputed) {
      if (newOwnDuration !== previousOwnDuration) {
        this.changeEmitter.fire(changeEvent);
      }
      return;
    }
    entry.ownComputedState = newOwnComputed;
    this.counts[previousOwnComputed]--;
    this.counts[newOwnComputed]++;
    refreshComputedState(this.computedStateAccessor, entry).forEach((t) => this.changeEmitter.fire(t === entry ? changeEvent : {
      item: t,
      result: this,
      reason: 0
    }));
  }
  addTestToRun(controllerId, item, parent) {
    var _a30;
    const node = itemToNode(controllerId, item);
    this.testById.set(item.extId, node);
    this.counts[0]++;
    if (parent) {
      (_a30 = this.testById.get(parent)) == null ? void 0 : _a30.children.push(node);
    }
    if (this.tasks.length) {
      for (let i = 0; i < this.tasks.length; i++) {
        node.tasks.push({ duration: void 0, messages: [], state: 0 });
      }
    }
    return node;
  }
  mustGetTaskIndex(taskId) {
    const index = this.tasks.findIndex((t) => t.id === taskId);
    if (index === -1) {
      throw new Error(`Unknown task ${taskId} in updateState`);
    }
    return index;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTesting.js
init_extHost_protocol();

// node_modules/vscode/vscode/src/vs/base/common/prefixTree.js
var unset = Symbol("unset");
var WellDefinedPrefixTree = class {
  constructor() {
    this.root = new Node();
    this._size = 0;
  }
  get size() {
    return this._size;
  }
  insert(key, value) {
    this.opNode(key, (n2) => n2.value = value);
  }
  mutate(key, mutate) {
    this.opNode(key, (n2) => n2.value = mutate(n2.value === unset ? void 0 : n2.value));
  }
  delete(key) {
    var _a30;
    const path = [{ part: "", node: this.root }];
    let i = 0;
    for (const part of key) {
      const node = (_a30 = path[i].node.children) == null ? void 0 : _a30.get(part);
      if (!node) {
        return void 0;
      }
      path.push({ part, node });
      i++;
    }
    const value = path[i].node.value;
    if (value === unset) {
      return;
    }
    this._size--;
    for (; i > 0; i--) {
      const parent = path[i - 1];
      parent.node.children.delete(path[i].part);
      if (parent.node.children.size > 0 || parent.node.value !== unset) {
        break;
      }
    }
    return value;
  }
  find(key) {
    var _a30;
    let node = this.root;
    for (const segment of key) {
      const next = (_a30 = node.children) == null ? void 0 : _a30.get(segment);
      if (!next) {
        return void 0;
      }
      node = next;
    }
    return node.value === unset ? void 0 : node.value;
  }
  hasKeyOrParent(key) {
    var _a30;
    let node = this.root;
    for (const segment of key) {
      const next = (_a30 = node.children) == null ? void 0 : _a30.get(segment);
      if (!next) {
        return false;
      }
      if (next.value !== unset) {
        return true;
      }
      node = next;
    }
    return false;
  }
  hasKeyOrChildren(key) {
    var _a30;
    let node = this.root;
    for (const segment of key) {
      const next = (_a30 = node.children) == null ? void 0 : _a30.get(segment);
      if (!next) {
        return false;
      }
      node = next;
    }
    return true;
  }
  hasKey(key) {
    var _a30;
    let node = this.root;
    for (const segment of key) {
      const next = (_a30 = node.children) == null ? void 0 : _a30.get(segment);
      if (!next) {
        return false;
      }
      node = next;
    }
    return node.value !== unset;
  }
  opNode(key, fn) {
    let node = this.root;
    for (const part of key) {
      if (!node.children) {
        const next = new Node();
        node.children = /* @__PURE__ */ new Map([[part, next]]);
        node = next;
      } else if (!node.children.has(part)) {
        const next = new Node();
        node.children.set(part, next);
        node = next;
      } else {
        node = node.children.get(part);
      }
    }
    if (node.value === unset) {
      this._size++;
    }
    fn(node);
  }
  *values() {
    const stack = [this.root];
    while (stack.length > 0) {
      const node = stack.pop();
      if (node.value !== unset) {
        yield node.value;
      }
      if (node.children) {
        for (const child of node.children.values()) {
          stack.push(child);
        }
      }
    }
  }
};
var Node = class {
  constructor() {
    this.value = unset;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadTesting.js
var MainThreadTesting = class MainThreadTesting2 extends Disposable {
  constructor(extHostContext, testService, testProfiles, resultService) {
    super();
    this.testService = testService;
    this.testProfiles = testProfiles;
    this.resultService = resultService;
    this.diffListener = this._register(new MutableDisposable());
    this.testProviderRegistrations = /* @__PURE__ */ new Map();
    this.proxy = extHostContext.getProxy(ExtHostContext.ExtHostTesting);
    this._register(this.testService.onDidCancelTestRun(({ runId }) => {
      this.proxy.$cancelExtensionTestRun(runId);
    }));
    this._register(resultService.onResultsChanged((evt) => {
      const results = "completed" in evt ? evt.completed : "inserted" in evt ? evt.inserted : void 0;
      const serialized = results == null ? void 0 : results.toJSONWithMessages();
      if (serialized) {
        this.proxy.$publishTestResults([serialized]);
      }
    }));
  }
  $markTestRetired(testIds) {
    let tree;
    if (testIds) {
      tree = new WellDefinedPrefixTree();
      for (const id of testIds) {
        tree.insert(TestId.fromString(id).path, void 0);
      }
    }
    for (const result of this.resultService.results) {
      if (result instanceof LiveTestResult) {
        result.markRetired(tree);
      }
    }
  }
  $publishTestRunProfile(profile) {
    const controller = this.testProviderRegistrations.get(profile.controllerId);
    if (controller) {
      this.testProfiles.addProfile(controller.instance, profile);
    }
  }
  $updateTestRunConfig(controllerId, profileId, update) {
    this.testProfiles.updateProfile(controllerId, profileId, update);
  }
  $removeTestProfile(controllerId, profileId) {
    this.testProfiles.removeProfile(controllerId, profileId);
  }
  $addTestsToRun(controllerId, runId, tests) {
    this.withLiveRun(runId, (r) => r.addTestChainToRun(controllerId, tests.map(ITestItem.deserialize)));
  }
  $signalCoverageAvailable(runId, taskId) {
    this.withLiveRun(runId, (run) => {
      const task = run.tasks.find((t) => t.id === taskId);
      if (!task) {
        return;
      }
      task.coverage.value = new TestCoverage2({
        provideFileCoverage: async (token) => revive(await this.proxy.$provideFileCoverage(runId, taskId, token)),
        resolveFileCoverage: (i, token) => this.proxy.$resolveFileCoverage(runId, taskId, i, token)
      });
    });
  }
  $startedExtensionTestRun(req) {
    this.resultService.createLiveResult(req);
  }
  $startedTestRunTask(runId, task) {
    this.withLiveRun(runId, (r) => r.addTask(task));
  }
  $finishedTestRunTask(runId, taskId) {
    this.withLiveRun(runId, (r) => r.markTaskComplete(taskId));
  }
  $finishedExtensionTestRun(runId) {
    this.withLiveRun(runId, (r) => r.markComplete());
  }
  $updateTestStateInRun(runId, taskId, testId, state, duration) {
    this.withLiveRun(runId, (r) => r.updateState(testId, taskId, state, duration));
  }
  $appendOutputToRun(runId, taskId, output, locationDto, testId) {
    const location2 = locationDto && {
      uri: URI.revive(locationDto.uri),
      range: Range.lift(locationDto.range)
    };
    this.withLiveRun(runId, (r) => r.appendOutput(output, taskId, location2, testId));
  }
  $appendTestMessagesInRun(runId, taskId, testId, messages) {
    const r = this.resultService.getResult(runId);
    if (r && r instanceof LiveTestResult) {
      for (const message of messages) {
        r.appendMessage(testId, taskId, ITestMessage.deserialize(message));
      }
    }
  }
  $registerTestController(controllerId, labelStr, canRefreshValue) {
    const disposable = new DisposableStore();
    const label = disposable.add(new MutableObservableValue(labelStr));
    const canRefresh = disposable.add(new MutableObservableValue(canRefreshValue));
    const controller = {
      id: controllerId,
      label,
      canRefresh,
      syncTests: () => this.proxy.$syncTests(),
      refreshTests: (token) => this.proxy.$refreshTests(controllerId, token),
      configureRunProfile: (id) => this.proxy.$configureRunProfile(controllerId, id),
      runTests: (reqs, token) => this.proxy.$runControllerTests(reqs, token),
      startContinuousRun: (reqs, token) => this.proxy.$startContinuousRun(reqs, token),
      expandTest: (testId, levels) => this.proxy.$expandTest(testId, isFinite(levels) ? levels : -1)
    };
    disposable.add(toDisposable(() => this.testProfiles.removeProfile(controllerId)));
    disposable.add(this.testService.registerTestController(controllerId, controller));
    this.testProviderRegistrations.set(controllerId, {
      instance: controller,
      label,
      canRefresh,
      disposable
    });
  }
  $updateController(controllerId, patch) {
    const controller = this.testProviderRegistrations.get(controllerId);
    if (!controller) {
      return;
    }
    if (patch.label !== void 0) {
      controller.label.value = patch.label;
    }
    if (patch.canRefresh !== void 0) {
      controller.canRefresh.value = patch.canRefresh;
    }
  }
  $unregisterTestController(controllerId) {
    var _a30;
    (_a30 = this.testProviderRegistrations.get(controllerId)) == null ? void 0 : _a30.disposable.dispose();
    this.testProviderRegistrations.delete(controllerId);
  }
  $subscribeToDiffs() {
    this.proxy.$acceptDiff(this.testService.collection.getReviverDiff().map(TestsDiffOp.serialize));
    this.diffListener.value = this.testService.onDidProcessDiff(this.proxy.$acceptDiff, this.proxy);
  }
  $unsubscribeFromDiffs() {
    this.diffListener.clear();
  }
  $publishDiff(controllerId, diff) {
    this.testService.publishDiff(controllerId, diff.map(TestsDiffOp.deserialize));
  }
  async $runTests(req, token) {
    const result = await this.testService.runResolvedTests(req, token);
    return result.id;
  }
  dispose() {
    super.dispose();
    for (const subscription of this.testProviderRegistrations.values()) {
      subscription.disposable.dispose();
    }
    this.testProviderRegistrations.clear();
  }
  withLiveRun(runId, fn) {
    const r = this.resultService.getResult(runId);
    return r && r instanceof LiveTestResult ? fn(r) : void 0;
  }
};
MainThreadTesting = __decorate([
  extHostNamedCustomer(MainContext.MainThreadTesting),
  __param(1, ITestService),
  __param(2, ITestProfileService),
  __param(3, ITestResultService)
], MainThreadTesting);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadSecretState.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
init_log();
init_async();
var OldMainThreadSecretState = class extends Disposable {
  constructor(_proxy10, credentialsService, encryptionService, logService) {
    super();
    this._proxy = _proxy10;
    this.credentialsService = credentialsService;
    this.encryptionService = encryptionService;
    this.logService = logService;
    this.secretStoragePrefix = this.credentialsService.getSecretStoragePrefix();
    this._register(this.credentialsService.onDidChangePassword(async (e) => {
      var _a30;
      const extensionId = (_a30 = e.service) == null ? void 0 : _a30.substring((await this.secretStoragePrefix).length);
      if (extensionId) {
        this._proxy.$onDidChangePassword({ extensionId, key: e.account });
      }
    }));
  }
  async getFullKey(extensionId) {
    return `${await this.secretStoragePrefix}${extensionId}`;
  }
  async $getPassword(extensionId, key) {
    this.logService.trace(`MainThreadSecretState#getPassword: Getting password for ${extensionId} extension: `, key);
    const fullKey = await this.getFullKey(extensionId);
    const password = await this.credentialsService.getPassword(fullKey, key);
    if (!password) {
      this.logService.trace("MainThreadSecretState#getPassword: No password found for: ", key);
      return void 0;
    }
    let decrypted;
    try {
      this.logService.trace("MainThreadSecretState#getPassword: Decrypting password for: ", key);
      decrypted = await this.encryptionService.decrypt(password);
    } catch (e) {
      this.logService.error(e);
      this.logService.trace("MainThreadSecretState#getPassword: Trying migration for: ", key);
      const encryptedForSet = await this.encryptionService.encrypt(password);
      await this.credentialsService.setPassword(fullKey, key, encryptedForSet);
      const passwordEncrypted = await this.credentialsService.getPassword(fullKey, key);
      decrypted = passwordEncrypted && await this.encryptionService.decrypt(passwordEncrypted);
    }
    if (decrypted) {
      try {
        const value = JSON.parse(decrypted);
        if (value.extensionId === extensionId) {
          this.logService.trace("MainThreadSecretState#getPassword: Password found for: ", key);
          return value.content;
        }
      } catch (parseError) {
        this.logService.error(parseError);
        throw new Error("Unable to parse decrypted password");
      }
    }
    this.logService.trace("MainThreadSecretState#getPassword: No password found for: ", key);
    return void 0;
  }
  async $setPassword(extensionId, key, value) {
    this.logService.trace(`MainThreadSecretState#setPassword: Setting password for ${extensionId} extension: `, key);
    const fullKey = await this.getFullKey(extensionId);
    const toEncrypt = JSON.stringify({
      extensionId,
      content: value
    });
    this.logService.trace("MainThreadSecretState#setPassword: Encrypting password for: ", key);
    const encrypted = await this.encryptionService.encrypt(toEncrypt);
    this.logService.trace("MainThreadSecretState#setPassword: Storing password for: ", key);
    return await this.credentialsService.setPassword(fullKey, key, encrypted);
  }
  async $deletePassword(extensionId, key) {
    try {
      const fullKey = await this.getFullKey(extensionId);
      await this.credentialsService.deletePassword(fullKey, key);
    } catch (_) {
      throw new Error("Cannot delete password");
    }
  }
};
var MainThreadSecretState = class MainThreadSecretState2 extends Disposable {
  constructor(extHostContext, secretStorageService, logService, credentialsService, encryptionService, environmentService) {
    var _a30, _b;
    super();
    this.secretStorageService = secretStorageService;
    this.logService = logService;
    this.credentialsService = credentialsService;
    this.encryptionService = encryptionService;
    this._sequencer = new SequencerByKey();
    this.secretStoragePrefix = this.credentialsService.getSecretStoragePrefix();
    this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostSecretState);
    if (((_a30 = environmentService.options) == null ? void 0 : _a30.credentialsProvider) && !((_b = environmentService.options) == null ? void 0 : _b.secretStorageProvider)) {
      this._oldMainThreadSecretState = this._register(new OldMainThreadSecretState(this._proxy, credentialsService, encryptionService, logService));
    }
    this._register(this.secretStorageService.onDidChangeSecret((e) => {
      try {
        const { extensionId, key } = this.parseKey(e);
        if (extensionId && key) {
          this._proxy.$onDidChangePassword({ extensionId, key });
        }
      } catch (e2) {
      }
    }));
  }
  $getPassword(extensionId, key) {
    this.logService.trace(`[mainThreadSecretState] Getting password for ${extensionId} extension: `, key);
    return this._sequencer.queue(extensionId, () => this.doGetPassword(extensionId, key));
  }
  async doGetPassword(extensionId, key) {
    if (this._oldMainThreadSecretState) {
      return await this._oldMainThreadSecretState.$getPassword(extensionId, key);
    }
    const fullKey = this.getKey(extensionId, key);
    const password = await this.secretStorageService.get(fullKey);
    if (!password) {
      this.logService.trace("[mainThreadSecretState] No password found for: ", extensionId, key);
      const password2 = await this.getAndDeleteOldPassword(extensionId, key);
      return password2;
    }
    this.logService.trace("[mainThreadSecretState] Password found for: ", extensionId, key);
    return password;
  }
  $setPassword(extensionId, key, value) {
    this.logService.trace(`[mainThreadSecretState] Setting password for ${extensionId} extension: `, key);
    return this._sequencer.queue(extensionId, () => this.doSetPassword(extensionId, key, value));
  }
  async doSetPassword(extensionId, key, value) {
    if (this._oldMainThreadSecretState) {
      return await this._oldMainThreadSecretState.$setPassword(extensionId, key, value);
    }
    const fullKey = this.getKey(extensionId, key);
    await this.secretStorageService.set(fullKey, value);
    this.logService.trace("[mainThreadSecretState] Password set for: ", extensionId, key);
  }
  $deletePassword(extensionId, key) {
    this.logService.trace(`[mainThreadSecretState] Deleting password for ${extensionId} extension: `, key);
    return this._sequencer.queue(extensionId, () => this.doDeletePassword(extensionId, key));
  }
  async doDeletePassword(extensionId, key) {
    if (this._oldMainThreadSecretState) {
      return await this._oldMainThreadSecretState.$deletePassword(extensionId, key);
    }
    const fullKey = this.getKey(extensionId, key);
    await this.secretStorageService.delete(fullKey);
    this.logService.trace("[mainThreadSecretState] Password deleted for: ", extensionId, key);
  }
  getKey(extensionId, key) {
    return JSON.stringify({ extensionId, key });
  }
  parseKey(key) {
    return JSON.parse(key);
  }
  async getAndDeleteOldPassword(extensionId, key) {
    const password = await this.getOldPassword(extensionId, key);
    if (password) {
      const fullKey = this.getKey(extensionId, key);
      this.logService.trace("[mainThreadSecretState] Setting old password to new location for: ", extensionId, key);
      await this.secretStorageService.set(fullKey, password);
      this.logService.trace("[mainThreadSecretState] Old Password set to new location for: ", extensionId, key);
      if (this.secretStorageService.type === "persisted") {
        this.logService.trace("[mainThreadSecretState] Deleting old password for since it was persisted in the new location: ", extensionId, key);
        await this.deleteOldPassword(extensionId, key);
      }
    }
    return password;
  }
  async getOldPassword(extensionId, key) {
    this.logService.trace(`[mainThreadSecretState] Getting old password for ${extensionId} extension: `, key);
    const fullKey = `${await this.secretStoragePrefix}${extensionId}`;
    const password = await this.credentialsService.getPassword(fullKey, key);
    if (!password) {
      this.logService.trace("[mainThreadSecretState] No old password found for: ", extensionId, key);
      return void 0;
    }
    let decrypted;
    try {
      this.logService.trace("[mainThreadSecretState] Decrypting old password for: ", extensionId, key);
      decrypted = await this.encryptionService.decrypt(password);
    } catch (e) {
      this.logService.error(e);
      this.logService.trace("[mainThreadSecretState] Trying old migration for: ", extensionId, key);
      const encryptedForSet = await this.encryptionService.encrypt(password);
      await this.credentialsService.setPassword(fullKey, key, encryptedForSet);
      const passwordEncrypted = await this.credentialsService.getPassword(fullKey, key);
      decrypted = passwordEncrypted && await this.encryptionService.decrypt(passwordEncrypted);
    }
    if (decrypted) {
      try {
        const value = JSON.parse(decrypted);
        if (value.extensionId === extensionId) {
          this.logService.trace("[mainThreadSecretState] Old password found for: ", extensionId, key);
          return value.content;
        }
      } catch (parseError) {
        this.logService.error(parseError);
        return void 0;
      }
    }
    this.logService.trace("[mainThreadSecretState] No old password found for: ", extensionId, key);
    return void 0;
  }
  async deleteOldPassword(extensionId, key) {
    try {
      const fullKey = `${await this.secretStoragePrefix}${extensionId}`;
      this.logService.trace(`[mainThreadSecretState] Deleting old password for ${extensionId} extension: `, key);
      await this.credentialsService.deletePassword(fullKey, key);
      this.logService.trace("[mainThreadSecretState] Old password deleted for: ", extensionId, key);
    } catch (_) {
      throw new Error("Cannot delete password");
    }
  }
};
MainThreadSecretState = __decorate([
  extHostNamedCustomer(MainContext.MainThreadSecretState),
  __param(1, ISecretStorageService),
  __param(2, ILogService),
  __param(3, ICredentialsService),
  __param(4, IEncryptionService),
  __param(5, IBrowserWorkbenchEnvironmentService)
], MainThreadSecretState);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadShare.js
init_tslib_es6();
init_cancellation();
init_lifecycle();
init_uri();
init_extHost_protocol();
var MainThreadShare = class MainThreadShare2 {
  constructor(extHostContext, shareService) {
    this.shareService = shareService;
    this.providers = /* @__PURE__ */ new Map();
    this.providerDisposables = /* @__PURE__ */ new Map();
    this.proxy = extHostContext.getProxy(ExtHostContext.ExtHostShare);
  }
  $registerShareProvider(handle, selector, id, label, priority) {
    const provider = {
      id,
      label,
      selector,
      priority,
      provideShare: async (item) => {
        const result = await this.proxy.$provideShare(handle, item, new CancellationTokenSource().token);
        return typeof result === "string" ? result : URI.revive(result);
      }
    };
    this.providers.set(handle, provider);
    const disposable = this.shareService.registerShareProvider(provider);
    this.providerDisposables.set(handle, disposable);
  }
  $unregisterShareProvider(handle) {
    if (this.providers.has(handle)) {
      this.providers.delete(handle);
    }
    if (this.providerDisposables.has(handle)) {
      this.providerDisposables.delete(handle);
    }
  }
  dispose() {
    this.providers.clear();
    dispose(this.providerDisposables.values());
    this.providerDisposables.clear();
  }
};
MainThreadShare = __decorate([
  extHostNamedCustomer(MainContext.MainThreadShare),
  __param(1, IShareService)
], MainThreadShare);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadProfilContentHandlers.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
var MainThreadProfileContentHandlers = class MainThreadProfileContentHandlers2 extends Disposable {
  constructor(context, userDataProfileImportExportService) {
    super();
    this.userDataProfileImportExportService = userDataProfileImportExportService;
    this.registeredHandlers = this._register(new DisposableMap());
    this.proxy = context.getProxy(ExtHostContext.ExtHostProfileContentHandlers);
  }
  async $registerProfileContentHandler(id, name, description, extensionId) {
    this.registeredHandlers.set(id, this.userDataProfileImportExportService.registerProfileContentHandler(id, {
      name,
      description,
      extensionId,
      saveProfile: async (name2, content, token) => {
        const result = await this.proxy.$saveProfile(id, name2, content, token);
        return result ? revive(result) : null;
      },
      readProfile: async (uri, token) => {
        return this.proxy.$readProfile(id, uri, token);
      }
    }));
  }
  async $unregisterProfileContentHandler(id) {
    this.registeredHandlers.deleteAndDispose(id);
  }
};
MainThreadProfileContentHandlers = __decorate([
  extHostNamedCustomer(MainContext.MainThreadProfileContentHandlers),
  __param(1, IUserDataProfileImportExportService)
], MainThreadProfileContentHandlers);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadAiRelatedInformation.js
init_tslib_es6();
init_cancellation();
init_lifecycle();
init_extHost_protocol();
var MainThreadAiRelatedInformation = class MainThreadAiRelatedInformation2 extends Disposable {
  constructor(context, _aiRelatedInformationService) {
    super();
    this._aiRelatedInformationService = _aiRelatedInformationService;
    this._registrations = this._register(new DisposableMap());
    this._proxy = context.getProxy(ExtHostContext.ExtHostAiRelatedInformation);
  }
  $getAiRelatedInformation(query, types) {
    return this._aiRelatedInformationService.getRelatedInformation(query, types, CancellationToken.None);
  }
  $registerAiRelatedInformationProvider(handle, type) {
    const provider = {
      provideAiRelatedInformation: (query, token) => {
        return this._proxy.$provideAiRelatedInformation(handle, query, token);
      }
    };
    this._registrations.set(handle, this._aiRelatedInformationService.registerAiRelatedInformationProvider(type, provider));
  }
  $unregisterAiRelatedInformationProvider(handle) {
    this._registrations.deleteAndDispose(handle);
  }
};
MainThreadAiRelatedInformation = __decorate([
  extHostNamedCustomer(MainContext.MainThreadAiRelatedInformation),
  __param(1, IAiRelatedInformationService)
], MainThreadAiRelatedInformation);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadAiEmbeddingVector.js
init_tslib_es6();
init_lifecycle();
init_extHost_protocol();
var MainThreadAiEmbeddingVector = class MainThreadAiEmbeddingVector2 extends Disposable {
  constructor(context, _AiEmbeddingVectorService) {
    super();
    this._AiEmbeddingVectorService = _AiEmbeddingVectorService;
    this._registrations = this._register(new DisposableMap());
    this._proxy = context.getProxy(ExtHostContext.ExtHostAiEmbeddingVector);
  }
  $registerAiEmbeddingVectorProvider(model, handle) {
    const provider = {
      provideAiEmbeddingVector: (strings, token) => {
        return this._proxy.$provideAiEmbeddingVector(handle, strings, token);
      }
    };
    this._registrations.set(handle, this._AiEmbeddingVectorService.registerAiEmbeddingVectorProvider(model, provider));
  }
  $unregisterAiEmbeddingVectorProvider(handle) {
    this._registrations.deleteAndDispose(handle);
  }
};
MainThreadAiEmbeddingVector = __decorate([
  extHostNamedCustomer(MainContext.MainThreadAiEmbeddingVector),
  __param(1, IAiEmbeddingVectorService)
], MainThreadAiEmbeddingVector);

// node_modules/vscode/vscode/src/vs/workbench/api/browser/mainThreadIssueReporter.js
init_tslib_es6();
init_lifecycle();
init_uri();
init_extHost_protocol();
var MainThreadIssueReporter = class MainThreadIssueReporter2 extends Disposable {
  constructor(context, _issueService) {
    super();
    this._issueService = _issueService;
    this._registrations = this._register(new DisposableMap());
    this._proxy = context.getProxy(ExtHostContext.ExtHostIssueReporter);
  }
  $registerIssueUriRequestHandler(extensionId) {
    const handler = {
      provideIssueUrl: async (token) => {
        const parts = await this._proxy.$getIssueReporterUri(extensionId, token);
        return URI.from(parts);
      }
    };
    this._registrations.set(extensionId, this._issueService.registerIssueUriRequestHandler(extensionId, handler));
  }
  $unregisterIssueUriRequestHandler(extensionId) {
    this._registrations.deleteAndDispose(extensionId);
  }
};
MainThreadIssueReporter = __decorate([
  extHostNamedCustomer(MainContext.MainThreadIssueReporter),
  __param(1, IWorkbenchIssueService)
], MainThreadIssueReporter);

// node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.common.services.js
init_extensions2();
init_log();
registerSingleton(IExtHostLocalizationService, ExtHostLocalizationService, 1);
registerSingleton(ILoggerService, ExtHostLoggerService, 1);
registerSingleton(IExtHostApiDeprecationService, ExtHostApiDeprecationService, 1);
registerSingleton(IExtHostCommands, ExtHostCommands, 0);
registerSingleton(IExtHostConfiguration, ExtHostConfiguration, 0);
registerSingleton(IExtHostConsumerFileSystem, ExtHostConsumerFileSystem, 0);
registerSingleton(IExtHostDebugService, WorkerExtHostDebugService, 0);
registerSingleton(IExtHostDecorations, ExtHostDecorations, 0);
registerSingleton(IExtHostDocumentsAndEditors, ExtHostDocumentsAndEditors, 0);
registerSingleton(IExtHostManagedSockets, ExtHostManagedSockets, 0);
registerSingleton(IExtHostFileSystemInfo, ExtHostFileSystemInfo, 0);
registerSingleton(IExtHostOutputService, ExtHostOutputService, 1);
registerSingleton(IExtHostSearch, ExtHostSearch, 0);
registerSingleton(IExtHostStorage, ExtHostStorage, 0);
registerSingleton(IExtHostTask, WorkerExtHostTask, 0);
registerSingleton(IExtHostTerminalService, WorkerExtHostTerminalService, 0);
registerSingleton(IExtHostTunnelService, ExtHostTunnelService, 0);
registerSingleton(IExtHostWindow, ExtHostWindow, 0);
registerSingleton(IExtHostWorkspace, ExtHostWorkspace, 0);
registerSingleton(IExtHostSecretState, ExtHostSecretState, 0);
registerSingleton(IExtHostTelemetry, ExtHostTelemetry, 0);
registerSingleton(IExtHostEditorTabs, ExtHostEditorTabs, 0);
registerSingleton(IExtHostVariableResolverProvider, ExtHostVariableResolverProviderService, 0);

// node_modules/vscode/service-override/extensions.js
function createMessagePassingProtocolPair() {
  const emitterA = new BufferedEmitter();
  const emitterB = new BufferedEmitter();
  class SimpleMessagePassingProtocol {
    constructor(emitterIn, emitterOut) {
      this.emitterIn = emitterIn;
      this.emitterOut = emitterOut;
      this.onMessage = this.emitterIn.event;
    }
    send(buffer) {
      this.emitterOut.fire(buffer);
    }
  }
  return [new SimpleMessagePassingProtocol(emitterA, emitterB), new SimpleMessagePassingProtocol(emitterB, emitterA)];
}
var LocalExtHostExtensionService = class extends ExtHostExtensionService {
  constructor() {
    super(...arguments);
    this._extApiImpl = new ExtensionIdentifierMap();
  }
  async getApi(extensionId) {
    const [myRegistry, configProvider] = await Promise.all([
      this.getExtensionRegistry(),
      this._extHostConfiguration.getConfigProvider()
    ]);
    const extensionRegistry = { mine: myRegistry, all: this._globalRegistry };
    const ext = extensionId != null ? myRegistry.getExtensionDescription(extensionId) : void 0;
    if (ext != null) {
      let apiImpl = this._extApiImpl.get(ext.identifier);
      if (apiImpl == null) {
        apiImpl = this._apiFactory(ext, extensionRegistry, configProvider);
        this._extApiImpl.set(ext.identifier, apiImpl);
      }
      return apiImpl;
    }
    if (this._defaultApiImpl == null) {
      this._defaultApiImpl = this._apiFactory(nullExtensionDescription, extensionRegistry, configProvider);
    }
    return this._defaultApiImpl;
  }
};
registerSingleton(IExtHostExtensionService, LocalExtHostExtensionService, 0);
registerSingleton(IExtensionStoragePaths, ExtensionStoragePaths, 0);
var hostUtil = new class {
  constructor() {
    this.pid = void 0;
    this.exit = unsupported;
  }
  async exists(_path) {
    return true;
  }
  async realpath(path) {
    return path;
  }
}();
var localExtHostDeferred = new DeferredPromise();
var localExtHostPromise = localExtHostDeferred.p;
var LocalExtensionHost = class LocalExtensionHost2 {
  constructor(runningLocation, startup, _initDataProvider, _telemetryService, _contextService, _labelService, _logService, _loggerService, _environmentService, _productService, _userDataProfilesService) {
    this.runningLocation = runningLocation;
    this.startup = startup;
    this._initDataProvider = _initDataProvider;
    this._telemetryService = _telemetryService;
    this._contextService = _contextService;
    this._labelService = _labelService;
    this._logService = _logService;
    this._loggerService = _loggerService;
    this._environmentService = _environmentService;
    this._productService = _productService;
    this._userDataProfilesService = _userDataProfilesService;
    this.remoteAuthority = null;
    this.extensions = new ExtensionHostExtensions();
    this.onExit = Event.None;
    this._protocolPromise = null;
    this._extensionHostLogsLocation = joinPath(this._environmentService.extHostLogsPath, "local");
  }
  async start() {
    if (this._protocolPromise == null) {
      this._protocolPromise = this._start();
    }
    return this._protocolPromise;
  }
  async _start() {
    const [mainThreadMessagePassingProtocol, extHostMessagePassingProtocol] = createMessagePassingProtocolPair();
    const initData = await this._createExtHostInitData();
    const hostMain = new ExtensionHostMain(extHostMessagePassingProtocol, initData, hostUtil, null);
    await localExtHostDeferred.complete(hostMain.getExtHostExtensionService());
    return mainThreadMessagePassingProtocol;
  }
  async _createExtHostInitData() {
    var _a30;
    const initData = await this._initDataProvider.getInitData();
    const workspace = this._contextService.getWorkspace();
    const deltaExtensions = this.extensions.set(initData.allExtensions, initData.myExtensions);
    const nlsBaseUrl = (_a30 = this._productService.extensionsGallery) == null ? void 0 : _a30.nlsBaseUrl;
    let nlsUrlWithDetails;
    if (nlsBaseUrl != null && this._productService.commit != null && !Language.isDefaultVariant()) {
      nlsUrlWithDetails = URI.joinPath(URI.parse(nlsBaseUrl), this._productService.commit, this._productService.version, Language.value());
    }
    return {
      commit: this._productService.commit,
      version: this._productService.version,
      quality: this._productService.quality,
      parentPid: 0,
      environment: {
        isExtensionDevelopmentDebug: this._environmentService.debugRenderer,
        appName: this._productService.nameLong,
        appHost: this._productService.embedderIdentifier ?? (isWeb ? "web" : "desktop"),
        appUriScheme: this._productService.urlProtocol,
        appLanguage: language,
        extensionTelemetryLogResource: this._environmentService.extHostTelemetryLogFile,
        isExtensionTelemetryLoggingOnly: isLoggingOnly(this._productService, this._environmentService),
        extensionDevelopmentLocationURI: this._environmentService.extensionDevelopmentLocationURI,
        extensionTestsLocationURI: this._environmentService.extensionTestsLocationURI,
        globalStorageHome: this._userDataProfilesService.defaultProfile.globalStorageHome,
        workspaceStorageHome: this._environmentService.workspaceStorageHome,
        extensionLogLevel: this._environmentService.extensionLogLevel
      },
      workspace: this._contextService.getWorkbenchState() === 1 ? void 0 : {
        configuration: workspace.configuration ?? void 0,
        id: workspace.id,
        name: this._labelService.getWorkspaceLabel(workspace),
        transient: workspace.transient
      },
      consoleForward: {
        includeStack: false,
        logNative: this._environmentService.debugRenderer
      },
      allExtensions: deltaExtensions.toAdd,
      activationEvents: deltaExtensions.addActivationEvents,
      myExtensions: deltaExtensions.myToAdd,
      nlsBaseUrl: nlsUrlWithDetails,
      telemetryInfo: {
        sessionId: this._telemetryService.sessionId,
        machineId: this._telemetryService.machineId,
        firstSessionDate: this._telemetryService.firstSessionDate,
        msftInternal: this._telemetryService.msftInternal
      },
      logLevel: this._logService.getLevel(),
      loggers: [...this._loggerService.getRegisteredLoggers()],
      logsLocation: this._extensionHostLogsLocation,
      autoStart: this.startup === 1,
      remote: {
        authority: this._environmentService.remoteAuthority,
        connectionData: null,
        isRemote: false
      },
      uiKind: isWeb ? UIKind.Web : UIKind.Desktop
    };
  }
  getInspectPort() {
    return void 0;
  }
  enableInspectPort() {
    return Promise.resolve(false);
  }
  dispose() {
  }
};
LocalExtensionHost = __decorate([
  __param(3, ITelemetryService),
  __param(4, IWorkspaceContextService),
  __param(5, ILabelService),
  __param(6, ILogService),
  __param(7, ILoggerService),
  __param(8, IBrowserWorkbenchEnvironmentService),
  __param(9, IProductService),
  __param(10, IUserDataProfilesService)
], LocalExtensionHost);
var EsmWebWorkerExtensionHost = class EsmWebWorkerExtensionHost2 extends WebWorkerExtensionHost {
  constructor(workerConfig, runningLocation, startup, _initDataProvider, _telemetryService, _contextService, _labelService, _logService, _loggerService, _environmentService, _userDataProfilesService, _productService, _layoutService, _storageService) {
    super(runningLocation, startup, _initDataProvider, _telemetryService, _contextService, _labelService, _logService, _loggerService, _environmentService, _userDataProfilesService, _productService, _layoutService, _storageService);
    this.workerConfig = workerConfig;
  }
  async _getWebWorkerExtensionHostIframeSrc() {
    const url = new URL(await super._getWebWorkerExtensionHostIframeSrc(), window.location.href);
    url.searchParams.set("vscodeExtHostWorkerSrc", this.workerConfig.url);
    if (this.workerConfig.options != null) {
      url.searchParams.set("vscodeExtHostWorkerOptions", JSON.stringify(this.workerConfig.options));
    }
    url.searchParams.set("parentOrigin", window.origin);
    return url.toString();
  }
};
EsmWebWorkerExtensionHost = __decorate([
  __param(4, ITelemetryService),
  __param(5, IWorkspaceContextService),
  __param(6, ILabelService),
  __param(7, ILogService),
  __param(8, ILoggerService),
  __param(9, IBrowserWorkbenchEnvironmentService),
  __param(10, IUserDataProfilesService),
  __param(11, IProductService),
  __param(12, ILayoutService),
  __param(13, IStorageService)
], EsmWebWorkerExtensionHost);
var LocalBrowserExtensionHostFactory = class LocalBrowserExtensionHostFactory2 extends BrowserExtensionHostFactory {
  constructor(workerConfig, _extensionsProposedApi, _scanWebExtensions, _getExtensions, _instantiationService, _remoteAgentService, _remoteAuthorityResolverService, _extensionEnablementService) {
    super(_extensionsProposedApi, _scanWebExtensions, _getExtensions, _instantiationService, _remoteAgentService, _remoteAuthorityResolverService, _extensionEnablementService);
    this.workerConfig = workerConfig;
  }
  createExtensionHost(runningLocations, runningLocation, isInitialStart) {
    switch (runningLocation.kind) {
      case 1: {
        return this._instantiationService.createInstance(LocalExtensionHost, runningLocation, 1, this._createLocalExtensionHostDataProvider(runningLocations, runningLocation, isInitialStart));
      }
      case 2: {
        if (this.workerConfig == null) {
          return null;
        }
        const startup = isInitialStart ? 2 : 1;
        return this._instantiationService.createInstance(EsmWebWorkerExtensionHost, this.workerConfig, runningLocation, startup, this._createLocalExtensionHostDataProvider(runningLocations, runningLocation, isInitialStart));
      }
      case 3: {
        return super.createExtensionHost(runningLocations, runningLocation, isInitialStart);
      }
    }
  }
};
LocalBrowserExtensionHostFactory = __decorate([
  __param(4, IInstantiationService),
  __param(5, IRemoteAgentService),
  __param(6, IRemoteAuthorityResolverService),
  __param(7, IWorkbenchExtensionEnablementService)
], LocalBrowserExtensionHostFactory);
var LocalBrowserExtensionHostKindPicker = class LocalBrowserExtensionHostKindPicker2 extends BrowserExtensionHostKindPicker {
  constructor(allowedExtHostKinds, _logService) {
    super(_logService);
    this.allowedExtHostKinds = allowedExtHostKinds;
    this.extensionHostKinds = /* @__PURE__ */ new Map();
  }
  pickExtensionHostKind(extensionId, extensionKinds, isInstalledLocally, isInstalledRemotely, preference) {
    const forcedKind = this.extensionHostKinds.get(extensionId.value);
    if (forcedKind != null) {
      return forcedKind;
    }
    const detectedKind = super.pickExtensionHostKind(extensionId, extensionKinds, isInstalledLocally, isInstalledRemotely, preference);
    if (detectedKind != null && !this.allowedExtHostKinds.includes(detectedKind)) {
      return this.allowedExtHostKinds[0] ?? null;
    }
    return detectedKind;
  }
  setForcedExtensionHostKind(id, kind) {
    this.extensionHostKinds.set(id, kind);
  }
  removeForcedExtensionHostKind(id) {
    this.extensionHostKinds.delete(id);
  }
};
LocalBrowserExtensionHostKindPicker = __decorate([
  __param(1, ILogService)
], LocalBrowserExtensionHostKindPicker);
var SimpleExtensionService = class SimpleExtensionService2 extends AbstractExtensionService {
  constructor(workerConfig, instantiationService, notificationService, browserEnvironmentService, telemetryService, extensionEnablementService, fileService, productService, extensionManagementService, contextService, configurationService, extensionManifestPropertiesService, logService, remoteAgentService, remoteExtensionsScannerService, lifecycleService, remoteAuthorityResolverService, userDataInitializationService, dialogService) {
    const extensionsProposedApi = instantiationService.createInstance(ExtensionsProposedApi);
    const extensionHostFactory = new LocalBrowserExtensionHostFactory(workerConfig, extensionsProposedApi, async () => [], () => this._getExtensions(), instantiationService, remoteAgentService, remoteAuthorityResolverService, extensionEnablementService);
    super(extensionsProposedApi, extensionHostFactory, new LocalBrowserExtensionHostKindPicker(workerConfig != null ? [2, 1, 3] : [1, 3], logService), instantiationService, notificationService, browserEnvironmentService, telemetryService, extensionEnablementService, fileService, productService, extensionManagementService, contextService, configurationService, extensionManifestPropertiesService, logService, remoteAgentService, remoteExtensionsScannerService, lifecycleService, remoteAuthorityResolverService, dialogService);
    void lifecycleService.when(2).then(async () => {
      await userDataInitializationService.initializeInstalledExtensions(instantiationService);
      return this._initialize();
    });
    this._initFetchFileSystem();
  }
  _initFetchFileSystem() {
    const provider = new FetchFileSystemProvider();
    this._register(this._fileService.registerProvider(Schemas.http, provider));
    this._register(this._fileService.registerProvider(Schemas.https, provider));
  }
  async deltaExtensions(toAdd, toRemove) {
    const extHostPicker = this._extensionHostKindPicker;
    for (const extension of toAdd) {
      if (extension.extHostKind != null) {
        extHostPicker.setForcedExtensionHostKind(extension.identifier.id, extension.extHostKind);
      }
    }
    for (const extension of toRemove) {
      extHostPicker.removeForcedExtensionHostKind(extension.identifier.id);
    }
    await this._handleDeltaExtensions(new DeltaExtensionsQueueItem(toAdd, toRemove));
  }
  async _resolveExtensions() {
    return new ResolvedExtensions([], [], false, false);
  }
  async _scanSingleExtension(extension) {
    return toExtensionDescription(extension);
  }
  _onExtensionHostExit() {
    this._doStopExtensionHosts();
  }
  _resolveAuthority(remoteAuthority) {
    return this._resolveAuthorityOnExtensionHosts(2, remoteAuthority);
  }
};
SimpleExtensionService = __decorate([
  __param(1, IInstantiationService),
  __param(2, INotificationService),
  __param(3, IBrowserWorkbenchEnvironmentService),
  __param(4, ITelemetryService),
  __param(5, IWorkbenchExtensionEnablementService),
  __param(6, IFileService),
  __param(7, IProductService),
  __param(8, IWorkbenchExtensionManagementService),
  __param(9, IWorkspaceContextService),
  __param(10, IConfigurationService),
  __param(11, IExtensionManifestPropertiesService),
  __param(12, ILogService),
  __param(13, IRemoteAgentService),
  __param(14, IRemoteExtensionsScannerService),
  __param(15, ILifecycleService),
  __param(16, IRemoteAuthorityResolverService),
  __param(17, IUserDataInitializationService),
  __param(18, IDialogService)
], SimpleExtensionService);
var iframeAlternateDomains;
registerAssets({
  "vs/workbench/services/extensions/worker/webWorkerExtensionHostIframe.html": () => changeUrlDomain(new URL("/home/jsimek/MUNI/diplomka/camel-learning-tool/vite-project/node_modules/vscode/assets/webWorkerExtensionHostIframe.html", import.meta.url).href, iframeAlternateDomains)
});
function getServiceOverride2(workerConfig, _iframeAlternateDomains) {
  if (_iframeAlternateDomains != null) {
    iframeAlternateDomains = _iframeAlternateDomains;
  }
  const _workerConfig = workerConfig != null ? {
    ...workerConfig,
    url: changeUrlDomain(workerConfig.url, iframeAlternateDomains)
  } : void 0;
  return {
    ...getServiceOverride(),
    [IExtensionService.toString()]: new SyncDescriptor(SimpleExtensionService, [_workerConfig], false),
    [IExtensionManifestPropertiesService.toString()]: new SyncDescriptor(ExtensionManifestPropertiesService, [], true)
  };
}
function getLocalExtHostExtensionService() {
  return localExtHostPromise;
}

// node_modules/vscode/service-override/layout.js
init_event();
init_codeEditorService();
init_dom();
init_dom();
init_descriptors();
init_platform();
init_arrays();
var LayoutService = class {
  constructor(container) {
    this.container = container;
    this.onDidChangeFullscreen = Event.None;
    this.onDidChangeZenMode = Event.None;
    this.onDidChangeWindowMaximized = Event.None;
    this.onDidChangeCenteredLayout = Event.None;
    this.onDidChangePanelPosition = Event.None;
    this.onDidChangePanelAlignment = Event.None;
    this.onDidChangeNotificationsVisibility = Event.None;
    this.openedDefaultEditors = false;
    this.whenRestored = Promise.resolve();
    this.parts = /* @__PURE__ */ new Map();
    this.hiddenParts = /* @__PURE__ */ new Set();
    this._onDidChangePartVisibility = new Emitter();
    this.onDidChangePartVisibility = this._onDidChangePartVisibility.event;
    this.offset = { top: 0, quickPickTop: 0 };
    this._onDidLayout = new Emitter();
    this.onDidLayout = this._onDidLayout.event;
    window.addEventListener("resize", () => this.layout());
    this.layout();
  }
  init(accessor) {
    this.editorGroupService = accessor.get(IEditorGroupsService);
    this.paneCompositeService = accessor.get(IPaneCompositePartService);
    this.statusBarService = accessor.get(IStatusbarService);
    this.viewDescriptorService = accessor.get(IViewDescriptorService);
  }
  focusPart(part) {
    switch (part) {
      case "workbench.parts.editor":
        this.editorGroupService.activeGroup.focus();
        break;
      case "workbench.parts.panel": {
        const activePanel = this.paneCompositeService.getActivePaneComposite(1);
        activePanel == null ? void 0 : activePanel.focus();
        break;
      }
      case "workbench.parts.sidebar": {
        const activeViewlet = this.paneCompositeService.getActivePaneComposite(0);
        activeViewlet == null ? void 0 : activeViewlet.focus();
        break;
      }
      case "workbench.parts.activitybar":
        this.getPart("workbench.parts.activitybar").focus();
        break;
      case "workbench.parts.statusbar":
        this.statusBarService.focus();
        break;
      default: {
        const container = this.getContainer(part);
        container == null ? void 0 : container.focus();
      }
    }
  }
  getDimension(part) {
    return this.getPart(part).dimension;
  }
  toggleMaximizedPanel() {
  }
  hasWindowBorder() {
    return false;
  }
  getWindowBorderWidth() {
    return 0;
  }
  getWindowBorderRadius() {
    return void 0;
  }
  toggleMenuBar() {
  }
  setPanelPosition() {
  }
  getPanelAlignment() {
    return "left";
  }
  setPanelAlignment() {
  }
  toggleZenMode() {
  }
  isEditorLayoutCentered() {
    return false;
  }
  centerEditorLayout() {
  }
  resizePart() {
  }
  isWindowMaximized() {
    return false;
  }
  updateWindowMaximizedState() {
  }
  getVisibleNeighborPart() {
    return void 0;
  }
  getMaximumEditorDimensions() {
    return new Dimension(Infinity, Infinity);
  }
  isPanelMaximized() {
    return false;
  }
  getPanelPosition() {
    return 2;
  }
  hasFocus(part) {
    const activeElement = document.activeElement;
    if (activeElement == null) {
      return false;
    }
    const container = this.getContainer(part);
    return !(container == null) && isAncestorUsingFlowTo(activeElement, container);
  }
  getContainer(part) {
    if (this.parts.get(part) == null) {
      return void 0;
    }
    return this.getPart(part).getContainer();
  }
  getPart(key) {
    const part = this.parts.get(key);
    if (part == null) {
      throw new Error(`Unknown part ${key}`);
    }
    return part;
  }
  hasViews(id) {
    const viewContainer = this.viewDescriptorService.getViewContainerById(id);
    if (viewContainer == null) {
      return false;
    }
    const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
    if (viewContainerModel == null) {
      return false;
    }
    return viewContainerModel.activeViewDescriptors.length >= 1;
  }
  setPartHidden(hidden, part) {
    var _a30;
    if (hidden) {
      this.hiddenParts.add(part);
    } else {
      this.hiddenParts.delete(part);
    }
    this._onDidChangePartVisibility.fire();
    const location2 = {
      ["workbench.parts.sidebar"]: 0,
      ["workbench.parts.auxiliarybar"]: 2,
      ["workbench.parts.panel"]: 1
    }[part];
    if (location2 != null) {
      const paneComposite = this.paneCompositeService.getActivePaneComposite(location2);
      if (paneComposite != null && hidden) {
        this.paneCompositeService.hideActivePaneComposite(location2);
      } else if (paneComposite == null && !hidden) {
        let panelToOpen = this.paneCompositeService.getLastActivePaneCompositeId(location2);
        if (panelToOpen == null || !this.hasViews(panelToOpen)) {
          panelToOpen = (_a30 = this.viewDescriptorService.getViewContainersByLocation(1).find((viewContainer) => this.hasViews(viewContainer.id))) == null ? void 0 : _a30.id;
        }
        if (panelToOpen != null) {
          void this.paneCompositeService.openPaneComposite(panelToOpen, 1, true);
        }
      }
      if (this.paneCompositeService.getPartByLocation != null) {
        this.paneCompositeService.getPartByLocation(location2).setVisible(!hidden);
      }
    }
  }
  isVisible(part) {
    return !this.hiddenParts.has(part);
  }
  getSideBarPosition() {
    return 0;
  }
  registerPart(part) {
    this.parts.set(part.getId(), part);
  }
  isRestored() {
    return true;
  }
  get dimension() {
    return this._dimension;
  }
  layout() {
    this._dimension = getClientArea(window.document.body);
    this._onDidLayout.fire(this._dimension);
  }
  get hasContainer() {
    return true;
  }
  focus() {
    var _a30;
    (_a30 = StandaloneServices.get(ICodeEditorService).getFocusedCodeEditor()) == null ? void 0 : _a30.focus();
  }
};
onRenderWorkbench((accessor) => {
  const layoutService = accessor.get(ILayoutService);
  if (layoutService instanceof LayoutService) {
    layoutService.init(accessor);
  }
});
function getServiceOverride3(container = document.body) {
  const platformClass = isWindows ? "windows" : isLinux ? "linux" : "mac";
  const workbenchClasses = coalesce([
    "monaco-workbench",
    platformClass,
    "web",
    isChrome ? "chromium" : isFirefox ? "firefox" : isSafari ? "safari" : void 0
  ]);
  container.classList.add(...workbenchClasses);
  document.body.classList.add(platformClass);
  document.body.classList.add("web");
  return {
    [ILayoutService.toString()]: new SyncDescriptor(LayoutService, [container], true),
    [IWorkbenchLayoutService.toString()]: new SyncDescriptor(LayoutService, [container], true)
  };
}

// node_modules/vscode/service-override/environment.js
init_tslib_es6();
init_descriptors();
init_uri();
init_environment();
var InjectedBrowserWorkbenchEnvironmentService = class InjectedBrowserWorkbenchEnvironmentService2 extends BrowserWorkbenchEnvironmentService {
  constructor(options, productService) {
    super("default", URI.from({ scheme: "logs", path: "/" }), options, productService);
  }
};
InjectedBrowserWorkbenchEnvironmentService = __decorate([
  __param(1, IProductService)
], InjectedBrowserWorkbenchEnvironmentService);
function getServiceOverride4(options = {}) {
  return {
    [IEnvironmentService.toString()]: new SyncDescriptor(InjectedBrowserWorkbenchEnvironmentService, [], true),
    [IBrowserWorkbenchEnvironmentService.toString()]: new SyncDescriptor(InjectedBrowserWorkbenchEnvironmentService, [options], true)
  };
}

// node_modules/vscode/service-override/quickaccess.js
init_tslib_es6();
init_descriptors();
init_cancellation();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/services/quickinput/browser/quickInputService.js
init_tslib_es6();
init_instantiation();
init_themeService();
init_configuration();
init_contextkey();

// node_modules/vscode/vscode/src/vs/workbench/browser/quickaccess.js
init_nls();
init_contextkey();
var inQuickPickContextKeyValue = "inQuickOpen";
var InQuickPickContextKey = new RawContextKey(inQuickPickContextKeyValue, false, localize("inQuickOpen", "Whether keyboard focus is inside the quick open control"));
var inQuickPickContext = ContextKeyExpr.has(inQuickPickContextKeyValue);
var defaultQuickAccessContextKeyValue = "inFilesPicker";
var defaultQuickAccessContext = ContextKeyExpr.and(inQuickPickContext, ContextKeyExpr.has(defaultQuickAccessContextKeyValue));
function getQuickNavigateHandler(id, next) {
  return (accessor) => {
    const keybindingService = accessor.get(IKeybindingService);
    const quickInputService = accessor.get(IQuickInputService);
    const keys = keybindingService.lookupKeybindings(id);
    const quickNavigate = { keybindings: keys };
    quickInputService.navigate(!!next, quickNavigate);
  };
}

// node_modules/vscode/vscode/src/vs/workbench/services/quickinput/browser/quickInputService.js
var QuickInputService2 = class QuickInputService3 extends QuickInputService {
  constructor(configurationService, instantiationService, keybindingService, contextKeyService, themeService, layoutService, hoverService) {
    super(instantiationService, contextKeyService, themeService, layoutService);
    this.configurationService = configurationService;
    this.keybindingService = keybindingService;
    this.hoverService = hoverService;
    this.hoverDelegate = new QuickInputHoverDelegate(this.configurationService, this.hoverService);
    this.inQuickInputContext = InQuickPickContextKey.bindTo(this.contextKeyService);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.onShow(() => this.inQuickInputContext.set(true)));
    this._register(this.onHide(() => this.inQuickInputContext.set(false)));
  }
  createController() {
    return super.createController(this.layoutService, {
      ignoreFocusOut: () => !this.configurationService.getValue("workbench.quickOpen.closeOnFocusLost"),
      backKeybindingLabel: () => {
        var _a30;
        return ((_a30 = this.keybindingService.lookupKeybinding("workbench.action.quickInputBack")) == null ? void 0 : _a30.getLabel()) || void 0;
      },
      hoverDelegate: this.hoverDelegate
    });
  }
};
QuickInputService2 = __decorate([
  __param(0, IConfigurationService),
  __param(1, IInstantiationService),
  __param(2, IKeybindingService),
  __param(3, IContextKeyService),
  __param(4, IThemeService),
  __param(5, ILayoutService),
  __param(6, IHoverService)
], QuickInputService2);
var QuickInputHoverDelegate = class {
  get delay() {
    if (Date.now() - this.lastHoverHideTime < 200) {
      return 0;
    }
    return this.configurationService.getValue("workbench.hover.delay");
  }
  constructor(configurationService, hoverService) {
    this.configurationService = configurationService;
    this.hoverService = hoverService;
    this.lastHoverHideTime = 0;
    this.placement = "element";
  }
  showHover(options, focus) {
    return this.hoverService.showHover({
      ...options,
      showHoverHint: true,
      hideOnKeyDown: false,
      skipFadeInAnimation: true
    }, focus);
  }
  onDidHideHover() {
    this.lastHoverHideTime = Date.now();
  }
};

// node_modules/vscode/service-override/quickaccess.js
init_codeEditorService();

// node_modules/vscode/vscode/src/vs/workbench/contrib/quickaccess/browser/commandsQuickAccess.js
init_tslib_es6();
init_nls();

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js
init_errorMessage();
init_errors();
init_filters();
init_lifecycle();
init_map();
init_nls();
init_commands();
init_configuration();
init_instantiation();
init_telemetry();
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AbstractCommandsQuickAccessProvider_1;
var CommandsHistory_1;
var AbstractCommandsQuickAccessProvider = AbstractCommandsQuickAccessProvider_1 = class AbstractCommandsQuickAccessProvider2 extends PickerQuickAccessProvider {
  constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
    super(AbstractCommandsQuickAccessProvider_1.PREFIX, options);
    this.instantiationService = instantiationService;
    this.keybindingService = keybindingService;
    this.commandService = commandService;
    this.telemetryService = telemetryService;
    this.dialogService = dialogService;
    this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));
    this.options = options;
  }
  _getPicks(filter2, _disposables, token, runOptions) {
    var _a30, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
      const allCommandPicks = yield this.getCommandPicks(token);
      if (token.isCancellationRequested) {
        return [];
      }
      const filteredCommandPicks = [];
      for (const commandPick of allCommandPicks) {
        const labelHighlights = (_a30 = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter2, commandPick.label)) !== null && _a30 !== void 0 ? _a30 : void 0;
        const aliasHighlights = commandPick.commandAlias ? (_b = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter2, commandPick.commandAlias)) !== null && _b !== void 0 ? _b : void 0 : void 0;
        if (labelHighlights || aliasHighlights) {
          commandPick.highlights = {
            label: labelHighlights,
            detail: this.options.showAlias ? aliasHighlights : void 0
          };
          filteredCommandPicks.push(commandPick);
        } else if (filter2 === commandPick.commandId) {
          filteredCommandPicks.push(commandPick);
        }
      }
      const mapLabelToCommand = /* @__PURE__ */ new Map();
      for (const commandPick of filteredCommandPicks) {
        const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);
        if (existingCommandForLabel) {
          commandPick.description = commandPick.commandId;
          existingCommandForLabel.description = existingCommandForLabel.commandId;
        } else {
          mapLabelToCommand.set(commandPick.label, commandPick);
        }
      }
      filteredCommandPicks.sort((commandPickA, commandPickB) => {
        const commandACounter = this.commandsHistory.peek(commandPickA.commandId);
        const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);
        if (commandACounter && commandBCounter) {
          return commandACounter > commandBCounter ? -1 : 1;
        }
        if (commandACounter) {
          return -1;
        }
        if (commandBCounter) {
          return 1;
        }
        if (this.options.suggestedCommandIds) {
          const commandASuggestion = this.options.suggestedCommandIds.has(commandPickA.commandId);
          const commandBSuggestion = this.options.suggestedCommandIds.has(commandPickB.commandId);
          if (commandASuggestion && commandBSuggestion) {
            return 0;
          }
          if (commandASuggestion) {
            return -1;
          }
          if (commandBSuggestion) {
            return 1;
          }
        }
        return commandPickA.label.localeCompare(commandPickB.label);
      });
      const commandPicks = [];
      let addOtherSeparator = false;
      let addCommonlyUsedSeparator = !!this.options.suggestedCommandIds;
      for (let i = 0; i < filteredCommandPicks.length; i++) {
        const commandPick = filteredCommandPicks[i];
        if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {
          commandPicks.push({ type: "separator", label: localize("recentlyUsed", "recently used") });
          addOtherSeparator = true;
        }
        if (addCommonlyUsedSeparator && !this.commandsHistory.peek(commandPick.commandId) && ((_c = this.options.suggestedCommandIds) === null || _c === void 0 ? void 0 : _c.has(commandPick.commandId))) {
          commandPicks.push({ type: "separator", label: localize("commonlyUsed", "commonly used") });
          addOtherSeparator = true;
          addCommonlyUsedSeparator = false;
        }
        if (addOtherSeparator && !this.commandsHistory.peek(commandPick.commandId) && !((_d = this.options.suggestedCommandIds) === null || _d === void 0 ? void 0 : _d.has(commandPick.commandId))) {
          commandPicks.push({ type: "separator", label: localize("morecCommands", "other commands") });
          addOtherSeparator = false;
        }
        commandPicks.push(this.toCommandPick(commandPick, runOptions));
      }
      if (!this.hasAdditionalCommandPicks(filter2, token)) {
        return commandPicks;
      }
      return {
        picks: commandPicks,
        additionalPicks: (() => __awaiter(this, void 0, void 0, function* () {
          const additionalCommandPicks = yield this.getAdditionalCommandPicks(allCommandPicks, filteredCommandPicks, filter2, token);
          if (token.isCancellationRequested) {
            return [];
          }
          return additionalCommandPicks.map((commandPick) => this.toCommandPick(commandPick, runOptions));
        }))()
      };
    });
  }
  toCommandPick(commandPick, runOptions) {
    if (commandPick.type === "separator") {
      return commandPick;
    }
    const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);
    const ariaLabel = keybinding ? localize("commandPickAriaLabelWithKeybinding", "{0}, {1}", commandPick.label, keybinding.getAriaLabel()) : commandPick.label;
    return Object.assign(Object.assign({}, commandPick), { ariaLabel, detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : void 0, keybinding, accept: () => __awaiter(this, void 0, void 0, function* () {
      var _a30, _b;
      this.commandsHistory.push(commandPick.commandId);
      this.telemetryService.publicLog2("workbenchActionExecuted", {
        id: commandPick.commandId,
        from: (_a30 = runOptions === null || runOptions === void 0 ? void 0 : runOptions.from) !== null && _a30 !== void 0 ? _a30 : "quick open"
      });
      try {
        ((_b = commandPick.args) === null || _b === void 0 ? void 0 : _b.length) ? yield this.commandService.executeCommand(commandPick.commandId, ...commandPick.args) : yield this.commandService.executeCommand(commandPick.commandId);
      } catch (error) {
        if (!isCancellationError(error)) {
          this.dialogService.error(localize("canNotRun", "Command '{0}' resulted in an error", commandPick.label), toErrorMessage(error));
        }
      }
    }) });
  }
};
AbstractCommandsQuickAccessProvider.PREFIX = ">";
AbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);
AbstractCommandsQuickAccessProvider = AbstractCommandsQuickAccessProvider_1 = __decorate2([
  __param2(1, IInstantiationService),
  __param2(2, IKeybindingService),
  __param2(3, ICommandService),
  __param2(4, ITelemetryService),
  __param2(5, IDialogService2)
], AbstractCommandsQuickAccessProvider);
var CommandsHistory = CommandsHistory_1 = class CommandsHistory2 extends Disposable {
  constructor(storageService, configurationService) {
    super();
    this.storageService = storageService;
    this.configurationService = configurationService;
    this.configuredCommandsHistoryLength = 0;
    this.updateConfiguration();
    this.load();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.updateConfiguration(e)));
  }
  updateConfiguration(e) {
    if (e && !e.affectsConfiguration("workbench.commandPalette.history")) {
      return;
    }
    this.configuredCommandsHistoryLength = CommandsHistory_1.getConfiguredCommandHistoryLength(this.configurationService);
    if (CommandsHistory_1.cache && CommandsHistory_1.cache.limit !== this.configuredCommandsHistoryLength) {
      CommandsHistory_1.cache.limit = this.configuredCommandsHistoryLength;
      CommandsHistory_1.saveState(this.storageService);
    }
  }
  load() {
    const raw = this.storageService.get(
      CommandsHistory_1.PREF_KEY_CACHE,
      0
      /* StorageScope.PROFILE */
    );
    let serializedCache;
    if (raw) {
      try {
        serializedCache = JSON.parse(raw);
      } catch (error) {
      }
    }
    const cache = CommandsHistory_1.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);
    if (serializedCache) {
      let entries;
      if (serializedCache.usesLRU) {
        entries = serializedCache.entries;
      } else {
        entries = serializedCache.entries.sort((a, b) => a.value - b.value);
      }
      entries.forEach((entry) => cache.set(entry.key, entry.value));
    }
    CommandsHistory_1.counter = this.storageService.getNumber(CommandsHistory_1.PREF_KEY_COUNTER, 0, CommandsHistory_1.counter);
  }
  push(commandId) {
    if (!CommandsHistory_1.cache) {
      return;
    }
    CommandsHistory_1.cache.set(commandId, CommandsHistory_1.counter++);
    CommandsHistory_1.saveState(this.storageService);
  }
  peek(commandId) {
    var _a30;
    return (_a30 = CommandsHistory_1.cache) === null || _a30 === void 0 ? void 0 : _a30.peek(commandId);
  }
  static saveState(storageService) {
    if (!CommandsHistory_1.cache) {
      return;
    }
    const serializedCache = { usesLRU: true, entries: [] };
    CommandsHistory_1.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));
    storageService.store(
      CommandsHistory_1.PREF_KEY_CACHE,
      JSON.stringify(serializedCache),
      0,
      0
      /* StorageTarget.USER */
    );
    storageService.store(
      CommandsHistory_1.PREF_KEY_COUNTER,
      CommandsHistory_1.counter,
      0,
      0
      /* StorageTarget.USER */
    );
  }
  static getConfiguredCommandHistoryLength(configurationService) {
    var _a30, _b;
    const config = configurationService.getValue();
    const configuredCommandHistoryLength = (_b = (_a30 = config.workbench) === null || _a30 === void 0 ? void 0 : _a30.commandPalette) === null || _b === void 0 ? void 0 : _b.history;
    if (typeof configuredCommandHistoryLength === "number") {
      return configuredCommandHistoryLength;
    }
    return CommandsHistory_1.DEFAULT_COMMANDS_HISTORY_LENGTH;
  }
};
CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
CommandsHistory.PREF_KEY_CACHE = "commandPalette.mru.cache";
CommandsHistory.PREF_KEY_COUNTER = "commandPalette.mru.counter";
CommandsHistory.counter = 1;
CommandsHistory = CommandsHistory_1 = __decorate2([
  __param2(0, IStorageService),
  __param2(1, IConfigurationService)
], CommandsHistory);

// node_modules/vscode/vscode/src/vs/workbench/contrib/quickaccess/browser/commandsQuickAccess.js
init_actions2();
init_async();

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js
init_iconLabels();
var AbstractEditorCommandsQuickAccessProvider = class extends AbstractCommandsQuickAccessProvider {
  constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
    super(options, instantiationService, keybindingService, commandService, telemetryService, dialogService);
  }
  getCodeEditorCommandPicks() {
    const activeTextEditorControl = this.activeTextEditorControl;
    if (!activeTextEditorControl) {
      return [];
    }
    const editorCommandPicks = [];
    for (const editorAction of activeTextEditorControl.getSupportedActions()) {
      editorCommandPicks.push({
        commandId: editorAction.id,
        commandAlias: editorAction.alias,
        label: stripIcons(editorAction.label) || editorAction.id
      });
    }
    return editorCommandPicks;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/quickaccess/browser/commandsQuickAccess.js
init_platform();
init_instantiation();
init_commands();
init_telemetry();
init_configuration();
init_codicons();
init_themables();
init_iconLabels();
init_browser();

// node_modules/vscode/vscode/src/vs/workbench/contrib/chat/browser/actions/chatQuickInputActions.js
var ASK_QUICK_QUESTION_ACTION_ID = "workbench.action.quickchat.toggle";

// node_modules/vscode/vscode/src/vs/workbench/contrib/quickaccess/browser/commandsQuickAccess.js
var CommandsQuickAccessProvider_1;
var _a27;
var CommandsQuickAccessProvider = (_a27 = class extends AbstractEditorCommandsQuickAccessProvider {
  get activeTextEditorControl() {
    return this.editorService.activeTextEditorControl;
  }
  get defaultFilterValue() {
    if (this.configuration.preserveInput) {
      return DefaultQuickAccessFilterValue.LAST;
    }
    return void 0;
  }
  constructor(editorService, menuService, extensionService, instantiationService, keybindingService, commandService, telemetryService, dialogService, configurationService, editorGroupService, preferencesService, productService, aiRelatedInformationService, chatService) {
    super({
      showAlias: !Language.isDefaultVariant(),
      noResultsPick: () => ({
        label: localize("noCommandResults", "No matching commands"),
        commandId: ""
      })
    }, instantiationService, keybindingService, commandService, telemetryService, dialogService);
    this.editorService = editorService;
    this.menuService = menuService;
    this.extensionService = extensionService;
    this.configurationService = configurationService;
    this.editorGroupService = editorGroupService;
    this.preferencesService = preferencesService;
    this.productService = productService;
    this.aiRelatedInformationService = aiRelatedInformationService;
    this.chatService = chatService;
    this.extensionRegistrationRace = raceTimeout(this.extensionService.whenInstalledExtensionsRegistered(), 800);
    this.useAiRelatedInfo = false;
    this._register(configurationService.onDidChangeConfiguration((e) => this.updateOptions(e)));
    this.updateOptions();
  }
  get configuration() {
    const commandPaletteConfig = this.configurationService.getValue().workbench.commandPalette;
    return {
      preserveInput: commandPaletteConfig.preserveInput,
      experimental: commandPaletteConfig.experimental
    };
  }
  updateOptions(e) {
    var _a30;
    if (e && !e.affectsConfiguration("workbench.commandPalette.experimental")) {
      return;
    }
    const config = this.configuration;
    const suggestedCommandIds = config.experimental.suggestCommands && ((_a30 = this.productService.commandPaletteSuggestedCommandIds) == null ? void 0 : _a30.length) ? new Set(this.productService.commandPaletteSuggestedCommandIds) : void 0;
    this.options.suggestedCommandIds = suggestedCommandIds;
    this.useAiRelatedInfo = config.experimental.enableNaturalLanguageSearch;
  }
  async getCommandPicks(token) {
    await this.extensionRegistrationRace;
    if (token.isCancellationRequested) {
      return [];
    }
    return [
      ...this.getCodeEditorCommandPicks(),
      ...this.getGlobalCommandPicks()
    ].map((picks) => ({
      ...picks,
      buttons: [{
        iconClass: ThemeIcon.asClassName(Codicon.gear),
        tooltip: localize("configure keybinding", "Configure Keybinding")
      }],
      trigger: () => {
        this.preferencesService.openGlobalKeybindingSettings(false, { query: `@command:${picks.commandId}` });
        return TriggerAction.CLOSE_PICKER;
      }
    }));
  }
  hasAdditionalCommandPicks(filter2, token) {
    if (!this.useAiRelatedInfo || token.isCancellationRequested || filter2 === "" || !this.aiRelatedInformationService.isEnabled()) {
      return false;
    }
    return true;
  }
  async getAdditionalCommandPicks(allPicks, picksSoFar, filter2, token) {
    if (!this.hasAdditionalCommandPicks(filter2, token)) {
      return [];
    }
    let additionalPicks;
    try {
      await timeout(CommandsQuickAccessProvider_1.AI_RELATED_INFORMATION_DEBOUNCE, token);
      additionalPicks = await this.getRelatedInformationPicks(allPicks, picksSoFar, filter2, token);
    } catch (e) {
      return [];
    }
    if (additionalPicks.length) {
      additionalPicks.unshift({
        type: "separator",
        label: localize("similarCommands", "similar commands")
      });
    }
    if (picksSoFar.length || additionalPicks.length) {
      additionalPicks.push({
        type: "separator"
      });
    }
    const info = this.chatService.getProviderInfos()[0];
    if (info) {
      additionalPicks.push({
        label: localize("askXInChat", "Ask {0}: {1}", info.displayName, filter2),
        commandId: ASK_QUICK_QUESTION_ACTION_ID,
        args: [filter2]
      });
    }
    return additionalPicks;
  }
  async getRelatedInformationPicks(allPicks, picksSoFar, filter2, token) {
    const relatedInformation = await this.aiRelatedInformationService.getRelatedInformation(filter2, [RelatedInformationType2.CommandInformation], token);
    relatedInformation.sort((a, b) => b.weight - a.weight);
    const setOfPicksSoFar = new Set(picksSoFar.map((p) => p.commandId));
    const additionalPicks = new Array();
    for (const info of relatedInformation) {
      if (info.weight < CommandsQuickAccessProvider_1.AI_RELATED_INFORMATION_THRESHOLD || additionalPicks.length === CommandsQuickAccessProvider_1.AI_RELATED_INFORMATION_MAX_PICKS) {
        break;
      }
      const pick = allPicks.find((p) => p.commandId === info.command && !setOfPicksSoFar.has(p.commandId));
      if (pick) {
        additionalPicks.push(pick);
      }
    }
    return additionalPicks;
  }
  getGlobalCommandPicks() {
    var _a30, _b;
    const globalCommandPicks = [];
    const scopedContextKeyService = ((_a30 = this.editorService.activeEditorPane) == null ? void 0 : _a30.scopedContextKeyService) || this.editorGroupService.activeGroup.scopedContextKeyService;
    const globalCommandsMenu = this.menuService.createMenu(MenuId.CommandPalette, scopedContextKeyService);
    const globalCommandsMenuActions = globalCommandsMenu.getActions().reduce((r, [, actions]) => [...r, ...actions], []).filter((action) => action instanceof MenuItemAction && action.enabled);
    for (const action of globalCommandsMenuActions) {
      let label = (typeof action.item.title === "string" ? action.item.title : action.item.title.value) || action.item.id;
      const category = typeof action.item.category === "string" ? action.item.category : (_b = action.item.category) == null ? void 0 : _b.value;
      if (category) {
        label = localize("commandWithCategory", "{0}: {1}", category, label);
      }
      const aliasLabel = typeof action.item.title !== "string" ? action.item.title.original : void 0;
      const aliasCategory = category && action.item.category && typeof action.item.category !== "string" ? action.item.category.original : void 0;
      const commandAlias = aliasLabel && category ? aliasCategory ? `${aliasCategory}: ${aliasLabel}` : `${category}: ${aliasLabel}` : aliasLabel;
      globalCommandPicks.push({
        commandId: action.item.id,
        commandAlias,
        label: stripIcons(label)
      });
    }
    globalCommandsMenu.dispose();
    return globalCommandPicks;
  }
}, CommandsQuickAccessProvider_1 = _a27, _a27.AI_RELATED_INFORMATION_MAX_PICKS = 3, _a27.AI_RELATED_INFORMATION_THRESHOLD = 0.8, _a27.AI_RELATED_INFORMATION_DEBOUNCE = 200, _a27);
CommandsQuickAccessProvider = CommandsQuickAccessProvider_1 = __decorate([
  __param(0, IEditorService),
  __param(1, IMenuService),
  __param(2, IExtensionService),
  __param(3, IInstantiationService),
  __param(4, IKeybindingService),
  __param(5, ICommandService),
  __param(6, ITelemetryService),
  __param(7, IDialogService),
  __param(8, IConfigurationService),
  __param(9, IEditorGroupsService),
  __param(10, IPreferencesService),
  __param(11, IProductService),
  __param(12, IAiRelatedInformationService),
  __param(13, IChatService)
], CommandsQuickAccessProvider);
var _ShowAllCommandsAction = class _ShowAllCommandsAction extends Action2 {
  constructor() {
    super({
      id: _ShowAllCommandsAction.ID,
      title: { value: localize("showTriggerActions", "Show All Commands"), original: "Show All Commands" },
      keybinding: {
        weight: 200,
        when: void 0,
        primary: !isFirefox2 ? 2048 | 1024 | 46 : void 0,
        secondary: [59]
      },
      f1: true
    });
  }
  async run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(CommandsQuickAccessProvider.PREFIX);
  }
};
_ShowAllCommandsAction.ID = "workbench.action.showCommands";
var ShowAllCommandsAction = _ShowAllCommandsAction;
var ClearCommandHistoryAction = class extends Action2 {
  constructor() {
    super({
      id: "workbench.action.clearCommandHistory",
      title: { value: localize("clearCommandHistory", "Clear Command History"), original: "Clear Command History" },
      f1: true
    });
  }
  async run(accessor) {
    const configurationService = accessor.get(IConfigurationService);
    const storageService = accessor.get(IStorageService);
    const dialogService = accessor.get(IDialogService);
    const commandHistoryLength = CommandsHistory.getConfiguredCommandHistoryLength(configurationService);
    if (commandHistoryLength > 0) {
      const { confirmed } = await dialogService.confirm({
        type: "warning",
        message: localize(
          "confirmClearMessage",
          "Do you want to clear the history of recently used commands?"
        ),
        detail: localize("confirmClearDetail", "This action is irreversible!"),
        primaryButton: localize({ key: "clearButtonLabel", comment: ["&& denotes a mnemonic"] }, "&&Clear")
      });
      if (!confirmed) {
        return;
      }
      CommandsHistory.clearHistory(configurationService, storageService);
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/quickaccess/gotoLineQuickAccess.js
init_tslib_es6();
init_nls();

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoLineQuickAccess.js
init_lifecycle();
init_editorBrowser();

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/editorNavigationQuickAccess.js
init_functional();
init_lifecycle();
init_editorBrowser();
init_model();
init_editorColorRegistry();
init_themeService();
init_aria();
var AbstractEditorNavigationQuickAccessProvider = class {
  constructor(options) {
    this.options = options;
    this.rangeHighlightDecorationId = void 0;
  }
  //#region Provider methods
  provide(picker, token) {
    var _a30;
    const disposables = new DisposableStore();
    picker.canAcceptInBackground = !!((_a30 = this.options) === null || _a30 === void 0 ? void 0 : _a30.canAcceptInBackground);
    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
    const pickerDisposable = disposables.add(new MutableDisposable());
    pickerDisposable.value = this.doProvide(picker, token);
    disposables.add(this.onDidActiveTextEditorControlChange(() => {
      pickerDisposable.value = void 0;
      pickerDisposable.value = this.doProvide(picker, token);
    }));
    return disposables;
  }
  doProvide(picker, token) {
    var _a30;
    const disposables = new DisposableStore();
    const editor = this.activeTextEditorControl;
    if (editor && this.canProvideWithTextEditor(editor)) {
      const context = { editor };
      const codeEditor = getCodeEditor(editor);
      if (codeEditor) {
        let lastKnownEditorViewState = (_a30 = editor.saveViewState()) !== null && _a30 !== void 0 ? _a30 : void 0;
        disposables.add(codeEditor.onDidChangeCursorPosition(() => {
          var _a31;
          lastKnownEditorViewState = (_a31 = editor.saveViewState()) !== null && _a31 !== void 0 ? _a31 : void 0;
        }));
        context.restoreViewState = () => {
          if (lastKnownEditorViewState && editor === this.activeTextEditorControl) {
            editor.restoreViewState(lastKnownEditorViewState);
          }
        };
        disposables.add(once(token.onCancellationRequested)(() => {
          var _a31;
          return (_a31 = context.restoreViewState) === null || _a31 === void 0 ? void 0 : _a31.call(context);
        }));
      }
      disposables.add(toDisposable(() => this.clearDecorations(editor)));
      disposables.add(this.provideWithTextEditor(context, picker, token));
    } else {
      disposables.add(this.provideWithoutTextEditor(picker, token));
    }
    return disposables;
  }
  /**
   * Subclasses to implement if they can operate on the text editor.
   */
  canProvideWithTextEditor(editor) {
    return true;
  }
  gotoLocation({ editor }, options) {
    editor.setSelection(options.range);
    editor.revealRangeInCenter(
      options.range,
      0
      /* ScrollType.Smooth */
    );
    if (!options.preserveFocus) {
      editor.focus();
    }
    const model = editor.getModel();
    if (model && "getLineContent" in model) {
      status(`${model.getLineContent(options.range.startLineNumber)}`);
    }
  }
  getModel(editor) {
    var _a30;
    return isDiffEditor(editor) ? (_a30 = editor.getModel()) === null || _a30 === void 0 ? void 0 : _a30.modified : editor.getModel();
  }
  addDecorations(editor, range) {
    editor.changeDecorations((changeAccessor) => {
      const deleteDecorations = [];
      if (this.rangeHighlightDecorationId) {
        deleteDecorations.push(this.rangeHighlightDecorationId.overviewRulerDecorationId);
        deleteDecorations.push(this.rangeHighlightDecorationId.rangeHighlightId);
        this.rangeHighlightDecorationId = void 0;
      }
      const newDecorations = [
        // highlight the entire line on the range
        {
          range,
          options: {
            description: "quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: true
          }
        },
        // also add overview ruler highlight
        {
          range,
          options: {
            description: "quick-access-range-highlight-overview",
            overviewRuler: {
              color: themeColorFromId(overviewRulerRangeHighlight),
              position: OverviewRulerLane.Full
            }
          }
        }
      ];
      const [rangeHighlightId, overviewRulerDecorationId] = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);
      this.rangeHighlightDecorationId = { rangeHighlightId, overviewRulerDecorationId };
    });
  }
  clearDecorations(editor) {
    const rangeHighlightDecorationId = this.rangeHighlightDecorationId;
    if (rangeHighlightDecorationId) {
      editor.changeDecorations((changeAccessor) => {
        changeAccessor.deltaDecorations([
          rangeHighlightDecorationId.overviewRulerDecorationId,
          rangeHighlightDecorationId.rangeHighlightId
        ], []);
      });
      this.rangeHighlightDecorationId = void 0;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoLineQuickAccess.js
init_nls();
var AbstractGotoLineQuickAccessProvider = class _AbstractGotoLineQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {
  constructor() {
    super({ canAcceptInBackground: true });
  }
  provideWithoutTextEditor(picker) {
    const label = localize("cannotRunGotoLine", "Open a text editor first to go to a line.");
    picker.items = [{ label }];
    picker.ariaLabel = label;
    return Disposable.None;
  }
  provideWithTextEditor(context, picker, token) {
    const editor = context.editor;
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (item) {
        if (!this.isValidLineNumber(editor, item.lineNumber)) {
          return;
        }
        this.gotoLocation(context, { range: this.toRange(item.lineNumber, item.column), keyMods: picker.keyMods, preserveFocus: event.inBackground });
        if (!event.inBackground) {
          picker.hide();
        }
      }
    }));
    const updatePickerAndEditor = () => {
      const position = this.parsePosition(editor, picker.value.trim().substr(_AbstractGotoLineQuickAccessProvider.PREFIX.length));
      const label = this.getPickLabel(editor, position.lineNumber, position.column);
      picker.items = [{
        lineNumber: position.lineNumber,
        column: position.column,
        label
      }];
      picker.ariaLabel = label;
      if (!this.isValidLineNumber(editor, position.lineNumber)) {
        this.clearDecorations(editor);
        return;
      }
      const range = this.toRange(position.lineNumber, position.column);
      editor.revealRangeInCenter(
        range,
        0
        /* ScrollType.Smooth */
      );
      this.addDecorations(editor, range);
    };
    updatePickerAndEditor();
    disposables.add(picker.onDidChangeValue(() => updatePickerAndEditor()));
    const codeEditor = getCodeEditor(editor);
    if (codeEditor) {
      const options = codeEditor.getOptions();
      const lineNumbers = options.get(
        66
        /* EditorOption.lineNumbers */
      );
      if (lineNumbers.renderType === 2) {
        codeEditor.updateOptions({ lineNumbers: "on" });
        disposables.add(toDisposable(() => codeEditor.updateOptions({ lineNumbers: "relative" })));
      }
    }
    return disposables;
  }
  toRange(lineNumber = 1, column = 1) {
    return {
      startLineNumber: lineNumber,
      startColumn: column,
      endLineNumber: lineNumber,
      endColumn: column
    };
  }
  parsePosition(editor, value) {
    const numbers = value.split(/,|:|#/).map((part) => parseInt(part, 10)).filter((part) => !isNaN(part));
    const endLine = this.lineCount(editor) + 1;
    return {
      lineNumber: numbers[0] > 0 ? numbers[0] : endLine + numbers[0],
      column: numbers[1]
    };
  }
  getPickLabel(editor, lineNumber, column) {
    if (this.isValidLineNumber(editor, lineNumber)) {
      if (this.isValidColumn(editor, lineNumber, column)) {
        return localize("gotoLineColumnLabel", "Go to line {0} and character {1}.", lineNumber, column);
      }
      return localize("gotoLineLabel", "Go to line {0}.", lineNumber);
    }
    const position = editor.getPosition() || { lineNumber: 1, column: 1 };
    const lineCount = this.lineCount(editor);
    if (lineCount > 1) {
      return localize("gotoLineLabelEmptyWithLimit", "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", position.lineNumber, position.column, lineCount);
    }
    return localize("gotoLineLabelEmpty", "Current Line: {0}, Character: {1}. Type a line number to navigate to.", position.lineNumber, position.column);
  }
  isValidLineNumber(editor, lineNumber) {
    if (!lineNumber || typeof lineNumber !== "number") {
      return false;
    }
    return lineNumber > 0 && lineNumber <= this.lineCount(editor);
  }
  isValidColumn(editor, lineNumber, column) {
    if (!column || typeof column !== "number") {
      return false;
    }
    const model = this.getModel(editor);
    if (!model) {
      return false;
    }
    const positionCandidate = { lineNumber, column };
    return model.validatePosition(positionCandidate).equals(positionCandidate);
  }
  lineCount(editor) {
    var _a30, _b;
    return (_b = (_a30 = this.getModel(editor)) === null || _a30 === void 0 ? void 0 : _a30.getLineCount()) !== null && _b !== void 0 ? _b : 0;
  }
};
AbstractGotoLineQuickAccessProvider.PREFIX = ":";

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/quickaccess/gotoLineQuickAccess.js
init_platform2();
init_configuration();
init_actions2();
var GotoLineQuickAccessProvider = class GotoLineQuickAccessProvider2 extends AbstractGotoLineQuickAccessProvider {
  constructor(editorService, editorGroupService, configurationService) {
    super();
    this.editorService = editorService;
    this.editorGroupService = editorGroupService;
    this.configurationService = configurationService;
    this.onDidActiveTextEditorControlChange = this.editorService.onDidActiveEditorChange;
  }
  get configuration() {
    var _a30;
    const editorConfig = (_a30 = this.configurationService.getValue().workbench) == null ? void 0 : _a30.editor;
    return {
      openEditorPinned: !(editorConfig == null ? void 0 : editorConfig.enablePreviewFromQuickOpen) || !(editorConfig == null ? void 0 : editorConfig.enablePreview)
    };
  }
  get activeTextEditorControl() {
    return this.editorService.activeTextEditorControl;
  }
  gotoLocation(context, options) {
    var _a30;
    if ((options.keyMods.alt || this.configuration.openEditorPinned && options.keyMods.ctrlCmd || options.forceSideBySide) && this.editorService.activeEditor) {
      (_a30 = context.restoreViewState) == null ? void 0 : _a30.call(context);
      const editorOptions = {
        selection: options.range,
        pinned: options.keyMods.ctrlCmd || this.configuration.openEditorPinned,
        preserveFocus: options.preserveFocus
      };
      this.editorGroupService.sideGroup.openEditor(this.editorService.activeEditor, editorOptions);
    } else {
      super.gotoLocation(context, options);
    }
  }
};
GotoLineQuickAccessProvider = __decorate([
  __param(0, IEditorService),
  __param(1, IEditorGroupsService),
  __param(2, IConfigurationService)
], GotoLineQuickAccessProvider);
var _GotoLineAction = class _GotoLineAction extends Action2 {
  constructor() {
    super({
      id: _GotoLineAction.ID,
      title: { value: localize("gotoLine", "Go to Line/Column..."), original: "Go to Line/Column..." },
      f1: true,
      keybinding: {
        weight: 200,
        when: null,
        primary: 2048 | 37,
        mac: { primary: 256 | 37 }
      }
    });
  }
  async run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(GotoLineQuickAccessProvider.PREFIX);
  }
};
_GotoLineAction.ID = "workbench.action.gotoLine";
var GotoLineAction = _GotoLineAction;
registerAction2(GotoLineAction);
Registry.as(Extensions6.Quickaccess).registerQuickAccessProvider({
  ctor: GotoLineQuickAccessProvider,
  prefix: AbstractGotoLineQuickAccessProvider.PREFIX,
  placeholder: localize(
    "gotoLineQuickAccessPlaceholder",
    "Type the line number and optional column to go to (e.g. 42:5 for line 42 and column 5)."
  ),
  helpEntries: [{ description: localize("gotoLineQuickAccess", "Go to Line/Column"), commandId: GotoLineAction.ID }]
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/quickaccess/gotoSymbolQuickAccess.js
init_tslib_es6();
init_nls();
init_platform2();

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js
init_async();
init_cancellation();
init_codicons();
init_themables();
init_lifecycle();
init_strings();
init_range();
init_languages();
init_outlineModel();
init_nls();
init_languageFeatures();
init_arrays();
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AbstractGotoSymbolQuickAccessProvider_1;
var AbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = class AbstractGotoSymbolQuickAccessProvider2 extends AbstractEditorNavigationQuickAccessProvider {
  constructor(_languageFeaturesService, _outlineModelService, options = /* @__PURE__ */ Object.create(null)) {
    super(options);
    this._languageFeaturesService = _languageFeaturesService;
    this._outlineModelService = _outlineModelService;
    this.options = options;
    this.options.canAcceptInBackground = true;
  }
  provideWithoutTextEditor(picker) {
    this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutEditor", "To go to a symbol, first open a text editor with symbol information."));
    return Disposable.None;
  }
  provideWithTextEditor(context, picker, token) {
    const editor = context.editor;
    const model = this.getModel(editor);
    if (!model) {
      return Disposable.None;
    }
    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
      return this.doProvideWithEditorSymbols(context, model, picker, token);
    }
    return this.doProvideWithoutEditorSymbols(context, model, picker, token);
  }
  doProvideWithoutEditorSymbols(context, model, picker, token) {
    const disposables = new DisposableStore();
    this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutSymbolProvider", "The active text editor does not provide symbol information."));
    (() => __awaiter2(this, void 0, void 0, function* () {
      const result = yield this.waitForLanguageSymbolRegistry(model, disposables);
      if (!result || token.isCancellationRequested) {
        return;
      }
      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));
    }))();
    return disposables;
  }
  provideLabelPick(picker, label) {
    picker.items = [{
      label,
      index: 0,
      kind: 14
      /* SymbolKind.String */
    }];
    picker.ariaLabel = label;
  }
  waitForLanguageSymbolRegistry(model, disposables) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
        return true;
      }
      const symbolProviderRegistryPromise = new DeferredPromise();
      const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {
        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
          symbolProviderListener.dispose();
          symbolProviderRegistryPromise.complete(true);
        }
      }));
      disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));
      return symbolProviderRegistryPromise.p;
    });
  }
  doProvideWithEditorSymbols(context, model, picker, token) {
    var _a30;
    const editor = context.editor;
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (item && item.range) {
        this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });
        if (!event.inBackground) {
          picker.hide();
        }
      }
    }));
    disposables.add(picker.onDidTriggerItemButton(({ item }) => {
      if (item && item.range) {
        this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });
        picker.hide();
      }
    }));
    const symbolsPromise = this.getDocumentSymbols(model, token);
    let picksCts = void 0;
    const updatePickerItems = (positionToEnclose) => __awaiter2(this, void 0, void 0, function* () {
      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
      picker.busy = false;
      picksCts = new CancellationTokenSource(token);
      picker.busy = true;
      try {
        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());
        const items = yield this.doGetSymbolPicks(symbolsPromise, query, void 0, picksCts.token);
        if (token.isCancellationRequested) {
          return;
        }
        if (items.length > 0) {
          picker.items = items;
          if (positionToEnclose && query.original.length === 0) {
            const candidate = findLast(items, (item) => Boolean(item.type !== "separator" && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));
            if (candidate) {
              picker.activeItems = [candidate];
            }
          }
        } else {
          if (query.original.length > 0) {
            this.provideLabelPick(picker, localize("noMatchingSymbolResults", "No matching editor symbols"));
          } else {
            this.provideLabelPick(picker, localize("noSymbolResults", "No editor symbols"));
          }
        }
      } finally {
        if (!token.isCancellationRequested) {
          picker.busy = false;
        }
      }
    });
    disposables.add(picker.onDidChangeValue(() => updatePickerItems(void 0)));
    updatePickerItems((_a30 = editor.getSelection()) === null || _a30 === void 0 ? void 0 : _a30.getPosition());
    disposables.add(picker.onDidChangeActive(() => {
      const [item] = picker.activeItems;
      if (item && item.range) {
        editor.revealRangeInCenter(
          item.range.selection,
          0
          /* ScrollType.Smooth */
        );
        this.addDecorations(editor, item.range.decoration);
      }
    }));
    return disposables;
  }
  doGetSymbolPicks(symbolsPromise, query, options, token) {
    var _a30, _b;
    return __awaiter2(this, void 0, void 0, function* () {
      const symbols = yield symbolsPromise;
      if (token.isCancellationRequested) {
        return [];
      }
      const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;
      const filterPos = filterBySymbolKind ? 1 : 0;
      let symbolQuery;
      let containerQuery;
      if (query.values && query.values.length > 1) {
        symbolQuery = pieceToQuery(query.values[0]);
        containerQuery = pieceToQuery(query.values.slice(1));
      } else {
        symbolQuery = query;
      }
      let buttons;
      const openSideBySideDirection = (_b = (_a30 = this.options) === null || _a30 === void 0 ? void 0 : _a30.openSideBySideDirection) === null || _b === void 0 ? void 0 : _b.call(_a30);
      if (openSideBySideDirection) {
        buttons = [{
          iconClass: openSideBySideDirection === "right" ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),
          tooltip: openSideBySideDirection === "right" ? localize("openToSide", "Open to the Side") : localize("openToBottom", "Open to the Bottom")
        }];
      }
      const filteredSymbolPicks = [];
      for (let index = 0; index < symbols.length; index++) {
        const symbol = symbols[index];
        const symbolLabel = trim(symbol.name);
        const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;
        const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;
        let containerLabel = symbol.containerName;
        if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {
          if (containerLabel) {
            containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;
          } else {
            containerLabel = options.extraContainerLabel;
          }
        }
        let symbolScore = void 0;
        let symbolMatches = void 0;
        let containerScore = void 0;
        let containerMatches = void 0;
        if (query.original.length > filterPos) {
          let skipContainerQuery = false;
          if (symbolQuery !== query) {
            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), {
              values: void 0
              /* disable multi-query support */
            }), filterPos, symbolLabelIconOffset);
            if (typeof symbolScore === "number") {
              skipContainerQuery = true;
            }
          }
          if (typeof symbolScore !== "number") {
            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);
            if (typeof symbolScore !== "number") {
              continue;
            }
          }
          if (!skipContainerQuery && containerQuery) {
            if (containerLabel && containerQuery.original.length > 0) {
              [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);
            }
            if (typeof containerScore !== "number") {
              continue;
            }
            if (typeof symbolScore === "number") {
              symbolScore += containerScore;
            }
          }
        }
        const deprecated = symbol.tags && symbol.tags.indexOf(
          1
          /* SymbolTag.Deprecated */
        ) >= 0;
        filteredSymbolPicks.push({
          index,
          kind: symbol.kind,
          score: symbolScore,
          label: symbolLabelWithIcon,
          ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),
          description: containerLabel,
          highlights: deprecated ? void 0 : {
            label: symbolMatches,
            description: containerMatches
          },
          range: {
            selection: Range.collapseToStart(symbol.selectionRange),
            decoration: symbol.range
          },
          strikethrough: deprecated,
          buttons
        });
      }
      const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));
      let symbolPicks = [];
      if (filterBySymbolKind) {
        let updateLastSeparatorLabel = function() {
          if (lastSeparator && typeof lastSymbolKind === "number" && lastSymbolKindCounter > 0) {
            lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);
          }
        };
        let lastSymbolKind = void 0;
        let lastSeparator = void 0;
        let lastSymbolKindCounter = 0;
        for (const symbolPick of sortedFilteredSymbolPicks) {
          if (lastSymbolKind !== symbolPick.kind) {
            updateLastSeparatorLabel();
            lastSymbolKind = symbolPick.kind;
            lastSymbolKindCounter = 1;
            lastSeparator = { type: "separator" };
            symbolPicks.push(lastSeparator);
          } else {
            lastSymbolKindCounter++;
          }
          symbolPicks.push(symbolPick);
        }
        updateLastSeparatorLabel();
      } else if (sortedFilteredSymbolPicks.length > 0) {
        symbolPicks = [
          { label: localize("symbols", "symbols ({0})", filteredSymbolPicks.length), type: "separator" },
          ...sortedFilteredSymbolPicks
        ];
      }
      return symbolPicks;
    });
  }
  compareByScore(symbolA, symbolB) {
    if (typeof symbolA.score !== "number" && typeof symbolB.score === "number") {
      return 1;
    } else if (typeof symbolA.score === "number" && typeof symbolB.score !== "number") {
      return -1;
    }
    if (typeof symbolA.score === "number" && typeof symbolB.score === "number") {
      if (symbolA.score > symbolB.score) {
        return -1;
      } else if (symbolA.score < symbolB.score) {
        return 1;
      }
    }
    if (symbolA.index < symbolB.index) {
      return -1;
    } else if (symbolA.index > symbolB.index) {
      return 1;
    }
    return 0;
  }
  compareByKindAndScore(symbolA, symbolB) {
    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;
    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;
    const result = kindA.localeCompare(kindB);
    if (result === 0) {
      return this.compareByScore(symbolA, symbolB);
    }
    return result;
  }
  getDocumentSymbols(document2, token) {
    return __awaiter2(this, void 0, void 0, function* () {
      const model = yield this._outlineModelService.getOrCreate(document2, token);
      return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();
    });
  }
};
AbstractGotoSymbolQuickAccessProvider.PREFIX = "@";
AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ":";
AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider_1.PREFIX}${AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX}`;
AbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate3([
  __param3(0, ILanguageFeaturesService),
  __param3(1, IOutlineModelService)
], AbstractGotoSymbolQuickAccessProvider);
var FALLBACK_NLS_SYMBOL_KIND = localize("property", "properties ({0})");
var NLS_SYMBOL_KIND_CACHE = {
  [
    5
    /* SymbolKind.Method */
  ]: localize("method", "methods ({0})"),
  [
    11
    /* SymbolKind.Function */
  ]: localize("function", "functions ({0})"),
  [
    8
    /* SymbolKind.Constructor */
  ]: localize("_constructor", "constructors ({0})"),
  [
    12
    /* SymbolKind.Variable */
  ]: localize("variable", "variables ({0})"),
  [
    4
    /* SymbolKind.Class */
  ]: localize("class", "classes ({0})"),
  [
    22
    /* SymbolKind.Struct */
  ]: localize("struct", "structs ({0})"),
  [
    23
    /* SymbolKind.Event */
  ]: localize("event", "events ({0})"),
  [
    24
    /* SymbolKind.Operator */
  ]: localize("operator", "operators ({0})"),
  [
    10
    /* SymbolKind.Interface */
  ]: localize("interface", "interfaces ({0})"),
  [
    2
    /* SymbolKind.Namespace */
  ]: localize("namespace", "namespaces ({0})"),
  [
    3
    /* SymbolKind.Package */
  ]: localize("package", "packages ({0})"),
  [
    25
    /* SymbolKind.TypeParameter */
  ]: localize("typeParameter", "type parameters ({0})"),
  [
    1
    /* SymbolKind.Module */
  ]: localize("modules", "modules ({0})"),
  [
    6
    /* SymbolKind.Property */
  ]: localize("property", "properties ({0})"),
  [
    9
    /* SymbolKind.Enum */
  ]: localize("enum", "enumerations ({0})"),
  [
    21
    /* SymbolKind.EnumMember */
  ]: localize("enumMember", "enumeration members ({0})"),
  [
    14
    /* SymbolKind.String */
  ]: localize("string", "strings ({0})"),
  [
    0
    /* SymbolKind.File */
  ]: localize("file", "files ({0})"),
  [
    17
    /* SymbolKind.Array */
  ]: localize("array", "arrays ({0})"),
  [
    15
    /* SymbolKind.Number */
  ]: localize("number", "numbers ({0})"),
  [
    16
    /* SymbolKind.Boolean */
  ]: localize("boolean", "booleans ({0})"),
  [
    18
    /* SymbolKind.Object */
  ]: localize("object", "objects ({0})"),
  [
    19
    /* SymbolKind.Key */
  ]: localize("key", "keys ({0})"),
  [
    7
    /* SymbolKind.Field */
  ]: localize("field", "fields ({0})"),
  [
    13
    /* SymbolKind.Constant */
  ]: localize("constant", "constants ({0})")
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/quickaccess/gotoSymbolQuickAccess.js
init_configuration();
init_lifecycle();
init_async();
init_cancellation();
init_actions2();
init_filters();
init_errors();
init_editorBrowser();
init_outlineModel();
init_languageFeatures();
var GotoSymbolQuickAccessProvider_1;
var _a28;
var GotoSymbolQuickAccessProvider = (_a28 = class extends AbstractGotoSymbolQuickAccessProvider {
  constructor(editorService, editorGroupService, configurationService, languageFeaturesService, outlineService, outlineModelService) {
    super(languageFeaturesService, outlineModelService, {
      openSideBySideDirection: () => this.configuration.openSideBySideDirection
    });
    this.editorService = editorService;
    this.editorGroupService = editorGroupService;
    this.configurationService = configurationService;
    this.outlineService = outlineService;
    this.onDidActiveTextEditorControlChange = this.editorService.onDidActiveEditorChange;
  }
  get configuration() {
    var _a30;
    const editorConfig = (_a30 = this.configurationService.getValue().workbench) == null ? void 0 : _a30.editor;
    return {
      openEditorPinned: !(editorConfig == null ? void 0 : editorConfig.enablePreviewFromQuickOpen) || !(editorConfig == null ? void 0 : editorConfig.enablePreview),
      openSideBySideDirection: editorConfig == null ? void 0 : editorConfig.openSideBySideDirection
    };
  }
  get activeTextEditorControl() {
    var _a30;
    if (isCompositeEditor((_a30 = this.editorService.activeEditorPane) == null ? void 0 : _a30.getControl())) {
      return void 0;
    }
    return this.editorService.activeTextEditorControl;
  }
  gotoLocation(context, options) {
    var _a30;
    if ((options.keyMods.alt || this.configuration.openEditorPinned && options.keyMods.ctrlCmd || options.forceSideBySide) && this.editorService.activeEditor) {
      (_a30 = context.restoreViewState) == null ? void 0 : _a30.call(context);
      const editorOptions = {
        selection: options.range,
        pinned: options.keyMods.ctrlCmd || this.configuration.openEditorPinned,
        preserveFocus: options.preserveFocus
      };
      this.editorGroupService.sideGroup.openEditor(this.editorService.activeEditor, editorOptions);
    } else {
      super.gotoLocation(context, options);
    }
  }
  async getSymbolPicks(model, filter2, options, disposables, token) {
    const result = await Promise.race([
      this.waitForLanguageSymbolRegistry(model, disposables),
      timeout(GotoSymbolQuickAccessProvider_1.SYMBOL_PICKS_TIMEOUT)
    ]);
    if (!result || token.isCancellationRequested) {
      return [];
    }
    return this.doGetSymbolPicks(this.getDocumentSymbols(model, token), prepareQuery(filter2), options, token);
  }
  provideWithoutTextEditor(picker) {
    if (this.canPickWithOutlineService()) {
      return this.doGetOutlinePicks(picker);
    }
    return super.provideWithoutTextEditor(picker);
  }
  canPickWithOutlineService() {
    return this.editorService.activeEditorPane ? this.outlineService.canCreateOutline(this.editorService.activeEditorPane) : false;
  }
  doGetOutlinePicks(picker) {
    const pane = this.editorService.activeEditorPane;
    if (!pane) {
      return Disposable.None;
    }
    const cts = new CancellationTokenSource();
    const disposables = new DisposableStore();
    disposables.add(toDisposable(() => cts.dispose(true)));
    picker.busy = true;
    this.outlineService.createOutline(pane, 4, cts.token).then((outline) => {
      if (!outline) {
        return;
      }
      if (cts.token.isCancellationRequested) {
        outline.dispose();
        return;
      }
      disposables.add(outline);
      const viewState = outline.captureViewState();
      disposables.add(toDisposable(() => {
        if (picker.selectedItems.length === 0) {
          viewState.dispose();
        }
      }));
      const entries = outline.config.quickPickDataSource.getQuickPickElements();
      const items = entries.map((entry, idx) => {
        return {
          kind: 0,
          index: idx,
          score: 0,
          label: entry.label,
          description: entry.description,
          ariaLabel: entry.ariaLabel,
          iconClasses: entry.iconClasses
        };
      });
      disposables.add(picker.onDidAccept(() => {
        picker.hide();
        const [entry] = picker.selectedItems;
        if (entry && entries[entry.index]) {
          outline.reveal(entries[entry.index].element, {}, false);
        }
      }));
      const updatePickerItems = () => {
        const filteredItems = items.filter((item) => {
          if (picker.value === "@") {
            item.score = 0;
            item.highlights = void 0;
            return true;
          }
          const score2 = fuzzyScore(picker.value, picker.value.toLowerCase(), 1, item.label, item.label.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });
          if (!score2) {
            return false;
          }
          item.score = score2[1];
          item.highlights = { label: createMatches(score2) };
          return true;
        });
        if (filteredItems.length === 0) {
          const label = localize("empty", "No matching entries");
          picker.items = [{ label, index: -1, kind: 14 }];
          picker.ariaLabel = label;
        } else {
          picker.items = filteredItems;
        }
      };
      updatePickerItems();
      disposables.add(picker.onDidChangeValue(updatePickerItems));
      const previewDisposable = new MutableDisposable();
      disposables.add(previewDisposable);
      disposables.add(picker.onDidChangeActive(() => {
        const [entry] = picker.activeItems;
        if (entry && entries[entry.index]) {
          previewDisposable.value = outline.preview(entries[entry.index].element);
        } else {
          previewDisposable.clear();
        }
      }));
    }).catch((err) => {
      onUnexpectedError(err);
      picker.hide();
    }).finally(() => {
      picker.busy = false;
    });
    return disposables;
  }
}, GotoSymbolQuickAccessProvider_1 = _a28, _a28.SYMBOL_PICKS_TIMEOUT = 8e3, _a28);
GotoSymbolQuickAccessProvider = GotoSymbolQuickAccessProvider_1 = __decorate([
  __param(0, IEditorService),
  __param(1, IEditorGroupsService),
  __param(2, IConfigurationService),
  __param(3, ILanguageFeaturesService),
  __param(4, IOutlineService),
  __param(5, IOutlineModelService)
], GotoSymbolQuickAccessProvider);
var _GotoSymbolAction = class _GotoSymbolAction extends Action2 {
  constructor() {
    super({
      id: _GotoSymbolAction.ID,
      title: {
        value: localize("gotoSymbol", "Go to Symbol in Editor..."),
        mnemonicTitle: localize(
          { key: "miGotoSymbolInEditor", comment: ["&& denotes a mnemonic"] },
          "Go to &&Symbol in Editor..."
        ),
        original: "Go to Symbol in Editor..."
      },
      f1: true,
      keybinding: {
        when: void 0,
        weight: 200,
        primary: 2048 | 1024 | 45
      },
      menu: [{
        id: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 1
      }]
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(GotoSymbolQuickAccessProvider.PREFIX, { itemActivation: ItemActivation.NONE });
  }
};
_GotoSymbolAction.ID = "workbench.action.gotoSymbol";
var GotoSymbolAction = _GotoSymbolAction;
registerAction2(GotoSymbolAction);
Registry.as(Extensions6.Quickaccess).registerQuickAccessProvider({
  ctor: GotoSymbolQuickAccessProvider,
  prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,
  contextKey: "inFileSymbolsPicker",
  placeholder: localize("gotoSymbolQuickAccessPlaceholder", "Type the name of a symbol to go to."),
  helpEntries: [
    {
      description: localize("gotoSymbolQuickAccess", "Go to Symbol in Editor"),
      prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,
      commandId: GotoSymbolAction.ID,
      commandCenterOrder: 40
    },
    {
      description: localize("gotoSymbolByCategoryQuickAccess", "Go to Symbol in Editor by Category"),
      prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY
    }
  ]
});

// node_modules/vscode/vscode/src/vs/workbench/browser/actions/quickAccessActions.js
init_nls();
init_actions2();
init_keybindingsRegistry();
init_commands();
var globalQuickAccessKeybinding = {
  primary: 2048 | 46,
  secondary: [2048 | 35],
  mac: { primary: 2048 | 46, secondary: void 0 }
};
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.action.closeQuickOpen",
  weight: 200,
  when: inQuickPickContext,
  primary: 9,
  secondary: [1024 | 9],
  handler: (accessor) => {
    const quickInputService = accessor.get(IQuickInputService);
    return quickInputService.cancel();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.action.acceptSelectedQuickOpenItem",
  weight: 200,
  when: inQuickPickContext,
  primary: 0,
  handler: (accessor) => {
    const quickInputService = accessor.get(IQuickInputService);
    return quickInputService.accept();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.action.alternativeAcceptSelectedQuickOpenItem",
  weight: 200,
  when: inQuickPickContext,
  primary: 0,
  handler: (accessor) => {
    const quickInputService = accessor.get(IQuickInputService);
    return quickInputService.accept({ ctrlCmd: true, alt: false });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.action.focusQuickOpen",
  weight: 200,
  when: inQuickPickContext,
  primary: 0,
  handler: (accessor) => {
    const quickInputService = accessor.get(IQuickInputService);
    quickInputService.focus();
  }
});
var quickAccessNavigateNextInFilePickerId = "workbench.action.quickOpenNavigateNextInFilePicker";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: quickAccessNavigateNextInFilePickerId,
  weight: 200 + 50,
  handler: getQuickNavigateHandler(quickAccessNavigateNextInFilePickerId, true),
  when: defaultQuickAccessContext,
  primary: globalQuickAccessKeybinding.primary,
  secondary: globalQuickAccessKeybinding.secondary,
  mac: globalQuickAccessKeybinding.mac
});
var quickAccessNavigatePreviousInFilePickerId = "workbench.action.quickOpenNavigatePreviousInFilePicker";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: quickAccessNavigatePreviousInFilePickerId,
  weight: 200 + 50,
  handler: getQuickNavigateHandler(quickAccessNavigatePreviousInFilePickerId, false),
  when: defaultQuickAccessContext,
  primary: globalQuickAccessKeybinding.primary | 1024,
  secondary: [globalQuickAccessKeybinding.secondary[0] | 1024],
  mac: {
    primary: globalQuickAccessKeybinding.mac.primary | 1024,
    secondary: void 0
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.action.quickPickManyToggle",
  weight: 200,
  when: inQuickPickContext,
  primary: 0,
  handler: (accessor) => {
    const quickInputService = accessor.get(IQuickInputService);
    quickInputService.toggle();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.action.quickInputBack",
  weight: 200 + 50,
  when: inQuickPickContext,
  primary: 0,
  win: { primary: 512 | 15 },
  mac: { primary: 256 | 88 },
  linux: { primary: 2048 | 512 | 88 },
  handler: (accessor) => {
    const quickInputService = accessor.get(IQuickInputService);
    quickInputService.back();
  }
});
registerAction2(class QuickAccessAction extends Action2 {
  constructor() {
    super({
      id: "workbench.action.quickOpen",
      title: {
        value: localize("quickOpen", "Go to File..."),
        original: "Go to File..."
      },
      description: {
        description: `Quick access`,
        args: [{
          name: "prefix",
          schema: {
            "type": "string"
          }
        }]
      },
      keybinding: {
        weight: 200,
        primary: globalQuickAccessKeybinding.primary,
        secondary: globalQuickAccessKeybinding.secondary,
        mac: globalQuickAccessKeybinding.mac
      },
      f1: true
    });
  }
  run(accessor, prefix) {
    const quickInputService = accessor.get(IQuickInputService);
    quickInputService.quickAccess.show(typeof prefix === "string" ? prefix : void 0, { preserveValue: typeof prefix === "string" });
  }
});
registerAction2(class QuickAccessAction2 extends Action2 {
  constructor() {
    super({
      id: "workbench.action.quickOpenWithModes",
      title: localize("quickOpenWithModes", "Quick Open"),
      menu: {
        id: MenuId.CommandCenter,
        order: 100
      }
    });
  }
  run(accessor) {
    const quickInputService = accessor.get(IQuickInputService);
    quickInputService.quickAccess.show(void 0, {
      preserveValue: true,
      providerOptions: {
        includeHelp: true,
        from: "commandCenter"
      }
    });
  }
});
CommandsRegistry.registerCommand("workbench.action.quickOpenPreviousEditor", async (accessor) => {
  const quickInputService = accessor.get(IQuickInputService);
  quickInputService.quickAccess.show("", { itemActivation: ItemActivation.SECOND });
});
var BaseQuickAccessNavigateAction = class extends Action2 {
  constructor(id, title, next, quickNavigate, keybinding) {
    super({ id, title, f1: true, keybinding });
    this.id = id;
    this.next = next;
    this.quickNavigate = quickNavigate;
  }
  async run(accessor) {
    const keybindingService = accessor.get(IKeybindingService);
    const quickInputService = accessor.get(IQuickInputService);
    const keys = keybindingService.lookupKeybindings(this.id);
    const quickNavigate = this.quickNavigate ? { keybindings: keys } : void 0;
    quickInputService.navigate(this.next, quickNavigate);
  }
};
var QuickAccessNavigateNextAction = class extends BaseQuickAccessNavigateAction {
  constructor() {
    super("workbench.action.quickOpenNavigateNext", { value: localize("quickNavigateNext", "Navigate Next in Quick Open"), original: "Navigate Next in Quick Open" }, true, true);
  }
};
var QuickAccessNavigatePreviousAction = class extends BaseQuickAccessNavigateAction {
  constructor() {
    super("workbench.action.quickOpenNavigatePrevious", { value: localize("quickNavigatePrevious", "Navigate Previous in Quick Open"), original: "Navigate Previous in Quick Open" }, false, true);
  }
};
var QuickAccessSelectNextAction = class extends BaseQuickAccessNavigateAction {
  constructor() {
    super("workbench.action.quickOpenSelectNext", { value: localize("quickSelectNext", "Select Next in Quick Open"), original: "Select Next in Quick Open" }, true, false, {
      weight: 200 + 50,
      when: inQuickPickContext,
      primary: 0,
      mac: { primary: 256 | 44 }
    });
  }
};
var QuickAccessSelectPreviousAction = class extends BaseQuickAccessNavigateAction {
  constructor() {
    super("workbench.action.quickOpenSelectPrevious", { value: localize("quickSelectPrevious", "Select Previous in Quick Open"), original: "Select Previous in Quick Open" }, false, false, {
      weight: 200 + 50,
      when: inQuickPickContext,
      primary: 0,
      mac: { primary: 256 | 46 }
    });
  }
};
registerAction2(QuickAccessSelectNextAction);
registerAction2(QuickAccessSelectPreviousAction);
registerAction2(QuickAccessNavigateNextAction);
registerAction2(QuickAccessNavigatePreviousAction);

// node_modules/vscode/vscode/src/vs/workbench/contrib/quickaccess/browser/quickAccess.contribution.js
init_nls();
init_platform2();

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/helpQuickAccess.js
init_nls();
init_platform2();
init_lifecycle();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var HelpQuickAccessProvider_1;
var HelpQuickAccessProvider = HelpQuickAccessProvider_1 = class HelpQuickAccessProvider2 {
  constructor(quickInputService, keybindingService) {
    this.quickInputService = quickInputService;
    this.keybindingService = keybindingService;
    this.registry = Registry.as(Extensions6.Quickaccess);
  }
  provide(picker) {
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept(() => {
      const [item] = picker.selectedItems;
      if (item) {
        this.quickInputService.quickAccess.show(item.prefix, { preserveValue: true });
      }
    }));
    disposables.add(picker.onDidChangeValue((value) => {
      const providerDescriptor = this.registry.getQuickAccessProvider(value.substr(HelpQuickAccessProvider_1.PREFIX.length));
      if (providerDescriptor && providerDescriptor.prefix && providerDescriptor.prefix !== HelpQuickAccessProvider_1.PREFIX) {
        this.quickInputService.quickAccess.show(providerDescriptor.prefix, { preserveValue: true });
      }
    }));
    picker.items = this.getQuickAccessProviders().filter((p) => p.prefix !== HelpQuickAccessProvider_1.PREFIX);
    return disposables;
  }
  getQuickAccessProviders() {
    const providers2 = this.registry.getQuickAccessProviders().sort((providerA, providerB) => providerA.prefix.localeCompare(providerB.prefix)).flatMap((provider) => this.createPicks(provider));
    return providers2;
  }
  createPicks(provider) {
    return provider.helpEntries.map((helpEntry) => {
      const prefix = helpEntry.prefix || provider.prefix;
      const label = prefix || "…";
      return {
        prefix,
        label,
        keybinding: helpEntry.commandId ? this.keybindingService.lookupKeybinding(helpEntry.commandId) : void 0,
        ariaLabel: localize("helpPickAriaLabel", "{0}, {1}", label, helpEntry.description),
        description: helpEntry.description
      };
    });
  }
};
HelpQuickAccessProvider.PREFIX = "?";
HelpQuickAccessProvider = HelpQuickAccessProvider_1 = __decorate4([
  __param4(0, IQuickInputService),
  __param4(1, IKeybindingService)
], HelpQuickAccessProvider);

// node_modules/vscode/vscode/src/vs/workbench/contrib/quickaccess/browser/viewQuickAccess.js
init_tslib_es6();
init_nls();
init_contextkey();
init_filters();
init_strings();
init_actions2();
init_debug();
var ViewQuickAccessProvider_1;
var _a29;
var ViewQuickAccessProvider = (_a29 = class extends PickerQuickAccessProvider {
  constructor(viewDescriptorService, viewsService, outputService, terminalService, terminalGroupService, debugService, paneCompositeService, contextKeyService) {
    super(ViewQuickAccessProvider_1.PREFIX, {
      noResultsPick: {
        label: localize("noViewResults", "No matching views"),
        containerLabel: ""
      }
    });
    this.viewDescriptorService = viewDescriptorService;
    this.viewsService = viewsService;
    this.outputService = outputService;
    this.terminalService = terminalService;
    this.terminalGroupService = terminalGroupService;
    this.debugService = debugService;
    this.paneCompositeService = paneCompositeService;
    this.contextKeyService = contextKeyService;
  }
  _getPicks(filter2) {
    const filteredViewEntries = this.doGetViewPickItems().filter((entry) => {
      if (!filter2) {
        return true;
      }
      entry.highlights = { label: matchesFuzzy(filter2, entry.label, true) ?? void 0 };
      return entry.highlights.label || fuzzyContains(entry.containerLabel, filter2);
    });
    const mapEntryToContainer = /* @__PURE__ */ new Map();
    for (const entry of filteredViewEntries) {
      if (!mapEntryToContainer.has(entry.label)) {
        mapEntryToContainer.set(entry.label, entry.containerLabel);
      }
    }
    const filteredViewEntriesWithSeparators = [];
    let lastContainer = void 0;
    for (const entry of filteredViewEntries) {
      if (lastContainer !== entry.containerLabel) {
        lastContainer = entry.containerLabel;
        let separatorLabel;
        if (mapEntryToContainer.has(lastContainer)) {
          separatorLabel = `${mapEntryToContainer.get(lastContainer)} / ${lastContainer}`;
        } else {
          separatorLabel = lastContainer;
        }
        filteredViewEntriesWithSeparators.push({ type: "separator", label: separatorLabel });
      }
      filteredViewEntriesWithSeparators.push(entry);
    }
    return filteredViewEntriesWithSeparators;
  }
  doGetViewPickItems() {
    const viewEntries = [];
    const getViewEntriesForPaneComposite = (paneComposite, viewContainer) => {
      const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
      const result = [];
      for (const view of viewContainerModel.allViewDescriptors) {
        if (this.contextKeyService.contextMatchesRules(view.when)) {
          result.push({
            label: view.name,
            containerLabel: viewContainerModel.title,
            accept: () => this.viewsService.openView(view.id, true)
          });
        }
      }
      return result;
    };
    const addPaneComposites = (location2, containerLabel) => {
      const paneComposites = this.paneCompositeService.getPaneComposites(location2);
      const visiblePaneCompositeIds = this.paneCompositeService.getVisiblePaneCompositeIds(location2);
      paneComposites.sort((a, b) => {
        let aIndex = visiblePaneCompositeIds.findIndex((id) => a.id === id);
        let bIndex = visiblePaneCompositeIds.findIndex((id) => b.id === id);
        if (aIndex < 0) {
          aIndex = paneComposites.indexOf(a) + visiblePaneCompositeIds.length;
        }
        if (bIndex < 0) {
          bIndex = paneComposites.indexOf(b) + visiblePaneCompositeIds.length;
        }
        return aIndex - bIndex;
      });
      for (const paneComposite of paneComposites) {
        if (this.includeViewContainer(paneComposite)) {
          const viewContainer = this.viewDescriptorService.getViewContainerById(paneComposite.id);
          if (viewContainer) {
            viewEntries.push({
              label: this.viewDescriptorService.getViewContainerModel(viewContainer).title,
              containerLabel,
              accept: () => this.paneCompositeService.openPaneComposite(paneComposite.id, location2, true)
            });
          }
        }
      }
    };
    addPaneComposites(0, localize("views", "Side Bar"));
    addPaneComposites(1, localize("panels", "Panel"));
    addPaneComposites(2, localize("secondary side bar", "Secondary Side Bar"));
    const addPaneCompositeViews = (location2) => {
      const paneComposites = this.paneCompositeService.getPaneComposites(location2);
      for (const paneComposite of paneComposites) {
        const viewContainer = this.viewDescriptorService.getViewContainerById(paneComposite.id);
        if (viewContainer) {
          viewEntries.push(...getViewEntriesForPaneComposite(paneComposite, viewContainer));
        }
      }
    };
    addPaneCompositeViews(0);
    addPaneCompositeViews(1);
    addPaneCompositeViews(2);
    this.terminalGroupService.groups.forEach((group, groupIndex) => {
      group.terminalInstances.forEach((terminal, terminalIndex) => {
        const label = localize(
          "terminalTitle",
          "{0}: {1}",
          `${groupIndex + 1}.${terminalIndex + 1}`,
          terminal.title
        );
        viewEntries.push({
          label,
          containerLabel: localize("terminals", "Terminal"),
          accept: async () => {
            await this.terminalGroupService.showPanel(true);
            this.terminalService.setActiveInstance(terminal);
          }
        });
      });
    });
    this.debugService.getModel().getSessions(true).filter((s) => s.hasSeparateRepl()).forEach((session, _) => {
      const label = session.name;
      viewEntries.push({
        label,
        containerLabel: localize("debugConsoles", "Debug Console"),
        accept: async () => {
          await this.debugService.focusStackFrame(void 0, void 0, session, { explicit: true });
          if (!this.viewsService.isViewVisible(REPL_VIEW_ID)) {
            await this.viewsService.openView(REPL_VIEW_ID, true);
          }
        }
      });
    });
    const channels = this.outputService.getChannelDescriptors();
    for (const channel of channels) {
      viewEntries.push({
        label: channel.label,
        containerLabel: localize("channels", "Output"),
        accept: () => this.outputService.showChannel(channel.id)
      });
    }
    return viewEntries;
  }
  includeViewContainer(container) {
    const viewContainer = this.viewDescriptorService.getViewContainerById(container.id);
    if (viewContainer == null ? void 0 : viewContainer.hideIfEmpty) {
      return this.viewDescriptorService.getViewContainerModel(viewContainer).activeViewDescriptors.length > 0;
    }
    return true;
  }
}, ViewQuickAccessProvider_1 = _a29, _a29.PREFIX = "view ", _a29);
ViewQuickAccessProvider = ViewQuickAccessProvider_1 = __decorate([
  __param(0, IViewDescriptorService),
  __param(1, IViewsService),
  __param(2, IOutputService),
  __param(3, ITerminalService),
  __param(4, ITerminalGroupService),
  __param(5, IDebugService),
  __param(6, IPaneCompositePartService),
  __param(7, IContextKeyService)
], ViewQuickAccessProvider);
var _OpenViewPickerAction = class _OpenViewPickerAction extends Action2 {
  constructor() {
    super({
      id: _OpenViewPickerAction.ID,
      title: { value: localize("openView", "Open View"), original: "Open View" },
      category: Categories.View,
      f1: true
    });
  }
  async run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(ViewQuickAccessProvider.PREFIX);
  }
};
_OpenViewPickerAction.ID = "workbench.action.openView";
var OpenViewPickerAction = _OpenViewPickerAction;
var _QuickAccessViewPickerAction = class _QuickAccessViewPickerAction extends Action2 {
  constructor() {
    super({
      id: _QuickAccessViewPickerAction.ID,
      title: { value: localize("quickOpenView", "Quick Open View"), original: "Quick Open View" },
      category: Categories.View,
      f1: false,
      keybinding: {
        weight: 200,
        when: void 0,
        ..._QuickAccessViewPickerAction.KEYBINDING
      }
    });
  }
  async run(accessor) {
    const keybindingService = accessor.get(IKeybindingService);
    const quickInputService = accessor.get(IQuickInputService);
    const keys = keybindingService.lookupKeybindings(_QuickAccessViewPickerAction.ID);
    quickInputService.quickAccess.show(ViewQuickAccessProvider.PREFIX, { quickNavigateConfiguration: { keybindings: keys }, itemActivation: ItemActivation.FIRST });
  }
};
_QuickAccessViewPickerAction.ID = "workbench.action.quickOpenView";
_QuickAccessViewPickerAction.KEYBINDING = {
  primary: 2048 | 47,
  mac: { primary: 256 | 47 },
  linux: { primary: 0 }
};
var QuickAccessViewPickerAction = _QuickAccessViewPickerAction;

// node_modules/vscode/vscode/src/vs/workbench/contrib/quickaccess/browser/quickAccess.contribution.js
init_actions2();
init_contextkey();
init_keybindingsRegistry();
init_editorContextKeys();
var quickAccessRegistry = Registry.as(Extensions6.Quickaccess);
quickAccessRegistry.registerQuickAccessProvider({
  ctor: HelpQuickAccessProvider,
  prefix: HelpQuickAccessProvider.PREFIX,
  placeholder: localize(
    "helpQuickAccessPlaceholder",
    "Type '{0}' to get help on the actions you can take from here.",
    HelpQuickAccessProvider.PREFIX
  ),
  helpEntries: [{
    description: localize("helpQuickAccess", "Show all Quick Access Providers"),
    commandCenterOrder: 70,
    commandCenterLabel: localize("more", "More")
  }]
});
quickAccessRegistry.registerQuickAccessProvider({
  ctor: ViewQuickAccessProvider,
  prefix: ViewQuickAccessProvider.PREFIX,
  contextKey: "inViewsPicker",
  placeholder: localize(
    "viewQuickAccessPlaceholder",
    "Type the name of a view, output channel or terminal to open."
  ),
  helpEntries: [{ description: localize("viewQuickAccess", "Open View"), commandId: OpenViewPickerAction.ID }]
});
quickAccessRegistry.registerQuickAccessProvider({
  ctor: CommandsQuickAccessProvider,
  prefix: CommandsQuickAccessProvider.PREFIX,
  contextKey: "inCommandsPicker",
  placeholder: localize("commandsQuickAccessPlaceholder", "Type the name of a command to run."),
  helpEntries: [{ description: localize("commandsQuickAccess", "Show and Run Commands"), commandId: ShowAllCommandsAction.ID, commandCenterOrder: 20 }]
});
MenuRegistry.appendMenuItem(MenuId.MenubarViewMenu, {
  group: "1_open",
  command: {
    id: ShowAllCommandsAction.ID,
    title: localize(
      { key: "miCommandPalette", comment: ["&& denotes a mnemonic"] },
      "&&Command Palette..."
    )
  },
  order: 1
});
MenuRegistry.appendMenuItem(MenuId.MenubarHelpMenu, {
  group: "1_welcome",
  command: {
    id: ShowAllCommandsAction.ID,
    title: localize(
      { key: "miShowAllCommands", comment: ["&& denotes a mnemonic"] },
      "Show All Commands"
    )
  },
  order: 2
});
MenuRegistry.appendMenuItem(MenuId.MenubarViewMenu, {
  group: "1_open",
  command: {
    id: OpenViewPickerAction.ID,
    title: localize(
      { key: "miOpenView", comment: ["&& denotes a mnemonic"] },
      "&&Open View..."
    )
  },
  order: 2
});
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "workbench.action.gotoLine",
    title: localize(
      { key: "miGotoLine", comment: ["&& denotes a mnemonic"] },
      "Go to &&Line/Column..."
    )
  },
  order: 1
});
MenuRegistry.appendMenuItem(MenuId.GlobalActivity, {
  group: "1_command",
  command: {
    id: ShowAllCommandsAction.ID,
    title: localize("commandPalette", "Command Palette...")
  },
  order: 1
});
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
  group: "z_commands",
  when: EditorContextKeys.editorSimpleInput.toNegated(),
  command: {
    id: ShowAllCommandsAction.ID,
    title: localize("commandPalette", "Command Palette...")
  },
  order: 1
});
registerAction2(ClearCommandHistoryAction);
registerAction2(ShowAllCommandsAction);
registerAction2(OpenViewPickerAction);
registerAction2(QuickAccessViewPickerAction);
var inViewsPickerContextKey = "inViewsPicker";
var inViewsPickerContext = ContextKeyExpr.and(inQuickPickContext, ContextKeyExpr.has(inViewsPickerContextKey));
var viewPickerKeybinding = QuickAccessViewPickerAction.KEYBINDING;
var quickAccessNavigateNextInViewPickerId = "workbench.action.quickOpenNavigateNextInViewPicker";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: quickAccessNavigateNextInViewPickerId,
  weight: 200 + 50,
  handler: getQuickNavigateHandler(quickAccessNavigateNextInViewPickerId, true),
  when: inViewsPickerContext,
  primary: viewPickerKeybinding.primary,
  linux: viewPickerKeybinding.linux,
  mac: viewPickerKeybinding.mac
});
var quickAccessNavigatePreviousInViewPickerId = "workbench.action.quickOpenNavigatePreviousInViewPicker";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: quickAccessNavigatePreviousInViewPickerId,
  weight: 200 + 50,
  handler: getQuickNavigateHandler(quickAccessNavigatePreviousInViewPickerId, false),
  when: inViewsPickerContext,
  primary: viewPickerKeybinding.primary | 1024,
  linux: viewPickerKeybinding.linux,
  mac: {
    primary: viewPickerKeybinding.mac.primary | 1024
  }
});

// node_modules/vscode/service-override/quickaccess.js
var isKeybindingConfigurationVisible = () => {
  return false;
};
var shouldUseGlobalPicker = (_activeCodeEditor, _activeCodeEditorStandalone) => {
  return false;
};
var original = CommandsQuickAccessProvider.prototype["getCommandPicks"];
CommandsQuickAccessProvider.prototype["getCommandPicks"] = async function(token) {
  let result = await original.call(this, token);
  if (!isKeybindingConfigurationVisible()) {
    result = result.map((picks) => {
      var _a30;
      return {
        ...picks,
        buttons: (_a30 = picks.buttons) == null ? void 0 : _a30.filter((button) => button.tooltip !== "Configure Keybinding")
      };
    });
  }
  return result;
};
var DelegateQuickInputService = class DelegateQuickInputService2 {
  constructor(instantiationService) {
    this.instantiationService = instantiationService;
    this.workbenchQuickInputService = instantiationService.createInstance(QuickInputService2);
  }
  get activeService() {
    const activeCodeEditor = StandaloneServices.get(ICodeEditorService).getFocusedCodeEditor();
    if (activeCodeEditor == null || shouldUseGlobalPicker(activeCodeEditor, activeCodeEditor instanceof StandaloneCodeEditor)) {
      return this.workbenchQuickInputService;
    }
    this.standaloneQuickInputService ?? (this.standaloneQuickInputService = this.instantiationService.createInstance(StandaloneQuickInputService));
    return this.standaloneQuickInputService;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  get backButton() {
    return this.activeService.backButton;
  }
  get onShow() {
    return this.activeService.onShow;
  }
  get onHide() {
    return this.activeService.onHide;
  }
  createQuickWidget() {
    return this.activeService.createQuickWidget();
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return this.activeService.pick(picks, options, token);
  }
  input(options, token) {
    return this.activeService.input(options, token);
  }
  createQuickPick() {
    return this.activeService.createQuickPick();
  }
  createInputBox() {
    return this.activeService.createInputBox();
  }
  focus() {
    return this.activeService.focus();
  }
  toggle() {
    return this.activeService.toggle();
  }
  navigate(next, quickNavigate) {
    return this.activeService.navigate(next, quickNavigate);
  }
  accept() {
    return this.activeService.accept();
  }
  back() {
    return this.activeService.back();
  }
  cancel() {
    return this.activeService.cancel();
  }
};
DelegateQuickInputService = __decorate([
  __param(0, IInstantiationService)
], DelegateQuickInputService);
function getServiceOverride5({ isKeybindingConfigurationVisible: _isKeybindingConfigurationVisible, shouldUseGlobalPicker: _shouldUseGlobalPicker } = {}) {
  if (_isKeybindingConfigurationVisible != null) {
    isKeybindingConfigurationVisible = _isKeybindingConfigurationVisible;
  }
  if (_shouldUseGlobalPicker != null) {
    shouldUseGlobalPicker = _shouldUseGlobalPicker;
  }
  return {
    [IQuickInputService.toString()]: new SyncDescriptor(DelegateQuickInputService, [], true)
  };
}

export {
  ExtensionHostKind,
  getServiceOverride2 as getServiceOverride,
  getLocalExtHostExtensionService,
  getServiceOverride3 as getServiceOverride2,
  getServiceOverride4 as getServiceOverride3,
  getServiceOverride5 as getServiceOverride4
};
//# sourceMappingURL=chunk-CZNSQQ73.js.map
