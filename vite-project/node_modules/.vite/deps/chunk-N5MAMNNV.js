import {
  __esm
} from "./chunk-PGWBAY6J.js";

// node_modules/monaco-editor/esm/vs/base/common/errors.js
function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
  errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
}
function onUnexpectedError(e) {
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedError(e);
  }
  return void 0;
}
function onUnexpectedExternalError(e) {
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedExternalError(e);
  }
  return void 0;
}
function transformErrorForSerialization(error) {
  if (error instanceof Error) {
    const { name, message } = error;
    const stack = error.stacktrace || error.stack;
    return {
      $isError: true,
      name,
      message,
      stack,
      noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
    };
  }
  return error;
}
function isCancellationError(error) {
  if (error instanceof CancellationError) {
    return true;
  }
  return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
function canceled() {
  const error = new Error(canceledName);
  error.name = error.message;
  return error;
}
function illegalArgument(name) {
  if (name) {
    return new Error(`Illegal argument: ${name}`);
  } else {
    return new Error("Illegal argument");
  }
}
function illegalState(name) {
  if (name) {
    return new Error(`Illegal state: ${name}`);
  } else {
    return new Error("Illegal state");
  }
}
function readonly(name) {
  return name ? new Error(`readonly property '${name} cannot be changed'`) : new Error("readonly property cannot be changed");
}
function disposed(what) {
  const result = new Error(`${what} has been disposed`);
  result.name = "DISPOSED";
  return result;
}
function getErrorMessage(err) {
  if (!err) {
    return "Error";
  }
  if (err.message) {
    return err.message;
  }
  if (err.stack) {
    return err.stack.split("\n")[0];
  }
  return String(err);
}
var ErrorHandler, errorHandler, canceledName, CancellationError, NotImplementedError, NotSupportedError, ErrorNoTelemetry, BugIndicatingError;
var init_errors = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/errors.js"() {
    ErrorHandler = class {
      constructor() {
        this.listeners = [];
        this.unexpectedErrorHandler = function(e) {
          setTimeout(() => {
            if (e.stack) {
              if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
                throw new ErrorNoTelemetry(e.message + "\n\n" + e.stack);
              }
              throw new Error(e.message + "\n\n" + e.stack);
            }
            throw e;
          }, 0);
        };
      }
      addListener(listener) {
        this.listeners.push(listener);
        return () => {
          this._removeListener(listener);
        };
      }
      emit(e) {
        this.listeners.forEach((listener) => {
          listener(e);
        });
      }
      _removeListener(listener) {
        this.listeners.splice(this.listeners.indexOf(listener), 1);
      }
      setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        this.unexpectedErrorHandler = newUnexpectedErrorHandler;
      }
      getUnexpectedErrorHandler() {
        return this.unexpectedErrorHandler;
      }
      onUnexpectedError(e) {
        this.unexpectedErrorHandler(e);
        this.emit(e);
      }
      // For external errors, we don't want the listeners to be called
      onUnexpectedExternalError(e) {
        this.unexpectedErrorHandler(e);
      }
    };
    errorHandler = new ErrorHandler();
    canceledName = "Canceled";
    CancellationError = class extends Error {
      constructor() {
        super(canceledName);
        this.name = this.message;
      }
    };
    NotImplementedError = class extends Error {
      constructor(message) {
        super("NotImplemented");
        if (message) {
          this.message = message;
        }
      }
    };
    NotSupportedError = class extends Error {
      constructor(message) {
        super("NotSupported");
        if (message) {
          this.message = message;
        }
      }
    };
    ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
      constructor(msg) {
        super(msg);
        this.name = "CodeExpectedError";
      }
      static fromError(err) {
        if (err instanceof _ErrorNoTelemetry) {
          return err;
        }
        const result = new _ErrorNoTelemetry();
        result.message = err.message;
        result.stack = err.stack;
        return result;
      }
      static isErrorNoTelemetry(err) {
        return err.name === "CodeExpectedError";
      }
    };
    BugIndicatingError = class _BugIndicatingError extends Error {
      constructor(message) {
        super(message || "An unexpected bug occurred.");
        Object.setPrototypeOf(this, _BugIndicatingError.prototype);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/functional.js
function once(fn) {
  const _this = this;
  let didCall = false;
  let result;
  return function() {
    if (didCall) {
      return result;
    }
    didCall = true;
    result = fn.apply(_this, arguments);
    return result;
  };
}
var init_functional = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/functional.js"() {
  }
});

// node_modules/monaco-editor/esm/vs/base/common/iterator.js
var Iterable;
var init_iterator = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/iterator.js"() {
    (function(Iterable2) {
      function is(thing) {
        return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
      }
      Iterable2.is = is;
      const _empty2 = Object.freeze([]);
      function empty() {
        return _empty2;
      }
      Iterable2.empty = empty;
      function* single(element) {
        yield element;
      }
      Iterable2.single = single;
      function wrap(iterableOrElement) {
        if (is(iterableOrElement)) {
          return iterableOrElement;
        } else {
          return single(iterableOrElement);
        }
      }
      Iterable2.wrap = wrap;
      function from(iterable) {
        return iterable || _empty2;
      }
      Iterable2.from = from;
      function isEmpty(iterable) {
        return !iterable || iterable[Symbol.iterator]().next().done === true;
      }
      Iterable2.isEmpty = isEmpty;
      function first(iterable) {
        return iterable[Symbol.iterator]().next().value;
      }
      Iterable2.first = first;
      function some(iterable, predicate) {
        for (const element of iterable) {
          if (predicate(element)) {
            return true;
          }
        }
        return false;
      }
      Iterable2.some = some;
      function find(iterable, predicate) {
        for (const element of iterable) {
          if (predicate(element)) {
            return element;
          }
        }
        return void 0;
      }
      Iterable2.find = find;
      function* filter2(iterable, predicate) {
        for (const element of iterable) {
          if (predicate(element)) {
            yield element;
          }
        }
      }
      Iterable2.filter = filter2;
      function* map(iterable, fn) {
        let index2 = 0;
        for (const element of iterable) {
          yield fn(element, index2++);
        }
      }
      Iterable2.map = map;
      function* concat(...iterables) {
        for (const iterable of iterables) {
          for (const element of iterable) {
            yield element;
          }
        }
      }
      Iterable2.concat = concat;
      function reduce(iterable, reducer, initialValue) {
        let value = initialValue;
        for (const element of iterable) {
          value = reducer(value, element);
        }
        return value;
      }
      Iterable2.reduce = reduce;
      function* slice(arr, from2, to = arr.length) {
        if (from2 < 0) {
          from2 += arr.length;
        }
        if (to < 0) {
          to += arr.length;
        } else if (to > arr.length) {
          to = arr.length;
        }
        for (; from2 < to; from2++) {
          yield arr[from2];
        }
      }
      Iterable2.slice = slice;
      function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
        const consumed = [];
        if (atMost === 0) {
          return [consumed, iterable];
        }
        const iterator = iterable[Symbol.iterator]();
        for (let i = 0; i < atMost; i++) {
          const next = iterator.next();
          if (next.done) {
            return [consumed, Iterable2.empty()];
          }
          consumed.push(next.value);
        }
        return [consumed, { [Symbol.iterator]() {
          return iterator;
        } }];
      }
      Iterable2.consume = consume;
    })(Iterable || (Iterable = {}));
  }
});

// node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
function setDisposableTracker(tracker) {
  disposableTracker = tracker;
}
function trackDisposable(x) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
  return x;
}
function markAsDisposed(disposable) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
}
function setParentOfDisposable(child, parent) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
}
function setParentOfDisposables(children, parent) {
  if (!disposableTracker) {
    return;
  }
  for (const child of children) {
    disposableTracker.setParent(child, parent);
  }
}
function markAsSingleton(singleton) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);
  return singleton;
}
function isDisposable(thing) {
  return typeof thing.dispose === "function" && thing.dispose.length === 0;
}
function dispose(arg) {
  if (Iterable.is(arg)) {
    const errors = [];
    for (const d of arg) {
      if (d) {
        try {
          d.dispose();
        } catch (e) {
          errors.push(e);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    } else if (errors.length > 1) {
      throw new AggregateError(errors, "Encountered errors while disposing of store");
    }
    return Array.isArray(arg) ? [] : arg;
  } else if (arg) {
    arg.dispose();
    return arg;
  }
}
function combinedDisposable(...disposables) {
  const parent = toDisposable(() => dispose(disposables));
  setParentOfDisposables(disposables, parent);
  return parent;
}
function toDisposable(fn) {
  const self2 = trackDisposable({
    dispose: once(() => {
      markAsDisposed(self2);
      fn();
    })
  });
  return self2;
}
var __awaiter, TRACK_DISPOSABLES, disposableTracker, DisposableStore, Disposable, MutableDisposable, RefCountedDisposable, ReferenceCollection, AsyncReferenceCollection, ImmortalReference, DisposableMap;
var init_lifecycle = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"() {
    init_functional();
    init_iterator();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    TRACK_DISPOSABLES = false;
    disposableTracker = null;
    if (TRACK_DISPOSABLES) {
      const __is_disposable_tracked__ = "__is_disposable_tracked__";
      setDisposableTracker(new class {
        trackDisposable(x) {
          const stack = new Error("Potentially leaked disposable").stack;
          setTimeout(() => {
            if (!x[__is_disposable_tracked__]) {
              console.log(stack);
            }
          }, 3e3);
        }
        setParent(child, parent) {
          if (child && child !== Disposable.None) {
            try {
              child[__is_disposable_tracked__] = true;
            } catch (_a4) {
            }
          }
        }
        markAsDisposed(disposable) {
          if (disposable && disposable !== Disposable.None) {
            try {
              disposable[__is_disposable_tracked__] = true;
            } catch (_a4) {
            }
          }
        }
        markAsSingleton(disposable) {
        }
      }());
    }
    DisposableStore = class _DisposableStore {
      constructor() {
        this._toDispose = /* @__PURE__ */ new Set();
        this._isDisposed = false;
        trackDisposable(this);
      }
      /**
       * Dispose of all registered disposables and mark this object as disposed.
       *
       * Any future disposables added to this object will be disposed of on `add`.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        markAsDisposed(this);
        this._isDisposed = true;
        this.clear();
      }
      /**
       * @return `true` if this object has been disposed of.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of all registered disposables but do not mark this object as disposed.
       */
      clear() {
        if (this._toDispose.size === 0) {
          return;
        }
        try {
          dispose(this._toDispose);
        } finally {
          this._toDispose.clear();
        }
      }
      /**
       * Add a new {@link IDisposable disposable} to the collection.
       */
      add(o) {
        if (!o) {
          return o;
        }
        if (o === this) {
          throw new Error("Cannot register a disposable on itself!");
        }
        setParentOfDisposable(o, this);
        if (this._isDisposed) {
          if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
            console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
          }
        } else {
          this._toDispose.add(o);
        }
        return o;
      }
    };
    DisposableStore.DISABLE_DISPOSED_WARNING = false;
    Disposable = class {
      constructor() {
        this._store = new DisposableStore();
        trackDisposable(this);
        setParentOfDisposable(this._store, this);
      }
      dispose() {
        markAsDisposed(this);
        this._store.dispose();
      }
      /**
       * Adds `o` to the collection of disposables managed by this object.
       */
      _register(o) {
        if (o === this) {
          throw new Error("Cannot register a disposable on itself!");
        }
        return this._store.add(o);
      }
    };
    Disposable.None = Object.freeze({ dispose() {
    } });
    MutableDisposable = class {
      constructor() {
        this._isDisposed = false;
        trackDisposable(this);
      }
      get value() {
        return this._isDisposed ? void 0 : this._value;
      }
      set value(value) {
        var _a4;
        if (this._isDisposed || value === this._value) {
          return;
        }
        (_a4 = this._value) === null || _a4 === void 0 ? void 0 : _a4.dispose();
        if (value) {
          setParentOfDisposable(value, this);
        }
        this._value = value;
      }
      /**
       * Resets the stored value and disposed of the previously stored value.
       */
      clear() {
        this.value = void 0;
      }
      dispose() {
        var _a4;
        this._isDisposed = true;
        markAsDisposed(this);
        (_a4 = this._value) === null || _a4 === void 0 ? void 0 : _a4.dispose();
        this._value = void 0;
      }
      /**
       * Clears the value, but does not dispose it.
       * The old value is returned.
      */
      clearAndLeak() {
        const oldValue = this._value;
        this._value = void 0;
        if (oldValue) {
          setParentOfDisposable(oldValue, null);
        }
        return oldValue;
      }
    };
    RefCountedDisposable = class {
      constructor(_disposable) {
        this._disposable = _disposable;
        this._counter = 1;
      }
      acquire() {
        this._counter++;
        return this;
      }
      release() {
        if (--this._counter === 0) {
          this._disposable.dispose();
        }
        return this;
      }
    };
    ReferenceCollection = class {
      constructor() {
        this.references = /* @__PURE__ */ new Map();
      }
      acquire(key, ...args) {
        let reference = this.references.get(key);
        if (!reference) {
          reference = { counter: 0, object: this.createReferencedObject(key, ...args) };
          this.references.set(key, reference);
        }
        const { object } = reference;
        const dispose2 = once(() => {
          if (--reference.counter === 0) {
            this.destroyReferencedObject(key, reference.object);
            this.references.delete(key);
          }
        });
        reference.counter++;
        return { object, dispose: dispose2 };
      }
    };
    AsyncReferenceCollection = class {
      constructor(referenceCollection) {
        this.referenceCollection = referenceCollection;
      }
      acquire(key, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
          const ref = this.referenceCollection.acquire(key, ...args);
          try {
            const object = yield ref.object;
            return {
              object,
              dispose: () => ref.dispose()
            };
          } catch (error) {
            ref.dispose();
            throw error;
          }
        });
      }
    };
    ImmortalReference = class {
      constructor(object) {
        this.object = object;
      }
      dispose() {
      }
    };
    DisposableMap = class {
      constructor() {
        this._store = /* @__PURE__ */ new Map();
        this._isDisposed = false;
        trackDisposable(this);
      }
      /**
       * Disposes of all stored values and mark this object as disposed.
       *
       * Trying to use this object after it has been disposed of is an error.
       */
      dispose() {
        markAsDisposed(this);
        this._isDisposed = true;
        this.clearAndDisposeAll();
      }
      /**
       * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
       */
      clearAndDisposeAll() {
        if (!this._store.size) {
          return;
        }
        try {
          dispose(this._store.values());
        } finally {
          this._store.clear();
        }
      }
      has(key) {
        return this._store.has(key);
      }
      get(key) {
        return this._store.get(key);
      }
      set(key, value, skipDisposeOnOverwrite = false) {
        var _a4;
        if (this._isDisposed) {
          console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack);
        }
        if (!skipDisposeOnOverwrite) {
          (_a4 = this._store.get(key)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
        }
        this._store.set(key, value);
      }
      /**
       * Delete the value stored for `key` from this map and also dispose of it.
       */
      deleteAndDispose(key) {
        var _a4;
        (_a4 = this._store.get(key)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
        this._store.delete(key);
      }
      [Symbol.iterator]() {
        return this._store[Symbol.iterator]();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/linkedList.js
var Node, LinkedList;
var init_linkedList = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/linkedList.js"() {
    Node = class _Node {
      constructor(element) {
        this.element = element;
        this.next = _Node.Undefined;
        this.prev = _Node.Undefined;
      }
    };
    Node.Undefined = new Node(void 0);
    LinkedList = class {
      constructor() {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
      }
      get size() {
        return this._size;
      }
      isEmpty() {
        return this._first === Node.Undefined;
      }
      clear() {
        let node = this._first;
        while (node !== Node.Undefined) {
          const next = node.next;
          node.prev = Node.Undefined;
          node.next = Node.Undefined;
          node = next;
        }
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
      }
      unshift(element) {
        return this._insert(element, false);
      }
      push(element) {
        return this._insert(element, true);
      }
      _insert(element, atTheEnd) {
        const newNode = new Node(element);
        if (this._first === Node.Undefined) {
          this._first = newNode;
          this._last = newNode;
        } else if (atTheEnd) {
          const oldLast = this._last;
          this._last = newNode;
          newNode.prev = oldLast;
          oldLast.next = newNode;
        } else {
          const oldFirst = this._first;
          this._first = newNode;
          newNode.next = oldFirst;
          oldFirst.prev = newNode;
        }
        this._size += 1;
        let didRemove = false;
        return () => {
          if (!didRemove) {
            didRemove = true;
            this._remove(newNode);
          }
        };
      }
      shift() {
        if (this._first === Node.Undefined) {
          return void 0;
        } else {
          const res = this._first.element;
          this._remove(this._first);
          return res;
        }
      }
      pop() {
        if (this._last === Node.Undefined) {
          return void 0;
        } else {
          const res = this._last.element;
          this._remove(this._last);
          return res;
        }
      }
      _remove(node) {
        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
          const anchor = node.prev;
          anchor.next = node.next;
          node.next.prev = anchor;
        } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
          this._first = Node.Undefined;
          this._last = Node.Undefined;
        } else if (node.next === Node.Undefined) {
          this._last = this._last.prev;
          this._last.next = Node.Undefined;
        } else if (node.prev === Node.Undefined) {
          this._first = this._first.next;
          this._first.prev = Node.Undefined;
        }
        this._size -= 1;
      }
      *[Symbol.iterator]() {
        let node = this._first;
        while (node !== Node.Undefined) {
          yield node.element;
          node = node.next;
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
var hasPerformanceNow, StopWatch;
var init_stopwatch = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/stopwatch.js"() {
    hasPerformanceNow = globalThis.performance && typeof globalThis.performance.now === "function";
    StopWatch = class _StopWatch {
      static create(highResolution) {
        return new _StopWatch(highResolution);
      }
      constructor(highResolution) {
        this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
        this._startTime = this._now();
        this._stopTime = -1;
      }
      stop() {
        this._stopTime = this._now();
      }
      reset() {
        this._startTime = this._now();
        this._stopTime = -1;
      }
      elapsed() {
        if (this._stopTime !== -1) {
          return this._stopTime - this._startTime;
        }
        return this._now() - this._startTime;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/event.js
var __awaiter2, _enableDisposeWithListenerWarning, _enableSnapshotPotentialLeakWarning, Event, EventProfiling, _globalLeakWarningThreshold, LeakageMonitor, Stacktrace, id, UniqueContainer, compactionThreshold, forEachListener, Emitter, createEventDeliveryQueue, EventDeliveryQueuePrivate, AsyncEmitter, PauseableEmitter, DebounceEmitter, MicrotaskEmitter, EventMultiplexer, EventBufferer, Relay;
var init_event = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/event.js"() {
    init_errors();
    init_functional();
    init_lifecycle();
    init_linkedList();
    init_stopwatch();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    _enableDisposeWithListenerWarning = false;
    _enableSnapshotPotentialLeakWarning = false;
    (function(Event2) {
      Event2.None = () => Disposable.None;
      function _addLeakageTraceLogic(options) {
        if (_enableSnapshotPotentialLeakWarning) {
          const { onDidAddListener: origListenerDidAdd } = options;
          const stack = Stacktrace.create();
          let count2 = 0;
          options.onDidAddListener = () => {
            if (++count2 === 2) {
              console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
              stack.print();
            }
            origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
          };
        }
      }
      function defer(event, disposable) {
        return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
      }
      Event2.defer = defer;
      function once2(event) {
        return (listener, thisArgs = null, disposables) => {
          let didFire = false;
          let result = void 0;
          result = event((e) => {
            if (didFire) {
              return;
            } else if (result) {
              result.dispose();
            } else {
              didFire = true;
            }
            return listener.call(thisArgs, e);
          }, null, disposables);
          if (didFire) {
            result.dispose();
          }
          return result;
        };
      }
      Event2.once = once2;
      function map(event, map2, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables), disposable);
      }
      Event2.map = map;
      function forEach(event, each, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event((i) => {
          each(i);
          listener.call(thisArgs, i);
        }, null, disposables), disposable);
      }
      Event2.forEach = forEach;
      function filter2(event, filter3, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event((e) => filter3(e) && listener.call(thisArgs, e), null, disposables), disposable);
      }
      Event2.filter = filter2;
      function signal(event) {
        return event;
      }
      Event2.signal = signal;
      function any(...events) {
        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
      }
      Event2.any = any;
      function reduce(event, merge, initial, disposable) {
        let output = initial;
        return map(event, (e) => {
          output = merge(output, e);
          return output;
        }, disposable);
      }
      Event2.reduce = reduce;
      function snapshot(event, disposable) {
        let listener;
        const options = {
          onWillAddFirstListener() {
            listener = event(emitter.fire, emitter);
          },
          onDidRemoveLastListener() {
            listener === null || listener === void 0 ? void 0 : listener.dispose();
          }
        };
        if (!disposable) {
          _addLeakageTraceLogic(options);
        }
        const emitter = new Emitter(options);
        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
        return emitter.event;
      }
      function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
        let subscription;
        let output = void 0;
        let handle = void 0;
        let numDebouncedCalls = 0;
        let doFire;
        const options = {
          leakWarningThreshold,
          onWillAddFirstListener() {
            subscription = event((cur) => {
              numDebouncedCalls++;
              output = merge(output, cur);
              if (leading && !handle) {
                emitter.fire(output);
                output = void 0;
              }
              doFire = () => {
                const _output = output;
                output = void 0;
                handle = void 0;
                if (!leading || numDebouncedCalls > 1) {
                  emitter.fire(_output);
                }
                numDebouncedCalls = 0;
              };
              if (typeof delay === "number") {
                clearTimeout(handle);
                handle = setTimeout(doFire, delay);
              } else {
                if (handle === void 0) {
                  handle = 0;
                  queueMicrotask(doFire);
                }
              }
            });
          },
          onWillRemoveListener() {
            if (flushOnListenerRemove && numDebouncedCalls > 0) {
              doFire === null || doFire === void 0 ? void 0 : doFire();
            }
          },
          onDidRemoveLastListener() {
            doFire = void 0;
            subscription.dispose();
          }
        };
        if (!disposable) {
          _addLeakageTraceLogic(options);
        }
        const emitter = new Emitter(options);
        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
        return emitter.event;
      }
      Event2.debounce = debounce;
      function accumulate(event, delay = 0, disposable) {
        return Event2.debounce(event, (last, e) => {
          if (!last) {
            return [e];
          }
          last.push(e);
          return last;
        }, delay, void 0, true, void 0, disposable);
      }
      Event2.accumulate = accumulate;
      function latch(event, equals3 = (a, b) => a === b, disposable) {
        let firstCall = true;
        let cache;
        return filter2(event, (value) => {
          const shouldEmit = firstCall || !equals3(value, cache);
          firstCall = false;
          cache = value;
          return shouldEmit;
        }, disposable);
      }
      Event2.latch = latch;
      function split(event, isT, disposable) {
        return [
          Event2.filter(event, isT, disposable),
          Event2.filter(event, (e) => !isT(e), disposable)
        ];
      }
      Event2.split = split;
      function buffer(event, flushAfterTimeout = false, _buffer = []) {
        let buffer2 = _buffer.slice();
        let listener = event((e) => {
          if (buffer2) {
            buffer2.push(e);
          } else {
            emitter.fire(e);
          }
        });
        const flush = () => {
          buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.forEach((e) => emitter.fire(e));
          buffer2 = null;
        };
        const emitter = new Emitter({
          onWillAddFirstListener() {
            if (!listener) {
              listener = event((e) => emitter.fire(e));
            }
          },
          onDidAddFirstListener() {
            if (buffer2) {
              if (flushAfterTimeout) {
                setTimeout(flush);
              } else {
                flush();
              }
            }
          },
          onDidRemoveLastListener() {
            if (listener) {
              listener.dispose();
            }
            listener = null;
          }
        });
        return emitter.event;
      }
      Event2.buffer = buffer;
      class ChainableEvent {
        constructor(event) {
          this.event = event;
          this.disposables = new DisposableStore();
        }
        /** @see {@link Event.map} */
        map(fn) {
          return new ChainableEvent(map(this.event, fn, this.disposables));
        }
        /** @see {@link Event.forEach} */
        forEach(fn) {
          return new ChainableEvent(forEach(this.event, fn, this.disposables));
        }
        filter(fn) {
          return new ChainableEvent(filter2(this.event, fn, this.disposables));
        }
        /** @see {@link Event.reduce} */
        reduce(merge, initial) {
          return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));
        }
        /** @see {@link Event.reduce} */
        latch() {
          return new ChainableEvent(latch(this.event, void 0, this.disposables));
        }
        debounce(merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold) {
          return new ChainableEvent(debounce(this.event, merge, delay, leading, flushOnListenerRemove, leakWarningThreshold, this.disposables));
        }
        /**
         * Attach a listener to the event.
         */
        on(listener, thisArgs, disposables) {
          return this.event(listener, thisArgs, disposables);
        }
        /** @see {@link Event.once} */
        once(listener, thisArgs, disposables) {
          return once2(this.event)(listener, thisArgs, disposables);
        }
        dispose() {
          this.disposables.dispose();
        }
      }
      function chain(event) {
        return new ChainableEvent(event);
      }
      Event2.chain = chain;
      function fromNodeEventEmitter(emitter, eventName, map2 = (id2) => id2) {
        const fn = (...args) => result.fire(map2(...args));
        const onFirstListenerAdd = () => emitter.on(eventName, fn);
        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
        return result.event;
      }
      Event2.fromNodeEventEmitter = fromNodeEventEmitter;
      function fromDOMEventEmitter(emitter, eventName, map2 = (id2) => id2) {
        const fn = (...args) => result.fire(map2(...args));
        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
        return result.event;
      }
      Event2.fromDOMEventEmitter = fromDOMEventEmitter;
      function toPromise(event) {
        return new Promise((resolve2) => once2(event)(resolve2));
      }
      Event2.toPromise = toPromise;
      function fromPromise(promise) {
        const result = new Emitter();
        promise.then((res) => {
          result.fire(res);
        }, () => {
          result.fire(void 0);
        }).finally(() => {
          result.dispose();
        });
        return result.event;
      }
      Event2.fromPromise = fromPromise;
      function runAndSubscribe(event, handler) {
        handler(void 0);
        return event((e) => handler(e));
      }
      Event2.runAndSubscribe = runAndSubscribe;
      function runAndSubscribeWithStore(event, handler) {
        let store = null;
        function run(e) {
          store === null || store === void 0 ? void 0 : store.dispose();
          store = new DisposableStore();
          handler(e, store);
        }
        run(void 0);
        const disposable = event((e) => run(e));
        return toDisposable(() => {
          disposable.dispose();
          store === null || store === void 0 ? void 0 : store.dispose();
        });
      }
      Event2.runAndSubscribeWithStore = runAndSubscribeWithStore;
      class EmitterObserver {
        constructor(_observable, store) {
          this._observable = _observable;
          this._counter = 0;
          this._hasChanged = false;
          const options = {
            onWillAddFirstListener: () => {
              _observable.addObserver(this);
            },
            onDidRemoveLastListener: () => {
              _observable.removeObserver(this);
            }
          };
          if (!store) {
            _addLeakageTraceLogic(options);
          }
          this.emitter = new Emitter(options);
          if (store) {
            store.add(this.emitter);
          }
        }
        beginUpdate(_observable) {
          this._counter++;
        }
        handlePossibleChange(_observable) {
        }
        handleChange(_observable, _change) {
          this._hasChanged = true;
        }
        endUpdate(_observable) {
          this._counter--;
          if (this._counter === 0) {
            this._observable.reportChanges();
            if (this._hasChanged) {
              this._hasChanged = false;
              this.emitter.fire(this._observable.get());
            }
          }
        }
      }
      function fromObservable(obs, store) {
        const observer = new EmitterObserver(obs, store);
        return observer.emitter.event;
      }
      Event2.fromObservable = fromObservable;
      function fromObservableLight(observable) {
        return (listener) => {
          let count2 = 0;
          let didChange = false;
          const observer = {
            beginUpdate() {
              count2++;
            },
            endUpdate() {
              count2--;
              if (count2 === 0) {
                observable.reportChanges();
                if (didChange) {
                  didChange = false;
                  listener();
                }
              }
            },
            handlePossibleChange() {
            },
            handleChange() {
              didChange = true;
            }
          };
          observable.addObserver(observer);
          observable.reportChanges();
          return {
            dispose() {
              observable.removeObserver(observer);
            }
          };
        };
      }
      Event2.fromObservableLight = fromObservableLight;
    })(Event || (Event = {}));
    EventProfiling = class _EventProfiling {
      constructor(name) {
        this.listenerCount = 0;
        this.invocationCount = 0;
        this.elapsedOverall = 0;
        this.durations = [];
        this.name = `${name}_${_EventProfiling._idPool++}`;
        _EventProfiling.all.add(this);
      }
      start(listenerCount) {
        this._stopWatch = new StopWatch();
        this.listenerCount = listenerCount;
      }
      stop() {
        if (this._stopWatch) {
          const elapsed = this._stopWatch.elapsed();
          this.durations.push(elapsed);
          this.elapsedOverall += elapsed;
          this.invocationCount += 1;
          this._stopWatch = void 0;
        }
      }
    };
    EventProfiling.all = /* @__PURE__ */ new Set();
    EventProfiling._idPool = 0;
    _globalLeakWarningThreshold = -1;
    LeakageMonitor = class {
      constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
        this.threshold = threshold;
        this.name = name;
        this._warnCountdown = 0;
      }
      dispose() {
        var _a4;
        (_a4 = this._stacks) === null || _a4 === void 0 ? void 0 : _a4.clear();
      }
      check(stack, listenerCount) {
        const threshold = this.threshold;
        if (threshold <= 0 || listenerCount < threshold) {
          return void 0;
        }
        if (!this._stacks) {
          this._stacks = /* @__PURE__ */ new Map();
        }
        const count2 = this._stacks.get(stack.value) || 0;
        this._stacks.set(stack.value, count2 + 1);
        this._warnCountdown -= 1;
        if (this._warnCountdown <= 0) {
          this._warnCountdown = threshold * 0.5;
          let topStack;
          let topCount = 0;
          for (const [stack2, count3] of this._stacks) {
            if (!topStack || topCount < count3) {
              topStack = stack2;
              topCount = count3;
            }
          }
          console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
          console.warn(topStack);
        }
        return () => {
          const count3 = this._stacks.get(stack.value) || 0;
          this._stacks.set(stack.value, count3 - 1);
        };
      }
    };
    Stacktrace = class _Stacktrace {
      static create() {
        var _a4;
        return new _Stacktrace((_a4 = new Error().stack) !== null && _a4 !== void 0 ? _a4 : "");
      }
      constructor(value) {
        this.value = value;
      }
      print() {
        console.warn(this.value.split("\n").slice(2).join("\n"));
      }
    };
    id = 0;
    UniqueContainer = class {
      constructor(value) {
        this.value = value;
        this.id = id++;
      }
    };
    compactionThreshold = 2;
    forEachListener = (listeners, fn) => {
      if (listeners instanceof UniqueContainer) {
        fn(listeners);
      } else {
        for (let i = 0; i < listeners.length; i++) {
          const l = listeners[i];
          if (l) {
            fn(l);
          }
        }
      }
    };
    Emitter = class {
      constructor(options) {
        var _a4, _b2, _c2, _d, _e;
        this._size = 0;
        this._options = options;
        this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.leakWarningThreshold) ? new LeakageMonitor((_c2 = (_b2 = this._options) === null || _b2 === void 0 ? void 0 : _b2.leakWarningThreshold) !== null && _c2 !== void 0 ? _c2 : _globalLeakWarningThreshold) : void 0;
        this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : void 0;
        this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;
      }
      dispose() {
        var _a4, _b2, _c2, _d;
        if (!this._disposed) {
          this._disposed = true;
          if (((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) === this) {
            this._deliveryQueue.reset();
          }
          if (this._listeners) {
            if (_enableDisposeWithListenerWarning) {
              const listeners = this._listeners;
              queueMicrotask(() => {
                forEachListener(listeners, (l) => {
                  var _a5;
                  return (_a5 = l.stack) === null || _a5 === void 0 ? void 0 : _a5.print();
                });
              });
            }
            this._listeners = void 0;
            this._size = 0;
          }
          (_c2 = (_b2 = this._options) === null || _b2 === void 0 ? void 0 : _b2.onDidRemoveLastListener) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
          (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
        }
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        var _a4;
        (_a4 = this._event) !== null && _a4 !== void 0 ? _a4 : this._event = (callback, thisArgs, disposables) => {
          var _a5, _b2, _c2, _d, _e;
          if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {
            console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);
            return Disposable.None;
          }
          if (this._disposed) {
            return Disposable.None;
          }
          if (thisArgs) {
            callback = callback.bind(thisArgs);
          }
          const contained = new UniqueContainer(callback);
          let removeMonitor;
          let stack;
          if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
            contained.stack = Stacktrace.create();
            removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
          }
          if (_enableDisposeWithListenerWarning) {
            contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
          }
          if (!this._listeners) {
            (_b2 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.onWillAddFirstListener) === null || _b2 === void 0 ? void 0 : _b2.call(_a5, this);
            this._listeners = contained;
            (_d = (_c2 = this._options) === null || _c2 === void 0 ? void 0 : _c2.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c2, this);
          } else if (this._listeners instanceof UniqueContainer) {
            (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : this._deliveryQueue = new EventDeliveryQueuePrivate();
            this._listeners = [this._listeners, contained];
          } else {
            this._listeners.push(contained);
          }
          this._size++;
          const result = toDisposable(() => {
            removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();
            this._removeListener(contained);
          });
          if (disposables instanceof DisposableStore) {
            disposables.add(result);
          } else if (Array.isArray(disposables)) {
            disposables.push(result);
          }
          return result;
        };
        return this._event;
      }
      _removeListener(listener) {
        var _a4, _b2, _c2, _d;
        (_b2 = (_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onWillRemoveListener) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, this);
        if (!this._listeners) {
          return;
        }
        if (this._size === 1) {
          this._listeners = void 0;
          (_d = (_c2 = this._options) === null || _c2 === void 0 ? void 0 : _c2.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c2, this);
          this._size = 0;
          return;
        }
        const listeners = this._listeners;
        const index2 = listeners.indexOf(listener);
        if (index2 === -1) {
          console.log("disposed?", this._disposed);
          console.log("size?", this._size);
          console.log("arr?", JSON.stringify(this._listeners));
          throw new Error("Attempted to dispose unknown listener");
        }
        this._size--;
        listeners[index2] = void 0;
        const adjustDeliveryQueue = this._deliveryQueue.current === this;
        if (this._size * compactionThreshold <= listeners.length) {
          let n = 0;
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]) {
              listeners[n++] = listeners[i];
            } else if (adjustDeliveryQueue) {
              this._deliveryQueue.end--;
              if (n < this._deliveryQueue.i) {
                this._deliveryQueue.i--;
              }
            }
          }
          listeners.length = n;
        }
      }
      _deliver(listener, value) {
        var _a4;
        if (!listener) {
          return;
        }
        const errorHandler2 = ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onListenerError) || onUnexpectedError;
        if (!errorHandler2) {
          listener.value(value);
          return;
        }
        try {
          listener.value(value);
        } catch (e) {
          errorHandler2(e);
        }
      }
      /** Delivers items in the queue. Assumes the queue is ready to go. */
      _deliverQueue(dq) {
        const listeners = dq.current._listeners;
        while (dq.i < dq.end) {
          this._deliver(listeners[dq.i++], dq.value);
        }
        dq.reset();
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        var _a4, _b2, _c2, _d;
        if ((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) {
          this._deliverQueue(this._deliveryQueue);
          (_b2 = this._perfMon) === null || _b2 === void 0 ? void 0 : _b2.stop();
        }
        (_c2 = this._perfMon) === null || _c2 === void 0 ? void 0 : _c2.start(this._size);
        if (!this._listeners) {
        } else if (this._listeners instanceof UniqueContainer) {
          this._deliver(this._listeners, event);
        } else {
          const dq = this._deliveryQueue;
          dq.enqueue(this, event, this._listeners.length);
          this._deliverQueue(dq);
        }
        (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();
      }
      hasListeners() {
        return this._size > 0;
      }
    };
    createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();
    EventDeliveryQueuePrivate = class {
      constructor() {
        this.i = -1;
        this.end = 0;
      }
      enqueue(emitter, value, end) {
        this.i = 0;
        this.end = end;
        this.current = emitter;
        this.value = value;
      }
      reset() {
        this.i = this.end;
        this.current = void 0;
        this.value = void 0;
      }
    };
    AsyncEmitter = class extends Emitter {
      fireAsync(data, token, promiseJoin) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this._listeners) {
            return;
          }
          if (!this._asyncDeliveryQueue) {
            this._asyncDeliveryQueue = new LinkedList();
          }
          forEachListener(this._listeners, (listener) => this._asyncDeliveryQueue.push([listener.value, data]));
          while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {
            const [listener, data2] = this._asyncDeliveryQueue.shift();
            const thenables = [];
            const event = Object.assign(Object.assign({}, data2), { token, waitUntil: (p) => {
              if (Object.isFrozen(thenables)) {
                throw new Error("waitUntil can NOT be called asynchronous");
              }
              if (promiseJoin) {
                p = promiseJoin(p, listener);
              }
              thenables.push(p);
            } });
            try {
              listener(event);
            } catch (e) {
              onUnexpectedError(e);
              continue;
            }
            Object.freeze(thenables);
            yield Promise.allSettled(thenables).then((values) => {
              for (const value of values) {
                if (value.status === "rejected") {
                  onUnexpectedError(value.reason);
                }
              }
            });
          }
        });
      }
    };
    PauseableEmitter = class extends Emitter {
      get isPaused() {
        return this._isPaused !== 0;
      }
      constructor(options) {
        super(options);
        this._isPaused = 0;
        this._eventQueue = new LinkedList();
        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;
      }
      pause() {
        this._isPaused++;
      }
      resume() {
        if (this._isPaused !== 0 && --this._isPaused === 0) {
          if (this._mergeFn) {
            if (this._eventQueue.size > 0) {
              const events = Array.from(this._eventQueue);
              this._eventQueue.clear();
              super.fire(this._mergeFn(events));
            }
          } else {
            while (!this._isPaused && this._eventQueue.size !== 0) {
              super.fire(this._eventQueue.shift());
            }
          }
        }
      }
      fire(event) {
        if (this._size) {
          if (this._isPaused !== 0) {
            this._eventQueue.push(event);
          } else {
            super.fire(event);
          }
        }
      }
    };
    DebounceEmitter = class extends PauseableEmitter {
      constructor(options) {
        var _a4;
        super(options);
        this._delay = (_a4 = options.delay) !== null && _a4 !== void 0 ? _a4 : 100;
      }
      fire(event) {
        if (!this._handle) {
          this.pause();
          this._handle = setTimeout(() => {
            this._handle = void 0;
            this.resume();
          }, this._delay);
        }
        super.fire(event);
      }
    };
    MicrotaskEmitter = class extends Emitter {
      constructor(options) {
        super(options);
        this._queuedEvents = [];
        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;
      }
      fire(event) {
        if (!this.hasListeners()) {
          return;
        }
        this._queuedEvents.push(event);
        if (this._queuedEvents.length === 1) {
          queueMicrotask(() => {
            if (this._mergeFn) {
              super.fire(this._mergeFn(this._queuedEvents));
            } else {
              this._queuedEvents.forEach((e) => super.fire(e));
            }
            this._queuedEvents = [];
          });
        }
      }
    };
    EventMultiplexer = class {
      constructor() {
        this.hasListeners = false;
        this.events = [];
        this.emitter = new Emitter({
          onWillAddFirstListener: () => this.onFirstListenerAdd(),
          onDidRemoveLastListener: () => this.onLastListenerRemove()
        });
      }
      get event() {
        return this.emitter.event;
      }
      add(event) {
        const e = { event, listener: null };
        this.events.push(e);
        if (this.hasListeners) {
          this.hook(e);
        }
        const dispose2 = () => {
          if (this.hasListeners) {
            this.unhook(e);
          }
          const idx = this.events.indexOf(e);
          this.events.splice(idx, 1);
        };
        return toDisposable(once(dispose2));
      }
      onFirstListenerAdd() {
        this.hasListeners = true;
        this.events.forEach((e) => this.hook(e));
      }
      onLastListenerRemove() {
        this.hasListeners = false;
        this.events.forEach((e) => this.unhook(e));
      }
      hook(e) {
        e.listener = e.event((r) => this.emitter.fire(r));
      }
      unhook(e) {
        if (e.listener) {
          e.listener.dispose();
        }
        e.listener = null;
      }
      dispose() {
        this.emitter.dispose();
      }
    };
    EventBufferer = class {
      constructor() {
        this.buffers = [];
      }
      wrapEvent(event) {
        return (listener, thisArgs, disposables) => {
          return event((i) => {
            const buffer = this.buffers[this.buffers.length - 1];
            if (buffer) {
              buffer.push(() => listener.call(thisArgs, i));
            } else {
              listener.call(thisArgs, i);
            }
          }, void 0, disposables);
        };
      }
      bufferEvents(fn) {
        const buffer = [];
        this.buffers.push(buffer);
        const r = fn();
        this.buffers.pop();
        buffer.forEach((flush) => flush());
        return r;
      }
    };
    Relay = class {
      constructor() {
        this.listening = false;
        this.inputEvent = Event.None;
        this.inputEventListener = Disposable.None;
        this.emitter = new Emitter({
          onDidAddFirstListener: () => {
            this.listening = true;
            this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
          },
          onDidRemoveLastListener: () => {
            this.listening = false;
            this.inputEventListener.dispose();
          }
        });
        this.event = this.emitter.event;
      }
      set input(event) {
        this.inputEvent = event;
        if (this.listening) {
          this.inputEventListener.dispose();
          this.inputEventListener = event(this.emitter.fire, this.emitter);
        }
      }
      dispose() {
        this.inputEventListener.dispose();
        this.emitter.dispose();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/nls.js
function _format(message, args) {
  let result;
  if (args.length === 0) {
    result = message;
  } else {
    result = message.replace(/\{(\d+)\}/g, (match, rest) => {
      const index2 = rest[0];
      const arg = args[index2];
      let result2 = match;
      if (typeof arg === "string") {
        result2 = arg;
      } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
        result2 = String(arg);
      }
      return result2;
    });
  }
  if (isPseudo) {
    result = "［" + result.replace(/[aouei]/g, "$&$&") + "］";
  }
  return result;
}
function localize(data, message, ...args) {
  return _format(message, args);
}
function getConfiguredDefaultLocale(_) {
  return void 0;
}
var isPseudo;
var init_nls = __esm({
  "node_modules/monaco-editor/esm/vs/nls.js"() {
    isPseudo = typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
  }
});

// node_modules/monaco-editor/esm/vs/base/common/platform.js
function PlatformToString(platform3) {
  switch (platform3) {
    case 0:
      return "Web";
    case 1:
      return "Mac";
    case 2:
      return "Linux";
    case 3:
      return "Windows";
  }
}
function isLittleEndian() {
  if (!_isLittleEndianComputed) {
    _isLittleEndianComputed = true;
    const test = new Uint8Array(2);
    test[0] = 1;
    test[1] = 2;
    const view = new Uint16Array(test.buffer);
    _isLittleEndian = view[0] === (2 << 8) + 1;
  }
  return _isLittleEndian;
}
var _a, LANGUAGE_DEFAULT, _isWindows, _isMacintosh, _isLinux, _isLinuxSnap, _isNative, _isWeb, _isElectron, _isIOS, _isCI, _isMobile, _locale, _language, _platformLocale, _translationsConfigFile, _userAgent, globals, nodeProcess, isElectronProcess, isElectronRenderer, _platform, isWindows, isMacintosh, isLinux, isNative, isWeb, isWebWorker, isIOS, isMobile, platform, userAgent, language, Language, setTimeout0IsFaster, setTimeout0, OS, _isLittleEndian, _isLittleEndianComputed, isChrome, isFirefox, isSafari, isEdge, isAndroid;
var init_platform = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/platform.js"() {
    init_nls();
    LANGUAGE_DEFAULT = "en";
    _isWindows = false;
    _isMacintosh = false;
    _isLinux = false;
    _isLinuxSnap = false;
    _isNative = false;
    _isWeb = false;
    _isElectron = false;
    _isIOS = false;
    _isCI = false;
    _isMobile = false;
    _locale = void 0;
    _language = LANGUAGE_DEFAULT;
    _platformLocale = LANGUAGE_DEFAULT;
    _translationsConfigFile = void 0;
    _userAgent = void 0;
    globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
    nodeProcess = void 0;
    if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
      nodeProcess = globals.vscode.process;
    } else if (typeof process !== "undefined") {
      nodeProcess = process;
    }
    isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === "string";
    isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
    if (typeof navigator === "object" && !isElectronRenderer) {
      _userAgent = navigator.userAgent;
      _isWindows = _userAgent.indexOf("Windows") >= 0;
      _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
      _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
      _isLinux = _userAgent.indexOf("Linux") >= 0;
      _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf("Mobi")) >= 0;
      _isWeb = true;
      const configuredLocale = getConfiguredDefaultLocale(
        // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
        // to ensure that the NLS AMD Loader plugin has been loaded and configured.
        // This is because the loader plugin decides what the default locale is based on
        // how it's able to resolve the strings.
        localize({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_")
      );
      _locale = configuredLocale || LANGUAGE_DEFAULT;
      _language = _locale;
      _platformLocale = navigator.language;
    } else if (typeof nodeProcess === "object") {
      _isWindows = nodeProcess.platform === "win32";
      _isMacintosh = nodeProcess.platform === "darwin";
      _isLinux = nodeProcess.platform === "linux";
      _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
      _isElectron = isElectronProcess;
      _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
      _locale = LANGUAGE_DEFAULT;
      _language = LANGUAGE_DEFAULT;
      const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
      if (rawNlsConfig) {
        try {
          const nlsConfig = JSON.parse(rawNlsConfig);
          const resolved = nlsConfig.availableLanguages["*"];
          _locale = nlsConfig.locale;
          _platformLocale = nlsConfig.osLocale;
          _language = resolved ? resolved : LANGUAGE_DEFAULT;
          _translationsConfigFile = nlsConfig._translationsConfigFile;
        } catch (e) {
        }
      }
      _isNative = true;
    } else {
      console.error("Unable to resolve platform.");
    }
    _platform = 0;
    if (_isMacintosh) {
      _platform = 1;
    } else if (_isWindows) {
      _platform = 3;
    } else if (_isLinux) {
      _platform = 2;
    }
    isWindows = _isWindows;
    isMacintosh = _isMacintosh;
    isLinux = _isLinux;
    isNative = _isNative;
    isWeb = _isWeb;
    isWebWorker = _isWeb && typeof globals.importScripts === "function";
    isIOS = _isIOS;
    isMobile = _isMobile;
    platform = _platform;
    userAgent = _userAgent;
    language = _language;
    (function(Language2) {
      function value() {
        return language;
      }
      Language2.value = value;
      function isDefaultVariant() {
        if (language.length === 2) {
          return language === "en";
        } else if (language.length >= 3) {
          return language[0] === "e" && language[1] === "n" && language[2] === "-";
        } else {
          return false;
        }
      }
      Language2.isDefaultVariant = isDefaultVariant;
      function isDefault() {
        return language === "en";
      }
      Language2.isDefault = isDefault;
    })(Language || (Language = {}));
    setTimeout0IsFaster = typeof globals.postMessage === "function" && !globals.importScripts;
    setTimeout0 = (() => {
      if (setTimeout0IsFaster) {
        const pending = [];
        globals.addEventListener("message", (e) => {
          if (e.data && e.data.vscodeScheduleAsyncWork) {
            for (let i = 0, len = pending.length; i < len; i++) {
              const candidate = pending[i];
              if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                pending.splice(i, 1);
                candidate.callback();
                return;
              }
            }
          }
        });
        let lastId = 0;
        return (callback) => {
          const myId = ++lastId;
          pending.push({
            id: myId,
            callback
          });
          globals.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
        };
      }
      return (callback) => setTimeout(callback);
    })();
    OS = _isMacintosh || _isIOS ? 2 : _isWindows ? 1 : 3;
    _isLittleEndian = true;
    _isLittleEndianComputed = false;
    isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
    isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
    isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
    isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
    isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);
  }
});

// node_modules/monaco-editor/esm/vs/base/common/process.js
var safeProcess, cwd, env, platform2, arch;
var init_process = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/process.js"() {
    init_platform();
    if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
      const sandboxProcess = globals.vscode.process;
      safeProcess = {
        get platform() {
          return sandboxProcess.platform;
        },
        get arch() {
          return sandboxProcess.arch;
        },
        get env() {
          return sandboxProcess.env;
        },
        cwd() {
          return sandboxProcess.cwd();
        }
      };
    } else if (typeof process !== "undefined") {
      safeProcess = {
        get platform() {
          return process.platform;
        },
        get arch() {
          return process.arch;
        },
        get env() {
          return process.env;
        },
        cwd() {
          return process.env["VSCODE_CWD"] || process.cwd();
        }
      };
    } else {
      safeProcess = {
        // Supported
        get platform() {
          return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
        },
        get arch() {
          return void 0;
        },
        // Unsupported
        get env() {
          return {};
        },
        cwd() {
          return "/";
        }
      };
    }
    cwd = safeProcess.cwd;
    env = safeProcess.env;
    platform2 = safeProcess.platform;
    arch = safeProcess.arch;
  }
});

// node_modules/monaco-editor/esm/vs/base/common/path.js
function validateObject(pathObject, name) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ErrorInvalidArgType(name, "Object", pathObject);
  }
}
function validateString(value, name) {
  if (typeof value !== "string") {
    throw new ErrorInvalidArgType(name, "string", value);
  }
}
function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = 0;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (isPathSeparator3(code)) {
      break;
    } else {
      code = CHAR_FORWARD_SLASH;
    }
    if (isPathSeparator3(code)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `${separator}${path.slice(lastSlash + 1, i)}`;
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format2(sep2, pathObject) {
  validateObject(pathObject, "pathObject");
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
  if (!dir) {
    return base;
  }
  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
}
var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_COLON, CHAR_QUESTION_MARK, ErrorInvalidArgType, platformIsWin32, win32, posixCwd, posix, normalize, isAbsolute, join, resolve, relative, dirname, basename, extname, format, parse, toNamespacedPath, sep, delimiter;
var init_path = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/path.js"() {
    init_process();
    CHAR_UPPERCASE_A = 65;
    CHAR_LOWERCASE_A = 97;
    CHAR_UPPERCASE_Z = 90;
    CHAR_LOWERCASE_Z = 122;
    CHAR_DOT = 46;
    CHAR_FORWARD_SLASH = 47;
    CHAR_BACKWARD_SLASH = 92;
    CHAR_COLON = 58;
    CHAR_QUESTION_MARK = 63;
    ErrorInvalidArgType = class extends Error {
      constructor(name, expected, actual) {
        let determiner;
        if (typeof expected === "string" && expected.indexOf("not ") === 0) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        const type = name.indexOf(".") !== -1 ? "property" : "argument";
        let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
        msg += `. Received type ${typeof actual}`;
        super(msg);
        this.code = "ERR_INVALID_ARG_TYPE";
      }
    };
    platformIsWin32 = platform2 === "win32";
    win32 = {
      // path.resolve([from ...], to)
      resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
          let path;
          if (i >= 0) {
            path = pathSegments[i];
            validateString(path, "path");
            if (path.length === 0) {
              continue;
            }
          } else if (resolvedDevice.length === 0) {
            path = cwd();
          } else {
            path = env[`=${resolvedDevice}`] || cwd();
            if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
              path = `${resolvedDevice}\\`;
            }
          }
          const len = path.length;
          let rootEnd = 0;
          let device = "";
          let isAbsolute2 = false;
          const code = path.charCodeAt(0);
          if (len === 1) {
            if (isPathSeparator(code)) {
              rootEnd = 1;
              isAbsolute2 = true;
            }
          } else if (isPathSeparator(code)) {
            isAbsolute2 = true;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                const firstPart = path.slice(last, j);
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len || j !== last) {
                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                    rootEnd = j;
                  }
                }
              }
            } else {
              rootEnd = 1;
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
              isAbsolute2 = true;
              rootEnd = 3;
            }
          }
          if (device.length > 0) {
            if (resolvedDevice.length > 0) {
              if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                continue;
              }
            } else {
              resolvedDevice = device;
            }
          }
          if (resolvedAbsolute) {
            if (resolvedDevice.length > 0) {
              break;
            }
          } else {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute2;
            if (isAbsolute2 && resolvedDevice.length > 0) {
              break;
            }
          }
        }
        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
        return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
      },
      normalize(path) {
        validateString(path, "path");
        const len = path.length;
        if (len === 0) {
          return ".";
        }
        let rootEnd = 0;
        let device;
        let isAbsolute2 = false;
        const code = path.charCodeAt(0);
        if (len === 1) {
          return isPosixPathSeparator(code) ? "\\" : path;
        }
        if (isPathSeparator(code)) {
          isAbsolute2 = true;
          if (isPathSeparator(path.charCodeAt(1))) {
            let j = 2;
            let last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              const firstPart = path.slice(last, j);
              last = j;
              while (j < len && isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j === len) {
                  return `\\\\${firstPart}\\${path.slice(last)}\\`;
                }
                if (j !== last) {
                  device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                  rootEnd = j;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
            isAbsolute2 = true;
            rootEnd = 3;
          }
        }
        let tail3 = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator) : "";
        if (tail3.length === 0 && !isAbsolute2) {
          tail3 = ".";
        }
        if (tail3.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
          tail3 += "\\";
        }
        if (device === void 0) {
          return isAbsolute2 ? `\\${tail3}` : tail3;
        }
        return isAbsolute2 ? `${device}\\${tail3}` : `${device}${tail3}`;
      },
      isAbsolute(path) {
        validateString(path, "path");
        const len = path.length;
        if (len === 0) {
          return false;
        }
        const code = path.charCodeAt(0);
        return isPathSeparator(code) || // Possible device root
        len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
      },
      join(...paths) {
        if (paths.length === 0) {
          return ".";
        }
        let joined;
        let firstPart;
        for (let i = 0; i < paths.length; ++i) {
          const arg = paths[i];
          validateString(arg, "path");
          if (arg.length > 0) {
            if (joined === void 0) {
              joined = firstPart = arg;
            } else {
              joined += `\\${arg}`;
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        let needsReplace = true;
        let slashCount = 0;
        if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
          ++slashCount;
          const firstLen = firstPart.length;
          if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
            ++slashCount;
            if (firstLen > 2) {
              if (isPathSeparator(firstPart.charCodeAt(2))) {
                ++slashCount;
              } else {
                needsReplace = false;
              }
            }
          }
        }
        if (needsReplace) {
          while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
            slashCount++;
          }
          if (slashCount >= 2) {
            joined = `\\${joined.slice(slashCount)}`;
          }
        }
        return win32.normalize(joined);
      },
      // It will solve the relative path from `from` to `to`, for instance:
      //  from = 'C:\\orandea\\test\\aaa'
      //  to = 'C:\\orandea\\impl\\bbb'
      // The output of the function should be: '..\\..\\impl\\bbb'
      relative(from, to) {
        validateString(from, "from");
        validateString(to, "to");
        if (from === to) {
          return "";
        }
        const fromOrig = win32.resolve(from);
        const toOrig = win32.resolve(to);
        if (fromOrig === toOrig) {
          return "";
        }
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to) {
          return "";
        }
        let fromStart = 0;
        while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
          fromStart++;
        }
        let fromEnd = from.length;
        while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
          fromEnd--;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 0;
        while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
          toStart++;
        }
        let toEnd = to.length;
        while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
          toEnd--;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
          const fromCode = from.charCodeAt(fromStart + i);
          if (fromCode !== to.charCodeAt(toStart + i)) {
            break;
          } else if (fromCode === CHAR_BACKWARD_SLASH) {
            lastCommonSep = i;
          }
        }
        if (i !== length) {
          if (lastCommonSep === -1) {
            return toOrig;
          }
        } else {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
              return toOrig.slice(toStart + i + 1);
            }
            if (i === 2) {
              return toOrig.slice(toStart + i);
            }
          }
          if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
              lastCommonSep = i;
            } else if (i === 2) {
              lastCommonSep = 3;
            }
          }
          if (lastCommonSep === -1) {
            lastCommonSep = 0;
          }
        }
        let out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
            out += out.length === 0 ? ".." : "\\..";
          }
        }
        toStart += lastCommonSep;
        if (out.length > 0) {
          return `${out}${toOrig.slice(toStart, toEnd)}`;
        }
        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
          ++toStart;
        }
        return toOrig.slice(toStart, toEnd);
      },
      toNamespacedPath(path) {
        if (typeof path !== "string" || path.length === 0) {
          return path;
        }
        const resolvedPath = win32.resolve(path);
        if (resolvedPath.length <= 2) {
          return path;
        }
        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
          if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
            const code = resolvedPath.charCodeAt(2);
            if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
              return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
            }
          }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
          return `\\\\?\\${resolvedPath}`;
        }
        return path;
      },
      dirname(path) {
        validateString(path, "path");
        const len = path.length;
        if (len === 0) {
          return ".";
        }
        let rootEnd = -1;
        let offset = 0;
        const code = path.charCodeAt(0);
        if (len === 1) {
          return isPathSeparator(code) ? path : ".";
        }
        if (isPathSeparator(code)) {
          rootEnd = offset = 1;
          if (isPathSeparator(path.charCodeAt(1))) {
            let j = 2;
            let last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j === len) {
                  return path;
                }
                if (j !== last) {
                  rootEnd = offset = j + 1;
                }
              }
            }
          }
        } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
          rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
          offset = rootEnd;
        }
        let end = -1;
        let matchedSlash = true;
        for (let i = len - 1; i >= offset; --i) {
          if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) {
          if (rootEnd === -1) {
            return ".";
          }
          end = rootEnd;
        }
        return path.slice(0, end);
      },
      basename(path, ext) {
        if (ext !== void 0) {
          validateString(ext, "ext");
        }
        validateString(path, "path");
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
          start = 2;
        }
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext === path) {
            return "";
          }
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) {
            end = firstNonSlashEnd;
          } else if (end === -1) {
            end = path.length;
          }
          return path.slice(start, end);
        }
        for (i = path.length - 1; i >= start; --i) {
          if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
        }
        if (end === -1) {
          return "";
        }
        return path.slice(start, end);
      },
      extname(path) {
        validateString(path, "path");
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
          start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
          const code = path.charCodeAt(i);
          if (isPathSeparator(code)) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === CHAR_DOT) {
            if (startDot === -1) {
              startDot = i;
            } else if (preDotState !== 1) {
              preDotState = 1;
            }
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: _format2.bind(null, "\\"),
      parse(path) {
        validateString(path, "path");
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) {
          return ret;
        }
        const len = path.length;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        if (len === 1) {
          if (isPathSeparator(code)) {
            ret.root = ret.dir = path;
            return ret;
          }
          ret.base = ret.name = path;
          return ret;
        }
        if (isPathSeparator(code)) {
          rootEnd = 1;
          if (isPathSeparator(path.charCodeAt(1))) {
            let j = 2;
            let last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j === len) {
                  rootEnd = j;
                } else if (j !== last) {
                  rootEnd = j + 1;
                }
              }
            }
          }
        } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
          if (len <= 2) {
            ret.root = ret.dir = path;
            return ret;
          }
          rootEnd = 2;
          if (isPathSeparator(path.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path;
              return ret;
            }
            rootEnd = 3;
          }
        }
        if (rootEnd > 0) {
          ret.root = path.slice(0, rootEnd);
        }
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= rootEnd; --i) {
          code = path.charCodeAt(i);
          if (isPathSeparator(code)) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === CHAR_DOT) {
            if (startDot === -1) {
              startDot = i;
            } else if (preDotState !== 1) {
              preDotState = 1;
            }
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (end !== -1) {
          if (startDot === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            ret.base = ret.name = path.slice(startPart, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
          }
        }
        if (startPart > 0 && startPart !== rootEnd) {
          ret.dir = path.slice(0, startPart - 1);
        } else {
          ret.dir = ret.root;
        }
        return ret;
      },
      sep: "\\",
      delimiter: ";",
      win32: null,
      posix: null
    };
    posixCwd = (() => {
      if (platformIsWin32) {
        const regexp = /\\/g;
        return () => {
          const cwd2 = cwd().replace(regexp, "/");
          return cwd2.slice(cwd2.indexOf("/"));
        };
      }
      return () => cwd();
    })();
    posix = {
      // path.resolve([from ...], to)
      resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          const path = i >= 0 ? pathSegments[i] : posixCwd();
          validateString(path, "path");
          if (path.length === 0) {
            continue;
          }
          resolvedPath = `${path}/${resolvedPath}`;
          resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        }
        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
        if (resolvedAbsolute) {
          return `/${resolvedPath}`;
        }
        return resolvedPath.length > 0 ? resolvedPath : ".";
      },
      normalize(path) {
        validateString(path, "path");
        if (path.length === 0) {
          return ".";
        }
        const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
        path = normalizeString(path, !isAbsolute2, "/", isPosixPathSeparator);
        if (path.length === 0) {
          if (isAbsolute2) {
            return "/";
          }
          return trailingSeparator ? "./" : ".";
        }
        if (trailingSeparator) {
          path += "/";
        }
        return isAbsolute2 ? `/${path}` : path;
      },
      isAbsolute(path) {
        validateString(path, "path");
        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      },
      join(...paths) {
        if (paths.length === 0) {
          return ".";
        }
        let joined;
        for (let i = 0; i < paths.length; ++i) {
          const arg = paths[i];
          validateString(arg, "path");
          if (arg.length > 0) {
            if (joined === void 0) {
              joined = arg;
            } else {
              joined += `/${arg}`;
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        return posix.normalize(joined);
      },
      relative(from, to) {
        validateString(from, "from");
        validateString(to, "to");
        if (from === to) {
          return "";
        }
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) {
          return "";
        }
        const fromStart = 1;
        const fromEnd = from.length;
        const fromLen = fromEnd - fromStart;
        const toStart = 1;
        const toLen = to.length - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
          const fromCode = from.charCodeAt(fromStart + i);
          if (fromCode !== to.charCodeAt(toStart + i)) {
            break;
          } else if (fromCode === CHAR_FORWARD_SLASH) {
            lastCommonSep = i;
          }
        }
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
              return to.slice(toStart + i + 1);
            }
            if (i === 0) {
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
              lastCommonSep = i;
            } else if (i === 0) {
              lastCommonSep = 0;
            }
          }
        }
        let out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
            out += out.length === 0 ? ".." : "/..";
          }
        }
        return `${out}${to.slice(toStart + lastCommonSep)}`;
      },
      toNamespacedPath(path) {
        return path;
      },
      dirname(path) {
        validateString(path, "path");
        if (path.length === 0) {
          return ".";
        }
        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
          if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) {
          return hasRoot ? "/" : ".";
        }
        if (hasRoot && end === 1) {
          return "//";
        }
        return path.slice(0, end);
      },
      basename(path, ext) {
        if (ext !== void 0) {
          validateString(ext, "ext");
        }
        validateString(path, "path");
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext === path) {
            return "";
          }
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) {
            end = firstNonSlashEnd;
          } else if (end === -1) {
            end = path.length;
          }
          return path.slice(start, end);
        }
        for (i = path.length - 1; i >= 0; --i) {
          if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
        }
        if (end === -1) {
          return "";
        }
        return path.slice(start, end);
      },
      extname(path) {
        validateString(path, "path");
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
          const code = path.charCodeAt(i);
          if (code === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === CHAR_DOT) {
            if (startDot === -1) {
              startDot = i;
            } else if (preDotState !== 1) {
              preDotState = 1;
            }
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: _format2.bind(null, "/"),
      parse(path) {
        validateString(path, "path");
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) {
          return ret;
        }
        const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= start; --i) {
          const code = path.charCodeAt(i);
          if (code === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === CHAR_DOT) {
            if (startDot === -1) {
              startDot = i;
            } else if (preDotState !== 1) {
              preDotState = 1;
            }
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (end !== -1) {
          const start2 = startPart === 0 && isAbsolute2 ? 1 : startPart;
          if (startDot === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            ret.base = ret.name = path.slice(start2, end);
          } else {
            ret.name = path.slice(start2, startDot);
            ret.base = path.slice(start2, end);
            ret.ext = path.slice(startDot, end);
          }
        }
        if (startPart > 0) {
          ret.dir = path.slice(0, startPart - 1);
        } else if (isAbsolute2) {
          ret.dir = "/";
        }
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.win32 = win32.win32 = win32;
    posix.posix = win32.posix = posix;
    normalize = platformIsWin32 ? win32.normalize : posix.normalize;
    isAbsolute = platformIsWin32 ? win32.isAbsolute : posix.isAbsolute;
    join = platformIsWin32 ? win32.join : posix.join;
    resolve = platformIsWin32 ? win32.resolve : posix.resolve;
    relative = platformIsWin32 ? win32.relative : posix.relative;
    dirname = platformIsWin32 ? win32.dirname : posix.dirname;
    basename = platformIsWin32 ? win32.basename : posix.basename;
    extname = platformIsWin32 ? win32.extname : posix.extname;
    format = platformIsWin32 ? win32.format : posix.format;
    parse = platformIsWin32 ? win32.parse : posix.parse;
    toNamespacedPath = platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath;
    sep = platformIsWin32 ? win32.sep : posix.sep;
    delimiter = platformIsWin32 ? win32.delimiter : posix.delimiter;
  }
});

// node_modules/monaco-editor/esm/vs/base/common/uri.js
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path) {
        path = _slash;
      } else if (path[0] !== _slash) {
        path = _slash + path;
      }
      break;
  }
  return path;
}
function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
  let res = void 0;
  let nativeEncodePos = -1;
  for (let pos = 0; pos < uriComponent.length; pos++) {
    const code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      const escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
  let res = void 0;
  for (let pos = 0; pos < path.length; pos++) {
    const code = path.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path[pos];
      }
    }
  }
  return res !== void 0 ? res : path;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  let value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = `//${uri.authority}${uri.path}`;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  let res = "";
  let { scheme, authority, path, query, fragment } = uri;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    let idx = authority.indexOf("@");
    if (idx !== -1) {
      const userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false, false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false, true);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.lastIndexOf(":");
    if (idx === -1) {
      res += encoder(authority, false, true);
    } else {
      res += encoder(authority.substr(0, idx), false, true);
      res += authority.substr(idx);
    }
  }
  if (path) {
    if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
      const code = path.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
      }
    } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
      const code = path.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
      }
    }
    res += encoder(path, true, false);
  }
  if (query) {
    res += "?";
    res += encoder(query, false, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch (_a4) {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
}
var _schemePattern, _singleSlashStart, _doubleSlashStart, _empty, _slash, _regexp, URI, _pathSepMarker, Uri, encodeTable, _rEncodedAsHex;
var init_uri = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/uri.js"() {
    init_path();
    init_platform();
    _schemePattern = /^\w[\w\d+.-]*$/;
    _singleSlashStart = /^\//;
    _doubleSlashStart = /^\/\//;
    _empty = "";
    _slash = "/";
    _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    URI = class _URI {
      static isUri(thing) {
        if (thing instanceof _URI) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
      }
      /**
       * @internal
       */
      constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
        if (typeof schemeOrData === "object") {
          this.scheme = schemeOrData.scheme || _empty;
          this.authority = schemeOrData.authority || _empty;
          this.path = schemeOrData.path || _empty;
          this.query = schemeOrData.query || _empty;
          this.fragment = schemeOrData.fragment || _empty;
        } else {
          this.scheme = _schemeFix(schemeOrData, _strict);
          this.authority = authority || _empty;
          this.path = _referenceResolution(this.scheme, path || _empty);
          this.query = query || _empty;
          this.fragment = fragment || _empty;
          _validateUri(this, _strict);
        }
      }
      // ---- filesystem path -----------------------
      /**
       * Returns a string representing the corresponding file system path of this URI.
       * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
       * platform specific path separator.
       *
       * * Will *not* validate the path for invalid characters and semantics.
       * * Will *not* look at the scheme of this URI.
       * * The result shall *not* be used for display purposes but for accessing a file on disk.
       *
       *
       * The *difference* to `URI#path` is the use of the platform specific separator and the handling
       * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
       *
       * ```ts
          const u = URI.parse('file://server/c$/folder/file.txt')
          u.authority === 'server'
          u.path === '/shares/c$/file.txt'
          u.fsPath === '\\server\c$\folder\file.txt'
      ```
       *
       * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
       * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
       * with URIs that represent files on disk (`file` scheme).
       */
      get fsPath() {
        return uriToFsPath(this, false);
      }
      // ---- modify to new -------------------------
      with(change) {
        if (!change) {
          return this;
        }
        let { scheme, authority, path, query, fragment } = change;
        if (scheme === void 0) {
          scheme = this.scheme;
        } else if (scheme === null) {
          scheme = _empty;
        }
        if (authority === void 0) {
          authority = this.authority;
        } else if (authority === null) {
          authority = _empty;
        }
        if (path === void 0) {
          path = this.path;
        } else if (path === null) {
          path = _empty;
        }
        if (query === void 0) {
          query = this.query;
        } else if (query === null) {
          query = _empty;
        }
        if (fragment === void 0) {
          fragment = this.fragment;
        } else if (fragment === null) {
          fragment = _empty;
        }
        if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
          return this;
        }
        return new Uri(scheme, authority, path, query, fragment);
      }
      // ---- parse & validate ------------------------
      /**
       * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
       * `file:///usr/home`, or `scheme:with/path`.
       *
       * @param value A string which represents an URI (see `URI#toString`).
       */
      static parse(value, _strict = false) {
        const match = _regexp.exec(value);
        if (!match) {
          return new Uri(_empty, _empty, _empty, _empty, _empty);
        }
        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
      }
      /**
       * Creates a new URI from a file system path, e.g. `c:\my\files`,
       * `/usr/home`, or `\\server\share\some\path`.
       *
       * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
       * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
       * `URI.parse('file://' + path)` because the path might contain characters that are
       * interpreted (# and ?). See the following sample:
       * ```ts
      const good = URI.file('/coding/c#/project1');
      good.scheme === 'file';
      good.path === '/coding/c#/project1';
      good.fragment === '';
      const bad = URI.parse('file://' + '/coding/c#/project1');
      bad.scheme === 'file';
      bad.path === '/coding/c'; // path is now broken
      bad.fragment === '/project1';
      ```
       *
       * @param path A file system path (see `URI#fsPath`)
       */
      static file(path) {
        let authority = _empty;
        if (isWindows) {
          path = path.replace(/\\/g, _slash);
        }
        if (path[0] === _slash && path[1] === _slash) {
          const idx = path.indexOf(_slash, 2);
          if (idx === -1) {
            authority = path.substring(2);
            path = _slash;
          } else {
            authority = path.substring(2, idx);
            path = path.substring(idx) || _slash;
          }
        }
        return new Uri("file", authority, path, _empty, _empty);
      }
      /**
       * Creates new URI from uri components.
       *
       * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
       * validation and should be used for untrusted uri components retrieved from storage,
       * user input, command arguments etc
       */
      static from(components, strict) {
        const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
        return result;
      }
      /**
       * Join a URI path with path fragments and normalizes the resulting path.
       *
       * @param uri The input URI.
       * @param pathFragment The path fragment to add to the URI path.
       * @returns The resulting URI.
       */
      static joinPath(uri, ...pathFragment) {
        if (!uri.path) {
          throw new Error(`[UriError]: cannot call joinPath on URI without path`);
        }
        let newPath;
        if (isWindows && uri.scheme === "file") {
          newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
        } else {
          newPath = posix.join(uri.path, ...pathFragment);
        }
        return uri.with({ path: newPath });
      }
      // ---- printing/externalize ---------------------------
      /**
       * Creates a string representation for this URI. It's guaranteed that calling
       * `URI.parse` with the result of this function creates an URI which is equal
       * to this URI.
       *
       * * The result shall *not* be used for display purposes but for externalization or transport.
       * * The result will be encoded using the percentage encoding and encoding happens mostly
       * ignore the scheme-specific encoding rules.
       *
       * @param skipEncoding Do not encode the result, default is `false`
       */
      toString(skipEncoding = false) {
        return _asFormatted(this, skipEncoding);
      }
      toJSON() {
        return this;
      }
      static revive(data) {
        var _a4, _b2;
        if (!data) {
          return data;
        } else if (data instanceof _URI) {
          return data;
        } else {
          const result = new Uri(data);
          result._formatted = (_a4 = data.external) !== null && _a4 !== void 0 ? _a4 : null;
          result._fsPath = data._sep === _pathSepMarker ? (_b2 = data.fsPath) !== null && _b2 !== void 0 ? _b2 : null : null;
          return result;
        }
      }
    };
    _pathSepMarker = isWindows ? 1 : void 0;
    Uri = class extends URI {
      constructor() {
        super(...arguments);
        this._formatted = null;
        this._fsPath = null;
      }
      get fsPath() {
        if (!this._fsPath) {
          this._fsPath = uriToFsPath(this, false);
        }
        return this._fsPath;
      }
      toString(skipEncoding = false) {
        if (!skipEncoding) {
          if (!this._formatted) {
            this._formatted = _asFormatted(this, false);
          }
          return this._formatted;
        } else {
          return _asFormatted(this, true);
        }
      }
      toJSON() {
        const res = {
          $mid: 1
          /* MarshalledId.Uri */
        };
        if (this._fsPath) {
          res.fsPath = this._fsPath;
          res._sep = _pathSepMarker;
        }
        if (this._formatted) {
          res.external = this._formatted;
        }
        if (this.path) {
          res.path = this.path;
        }
        if (this.scheme) {
          res.scheme = this.scheme;
        }
        if (this.authority) {
          res.authority = this.authority;
        }
        if (this.query) {
          res.query = this.query;
        }
        if (this.fragment) {
          res.fragment = this.fragment;
        }
        return res;
      }
    };
    encodeTable = {
      [
        58
        /* CharCode.Colon */
      ]: "%3A",
      [
        47
        /* CharCode.Slash */
      ]: "%2F",
      [
        63
        /* CharCode.QuestionMark */
      ]: "%3F",
      [
        35
        /* CharCode.Hash */
      ]: "%23",
      [
        91
        /* CharCode.OpenSquareBracket */
      ]: "%5B",
      [
        93
        /* CharCode.CloseSquareBracket */
      ]: "%5D",
      [
        64
        /* CharCode.AtSign */
      ]: "%40",
      [
        33
        /* CharCode.ExclamationMark */
      ]: "%21",
      [
        36
        /* CharCode.DollarSign */
      ]: "%24",
      [
        38
        /* CharCode.Ampersand */
      ]: "%26",
      [
        39
        /* CharCode.SingleQuote */
      ]: "%27",
      [
        40
        /* CharCode.OpenParen */
      ]: "%28",
      [
        41
        /* CharCode.CloseParen */
      ]: "%29",
      [
        42
        /* CharCode.Asterisk */
      ]: "%2A",
      [
        43
        /* CharCode.Plus */
      ]: "%2B",
      [
        44
        /* CharCode.Comma */
      ]: "%2C",
      [
        59
        /* CharCode.Semicolon */
      ]: "%3B",
      [
        61
        /* CharCode.Equals */
      ]: "%3D",
      [
        32
        /* CharCode.Space */
      ]: "%20"
    };
    _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  }
});

// node_modules/monaco-editor/esm/vs/base/common/cancellation.js
var shortcutEvent, CancellationToken, MutableToken, CancellationTokenSource;
var init_cancellation = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/cancellation.js"() {
    init_event();
    shortcutEvent = Object.freeze(function(callback, context) {
      const handle = setTimeout(callback.bind(context), 0);
      return { dispose() {
        clearTimeout(handle);
      } };
    });
    (function(CancellationToken2) {
      function isCancellationToken(thing) {
        if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
          return true;
        }
        if (thing instanceof MutableToken) {
          return true;
        }
        if (!thing || typeof thing !== "object") {
          return false;
        }
        return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
      }
      CancellationToken2.isCancellationToken = isCancellationToken;
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: shortcutEvent
      });
    })(CancellationToken || (CancellationToken = {}));
    MutableToken = class {
      constructor() {
        this._isCancelled = false;
        this._emitter = null;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = null;
        }
      }
    };
    CancellationTokenSource = class {
      constructor(parent) {
        this._token = void 0;
        this._parentListener = void 0;
        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
      }
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else if (this._token instanceof MutableToken) {
          this._token.cancel();
        }
      }
      dispose(cancel = false) {
        var _a4;
        if (cancel) {
          this.cancel();
        }
        (_a4 = this._parentListener) === null || _a4 === void 0 ? void 0 : _a4.dispose();
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js
function storeServiceDependency(id2, target, index2) {
  if (target[_util.DI_TARGET] === target) {
    target[_util.DI_DEPENDENCIES].push({ id: id2, index: index2 });
  } else {
    target[_util.DI_DEPENDENCIES] = [{ id: id2, index: index2 }];
    target[_util.DI_TARGET] = target;
  }
}
function createDecorator(serviceId) {
  if (_util.serviceIds.has(serviceId)) {
    return _util.serviceIds.get(serviceId);
  }
  const id2 = function(target, key, index2) {
    if (arguments.length !== 3) {
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    }
    storeServiceDependency(id2, target, index2);
  };
  id2.toString = () => serviceId;
  _util.serviceIds.set(serviceId, id2);
  return id2;
}
function refineServiceDecorator(serviceIdentifier) {
  return serviceIdentifier;
}
var _util, IInstantiationService;
var init_instantiation = __esm({
  "node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js"() {
    (function(_util2) {
      _util2.serviceIds = /* @__PURE__ */ new Map();
      _util2.DI_TARGET = "$di$target";
      _util2.DI_DEPENDENCIES = "$di$dependencies";
      function getServiceDependencies(ctor) {
        return ctor[_util2.DI_DEPENDENCIES] || [];
      }
      _util2.getServiceDependencies = getServiceDependencies;
    })(_util || (_util = {}));
    IInstantiationService = createDecorator("instantiationService");
  }
});

// node_modules/monaco-editor/esm/vs/base/common/map.js
function getOrSet(map, key, value) {
  let result = map.get(key);
  if (result === void 0) {
    result = value;
    map.set(key, result);
  }
  return result;
}
var _a2, _b, _c, ResourceMapEntry, ResourceMap, ResourceSet, LinkedMap, LRUCache;
var init_map = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/map.js"() {
    ResourceMapEntry = class {
      constructor(uri, value) {
        this.uri = uri;
        this.value = value;
      }
    };
    ResourceMap = class _ResourceMap {
      constructor(mapOrKeyFn, toKey) {
        this[_a2] = "ResourceMap";
        if (mapOrKeyFn instanceof _ResourceMap) {
          this.map = new Map(mapOrKeyFn.map);
          this.toKey = toKey !== null && toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;
        } else {
          this.map = /* @__PURE__ */ new Map();
          this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : _ResourceMap.defaultToKey;
        }
      }
      set(resource, value) {
        this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
        return this;
      }
      get(resource) {
        var _d;
        return (_d = this.map.get(this.toKey(resource))) === null || _d === void 0 ? void 0 : _d.value;
      }
      has(resource) {
        return this.map.has(this.toKey(resource));
      }
      get size() {
        return this.map.size;
      }
      clear() {
        this.map.clear();
      }
      delete(resource) {
        return this.map.delete(this.toKey(resource));
      }
      forEach(clb, thisArg) {
        if (typeof thisArg !== "undefined") {
          clb = clb.bind(thisArg);
        }
        for (const [_, entry] of this.map) {
          clb(entry.value, entry.uri, this);
        }
      }
      *values() {
        for (const entry of this.map.values()) {
          yield entry.value;
        }
      }
      *keys() {
        for (const entry of this.map.values()) {
          yield entry.uri;
        }
      }
      *entries() {
        for (const entry of this.map.values()) {
          yield [entry.uri, entry.value];
        }
      }
      *[(_a2 = Symbol.toStringTag, Symbol.iterator)]() {
        for (const [, entry] of this.map) {
          yield [entry.uri, entry.value];
        }
      }
    };
    ResourceMap.defaultToKey = (resource) => resource.toString();
    ResourceSet = class {
      constructor(entriesOrKey, toKey) {
        this[_b] = "ResourceSet";
        if (!entriesOrKey || typeof entriesOrKey === "function") {
          this._map = new ResourceMap(entriesOrKey);
        } else {
          this._map = new ResourceMap(toKey);
          entriesOrKey.forEach(this.add, this);
        }
      }
      get size() {
        return this._map.size;
      }
      add(value) {
        this._map.set(value, value);
        return this;
      }
      clear() {
        this._map.clear();
      }
      delete(value) {
        return this._map.delete(value);
      }
      forEach(callbackfn, thisArg) {
        this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));
      }
      has(value) {
        return this._map.has(value);
      }
      entries() {
        return this._map.entries();
      }
      keys() {
        return this._map.keys();
      }
      values() {
        return this._map.keys();
      }
      [(_b = Symbol.toStringTag, Symbol.iterator)]() {
        return this.keys();
      }
    };
    LinkedMap = class {
      constructor() {
        this[_c] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _d;
        return (_d = this._head) === null || _d === void 0 ? void 0 : _d.value;
      }
      get last() {
        var _d;
        return (_d = this._tail) === null || _d === void 0 ? void 0 : _d.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = 0) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== 0) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = 0) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== 0) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case 0:
              this.addItemLast(item);
              break;
            case 1:
              this.addItemFirst(item);
              break;
            case 2:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_c = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== 1 && touch !== 2) {
          return;
        }
        if (touch === 1) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === 2) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = 2) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(
          key,
          0
          /* Touch.None */
        );
      }
      set(key, value) {
        super.set(
          key,
          value,
          2
          /* Touch.AsNew */
        );
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/network.js
var Schemas, connectionTokenQueryName, RemoteAuthoritiesImpl, RemoteAuthorities, nodeModulesPath, nodeModulesAsarPath, nodeModulesAsarUnpackedPath, FileAccessImpl, FileAccess, COI;
var init_network = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/network.js"() {
    init_errors();
    init_lifecycle();
    init_map();
    init_platform();
    init_uri();
    (function(Schemas2) {
      Schemas2.inMemory = "inmemory";
      Schemas2.vscode = "vscode";
      Schemas2.internal = "private";
      Schemas2.walkThrough = "walkThrough";
      Schemas2.walkThroughSnippet = "walkThroughSnippet";
      Schemas2.http = "http";
      Schemas2.https = "https";
      Schemas2.file = "file";
      Schemas2.mailto = "mailto";
      Schemas2.untitled = "untitled";
      Schemas2.data = "data";
      Schemas2.command = "command";
      Schemas2.vscodeRemote = "vscode-remote";
      Schemas2.vscodeRemoteResource = "vscode-remote-resource";
      Schemas2.vscodeManagedRemoteResource = "vscode-managed-remote-resource";
      Schemas2.vscodeUserData = "vscode-userdata";
      Schemas2.vscodeCustomEditor = "vscode-custom-editor";
      Schemas2.vscodeNotebookCell = "vscode-notebook-cell";
      Schemas2.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata";
      Schemas2.vscodeNotebookCellOutput = "vscode-notebook-cell-output";
      Schemas2.vscodeInteractiveInput = "vscode-interactive-input";
      Schemas2.vscodeSettings = "vscode-settings";
      Schemas2.vscodeWorkspaceTrust = "vscode-workspace-trust";
      Schemas2.vscodeTerminal = "vscode-terminal";
      Schemas2.vscodeChatSesssion = "vscode-chat-editor";
      Schemas2.webviewPanel = "webview-panel";
      Schemas2.vscodeWebview = "vscode-webview";
      Schemas2.extension = "extension";
      Schemas2.vscodeFileResource = "vscode-file";
      Schemas2.tmp = "tmp";
      Schemas2.vsls = "vsls";
      Schemas2.vscodeSourceControl = "vscode-scm";
    })(Schemas || (Schemas = {}));
    connectionTokenQueryName = "tkn";
    RemoteAuthoritiesImpl = class {
      constructor() {
        this._hosts = /* @__PURE__ */ Object.create(null);
        this._ports = /* @__PURE__ */ Object.create(null);
        this._connectionTokens = /* @__PURE__ */ Object.create(null);
        this._preferredWebSchema = "http";
        this._delegate = null;
        this._remoteResourcesPath = `/${Schemas.vscodeRemoteResource}`;
      }
      setPreferredWebSchema(schema) {
        this._preferredWebSchema = schema;
      }
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      setServerRootPath(serverRootPath) {
        this._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;
      }
      set(authority, host, port) {
        this._hosts[authority] = host;
        this._ports[authority] = port;
      }
      setConnectionToken(authority, connectionToken) {
        this._connectionTokens[authority] = connectionToken;
      }
      getPreferredWebSchema() {
        return this._preferredWebSchema;
      }
      rewrite(uri) {
        if (this._delegate) {
          try {
            return this._delegate(uri);
          } catch (err) {
            onUnexpectedError(err);
            return uri;
          }
        }
        const authority = uri.authority;
        let host = this._hosts[authority];
        if (host && host.indexOf(":") !== -1 && host.indexOf("[") === -1) {
          host = `[${host}]`;
        }
        const port = this._ports[authority];
        const connectionToken = this._connectionTokens[authority];
        let query = `path=${encodeURIComponent(uri.path)}`;
        if (typeof connectionToken === "string") {
          query += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;
        }
        return URI.from({
          scheme: isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,
          authority: `${host}:${port}`,
          path: this._remoteResourcesPath,
          query
        });
      }
    };
    RemoteAuthorities = new RemoteAuthoritiesImpl();
    nodeModulesPath = "vs/../../node_modules";
    nodeModulesAsarPath = "vs/../../node_modules.asar";
    nodeModulesAsarUnpackedPath = "vs/../../node_modules.asar.unpacked";
    FileAccessImpl = class _FileAccessImpl {
      constructor() {
        this.staticBrowserUris = new ResourceMap();
      }
      /**
       * Returns a URI to use in contexts where the browser is responsible
       * for loading (e.g. fetch()) or when used within the DOM.
       *
       * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
       */
      asBrowserUri(resourcePath) {
        const uri = this.toUri(resourcePath, globalThis.monacoRequire);
        return this.uriToBrowserUri(uri);
      }
      /**
       * Returns a URI to use in contexts where the browser is responsible
       * for loading (e.g. fetch()) or when used within the DOM.
       *
       * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
       */
      uriToBrowserUri(uri) {
        var _a4;
        if (uri.scheme === Schemas.vscodeRemote) {
          return RemoteAuthorities.rewrite(uri);
        }
        if (
          // ...only ever for `file` resources
          uri.scheme === Schemas.file && // ...and we run in native environments
          (isNative || // ...or web worker extensions on desktop
          isWebWorker && globals.origin === `${Schemas.vscodeFileResource}://${_FileAccessImpl.FALLBACK_AUTHORITY}`)
        ) {
          return uri.with({
            scheme: Schemas.vscodeFileResource,
            // We need to provide an authority here so that it can serve
            // as origin for network and loading matters in chromium.
            // If the URI is not coming with an authority already, we
            // add our own
            authority: uri.authority || _FileAccessImpl.FALLBACK_AUTHORITY,
            query: null,
            fragment: null
          });
        }
        return (_a4 = this.staticBrowserUris.get(uri)) !== null && _a4 !== void 0 ? _a4 : uri;
      }
      /**
       * Returns the `file` URI to use in contexts where node.js
       * is responsible for loading.
       */
      asFileUri(resourcePath) {
        const uri = this.toUri(resourcePath, globalThis.monacoRequire);
        return this.uriToFileUri(uri);
      }
      /**
       * Returns the `file` URI to use in contexts where node.js
       * is responsible for loading.
       */
      uriToFileUri(uri) {
        if (uri.scheme === Schemas.vscodeFileResource) {
          return uri.with({
            scheme: Schemas.file,
            // Only preserve the `authority` if it is different from
            // our fallback authority. This ensures we properly preserve
            // Windows UNC paths that come with their own authority.
            authority: uri.authority !== _FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,
            query: null,
            fragment: null
          });
        }
        return uri;
      }
      toUri(uriOrModule, moduleIdToUrl) {
        if (URI.isUri(uriOrModule)) {
          return uriOrModule;
        }
        return URI.parse(moduleIdToUrl.toUrl(uriOrModule));
      }
      registerStaticBrowserUri(uri, browserUri) {
        this.staticBrowserUris.set(uri, browserUri);
        return toDisposable(() => {
          if (this.staticBrowserUris.get(uri) === browserUri) {
            this.staticBrowserUris.delete(uri);
          }
        });
      }
      getRegisteredBrowserUris() {
        return this.staticBrowserUris.keys();
      }
    };
    FileAccessImpl.FALLBACK_AUTHORITY = "vscode-app";
    FileAccess = new FileAccessImpl();
    (function(COI2) {
      const coiHeaders = /* @__PURE__ */ new Map([
        ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
        ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
        ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
      ]);
      COI2.CoopAndCoep = Object.freeze(coiHeaders.get("3"));
      const coiSearchParamName = "vscode-coi";
      function getHeadersFromQuery(url) {
        let params;
        if (typeof url === "string") {
          params = new URL(url).searchParams;
        } else if (url instanceof URL) {
          params = url.searchParams;
        } else if (URI.isUri(url)) {
          params = new URL(url.toString(true)).searchParams;
        }
        const value = params === null || params === void 0 ? void 0 : params.get(coiSearchParamName);
        if (!value) {
          return void 0;
        }
        return coiHeaders.get(value);
      }
      COI2.getHeadersFromQuery = getHeadersFromQuery;
      function addSearchParam(urlOrSearch, coop, coep) {
        if (!globalThis.crossOriginIsolated) {
          return;
        }
        const value = coop && coep ? "3" : coep ? "2" : "1";
        if (urlOrSearch instanceof URLSearchParams) {
          urlOrSearch.set(coiSearchParamName, value);
        } else {
          urlOrSearch[coiSearchParamName] = value;
        }
      }
      COI2.addSearchParam = addSearchParam;
    })(COI || (COI = {}));
  }
});

// node_modules/monaco-editor/esm/vs/base/common/types.js
function isString(str) {
  return typeof str === "string";
}
function isStringArray(value) {
  return Array.isArray(value) && value.every((elem) => isString(elem));
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function isTypedArray(obj) {
  const TypedArray = Object.getPrototypeOf(Uint8Array);
  return typeof obj === "object" && obj instanceof TypedArray;
}
function isNumber(obj) {
  return typeof obj === "number" && !isNaN(obj);
}
function isIterable(obj) {
  return !!obj && typeof obj[Symbol.iterator] === "function";
}
function isBoolean(obj) {
  return obj === true || obj === false;
}
function isUndefined(obj) {
  return typeof obj === "undefined";
}
function isDefined(arg) {
  return !isUndefinedOrNull(arg);
}
function isUndefinedOrNull(obj) {
  return isUndefined(obj) || obj === null;
}
function assertType(condition, type) {
  if (!condition) {
    throw new Error(type ? `Unexpected type, expected '${type}'` : "Unexpected type");
  }
}
function assertIsDefined(arg) {
  if (isUndefinedOrNull(arg)) {
    throw new Error("Assertion Failed: argument is undefined or null");
  }
  return arg;
}
function isEmptyObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  for (const key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
function isFunction(obj) {
  return typeof obj === "function";
}
function validateConstraints(args, constraints) {
  const len = Math.min(args.length, constraints.length);
  for (let i = 0; i < len; i++) {
    validateConstraint(args[i], constraints[i]);
  }
}
function validateConstraint(arg, constraint) {
  if (isString(constraint)) {
    if (typeof arg !== constraint) {
      throw new Error(`argument does not match constraint: typeof ${constraint}`);
    }
  } else if (isFunction(constraint)) {
    try {
      if (arg instanceof constraint) {
        return;
      }
    } catch (_a4) {
    }
    if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
      return;
    }
    if (constraint.length === 1 && constraint.call(void 0, arg) === true) {
      return;
    }
    throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);
  }
}
var hasOwnProperty;
var init_types = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/types.js"() {
    hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// node_modules/monaco-editor/esm/vs/base/common/cache.js
var LRUCachedFunction, CachedFunction;
var init_cache = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/cache.js"() {
    init_cancellation();
    LRUCachedFunction = class {
      constructor(fn) {
        this.fn = fn;
        this.lastCache = void 0;
        this.lastArgKey = void 0;
      }
      get(arg) {
        const key = JSON.stringify(arg);
        if (this.lastArgKey !== key) {
          this.lastArgKey = key;
          this.lastCache = this.fn(arg);
        }
        return this.lastCache;
      }
    };
    CachedFunction = class {
      get cachedValues() {
        return this._map;
      }
      constructor(fn) {
        this.fn = fn;
        this._map = /* @__PURE__ */ new Map();
      }
      get(arg) {
        if (this._map.has(arg)) {
          return this._map.get(arg);
        }
        const value = this.fn(arg);
        this._map.set(arg, value);
        return value;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/lazy.js
var Lazy;
var init_lazy = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/lazy.js"() {
    Lazy = class {
      constructor(executor) {
        this.executor = executor;
        this._didRun = false;
      }
      /**
       * True if the lazy value has been resolved.
       */
      get hasValue() {
        return this._didRun;
      }
      /**
       * Get the wrapped value.
       *
       * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
       * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
       */
      get value() {
        if (!this._didRun) {
          try {
            this._value = this.executor();
          } catch (err) {
            this._error = err;
          } finally {
            this._didRun = true;
          }
        }
        if (this._error) {
          throw this._error;
        }
        return this._value;
      }
      /**
       * Get the wrapped value without forcing evaluation.
       */
      get rawValue() {
        return this._value;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/strings.js
function isFalsyOrWhitespace(str) {
  if (!str || typeof str !== "string") {
    return true;
  }
  return str.trim().length === 0;
}
function format2(value, ...args) {
  if (args.length === 0) {
    return value;
  }
  return value.replace(_formatRegexp, function(match, group) {
    const idx = parseInt(group, 10);
    return isNaN(idx) || idx < 0 || idx >= args.length ? match : args[idx];
  });
}
function format22(template, values) {
  return template.replace(_format2Regexp, (match, group) => {
    var _b2;
    return (_b2 = values[group]) !== null && _b2 !== void 0 ? _b2 : match;
  });
}
function escape(html) {
  return html.replace(/[<>&]/g, function(match) {
    switch (match) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return match;
    }
  });
}
function escapeRegExpCharacters(value) {
  return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function count(value, character) {
  let result = 0;
  const ch = character.charCodeAt(0);
  for (let i = value.length - 1; i >= 0; i--) {
    if (value.charCodeAt(i) === ch) {
      result++;
    }
  }
  return result;
}
function trim(haystack, needle = " ") {
  const trimmed = ltrim(haystack, needle);
  return rtrim(trimmed, needle);
}
function ltrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length;
  if (needleLen === 0 || haystack.length === 0) {
    return haystack;
  }
  let offset = 0;
  while (haystack.indexOf(needle, offset) === offset) {
    offset = offset + needleLen;
  }
  return haystack.substring(offset);
}
function rtrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length, haystackLen = haystack.length;
  if (needleLen === 0 || haystackLen === 0) {
    return haystack;
  }
  let offset = haystackLen, idx = -1;
  while (true) {
    idx = haystack.lastIndexOf(needle, offset - 1);
    if (idx === -1 || idx + needleLen !== offset) {
      break;
    }
    if (idx === 0) {
      return "";
    }
    offset = idx;
  }
  return haystack.substring(0, offset);
}
function convertSimple2RegExpPattern(pattern) {
  return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function stripWildcards(pattern) {
  return pattern.replace(/\*/g, "");
}
function createRegExp(searchString, isRegex, options = {}) {
  if (!searchString) {
    throw new Error("Cannot create regex from empty string");
  }
  if (!isRegex) {
    searchString = escapeRegExpCharacters(searchString);
  }
  if (options.wholeWord) {
    if (!/\B/.test(searchString.charAt(0))) {
      searchString = "\\b" + searchString;
    }
    if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
      searchString = searchString + "\\b";
    }
  }
  let modifiers = "";
  if (options.global) {
    modifiers += "g";
  }
  if (!options.matchCase) {
    modifiers += "i";
  }
  if (options.multiline) {
    modifiers += "m";
  }
  if (options.unicode) {
    modifiers += "u";
  }
  return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
  if (regexp.source === "^" || regexp.source === "^$" || regexp.source === "$" || regexp.source === "^\\s*$") {
    return false;
  }
  const match = regexp.exec("");
  return !!(match && regexp.lastIndex === 0);
}
function splitLines(str) {
  return str.split(/\r\n|\r|\n/);
}
function firstNonWhitespaceIndex(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function getLeadingWhitespace(str, start = 0, end = str.length) {
  for (let i = start; i < end; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return str.substring(start, i);
    }
  }
  return str.substring(start, end);
}
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
  for (let i = startIndex; i >= 0; i--) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function replaceAsync(str, search, replacer) {
  const parts = [];
  let last = 0;
  for (const match of str.matchAll(search)) {
    parts.push(str.slice(last, match.index));
    if (match.index === void 0) {
      throw new Error("match.index should be defined");
    }
    last = match.index + match[0].length;
    parts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));
  }
  parts.push(str.slice(last));
  return Promise.all(parts).then((p) => p.join(""));
}
function compare(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}
function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    const codeA = a.charCodeAt(aStart);
    const codeB = b.charCodeAt(bStart);
    if (codeA < codeB) {
      return -1;
    } else if (codeA > codeB) {
      return 1;
    }
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function compareIgnoreCase(a, b) {
  return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
}
function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let codeA = a.charCodeAt(aStart);
    let codeB = b.charCodeAt(bStart);
    if (codeA === codeB) {
      continue;
    }
    if (codeA >= 128 || codeB >= 128) {
      return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
    }
    if (isLowerAsciiLetter(codeA)) {
      codeA -= 32;
    }
    if (isLowerAsciiLetter(codeB)) {
      codeB -= 32;
    }
    const diff = codeA - codeB;
    if (diff === 0) {
      continue;
    }
    return diff;
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function isAsciiDigit(code) {
  return code >= 48 && code <= 57;
}
function isLowerAsciiLetter(code) {
  return code >= 97 && code <= 122;
}
function isUpperAsciiLetter(code) {
  return code >= 65 && code <= 90;
}
function equalsIgnoreCase(a, b) {
  return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;
}
function startsWithIgnoreCase(str, candidate) {
  const candidateLength = candidate.length;
  if (candidate.length > str.length) {
    return false;
  }
  return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;
}
function commonPrefixLength(a, b) {
  const len = Math.min(a.length, b.length);
  let i;
  for (i = 0; i < len; i++) {
    if (a.charCodeAt(i) !== b.charCodeAt(i)) {
      return i;
    }
  }
  return len;
}
function commonSuffixLength(a, b) {
  const len = Math.min(a.length, b.length);
  let i;
  const aLastIndex = a.length - 1;
  const bLastIndex = b.length - 1;
  for (i = 0; i < len; i++) {
    if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
      return i;
    }
  }
  return len;
}
function isHighSurrogate(charCode) {
  return 55296 <= charCode && charCode <= 56319;
}
function isLowSurrogate(charCode) {
  return 56320 <= charCode && charCode <= 57343;
}
function computeCodePoint(highSurrogate, lowSurrogate) {
  return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
}
function getNextCodePoint(str, len, offset) {
  const charCode = str.charCodeAt(offset);
  if (isHighSurrogate(charCode) && offset + 1 < len) {
    const nextCharCode = str.charCodeAt(offset + 1);
    if (isLowSurrogate(nextCharCode)) {
      return computeCodePoint(charCode, nextCharCode);
    }
  }
  return charCode;
}
function getPrevCodePoint(str, offset) {
  const charCode = str.charCodeAt(offset - 1);
  if (isLowSurrogate(charCode) && offset > 1) {
    const prevCharCode = str.charCodeAt(offset - 2);
    if (isHighSurrogate(prevCharCode)) {
      return computeCodePoint(prevCharCode, charCode);
    }
  }
  return charCode;
}
function nextCharLength(str, initialOffset) {
  const iterator = new GraphemeIterator(str, initialOffset);
  return iterator.nextGraphemeLength();
}
function prevCharLength(str, initialOffset) {
  const iterator = new GraphemeIterator(str, initialOffset);
  return iterator.prevGraphemeLength();
}
function getCharContainingOffset(str, offset) {
  if (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {
    offset--;
  }
  const endOffset = offset + nextCharLength(str, offset);
  const startOffset = endOffset - prevCharLength(str, endOffset);
  return [startOffset, endOffset];
}
function makeContainsRtl() {
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
}
function containsRTL(str) {
  if (!CONTAINS_RTL) {
    CONTAINS_RTL = makeContainsRtl();
  }
  return CONTAINS_RTL.test(str);
}
function isBasicASCII(str) {
  return IS_BASIC_ASCII.test(str);
}
function containsUnusualLineTerminators(str) {
  return UNUSUAL_LINE_TERMINATORS.test(str);
}
function isFullWidthCharacter(charCode) {
  return charCode >= 11904 && charCode <= 55215 || charCode >= 63744 && charCode <= 64255 || charCode >= 65281 && charCode <= 65374;
}
function isEmojiImprecise(x) {
  return x >= 127462 && x <= 127487 || x === 8986 || x === 8987 || x === 9200 || x === 9203 || x >= 9728 && x <= 10175 || x === 11088 || x === 11093 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129008 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129782;
}
function lcut(text, n) {
  if (text.length < n) {
    return text;
  }
  const re = /\b/g;
  let i = 0;
  while (re.test(text)) {
    if (text.length - re.lastIndex < n) {
      break;
    }
    i = re.lastIndex;
    re.lastIndex += 1;
  }
  return text.substring(i).replace(/^\s/, "");
}
function removeAnsiEscapeCodes(str) {
  if (str) {
    str = str.replace(CSI_SEQUENCE, "").replace(CSI_CUSTOM_SEQUENCE, "");
  }
  return str;
}
function startsWithUTF8BOM(str) {
  return !!(str && str.length > 0 && str.charCodeAt(0) === 65279);
}
function fuzzyContains(target, query) {
  if (!target || !query) {
    return false;
  }
  if (target.length < query.length) {
    return false;
  }
  const queryLen = query.length;
  const targetLower = target.toLowerCase();
  let index2 = 0;
  let lastIndexOf = -1;
  while (index2 < queryLen) {
    const indexOf = targetLower.indexOf(query[index2], lastIndexOf + 1);
    if (indexOf < 0) {
      return false;
    }
    lastIndexOf = indexOf;
    index2++;
  }
  return true;
}
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
  if (!target) {
    return false;
  }
  if (ignoreEscapedChars) {
    target = target.replace(/\\./g, "");
  }
  return target.toLowerCase() !== target;
}
function getNLines(str, n = 1) {
  if (n === 0) {
    return "";
  }
  let idx = -1;
  do {
    idx = str.indexOf("\n", idx + 1);
    n--;
  } while (n > 0 && idx >= 0);
  if (idx === -1) {
    return str;
  }
  if (str[idx - 1] === "\r") {
    idx--;
  }
  return str.substr(0, idx);
}
function singleLetterHash(n) {
  const LETTERS_CNT = 90 - 65 + 1;
  n = n % (2 * LETTERS_CNT);
  if (n < LETTERS_CNT) {
    return String.fromCharCode(97 + n);
  }
  return String.fromCharCode(65 + n - LETTERS_CNT);
}
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
  if (breakTypeA === 0) {
    return breakTypeB !== 5 && breakTypeB !== 7;
  }
  if (breakTypeA === 2) {
    if (breakTypeB === 3) {
      return false;
    }
  }
  if (breakTypeA === 4 || breakTypeA === 2 || breakTypeA === 3) {
    return true;
  }
  if (breakTypeB === 4 || breakTypeB === 2 || breakTypeB === 3) {
    return true;
  }
  if (breakTypeA === 8) {
    if (breakTypeB === 8 || breakTypeB === 9 || breakTypeB === 11 || breakTypeB === 12) {
      return false;
    }
  }
  if (breakTypeA === 11 || breakTypeA === 9) {
    if (breakTypeB === 9 || breakTypeB === 10) {
      return false;
    }
  }
  if (breakTypeA === 12 || breakTypeA === 10) {
    if (breakTypeB === 10) {
      return false;
    }
  }
  if (breakTypeB === 5 || breakTypeB === 13) {
    return false;
  }
  if (breakTypeB === 7) {
    return false;
  }
  if (breakTypeA === 1) {
    return false;
  }
  if (breakTypeA === 13 && breakTypeB === 14) {
    return false;
  }
  if (breakTypeA === 6 && breakTypeB === 6) {
    return false;
  }
  return true;
}
function getGraphemeBreakRawData() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
function getLeftDeleteOffset(offset, str) {
  if (offset === 0) {
    return 0;
  }
  const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);
  if (emojiOffset !== void 0) {
    return emojiOffset;
  }
  const iterator = new CodePointIterator(str, offset);
  iterator.prevCodePoint();
  return iterator.offset;
}
function getOffsetBeforeLastEmojiComponent(initialOffset, str) {
  const iterator = new CodePointIterator(str, initialOffset);
  let codePoint = iterator.prevCodePoint();
  while (isEmojiModifier(codePoint) || codePoint === 65039 || codePoint === 8419) {
    if (iterator.offset === 0) {
      return void 0;
    }
    codePoint = iterator.prevCodePoint();
  }
  if (!isEmojiImprecise(codePoint)) {
    return void 0;
  }
  let resultOffset = iterator.offset;
  if (resultOffset > 0) {
    const optionalZwjCodePoint = iterator.prevCodePoint();
    if (optionalZwjCodePoint === 8205) {
      resultOffset = iterator.offset;
    }
  }
  return resultOffset;
}
function isEmojiModifier(codePoint) {
  return 127995 <= codePoint && codePoint <= 127999;
}
var _a3, _formatRegexp, _format2Regexp, CodePointIterator, GraphemeIterator, CONTAINS_RTL, IS_BASIC_ASCII, UNUSUAL_LINE_TERMINATORS, CSI_SEQUENCE, CSI_CUSTOM_SEQUENCE, UTF8_BOM_CHARACTER, GraphemeBreakTree, noBreakWhitespace, AmbiguousCharacters, InvisibleCharacters;
var init_strings = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/strings.js"() {
    init_cache();
    init_lazy();
    _formatRegexp = /{(\d+)}/g;
    _format2Regexp = /{([^}]+)}/g;
    CodePointIterator = class {
      get offset() {
        return this._offset;
      }
      constructor(str, offset = 0) {
        this._str = str;
        this._len = str.length;
        this._offset = offset;
      }
      setOffset(offset) {
        this._offset = offset;
      }
      prevCodePoint() {
        const codePoint = getPrevCodePoint(this._str, this._offset);
        this._offset -= codePoint >= 65536 ? 2 : 1;
        return codePoint;
      }
      nextCodePoint() {
        const codePoint = getNextCodePoint(this._str, this._len, this._offset);
        this._offset += codePoint >= 65536 ? 2 : 1;
        return codePoint;
      }
      eol() {
        return this._offset >= this._len;
      }
    };
    GraphemeIterator = class {
      get offset() {
        return this._iterator.offset;
      }
      constructor(str, offset = 0) {
        this._iterator = new CodePointIterator(str, offset);
      }
      nextGraphemeLength() {
        const graphemeBreakTree = GraphemeBreakTree.getInstance();
        const iterator = this._iterator;
        const initialOffset = iterator.offset;
        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
        while (!iterator.eol()) {
          const offset = iterator.offset;
          const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
          if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
            iterator.setOffset(offset);
            break;
          }
          graphemeBreakType = nextGraphemeBreakType;
        }
        return iterator.offset - initialOffset;
      }
      prevGraphemeLength() {
        const graphemeBreakTree = GraphemeBreakTree.getInstance();
        const iterator = this._iterator;
        const initialOffset = iterator.offset;
        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
        while (iterator.offset > 0) {
          const offset = iterator.offset;
          const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
          if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
            iterator.setOffset(offset);
            break;
          }
          graphemeBreakType = prevGraphemeBreakType;
        }
        return initialOffset - iterator.offset;
      }
      eol() {
        return this._iterator.eol();
      }
    };
    CONTAINS_RTL = void 0;
    IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
    UNUSUAL_LINE_TERMINATORS = /[\u2028\u2029]/;
    CSI_SEQUENCE = /(:?\x1b\[|\x9B)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/g;
    CSI_CUSTOM_SEQUENCE = /\x1b\].*?\x07/g;
    UTF8_BOM_CHARACTER = String.fromCharCode(
      65279
      /* CharCode.UTF8_BOM */
    );
    GraphemeBreakTree = class _GraphemeBreakTree {
      static getInstance() {
        if (!_GraphemeBreakTree._INSTANCE) {
          _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();
        }
        return _GraphemeBreakTree._INSTANCE;
      }
      constructor() {
        this._data = getGraphemeBreakRawData();
      }
      getGraphemeBreakType(codePoint) {
        if (codePoint < 32) {
          if (codePoint === 10) {
            return 3;
          }
          if (codePoint === 13) {
            return 2;
          }
          return 4;
        }
        if (codePoint < 127) {
          return 0;
        }
        const data = this._data;
        const nodeCount = data.length / 3;
        let nodeIndex = 1;
        while (nodeIndex <= nodeCount) {
          if (codePoint < data[3 * nodeIndex]) {
            nodeIndex = 2 * nodeIndex;
          } else if (codePoint > data[3 * nodeIndex + 1]) {
            nodeIndex = 2 * nodeIndex + 1;
          } else {
            return data[3 * nodeIndex + 2];
          }
        }
        return 0;
      }
    };
    GraphemeBreakTree._INSTANCE = null;
    noBreakWhitespace = " ";
    AmbiguousCharacters = class {
      static getInstance(locales) {
        return _a3.cache.get(Array.from(locales));
      }
      static getLocales() {
        return _a3._locales.value;
      }
      constructor(confusableDictionary) {
        this.confusableDictionary = confusableDictionary;
      }
      isAmbiguous(codePoint) {
        return this.confusableDictionary.has(codePoint);
      }
      /**
       * Returns the non basic ASCII code point that the given code point can be confused,
       * or undefined if such code point does note exist.
       */
      getPrimaryConfusable(codePoint) {
        return this.confusableDictionary.get(codePoint);
      }
      getConfusableCodePoints() {
        return new Set(this.confusableDictionary.keys());
      }
    };
    _a3 = AmbiguousCharacters;
    AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
      return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
    });
    AmbiguousCharacters.cache = new LRUCachedFunction((locales) => {
      function arrayToMap(arr) {
        const result = /* @__PURE__ */ new Map();
        for (let i = 0; i < arr.length; i += 2) {
          result.set(arr[i], arr[i + 1]);
        }
        return result;
      }
      function mergeMaps(map1, map2) {
        const result = new Map(map1);
        for (const [key, value] of map2) {
          result.set(key, value);
        }
        return result;
      }
      function intersectMaps(map1, map2) {
        if (!map1) {
          return map2;
        }
        const result = /* @__PURE__ */ new Map();
        for (const [key, value] of map1) {
          if (map2.has(key)) {
            result.set(key, value);
          }
        }
        return result;
      }
      const data = _a3.ambiguousCharacterData.value;
      let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
      if (filteredLocales.length === 0) {
        filteredLocales = ["_default"];
      }
      let languageSpecificMap = void 0;
      for (const locale of filteredLocales) {
        const map2 = arrayToMap(data[locale]);
        languageSpecificMap = intersectMaps(languageSpecificMap, map2);
      }
      const commonMap = arrayToMap(data["_common"]);
      const map = mergeMaps(commonMap, languageSpecificMap);
      return new _a3(map);
    });
    AmbiguousCharacters._locales = new Lazy(() => Object.keys(_a3.ambiguousCharacterData.value).filter((k) => !k.startsWith("_")));
    InvisibleCharacters = class _InvisibleCharacters {
      static getRawData() {
        return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
      }
      static getData() {
        if (!this._data) {
          this._data = new Set(_InvisibleCharacters.getRawData());
        }
        return this._data;
      }
      static isInvisibleCharacter(codePoint) {
        return _InvisibleCharacters.getData().has(codePoint);
      }
      static get codePoints() {
        return _InvisibleCharacters.getData();
      }
    };
    InvisibleCharacters._data = void 0;
  }
});

// node_modules/monaco-editor/esm/vs/base/common/extpath.js
function isPathSeparator2(code) {
  return code === 47 || code === 92;
}
function toSlashes(osPath) {
  return osPath.replace(/[\\/]/g, posix.sep);
}
function toPosixPath(osPath) {
  if (osPath.indexOf("/") === -1) {
    osPath = toSlashes(osPath);
  }
  if (/^[a-zA-Z]:(\/|$)/.test(osPath)) {
    osPath = "/" + osPath;
  }
  return osPath;
}
function getRoot(path, sep2 = posix.sep) {
  if (!path) {
    return "";
  }
  const len = path.length;
  const firstLetter = path.charCodeAt(0);
  if (isPathSeparator2(firstLetter)) {
    if (isPathSeparator2(path.charCodeAt(1))) {
      if (!isPathSeparator2(path.charCodeAt(2))) {
        let pos2 = 3;
        const start = pos2;
        for (; pos2 < len; pos2++) {
          if (isPathSeparator2(path.charCodeAt(pos2))) {
            break;
          }
        }
        if (start !== pos2 && !isPathSeparator2(path.charCodeAt(pos2 + 1))) {
          pos2 += 1;
          for (; pos2 < len; pos2++) {
            if (isPathSeparator2(path.charCodeAt(pos2))) {
              return path.slice(0, pos2 + 1).replace(/[\\/]/g, sep2);
            }
          }
        }
      }
    }
    return sep2;
  } else if (isWindowsDriveLetter(firstLetter)) {
    if (path.charCodeAt(1) === 58) {
      if (isPathSeparator2(path.charCodeAt(2))) {
        return path.slice(0, 2) + sep2;
      } else {
        return path.slice(0, 2);
      }
    }
  }
  let pos = path.indexOf("://");
  if (pos !== -1) {
    pos += 3;
    for (; pos < len; pos++) {
      if (isPathSeparator2(path.charCodeAt(pos))) {
        return path.slice(0, pos + 1);
      }
    }
  }
  return "";
}
function isUNC(path) {
  if (!isWindows) {
    return false;
  }
  if (!path || path.length < 5) {
    return false;
  }
  let code = path.charCodeAt(0);
  if (code !== 92) {
    return false;
  }
  code = path.charCodeAt(1);
  if (code !== 92) {
    return false;
  }
  let pos = 2;
  const start = pos;
  for (; pos < path.length; pos++) {
    code = path.charCodeAt(pos);
    if (code === 92) {
      break;
    }
  }
  if (start === pos) {
    return false;
  }
  code = path.charCodeAt(pos + 1);
  if (isNaN(code) || code === 92) {
    return false;
  }
  return true;
}
function isValidBasename(name, isWindowsOS = isWindows) {
  const invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;
  if (!name || name.length === 0 || /^\s+$/.test(name)) {
    return false;
  }
  invalidFileChars.lastIndex = 0;
  if (invalidFileChars.test(name)) {
    return false;
  }
  if (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {
    return false;
  }
  if (name === "." || name === "..") {
    return false;
  }
  if (isWindowsOS && name[name.length - 1] === ".") {
    return false;
  }
  if (isWindowsOS && name.length !== name.trim().length) {
    return false;
  }
  if (name.length > 255) {
    return false;
  }
  return true;
}
function isEqual(pathA, pathB, ignoreCase) {
  const identityEquals = pathA === pathB;
  if (!ignoreCase || identityEquals) {
    return identityEquals;
  }
  if (!pathA || !pathB) {
    return false;
  }
  return equalsIgnoreCase(pathA, pathB);
}
function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {
  if (base === parentCandidate) {
    return true;
  }
  if (!base || !parentCandidate) {
    return false;
  }
  if (parentCandidate.length > base.length) {
    return false;
  }
  if (ignoreCase) {
    const beginsWith = startsWithIgnoreCase(base, parentCandidate);
    if (!beginsWith) {
      return false;
    }
    if (parentCandidate.length === base.length) {
      return true;
    }
    let sepOffset = parentCandidate.length;
    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {
      sepOffset--;
    }
    return base.charAt(sepOffset) === separator;
  }
  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {
    parentCandidate += separator;
  }
  return base.indexOf(parentCandidate) === 0;
}
function isWindowsDriveLetter(char0) {
  return char0 >= 65 && char0 <= 90 || char0 >= 97 && char0 <= 122;
}
function hasDriveLetter(path, isWindowsOS = isWindows) {
  if (isWindowsOS) {
    return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58;
  }
  return false;
}
function getDriveLetter(path, isWindowsOS = isWindows) {
  return hasDriveLetter(path, isWindowsOS) ? path[0] : void 0;
}
function indexOfPath(path, candidate, ignoreCase) {
  if (candidate.length > path.length) {
    return -1;
  }
  if (path === candidate) {
    return 0;
  }
  if (ignoreCase) {
    path = path.toLowerCase();
    candidate = candidate.toLowerCase();
  }
  return path.indexOf(candidate);
}
function parseLineAndColumnAware(rawPath) {
  const segments = rawPath.split(":");
  let path = void 0;
  let line = void 0;
  let column = void 0;
  for (const segment of segments) {
    const segmentAsNumber = Number(segment);
    if (!isNumber(segmentAsNumber)) {
      path = !!path ? [path, segment].join(":") : segment;
    } else if (line === void 0) {
      line = segmentAsNumber;
    } else if (column === void 0) {
      column = segmentAsNumber;
    }
  }
  if (!path) {
    throw new Error("Format for `--goto` should be: `FILE:LINE(:COLUMN)`");
  }
  return {
    path,
    line: line !== void 0 ? line : void 0,
    column: column !== void 0 ? column : line !== void 0 ? 1 : void 0
    // if we have a line, make sure column is also set
  };
}
var WINDOWS_INVALID_FILE_CHARS, UNIX_INVALID_FILE_CHARS, WINDOWS_FORBIDDEN_NAMES;
var init_extpath = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/extpath.js"() {
    init_path();
    init_platform();
    init_strings();
    init_types();
    WINDOWS_INVALID_FILE_CHARS = /[\\/:\*\?"<>\|]/g;
    UNIX_INVALID_FILE_CHARS = /[\\/]/g;
    WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i;
  }
});

// node_modules/monaco-editor/esm/vs/base/common/resources.js
function originalFSPath(uri) {
  return uriToFsPath(uri, true);
}
function distinctParents(items, resourceAccessor) {
  const distinctParents2 = [];
  for (let i = 0; i < items.length; i++) {
    const candidateResource = resourceAccessor(items[i]);
    if (items.some((otherItem, index2) => {
      if (index2 === i) {
        return false;
      }
      return isEqualOrParent2(candidateResource, resourceAccessor(otherItem));
    })) {
      continue;
    }
    distinctParents2.push(items[i]);
  }
  return distinctParents2;
}
function toLocalResource(resource, authority, localScheme) {
  if (authority) {
    let path = resource.path;
    if (path && path[0] !== posix.sep) {
      path = posix.sep + path;
    }
    return resource.with({ scheme: localScheme, authority, path });
  }
  return resource.with({ scheme: localScheme });
}
var ExtUri, extUri, extUriBiasedIgnorePathCase, extUriIgnorePathCase, isEqual2, isEqualOrParent2, getComparisonKey, basenameOrAuthority, basename2, extname2, dirname2, joinPath, normalizePath, relativePath, resolvePath, isAbsolutePath, isEqualAuthority, hasTrailingPathSeparator, removeTrailingPathSeparator, addTrailingPathSeparator, DataUri;
var init_resources = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/resources.js"() {
    init_extpath();
    init_network();
    init_path();
    init_platform();
    init_strings();
    init_uri();
    ExtUri = class {
      constructor(_ignorePathCasing) {
        this._ignorePathCasing = _ignorePathCasing;
      }
      compare(uri1, uri2, ignoreFragment = false) {
        if (uri1 === uri2) {
          return 0;
        }
        return compare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));
      }
      isEqual(uri1, uri2, ignoreFragment = false) {
        if (uri1 === uri2) {
          return true;
        }
        if (!uri1 || !uri2) {
          return false;
        }
        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);
      }
      getComparisonKey(uri, ignoreFragment = false) {
        return uri.with({
          path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : void 0,
          fragment: ignoreFragment ? null : void 0
        }).toString();
      }
      ignorePathCasing(uri) {
        return this._ignorePathCasing(uri);
      }
      isEqualOrParent(base, parentCandidate, ignoreFragment = false) {
        if (base.scheme === parentCandidate.scheme) {
          if (base.scheme === Schemas.file) {
            return isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
          }
          if (isEqualAuthority(base.authority, parentCandidate.authority)) {
            return isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), "/") && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
          }
        }
        return false;
      }
      // --- path math
      joinPath(resource, ...pathFragment) {
        return URI.joinPath(resource, ...pathFragment);
      }
      basenameOrAuthority(resource) {
        return basename2(resource) || resource.authority;
      }
      basename(resource) {
        return posix.basename(resource.path);
      }
      extname(resource) {
        return posix.extname(resource.path);
      }
      dirname(resource) {
        if (resource.path.length === 0) {
          return resource;
        }
        let dirname3;
        if (resource.scheme === Schemas.file) {
          dirname3 = URI.file(dirname(originalFSPath(resource))).path;
        } else {
          dirname3 = posix.dirname(resource.path);
          if (resource.authority && dirname3.length && dirname3.charCodeAt(0) !== 47) {
            console.error(`dirname("${resource.toString})) resulted in a relative path`);
            dirname3 = "/";
          }
        }
        return resource.with({
          path: dirname3
        });
      }
      normalizePath(resource) {
        if (!resource.path.length) {
          return resource;
        }
        let normalizedPath;
        if (resource.scheme === Schemas.file) {
          normalizedPath = URI.file(normalize(originalFSPath(resource))).path;
        } else {
          normalizedPath = posix.normalize(resource.path);
        }
        return resource.with({
          path: normalizedPath
        });
      }
      relativePath(from, to) {
        if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {
          return void 0;
        }
        if (from.scheme === Schemas.file) {
          const relativePath2 = relative(originalFSPath(from), originalFSPath(to));
          return isWindows ? toSlashes(relativePath2) : relativePath2;
        }
        let fromPath = from.path || "/";
        const toPath = to.path || "/";
        if (this._ignorePathCasing(from)) {
          let i = 0;
          for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {
            if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {
              if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {
                break;
              }
            }
          }
          fromPath = toPath.substr(0, i) + fromPath.substr(i);
        }
        return posix.relative(fromPath, toPath);
      }
      resolvePath(base, path) {
        if (base.scheme === Schemas.file) {
          const newURI = URI.file(resolve(originalFSPath(base), path));
          return base.with({
            authority: newURI.authority,
            path: newURI.path
          });
        }
        path = toPosixPath(path);
        return base.with({
          path: posix.resolve(base.path, path)
        });
      }
      // --- misc
      isAbsolutePath(resource) {
        return !!resource.path && resource.path[0] === "/";
      }
      isEqualAuthority(a1, a2) {
        return a1 === a2 || a1 !== void 0 && a2 !== void 0 && equalsIgnoreCase(a1, a2);
      }
      hasTrailingPathSeparator(resource, sep2 = sep) {
        if (resource.scheme === Schemas.file) {
          const fsp = originalFSPath(resource);
          return fsp.length > getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
        } else {
          const p = resource.path;
          return p.length > 1 && p.charCodeAt(p.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(resource.fsPath);
        }
      }
      removeTrailingPathSeparator(resource, sep2 = sep) {
        if (hasTrailingPathSeparator(resource, sep2)) {
          return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });
        }
        return resource;
      }
      addTrailingPathSeparator(resource, sep2 = sep) {
        let isRootSep = false;
        if (resource.scheme === Schemas.file) {
          const fsp = originalFSPath(resource);
          isRootSep = fsp !== void 0 && fsp.length === getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
        } else {
          sep2 = "/";
          const p = resource.path;
          isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47;
        }
        if (!isRootSep && !hasTrailingPathSeparator(resource, sep2)) {
          return resource.with({ path: resource.path + "/" });
        }
        return resource;
      }
    };
    extUri = new ExtUri(() => false);
    extUriBiasedIgnorePathCase = new ExtUri((uri) => {
      return uri.scheme === Schemas.file ? !isLinux : true;
    });
    extUriIgnorePathCase = new ExtUri((_) => true);
    isEqual2 = extUri.isEqual.bind(extUri);
    isEqualOrParent2 = extUri.isEqualOrParent.bind(extUri);
    getComparisonKey = extUri.getComparisonKey.bind(extUri);
    basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);
    basename2 = extUri.basename.bind(extUri);
    extname2 = extUri.extname.bind(extUri);
    dirname2 = extUri.dirname.bind(extUri);
    joinPath = extUri.joinPath.bind(extUri);
    normalizePath = extUri.normalizePath.bind(extUri);
    relativePath = extUri.relativePath.bind(extUri);
    resolvePath = extUri.resolvePath.bind(extUri);
    isAbsolutePath = extUri.isAbsolutePath.bind(extUri);
    isEqualAuthority = extUri.isEqualAuthority.bind(extUri);
    hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);
    removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);
    addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);
    (function(DataUri2) {
      DataUri2.META_DATA_LABEL = "label";
      DataUri2.META_DATA_DESCRIPTION = "description";
      DataUri2.META_DATA_SIZE = "size";
      DataUri2.META_DATA_MIME = "mime";
      function parseMetaData(dataUri) {
        const metadata = /* @__PURE__ */ new Map();
        const meta = dataUri.path.substring(dataUri.path.indexOf(";") + 1, dataUri.path.lastIndexOf(";"));
        meta.split(";").forEach((property) => {
          const [key, value] = property.split(":");
          if (key && value) {
            metadata.set(key, value);
          }
        });
        const mime = dataUri.path.substring(0, dataUri.path.indexOf(";"));
        if (mime) {
          metadata.set(DataUri2.META_DATA_MIME, mime);
        }
        return metadata;
      }
      DataUri2.parseMetaData = parseMetaData;
    })(DataUri || (DataUri = {}));
  }
});

// node_modules/monaco-editor/esm/vs/base/common/arrays.js
function tail(array, n = 0) {
  return array[array.length - (1 + n)];
}
function tail2(arr) {
  if (arr.length === 0) {
    throw new Error("Invalid tail call");
  }
  return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
}
function equals(one, other, itemEquals = (a, b) => a === b) {
  if (one === other) {
    return true;
  }
  if (!one || !other) {
    return false;
  }
  if (one.length !== other.length) {
    return false;
  }
  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }
  return true;
}
function removeFastWithoutKeepingOrder(array, index2) {
  const last = array.length - 1;
  if (index2 < last) {
    array[index2] = array[last];
  }
  array.pop();
}
function binarySearch(array, key, comparator) {
  return binarySearch2(array.length, (i) => comparator(array[i], key));
}
function binarySearch2(length, compareToKey) {
  let low = 0, high = length - 1;
  while (low <= high) {
    const mid = (low + high) / 2 | 0;
    const comp = compareToKey(mid);
    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return -(low + 1);
}
function findFirstInSorted(array, p) {
  let low = 0, high = array.length;
  if (high === 0) {
    return 0;
  }
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (p(array[mid])) {
      high = mid;
    } else {
      low = mid + 1;
    }
  }
  return low;
}
function quickSelect(nth, data, compare2) {
  nth = nth | 0;
  if (nth >= data.length) {
    throw new TypeError("invalid index");
  }
  const pivotValue = data[Math.floor(data.length * Math.random())];
  const lower = [];
  const higher = [];
  const pivots = [];
  for (const value of data) {
    const val = compare2(value, pivotValue);
    if (val < 0) {
      lower.push(value);
    } else if (val > 0) {
      higher.push(value);
    } else {
      pivots.push(value);
    }
  }
  if (nth < lower.length) {
    return quickSelect(nth, lower, compare2);
  } else if (nth < lower.length + pivots.length) {
    return pivots[0];
  } else {
    return quickSelect(nth - (lower.length + pivots.length), higher, compare2);
  }
}
function groupBy(data, compare2) {
  const result = [];
  let currentGroup = void 0;
  for (const element of data.slice(0).sort(compare2)) {
    if (!currentGroup || compare2(currentGroup[0], element) !== 0) {
      currentGroup = [element];
      result.push(currentGroup);
    } else {
      currentGroup.push(element);
    }
  }
  return result;
}
function sortedDiff(before, after, compare2) {
  const result = [];
  function pushSplice(start, deleteCount, toInsert) {
    if (deleteCount === 0 && toInsert.length === 0) {
      return;
    }
    const latest = result[result.length - 1];
    if (latest && latest.start + latest.deleteCount === start) {
      latest.deleteCount += deleteCount;
      latest.toInsert.push(...toInsert);
    } else {
      result.push({ start, deleteCount, toInsert });
    }
  }
  let beforeIdx = 0;
  let afterIdx = 0;
  while (true) {
    if (beforeIdx === before.length) {
      pushSplice(beforeIdx, 0, after.slice(afterIdx));
      break;
    }
    if (afterIdx === after.length) {
      pushSplice(beforeIdx, before.length - beforeIdx, []);
      break;
    }
    const beforeElement = before[beforeIdx];
    const afterElement = after[afterIdx];
    const n = compare2(beforeElement, afterElement);
    if (n === 0) {
      beforeIdx += 1;
      afterIdx += 1;
    } else if (n < 0) {
      pushSplice(beforeIdx, 1, []);
      beforeIdx += 1;
    } else if (n > 0) {
      pushSplice(beforeIdx, 0, [afterElement]);
      afterIdx += 1;
    }
  }
  return result;
}
function delta(before, after, compare2) {
  const splices = sortedDiff(before, after, compare2);
  const removed = [];
  const added = [];
  for (const splice2 of splices) {
    removed.push(...before.slice(splice2.start, splice2.start + splice2.deleteCount));
    added.push(...splice2.toInsert);
  }
  return { removed, added };
}
function coalesce(array) {
  return array.filter((e) => !!e);
}
function coalesceInPlace(array) {
  let to = 0;
  for (let i = 0; i < array.length; i++) {
    if (!!array[i]) {
      array[to] = array[i];
      to += 1;
    }
  }
  array.length = to;
}
function isFalsyOrEmpty(obj) {
  return !Array.isArray(obj) || obj.length === 0;
}
function isNonEmptyArray(obj) {
  return Array.isArray(obj) && obj.length > 0;
}
function distinct(array, keyFn = (value) => value) {
  const seen = /* @__PURE__ */ new Set();
  return array.filter((element) => {
    const key = keyFn(element);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}
function findLast(arr, predicate) {
  const idx = findLastIndex(arr, predicate);
  if (idx === -1) {
    return void 0;
  }
  return arr[idx];
}
function findLastIndex(array, fn) {
  for (let i = array.length - 1; i >= 0; i--) {
    const element = array[i];
    if (fn(element)) {
      return i;
    }
  }
  return -1;
}
function firstOrDefault(array, notFoundValue) {
  return array.length > 0 ? array[0] : notFoundValue;
}
function lastOrDefault(array, notFoundValue) {
  return array.length > 0 ? array[array.length - 1] : notFoundValue;
}
function flatten(arr) {
  return [].concat(...arr);
}
function range(arg, to) {
  let from = typeof to === "number" ? arg : 0;
  if (typeof to === "number") {
    from = arg;
  } else {
    from = 0;
    to = arg;
  }
  const result = [];
  if (from <= to) {
    for (let i = from; i < to; i++) {
      result.push(i);
    }
  } else {
    for (let i = from; i > to; i--) {
      result.push(i);
    }
  }
  return result;
}
function index(array, indexer, mapper) {
  return array.reduce((r, t) => {
    r[indexer(t)] = mapper ? mapper(t) : t;
    return r;
  }, /* @__PURE__ */ Object.create(null));
}
function insert(array, element) {
  array.push(element);
  return () => remove(array, element);
}
function remove(array, element) {
  const index2 = array.indexOf(element);
  if (index2 > -1) {
    array.splice(index2, 1);
    return element;
  }
  return void 0;
}
function arrayInsert(target, insertIndex, insertArr) {
  const before = target.slice(0, insertIndex);
  const after = target.slice(insertIndex);
  return before.concat(insertArr, after);
}
function shuffle(array, _seed) {
  let rand;
  if (typeof _seed === "number") {
    let seed = _seed;
    rand = () => {
      const x = Math.sin(seed++) * 179426549;
      return x - Math.floor(x);
    };
  } else {
    rand = Math.random;
  }
  for (let i = array.length - 1; i > 0; i -= 1) {
    const j = Math.floor(rand() * (i + 1));
    const temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
}
function pushToStart(arr, value) {
  const index2 = arr.indexOf(value);
  if (index2 > -1) {
    arr.splice(index2, 1);
    arr.unshift(value);
  }
}
function pushToEnd(arr, value) {
  const index2 = arr.indexOf(value);
  if (index2 > -1) {
    arr.splice(index2, 1);
    arr.push(value);
  }
}
function pushMany(arr, items) {
  for (const item of items) {
    arr.push(item);
  }
}
function mapArrayOrNot(items, fn) {
  return Array.isArray(items) ? items.map(fn) : fn(items);
}
function asArray(x) {
  return Array.isArray(x) ? x : [x];
}
function mapFind(array, mapFn) {
  for (const value of array) {
    const mapped = mapFn(value);
    if (mapped !== void 0) {
      return mapped;
    }
  }
  return void 0;
}
function insertInto(array, start, newItems) {
  const startIdx = getActualStartIndex(array, start);
  const originalLength = array.length;
  const newItemsLength = newItems.length;
  array.length = originalLength + newItemsLength;
  for (let i = originalLength - 1; i >= startIdx; i--) {
    array[i + newItemsLength] = array[i];
  }
  for (let i = 0; i < newItemsLength; i++) {
    array[i + startIdx] = newItems[i];
  }
}
function splice(array, start, deleteCount, newItems) {
  const index2 = getActualStartIndex(array, start);
  const result = array.splice(index2, deleteCount);
  insertInto(array, index2, newItems);
  return result;
}
function getActualStartIndex(array, start) {
  return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);
}
function compareBy(selector, comparator) {
  return (a, b) => comparator(selector(a), selector(b));
}
function tieBreakComparators(...comparators) {
  return (item1, item2) => {
    for (const comparator of comparators) {
      const result = comparator(item1, item2);
      if (!CompareResult.isNeitherLessOrGreaterThan(result)) {
        return result;
      }
    }
    return CompareResult.neitherLessOrGreaterThan;
  };
}
function reverseOrder(comparator) {
  return (a, b) => -comparator(a, b);
}
function findMaxBy(items, comparator) {
  if (items.length === 0) {
    return void 0;
  }
  let max = items[0];
  for (let i = 1; i < items.length; i++) {
    const item = items[i];
    if (comparator(item, max) > 0) {
      max = item;
    }
  }
  return max;
}
function findLastMaxBy(items, comparator) {
  if (items.length === 0) {
    return void 0;
  }
  let max = items[0];
  for (let i = 1; i < items.length; i++) {
    const item = items[i];
    if (comparator(item, max) >= 0) {
      max = item;
    }
  }
  return max;
}
function findMinBy(items, comparator) {
  return findMaxBy(items, (a, b) => -comparator(a, b));
}
function findMaxIdxBy(items, comparator) {
  if (items.length === 0) {
    return -1;
  }
  let maxIdx = 0;
  for (let i = 1; i < items.length; i++) {
    const item = items[i];
    if (comparator(item, items[maxIdx]) > 0) {
      maxIdx = i;
    }
  }
  return maxIdx;
}
var CompareResult, numberComparator, booleanComparator, ArrayQueue, CallbackIterable;
var init_arrays = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/arrays.js"() {
    init_errors();
    (function(CompareResult2) {
      function isLessThan(result) {
        return result < 0;
      }
      CompareResult2.isLessThan = isLessThan;
      function isLessThanOrEqual(result) {
        return result <= 0;
      }
      CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
      function isGreaterThan(result) {
        return result > 0;
      }
      CompareResult2.isGreaterThan = isGreaterThan;
      function isNeitherLessOrGreaterThan(result) {
        return result === 0;
      }
      CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
      CompareResult2.greaterThan = 1;
      CompareResult2.lessThan = -1;
      CompareResult2.neitherLessOrGreaterThan = 0;
    })(CompareResult || (CompareResult = {}));
    numberComparator = (a, b) => a - b;
    booleanComparator = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);
    ArrayQueue = class {
      /**
       * Constructs a queue that is backed by the given array. Runtime is O(1).
      */
      constructor(items) {
        this.items = items;
        this.firstIdx = 0;
        this.lastIdx = this.items.length - 1;
      }
      get length() {
        return this.lastIdx - this.firstIdx + 1;
      }
      /**
       * Consumes elements from the beginning of the queue as long as the predicate returns true.
       * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
      */
      takeWhile(predicate) {
        let startIdx = this.firstIdx;
        while (startIdx < this.items.length && predicate(this.items[startIdx])) {
          startIdx++;
        }
        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);
        this.firstIdx = startIdx;
        return result;
      }
      /**
       * Consumes elements from the end of the queue as long as the predicate returns true.
       * If no elements were consumed, `null` is returned.
       * The result has the same order as the underlying array!
      */
      takeFromEndWhile(predicate) {
        let endIdx = this.lastIdx;
        while (endIdx >= 0 && predicate(this.items[endIdx])) {
          endIdx--;
        }
        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);
        this.lastIdx = endIdx;
        return result;
      }
      peek() {
        if (this.length === 0) {
          return void 0;
        }
        return this.items[this.firstIdx];
      }
      peekLast() {
        if (this.length === 0) {
          return void 0;
        }
        return this.items[this.lastIdx];
      }
      dequeue() {
        const result = this.items[this.firstIdx];
        this.firstIdx++;
        return result;
      }
      removeLast() {
        const result = this.items[this.lastIdx];
        this.lastIdx--;
        return result;
      }
      takeCount(count2) {
        const result = this.items.slice(this.firstIdx, this.firstIdx + count2);
        this.firstIdx += count2;
        return result;
      }
    };
    CallbackIterable = class _CallbackIterable {
      constructor(iterate) {
        this.iterate = iterate;
      }
      forEach(handler) {
        this.iterate((item) => {
          handler(item);
          return true;
        });
      }
      toArray() {
        const result = [];
        this.iterate((item) => {
          result.push(item);
          return true;
        });
        return result;
      }
      filter(predicate) {
        return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
      }
      map(mapFn) {
        return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
      }
      some(predicate) {
        let result = false;
        this.iterate((item) => {
          result = predicate(item);
          return !result;
        });
        return result;
      }
      findFirst(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
            return false;
          }
          return true;
        });
        return result;
      }
      findLast(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
          }
          return true;
        });
        return result;
      }
      findLastMaxBy(comparator) {
        let result;
        let first = true;
        this.iterate((item) => {
          if (first || CompareResult.isGreaterThan(comparator(item, result))) {
            first = false;
            result = item;
          }
          return true;
        });
        return result;
      }
    };
    CallbackIterable.empty = new CallbackIterable((_callback) => {
    });
  }
});

// node_modules/monaco-editor/esm/vs/base/common/ternarySearchTree.js
var StringIterator, ConfigKeysIterator, PathIterator, UriIterator, TernarySearchTreeNode, TernarySearchTree;
var init_ternarySearchTree = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/ternarySearchTree.js"() {
    init_arrays();
    init_strings();
    StringIterator = class {
      constructor() {
        this._value = "";
        this._pos = 0;
      }
      reset(key) {
        this._value = key;
        this._pos = 0;
        return this;
      }
      next() {
        this._pos += 1;
        return this;
      }
      hasNext() {
        return this._pos < this._value.length - 1;
      }
      cmp(a) {
        const aCode = a.charCodeAt(0);
        const thisCode = this._value.charCodeAt(this._pos);
        return aCode - thisCode;
      }
      value() {
        return this._value[this._pos];
      }
    };
    ConfigKeysIterator = class {
      constructor(_caseSensitive = true) {
        this._caseSensitive = _caseSensitive;
      }
      reset(key) {
        this._value = key;
        this._from = 0;
        this._to = 0;
        return this.next();
      }
      hasNext() {
        return this._to < this._value.length;
      }
      next() {
        this._from = this._to;
        let justSeps = true;
        for (; this._to < this._value.length; this._to++) {
          const ch = this._value.charCodeAt(this._to);
          if (ch === 46) {
            if (justSeps) {
              this._from++;
            } else {
              break;
            }
          } else {
            justSeps = false;
          }
        }
        return this;
      }
      cmp(a) {
        return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
      }
      value() {
        return this._value.substring(this._from, this._to);
      }
    };
    PathIterator = class {
      constructor(_splitOnBackslash = true, _caseSensitive = true) {
        this._splitOnBackslash = _splitOnBackslash;
        this._caseSensitive = _caseSensitive;
      }
      reset(key) {
        this._from = 0;
        this._to = 0;
        this._value = key;
        this._valueLen = key.length;
        for (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {
          const ch = this._value.charCodeAt(pos);
          if (!(ch === 47 || this._splitOnBackslash && ch === 92)) {
            break;
          }
        }
        return this.next();
      }
      hasNext() {
        return this._to < this._valueLen;
      }
      next() {
        this._from = this._to;
        let justSeps = true;
        for (; this._to < this._valueLen; this._to++) {
          const ch = this._value.charCodeAt(this._to);
          if (ch === 47 || this._splitOnBackslash && ch === 92) {
            if (justSeps) {
              this._from++;
            } else {
              break;
            }
          } else {
            justSeps = false;
          }
        }
        return this;
      }
      cmp(a) {
        return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
      }
      value() {
        return this._value.substring(this._from, this._to);
      }
    };
    UriIterator = class {
      constructor(_ignorePathCasing, _ignoreQueryAndFragment) {
        this._ignorePathCasing = _ignorePathCasing;
        this._ignoreQueryAndFragment = _ignoreQueryAndFragment;
        this._states = [];
        this._stateIdx = 0;
      }
      reset(key) {
        this._value = key;
        this._states = [];
        if (this._value.scheme) {
          this._states.push(
            1
            /* UriIteratorState.Scheme */
          );
        }
        if (this._value.authority) {
          this._states.push(
            2
            /* UriIteratorState.Authority */
          );
        }
        if (this._value.path) {
          this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));
          this._pathIterator.reset(key.path);
          if (this._pathIterator.value()) {
            this._states.push(
              3
              /* UriIteratorState.Path */
            );
          }
        }
        if (!this._ignoreQueryAndFragment(key)) {
          if (this._value.query) {
            this._states.push(
              4
              /* UriIteratorState.Query */
            );
          }
          if (this._value.fragment) {
            this._states.push(
              5
              /* UriIteratorState.Fragment */
            );
          }
        }
        this._stateIdx = 0;
        return this;
      }
      next() {
        if (this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()) {
          this._pathIterator.next();
        } else {
          this._stateIdx += 1;
        }
        return this;
      }
      hasNext() {
        return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
      }
      cmp(a) {
        if (this._states[this._stateIdx] === 1) {
          return compareIgnoreCase(a, this._value.scheme);
        } else if (this._states[this._stateIdx] === 2) {
          return compareIgnoreCase(a, this._value.authority);
        } else if (this._states[this._stateIdx] === 3) {
          return this._pathIterator.cmp(a);
        } else if (this._states[this._stateIdx] === 4) {
          return compare(a, this._value.query);
        } else if (this._states[this._stateIdx] === 5) {
          return compare(a, this._value.fragment);
        }
        throw new Error();
      }
      value() {
        if (this._states[this._stateIdx] === 1) {
          return this._value.scheme;
        } else if (this._states[this._stateIdx] === 2) {
          return this._value.authority;
        } else if (this._states[this._stateIdx] === 3) {
          return this._pathIterator.value();
        } else if (this._states[this._stateIdx] === 4) {
          return this._value.query;
        } else if (this._states[this._stateIdx] === 5) {
          return this._value.fragment;
        }
        throw new Error();
      }
    };
    TernarySearchTreeNode = class {
      constructor() {
        this.height = 1;
      }
      isEmpty() {
        return !this.left && !this.mid && !this.right && !this.value;
      }
      rotateLeft() {
        const tmp = this.right;
        this.right = tmp.left;
        tmp.left = this;
        this.updateHeight();
        tmp.updateHeight();
        return tmp;
      }
      rotateRight() {
        const tmp = this.left;
        this.left = tmp.right;
        tmp.right = this;
        this.updateHeight();
        tmp.updateHeight();
        return tmp;
      }
      updateHeight() {
        this.height = 1 + Math.max(this.heightLeft, this.heightRight);
      }
      balanceFactor() {
        return this.heightRight - this.heightLeft;
      }
      get heightLeft() {
        var _a4, _b2;
        return (_b2 = (_a4 = this.left) === null || _a4 === void 0 ? void 0 : _a4.height) !== null && _b2 !== void 0 ? _b2 : 0;
      }
      get heightRight() {
        var _a4, _b2;
        return (_b2 = (_a4 = this.right) === null || _a4 === void 0 ? void 0 : _a4.height) !== null && _b2 !== void 0 ? _b2 : 0;
      }
    };
    TernarySearchTree = class _TernarySearchTree {
      static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {
        return new _TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));
      }
      static forPaths(ignorePathCasing = false) {
        return new _TernarySearchTree(new PathIterator(void 0, !ignorePathCasing));
      }
      static forStrings() {
        return new _TernarySearchTree(new StringIterator());
      }
      static forConfigKeys() {
        return new _TernarySearchTree(new ConfigKeysIterator());
      }
      constructor(segments) {
        this._iter = segments;
      }
      clear() {
        this._root = void 0;
      }
      fill(values, keys) {
        if (keys) {
          const arr = keys.slice(0);
          shuffle(arr);
          for (const k of arr) {
            this.set(k, values);
          }
        } else {
          const arr = values.slice(0);
          shuffle(arr);
          for (const entry of arr) {
            this.set(entry[0], entry[1]);
          }
        }
      }
      set(key, element) {
        const iter = this._iter.reset(key);
        let node;
        if (!this._root) {
          this._root = new TernarySearchTreeNode();
          this._root.segment = iter.value();
        }
        const stack = [];
        node = this._root;
        while (true) {
          const val = iter.cmp(node.segment);
          if (val > 0) {
            if (!node.left) {
              node.left = new TernarySearchTreeNode();
              node.left.segment = iter.value();
            }
            stack.push([-1, node]);
            node = node.left;
          } else if (val < 0) {
            if (!node.right) {
              node.right = new TernarySearchTreeNode();
              node.right.segment = iter.value();
            }
            stack.push([1, node]);
            node = node.right;
          } else if (iter.hasNext()) {
            iter.next();
            if (!node.mid) {
              node.mid = new TernarySearchTreeNode();
              node.mid.segment = iter.value();
            }
            stack.push([0, node]);
            node = node.mid;
          } else {
            break;
          }
        }
        const oldElement = node.value;
        node.value = element;
        node.key = key;
        for (let i = stack.length - 1; i >= 0; i--) {
          const node2 = stack[i][1];
          node2.updateHeight();
          const bf = node2.balanceFactor();
          if (bf < -1 || bf > 1) {
            const d1 = stack[i][0];
            const d2 = stack[i + 1][0];
            if (d1 === 1 && d2 === 1) {
              stack[i][1] = node2.rotateLeft();
            } else if (d1 === -1 && d2 === -1) {
              stack[i][1] = node2.rotateRight();
            } else if (d1 === 1 && d2 === -1) {
              node2.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();
              stack[i][1] = node2.rotateLeft();
            } else if (d1 === -1 && d2 === 1) {
              node2.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();
              stack[i][1] = node2.rotateRight();
            } else {
              throw new Error();
            }
            if (i > 0) {
              switch (stack[i - 1][0]) {
                case -1:
                  stack[i - 1][1].left = stack[i][1];
                  break;
                case 1:
                  stack[i - 1][1].right = stack[i][1];
                  break;
                case 0:
                  stack[i - 1][1].mid = stack[i][1];
                  break;
              }
            } else {
              this._root = stack[0][1];
            }
          }
        }
        return oldElement;
      }
      get(key) {
        var _a4;
        return (_a4 = this._getNode(key)) === null || _a4 === void 0 ? void 0 : _a4.value;
      }
      _getNode(key) {
        const iter = this._iter.reset(key);
        let node = this._root;
        while (node) {
          const val = iter.cmp(node.segment);
          if (val > 0) {
            node = node.left;
          } else if (val < 0) {
            node = node.right;
          } else if (iter.hasNext()) {
            iter.next();
            node = node.mid;
          } else {
            break;
          }
        }
        return node;
      }
      has(key) {
        const node = this._getNode(key);
        return !((node === null || node === void 0 ? void 0 : node.value) === void 0 && (node === null || node === void 0 ? void 0 : node.mid) === void 0);
      }
      delete(key) {
        return this._delete(key, false);
      }
      deleteSuperstr(key) {
        return this._delete(key, true);
      }
      _delete(key, superStr) {
        var _a4;
        const iter = this._iter.reset(key);
        const stack = [];
        let node = this._root;
        while (node) {
          const val = iter.cmp(node.segment);
          if (val > 0) {
            stack.push([-1, node]);
            node = node.left;
          } else if (val < 0) {
            stack.push([1, node]);
            node = node.right;
          } else if (iter.hasNext()) {
            iter.next();
            stack.push([0, node]);
            node = node.mid;
          } else {
            break;
          }
        }
        if (!node) {
          return;
        }
        if (superStr) {
          node.left = void 0;
          node.mid = void 0;
          node.right = void 0;
          node.height = 1;
        } else {
          node.key = void 0;
          node.value = void 0;
        }
        if (!node.mid && !node.value) {
          if (node.left && node.right) {
            const min = this._min(node.right);
            if (min.key) {
              const { key: key2, value, segment } = min;
              this._delete(min.key, false);
              node.key = key2;
              node.value = value;
              node.segment = segment;
            }
          } else {
            const newChild = (_a4 = node.left) !== null && _a4 !== void 0 ? _a4 : node.right;
            if (stack.length > 0) {
              const [dir, parent] = stack[stack.length - 1];
              switch (dir) {
                case -1:
                  parent.left = newChild;
                  break;
                case 0:
                  parent.mid = newChild;
                  break;
                case 1:
                  parent.right = newChild;
                  break;
              }
            } else {
              this._root = newChild;
            }
          }
        }
        for (let i = stack.length - 1; i >= 0; i--) {
          const node2 = stack[i][1];
          node2.updateHeight();
          const bf = node2.balanceFactor();
          if (bf > 1) {
            if (node2.right.balanceFactor() >= 0) {
              stack[i][1] = node2.rotateLeft();
            } else {
              node2.right = node2.right.rotateRight();
              stack[i][1] = node2.rotateLeft();
            }
          } else if (bf < -1) {
            if (node2.left.balanceFactor() <= 0) {
              stack[i][1] = node2.rotateRight();
            } else {
              node2.left = node2.left.rotateLeft();
              stack[i][1] = node2.rotateRight();
            }
          }
          if (i > 0) {
            switch (stack[i - 1][0]) {
              case -1:
                stack[i - 1][1].left = stack[i][1];
                break;
              case 1:
                stack[i - 1][1].right = stack[i][1];
                break;
              case 0:
                stack[i - 1][1].mid = stack[i][1];
                break;
            }
          } else {
            this._root = stack[0][1];
          }
        }
      }
      _min(node) {
        while (node.left) {
          node = node.left;
        }
        return node;
      }
      findSubstr(key) {
        const iter = this._iter.reset(key);
        let node = this._root;
        let candidate = void 0;
        while (node) {
          const val = iter.cmp(node.segment);
          if (val > 0) {
            node = node.left;
          } else if (val < 0) {
            node = node.right;
          } else if (iter.hasNext()) {
            iter.next();
            candidate = node.value || candidate;
            node = node.mid;
          } else {
            break;
          }
        }
        return node && node.value || candidate;
      }
      findSuperstr(key) {
        return this._findSuperstrOrElement(key, false);
      }
      _findSuperstrOrElement(key, allowValue) {
        const iter = this._iter.reset(key);
        let node = this._root;
        while (node) {
          const val = iter.cmp(node.segment);
          if (val > 0) {
            node = node.left;
          } else if (val < 0) {
            node = node.right;
          } else if (iter.hasNext()) {
            iter.next();
            node = node.mid;
          } else {
            if (!node.mid) {
              if (allowValue) {
                return node.value;
              } else {
                return void 0;
              }
            } else {
              return this._entries(node.mid);
            }
          }
        }
        return void 0;
      }
      hasElementOrSubtree(key) {
        return this._findSuperstrOrElement(key, true) !== void 0;
      }
      forEach(callback) {
        for (const [key, value] of this) {
          callback(value, key);
        }
      }
      *[Symbol.iterator]() {
        yield* this._entries(this._root);
      }
      _entries(node) {
        const result = [];
        this._dfsEntries(node, result);
        return result[Symbol.iterator]();
      }
      _dfsEntries(node, bucket) {
        if (!node) {
          return;
        }
        if (node.left) {
          this._dfsEntries(node.left, bucket);
        }
        if (node.value) {
          bucket.push([node.key, node.value]);
        }
        if (node.mid) {
          this._dfsEntries(node.mid, bucket);
        }
        if (node.right) {
          this._dfsEntries(node.right, bucket);
        }
      }
      // for debug/testing
      _isBalanced() {
        const nodeIsBalanced = (node) => {
          if (!node) {
            return true;
          }
          const bf = node.balanceFactor();
          if (bf < -1 || bf > 1) {
            return false;
          }
          return nodeIsBalanced(node.left) && nodeIsBalanced(node.right);
        };
        return nodeIsBalanced(this._root);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/platform/files/common/files.js
function hasReadWriteCapability(provider) {
  return !!(provider.capabilities & 2);
}
function hasFileFolderCopyCapability(provider) {
  return !!(provider.capabilities & 8);
}
function hasFileCloneCapability(provider) {
  return !!(provider.capabilities & 131072);
}
function hasOpenReadWriteCloseCapability(provider) {
  return !!(provider.capabilities & 4);
}
function hasFileReadStreamCapability(provider) {
  return !!(provider.capabilities & 16);
}
function hasFileAtomicReadCapability(provider) {
  if (!hasReadWriteCapability(provider)) {
    return false;
  }
  return !!(provider.capabilities & 16384);
}
function hasReadonlyCapability(provider) {
  return !!(provider.capabilities & 2048);
}
function createFileSystemProviderError(error, code) {
  return FileSystemProviderError.create(error, code);
}
function ensureFileSystemProviderError(error) {
  if (!error) {
    return createFileSystemProviderError(localize("unknownError", "Unknown Error"), FileSystemProviderErrorCode.Unknown);
  }
  return error;
}
function markAsFileSystemProviderError(error, code) {
  error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;
  return error;
}
function toFileSystemProviderErrorCode(error) {
  if (!error) {
    return FileSystemProviderErrorCode.Unknown;
  }
  if (error instanceof FileSystemProviderError) {
    return error.code;
  }
  const match = /^(.+) \(FileSystemError\)$/.exec(error.name);
  if (!match) {
    return FileSystemProviderErrorCode.Unknown;
  }
  switch (match[1]) {
    case FileSystemProviderErrorCode.FileExists:
      return FileSystemProviderErrorCode.FileExists;
    case FileSystemProviderErrorCode.FileIsADirectory:
      return FileSystemProviderErrorCode.FileIsADirectory;
    case FileSystemProviderErrorCode.FileNotADirectory:
      return FileSystemProviderErrorCode.FileNotADirectory;
    case FileSystemProviderErrorCode.FileNotFound:
      return FileSystemProviderErrorCode.FileNotFound;
    case FileSystemProviderErrorCode.FileTooLarge:
      return FileSystemProviderErrorCode.FileTooLarge;
    case FileSystemProviderErrorCode.FileWriteLocked:
      return FileSystemProviderErrorCode.FileWriteLocked;
    case FileSystemProviderErrorCode.NoPermissions:
      return FileSystemProviderErrorCode.NoPermissions;
    case FileSystemProviderErrorCode.Unavailable:
      return FileSystemProviderErrorCode.Unavailable;
  }
  return FileSystemProviderErrorCode.Unknown;
}
function toFileOperationResult(error) {
  if (error instanceof FileOperationError) {
    return error.fileOperationResult;
  }
  switch (toFileSystemProviderErrorCode(error)) {
    case FileSystemProviderErrorCode.FileNotFound:
      return 1;
    case FileSystemProviderErrorCode.FileIsADirectory:
      return 0;
    case FileSystemProviderErrorCode.FileNotADirectory:
      return 9;
    case FileSystemProviderErrorCode.FileWriteLocked:
      return 5;
    case FileSystemProviderErrorCode.NoPermissions:
      return 6;
    case FileSystemProviderErrorCode.FileExists:
      return 4;
    case FileSystemProviderErrorCode.FileTooLarge:
      return 7;
    default:
      return 10;
  }
}
function etag(stat) {
  if (typeof stat.size !== "number" || typeof stat.mtime !== "number") {
    return void 0;
  }
  return stat.mtime.toString(29) + stat.size.toString(31);
}
function whenProviderRegistered(file, fileService) {
  return __awaiter3(this, void 0, void 0, function* () {
    if (fileService.hasProvider(URI.from({ scheme: file.scheme }))) {
      return;
    }
    return new Promise((resolve2) => {
      const disposable = fileService.onDidChangeFileSystemProviderRegistrations((e) => {
        if (e.scheme === file.scheme && e.added) {
          disposable.dispose();
          resolve2();
        }
      });
    });
  });
}
var __awaiter3, IFileService, FileType, FilePermission, FileSystemProviderErrorCode, FileSystemProviderError, FileOperationEvent, FileChangesEvent, FileOperationError, TooLargeFileOperationError, NotModifiedSinceFileOperationError, AutoSaveConfiguration, HotExitConfiguration, FILES_ASSOCIATIONS_CONFIG, FILES_EXCLUDE_CONFIG, FILES_READONLY_INCLUDE_CONFIG, FILES_READONLY_EXCLUDE_CONFIG, FILES_READONLY_FROM_PERMISSIONS_CONFIG, FileKind, ETAG_DISABLED, ByteSize;
var init_files = __esm({
  "node_modules/monaco-editor/esm/vs/platform/files/common/files.js"() {
    init_ternarySearchTree();
    init_path();
    init_strings();
    init_types();
    init_uri();
    init_nls();
    init_instantiation();
    init_platform();
    init_network();
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    IFileService = createDecorator("fileService");
    (function(FileType2) {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
    })(FileType || (FileType = {}));
    (function(FilePermission2) {
      FilePermission2[FilePermission2["Readonly"] = 1] = "Readonly";
      FilePermission2[FilePermission2["Locked"] = 2] = "Locked";
    })(FilePermission || (FilePermission = {}));
    (function(FileSystemProviderErrorCode2) {
      FileSystemProviderErrorCode2["FileExists"] = "EntryExists";
      FileSystemProviderErrorCode2["FileNotFound"] = "EntryNotFound";
      FileSystemProviderErrorCode2["FileNotADirectory"] = "EntryNotADirectory";
      FileSystemProviderErrorCode2["FileIsADirectory"] = "EntryIsADirectory";
      FileSystemProviderErrorCode2["FileExceedsStorageQuota"] = "EntryExceedsStorageQuota";
      FileSystemProviderErrorCode2["FileTooLarge"] = "EntryTooLarge";
      FileSystemProviderErrorCode2["FileWriteLocked"] = "EntryWriteLocked";
      FileSystemProviderErrorCode2["NoPermissions"] = "NoPermissions";
      FileSystemProviderErrorCode2["Unavailable"] = "Unavailable";
      FileSystemProviderErrorCode2["Unknown"] = "Unknown";
    })(FileSystemProviderErrorCode || (FileSystemProviderErrorCode = {}));
    FileSystemProviderError = class _FileSystemProviderError extends Error {
      static create(error, code) {
        const providerError = new _FileSystemProviderError(error.toString(), code);
        markAsFileSystemProviderError(providerError, code);
        return providerError;
      }
      constructor(message, code) {
        super(message);
        this.code = code;
      }
    };
    FileOperationEvent = class {
      constructor(resource, operation, target) {
        this.resource = resource;
        this.operation = operation;
        this.target = target;
      }
      isOperation(operation) {
        return this.operation === operation;
      }
    };
    FileChangesEvent = class {
      constructor(changes, ignorePathCasing) {
        this.added = void 0;
        this.updated = void 0;
        this.deleted = void 0;
        this.rawAdded = [];
        this.rawUpdated = [];
        this.rawDeleted = [];
        const entriesByType = /* @__PURE__ */ new Map();
        for (const change of changes) {
          const array = entriesByType.get(change.type);
          if (array) {
            array.push([change.resource, change]);
          } else {
            entriesByType.set(change.type, [[change.resource, change]]);
          }
          switch (change.type) {
            case 1:
              this.rawAdded.push(change.resource);
              break;
            case 0:
              this.rawUpdated.push(change.resource);
              break;
            case 2:
              this.rawDeleted.push(change.resource);
              break;
          }
        }
        for (const [key, value] of entriesByType) {
          switch (key) {
            case 1:
              this.added = TernarySearchTree.forUris(() => ignorePathCasing);
              this.added.fill(value);
              break;
            case 0:
              this.updated = TernarySearchTree.forUris(() => ignorePathCasing);
              this.updated.fill(value);
              break;
            case 2:
              this.deleted = TernarySearchTree.forUris(() => ignorePathCasing);
              this.deleted.fill(value);
              break;
          }
        }
      }
      /**
       * Find out if the file change events match the provided resource.
       *
       * Note: when passing `FileChangeType.DELETED`, we consider a match
       * also when the parent of the resource got deleted.
       */
      contains(resource, ...types) {
        return this.doContains(resource, { includeChildren: false }, ...types);
      }
      /**
       * Find out if the file change events either match the provided
       * resource, or contain a child of this resource.
       */
      affects(resource, ...types) {
        return this.doContains(resource, { includeChildren: true }, ...types);
      }
      doContains(resource, options, ...types) {
        var _a4, _b2, _c2, _d, _e, _f;
        if (!resource) {
          return false;
        }
        const hasTypesFilter = types.length > 0;
        if (!hasTypesFilter || types.includes(
          1
          /* FileChangeType.ADDED */
        )) {
          if ((_a4 = this.added) === null || _a4 === void 0 ? void 0 : _a4.get(resource)) {
            return true;
          }
          if (options.includeChildren && ((_b2 = this.added) === null || _b2 === void 0 ? void 0 : _b2.findSuperstr(resource))) {
            return true;
          }
        }
        if (!hasTypesFilter || types.includes(
          0
          /* FileChangeType.UPDATED */
        )) {
          if ((_c2 = this.updated) === null || _c2 === void 0 ? void 0 : _c2.get(resource)) {
            return true;
          }
          if (options.includeChildren && ((_d = this.updated) === null || _d === void 0 ? void 0 : _d.findSuperstr(resource))) {
            return true;
          }
        }
        if (!hasTypesFilter || types.includes(
          2
          /* FileChangeType.DELETED */
        )) {
          if ((_e = this.deleted) === null || _e === void 0 ? void 0 : _e.findSubstr(resource)) {
            return true;
          }
          if (options.includeChildren && ((_f = this.deleted) === null || _f === void 0 ? void 0 : _f.findSuperstr(resource))) {
            return true;
          }
        }
        return false;
      }
      /**
       * Returns if this event contains added files.
       */
      gotAdded() {
        return !!this.added;
      }
      /**
       * Returns if this event contains deleted files.
       */
      gotDeleted() {
        return !!this.deleted;
      }
      /**
       * Returns if this event contains updated files.
       */
      gotUpdated() {
        return !!this.updated;
      }
    };
    FileOperationError = class extends Error {
      constructor(message, fileOperationResult, options) {
        super(message);
        this.fileOperationResult = fileOperationResult;
        this.options = options;
      }
    };
    TooLargeFileOperationError = class extends FileOperationError {
      constructor(message, fileOperationResult, size, options) {
        super(message, fileOperationResult, options);
        this.fileOperationResult = fileOperationResult;
        this.size = size;
      }
    };
    NotModifiedSinceFileOperationError = class extends FileOperationError {
      constructor(message, stat, options) {
        super(message, 2, options);
        this.stat = stat;
      }
    };
    AutoSaveConfiguration = {
      OFF: "off",
      AFTER_DELAY: "afterDelay",
      ON_FOCUS_CHANGE: "onFocusChange",
      ON_WINDOW_CHANGE: "onWindowChange"
    };
    HotExitConfiguration = {
      OFF: "off",
      ON_EXIT: "onExit",
      ON_EXIT_AND_WINDOW_CLOSE: "onExitAndWindowClose"
    };
    FILES_ASSOCIATIONS_CONFIG = "files.associations";
    FILES_EXCLUDE_CONFIG = "files.exclude";
    FILES_READONLY_INCLUDE_CONFIG = "files.readonlyInclude";
    FILES_READONLY_EXCLUDE_CONFIG = "files.readonlyExclude";
    FILES_READONLY_FROM_PERMISSIONS_CONFIG = "files.readonlyFromPermissions";
    (function(FileKind2) {
      FileKind2[FileKind2["FILE"] = 0] = "FILE";
      FileKind2[FileKind2["FOLDER"] = 1] = "FOLDER";
      FileKind2[FileKind2["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
    })(FileKind || (FileKind = {}));
    ETAG_DISABLED = "";
    ByteSize = class _ByteSize {
      static formatSize(size) {
        if (!isNumber(size)) {
          size = 0;
        }
        if (size < _ByteSize.KB) {
          return localize("sizeB", "{0}B", size.toFixed(0));
        }
        if (size < _ByteSize.MB) {
          return localize("sizeKB", "{0}KB", (size / _ByteSize.KB).toFixed(2));
        }
        if (size < _ByteSize.GB) {
          return localize("sizeMB", "{0}MB", (size / _ByteSize.MB).toFixed(2));
        }
        if (size < _ByteSize.TB) {
          return localize("sizeGB", "{0}GB", (size / _ByteSize.GB).toFixed(2));
        }
        return localize("sizeTB", "{0}TB", (size / _ByteSize.TB).toFixed(2));
      }
    };
    ByteSize.KB = 1024;
    ByteSize.MB = ByteSize.KB * ByteSize.KB;
    ByteSize.GB = ByteSize.MB * ByteSize.KB;
    ByteSize.TB = ByteSize.GB * ByteSize.KB;
  }
});

// node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js
function hintDidYouMean(...meant) {
  switch (meant.length) {
    case 1:
      return localize("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", meant[0]);
    case 2:
      return localize("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", meant[0], meant[1]);
    case 3:
      return localize("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", meant[0], meant[1], meant[2]);
    default:
      return void 0;
  }
}
var hintDidYouForgetToOpenOrCloseQuote, hintDidYouForgetToEscapeSlash, Scanner;
var init_scanner = __esm({
  "node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js"() {
    init_errors();
    init_nls();
    hintDidYouForgetToOpenOrCloseQuote = localize("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?");
    hintDidYouForgetToEscapeSlash = localize("contextkey.scanner.hint.didYouForgetToEscapeSlash", "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'.");
    Scanner = class _Scanner {
      constructor() {
        this._input = "";
        this._start = 0;
        this._current = 0;
        this._tokens = [];
        this._errors = [];
        this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
      }
      static getLexeme(token) {
        switch (token.type) {
          case 0:
            return "(";
          case 1:
            return ")";
          case 2:
            return "!";
          case 3:
            return token.isTripleEq ? "===" : "==";
          case 4:
            return token.isTripleEq ? "!==" : "!=";
          case 5:
            return "<";
          case 6:
            return "<=";
          case 7:
            return ">=";
          case 8:
            return ">=";
          case 9:
            return "=~";
          case 10:
            return token.lexeme;
          case 11:
            return "true";
          case 12:
            return "false";
          case 13:
            return "in";
          case 14:
            return "not";
          case 15:
            return "&&";
          case 16:
            return "||";
          case 17:
            return token.lexeme;
          case 18:
            return token.lexeme;
          case 19:
            return token.lexeme;
          case 20:
            return "EOF";
          default:
            throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);
        }
      }
      get errors() {
        return this._errors;
      }
      reset(value) {
        this._input = value;
        this._start = 0;
        this._current = 0;
        this._tokens = [];
        this._errors = [];
        return this;
      }
      scan() {
        while (!this._isAtEnd()) {
          this._start = this._current;
          const ch = this._advance();
          switch (ch) {
            case 40:
              this._addToken(
                0
                /* TokenType.LParen */
              );
              break;
            case 41:
              this._addToken(
                1
                /* TokenType.RParen */
              );
              break;
            case 33:
              if (this._match(
                61
                /* CharCode.Equals */
              )) {
                const isTripleEq = this._match(
                  61
                  /* CharCode.Equals */
                );
                this._tokens.push({ type: 4, offset: this._start, isTripleEq });
              } else {
                this._addToken(
                  2
                  /* TokenType.Neg */
                );
              }
              break;
            case 39:
              this._quotedString();
              break;
            case 47:
              this._regex();
              break;
            case 61:
              if (this._match(
                61
                /* CharCode.Equals */
              )) {
                const isTripleEq = this._match(
                  61
                  /* CharCode.Equals */
                );
                this._tokens.push({ type: 3, offset: this._start, isTripleEq });
              } else if (this._match(
                126
                /* CharCode.Tilde */
              )) {
                this._addToken(
                  9
                  /* TokenType.RegexOp */
                );
              } else {
                this._error(hintDidYouMean("==", "=~"));
              }
              break;
            case 60:
              this._addToken(
                this._match(
                  61
                  /* CharCode.Equals */
                ) ? 6 : 5
                /* TokenType.Lt */
              );
              break;
            case 62:
              this._addToken(
                this._match(
                  61
                  /* CharCode.Equals */
                ) ? 8 : 7
                /* TokenType.Gt */
              );
              break;
            case 38:
              if (this._match(
                38
                /* CharCode.Ampersand */
              )) {
                this._addToken(
                  15
                  /* TokenType.And */
                );
              } else {
                this._error(hintDidYouMean("&&"));
              }
              break;
            case 124:
              if (this._match(
                124
                /* CharCode.Pipe */
              )) {
                this._addToken(
                  16
                  /* TokenType.Or */
                );
              } else {
                this._error(hintDidYouMean("||"));
              }
              break;
            case 32:
            case 13:
            case 9:
            case 10:
            case 160:
              break;
            default:
              this._string();
          }
        }
        this._start = this._current;
        this._addToken(
          20
          /* TokenType.EOF */
        );
        return Array.from(this._tokens);
      }
      _match(expected) {
        if (this._isAtEnd()) {
          return false;
        }
        if (this._input.charCodeAt(this._current) !== expected) {
          return false;
        }
        this._current++;
        return true;
      }
      _advance() {
        return this._input.charCodeAt(this._current++);
      }
      _peek() {
        return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current);
      }
      _addToken(type) {
        this._tokens.push({ type, offset: this._start });
      }
      _error(additional) {
        const offset = this._start;
        const lexeme = this._input.substring(this._start, this._current);
        const errToken = { type: 19, offset: this._start, lexeme };
        this._errors.push({ offset, lexeme, additionalInfo: additional });
        this._tokens.push(errToken);
      }
      _string() {
        this.stringRe.lastIndex = this._start;
        const match = this.stringRe.exec(this._input);
        if (match) {
          this._current = this._start + match[0].length;
          const lexeme = this._input.substring(this._start, this._current);
          const keyword = _Scanner._keywords.get(lexeme);
          if (keyword) {
            this._addToken(keyword);
          } else {
            this._tokens.push({ type: 17, lexeme, offset: this._start });
          }
        }
      }
      // captures the lexeme without the leading and trailing '
      _quotedString() {
        while (this._peek() !== 39 && !this._isAtEnd()) {
          this._advance();
        }
        if (this._isAtEnd()) {
          this._error(hintDidYouForgetToOpenOrCloseQuote);
          return;
        }
        this._advance();
        this._tokens.push({ type: 18, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
      }
      /*
       * Lexing a regex expression: /.../[igsmyu]*
       * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
       *
       * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
       */
      _regex() {
        let p = this._current;
        let inEscape = false;
        let inCharacterClass = false;
        while (true) {
          if (p >= this._input.length) {
            this._current = p;
            this._error(hintDidYouForgetToEscapeSlash);
            return;
          }
          const ch = this._input.charCodeAt(p);
          if (inEscape) {
            inEscape = false;
          } else if (ch === 47 && !inCharacterClass) {
            p++;
            break;
          } else if (ch === 91) {
            inCharacterClass = true;
          } else if (ch === 92) {
            inEscape = true;
          } else if (ch === 93) {
            inCharacterClass = false;
          }
          p++;
        }
        while (p < this._input.length && _Scanner._regexFlags.has(this._input.charCodeAt(p))) {
          p++;
        }
        this._current = p;
        const lexeme = this._input.substring(this._start, this._current);
        this._tokens.push({ type: 10, lexeme, offset: this._start });
      }
      _isAtEnd() {
        return this._current >= this._input.length;
      }
    };
    Scanner._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((ch) => ch.charCodeAt(0)));
    Scanner._keywords = /* @__PURE__ */ new Map([
      [
        "not",
        14
        /* TokenType.Not */
      ],
      [
        "in",
        13
        /* TokenType.In */
      ],
      [
        "false",
        12
        /* TokenType.False */
      ],
      [
        "true",
        11
        /* TokenType.True */
      ]
    ]);
  }
});

// node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js
function setConstant(key, value) {
  if (CONSTANT_VALUES.get(key) !== void 0) {
    throw illegalArgument("contextkey.setConstant(k, v) invoked with already set constant `k`");
  }
  CONSTANT_VALUES.set(key, value);
}
function validateWhenClauses(whenClauses) {
  const parser = new Parser({ regexParsingWithErrorRecovery: false });
  return whenClauses.map((whenClause) => {
    parser.parse(whenClause);
    if (parser.lexingErrors.length > 0) {
      return parser.lexingErrors.map((se) => ({
        errorMessage: se.additionalInfo ? localize("contextkey.scanner.errorForLinterWithHint", "Unexpected token. Hint: {0}", se.additionalInfo) : localize("contextkey.scanner.errorForLinter", "Unexpected token."),
        offset: se.offset,
        length: se.lexeme.length
      }));
    } else if (parser.parsingErrors.length > 0) {
      return parser.parsingErrors.map((pe) => ({
        errorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,
        offset: pe.offset,
        length: pe.lexeme.length
      }));
    } else {
      return [];
    }
  });
}
function expressionsAreEqualWithConstantSubstitution(a, b) {
  const aExpr = a ? a.substituteConstants() : void 0;
  const bExpr = b ? b.substituteConstants() : void 0;
  if (!aExpr && !bExpr) {
    return true;
  }
  if (!aExpr || !bExpr) {
    return false;
  }
  return aExpr.equals(bExpr);
}
function cmp(a, b) {
  return a.cmp(b);
}
function withFloatOrStr(value, callback) {
  if (typeof value === "string") {
    const n = parseFloat(value);
    if (!isNaN(n)) {
      value = n;
    }
  }
  if (typeof value === "string" || typeof value === "number") {
    return callback(value);
  }
  return ContextKeyFalseExpr.INSTANCE;
}
function eliminateConstantsInArray(arr) {
  let newArr = null;
  for (let i = 0, len = arr.length; i < len; i++) {
    const newExpr = arr[i].substituteConstants();
    if (arr[i] !== newExpr) {
      if (newArr === null) {
        newArr = [];
        for (let j = 0; j < i; j++) {
          newArr[j] = arr[j];
        }
      }
    }
    if (newArr !== null) {
      newArr[i] = newExpr;
    }
  }
  if (newArr === null) {
    return arr;
  }
  return newArr;
}
function cmp1(key1, key2) {
  if (key1 < key2) {
    return -1;
  }
  if (key1 > key2) {
    return 1;
  }
  return 0;
}
function cmp2(key1, value1, key2, value2) {
  if (key1 < key2) {
    return -1;
  }
  if (key1 > key2) {
    return 1;
  }
  if (value1 < value2) {
    return -1;
  }
  if (value1 > value2) {
    return 1;
  }
  return 0;
}
function implies(p, q) {
  if (p.type === 0 || q.type === 1) {
    return true;
  }
  if (p.type === 9) {
    if (q.type === 9) {
      return allElementsIncluded(p.expr, q.expr);
    }
    return false;
  }
  if (q.type === 9) {
    for (const element of q.expr) {
      if (implies(p, element)) {
        return true;
      }
    }
    return false;
  }
  if (p.type === 6) {
    if (q.type === 6) {
      return allElementsIncluded(q.expr, p.expr);
    }
    for (const element of p.expr) {
      if (implies(element, q)) {
        return true;
      }
    }
    return false;
  }
  return p.equals(q);
}
function allElementsIncluded(p, q) {
  let pIndex = 0;
  let qIndex = 0;
  while (pIndex < p.length && qIndex < q.length) {
    const cmp3 = p[pIndex].cmp(q[qIndex]);
    if (cmp3 < 0) {
      return false;
    } else if (cmp3 === 0) {
      pIndex++;
      qIndex++;
    } else {
      qIndex++;
    }
  }
  return pIndex === p.length;
}
function getTerminals(node) {
  if (node.type === 9) {
    return node.expr;
  }
  return [node];
}
var CONSTANT_VALUES, hasOwnProperty2, defaultConfig, errorEmptyString, hintEmptyString, errorNoInAfterNot, errorClosingParenthesis, errorUnexpectedToken, hintUnexpectedToken, errorUnexpectedEOF, hintUnexpectedEOF, Parser, ContextKeyExpr, ContextKeyFalseExpr, ContextKeyTrueExpr, ContextKeyDefinedExpr, ContextKeyEqualsExpr, ContextKeyInExpr, ContextKeyNotInExpr, ContextKeyNotEqualsExpr, ContextKeyNotExpr, ContextKeyGreaterExpr, ContextKeyGreaterEqualsExpr, ContextKeySmallerExpr, ContextKeySmallerEqualsExpr, ContextKeyRegexExpr, ContextKeyNotRegexExpr, ContextKeyAndExpr, ContextKeyOrExpr, RawContextKey, IContextKeyService;
var init_contextkey = __esm({
  "node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js"() {
    init_platform();
    init_strings();
    init_scanner();
    init_instantiation();
    init_nls();
    init_errors();
    CONSTANT_VALUES = /* @__PURE__ */ new Map();
    CONSTANT_VALUES.set("false", false);
    CONSTANT_VALUES.set("true", true);
    CONSTANT_VALUES.set("isMac", isMacintosh);
    CONSTANT_VALUES.set("isLinux", isLinux);
    CONSTANT_VALUES.set("isWindows", isWindows);
    CONSTANT_VALUES.set("isWeb", isWeb);
    CONSTANT_VALUES.set("isMacNative", isMacintosh && !isWeb);
    CONSTANT_VALUES.set("isEdge", isEdge);
    CONSTANT_VALUES.set("isFirefox", isFirefox);
    CONSTANT_VALUES.set("isChrome", isChrome);
    CONSTANT_VALUES.set("isSafari", isSafari);
    hasOwnProperty2 = Object.prototype.hasOwnProperty;
    defaultConfig = {
      regexParsingWithErrorRecovery: true
    };
    errorEmptyString = localize("contextkey.parser.error.emptyString", "Empty context key expression");
    hintEmptyString = localize("contextkey.parser.error.emptyString.hint", "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.");
    errorNoInAfterNot = localize("contextkey.parser.error.noInAfterNot", "'in' after 'not'.");
    errorClosingParenthesis = localize("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'");
    errorUnexpectedToken = localize("contextkey.parser.error.unexpectedToken", "Unexpected token");
    hintUnexpectedToken = localize("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?");
    errorUnexpectedEOF = localize("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression");
    hintUnexpectedEOF = localize("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?");
    Parser = class _Parser {
      get lexingErrors() {
        return this._scanner.errors;
      }
      get parsingErrors() {
        return this._parsingErrors;
      }
      constructor(_config = defaultConfig) {
        this._config = _config;
        this._scanner = new Scanner();
        this._tokens = [];
        this._current = 0;
        this._parsingErrors = [];
        this._flagsGYRe = /g|y/g;
      }
      /**
       * Parse a context key expression.
       *
       * @param input the expression to parse
       * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
       */
      parse(input) {
        if (input === "") {
          this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: "", additionalInfo: hintEmptyString });
          return void 0;
        }
        this._tokens = this._scanner.reset(input).scan();
        this._current = 0;
        this._parsingErrors = [];
        try {
          const expr = this._expr();
          if (!this._isAtEnd()) {
            const peek = this._peek();
            const additionalInfo = peek.type === 17 ? hintUnexpectedToken : void 0;
            this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });
            throw _Parser._parseError;
          }
          return expr;
        } catch (e) {
          if (!(e === _Parser._parseError)) {
            throw e;
          }
          return void 0;
        }
      }
      _expr() {
        return this._or();
      }
      _or() {
        const expr = [this._and()];
        while (this._matchOne(
          16
          /* TokenType.Or */
        )) {
          const right = this._and();
          expr.push(right);
        }
        return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);
      }
      _and() {
        const expr = [this._term()];
        while (this._matchOne(
          15
          /* TokenType.And */
        )) {
          const right = this._term();
          expr.push(right);
        }
        return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);
      }
      _term() {
        if (this._matchOne(
          2
          /* TokenType.Neg */
        )) {
          const peek = this._peek();
          switch (peek.type) {
            case 11:
              this._advance();
              return ContextKeyFalseExpr.INSTANCE;
            case 12:
              this._advance();
              return ContextKeyTrueExpr.INSTANCE;
            case 0: {
              this._advance();
              const expr = this._expr();
              this._consume(1, errorClosingParenthesis);
              return expr === null || expr === void 0 ? void 0 : expr.negate();
            }
            case 17:
              this._advance();
              return ContextKeyNotExpr.create(peek.lexeme);
            default:
              throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);
          }
        }
        return this._primary();
      }
      _primary() {
        const peek = this._peek();
        switch (peek.type) {
          case 11:
            this._advance();
            return ContextKeyExpr.true();
          case 12:
            this._advance();
            return ContextKeyExpr.false();
          case 0: {
            this._advance();
            const expr = this._expr();
            this._consume(1, errorClosingParenthesis);
            return expr;
          }
          case 17: {
            const key = peek.lexeme;
            this._advance();
            if (this._matchOne(
              9
              /* TokenType.RegexOp */
            )) {
              const expr = this._peek();
              if (!this._config.regexParsingWithErrorRecovery) {
                this._advance();
                if (expr.type !== 10) {
                  throw this._errExpectedButGot(`REGEX`, expr);
                }
                const regexLexeme = expr.lexeme;
                const closingSlashIndex = regexLexeme.lastIndexOf("/");
                const flags = closingSlashIndex === regexLexeme.length - 1 ? void 0 : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
                let regexp;
                try {
                  regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                } catch (e) {
                  throw this._errExpectedButGot(`REGEX`, expr);
                }
                return ContextKeyRegexExpr.create(key, regexp);
              }
              switch (expr.type) {
                case 10:
                case 19: {
                  const lexemeReconstruction = [expr.lexeme];
                  this._advance();
                  let followingToken = this._peek();
                  let parenBalance = 0;
                  for (let i = 0; i < expr.lexeme.length; i++) {
                    if (expr.lexeme.charCodeAt(i) === 40) {
                      parenBalance++;
                    } else if (expr.lexeme.charCodeAt(i) === 41) {
                      parenBalance--;
                    }
                  }
                  while (!this._isAtEnd() && followingToken.type !== 15 && followingToken.type !== 16) {
                    switch (followingToken.type) {
                      case 0:
                        parenBalance++;
                        break;
                      case 1:
                        parenBalance--;
                        break;
                      case 10:
                      case 18:
                        for (let i = 0; i < followingToken.lexeme.length; i++) {
                          if (followingToken.lexeme.charCodeAt(i) === 40) {
                            parenBalance++;
                          } else if (expr.lexeme.charCodeAt(i) === 41) {
                            parenBalance--;
                          }
                        }
                    }
                    if (parenBalance < 0) {
                      break;
                    }
                    lexemeReconstruction.push(Scanner.getLexeme(followingToken));
                    this._advance();
                    followingToken = this._peek();
                  }
                  const regexLexeme = lexemeReconstruction.join("");
                  const closingSlashIndex = regexLexeme.lastIndexOf("/");
                  const flags = closingSlashIndex === regexLexeme.length - 1 ? void 0 : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
                  let regexp;
                  try {
                    regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                  } catch (e) {
                    throw this._errExpectedButGot(`REGEX`, expr);
                  }
                  return ContextKeyExpr.regex(key, regexp);
                }
                case 18: {
                  const serializedValue = expr.lexeme;
                  this._advance();
                  let regex = null;
                  if (!isFalsyOrWhitespace(serializedValue)) {
                    const start = serializedValue.indexOf("/");
                    const end = serializedValue.lastIndexOf("/");
                    if (start !== end && start >= 0) {
                      const value = serializedValue.slice(start + 1, end);
                      const caseIgnoreFlag = serializedValue[end + 1] === "i" ? "i" : "";
                      try {
                        regex = new RegExp(value, caseIgnoreFlag);
                      } catch (_e) {
                        throw this._errExpectedButGot(`REGEX`, expr);
                      }
                    }
                  }
                  if (regex === null) {
                    throw this._errExpectedButGot("REGEX", expr);
                  }
                  return ContextKeyRegexExpr.create(key, regex);
                }
                default:
                  throw this._errExpectedButGot("REGEX", this._peek());
              }
            }
            if (this._matchOne(
              14
              /* TokenType.Not */
            )) {
              this._consume(13, errorNoInAfterNot);
              const right = this._value();
              return ContextKeyExpr.notIn(key, right);
            }
            const maybeOp = this._peek().type;
            switch (maybeOp) {
              case 3: {
                this._advance();
                const right = this._value();
                if (this._previous().type === 18) {
                  return ContextKeyExpr.equals(key, right);
                }
                switch (right) {
                  case "true":
                    return ContextKeyExpr.has(key);
                  case "false":
                    return ContextKeyExpr.not(key);
                  default:
                    return ContextKeyExpr.equals(key, right);
                }
              }
              case 4: {
                this._advance();
                const right = this._value();
                if (this._previous().type === 18) {
                  return ContextKeyExpr.notEquals(key, right);
                }
                switch (right) {
                  case "true":
                    return ContextKeyExpr.not(key);
                  case "false":
                    return ContextKeyExpr.has(key);
                  default:
                    return ContextKeyExpr.notEquals(key, right);
                }
              }
              case 5:
                this._advance();
                return ContextKeySmallerExpr.create(key, this._value());
              case 6:
                this._advance();
                return ContextKeySmallerEqualsExpr.create(key, this._value());
              case 7:
                this._advance();
                return ContextKeyGreaterExpr.create(key, this._value());
              case 8:
                this._advance();
                return ContextKeyGreaterEqualsExpr.create(key, this._value());
              case 13:
                this._advance();
                return ContextKeyExpr.in(key, this._value());
              default:
                return ContextKeyExpr.has(key);
            }
          }
          case 20:
            this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: "", additionalInfo: hintUnexpectedEOF });
            throw _Parser._parseError;
          default:
            throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
        }
      }
      _value() {
        const token = this._peek();
        switch (token.type) {
          case 17:
          case 18:
            this._advance();
            return token.lexeme;
          case 11:
            this._advance();
            return "true";
          case 12:
            this._advance();
            return "false";
          case 13:
            this._advance();
            return "in";
          default:
            return "";
        }
      }
      _removeFlagsGY(flags) {
        return flags.replaceAll(this._flagsGYRe, "");
      }
      // careful: this can throw if current token is the initial one (ie index = 0)
      _previous() {
        return this._tokens[this._current - 1];
      }
      _matchOne(token) {
        if (this._check(token)) {
          this._advance();
          return true;
        }
        return false;
      }
      _advance() {
        if (!this._isAtEnd()) {
          this._current++;
        }
        return this._previous();
      }
      _consume(type, message) {
        if (this._check(type)) {
          return this._advance();
        }
        throw this._errExpectedButGot(message, this._peek());
      }
      _errExpectedButGot(expected, got, additionalInfo) {
        const message = localize("contextkey.parser.error.expectedButGot", "Expected: {0}\nReceived: '{1}'.", expected, Scanner.getLexeme(got));
        const offset = got.offset;
        const lexeme = Scanner.getLexeme(got);
        this._parsingErrors.push({ message, offset, lexeme, additionalInfo });
        return _Parser._parseError;
      }
      _check(type) {
        return this._peek().type === type;
      }
      _peek() {
        return this._tokens[this._current];
      }
      _isAtEnd() {
        return this._peek().type === 20;
      }
    };
    Parser._parseError = new Error();
    ContextKeyExpr = class {
      static false() {
        return ContextKeyFalseExpr.INSTANCE;
      }
      static true() {
        return ContextKeyTrueExpr.INSTANCE;
      }
      static has(key) {
        return ContextKeyDefinedExpr.create(key);
      }
      static equals(key, value) {
        return ContextKeyEqualsExpr.create(key, value);
      }
      static notEquals(key, value) {
        return ContextKeyNotEqualsExpr.create(key, value);
      }
      static regex(key, value) {
        return ContextKeyRegexExpr.create(key, value);
      }
      static in(key, value) {
        return ContextKeyInExpr.create(key, value);
      }
      static notIn(key, value) {
        return ContextKeyNotInExpr.create(key, value);
      }
      static not(key) {
        return ContextKeyNotExpr.create(key);
      }
      static and(...expr) {
        return ContextKeyAndExpr.create(expr, null, true);
      }
      static or(...expr) {
        return ContextKeyOrExpr.create(expr, null, true);
      }
      static greater(key, value) {
        return ContextKeyGreaterExpr.create(key, value);
      }
      static greaterEquals(key, value) {
        return ContextKeyGreaterEqualsExpr.create(key, value);
      }
      static smaller(key, value) {
        return ContextKeySmallerExpr.create(key, value);
      }
      static smallerEquals(key, value) {
        return ContextKeySmallerEqualsExpr.create(key, value);
      }
      static deserialize(serialized) {
        if (serialized === void 0 || serialized === null) {
          return void 0;
        }
        const expr = this._parser.parse(serialized);
        return expr;
      }
    };
    ContextKeyExpr._parser = new Parser({ regexParsingWithErrorRecovery: false });
    ContextKeyFalseExpr = class {
      constructor() {
        this.type = 0;
      }
      cmp(other) {
        return this.type - other.type;
      }
      equals(other) {
        return other.type === this.type;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        return false;
      }
      serialize() {
        return "false";
      }
      keys() {
        return [];
      }
      map(mapFnc) {
        return this;
      }
      negate() {
        return ContextKeyTrueExpr.INSTANCE;
      }
    };
    ContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();
    ContextKeyTrueExpr = class {
      constructor() {
        this.type = 1;
      }
      cmp(other) {
        return this.type - other.type;
      }
      equals(other) {
        return other.type === this.type;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        return true;
      }
      serialize() {
        return "true";
      }
      keys() {
        return [];
      }
      map(mapFnc) {
        return this;
      }
      negate() {
        return ContextKeyFalseExpr.INSTANCE;
      }
    };
    ContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();
    ContextKeyDefinedExpr = class _ContextKeyDefinedExpr {
      static create(key, negated = null) {
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === "boolean") {
          return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return new _ContextKeyDefinedExpr(key, negated);
      }
      constructor(key, negated) {
        this.key = key;
        this.negated = negated;
        this.type = 2;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp1(this.key, other.key);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key;
        }
        return false;
      }
      substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === "boolean") {
          return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return this;
      }
      evaluate(context) {
        return !!context.getValue(this.key);
      }
      serialize() {
        return this.key;
      }
      keys() {
        return [this.key];
      }
      map(mapFnc) {
        return mapFnc.mapDefined(this.key);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyNotExpr.create(this.key, this);
        }
        return this.negated;
      }
    };
    ContextKeyEqualsExpr = class _ContextKeyEqualsExpr {
      static create(key, value, negated = null) {
        if (typeof value === "boolean") {
          return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);
        }
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === "boolean") {
          const trueValue = constantValue ? "true" : "false";
          return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return new _ContextKeyEqualsExpr(key, value, negated);
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 4;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === "boolean") {
          const trueValue = constantValue ? "true" : "false";
          return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return this;
      }
      evaluate(context) {
        return context.getValue(this.key) == this.value;
      }
      serialize() {
        return `${this.key} == '${this.value}'`;
      }
      keys() {
        return [this.key];
      }
      map(mapFnc) {
        return mapFnc.mapEquals(this.key, this.value);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeyInExpr = class _ContextKeyInExpr {
      static create(key, valueKey) {
        return new _ContextKeyInExpr(key, valueKey);
      }
      constructor(key, valueKey) {
        this.key = key;
        this.valueKey = valueKey;
        this.type = 10;
        this.negated = null;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.valueKey, other.key, other.valueKey);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.valueKey === other.valueKey;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        const source = context.getValue(this.valueKey);
        const item = context.getValue(this.key);
        if (Array.isArray(source)) {
          return source.includes(item);
        }
        if (typeof item === "string" && typeof source === "object" && source !== null) {
          return hasOwnProperty2.call(source, item);
        }
        return false;
      }
      serialize() {
        return `${this.key} in '${this.valueKey}'`;
      }
      keys() {
        return [this.key, this.valueKey];
      }
      map(mapFnc) {
        return mapFnc.mapIn(this.key, this.valueKey);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);
        }
        return this.negated;
      }
    };
    ContextKeyNotInExpr = class _ContextKeyNotInExpr {
      static create(key, valueKey) {
        return new _ContextKeyNotInExpr(key, valueKey);
      }
      constructor(key, valueKey) {
        this.key = key;
        this.valueKey = valueKey;
        this.type = 11;
        this._negated = ContextKeyInExpr.create(key, valueKey);
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return this._negated.cmp(other._negated);
      }
      equals(other) {
        if (other.type === this.type) {
          return this._negated.equals(other._negated);
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        return !this._negated.evaluate(context);
      }
      serialize() {
        return `${this.key} not in '${this.valueKey}'`;
      }
      keys() {
        return this._negated.keys();
      }
      map(mapFnc) {
        return mapFnc.mapNotIn(this.key, this.valueKey);
      }
      negate() {
        return this._negated;
      }
    };
    ContextKeyNotEqualsExpr = class _ContextKeyNotEqualsExpr {
      static create(key, value, negated = null) {
        if (typeof value === "boolean") {
          if (value) {
            return ContextKeyNotExpr.create(key, negated);
          }
          return ContextKeyDefinedExpr.create(key, negated);
        }
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === "boolean") {
          const falseValue = constantValue ? "true" : "false";
          return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
        }
        return new _ContextKeyNotEqualsExpr(key, value, negated);
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 5;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === "boolean") {
          const falseValue = constantValue ? "true" : "false";
          return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
        }
        return this;
      }
      evaluate(context) {
        return context.getValue(this.key) != this.value;
      }
      serialize() {
        return `${this.key} != '${this.value}'`;
      }
      keys() {
        return [this.key];
      }
      map(mapFnc) {
        return mapFnc.mapNotEquals(this.key, this.value);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeyNotExpr = class _ContextKeyNotExpr {
      static create(key, negated = null) {
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === "boolean") {
          return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
        }
        return new _ContextKeyNotExpr(key, negated);
      }
      constructor(key, negated) {
        this.key = key;
        this.negated = negated;
        this.type = 3;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp1(this.key, other.key);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key;
        }
        return false;
      }
      substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === "boolean") {
          return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
        }
        return this;
      }
      evaluate(context) {
        return !context.getValue(this.key);
      }
      serialize() {
        return `!${this.key}`;
      }
      keys() {
        return [this.key];
      }
      map(mapFnc) {
        return mapFnc.mapNot(this.key);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyDefinedExpr.create(this.key, this);
        }
        return this.negated;
      }
    };
    ContextKeyGreaterExpr = class _ContextKeyGreaterExpr {
      static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new _ContextKeyGreaterExpr(key, value, negated));
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 12;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        if (typeof this.value === "string") {
          return false;
        }
        return parseFloat(context.getValue(this.key)) > this.value;
      }
      serialize() {
        return `${this.key} > ${this.value}`;
      }
      keys() {
        return [this.key];
      }
      map(mapFnc) {
        return mapFnc.mapGreater(this.key, this.value);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeyGreaterEqualsExpr = class _ContextKeyGreaterEqualsExpr {
      static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new _ContextKeyGreaterEqualsExpr(key, value, negated));
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 13;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        if (typeof this.value === "string") {
          return false;
        }
        return parseFloat(context.getValue(this.key)) >= this.value;
      }
      serialize() {
        return `${this.key} >= ${this.value}`;
      }
      keys() {
        return [this.key];
      }
      map(mapFnc) {
        return mapFnc.mapGreaterEquals(this.key, this.value);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeySmallerExpr = class _ContextKeySmallerExpr {
      static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new _ContextKeySmallerExpr(key, value, negated));
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 14;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        if (typeof this.value === "string") {
          return false;
        }
        return parseFloat(context.getValue(this.key)) < this.value;
      }
      serialize() {
        return `${this.key} < ${this.value}`;
      }
      keys() {
        return [this.key];
      }
      map(mapFnc) {
        return mapFnc.mapSmaller(this.key, this.value);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeySmallerEqualsExpr = class _ContextKeySmallerEqualsExpr {
      static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new _ContextKeySmallerEqualsExpr(key, value, negated));
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 15;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        if (typeof this.value === "string") {
          return false;
        }
        return parseFloat(context.getValue(this.key)) <= this.value;
      }
      serialize() {
        return `${this.key} <= ${this.value}`;
      }
      keys() {
        return [this.key];
      }
      map(mapFnc) {
        return mapFnc.mapSmallerEquals(this.key, this.value);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeyRegexExpr = class _ContextKeyRegexExpr {
      static create(key, regexp) {
        return new _ContextKeyRegexExpr(key, regexp);
      }
      constructor(key, regexp) {
        this.key = key;
        this.regexp = regexp;
        this.type = 7;
        this.negated = null;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        if (this.key < other.key) {
          return -1;
        }
        if (this.key > other.key) {
          return 1;
        }
        const thisSource = this.regexp ? this.regexp.source : "";
        const otherSource = other.regexp ? other.regexp.source : "";
        if (thisSource < otherSource) {
          return -1;
        }
        if (thisSource > otherSource) {
          return 1;
        }
        return 0;
      }
      equals(other) {
        if (other.type === this.type) {
          const thisSource = this.regexp ? this.regexp.source : "";
          const otherSource = other.regexp ? other.regexp.source : "";
          return this.key === other.key && thisSource === otherSource;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        const value = context.getValue(this.key);
        return this.regexp ? this.regexp.test(value) : false;
      }
      serialize() {
        const value = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
        return `${this.key} =~ ${value}`;
      }
      keys() {
        return [this.key];
      }
      map(mapFnc) {
        return mapFnc.mapRegex(this.key, this.regexp);
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyNotRegexExpr.create(this);
        }
        return this.negated;
      }
    };
    ContextKeyNotRegexExpr = class _ContextKeyNotRegexExpr {
      static create(actual) {
        return new _ContextKeyNotRegexExpr(actual);
      }
      constructor(_actual) {
        this._actual = _actual;
        this.type = 8;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return this._actual.cmp(other._actual);
      }
      equals(other) {
        if (other.type === this.type) {
          return this._actual.equals(other._actual);
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        return !this._actual.evaluate(context);
      }
      serialize() {
        return `!(${this._actual.serialize()})`;
      }
      keys() {
        return this._actual.keys();
      }
      map(mapFnc) {
        return new _ContextKeyNotRegexExpr(this._actual.map(mapFnc));
      }
      negate() {
        return this._actual;
      }
    };
    ContextKeyAndExpr = class _ContextKeyAndExpr {
      static create(_expr, negated, extraRedundantCheck) {
        return _ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);
      }
      constructor(expr, negated) {
        this.expr = expr;
        this.negated = negated;
        this.type = 6;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        if (this.expr.length < other.expr.length) {
          return -1;
        }
        if (this.expr.length > other.expr.length) {
          return 1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
          const r = cmp(this.expr[i], other.expr[i]);
          if (r !== 0) {
            return r;
          }
        }
        return 0;
      }
      equals(other) {
        if (other.type === this.type) {
          if (this.expr.length !== other.expr.length) {
            return false;
          }
          for (let i = 0, len = this.expr.length; i < len; i++) {
            if (!this.expr[i].equals(other.expr[i])) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      substituteConstants() {
        const exprArr = eliminateConstantsInArray(this.expr);
        if (exprArr === this.expr) {
          return this;
        }
        return _ContextKeyAndExpr.create(exprArr, this.negated, false);
      }
      evaluate(context) {
        for (let i = 0, len = this.expr.length; i < len; i++) {
          if (!this.expr[i].evaluate(context)) {
            return false;
          }
        }
        return true;
      }
      static _normalizeArr(arr, negated, extraRedundantCheck) {
        const expr = [];
        let hasTrue = false;
        for (const e of arr) {
          if (!e) {
            continue;
          }
          if (e.type === 1) {
            hasTrue = true;
            continue;
          }
          if (e.type === 0) {
            return ContextKeyFalseExpr.INSTANCE;
          }
          if (e.type === 6) {
            expr.push(...e.expr);
            continue;
          }
          expr.push(e);
        }
        if (expr.length === 0 && hasTrue) {
          return ContextKeyTrueExpr.INSTANCE;
        }
        if (expr.length === 0) {
          return void 0;
        }
        if (expr.length === 1) {
          return expr[0];
        }
        expr.sort(cmp);
        for (let i = 1; i < expr.length; i++) {
          if (expr[i - 1].equals(expr[i])) {
            expr.splice(i, 1);
            i--;
          }
        }
        if (expr.length === 1) {
          return expr[0];
        }
        while (expr.length > 1) {
          const lastElement = expr[expr.length - 1];
          if (lastElement.type !== 9) {
            break;
          }
          expr.pop();
          const secondToLastElement = expr.pop();
          const isFinished = expr.length === 0;
          const resultElement = ContextKeyOrExpr.create(lastElement.expr.map((el) => _ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);
          if (resultElement) {
            expr.push(resultElement);
            expr.sort(cmp);
          }
        }
        if (expr.length === 1) {
          return expr[0];
        }
        if (extraRedundantCheck) {
          for (let i = 0; i < expr.length; i++) {
            for (let j = i + 1; j < expr.length; j++) {
              if (expr[i].negate().equals(expr[j])) {
                return ContextKeyFalseExpr.INSTANCE;
              }
            }
          }
          if (expr.length === 1) {
            return expr[0];
          }
        }
        return new _ContextKeyAndExpr(expr, negated);
      }
      serialize() {
        return this.expr.map((e) => e.serialize()).join(" && ");
      }
      keys() {
        const result = [];
        for (const expr of this.expr) {
          result.push(...expr.keys());
        }
        return result;
      }
      map(mapFnc) {
        return new _ContextKeyAndExpr(this.expr.map((expr) => expr.map(mapFnc)), null);
      }
      negate() {
        if (!this.negated) {
          const result = [];
          for (const expr of this.expr) {
            result.push(expr.negate());
          }
          this.negated = ContextKeyOrExpr.create(result, this, true);
        }
        return this.negated;
      }
    };
    ContextKeyOrExpr = class _ContextKeyOrExpr {
      static create(_expr, negated, extraRedundantCheck) {
        return _ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);
      }
      constructor(expr, negated) {
        this.expr = expr;
        this.negated = negated;
        this.type = 9;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        if (this.expr.length < other.expr.length) {
          return -1;
        }
        if (this.expr.length > other.expr.length) {
          return 1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
          const r = cmp(this.expr[i], other.expr[i]);
          if (r !== 0) {
            return r;
          }
        }
        return 0;
      }
      equals(other) {
        if (other.type === this.type) {
          if (this.expr.length !== other.expr.length) {
            return false;
          }
          for (let i = 0, len = this.expr.length; i < len; i++) {
            if (!this.expr[i].equals(other.expr[i])) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      substituteConstants() {
        const exprArr = eliminateConstantsInArray(this.expr);
        if (exprArr === this.expr) {
          return this;
        }
        return _ContextKeyOrExpr.create(exprArr, this.negated, false);
      }
      evaluate(context) {
        for (let i = 0, len = this.expr.length; i < len; i++) {
          if (this.expr[i].evaluate(context)) {
            return true;
          }
        }
        return false;
      }
      static _normalizeArr(arr, negated, extraRedundantCheck) {
        let expr = [];
        let hasFalse = false;
        if (arr) {
          for (let i = 0, len = arr.length; i < len; i++) {
            const e = arr[i];
            if (!e) {
              continue;
            }
            if (e.type === 0) {
              hasFalse = true;
              continue;
            }
            if (e.type === 1) {
              return ContextKeyTrueExpr.INSTANCE;
            }
            if (e.type === 9) {
              expr = expr.concat(e.expr);
              continue;
            }
            expr.push(e);
          }
          if (expr.length === 0 && hasFalse) {
            return ContextKeyFalseExpr.INSTANCE;
          }
          expr.sort(cmp);
        }
        if (expr.length === 0) {
          return void 0;
        }
        if (expr.length === 1) {
          return expr[0];
        }
        for (let i = 1; i < expr.length; i++) {
          if (expr[i - 1].equals(expr[i])) {
            expr.splice(i, 1);
            i--;
          }
        }
        if (expr.length === 1) {
          return expr[0];
        }
        if (extraRedundantCheck) {
          for (let i = 0; i < expr.length; i++) {
            for (let j = i + 1; j < expr.length; j++) {
              if (expr[i].negate().equals(expr[j])) {
                return ContextKeyTrueExpr.INSTANCE;
              }
            }
          }
          if (expr.length === 1) {
            return expr[0];
          }
        }
        return new _ContextKeyOrExpr(expr, negated);
      }
      serialize() {
        return this.expr.map((e) => e.serialize()).join(" || ");
      }
      keys() {
        const result = [];
        for (const expr of this.expr) {
          result.push(...expr.keys());
        }
        return result;
      }
      map(mapFnc) {
        return new _ContextKeyOrExpr(this.expr.map((expr) => expr.map(mapFnc)), null);
      }
      negate() {
        if (!this.negated) {
          const result = [];
          for (const expr of this.expr) {
            result.push(expr.negate());
          }
          while (result.length > 1) {
            const LEFT = result.shift();
            const RIGHT = result.shift();
            const all = [];
            for (const left of getTerminals(LEFT)) {
              for (const right of getTerminals(RIGHT)) {
                all.push(ContextKeyAndExpr.create([left, right], null, false));
              }
            }
            result.unshift(_ContextKeyOrExpr.create(all, null, false));
          }
          this.negated = _ContextKeyOrExpr.create(result, this, true);
        }
        return this.negated;
      }
    };
    RawContextKey = class _RawContextKey extends ContextKeyDefinedExpr {
      static all() {
        return _RawContextKey._info.values();
      }
      constructor(key, defaultValue, metaOrHide) {
        super(key, null);
        this._defaultValue = defaultValue;
        if (typeof metaOrHide === "object") {
          _RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), { key }));
        } else if (metaOrHide !== true) {
          _RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== void 0 ? typeof defaultValue : void 0 });
        }
      }
      bindTo(target) {
        return target.createKey(this.key, this._defaultValue);
      }
      getValue(target) {
        return target.getContextKeyValue(this.key);
      }
      toNegated() {
        return this.negate();
      }
      isEqualTo(value) {
        return ContextKeyEqualsExpr.create(this.key, value);
      }
      notEqualsTo(value) {
        return ContextKeyNotEqualsExpr.create(this.key, value);
      }
    };
    RawContextKey._info = [];
    IContextKeyService = createDecorator("contextKeyService");
  }
});

// node_modules/monaco-editor/esm/vs/base/common/errorMessage.js
function exceptionToErrorMessage(exception, verbose) {
  if (verbose && (exception.stack || exception.stacktrace)) {
    return localize("stackTrace.format", "{0}: {1}", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
  }
  return detectSystemErrorMessage(exception);
}
function stackToString(stack) {
  if (Array.isArray(stack)) {
    return stack.join("\n");
  }
  return stack;
}
function detectSystemErrorMessage(exception) {
  if (exception.code === "ERR_UNC_HOST_NOT_ALLOWED") {
    return `${exception.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;
  }
  if (typeof exception.code === "string" && typeof exception.errno === "number" && typeof exception.syscall === "string") {
    return localize("nodeExceptionMessage", "A system error occurred ({0})", exception.message);
  }
  return exception.message || localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
function toErrorMessage(error = null, verbose = false) {
  if (!error) {
    return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
  }
  if (Array.isArray(error)) {
    const errors = coalesce(error);
    const msg = toErrorMessage(errors[0], verbose);
    if (errors.length > 1) {
      return localize("error.moreErrors", "{0} ({1} errors in total)", msg, errors.length);
    }
    return msg;
  }
  if (isString(error)) {
    return error;
  }
  if (error.detail) {
    const detail = error.detail;
    if (detail.error) {
      return exceptionToErrorMessage(detail.error, verbose);
    }
    if (detail.exception) {
      return exceptionToErrorMessage(detail.exception, verbose);
    }
  }
  if (error.stack) {
    return exceptionToErrorMessage(error, verbose);
  }
  if (error.message) {
    return error.message;
  }
  return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
function createErrorWithActions(messageOrError, actions) {
  let error;
  if (typeof messageOrError === "string") {
    error = new Error(messageOrError);
  } else {
    error = messageOrError;
  }
  error.actions = actions;
  return error;
}
var init_errorMessage = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/errorMessage.js"() {
    init_arrays();
    init_types();
    init_nls();
  }
});

// node_modules/monaco-editor/esm/vs/base/common/hash.js
function hash(obj) {
  return doHash(obj, 0);
}
function doHash(obj, hashVal) {
  switch (typeof obj) {
    case "object":
      if (obj === null) {
        return numberHash(349, hashVal);
      } else if (Array.isArray(obj)) {
        return arrayHash(obj, hashVal);
      }
      return objectHash(obj, hashVal);
    case "string":
      return stringHash(obj, hashVal);
    case "boolean":
      return booleanHash(obj, hashVal);
    case "number":
      return numberHash(obj, hashVal);
    case "undefined":
      return numberHash(937, hashVal);
    default:
      return numberHash(617, hashVal);
  }
}
function numberHash(val, initialHashVal) {
  return (initialHashVal << 5) - initialHashVal + val | 0;
}
function booleanHash(b, initialHashVal) {
  return numberHash(b ? 433 : 863, initialHashVal);
}
function stringHash(s, hashVal) {
  hashVal = numberHash(149417, hashVal);
  for (let i = 0, length = s.length; i < length; i++) {
    hashVal = numberHash(s.charCodeAt(i), hashVal);
  }
  return hashVal;
}
function arrayHash(arr, initialHashVal) {
  initialHashVal = numberHash(104579, initialHashVal);
  return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
}
function objectHash(obj, initialHashVal) {
  initialHashVal = numberHash(181387, initialHashVal);
  return Object.keys(obj).sort().reduce((hashVal, key) => {
    hashVal = stringHash(key, hashVal);
    return doHash(obj[key], hashVal);
  }, initialHashVal);
}
function leftRotate(value, bits, totalBits = 32) {
  const delta2 = totalBits - bits;
  const mask = ~((1 << delta2) - 1);
  return (value << bits | (mask & value) >>> delta2) >>> 0;
}
function fill(dest, index2 = 0, count2 = dest.byteLength, value = 0) {
  for (let i = 0; i < count2; i++) {
    dest[index2 + i] = value;
  }
}
function leftPad(value, length, char = "0") {
  while (value.length < length) {
    value = char + value;
  }
  return value;
}
function toHexString(bufferOrValue, bitsize = 32) {
  if (bufferOrValue instanceof ArrayBuffer) {
    return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
}
var StringSHA1;
var init_hash = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/hash.js"() {
    init_strings();
    StringSHA1 = class _StringSHA1 {
      constructor() {
        this._h0 = 1732584193;
        this._h1 = 4023233417;
        this._h2 = 2562383102;
        this._h3 = 271733878;
        this._h4 = 3285377520;
        this._buff = new Uint8Array(
          64 + 3
          /* to fit any utf-8 */
        );
        this._buffDV = new DataView(this._buff.buffer);
        this._buffLen = 0;
        this._totalLen = 0;
        this._leftoverHighSurrogate = 0;
        this._finished = false;
      }
      update(str) {
        const strLen = str.length;
        if (strLen === 0) {
          return;
        }
        const buff = this._buff;
        let buffLen = this._buffLen;
        let leftoverHighSurrogate = this._leftoverHighSurrogate;
        let charCode;
        let offset;
        if (leftoverHighSurrogate !== 0) {
          charCode = leftoverHighSurrogate;
          offset = -1;
          leftoverHighSurrogate = 0;
        } else {
          charCode = str.charCodeAt(0);
          offset = 0;
        }
        while (true) {
          let codePoint = charCode;
          if (isHighSurrogate(charCode)) {
            if (offset + 1 < strLen) {
              const nextCharCode = str.charCodeAt(offset + 1);
              if (isLowSurrogate(nextCharCode)) {
                offset++;
                codePoint = computeCodePoint(charCode, nextCharCode);
              } else {
                codePoint = 65533;
              }
            } else {
              leftoverHighSurrogate = charCode;
              break;
            }
          } else if (isLowSurrogate(charCode)) {
            codePoint = 65533;
          }
          buffLen = this._push(buff, buffLen, codePoint);
          offset++;
          if (offset < strLen) {
            charCode = str.charCodeAt(offset);
          } else {
            break;
          }
        }
        this._buffLen = buffLen;
        this._leftoverHighSurrogate = leftoverHighSurrogate;
      }
      _push(buff, buffLen, codePoint) {
        if (codePoint < 128) {
          buff[buffLen++] = codePoint;
        } else if (codePoint < 2048) {
          buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
          buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
        } else if (codePoint < 65536) {
          buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
          buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
          buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
        } else {
          buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
          buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
          buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
          buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
        }
        if (buffLen >= 64) {
          this._step();
          buffLen -= 64;
          this._totalLen += 64;
          buff[0] = buff[64 + 0];
          buff[1] = buff[64 + 1];
          buff[2] = buff[64 + 2];
        }
        return buffLen;
      }
      digest() {
        if (!this._finished) {
          this._finished = true;
          if (this._leftoverHighSurrogate) {
            this._leftoverHighSurrogate = 0;
            this._buffLen = this._push(
              this._buff,
              this._buffLen,
              65533
              /* SHA1Constant.UNICODE_REPLACEMENT */
            );
          }
          this._totalLen += this._buffLen;
          this._wrapUp();
        }
        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
      }
      _wrapUp() {
        this._buff[this._buffLen++] = 128;
        fill(this._buff, this._buffLen);
        if (this._buffLen > 56) {
          this._step();
          fill(this._buff);
        }
        const ml = 8 * this._totalLen;
        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
        this._buffDV.setUint32(60, ml % 4294967296, false);
        this._step();
      }
      _step() {
        const bigBlock32 = _StringSHA1._bigBlock32;
        const data = this._buffDV;
        for (let j = 0; j < 64; j += 4) {
          bigBlock32.setUint32(j, data.getUint32(j, false), false);
        }
        for (let j = 64; j < 320; j += 4) {
          bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
        }
        let a = this._h0;
        let b = this._h1;
        let c = this._h2;
        let d = this._h3;
        let e = this._h4;
        let f, k;
        let temp;
        for (let j = 0; j < 80; j++) {
          if (j < 20) {
            f = b & c | ~b & d;
            k = 1518500249;
          } else if (j < 40) {
            f = b ^ c ^ d;
            k = 1859775393;
          } else if (j < 60) {
            f = b & c | b & d | c & d;
            k = 2400959708;
          } else {
            f = b ^ c ^ d;
            k = 3395469782;
          }
          temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
          e = d;
          d = c;
          c = leftRotate(b, 30);
          b = a;
          a = temp;
        }
        this._h0 = this._h0 + a & 4294967295;
        this._h1 = this._h1 + b & 4294967295;
        this._h2 = this._h2 + c & 4294967295;
        this._h3 = this._h3 + d & 4294967295;
        this._h4 = this._h4 + e & 4294967295;
      }
    };
    StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));
  }
});

// node_modules/monaco-editor/esm/vs/platform/log/common/log.js
function isLogLevel(thing) {
  return isNumber(thing);
}
function log(logger, level, message) {
  switch (level) {
    case LogLevel.Trace:
      logger.trace(message);
      break;
    case LogLevel.Debug:
      logger.debug(message);
      break;
    case LogLevel.Info:
      logger.info(message);
      break;
    case LogLevel.Warning:
      logger.warn(message);
      break;
    case LogLevel.Error:
      logger.error(message);
      break;
    case LogLevel.Off:
      break;
    default:
      throw new Error(`Invalid log level ${level}`);
  }
}
function format3(args, verbose = false) {
  let result = "";
  for (let i = 0; i < args.length; i++) {
    let a = args[i];
    if (a instanceof Error) {
      a = toErrorMessage(a, verbose);
    }
    if (typeof a === "object") {
      try {
        a = JSON.stringify(a);
      } catch (e) {
      }
    }
    result += (i > 0 ? " " : "") + a;
  }
  return result;
}
function LogLevelToString(logLevel) {
  switch (logLevel) {
    case LogLevel.Trace:
      return "trace";
    case LogLevel.Debug:
      return "debug";
    case LogLevel.Info:
      return "info";
    case LogLevel.Warning:
      return "warn";
    case LogLevel.Error:
      return "error";
    case LogLevel.Off:
      return "off";
  }
}
function parseLogLevel(logLevel) {
  switch (logLevel) {
    case "trace":
      return LogLevel.Trace;
    case "debug":
      return LogLevel.Debug;
    case "info":
      return LogLevel.Info;
    case "warn":
      return LogLevel.Warning;
    case "error":
      return LogLevel.Error;
    case "critical":
      return LogLevel.Error;
    case "off":
      return LogLevel.Off;
  }
  return void 0;
}
var ILogService, ILoggerService, LogLevel, DEFAULT_LOG_LEVEL, AbstractLogger, AbstractMessageLogger, ConsoleLogger, MultiplexLogger, AbstractLoggerService, NullLogger, CONTEXT_LOG_LEVEL;
var init_log = __esm({
  "node_modules/monaco-editor/esm/vs/platform/log/common/log.js"() {
    init_errorMessage();
    init_event();
    init_hash();
    init_lifecycle();
    init_map();
    init_platform();
    init_resources();
    init_types();
    init_uri();
    init_contextkey();
    init_instantiation();
    ILogService = createDecorator("logService");
    ILoggerService = createDecorator("loggerService");
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Off"] = 0] = "Off";
      LogLevel2[LogLevel2["Trace"] = 1] = "Trace";
      LogLevel2[LogLevel2["Debug"] = 2] = "Debug";
      LogLevel2[LogLevel2["Info"] = 3] = "Info";
      LogLevel2[LogLevel2["Warning"] = 4] = "Warning";
      LogLevel2[LogLevel2["Error"] = 5] = "Error";
    })(LogLevel || (LogLevel = {}));
    DEFAULT_LOG_LEVEL = LogLevel.Info;
    AbstractLogger = class extends Disposable {
      constructor() {
        super(...arguments);
        this.level = DEFAULT_LOG_LEVEL;
        this._onDidChangeLogLevel = this._register(new Emitter());
        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
      }
      setLevel(level) {
        if (this.level !== level) {
          this.level = level;
          this._onDidChangeLogLevel.fire(this.level);
        }
      }
      getLevel() {
        return this.level;
      }
      checkLogLevel(level) {
        return this.level !== LogLevel.Off && this.level <= level;
      }
    };
    AbstractMessageLogger = class extends AbstractLogger {
      constructor(logAlways) {
        super();
        this.logAlways = logAlways;
      }
      checkLogLevel(level) {
        return this.logAlways || super.checkLogLevel(level);
      }
      trace(message, ...args) {
        if (this.checkLogLevel(LogLevel.Trace)) {
          this.log(LogLevel.Trace, format3([message, ...args], true));
        }
      }
      debug(message, ...args) {
        if (this.checkLogLevel(LogLevel.Debug)) {
          this.log(LogLevel.Debug, format3([message, ...args]));
        }
      }
      info(message, ...args) {
        if (this.checkLogLevel(LogLevel.Info)) {
          this.log(LogLevel.Info, format3([message, ...args]));
        }
      }
      warn(message, ...args) {
        if (this.checkLogLevel(LogLevel.Warning)) {
          this.log(LogLevel.Warning, format3([message, ...args]));
        }
      }
      error(message, ...args) {
        if (this.checkLogLevel(LogLevel.Error)) {
          if (message instanceof Error) {
            const array = Array.prototype.slice.call(arguments);
            array[0] = message.stack;
            this.log(LogLevel.Error, format3(array));
          } else {
            this.log(LogLevel.Error, format3([message, ...args]));
          }
        }
      }
      flush() {
      }
    };
    ConsoleLogger = class extends AbstractLogger {
      constructor(logLevel = DEFAULT_LOG_LEVEL, useColors = true) {
        super();
        this.useColors = useColors;
        this.setLevel(logLevel);
      }
      trace(message, ...args) {
        if (this.checkLogLevel(LogLevel.Trace)) {
          if (this.useColors) {
            console.log("%cTRACE", "color: #888", message, ...args);
          } else {
            console.log(message, ...args);
          }
        }
      }
      debug(message, ...args) {
        if (this.checkLogLevel(LogLevel.Debug)) {
          if (this.useColors) {
            console.log("%cDEBUG", "background: #eee; color: #888", message, ...args);
          } else {
            console.log(message, ...args);
          }
        }
      }
      info(message, ...args) {
        if (this.checkLogLevel(LogLevel.Info)) {
          if (this.useColors) {
            console.log("%c INFO", "color: #33f", message, ...args);
          } else {
            console.log(message, ...args);
          }
        }
      }
      warn(message, ...args) {
        if (this.checkLogLevel(LogLevel.Warning)) {
          if (this.useColors) {
            console.log("%c WARN", "color: #993", message, ...args);
          } else {
            console.log(message, ...args);
          }
        }
      }
      error(message, ...args) {
        if (this.checkLogLevel(LogLevel.Error)) {
          if (this.useColors) {
            console.log("%c  ERR", "color: #f33", message, ...args);
          } else {
            console.error(message, ...args);
          }
        }
      }
      dispose() {
      }
      flush() {
      }
    };
    MultiplexLogger = class extends AbstractLogger {
      constructor(loggers) {
        super();
        this.loggers = loggers;
        if (loggers.length) {
          this.setLevel(loggers[0].getLevel());
        }
      }
      setLevel(level) {
        for (const logger of this.loggers) {
          logger.setLevel(level);
        }
        super.setLevel(level);
      }
      trace(message, ...args) {
        for (const logger of this.loggers) {
          logger.trace(message, ...args);
        }
      }
      debug(message, ...args) {
        for (const logger of this.loggers) {
          logger.debug(message, ...args);
        }
      }
      info(message, ...args) {
        for (const logger of this.loggers) {
          logger.info(message, ...args);
        }
      }
      warn(message, ...args) {
        for (const logger of this.loggers) {
          logger.warn(message, ...args);
        }
      }
      error(message, ...args) {
        for (const logger of this.loggers) {
          logger.error(message, ...args);
        }
      }
      flush() {
        for (const logger of this.loggers) {
          logger.flush();
        }
      }
      dispose() {
        for (const logger of this.loggers) {
          logger.dispose();
        }
      }
    };
    AbstractLoggerService = class extends Disposable {
      constructor(logLevel, logsHome, loggerResources) {
        super();
        this.logLevel = logLevel;
        this.logsHome = logsHome;
        this._loggers = new ResourceMap();
        this._onDidChangeLoggers = this._register(new Emitter());
        this.onDidChangeLoggers = this._onDidChangeLoggers.event;
        this._onDidChangeLogLevel = this._register(new Emitter());
        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
        this._onDidChangeVisibility = this._register(new Emitter());
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        if (loggerResources) {
          for (const loggerResource of loggerResources) {
            this._loggers.set(loggerResource.resource, { logger: void 0, info: loggerResource });
          }
        }
      }
      getLoggerEntry(resourceOrId) {
        if (isString(resourceOrId)) {
          return [...this._loggers.values()].find((logger) => logger.info.id === resourceOrId);
        }
        return this._loggers.get(resourceOrId);
      }
      getLogger(resourceOrId) {
        var _a4;
        return (_a4 = this.getLoggerEntry(resourceOrId)) === null || _a4 === void 0 ? void 0 : _a4.logger;
      }
      createLogger(idOrResource, options) {
        var _a4, _b2, _c2;
        const resource = this.toResource(idOrResource);
        const id2 = isString(idOrResource) ? idOrResource : (_a4 = options === null || options === void 0 ? void 0 : options.id) !== null && _a4 !== void 0 ? _a4 : hash(resource.toString()).toString(16);
        let logger = (_b2 = this._loggers.get(resource)) === null || _b2 === void 0 ? void 0 : _b2.logger;
        const logLevel = (options === null || options === void 0 ? void 0 : options.logLevel) === "always" ? LogLevel.Trace : options === null || options === void 0 ? void 0 : options.logLevel;
        if (!logger) {
          logger = this.doCreateLogger(resource, (_c2 = logLevel !== null && logLevel !== void 0 ? logLevel : this.getLogLevel(resource)) !== null && _c2 !== void 0 ? _c2 : this.logLevel, Object.assign(Object.assign({}, options), { id: id2 }));
        }
        const loggerEntry = {
          logger,
          info: { resource, id: id2, logLevel, name: options === null || options === void 0 ? void 0 : options.name, hidden: options === null || options === void 0 ? void 0 : options.hidden, extensionId: options === null || options === void 0 ? void 0 : options.extensionId, when: options === null || options === void 0 ? void 0 : options.when }
        };
        this.registerLogger(loggerEntry.info);
        this._loggers.set(resource, loggerEntry);
        return logger;
      }
      toResource(idOrResource) {
        return isString(idOrResource) ? joinPath(this.logsHome, `${idOrResource}.log`) : idOrResource;
      }
      setLogLevel(arg1, arg2) {
        var _a4, _b2, _c2;
        if (URI.isUri(arg1)) {
          const resource = arg1;
          const logLevel = arg2;
          const logger = this._loggers.get(resource);
          if (logger && logLevel !== logger.info.logLevel) {
            logger.info.logLevel = logLevel === this.logLevel ? void 0 : logLevel;
            (_a4 = logger.logger) === null || _a4 === void 0 ? void 0 : _a4.setLevel(logLevel);
            this._loggers.set(logger.info.resource, logger);
            this._onDidChangeLogLevel.fire([resource, logLevel]);
          }
        } else {
          this.logLevel = arg1;
          for (const [resource, logger] of this._loggers.entries()) {
            if (((_b2 = this._loggers.get(resource)) === null || _b2 === void 0 ? void 0 : _b2.info.logLevel) === void 0) {
              (_c2 = logger.logger) === null || _c2 === void 0 ? void 0 : _c2.setLevel(this.logLevel);
            }
          }
          this._onDidChangeLogLevel.fire(this.logLevel);
        }
      }
      setVisibility(resourceOrId, visibility) {
        const logger = this.getLoggerEntry(resourceOrId);
        if (logger && visibility !== !logger.info.hidden) {
          logger.info.hidden = !visibility;
          this._loggers.set(logger.info.resource, logger);
          this._onDidChangeVisibility.fire([logger.info.resource, visibility]);
        }
      }
      getLogLevel(resource) {
        var _a4;
        let logLevel;
        if (resource) {
          logLevel = (_a4 = this._loggers.get(resource)) === null || _a4 === void 0 ? void 0 : _a4.info.logLevel;
        }
        return logLevel !== null && logLevel !== void 0 ? logLevel : this.logLevel;
      }
      registerLogger(resource) {
        const existing = this._loggers.get(resource.resource);
        if (existing) {
          if (existing.info.hidden !== resource.hidden) {
            this.setVisibility(resource.resource, !resource.hidden);
          }
        } else {
          this._loggers.set(resource.resource, { info: resource, logger: void 0 });
          this._onDidChangeLoggers.fire({ added: [resource], removed: [] });
        }
      }
      deregisterLogger(resource) {
        const existing = this._loggers.get(resource);
        if (existing) {
          if (existing.logger) {
            existing.logger.dispose();
          }
          this._loggers.delete(resource);
          this._onDidChangeLoggers.fire({ added: [], removed: [existing.info] });
        }
      }
      *getRegisteredLoggers() {
        for (const entry of this._loggers.values()) {
          yield entry.info;
        }
      }
      getRegisteredLogger(resource) {
        var _a4;
        return (_a4 = this._loggers.get(resource)) === null || _a4 === void 0 ? void 0 : _a4.info;
      }
      dispose() {
        this._loggers.forEach((logger) => {
          var _a4;
          return (_a4 = logger.logger) === null || _a4 === void 0 ? void 0 : _a4.dispose();
        });
        this._loggers.clear();
        super.dispose();
      }
    };
    NullLogger = class {
      constructor() {
        this.onDidChangeLogLevel = new Emitter().event;
      }
      setLevel(level) {
      }
      getLevel() {
        return LogLevel.Info;
      }
      trace(message, ...args) {
      }
      debug(message, ...args) {
      }
      info(message, ...args) {
      }
      warn(message, ...args) {
      }
      error(message, ...args) {
      }
      critical(message, ...args) {
      }
      dispose() {
      }
      flush() {
      }
    };
    CONTEXT_LOG_LEVEL = new RawContextKey("logLevel", LogLevelToString(LogLevel.Info));
  }
});

// node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js
var ITelemetryService, ICustomEndpointTelemetryService, TELEMETRY_SETTING_ID, TELEMETRY_CRASH_REPORTER_SETTING_ID, TELEMETRY_OLD_SETTING_ID;
var init_telemetry = __esm({
  "node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js"() {
    init_instantiation();
    ITelemetryService = createDecorator("telemetryService");
    ICustomEndpointTelemetryService = createDecorator("customEndpointTelemetryService");
    TELEMETRY_SETTING_ID = "telemetry.telemetryLevel";
    TELEMETRY_CRASH_REPORTER_SETTING_ID = "telemetry.enableCrashReporter";
    TELEMETRY_OLD_SETTING_ID = "telemetry.enableTelemetry";
  }
});

// node_modules/monaco-editor/esm/vs/base/common/stream.js
function isReadableStream(obj) {
  const candidate = obj;
  if (!candidate) {
    return false;
  }
  return [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every((fn) => typeof fn === "function");
}
function isReadableBufferedStream(obj) {
  const candidate = obj;
  if (!candidate) {
    return false;
  }
  return isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === "boolean";
}
function newWriteableStream(reducer, options) {
  return new WriteableStreamImpl(reducer, options);
}
function consumeReadable(readable, reducer) {
  const chunks = [];
  let chunk;
  while ((chunk = readable.read()) !== null) {
    chunks.push(chunk);
  }
  return reducer(chunks);
}
function peekReadable(readable, reducer, maxChunks) {
  const chunks = [];
  let chunk = void 0;
  while ((chunk = readable.read()) !== null && chunks.length < maxChunks) {
    chunks.push(chunk);
  }
  if (chunk === null && chunks.length > 0) {
    return reducer(chunks);
  }
  return {
    read: () => {
      if (chunks.length > 0) {
        return chunks.shift();
      }
      if (typeof chunk !== "undefined") {
        const lastReadChunk = chunk;
        chunk = void 0;
        return lastReadChunk;
      }
      return readable.read();
    }
  };
}
function consumeStream(stream, reducer) {
  return new Promise((resolve2, reject) => {
    const chunks = [];
    listenStream(stream, {
      onData: (chunk) => {
        if (reducer) {
          chunks.push(chunk);
        }
      },
      onError: (error) => {
        if (reducer) {
          reject(error);
        } else {
          resolve2(void 0);
        }
      },
      onEnd: () => {
        if (reducer) {
          resolve2(reducer(chunks));
        } else {
          resolve2(void 0);
        }
      }
    });
  });
}
function listenStream(stream, listener, token) {
  stream.on("error", (error) => {
    if (!(token === null || token === void 0 ? void 0 : token.isCancellationRequested)) {
      listener.onError(error);
    }
  });
  stream.on("end", () => {
    if (!(token === null || token === void 0 ? void 0 : token.isCancellationRequested)) {
      listener.onEnd();
    }
  });
  stream.on("data", (data) => {
    if (!(token === null || token === void 0 ? void 0 : token.isCancellationRequested)) {
      listener.onData(data);
    }
  });
}
function peekStream(stream, maxChunks) {
  return new Promise((resolve2, reject) => {
    const streamListeners = new DisposableStore();
    const buffer = [];
    const dataListener = (chunk) => {
      buffer.push(chunk);
      if (buffer.length > maxChunks) {
        streamListeners.dispose();
        stream.pause();
        return resolve2({ stream, buffer, ended: false });
      }
    };
    const errorListener = (error) => {
      return reject(error);
    };
    const endListener = () => {
      return resolve2({ stream, buffer, ended: true });
    };
    streamListeners.add(toDisposable(() => stream.removeListener("error", errorListener)));
    stream.on("error", errorListener);
    streamListeners.add(toDisposable(() => stream.removeListener("end", endListener)));
    stream.on("end", endListener);
    streamListeners.add(toDisposable(() => stream.removeListener("data", dataListener)));
    stream.on("data", dataListener);
  });
}
function toStream(t, reducer) {
  const stream = newWriteableStream(reducer);
  stream.end(t);
  return stream;
}
function toReadable(t) {
  let consumed = false;
  return {
    read: () => {
      if (consumed) {
        return null;
      }
      consumed = true;
      return t;
    }
  };
}
function transform(stream, transformer, reducer) {
  const target = newWriteableStream(reducer);
  listenStream(stream, {
    onData: (data) => target.write(transformer.data(data)),
    onError: (error) => target.error(transformer.error ? transformer.error(error) : error),
    onEnd: () => target.end()
  });
  return target;
}
function prefixedReadable(prefix, readable, reducer) {
  let prefixHandled = false;
  return {
    read: () => {
      const chunk = readable.read();
      if (!prefixHandled) {
        prefixHandled = true;
        if (chunk !== null) {
          return reducer([prefix, chunk]);
        }
        return prefix;
      }
      return chunk;
    }
  };
}
function prefixedStream(prefix, stream, reducer) {
  let prefixHandled = false;
  const target = newWriteableStream(reducer);
  listenStream(stream, {
    onData: (data) => {
      if (!prefixHandled) {
        prefixHandled = true;
        return target.write(reducer([prefix, data]));
      }
      return target.write(data);
    },
    onError: (error) => target.error(error),
    onEnd: () => {
      if (!prefixHandled) {
        prefixHandled = true;
        target.write(prefix);
      }
      target.end();
    }
  });
  return target;
}
var WriteableStreamImpl;
var init_stream = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/stream.js"() {
    init_errors();
    init_lifecycle();
    WriteableStreamImpl = class {
      constructor(reducer, options) {
        this.reducer = reducer;
        this.options = options;
        this.state = {
          flowing: false,
          ended: false,
          destroyed: false
        };
        this.buffer = {
          data: [],
          error: []
        };
        this.listeners = {
          data: [],
          error: [],
          end: []
        };
        this.pendingWritePromises = [];
      }
      pause() {
        if (this.state.destroyed) {
          return;
        }
        this.state.flowing = false;
      }
      resume() {
        if (this.state.destroyed) {
          return;
        }
        if (!this.state.flowing) {
          this.state.flowing = true;
          this.flowData();
          this.flowErrors();
          this.flowEnd();
        }
      }
      write(data) {
        var _a4;
        if (this.state.destroyed) {
          return;
        }
        if (this.state.flowing) {
          this.emitData(data);
        } else {
          this.buffer.data.push(data);
          if (typeof ((_a4 = this.options) === null || _a4 === void 0 ? void 0 : _a4.highWaterMark) === "number" && this.buffer.data.length > this.options.highWaterMark) {
            return new Promise((resolve2) => this.pendingWritePromises.push(resolve2));
          }
        }
      }
      error(error) {
        if (this.state.destroyed) {
          return;
        }
        if (this.state.flowing) {
          this.emitError(error);
        } else {
          this.buffer.error.push(error);
        }
      }
      end(result) {
        if (this.state.destroyed) {
          return;
        }
        if (typeof result !== "undefined") {
          this.write(result);
        }
        if (this.state.flowing) {
          this.emitEnd();
          this.destroy();
        } else {
          this.state.ended = true;
        }
      }
      emitData(data) {
        this.listeners.data.slice(0).forEach((listener) => listener(data));
      }
      emitError(error) {
        if (this.listeners.error.length === 0) {
          onUnexpectedError(error);
        } else {
          this.listeners.error.slice(0).forEach((listener) => listener(error));
        }
      }
      emitEnd() {
        this.listeners.end.slice(0).forEach((listener) => listener());
      }
      on(event, callback) {
        if (this.state.destroyed) {
          return;
        }
        switch (event) {
          case "data":
            this.listeners.data.push(callback);
            this.resume();
            break;
          case "end":
            this.listeners.end.push(callback);
            if (this.state.flowing && this.flowEnd()) {
              this.destroy();
            }
            break;
          case "error":
            this.listeners.error.push(callback);
            if (this.state.flowing) {
              this.flowErrors();
            }
            break;
        }
      }
      removeListener(event, callback) {
        if (this.state.destroyed) {
          return;
        }
        let listeners = void 0;
        switch (event) {
          case "data":
            listeners = this.listeners.data;
            break;
          case "end":
            listeners = this.listeners.end;
            break;
          case "error":
            listeners = this.listeners.error;
            break;
        }
        if (listeners) {
          const index2 = listeners.indexOf(callback);
          if (index2 >= 0) {
            listeners.splice(index2, 1);
          }
        }
      }
      flowData() {
        if (this.buffer.data.length > 0) {
          const fullDataBuffer = this.reducer(this.buffer.data);
          this.emitData(fullDataBuffer);
          this.buffer.data.length = 0;
          const pendingWritePromises = [...this.pendingWritePromises];
          this.pendingWritePromises.length = 0;
          pendingWritePromises.forEach((pendingWritePromise) => pendingWritePromise());
        }
      }
      flowErrors() {
        if (this.listeners.error.length > 0) {
          for (const error of this.buffer.error) {
            this.emitError(error);
          }
          this.buffer.error.length = 0;
        }
      }
      flowEnd() {
        if (this.state.ended) {
          this.emitEnd();
          return this.listeners.end.length > 0;
        }
        return false;
      }
      destroy() {
        if (!this.state.destroyed) {
          this.state.destroyed = true;
          this.state.ended = true;
          this.buffer.data.length = 0;
          this.buffer.error.length = 0;
          this.listeners.data.length = 0;
          this.listeners.error.length = 0;
          this.listeners.end.length = 0;
          this.pendingWritePromises.length = 0;
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/buffer.js
function binaryIndexOf(haystack, needle, offset = 0) {
  const needleLen = needle.byteLength;
  const haystackLen = haystack.byteLength;
  if (needleLen === 0) {
    return 0;
  }
  if (needleLen === 1) {
    return haystack.indexOf(needle[0]);
  }
  if (needleLen > haystackLen - offset) {
    return -1;
  }
  const table = indexOfTable.value;
  table.fill(needle.length);
  for (let i2 = 0; i2 < needle.length; i2++) {
    table[needle[i2]] = needle.length - i2 - 1;
  }
  let i = offset + needle.length - 1;
  let j = i;
  let result = -1;
  while (i < haystackLen) {
    if (haystack[i] === needle[j]) {
      if (j === 0) {
        result = i;
        break;
      }
      i--;
      j--;
    } else {
      i += Math.max(needle.length - j, table[haystack[i]]);
      j = needle.length - 1;
    }
  }
  return result;
}
function readUInt16LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;
}
function writeUInt16LE(destination, value, offset) {
  destination[offset + 0] = value & 255;
  value = value >>> 8;
  destination[offset + 1] = value & 255;
}
function readUInt32BE(source, offset) {
  return source[offset] * Math.pow(2, 24) + source[offset + 1] * Math.pow(2, 16) + source[offset + 2] * Math.pow(2, 8) + source[offset + 3];
}
function writeUInt32BE(destination, value, offset) {
  destination[offset + 3] = value;
  value = value >>> 8;
  destination[offset + 2] = value;
  value = value >>> 8;
  destination[offset + 1] = value;
  value = value >>> 8;
  destination[offset] = value;
}
function readUInt32LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0 | source[offset + 2] << 16 >>> 0 | source[offset + 3] << 24 >>> 0;
}
function writeUInt32LE(destination, value, offset) {
  destination[offset + 0] = value & 255;
  value = value >>> 8;
  destination[offset + 1] = value & 255;
  value = value >>> 8;
  destination[offset + 2] = value & 255;
  value = value >>> 8;
  destination[offset + 3] = value & 255;
}
function readUInt8(source, offset) {
  return source[offset];
}
function writeUInt8(destination, value, offset) {
  destination[offset] = value;
}
function readableToBuffer(readable) {
  return consumeReadable(readable, (chunks) => VSBuffer.concat(chunks));
}
function bufferToReadable(buffer) {
  return toReadable(buffer);
}
function streamToBuffer(stream) {
  return consumeStream(stream, (chunks) => VSBuffer.concat(chunks));
}
function bufferedStreamToBuffer(bufferedStream) {
  return __awaiter4(this, void 0, void 0, function* () {
    if (bufferedStream.ended) {
      return VSBuffer.concat(bufferedStream.buffer);
    }
    return VSBuffer.concat([
      // Include already read chunks...
      ...bufferedStream.buffer,
      // ...and all additional chunks
      yield streamToBuffer(bufferedStream.stream)
    ]);
  });
}
function bufferToStream(buffer) {
  return toStream(buffer, (chunks) => VSBuffer.concat(chunks));
}
function newWriteableBufferStream(options) {
  return newWriteableStream((chunks) => VSBuffer.concat(chunks), options);
}
function prefixedBufferReadable(prefix, readable) {
  return prefixedReadable(prefix, readable, (chunks) => VSBuffer.concat(chunks));
}
function prefixedBufferStream(prefix, stream) {
  return prefixedStream(prefix, stream, (chunks) => VSBuffer.concat(chunks));
}
function decodeBase64(encoded) {
  let building = 0;
  let remainder = 0;
  let bufi = 0;
  const buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));
  const append = (value) => {
    switch (remainder) {
      case 3:
        buffer[bufi++] = building | value;
        remainder = 0;
        break;
      case 2:
        buffer[bufi++] = building | value >>> 2;
        building = value << 6;
        remainder = 3;
        break;
      case 1:
        buffer[bufi++] = building | value >>> 4;
        building = value << 4;
        remainder = 2;
        break;
      default:
        building = value << 2;
        remainder = 1;
    }
  };
  for (let i = 0; i < encoded.length; i++) {
    const code = encoded.charCodeAt(i);
    if (code >= 65 && code <= 90) {
      append(code - 65);
    } else if (code >= 97 && code <= 122) {
      append(code - 97 + 26);
    } else if (code >= 48 && code <= 57) {
      append(code - 48 + 52);
    } else if (code === 43 || code === 45) {
      append(62);
    } else if (code === 47 || code === 95) {
      append(63);
    } else if (code === 61) {
      break;
    } else {
      throw new SyntaxError(`Unexpected base64 character ${encoded[i]}`);
    }
  }
  const unpadded = bufi;
  while (remainder > 0) {
    append(0);
  }
  return VSBuffer.wrap(buffer).slice(0, unpadded);
}
function encodeBase64({ buffer }, padded = true, urlSafe = false) {
  const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;
  let output = "";
  const remainder = buffer.byteLength % 3;
  let i = 0;
  for (; i < buffer.byteLength - remainder; i += 3) {
    const a = buffer[i + 0];
    const b = buffer[i + 1];
    const c = buffer[i + 2];
    output += dictionary[a >>> 2];
    output += dictionary[(a << 4 | b >>> 4) & 63];
    output += dictionary[(b << 2 | c >>> 6) & 63];
    output += dictionary[c & 63];
  }
  if (remainder === 1) {
    const a = buffer[i + 0];
    output += dictionary[a >>> 2];
    output += dictionary[a << 4 & 63];
    if (padded) {
      output += "==";
    }
  } else if (remainder === 2) {
    const a = buffer[i + 0];
    const b = buffer[i + 1];
    output += dictionary[a >>> 2];
    output += dictionary[(a << 4 | b >>> 4) & 63];
    output += dictionary[b << 2 & 63];
    if (padded) {
      output += "=";
    }
  }
  return output;
}
var __awaiter4, hasBuffer, indexOfTable, textEncoder, textDecoder, VSBuffer, base64Alphabet, base64UrlSafeAlphabet;
var init_buffer = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/buffer.js"() {
    init_lazy();
    init_stream();
    __awaiter4 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    hasBuffer = typeof Buffer !== "undefined";
    indexOfTable = new Lazy(() => new Uint8Array(256));
    VSBuffer = class _VSBuffer {
      /**
       * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
       * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
       */
      static alloc(byteLength) {
        if (hasBuffer) {
          return new _VSBuffer(Buffer.allocUnsafe(byteLength));
        } else {
          return new _VSBuffer(new Uint8Array(byteLength));
        }
      }
      /**
       * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
       * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
       * which is not transferrable.
       */
      static wrap(actual) {
        if (hasBuffer && !Buffer.isBuffer(actual)) {
          actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
        }
        return new _VSBuffer(actual);
      }
      /**
       * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
       * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
       */
      static fromString(source, options) {
        const dontUseNodeBuffer = (options === null || options === void 0 ? void 0 : options.dontUseNodeBuffer) || false;
        if (!dontUseNodeBuffer && hasBuffer) {
          return new _VSBuffer(Buffer.from(source));
        } else {
          if (!textEncoder) {
            textEncoder = new TextEncoder();
          }
          return new _VSBuffer(textEncoder.encode(source));
        }
      }
      /**
       * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
       * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
       */
      static fromByteArray(source) {
        const result = _VSBuffer.alloc(source.length);
        for (let i = 0, len = source.length; i < len; i++) {
          result.buffer[i] = source[i];
        }
        return result;
      }
      /**
       * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
       * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
       */
      static concat(buffers, totalLength) {
        if (typeof totalLength === "undefined") {
          totalLength = 0;
          for (let i = 0, len = buffers.length; i < len; i++) {
            totalLength += buffers[i].byteLength;
          }
        }
        const ret = _VSBuffer.alloc(totalLength);
        let offset = 0;
        for (let i = 0, len = buffers.length; i < len; i++) {
          const element = buffers[i];
          ret.set(element, offset);
          offset += element.byteLength;
        }
        return ret;
      }
      constructor(buffer) {
        this.buffer = buffer;
        this.byteLength = this.buffer.byteLength;
      }
      /**
       * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
       * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
       */
      clone() {
        const result = _VSBuffer.alloc(this.byteLength);
        result.set(this);
        return result;
      }
      toString() {
        if (hasBuffer) {
          return this.buffer.toString();
        } else {
          if (!textDecoder) {
            textDecoder = new TextDecoder();
          }
          return textDecoder.decode(this.buffer);
        }
      }
      slice(start, end) {
        return new _VSBuffer(this.buffer.subarray(start, end));
      }
      set(array, offset) {
        if (array instanceof _VSBuffer) {
          this.buffer.set(array.buffer, offset);
        } else if (array instanceof Uint8Array) {
          this.buffer.set(array, offset);
        } else if (array instanceof ArrayBuffer) {
          this.buffer.set(new Uint8Array(array), offset);
        } else if (ArrayBuffer.isView(array)) {
          this.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);
        } else {
          throw new Error(`Unknown argument 'array'`);
        }
      }
      readUInt32BE(offset) {
        return readUInt32BE(this.buffer, offset);
      }
      writeUInt32BE(value, offset) {
        writeUInt32BE(this.buffer, value, offset);
      }
      readUInt32LE(offset) {
        return readUInt32LE(this.buffer, offset);
      }
      writeUInt32LE(value, offset) {
        writeUInt32LE(this.buffer, value, offset);
      }
      readUInt8(offset) {
        return readUInt8(this.buffer, offset);
      }
      writeUInt8(value, offset) {
        writeUInt8(this.buffer, value, offset);
      }
      indexOf(subarray, offset = 0) {
        return binaryIndexOf(this.buffer, subarray instanceof _VSBuffer ? subarray.buffer : subarray, offset);
      }
    };
    base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    base64UrlSafeAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  }
});

// node_modules/monaco-editor/esm/vs/base/common/objects.js
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.entries(obj).forEach(([key, value]) => {
    result[key] = value && typeof value === "object" ? deepClone(value) : value;
  });
  return result;
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    const obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key in obj2) {
      if (_hasOwnProperty.call(obj2, key)) {
        const prop = obj2[key];
        if (typeof prop === "object" && !Object.isFrozen(prop) && !isTypedArray(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
function cloneAndChange(obj, changer) {
  return _cloneAndChange(obj, changer, /* @__PURE__ */ new Set());
}
function _cloneAndChange(obj, changer, seen) {
  if (isUndefinedOrNull(obj)) {
    return obj;
  }
  const changed = changer(obj);
  if (typeof changed !== "undefined") {
    return changed;
  }
  if (Array.isArray(obj)) {
    const r1 = [];
    for (const e of obj) {
      r1.push(_cloneAndChange(e, changer, seen));
    }
    return r1;
  }
  if (isObject(obj)) {
    if (seen.has(obj)) {
      throw new Error("Cannot clone recursive data-structure");
    }
    seen.add(obj);
    const r2 = {};
    for (const i2 in obj) {
      if (_hasOwnProperty.call(obj, i2)) {
        r2[i2] = _cloneAndChange(obj[i2], changer, seen);
      }
    }
    seen.delete(obj);
    return r2;
  }
  return obj;
}
function mixin(destination, source, overwrite = true) {
  if (!isObject(destination)) {
    return source;
  }
  if (isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (isObject(destination[key]) && isObject(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function equals2(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals2(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals2(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals2(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
function safeStringify(obj) {
  const seen = /* @__PURE__ */ new Set();
  return JSON.stringify(obj, (key, value) => {
    if (isObject(value) || Array.isArray(value)) {
      if (seen.has(value)) {
        return "[Circular]";
      } else {
        seen.add(value);
      }
    }
    return value;
  });
}
function distinct2(base, target) {
  const result = /* @__PURE__ */ Object.create(null);
  if (!base || !target) {
    return result;
  }
  const targetKeys = Object.keys(target);
  targetKeys.forEach((k) => {
    const baseValue = base[k];
    const targetValue = target[k];
    if (!equals2(baseValue, targetValue)) {
      result[k] = targetValue;
    }
  });
  return result;
}
function filter(obj, predicate) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    if (predicate(key, value)) {
      result[key] = value;
    }
  }
  return result;
}
function getAllPropertyNames(obj) {
  let res = [];
  while (Object.prototype !== obj) {
    res = res.concat(Object.getOwnPropertyNames(obj));
    obj = Object.getPrototypeOf(obj);
  }
  return res;
}
function getAllMethodNames(obj) {
  const methods = [];
  for (const prop of getAllPropertyNames(obj)) {
    if (typeof obj[prop] === "function") {
      methods.push(prop);
    }
  }
  return methods;
}
function createProxyObject(methodNames, invoke) {
  const createProxyMethod = (method) => {
    return function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    };
  };
  const result = {};
  for (const methodName of methodNames) {
    result[methodName] = createProxyMethod(methodName);
  }
  return result;
}
var _hasOwnProperty;
var init_objects = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/objects.js"() {
    init_types();
    _hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model.js
function isITextSnapshot(obj) {
  return obj && typeof obj.read === "function";
}
function shouldSynchronizeModel(model) {
  return !model.isTooLargeForSyncing() && !model.isForSimpleWidget;
}
var OverviewRulerLane, GlyphMarginLane, MinimapPosition, InjectedTextCursorStops, TextModelResolvedOptions, FindMatch, ValidAnnotatedEditOperation, SearchData, ApplyEditsResult;
var init_model = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model.js"() {
    init_objects();
    (function(OverviewRulerLane2) {
      OverviewRulerLane2[OverviewRulerLane2["Left"] = 1] = "Left";
      OverviewRulerLane2[OverviewRulerLane2["Center"] = 2] = "Center";
      OverviewRulerLane2[OverviewRulerLane2["Right"] = 4] = "Right";
      OverviewRulerLane2[OverviewRulerLane2["Full"] = 7] = "Full";
    })(OverviewRulerLane || (OverviewRulerLane = {}));
    (function(GlyphMarginLane2) {
      GlyphMarginLane2[GlyphMarginLane2["Left"] = 1] = "Left";
      GlyphMarginLane2[GlyphMarginLane2["Right"] = 2] = "Right";
    })(GlyphMarginLane || (GlyphMarginLane = {}));
    (function(MinimapPosition2) {
      MinimapPosition2[MinimapPosition2["Inline"] = 1] = "Inline";
      MinimapPosition2[MinimapPosition2["Gutter"] = 2] = "Gutter";
    })(MinimapPosition || (MinimapPosition = {}));
    (function(InjectedTextCursorStops2) {
      InjectedTextCursorStops2[InjectedTextCursorStops2["Both"] = 0] = "Both";
      InjectedTextCursorStops2[InjectedTextCursorStops2["Right"] = 1] = "Right";
      InjectedTextCursorStops2[InjectedTextCursorStops2["Left"] = 2] = "Left";
      InjectedTextCursorStops2[InjectedTextCursorStops2["None"] = 3] = "None";
    })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
    TextModelResolvedOptions = class {
      get originalIndentSize() {
        return this._indentSizeIsTabSize ? "tabSize" : this.indentSize;
      }
      /**
       * @internal
       */
      constructor(src) {
        this._textModelResolvedOptionsBrand = void 0;
        this.tabSize = Math.max(1, src.tabSize | 0);
        if (src.indentSize === "tabSize") {
          this.indentSize = this.tabSize;
          this._indentSizeIsTabSize = true;
        } else {
          this.indentSize = Math.max(1, src.indentSize | 0);
          this._indentSizeIsTabSize = false;
        }
        this.insertSpaces = Boolean(src.insertSpaces);
        this.defaultEOL = src.defaultEOL | 0;
        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;
      }
      /**
       * @internal
       */
      equals(other) {
        return this.tabSize === other.tabSize && this._indentSizeIsTabSize === other._indentSizeIsTabSize && this.indentSize === other.indentSize && this.insertSpaces === other.insertSpaces && this.defaultEOL === other.defaultEOL && this.trimAutoWhitespace === other.trimAutoWhitespace && equals2(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions);
      }
      /**
       * @internal
       */
      createChangeEvent(newOpts) {
        return {
          tabSize: this.tabSize !== newOpts.tabSize,
          indentSize: this.indentSize !== newOpts.indentSize,
          insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
          trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace
        };
      }
    };
    FindMatch = class {
      /**
       * @internal
       */
      constructor(range2, matches) {
        this._findMatchBrand = void 0;
        this.range = range2;
        this.matches = matches;
      }
    };
    ValidAnnotatedEditOperation = class {
      constructor(identifier, range2, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {
        this.identifier = identifier;
        this.range = range2;
        this.text = text;
        this.forceMoveMarkers = forceMoveMarkers;
        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;
        this._isTracked = _isTracked;
      }
    };
    SearchData = class {
      constructor(regex, wordSeparators2, simpleSearch) {
        this.regex = regex;
        this.wordSeparators = wordSeparators2;
        this.simpleSearch = simpleSearch;
      }
    };
    ApplyEditsResult = class {
      constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
        this.reverseEdits = reverseEdits;
        this.changes = changes;
        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js
var EDITOR_MODEL_DEFAULTS;
var init_textModelDefaults = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js"() {
    EDITOR_MODEL_DEFAULTS = {
      tabSize: 4,
      indentSize: 4,
      insertSpaces: true,
      detectIndentation: true,
      trimAutoWhitespace: true,
      largeFileOptimizations: true,
      bracketPairColorizationOptions: {
        enabled: true,
        independentColorPoolPerBracketType: false
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
function createWordRegExp(allowInWords = "") {
  let source = "(-?\\d*\\.\\d\\w*)|([^";
  for (const sep2 of USUAL_WORD_SEPARATORS) {
    if (allowInWords.indexOf(sep2) >= 0) {
      continue;
    }
    source += "\\" + sep2;
  }
  source += "\\s]+)";
  return new RegExp(source, "g");
}
function ensureValidWordDefinition(wordDefinition) {
  let result = DEFAULT_WORD_REGEXP;
  if (wordDefinition && wordDefinition instanceof RegExp) {
    if (!wordDefinition.global) {
      let flags = "g";
      if (wordDefinition.ignoreCase) {
        flags += "i";
      }
      if (wordDefinition.multiline) {
        flags += "m";
      }
      if (wordDefinition.unicode) {
        flags += "u";
      }
      result = new RegExp(wordDefinition.source, flags);
    } else {
      result = wordDefinition;
    }
  }
  result.lastIndex = 0;
  return result;
}
function getWordAtText(column, wordDefinition, text, textOffset, config) {
  if (!config) {
    config = Iterable.first(_defaultConfig);
  }
  if (text.length > config.maxLen) {
    let start = column - config.maxLen / 2;
    if (start < 0) {
      start = 0;
    } else {
      textOffset += start;
    }
    text = text.substring(start, column + config.maxLen / 2);
    return getWordAtText(column, wordDefinition, text, textOffset, config);
  }
  const t1 = Date.now();
  const pos = column - 1 - textOffset;
  let prevRegexIndex = -1;
  let match = null;
  for (let i = 1; ; i++) {
    if (Date.now() - t1 >= config.timeBudget) {
      break;
    }
    const regexIndex = pos - config.windowSize * i;
    wordDefinition.lastIndex = Math.max(0, regexIndex);
    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
    if (!thisMatch && match) {
      break;
    }
    match = thisMatch;
    if (regexIndex <= 0) {
      break;
    }
    prevRegexIndex = regexIndex;
  }
  if (match) {
    const result = {
      word: match[0],
      startColumn: textOffset + 1 + match.index,
      endColumn: textOffset + 1 + match.index + match[0].length
    };
    wordDefinition.lastIndex = 0;
    return result;
  }
  return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
  let match;
  while (match = wordDefinition.exec(text)) {
    const matchIndex = match.index || 0;
    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
      return match;
    } else if (stopPos > 0 && matchIndex > stopPos) {
      return null;
    }
  }
  return null;
}
var USUAL_WORD_SEPARATORS, DEFAULT_WORD_REGEXP, _defaultConfig;
var init_wordHelper = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"() {
    init_iterator();
    init_lifecycle();
    init_linkedList();
    USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
    DEFAULT_WORD_REGEXP = createWordRegExp();
    _defaultConfig = new LinkedList();
    _defaultConfig.unshift({
      maxLen: 1e3,
      windowSize: 15,
      timeBudget: 150
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js
function applyUpdate(value, update) {
  if (typeof value !== "object" || typeof update !== "object" || !value || !update) {
    return new ApplyUpdateResult(update, value !== update);
  }
  if (Array.isArray(value) || Array.isArray(update)) {
    const arrayEquals = Array.isArray(value) && Array.isArray(update) && equals(value, update);
    return new ApplyUpdateResult(update, !arrayEquals);
  }
  let didChange = false;
  for (const key in update) {
    if (update.hasOwnProperty(key)) {
      const result = applyUpdate(value[key], update[key]);
      if (result.didChange) {
        value[key] = result.newValue;
        didChange = true;
      }
    }
  }
  return new ApplyUpdateResult(value, didChange);
}
function boolean(value, defaultValue) {
  if (typeof value === "undefined") {
    return defaultValue;
  }
  if (value === "false") {
    return false;
  }
  return Boolean(value);
}
function clampedInt(value, defaultValue, minimum, maximum) {
  if (typeof value === "undefined") {
    return defaultValue;
  }
  let r = parseInt(value, 10);
  if (isNaN(r)) {
    return defaultValue;
  }
  r = Math.max(minimum, r);
  r = Math.min(maximum, r);
  return r | 0;
}
function clampedFloat(value, defaultValue, minimum, maximum) {
  if (typeof value === "undefined") {
    return defaultValue;
  }
  const r = EditorFloatOption.float(value, defaultValue);
  return EditorFloatOption.clamp(r, minimum, maximum);
}
function stringSet(value, defaultValue, allowedValues, renamedValues) {
  if (typeof value !== "string") {
    return defaultValue;
  }
  if (renamedValues && value in renamedValues) {
    return renamedValues[value];
  }
  if (allowedValues.indexOf(value) === -1) {
    return defaultValue;
  }
  return value;
}
function _autoIndentFromString(autoIndent) {
  switch (autoIndent) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
function _cursorBlinkingStyleFromString(cursorBlinkingStyle) {
  switch (cursorBlinkingStyle) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
function cursorStyleToString(cursorStyle) {
  switch (cursorStyle) {
    case TextEditorCursorStyle.Line:
      return "line";
    case TextEditorCursorStyle.Block:
      return "block";
    case TextEditorCursorStyle.Underline:
      return "underline";
    case TextEditorCursorStyle.LineThin:
      return "line-thin";
    case TextEditorCursorStyle.BlockOutline:
      return "block-outline";
    case TextEditorCursorStyle.UnderlineThin:
      return "underline-thin";
  }
}
function _cursorStyleFromString(cursorStyle) {
  switch (cursorStyle) {
    case "line":
      return TextEditorCursorStyle.Line;
    case "block":
      return TextEditorCursorStyle.Block;
    case "underline":
      return TextEditorCursorStyle.Underline;
    case "line-thin":
      return TextEditorCursorStyle.LineThin;
    case "block-outline":
      return TextEditorCursorStyle.BlockOutline;
    case "underline-thin":
      return TextEditorCursorStyle.UnderlineThin;
  }
}
function _multiCursorModifierFromString(multiCursorModifier) {
  if (multiCursorModifier === "ctrlCmd") {
    return isMacintosh ? "metaKey" : "ctrlKey";
  }
  return "altKey";
}
function filterValidationDecorations(options) {
  const renderValidationDecorations = options.get(
    96
    /* EditorOption.renderValidationDecorations */
  );
  if (renderValidationDecorations === "editable") {
    return options.get(
      89
      /* EditorOption.readOnly */
    );
  }
  return renderValidationDecorations === "on" ? false : true;
}
function _scrollbarVisibilityFromString(visibility, defaultValue) {
  if (typeof visibility !== "string") {
    return defaultValue;
  }
  switch (visibility) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
function primitiveSet(value, defaultValue, allowedValues) {
  const idx = allowedValues.indexOf(value);
  if (idx === -1) {
    return defaultValue;
  }
  return allowedValues[idx];
}
function register(option) {
  editorOptionsRegistry[option.id] = option;
  return option;
}
var MINIMAP_GUTTER_WIDTH, ConfigurationChangedEvent, ComputeOptionsMemory, BaseEditorOption, ApplyUpdateResult, ComputedEditorOption, SimpleEditorOption, EditorBooleanOption, EditorIntOption, EditorFloatOption, EditorStringOption, EditorStringEnumOption, EditorEnumOption, EditorAccessibilitySupport, EditorComments, TextEditorCursorStyle, EditorClassName, EditorEmptySelectionClipboard, EditorFind, EditorFontLigatures, EditorFontVariations, EditorFontInfo, EditorFontSize, EditorFontWeight, EditorGoToLocation, EditorHover, EditorLayoutInfoComputer, WrappingStrategy, EditorLightbulb, EditorStickyScroll, EditorInlayHints, EditorLineDecorationsWidth, EditorLineHeight, EditorMinimap, EditorPadding, EditorParameterHints, EditorPixelRatio, EditorQuickSuggestions, EditorRenderLineNumbersOption, EditorRulers, ReadonlyMessage, EditorScrollbar, inUntrustedWorkspace, unicodeHighlightConfigKeys, UnicodeHighlight, InlineEditorSuggest, BracketPairColorization, GuideOptions, EditorSuggest, SmartSelect, WrappingIndentOption, EditorWrappingInfoComputer, EditorDropIntoEditor, EditorPasteAs, DEFAULT_WINDOWS_FONT_FAMILY, DEFAULT_MAC_FONT_FAMILY, DEFAULT_LINUX_FONT_FAMILY, EDITOR_FONT_DEFAULTS, editorOptionsRegistry, EditorOptions;
var init_editorOptions = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js"() {
    init_arrays();
    init_objects();
    init_platform();
    init_textModelDefaults();
    init_wordHelper();
    init_nls();
    MINIMAP_GUTTER_WIDTH = 8;
    ConfigurationChangedEvent = class {
      /**
       * @internal
       */
      constructor(values) {
        this._values = values;
      }
      hasChanged(id2) {
        return this._values[id2];
      }
    };
    ComputeOptionsMemory = class {
      constructor() {
        this.stableMinimapLayoutInput = null;
        this.stableFitMaxMinimapScale = 0;
        this.stableFitRemainingWidth = 0;
      }
    };
    BaseEditorOption = class {
      constructor(id2, name, defaultValue, schema) {
        this.id = id2;
        this.name = name;
        this.defaultValue = defaultValue;
        this.schema = schema;
      }
      applyUpdate(value, update) {
        return applyUpdate(value, update);
      }
      compute(env2, options, value) {
        return value;
      }
    };
    ApplyUpdateResult = class {
      constructor(newValue, didChange) {
        this.newValue = newValue;
        this.didChange = didChange;
      }
    };
    ComputedEditorOption = class {
      constructor(id2) {
        this.schema = void 0;
        this.id = id2;
        this.name = "_never_";
        this.defaultValue = void 0;
      }
      applyUpdate(value, update) {
        return applyUpdate(value, update);
      }
      validate(input) {
        return this.defaultValue;
      }
    };
    SimpleEditorOption = class {
      constructor(id2, name, defaultValue, schema) {
        this.id = id2;
        this.name = name;
        this.defaultValue = defaultValue;
        this.schema = schema;
      }
      applyUpdate(value, update) {
        return applyUpdate(value, update);
      }
      validate(input) {
        if (typeof input === "undefined") {
          return this.defaultValue;
        }
        return input;
      }
      compute(env2, options, value) {
        return value;
      }
    };
    EditorBooleanOption = class extends SimpleEditorOption {
      constructor(id2, name, defaultValue, schema = void 0) {
        if (typeof schema !== "undefined") {
          schema.type = "boolean";
          schema.default = defaultValue;
        }
        super(id2, name, defaultValue, schema);
      }
      validate(input) {
        return boolean(input, this.defaultValue);
      }
    };
    EditorIntOption = class _EditorIntOption extends SimpleEditorOption {
      static clampedInt(value, defaultValue, minimum, maximum) {
        return clampedInt(value, defaultValue, minimum, maximum);
      }
      constructor(id2, name, defaultValue, minimum, maximum, schema = void 0) {
        if (typeof schema !== "undefined") {
          schema.type = "integer";
          schema.default = defaultValue;
          schema.minimum = minimum;
          schema.maximum = maximum;
        }
        super(id2, name, defaultValue, schema);
        this.minimum = minimum;
        this.maximum = maximum;
      }
      validate(input) {
        return _EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);
      }
    };
    EditorFloatOption = class _EditorFloatOption extends SimpleEditorOption {
      static clamp(n, min, max) {
        if (n < min) {
          return min;
        }
        if (n > max) {
          return max;
        }
        return n;
      }
      static float(value, defaultValue) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "undefined") {
          return defaultValue;
        }
        const r = parseFloat(value);
        return isNaN(r) ? defaultValue : r;
      }
      constructor(id2, name, defaultValue, validationFn, schema) {
        if (typeof schema !== "undefined") {
          schema.type = "number";
          schema.default = defaultValue;
        }
        super(id2, name, defaultValue, schema);
        this.validationFn = validationFn;
      }
      validate(input) {
        return this.validationFn(_EditorFloatOption.float(input, this.defaultValue));
      }
    };
    EditorStringOption = class _EditorStringOption extends SimpleEditorOption {
      static string(value, defaultValue) {
        if (typeof value !== "string") {
          return defaultValue;
        }
        return value;
      }
      constructor(id2, name, defaultValue, schema = void 0) {
        if (typeof schema !== "undefined") {
          schema.type = "string";
          schema.default = defaultValue;
        }
        super(id2, name, defaultValue, schema);
      }
      validate(input) {
        return _EditorStringOption.string(input, this.defaultValue);
      }
    };
    EditorStringEnumOption = class extends SimpleEditorOption {
      constructor(id2, name, defaultValue, allowedValues, schema = void 0) {
        if (typeof schema !== "undefined") {
          schema.type = "string";
          schema.enum = allowedValues;
          schema.default = defaultValue;
        }
        super(id2, name, defaultValue, schema);
        this._allowedValues = allowedValues;
      }
      validate(input) {
        return stringSet(input, this.defaultValue, this._allowedValues);
      }
    };
    EditorEnumOption = class extends BaseEditorOption {
      constructor(id2, name, defaultValue, defaultStringValue, allowedValues, convert, schema = void 0) {
        if (typeof schema !== "undefined") {
          schema.type = "string";
          schema.enum = allowedValues;
          schema.default = defaultStringValue;
        }
        super(id2, name, defaultValue, schema);
        this._allowedValues = allowedValues;
        this._convert = convert;
      }
      validate(input) {
        if (typeof input !== "string") {
          return this.defaultValue;
        }
        if (this._allowedValues.indexOf(input) === -1) {
          return this.defaultValue;
        }
        return this._convert(input);
      }
    };
    EditorAccessibilitySupport = class extends BaseEditorOption {
      constructor() {
        super(2, "accessibilitySupport", 0, {
          type: "string",
          enum: ["auto", "on", "off"],
          enumDescriptions: [
            localize("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached"),
            localize("accessibilitySupport.on", "Optimize for usage with a Screen Reader"),
            localize("accessibilitySupport.off", "Assume a screen reader is not attached")
          ],
          default: "auto",
          tags: ["accessibility"],
          description: localize("accessibilitySupport", "Controls if the UI should run in a mode where it is optimized for screen readers.")
        });
      }
      validate(input) {
        switch (input) {
          case "auto":
            return 0;
          case "off":
            return 1;
          case "on":
            return 2;
        }
        return this.defaultValue;
      }
      compute(env2, options, value) {
        if (value === 0) {
          return env2.accessibilitySupport;
        }
        return value;
      }
    };
    EditorComments = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          insertSpace: true,
          ignoreEmptyLines: true
        };
        super(22, "comments", defaults, {
          "editor.comments.insertSpace": {
            type: "boolean",
            default: defaults.insertSpace,
            description: localize("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
          },
          "editor.comments.ignoreEmptyLines": {
            type: "boolean",
            default: defaults.ignoreEmptyLines,
            description: localize("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),
          ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
        };
      }
    };
    (function(TextEditorCursorStyle2) {
      TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
      TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
      TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
      TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
      TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
      TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
    })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
    EditorClassName = class extends ComputedEditorOption {
      constructor() {
        super(
          139
          /* EditorOption.editorClassName */
        );
      }
      compute(env2, options, _) {
        const classNames = ["monaco-editor"];
        if (options.get(
          38
          /* EditorOption.extraEditorClassName */
        )) {
          classNames.push(options.get(
            38
            /* EditorOption.extraEditorClassName */
          ));
        }
        if (env2.extraEditorClassName) {
          classNames.push(env2.extraEditorClassName);
        }
        if (options.get(
          72
          /* EditorOption.mouseStyle */
        ) === "default") {
          classNames.push("mouse-default");
        } else if (options.get(
          72
          /* EditorOption.mouseStyle */
        ) === "copy") {
          classNames.push("mouse-copy");
        }
        if (options.get(
          109
          /* EditorOption.showUnused */
        )) {
          classNames.push("showUnused");
        }
        if (options.get(
          137
          /* EditorOption.showDeprecated */
        )) {
          classNames.push("showDeprecated");
        }
        return classNames.join(" ");
      }
    };
    EditorEmptySelectionClipboard = class extends EditorBooleanOption {
      constructor() {
        super(36, "emptySelectionClipboard", true, { description: localize("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
      }
      compute(env2, options, value) {
        return value && env2.emptySelectionClipboard;
      }
    };
    EditorFind = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          cursorMoveOnType: true,
          seedSearchStringFromSelection: "always",
          autoFindInSelection: "never",
          globalFindClipboard: false,
          addExtraSpaceOnTop: true,
          loop: true
        };
        super(40, "find", defaults, {
          "editor.find.cursorMoveOnType": {
            type: "boolean",
            default: defaults.cursorMoveOnType,
            description: localize("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
          },
          "editor.find.seedSearchStringFromSelection": {
            type: "string",
            enum: ["never", "always", "selection"],
            default: defaults.seedSearchStringFromSelection,
            enumDescriptions: [
              localize("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
              localize("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
              localize("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
            ],
            description: localize("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
          },
          "editor.find.autoFindInSelection": {
            type: "string",
            enum: ["never", "always", "multiline"],
            default: defaults.autoFindInSelection,
            enumDescriptions: [
              localize("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
              localize("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
              localize("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
            ],
            description: localize("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
          },
          "editor.find.globalFindClipboard": {
            type: "boolean",
            default: defaults.globalFindClipboard,
            description: localize("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
            included: isMacintosh
          },
          "editor.find.addExtraSpaceOnTop": {
            type: "boolean",
            default: defaults.addExtraSpaceOnTop,
            description: localize("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
          },
          "editor.find.loop": {
            type: "boolean",
            default: defaults.loop,
            description: localize("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
          seedSearchStringFromSelection: typeof _input.seedSearchStringFromSelection === "boolean" ? _input.seedSearchStringFromSelection ? "always" : "never" : stringSet(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
          autoFindInSelection: typeof _input.autoFindInSelection === "boolean" ? _input.autoFindInSelection ? "always" : "never" : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
          globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),
          addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
          loop: boolean(input.loop, this.defaultValue.loop)
        };
      }
    };
    EditorFontLigatures = class _EditorFontLigatures extends BaseEditorOption {
      constructor() {
        super(50, "fontLigatures", _EditorFontLigatures.OFF, {
          anyOf: [
            {
              type: "boolean",
              description: localize("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
            },
            {
              type: "string",
              description: localize("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
            }
          ],
          description: localize("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
          default: false
        });
      }
      validate(input) {
        if (typeof input === "undefined") {
          return this.defaultValue;
        }
        if (typeof input === "string") {
          if (input === "false") {
            return _EditorFontLigatures.OFF;
          }
          if (input === "true") {
            return _EditorFontLigatures.ON;
          }
          return input;
        }
        if (Boolean(input)) {
          return _EditorFontLigatures.ON;
        }
        return _EditorFontLigatures.OFF;
      }
    };
    EditorFontLigatures.OFF = '"liga" off, "calt" off';
    EditorFontLigatures.ON = '"liga" on, "calt" on';
    EditorFontVariations = class _EditorFontVariations extends BaseEditorOption {
      constructor() {
        super(53, "fontVariations", _EditorFontVariations.OFF, {
          anyOf: [
            {
              type: "boolean",
              description: localize("fontVariations", "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.")
            },
            {
              type: "string",
              description: localize("fontVariationSettings", "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
            }
          ],
          description: localize("fontVariationsGeneral", "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
          default: false
        });
      }
      validate(input) {
        if (typeof input === "undefined") {
          return this.defaultValue;
        }
        if (typeof input === "string") {
          if (input === "false") {
            return _EditorFontVariations.OFF;
          }
          if (input === "true") {
            return _EditorFontVariations.TRANSLATE;
          }
          return input;
        }
        if (Boolean(input)) {
          return _EditorFontVariations.TRANSLATE;
        }
        return _EditorFontVariations.OFF;
      }
      compute(env2, options, value) {
        return env2.fontInfo.fontVariationSettings;
      }
    };
    EditorFontVariations.OFF = "normal";
    EditorFontVariations.TRANSLATE = "translate";
    EditorFontInfo = class extends ComputedEditorOption {
      constructor() {
        super(
          49
          /* EditorOption.fontInfo */
        );
      }
      compute(env2, options, _) {
        return env2.fontInfo;
      }
    };
    EditorFontSize = class extends SimpleEditorOption {
      constructor() {
        super(51, "fontSize", EDITOR_FONT_DEFAULTS.fontSize, {
          type: "number",
          minimum: 6,
          maximum: 100,
          default: EDITOR_FONT_DEFAULTS.fontSize,
          description: localize("fontSize", "Controls the font size in pixels.")
        });
      }
      validate(input) {
        const r = EditorFloatOption.float(input, this.defaultValue);
        if (r === 0) {
          return EDITOR_FONT_DEFAULTS.fontSize;
        }
        return EditorFloatOption.clamp(r, 6, 100);
      }
      compute(env2, options, value) {
        return env2.fontInfo.fontSize;
      }
    };
    EditorFontWeight = class _EditorFontWeight extends BaseEditorOption {
      constructor() {
        super(52, "fontWeight", EDITOR_FONT_DEFAULTS.fontWeight, {
          anyOf: [
            {
              type: "number",
              minimum: _EditorFontWeight.MINIMUM_VALUE,
              maximum: _EditorFontWeight.MAXIMUM_VALUE,
              errorMessage: localize("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
            },
            {
              type: "string",
              pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
            },
            {
              enum: _EditorFontWeight.SUGGESTION_VALUES
            }
          ],
          default: EDITOR_FONT_DEFAULTS.fontWeight,
          description: localize("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
        });
      }
      validate(input) {
        if (input === "normal" || input === "bold") {
          return input;
        }
        return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, _EditorFontWeight.MINIMUM_VALUE, _EditorFontWeight.MAXIMUM_VALUE));
      }
    };
    EditorFontWeight.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
    EditorFontWeight.MINIMUM_VALUE = 1;
    EditorFontWeight.MAXIMUM_VALUE = 1e3;
    EditorGoToLocation = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          multiple: "peek",
          multipleDefinitions: "peek",
          multipleTypeDefinitions: "peek",
          multipleDeclarations: "peek",
          multipleImplementations: "peek",
          multipleReferences: "peek",
          alternativeDefinitionCommand: "editor.action.goToReferences",
          alternativeTypeDefinitionCommand: "editor.action.goToReferences",
          alternativeDeclarationCommand: "editor.action.goToReferences",
          alternativeImplementationCommand: "",
          alternativeReferenceCommand: ""
        };
        const jsonSubset = {
          type: "string",
          enum: ["peek", "gotoAndPeek", "goto"],
          default: defaults.multiple,
          enumDescriptions: [
            localize("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
            localize("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
            localize("editor.gotoLocation.multiple.goto", "Go to the primary result and enable Peek-less navigation to others")
          ]
        };
        const alternativeCommandOptions = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
        super(57, "gotoLocation", defaults, {
          "editor.gotoLocation.multiple": {
            deprecationMessage: localize("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
          },
          "editor.gotoLocation.multipleDefinitions": Object.assign({ description: localize("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist.") }, jsonSubset),
          "editor.gotoLocation.multipleTypeDefinitions": Object.assign({ description: localize("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.") }, jsonSubset),
          "editor.gotoLocation.multipleDeclarations": Object.assign({ description: localize("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.") }, jsonSubset),
          "editor.gotoLocation.multipleImplementations": Object.assign({ description: localize("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.") }, jsonSubset),
          "editor.gotoLocation.multipleReferences": Object.assign({ description: localize("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist.") }, jsonSubset),
          "editor.gotoLocation.alternativeDefinitionCommand": {
            type: "string",
            default: defaults.alternativeDefinitionCommand,
            enum: alternativeCommandOptions,
            description: localize("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
          },
          "editor.gotoLocation.alternativeTypeDefinitionCommand": {
            type: "string",
            default: defaults.alternativeTypeDefinitionCommand,
            enum: alternativeCommandOptions,
            description: localize("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
          },
          "editor.gotoLocation.alternativeDeclarationCommand": {
            type: "string",
            default: defaults.alternativeDeclarationCommand,
            enum: alternativeCommandOptions,
            description: localize("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
          },
          "editor.gotoLocation.alternativeImplementationCommand": {
            type: "string",
            default: defaults.alternativeImplementationCommand,
            enum: alternativeCommandOptions,
            description: localize("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
          },
          "editor.gotoLocation.alternativeReferenceCommand": {
            type: "string",
            default: defaults.alternativeReferenceCommand,
            enum: alternativeCommandOptions,
            description: localize("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
          }
        });
      }
      validate(_input) {
        var _a4, _b2, _c2, _d, _e;
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          multiple: stringSet(input.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
          multipleDefinitions: (_a4 = input.multipleDefinitions) !== null && _a4 !== void 0 ? _a4 : stringSet(input.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
          multipleTypeDefinitions: (_b2 = input.multipleTypeDefinitions) !== null && _b2 !== void 0 ? _b2 : stringSet(input.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
          multipleDeclarations: (_c2 = input.multipleDeclarations) !== null && _c2 !== void 0 ? _c2 : stringSet(input.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
          multipleImplementations: (_d = input.multipleImplementations) !== null && _d !== void 0 ? _d : stringSet(input.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
          multipleReferences: (_e = input.multipleReferences) !== null && _e !== void 0 ? _e : stringSet(input.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
          alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
          alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
          alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
          alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
          alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand)
        };
      }
    };
    EditorHover = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          enabled: true,
          delay: 300,
          sticky: true,
          above: true
        };
        super(59, "hover", defaults, {
          "editor.hover.enabled": {
            type: "boolean",
            default: defaults.enabled,
            description: localize("hover.enabled", "Controls whether the hover is shown.")
          },
          "editor.hover.delay": {
            type: "number",
            default: defaults.delay,
            minimum: 0,
            maximum: 1e4,
            description: localize("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
          },
          "editor.hover.sticky": {
            type: "boolean",
            default: defaults.sticky,
            description: localize("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
          },
          "editor.hover.above": {
            type: "boolean",
            default: defaults.above,
            description: localize("hover.above", "Prefer showing hovers above the line, if there's space.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          enabled: boolean(input.enabled, this.defaultValue.enabled),
          delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 1e4),
          sticky: boolean(input.sticky, this.defaultValue.sticky),
          above: boolean(input.above, this.defaultValue.above)
        };
      }
    };
    EditorLayoutInfoComputer = class _EditorLayoutInfoComputer extends ComputedEditorOption {
      constructor() {
        super(
          142
          /* EditorOption.layoutInfo */
        );
      }
      compute(env2, options, _) {
        return _EditorLayoutInfoComputer.computeLayout(options, {
          memory: env2.memory,
          outerWidth: env2.outerWidth,
          outerHeight: env2.outerHeight,
          isDominatedByLongLines: env2.isDominatedByLongLines,
          lineHeight: env2.fontInfo.lineHeight,
          viewLineCount: env2.viewLineCount,
          lineNumbersDigitCount: env2.lineNumbersDigitCount,
          typicalHalfwidthCharacterWidth: env2.fontInfo.typicalHalfwidthCharacterWidth,
          maxDigitWidth: env2.fontInfo.maxDigitWidth,
          pixelRatio: env2.pixelRatio,
          glyphMarginDecorationLaneCount: env2.glyphMarginDecorationLaneCount
        });
      }
      static computeContainedMinimapLineCount(input) {
        const typicalViewportLineCount = input.height / input.lineHeight;
        const extraLinesBeforeFirstLine = Math.floor(input.paddingTop / input.lineHeight);
        let extraLinesBeyondLastLine = Math.floor(input.paddingBottom / input.lineHeight);
        if (input.scrollBeyondLastLine) {
          extraLinesBeyondLastLine = Math.max(extraLinesBeyondLastLine, typicalViewportLineCount - 1);
        }
        const desiredRatio = (extraLinesBeforeFirstLine + input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);
        const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);
        return { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };
      }
      static _computeMinimapLayout(input, memory) {
        const outerWidth = input.outerWidth;
        const outerHeight = input.outerHeight;
        const pixelRatio = input.pixelRatio;
        if (!input.minimap.enabled) {
          return {
            renderMinimap: 0,
            minimapLeft: 0,
            minimapWidth: 0,
            minimapHeightIsEditorHeight: false,
            minimapIsSampling: false,
            minimapScale: 1,
            minimapLineHeight: 1,
            minimapCanvasInnerWidth: 0,
            minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),
            minimapCanvasOuterWidth: 0,
            minimapCanvasOuterHeight: outerHeight
          };
        }
        const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;
        const couldUseMemory = stableMinimapLayoutInput && input.outerHeight === stableMinimapLayoutInput.outerHeight && input.lineHeight === stableMinimapLayoutInput.lineHeight && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth && input.pixelRatio === stableMinimapLayoutInput.pixelRatio && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine && input.paddingTop === stableMinimapLayoutInput.paddingTop && input.paddingBottom === stableMinimapLayoutInput.paddingBottom && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled && input.minimap.side === stableMinimapLayoutInput.minimap.side && input.minimap.size === stableMinimapLayoutInput.minimap.size && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn && input.minimap.scale === stableMinimapLayoutInput.minimap.scale && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping;
        const lineHeight = input.lineHeight;
        const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;
        const scrollBeyondLastLine = input.scrollBeyondLastLine;
        const minimapRenderCharacters = input.minimap.renderCharacters;
        let minimapScale = pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale;
        const minimapMaxColumn = input.minimap.maxColumn;
        const minimapSize = input.minimap.size;
        const minimapSide = input.minimap.side;
        const verticalScrollbarWidth = input.verticalScrollbarWidth;
        const viewLineCount = input.viewLineCount;
        const remainingWidth = input.remainingWidth;
        const isViewportWrapping = input.isViewportWrapping;
        const baseCharHeight = minimapRenderCharacters ? 2 : 3;
        let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);
        const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;
        let minimapHeightIsEditorHeight = false;
        let minimapIsSampling = false;
        let minimapLineHeight = baseCharHeight * minimapScale;
        let minimapCharWidth = minimapScale / pixelRatio;
        let minimapWidthMultiplier = 1;
        if (minimapSize === "fill" || minimapSize === "fit") {
          const { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = _EditorLayoutInfoComputer.computeContainedMinimapLineCount({
            viewLineCount,
            scrollBeyondLastLine,
            paddingTop: input.paddingTop,
            paddingBottom: input.paddingBottom,
            height: outerHeight,
            lineHeight,
            pixelRatio
          });
          const ratio = viewLineCount / minimapLineCount;
          if (ratio > 1) {
            minimapHeightIsEditorHeight = true;
            minimapIsSampling = true;
            minimapScale = 1;
            minimapLineHeight = 1;
            minimapCharWidth = minimapScale / pixelRatio;
          } else {
            let fitBecomesFill = false;
            let maxMinimapScale = minimapScale + 1;
            if (minimapSize === "fit") {
              const effectiveMinimapHeight = Math.ceil((extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
              if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
                fitBecomesFill = true;
                maxMinimapScale = memory.stableFitMaxMinimapScale;
              } else {
                fitBecomesFill = effectiveMinimapHeight > minimapCanvasInnerHeight;
              }
            }
            if (minimapSize === "fill" || fitBecomesFill) {
              minimapHeightIsEditorHeight = true;
              const configuredMinimapScale = minimapScale;
              minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));
              if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
                maxMinimapScale = memory.stableFitMaxMinimapScale;
              }
              minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));
              if (minimapScale > configuredMinimapScale) {
                minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);
              }
              minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;
              minimapCanvasInnerHeight = Math.ceil(Math.max(typicalViewportLineCount, extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
              if (isViewportWrapping) {
                memory.stableMinimapLayoutInput = input;
                memory.stableFitRemainingWidth = remainingWidth;
                memory.stableFitMaxMinimapScale = minimapScale;
              } else {
                memory.stableMinimapLayoutInput = null;
                memory.stableFitRemainingWidth = 0;
              }
            }
          }
        }
        const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
        const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);
        let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);
        const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;
        minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);
        const renderMinimap = minimapRenderCharacters ? 1 : 2;
        const minimapLeft = minimapSide === "left" ? 0 : outerWidth - minimapWidth - verticalScrollbarWidth;
        return {
          renderMinimap,
          minimapLeft,
          minimapWidth,
          minimapHeightIsEditorHeight,
          minimapIsSampling,
          minimapScale,
          minimapLineHeight,
          minimapCanvasInnerWidth,
          minimapCanvasInnerHeight,
          minimapCanvasOuterWidth,
          minimapCanvasOuterHeight
        };
      }
      static computeLayout(options, env2) {
        const outerWidth = env2.outerWidth | 0;
        const outerHeight = env2.outerHeight | 0;
        const lineHeight = env2.lineHeight | 0;
        const lineNumbersDigitCount = env2.lineNumbersDigitCount | 0;
        const typicalHalfwidthCharacterWidth = env2.typicalHalfwidthCharacterWidth;
        const maxDigitWidth = env2.maxDigitWidth;
        const pixelRatio = env2.pixelRatio;
        const viewLineCount = env2.viewLineCount;
        const wordWrapOverride2 = options.get(
          134
          /* EditorOption.wordWrapOverride2 */
        );
        const wordWrapOverride1 = wordWrapOverride2 === "inherit" ? options.get(
          133
          /* EditorOption.wordWrapOverride1 */
        ) : wordWrapOverride2;
        const wordWrap = wordWrapOverride1 === "inherit" ? options.get(
          129
          /* EditorOption.wordWrap */
        ) : wordWrapOverride1;
        const wordWrapColumn = options.get(
          132
          /* EditorOption.wordWrapColumn */
        );
        const isDominatedByLongLines = env2.isDominatedByLongLines;
        const showGlyphMargin = options.get(
          56
          /* EditorOption.glyphMargin */
        );
        const showLineNumbers = options.get(
          66
          /* EditorOption.lineNumbers */
        ).renderType !== 0;
        const lineNumbersMinChars = options.get(
          67
          /* EditorOption.lineNumbersMinChars */
        );
        const scrollBeyondLastLine = options.get(
          103
          /* EditorOption.scrollBeyondLastLine */
        );
        const padding = options.get(
          82
          /* EditorOption.padding */
        );
        const minimap = options.get(
          71
          /* EditorOption.minimap */
        );
        const scrollbar = options.get(
          101
          /* EditorOption.scrollbar */
        );
        const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;
        const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;
        const scrollbarArrowSize = scrollbar.arrowSize;
        const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;
        const folding = options.get(
          42
          /* EditorOption.folding */
        );
        const showFoldingDecoration = options.get(
          108
          /* EditorOption.showFoldingControls */
        ) !== "never";
        let lineDecorationsWidth = options.get(
          64
          /* EditorOption.lineDecorationsWidth */
        );
        if (folding && showFoldingDecoration) {
          lineDecorationsWidth += 16;
        }
        let lineNumbersWidth = 0;
        if (showLineNumbers) {
          const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
          lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
        }
        let glyphMarginWidth = 0;
        if (showGlyphMargin) {
          glyphMarginWidth = lineHeight * env2.glyphMarginDecorationLaneCount;
        }
        let glyphMarginLeft = 0;
        let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
        let decorationsLeft = lineNumbersLeft + lineNumbersWidth;
        let contentLeft = decorationsLeft + lineDecorationsWidth;
        const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
        let isWordWrapMinified = false;
        let isViewportWrapping = false;
        let wrappingColumn = -1;
        if (wordWrapOverride1 === "inherit" && isDominatedByLongLines) {
          isWordWrapMinified = true;
          isViewportWrapping = true;
        } else if (wordWrap === "on" || wordWrap === "bounded") {
          isViewportWrapping = true;
        } else if (wordWrap === "wordWrapColumn") {
          wrappingColumn = wordWrapColumn;
        }
        const minimapLayout = _EditorLayoutInfoComputer._computeMinimapLayout({
          outerWidth,
          outerHeight,
          lineHeight,
          typicalHalfwidthCharacterWidth,
          pixelRatio,
          scrollBeyondLastLine,
          paddingTop: padding.top,
          paddingBottom: padding.bottom,
          minimap,
          verticalScrollbarWidth,
          viewLineCount,
          remainingWidth,
          isViewportWrapping
        }, env2.memory || new ComputeOptionsMemory());
        if (minimapLayout.renderMinimap !== 0 && minimapLayout.minimapLeft === 0) {
          glyphMarginLeft += minimapLayout.minimapWidth;
          lineNumbersLeft += minimapLayout.minimapWidth;
          decorationsLeft += minimapLayout.minimapWidth;
          contentLeft += minimapLayout.minimapWidth;
        }
        const contentWidth = remainingWidth - minimapLayout.minimapWidth;
        const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));
        const verticalArrowSize = verticalScrollbarHasArrows ? scrollbarArrowSize : 0;
        if (isViewportWrapping) {
          wrappingColumn = Math.max(1, viewportColumn);
          if (wordWrap === "bounded") {
            wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);
          }
        }
        return {
          width: outerWidth,
          height: outerHeight,
          glyphMarginLeft,
          glyphMarginWidth,
          glyphMarginDecorationLaneCount: env2.glyphMarginDecorationLaneCount,
          lineNumbersLeft,
          lineNumbersWidth,
          decorationsLeft,
          decorationsWidth: lineDecorationsWidth,
          contentLeft,
          contentWidth,
          minimap: minimapLayout,
          viewportColumn,
          isWordWrapMinified,
          isViewportWrapping,
          wrappingColumn,
          verticalScrollbarWidth,
          horizontalScrollbarHeight,
          overviewRuler: {
            top: verticalArrowSize,
            width: verticalScrollbarWidth,
            height: outerHeight - 2 * verticalArrowSize,
            right: 0
          }
        };
      }
    };
    WrappingStrategy = class extends BaseEditorOption {
      constructor() {
        super(136, "wrappingStrategy", "simple", {
          "editor.wrappingStrategy": {
            enumDescriptions: [
              localize("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
              localize("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
            ],
            type: "string",
            enum: ["simple", "advanced"],
            default: "simple",
            description: localize("wrappingStrategy", "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
          }
        });
      }
      validate(input) {
        return stringSet(input, "simple", ["simple", "advanced"]);
      }
      compute(env2, options, value) {
        const accessibilitySupport = options.get(
          2
          /* EditorOption.accessibilitySupport */
        );
        if (accessibilitySupport === 2) {
          return "advanced";
        }
        return value;
      }
    };
    EditorLightbulb = class extends BaseEditorOption {
      constructor() {
        const defaults = { enabled: true };
        super(63, "lightbulb", defaults, {
          "editor.lightbulb.enabled": {
            type: "boolean",
            default: defaults.enabled,
            description: localize("codeActions", "Enables the Code Action lightbulb in the editor.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          enabled: boolean(input.enabled, this.defaultValue.enabled)
        };
      }
    };
    EditorStickyScroll = class extends BaseEditorOption {
      constructor() {
        const defaults = { enabled: false, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: true };
        super(113, "stickyScroll", defaults, {
          "editor.stickyScroll.enabled": {
            type: "boolean",
            default: defaults.enabled,
            description: localize("editor.stickyScroll.enabled", "Shows the nested current scopes during the scroll at the top of the editor.")
          },
          "editor.stickyScroll.maxLineCount": {
            type: "number",
            default: defaults.maxLineCount,
            minimum: 1,
            maximum: 10,
            description: localize("editor.stickyScroll.maxLineCount", "Defines the maximum number of sticky lines to show.")
          },
          "editor.stickyScroll.defaultModel": {
            type: "string",
            enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
            default: defaults.defaultModel,
            description: localize("editor.stickyScroll.defaultModel", "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
          },
          "editor.stickyScroll.scrollWithEditor": {
            type: "boolean",
            default: defaults.scrollWithEditor,
            description: localize("editor.stickyScroll.scrollWithEditor", "Enable scrolling of the sticky scroll widget with the editor's horizontal scrollbar.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          enabled: boolean(input.enabled, this.defaultValue.enabled),
          maxLineCount: EditorIntOption.clampedInt(input.maxLineCount, this.defaultValue.maxLineCount, 1, 10),
          defaultModel: stringSet(input.defaultModel, this.defaultValue.defaultModel, ["outlineModel", "foldingProviderModel", "indentationModel"]),
          scrollWithEditor: boolean(input.scrollWithEditor, this.defaultValue.scrollWithEditor)
        };
      }
    };
    EditorInlayHints = class extends BaseEditorOption {
      constructor() {
        const defaults = { enabled: "on", fontSize: 0, fontFamily: "", padding: false };
        super(138, "inlayHints", defaults, {
          "editor.inlayHints.enabled": {
            type: "string",
            default: defaults.enabled,
            description: localize("inlayHints.enable", "Enables the inlay hints in the editor."),
            enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
            markdownEnumDescriptions: [
              localize("editor.inlayHints.on", "Inlay hints are enabled"),
              localize("editor.inlayHints.onUnlessPressed", "Inlay hints are showing by default and hide when holding {0}", isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
              localize("editor.inlayHints.offUnlessPressed", "Inlay hints are hidden by default and show when holding {0}", isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
              localize("editor.inlayHints.off", "Inlay hints are disabled")
            ]
          },
          "editor.inlayHints.fontSize": {
            type: "number",
            default: defaults.fontSize,
            markdownDescription: localize("inlayHints.fontSize", "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", "`#editor.fontSize#`", "`5`")
          },
          "editor.inlayHints.fontFamily": {
            type: "string",
            default: defaults.fontFamily,
            markdownDescription: localize("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", "`#editor.fontFamily#`")
          },
          "editor.inlayHints.padding": {
            type: "boolean",
            default: defaults.padding,
            description: localize("inlayHints.padding", "Enables the padding around the inlay hints in the editor.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        if (typeof input.enabled === "boolean") {
          input.enabled = input.enabled ? "on" : "off";
        }
        return {
          enabled: stringSet(input.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
          fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),
          fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),
          padding: boolean(input.padding, this.defaultValue.padding)
        };
      }
    };
    EditorLineDecorationsWidth = class extends BaseEditorOption {
      constructor() {
        super(64, "lineDecorationsWidth", 10);
      }
      validate(input) {
        if (typeof input === "string" && /^\d+(\.\d+)?ch$/.test(input)) {
          const multiple = parseFloat(input.substring(0, input.length - 2));
          return -multiple;
        } else {
          return EditorIntOption.clampedInt(input, this.defaultValue, 0, 1e3);
        }
      }
      compute(env2, options, value) {
        if (value < 0) {
          return EditorIntOption.clampedInt(-value * env2.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3);
        } else {
          return value;
        }
      }
    };
    EditorLineHeight = class extends EditorFloatOption {
      constructor() {
        super(65, "lineHeight", EDITOR_FONT_DEFAULTS.lineHeight, (x) => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: localize("lineHeight", "Controls the line height. \n - Use 0 to automatically compute the line height from the font size.\n - Values between 0 and 8 will be used as a multiplier with the font size.\n - Values greater than or equal to 8 will be used as effective values.") });
      }
      compute(env2, options, value) {
        return env2.fontInfo.lineHeight;
      }
    };
    EditorMinimap = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          enabled: true,
          size: "proportional",
          side: "right",
          showSlider: "mouseover",
          autohide: false,
          renderCharacters: true,
          maxColumn: 120,
          scale: 1
        };
        super(71, "minimap", defaults, {
          "editor.minimap.enabled": {
            type: "boolean",
            default: defaults.enabled,
            description: localize("minimap.enabled", "Controls whether the minimap is shown.")
          },
          "editor.minimap.autohide": {
            type: "boolean",
            default: defaults.autohide,
            description: localize("minimap.autohide", "Controls whether the minimap is hidden automatically.")
          },
          "editor.minimap.size": {
            type: "string",
            enum: ["proportional", "fill", "fit"],
            enumDescriptions: [
              localize("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
              localize("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
              localize("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
            ],
            default: defaults.size,
            description: localize("minimap.size", "Controls the size of the minimap.")
          },
          "editor.minimap.side": {
            type: "string",
            enum: ["left", "right"],
            default: defaults.side,
            description: localize("minimap.side", "Controls the side where to render the minimap.")
          },
          "editor.minimap.showSlider": {
            type: "string",
            enum: ["always", "mouseover"],
            default: defaults.showSlider,
            description: localize("minimap.showSlider", "Controls when the minimap slider is shown.")
          },
          "editor.minimap.scale": {
            type: "number",
            default: defaults.scale,
            minimum: 1,
            maximum: 3,
            enum: [1, 2, 3],
            description: localize("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
          },
          "editor.minimap.renderCharacters": {
            type: "boolean",
            default: defaults.renderCharacters,
            description: localize("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
          },
          "editor.minimap.maxColumn": {
            type: "number",
            default: defaults.maxColumn,
            description: localize("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          enabled: boolean(input.enabled, this.defaultValue.enabled),
          autohide: boolean(input.autohide, this.defaultValue.autohide),
          size: stringSet(input.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
          side: stringSet(input.side, this.defaultValue.side, ["right", "left"]),
          showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
          renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),
          scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),
          maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 1e4)
        };
      }
    };
    EditorPadding = class extends BaseEditorOption {
      constructor() {
        super(82, "padding", { top: 0, bottom: 0 }, {
          "editor.padding.top": {
            type: "number",
            default: 0,
            minimum: 0,
            maximum: 1e3,
            description: localize("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
          },
          "editor.padding.bottom": {
            type: "number",
            default: 0,
            minimum: 0,
            maximum: 1e3,
            description: localize("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          top: EditorIntOption.clampedInt(input.top, 0, 0, 1e3),
          bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1e3)
        };
      }
    };
    EditorParameterHints = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          enabled: true,
          cycle: true
        };
        super(84, "parameterHints", defaults, {
          "editor.parameterHints.enabled": {
            type: "boolean",
            default: defaults.enabled,
            description: localize("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
          },
          "editor.parameterHints.cycle": {
            type: "boolean",
            default: defaults.cycle,
            description: localize("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          enabled: boolean(input.enabled, this.defaultValue.enabled),
          cycle: boolean(input.cycle, this.defaultValue.cycle)
        };
      }
    };
    EditorPixelRatio = class extends ComputedEditorOption {
      constructor() {
        super(
          140
          /* EditorOption.pixelRatio */
        );
      }
      compute(env2, options, _) {
        return env2.pixelRatio;
      }
    };
    EditorQuickSuggestions = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          other: "on",
          comments: "off",
          strings: "off"
        };
        const types = [
          { type: "boolean" },
          {
            type: "string",
            enum: ["on", "inline", "off"],
            enumDescriptions: [localize("on", "Quick suggestions show inside the suggest widget"), localize("inline", "Quick suggestions show as ghost text"), localize("off", "Quick suggestions are disabled")]
          }
        ];
        super(87, "quickSuggestions", defaults, {
          type: "object",
          additionalProperties: false,
          properties: {
            strings: {
              anyOf: types,
              default: defaults.strings,
              description: localize("quickSuggestions.strings", "Enable quick suggestions inside strings.")
            },
            comments: {
              anyOf: types,
              default: defaults.comments,
              description: localize("quickSuggestions.comments", "Enable quick suggestions inside comments.")
            },
            other: {
              anyOf: types,
              default: defaults.other,
              description: localize("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
            }
          },
          default: defaults,
          markdownDescription: localize("quickSuggestions", "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the '{0}'-setting which controls if suggestions are triggered by special characters.", `#editor.suggestOnTriggerCharacters#`)
        });
        this.defaultValue = defaults;
      }
      validate(input) {
        if (typeof input === "boolean") {
          const value = input ? "on" : "off";
          return { comments: value, strings: value, other: value };
        }
        if (!input || typeof input !== "object") {
          return this.defaultValue;
        }
        const { other, comments, strings } = input;
        const allowedValues = ["on", "inline", "off"];
        let validatedOther;
        let validatedComments;
        let validatedStrings;
        if (typeof other === "boolean") {
          validatedOther = other ? "on" : "off";
        } else {
          validatedOther = stringSet(other, this.defaultValue.other, allowedValues);
        }
        if (typeof comments === "boolean") {
          validatedComments = comments ? "on" : "off";
        } else {
          validatedComments = stringSet(comments, this.defaultValue.comments, allowedValues);
        }
        if (typeof strings === "boolean") {
          validatedStrings = strings ? "on" : "off";
        } else {
          validatedStrings = stringSet(strings, this.defaultValue.strings, allowedValues);
        }
        return {
          other: validatedOther,
          comments: validatedComments,
          strings: validatedStrings
        };
      }
    };
    EditorRenderLineNumbersOption = class extends BaseEditorOption {
      constructor() {
        super(66, "lineNumbers", { renderType: 1, renderFn: null }, {
          type: "string",
          enum: ["off", "on", "relative", "interval"],
          enumDescriptions: [
            localize("lineNumbers.off", "Line numbers are not rendered."),
            localize("lineNumbers.on", "Line numbers are rendered as absolute number."),
            localize("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
            localize("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
          ],
          default: "on",
          description: localize("lineNumbers", "Controls the display of line numbers.")
        });
      }
      validate(lineNumbers) {
        let renderType = this.defaultValue.renderType;
        let renderFn = this.defaultValue.renderFn;
        if (typeof lineNumbers !== "undefined") {
          if (typeof lineNumbers === "function") {
            renderType = 4;
            renderFn = lineNumbers;
          } else if (lineNumbers === "interval") {
            renderType = 3;
          } else if (lineNumbers === "relative") {
            renderType = 2;
          } else if (lineNumbers === "on") {
            renderType = 1;
          } else {
            renderType = 0;
          }
        }
        return {
          renderType,
          renderFn
        };
      }
    };
    EditorRulers = class extends BaseEditorOption {
      constructor() {
        const defaults = [];
        const columnSchema = { type: "number", description: localize("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
        super(100, "rulers", defaults, {
          type: "array",
          items: {
            anyOf: [
              columnSchema,
              {
                type: [
                  "object"
                ],
                properties: {
                  column: columnSchema,
                  color: {
                    type: "string",
                    description: localize("rulers.color", "Color of this editor ruler."),
                    format: "color-hex"
                  }
                }
              }
            ]
          },
          default: defaults,
          description: localize("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
        });
      }
      validate(input) {
        if (Array.isArray(input)) {
          const rulers = [];
          for (const _element of input) {
            if (typeof _element === "number") {
              rulers.push({
                column: EditorIntOption.clampedInt(_element, 0, 0, 1e4),
                color: null
              });
            } else if (_element && typeof _element === "object") {
              const element = _element;
              rulers.push({
                column: EditorIntOption.clampedInt(element.column, 0, 0, 1e4),
                color: element.color
              });
            }
          }
          rulers.sort((a, b) => a.column - b.column);
          return rulers;
        }
        return this.defaultValue;
      }
    };
    ReadonlyMessage = class extends BaseEditorOption {
      constructor() {
        const defaults = void 0;
        super(90, "readOnlyMessage", defaults);
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        return _input;
      }
    };
    EditorScrollbar = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          vertical: 1,
          horizontal: 1,
          arrowSize: 11,
          useShadows: true,
          verticalHasArrows: false,
          horizontalHasArrows: false,
          horizontalScrollbarSize: 12,
          horizontalSliderSize: 12,
          verticalScrollbarSize: 14,
          verticalSliderSize: 14,
          handleMouseWheel: true,
          alwaysConsumeMouseWheel: true,
          scrollByPage: false
        };
        super(101, "scrollbar", defaults, {
          "editor.scrollbar.vertical": {
            type: "string",
            enum: ["auto", "visible", "hidden"],
            enumDescriptions: [
              localize("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
              localize("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
              localize("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
            ],
            default: "auto",
            description: localize("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
          },
          "editor.scrollbar.horizontal": {
            type: "string",
            enum: ["auto", "visible", "hidden"],
            enumDescriptions: [
              localize("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
              localize("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
              localize("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
            ],
            default: "auto",
            description: localize("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
          },
          "editor.scrollbar.verticalScrollbarSize": {
            type: "number",
            default: defaults.verticalScrollbarSize,
            description: localize("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
          },
          "editor.scrollbar.horizontalScrollbarSize": {
            type: "number",
            default: defaults.horizontalScrollbarSize,
            description: localize("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
          },
          "editor.scrollbar.scrollByPage": {
            type: "boolean",
            default: defaults.scrollByPage,
            description: localize("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3);
        const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
        return {
          arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
          vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),
          horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),
          useShadows: boolean(input.useShadows, this.defaultValue.useShadows),
          verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),
          horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
          handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),
          alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
          horizontalScrollbarSize,
          horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1e3),
          verticalScrollbarSize,
          verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1e3),
          scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage)
        };
      }
    };
    inUntrustedWorkspace = "inUntrustedWorkspace";
    unicodeHighlightConfigKeys = {
      allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
      invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
      nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
      ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
      includeComments: "editor.unicodeHighlight.includeComments",
      includeStrings: "editor.unicodeHighlight.includeStrings",
      allowedLocales: "editor.unicodeHighlight.allowedLocales"
    };
    UnicodeHighlight = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          nonBasicASCII: inUntrustedWorkspace,
          invisibleCharacters: true,
          ambiguousCharacters: true,
          includeComments: inUntrustedWorkspace,
          includeStrings: true,
          allowedCharacters: {},
          allowedLocales: { _os: true, _vscode: true }
        };
        super(123, "unicodeHighlight", defaults, {
          [unicodeHighlightConfigKeys.nonBasicASCII]: {
            restricted: true,
            type: ["boolean", "string"],
            enum: [true, false, inUntrustedWorkspace],
            default: defaults.nonBasicASCII,
            description: localize("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
          },
          [unicodeHighlightConfigKeys.invisibleCharacters]: {
            restricted: true,
            type: "boolean",
            default: defaults.invisibleCharacters,
            description: localize("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
          },
          [unicodeHighlightConfigKeys.ambiguousCharacters]: {
            restricted: true,
            type: "boolean",
            default: defaults.ambiguousCharacters,
            description: localize("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
          },
          [unicodeHighlightConfigKeys.includeComments]: {
            restricted: true,
            type: ["boolean", "string"],
            enum: [true, false, inUntrustedWorkspace],
            default: defaults.includeComments,
            description: localize("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to Unicode highlighting.")
          },
          [unicodeHighlightConfigKeys.includeStrings]: {
            restricted: true,
            type: ["boolean", "string"],
            enum: [true, false, inUntrustedWorkspace],
            default: defaults.includeStrings,
            description: localize("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to Unicode highlighting.")
          },
          [unicodeHighlightConfigKeys.allowedCharacters]: {
            restricted: true,
            type: "object",
            default: defaults.allowedCharacters,
            description: localize("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
            additionalProperties: {
              type: "boolean"
            }
          },
          [unicodeHighlightConfigKeys.allowedLocales]: {
            restricted: true,
            type: "object",
            additionalProperties: {
              type: "boolean"
            },
            default: defaults.allowedLocales,
            description: localize("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
          }
        });
      }
      applyUpdate(value, update) {
        let didChange = false;
        if (update.allowedCharacters && value) {
          if (!equals2(value.allowedCharacters, update.allowedCharacters)) {
            value = Object.assign(Object.assign({}, value), { allowedCharacters: update.allowedCharacters });
            didChange = true;
          }
        }
        if (update.allowedLocales && value) {
          if (!equals2(value.allowedLocales, update.allowedLocales)) {
            value = Object.assign(Object.assign({}, value), { allowedLocales: update.allowedLocales });
            didChange = true;
          }
        }
        const result = super.applyUpdate(value, update);
        if (didChange) {
          return new ApplyUpdateResult(result.newValue, true);
        }
        return result;
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          nonBasicASCII: primitiveSet(input.nonBasicASCII, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
          invisibleCharacters: boolean(input.invisibleCharacters, this.defaultValue.invisibleCharacters),
          ambiguousCharacters: boolean(input.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
          includeComments: primitiveSet(input.includeComments, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
          includeStrings: primitiveSet(input.includeStrings, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
          allowedCharacters: this.validateBooleanMap(_input.allowedCharacters, this.defaultValue.allowedCharacters),
          allowedLocales: this.validateBooleanMap(_input.allowedLocales, this.defaultValue.allowedLocales)
        };
      }
      validateBooleanMap(map, defaultValue) {
        if (typeof map !== "object" || !map) {
          return defaultValue;
        }
        const result = {};
        for (const [key, value] of Object.entries(map)) {
          if (value === true) {
            result[key] = true;
          }
        }
        return result;
      }
    };
    InlineEditorSuggest = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          enabled: true,
          mode: "subwordSmart",
          showToolbar: "onHover",
          suppressSuggestions: false,
          keepOnBlur: false
        };
        super(61, "inlineSuggest", defaults, {
          "editor.inlineSuggest.enabled": {
            type: "boolean",
            default: defaults.enabled,
            description: localize("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
          },
          "editor.inlineSuggest.showToolbar": {
            type: "string",
            default: defaults.showToolbar,
            enum: ["always", "onHover"],
            enumDescriptions: [
              localize("inlineSuggest.showToolbar.always", "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
              localize("inlineSuggest.showToolbar.onHover", "Show the inline suggestion toolbar when hovering over an inline suggestion.")
            ],
            description: localize("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar.")
          },
          "editor.inlineSuggest.suppressSuggestions": {
            type: "boolean",
            default: defaults.suppressSuggestions,
            description: localize("inlineSuggest.suppressSuggestions", "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          enabled: boolean(input.enabled, this.defaultValue.enabled),
          mode: stringSet(input.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
          showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ["always", "onHover"]),
          suppressSuggestions: boolean(input.suppressSuggestions, this.defaultValue.suppressSuggestions),
          keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur)
        };
      }
    };
    BracketPairColorization = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          enabled: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.enabled,
          independentColorPoolPerBracketType: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.independentColorPoolPerBracketType
        };
        super(14, "bracketPairColorization", defaults, {
          "editor.bracketPairColorization.enabled": {
            type: "boolean",
            default: defaults.enabled,
            markdownDescription: localize("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", "`#workbench.colorCustomizations#`")
          },
          "editor.bracketPairColorization.independentColorPoolPerBracketType": {
            type: "boolean",
            default: defaults.independentColorPoolPerBracketType,
            description: localize("bracketPairColorization.independentColorPoolPerBracketType", "Controls whether each bracket type has its own independent color pool.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          enabled: boolean(input.enabled, this.defaultValue.enabled),
          independentColorPoolPerBracketType: boolean(input.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
        };
      }
    };
    GuideOptions = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          bracketPairs: false,
          bracketPairsHorizontal: "active",
          highlightActiveBracketPair: true,
          indentation: true,
          highlightActiveIndentation: true
        };
        super(15, "guides", defaults, {
          "editor.guides.bracketPairs": {
            type: ["boolean", "string"],
            enum: [true, "active", false],
            enumDescriptions: [
              localize("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
              localize("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
              localize("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
            ],
            default: defaults.bracketPairs,
            description: localize("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
          },
          "editor.guides.bracketPairsHorizontal": {
            type: ["boolean", "string"],
            enum: [true, "active", false],
            enumDescriptions: [
              localize("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
              localize("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
              localize("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
            ],
            default: defaults.bracketPairsHorizontal,
            description: localize("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
          },
          "editor.guides.highlightActiveBracketPair": {
            type: "boolean",
            default: defaults.highlightActiveBracketPair,
            description: localize("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
          },
          "editor.guides.indentation": {
            type: "boolean",
            default: defaults.indentation,
            description: localize("editor.guides.indentation", "Controls whether the editor should render indent guides.")
          },
          "editor.guides.highlightActiveIndentation": {
            type: ["boolean", "string"],
            enum: [true, "always", false],
            enumDescriptions: [
              localize("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
              localize("editor.guides.highlightActiveIndentation.always", "Highlights the active indent guide even if bracket guides are highlighted."),
              localize("editor.guides.highlightActiveIndentation.false", "Do not highlight the active indent guide.")
            ],
            default: defaults.highlightActiveIndentation,
            description: localize("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          bracketPairs: primitiveSet(input.bracketPairs, this.defaultValue.bracketPairs, [true, false, "active"]),
          bracketPairsHorizontal: primitiveSet(input.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [true, false, "active"]),
          highlightActiveBracketPair: boolean(input.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
          indentation: boolean(input.indentation, this.defaultValue.indentation),
          highlightActiveIndentation: primitiveSet(input.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [true, false, "always"])
        };
      }
    };
    EditorSuggest = class extends BaseEditorOption {
      constructor() {
        const defaults = {
          insertMode: "insert",
          filterGraceful: true,
          snippetsPreventQuickSuggestions: false,
          localityBonus: false,
          shareSuggestSelections: false,
          selectionMode: "always",
          showIcons: true,
          showStatusBar: false,
          preview: false,
          previewMode: "subwordSmart",
          showInlineDetails: true,
          showMethods: true,
          showFunctions: true,
          showConstructors: true,
          showDeprecated: true,
          matchOnWordStartOnly: true,
          showFields: true,
          showVariables: true,
          showClasses: true,
          showStructs: true,
          showInterfaces: true,
          showModules: true,
          showProperties: true,
          showEvents: true,
          showOperators: true,
          showUnits: true,
          showValues: true,
          showConstants: true,
          showEnums: true,
          showEnumMembers: true,
          showKeywords: true,
          showWords: true,
          showColors: true,
          showFiles: true,
          showReferences: true,
          showFolders: true,
          showTypeParameters: true,
          showSnippets: true,
          showUsers: true,
          showIssues: true
        };
        super(116, "suggest", defaults, {
          "editor.suggest.insertMode": {
            type: "string",
            enum: ["insert", "replace"],
            enumDescriptions: [
              localize("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
              localize("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
            ],
            default: defaults.insertMode,
            description: localize("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
          },
          "editor.suggest.filterGraceful": {
            type: "boolean",
            default: defaults.filterGraceful,
            description: localize("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
          },
          "editor.suggest.localityBonus": {
            type: "boolean",
            default: defaults.localityBonus,
            description: localize("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
          },
          "editor.suggest.shareSuggestSelections": {
            type: "boolean",
            default: defaults.shareSuggestSelections,
            markdownDescription: localize("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
          },
          "editor.suggest.selectionMode": {
            type: "string",
            enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
            enumDescriptions: [
              localize("suggest.insertMode.always", "Always select a suggestion when automatically triggering IntelliSense."),
              localize("suggest.insertMode.never", "Never select a suggestion when automatically triggering IntelliSense."),
              localize("suggest.insertMode.whenTriggerCharacter", "Select a suggestion only when triggering IntelliSense from a trigger character."),
              localize("suggest.insertMode.whenQuickSuggestion", "Select a suggestion only when triggering IntelliSense as you type.")
            ],
            default: defaults.selectionMode,
            markdownDescription: localize("suggest.selectionMode", "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions (`#editor.quickSuggestions#` and `#editor.suggestOnTriggerCharacters#`) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.")
          },
          "editor.suggest.snippetsPreventQuickSuggestions": {
            type: "boolean",
            default: defaults.snippetsPreventQuickSuggestions,
            description: localize("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
          },
          "editor.suggest.showIcons": {
            type: "boolean",
            default: defaults.showIcons,
            description: localize("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
          },
          "editor.suggest.showStatusBar": {
            type: "boolean",
            default: defaults.showStatusBar,
            description: localize("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
          },
          "editor.suggest.preview": {
            type: "boolean",
            default: defaults.preview,
            description: localize("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
          },
          "editor.suggest.showInlineDetails": {
            type: "boolean",
            default: defaults.showInlineDetails,
            description: localize("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget.")
          },
          "editor.suggest.maxVisibleSuggestions": {
            type: "number",
            deprecationMessage: localize("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
          },
          "editor.suggest.filteredTypes": {
            type: "object",
            deprecationMessage: localize("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
          },
          "editor.suggest.showMethods": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
          },
          "editor.suggest.showFunctions": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
          },
          "editor.suggest.showConstructors": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
          },
          "editor.suggest.showDeprecated": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
          },
          "editor.suggest.matchOnWordStartOnly": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.matchOnWordStartOnly", "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
          },
          "editor.suggest.showFields": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
          },
          "editor.suggest.showVariables": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
          },
          "editor.suggest.showClasses": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
          },
          "editor.suggest.showStructs": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
          },
          "editor.suggest.showInterfaces": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
          },
          "editor.suggest.showModules": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
          },
          "editor.suggest.showProperties": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
          },
          "editor.suggest.showEvents": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
          },
          "editor.suggest.showOperators": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
          },
          "editor.suggest.showUnits": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
          },
          "editor.suggest.showValues": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
          },
          "editor.suggest.showConstants": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
          },
          "editor.suggest.showEnums": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
          },
          "editor.suggest.showEnumMembers": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
          },
          "editor.suggest.showKeywords": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
          },
          "editor.suggest.showWords": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
          },
          "editor.suggest.showColors": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
          },
          "editor.suggest.showFiles": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
          },
          "editor.suggest.showReferences": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
          },
          "editor.suggest.showCustomcolors": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
          },
          "editor.suggest.showFolders": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
          },
          "editor.suggest.showTypeParameters": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
          },
          "editor.suggest.showSnippets": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
          },
          "editor.suggest.showUsers": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
          },
          "editor.suggest.showIssues": {
            type: "boolean",
            default: true,
            markdownDescription: localize("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
          filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),
          snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
          localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),
          shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
          selectionMode: stringSet(input.selectionMode, this.defaultValue.selectionMode, ["always", "never", "whenQuickSuggestion", "whenTriggerCharacter"]),
          showIcons: boolean(input.showIcons, this.defaultValue.showIcons),
          showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),
          preview: boolean(input.preview, this.defaultValue.preview),
          previewMode: stringSet(input.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
          showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),
          showMethods: boolean(input.showMethods, this.defaultValue.showMethods),
          showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),
          showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),
          showDeprecated: boolean(input.showDeprecated, this.defaultValue.showDeprecated),
          matchOnWordStartOnly: boolean(input.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
          showFields: boolean(input.showFields, this.defaultValue.showFields),
          showVariables: boolean(input.showVariables, this.defaultValue.showVariables),
          showClasses: boolean(input.showClasses, this.defaultValue.showClasses),
          showStructs: boolean(input.showStructs, this.defaultValue.showStructs),
          showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),
          showModules: boolean(input.showModules, this.defaultValue.showModules),
          showProperties: boolean(input.showProperties, this.defaultValue.showProperties),
          showEvents: boolean(input.showEvents, this.defaultValue.showEvents),
          showOperators: boolean(input.showOperators, this.defaultValue.showOperators),
          showUnits: boolean(input.showUnits, this.defaultValue.showUnits),
          showValues: boolean(input.showValues, this.defaultValue.showValues),
          showConstants: boolean(input.showConstants, this.defaultValue.showConstants),
          showEnums: boolean(input.showEnums, this.defaultValue.showEnums),
          showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),
          showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),
          showWords: boolean(input.showWords, this.defaultValue.showWords),
          showColors: boolean(input.showColors, this.defaultValue.showColors),
          showFiles: boolean(input.showFiles, this.defaultValue.showFiles),
          showReferences: boolean(input.showReferences, this.defaultValue.showReferences),
          showFolders: boolean(input.showFolders, this.defaultValue.showFolders),
          showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),
          showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),
          showUsers: boolean(input.showUsers, this.defaultValue.showUsers),
          showIssues: boolean(input.showIssues, this.defaultValue.showIssues)
        };
      }
    };
    SmartSelect = class extends BaseEditorOption {
      constructor() {
        super(111, "smartSelect", {
          selectLeadingAndTrailingWhitespace: true,
          selectSubwords: true
        }, {
          "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
            description: localize("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
            default: true,
            type: "boolean"
          },
          "editor.smartSelect.selectSubwords": {
            description: localize("selectSubwords", "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
            default: true,
            type: "boolean"
          }
        });
      }
      validate(input) {
        if (!input || typeof input !== "object") {
          return this.defaultValue;
        }
        return {
          selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
          selectSubwords: boolean(input.selectSubwords, this.defaultValue.selectSubwords)
        };
      }
    };
    WrappingIndentOption = class extends BaseEditorOption {
      constructor() {
        super(135, "wrappingIndent", 1, {
          "editor.wrappingIndent": {
            type: "string",
            enum: ["none", "same", "indent", "deepIndent"],
            enumDescriptions: [
              localize("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
              localize("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
              localize("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
              localize("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
            ],
            description: localize("wrappingIndent", "Controls the indentation of wrapped lines."),
            default: "same"
          }
        });
      }
      validate(input) {
        switch (input) {
          case "none":
            return 0;
          case "same":
            return 1;
          case "indent":
            return 2;
          case "deepIndent":
            return 3;
        }
        return 1;
      }
      compute(env2, options, value) {
        const accessibilitySupport = options.get(
          2
          /* EditorOption.accessibilitySupport */
        );
        if (accessibilitySupport === 2) {
          return 0;
        }
        return value;
      }
    };
    EditorWrappingInfoComputer = class extends ComputedEditorOption {
      constructor() {
        super(
          143
          /* EditorOption.wrappingInfo */
        );
      }
      compute(env2, options, _) {
        const layoutInfo = options.get(
          142
          /* EditorOption.layoutInfo */
        );
        return {
          isDominatedByLongLines: env2.isDominatedByLongLines,
          isWordWrapMinified: layoutInfo.isWordWrapMinified,
          isViewportWrapping: layoutInfo.isViewportWrapping,
          wrappingColumn: layoutInfo.wrappingColumn
        };
      }
    };
    EditorDropIntoEditor = class extends BaseEditorOption {
      constructor() {
        const defaults = { enabled: true, showDropSelector: "afterDrop" };
        super(35, "dropIntoEditor", defaults, {
          "editor.dropIntoEditor.enabled": {
            type: "boolean",
            default: defaults.enabled,
            markdownDescription: localize("dropIntoEditor.enabled", "Controls whether you can drag and drop a file into a text editor by holding down `shift` (instead of opening the file in an editor).")
          },
          "editor.dropIntoEditor.showDropSelector": {
            type: "string",
            markdownDescription: localize("dropIntoEditor.showDropSelector", "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
            enum: [
              "afterDrop",
              "never"
            ],
            enumDescriptions: [
              localize("dropIntoEditor.showDropSelector.afterDrop", "Show the drop selector widget after a file is dropped into the editor."),
              localize("dropIntoEditor.showDropSelector.never", "Never show the drop selector widget. Instead the default drop provider is always used.")
            ],
            default: "afterDrop"
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          enabled: boolean(input.enabled, this.defaultValue.enabled),
          showDropSelector: stringSet(input.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"])
        };
      }
    };
    EditorPasteAs = class extends BaseEditorOption {
      constructor() {
        const defaults = { enabled: true, showPasteSelector: "afterPaste" };
        super(83, "pasteAs", defaults, {
          "editor.pasteAs.enabled": {
            type: "boolean",
            default: defaults.enabled,
            markdownDescription: localize("pasteAs.enabled", "Controls whether you can paste content in different ways.")
          },
          "editor.pasteAs.showPasteSelector": {
            type: "string",
            markdownDescription: localize("pasteAs.showPasteSelector", "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
            enum: [
              "afterPaste",
              "never"
            ],
            enumDescriptions: [
              localize("pasteAs.showPasteSelector.afterPaste", "Show the paste selector widget after content is pasted into the editor."),
              localize("pasteAs.showPasteSelector.never", "Never show the paste selector widget. Instead the default pasting behavior is always used.")
            ],
            default: "afterPaste"
          }
        });
      }
      validate(_input) {
        if (!_input || typeof _input !== "object") {
          return this.defaultValue;
        }
        const input = _input;
        return {
          enabled: boolean(input.enabled, this.defaultValue.enabled),
          showPasteSelector: stringSet(input.showPasteSelector, this.defaultValue.showPasteSelector, ["afterPaste", "never"])
        };
      }
    };
    DEFAULT_WINDOWS_FONT_FAMILY = "Consolas, 'Courier New', monospace";
    DEFAULT_MAC_FONT_FAMILY = "Menlo, Monaco, 'Courier New', monospace";
    DEFAULT_LINUX_FONT_FAMILY = "'Droid Sans Mono', 'monospace', monospace";
    EDITOR_FONT_DEFAULTS = {
      fontFamily: isMacintosh ? DEFAULT_MAC_FONT_FAMILY : isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY,
      fontWeight: "normal",
      fontSize: isMacintosh ? 12 : 14,
      lineHeight: 0,
      letterSpacing: 0
    };
    editorOptionsRegistry = [];
    EditorOptions = {
      acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(0, "acceptSuggestionOnCommitCharacter", true, { markdownDescription: localize("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
      acceptSuggestionOnEnter: register(new EditorStringEnumOption(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
        markdownEnumDescriptions: [
          "",
          localize("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
          ""
        ],
        markdownDescription: localize("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
      })),
      accessibilitySupport: register(new EditorAccessibilitySupport()),
      accessibilityPageSize: register(new EditorIntOption(3, "accessibilityPageSize", 10, 1, 1073741824, {
        description: localize("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
        tags: ["accessibility"]
      })),
      ariaLabel: register(new EditorStringOption(4, "ariaLabel", localize("editorViewAccessibleLabel", "Editor content"))),
      ariaRequired: register(new EditorBooleanOption(5, "ariaRequired", false, void 0)),
      screenReaderAnnounceInlineSuggestion: register(new EditorBooleanOption(7, "screenReaderAnnounceInlineSuggestion", true, {
        description: localize("screenReaderAnnounceInlineSuggestion", "Control whether inline suggestions are announced by a screen reader."),
        tags: ["accessibility"]
      })),
      autoClosingBrackets: register(new EditorStringEnumOption(6, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
        enumDescriptions: [
          "",
          localize("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
          localize("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
          ""
        ],
        description: localize("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
      })),
      autoClosingDelete: register(new EditorStringEnumOption(8, "autoClosingDelete", "auto", ["always", "auto", "never"], {
        enumDescriptions: [
          "",
          localize("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
          ""
        ],
        description: localize("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
      })),
      autoClosingOvertype: register(new EditorStringEnumOption(9, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
        enumDescriptions: [
          "",
          localize("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
          ""
        ],
        description: localize("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
      })),
      autoClosingQuotes: register(new EditorStringEnumOption(10, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
        enumDescriptions: [
          "",
          localize("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
          localize("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
          ""
        ],
        description: localize("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
      })),
      autoIndent: register(new EditorEnumOption(11, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], _autoIndentFromString, {
        enumDescriptions: [
          localize("editor.autoIndent.none", "The editor will not insert indentation automatically."),
          localize("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
          localize("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
          localize("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
          localize("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
        ],
        description: localize("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
      })),
      automaticLayout: register(new EditorBooleanOption(12, "automaticLayout", false)),
      autoSurround: register(new EditorStringEnumOption(13, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
        enumDescriptions: [
          localize("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
          localize("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
          localize("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
          ""
        ],
        description: localize("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
      })),
      bracketPairColorization: register(new BracketPairColorization()),
      bracketPairGuides: register(new GuideOptions()),
      stickyTabStops: register(new EditorBooleanOption(114, "stickyTabStops", false, { description: localize("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
      codeLens: register(new EditorBooleanOption(16, "codeLens", true, { description: localize("codeLens", "Controls whether the editor shows CodeLens.") })),
      codeLensFontFamily: register(new EditorStringOption(17, "codeLensFontFamily", "", { description: localize("codeLensFontFamily", "Controls the font family for CodeLens.") })),
      codeLensFontSize: register(new EditorIntOption(18, "codeLensFontSize", 0, 0, 100, {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 100,
        markdownDescription: localize("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
      })),
      colorDecorators: register(new EditorBooleanOption(19, "colorDecorators", true, { description: localize("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
      colorDecoratorActivatedOn: register(new EditorStringEnumOption(145, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
        enumDescriptions: [
          localize("editor.colorDecoratorActivatedOn.clickAndHover", "Make the color picker appear both on click and hover of the color decorator"),
          localize("editor.colorDecoratorActivatedOn.hover", "Make the color picker appear on hover of the color decorator"),
          localize("editor.colorDecoratorActivatedOn.click", "Make the color picker appear on click of the color decorator")
        ],
        description: localize("colorDecoratorActivatedOn", "Controls the condition to make a color picker appear from a color decorator")
      })),
      colorDecoratorsLimit: register(new EditorIntOption(20, "colorDecoratorsLimit", 500, 1, 1e6, {
        markdownDescription: localize("colorDecoratorsLimit", "Controls the max number of color decorators that can be rendered in an editor at once.")
      })),
      columnSelection: register(new EditorBooleanOption(21, "columnSelection", false, { description: localize("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
      comments: register(new EditorComments()),
      contextmenu: register(new EditorBooleanOption(23, "contextmenu", true)),
      copyWithSyntaxHighlighting: register(new EditorBooleanOption(24, "copyWithSyntaxHighlighting", true, { description: localize("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
      cursorBlinking: register(new EditorEnumOption(25, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], _cursorBlinkingStyleFromString, { description: localize("cursorBlinking", "Control the cursor animation style.") })),
      cursorSmoothCaretAnimation: register(new EditorStringEnumOption(26, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
        enumDescriptions: [
          localize("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
          localize("cursorSmoothCaretAnimation.explicit", "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
          localize("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled.")
        ],
        description: localize("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.")
      })),
      cursorStyle: register(new EditorEnumOption(27, "cursorStyle", TextEditorCursorStyle.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], _cursorStyleFromString, { description: localize("cursorStyle", "Controls the cursor style.") })),
      cursorSurroundingLines: register(new EditorIntOption(28, "cursorSurroundingLines", 0, 0, 1073741824, { description: localize("cursorSurroundingLines", "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
      cursorSurroundingLinesStyle: register(new EditorStringEnumOption(29, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
        enumDescriptions: [
          localize("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
          localize("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
        ],
        description: localize("cursorSurroundingLinesStyle", "Controls when `cursorSurroundingLines` should be enforced.")
      })),
      cursorWidth: register(new EditorIntOption(30, "cursorWidth", 0, 0, 1073741824, { markdownDescription: localize("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
      disableLayerHinting: register(new EditorBooleanOption(31, "disableLayerHinting", false)),
      disableMonospaceOptimizations: register(new EditorBooleanOption(32, "disableMonospaceOptimizations", false)),
      domReadOnly: register(new EditorBooleanOption(33, "domReadOnly", false)),
      dragAndDrop: register(new EditorBooleanOption(34, "dragAndDrop", true, { description: localize("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
      emptySelectionClipboard: register(new EditorEmptySelectionClipboard()),
      dropIntoEditor: register(new EditorDropIntoEditor()),
      stickyScroll: register(new EditorStickyScroll()),
      experimentalWhitespaceRendering: register(new EditorStringEnumOption(37, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
        enumDescriptions: [
          localize("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
          localize("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
          localize("experimentalWhitespaceRendering.off", "Use the stable rendering method.")
        ],
        description: localize("experimentalWhitespaceRendering", "Controls whether whitespace is rendered with a new, experimental method.")
      })),
      extraEditorClassName: register(new EditorStringOption(38, "extraEditorClassName", "")),
      fastScrollSensitivity: register(new EditorFloatOption(39, "fastScrollSensitivity", 5, (x) => x <= 0 ? 5 : x, { markdownDescription: localize("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
      find: register(new EditorFind()),
      fixedOverflowWidgets: register(new EditorBooleanOption(41, "fixedOverflowWidgets", false)),
      folding: register(new EditorBooleanOption(42, "folding", true, { description: localize("folding", "Controls whether the editor has code folding enabled.") })),
      foldingStrategy: register(new EditorStringEnumOption(43, "foldingStrategy", "auto", ["auto", "indentation"], {
        enumDescriptions: [
          localize("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
          localize("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
        ],
        description: localize("foldingStrategy", "Controls the strategy for computing folding ranges.")
      })),
      foldingHighlight: register(new EditorBooleanOption(44, "foldingHighlight", true, { description: localize("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
      foldingImportsByDefault: register(new EditorBooleanOption(45, "foldingImportsByDefault", false, { description: localize("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.") })),
      foldingMaximumRegions: register(new EditorIntOption(
        46,
        "foldingMaximumRegions",
        5e3,
        10,
        65e3,
        // limit must be less than foldingRanges MAX_FOLDING_REGIONS
        { description: localize("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") }
      )),
      unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(47, "unfoldOnClickAfterEndOfLine", false, { description: localize("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
      fontFamily: register(new EditorStringOption(48, "fontFamily", EDITOR_FONT_DEFAULTS.fontFamily, { description: localize("fontFamily", "Controls the font family.") })),
      fontInfo: register(new EditorFontInfo()),
      fontLigatures2: register(new EditorFontLigatures()),
      fontSize: register(new EditorFontSize()),
      fontWeight: register(new EditorFontWeight()),
      fontVariations: register(new EditorFontVariations()),
      formatOnPaste: register(new EditorBooleanOption(54, "formatOnPaste", false, { description: localize("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
      formatOnType: register(new EditorBooleanOption(55, "formatOnType", false, { description: localize("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
      glyphMargin: register(new EditorBooleanOption(56, "glyphMargin", true, { description: localize("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
      gotoLocation: register(new EditorGoToLocation()),
      hideCursorInOverviewRuler: register(new EditorBooleanOption(58, "hideCursorInOverviewRuler", false, { description: localize("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
      hover: register(new EditorHover()),
      inDiffEditor: register(new EditorBooleanOption(60, "inDiffEditor", false)),
      letterSpacing: register(new EditorFloatOption(62, "letterSpacing", EDITOR_FONT_DEFAULTS.letterSpacing, (x) => EditorFloatOption.clamp(x, -5, 20), { description: localize("letterSpacing", "Controls the letter spacing in pixels.") })),
      lightbulb: register(new EditorLightbulb()),
      lineDecorationsWidth: register(new EditorLineDecorationsWidth()),
      lineHeight: register(new EditorLineHeight()),
      lineNumbers: register(new EditorRenderLineNumbersOption()),
      lineNumbersMinChars: register(new EditorIntOption(67, "lineNumbersMinChars", 5, 1, 300)),
      linkedEditing: register(new EditorBooleanOption(68, "linkedEditing", false, { description: localize("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.") })),
      links: register(new EditorBooleanOption(69, "links", true, { description: localize("links", "Controls whether the editor should detect links and make them clickable.") })),
      matchBrackets: register(new EditorStringEnumOption(70, "matchBrackets", "always", ["always", "near", "never"], { description: localize("matchBrackets", "Highlight matching brackets.") })),
      minimap: register(new EditorMinimap()),
      mouseStyle: register(new EditorStringEnumOption(72, "mouseStyle", "text", ["text", "default", "copy"])),
      mouseWheelScrollSensitivity: register(new EditorFloatOption(73, "mouseWheelScrollSensitivity", 1, (x) => x === 0 ? 1 : x, { markdownDescription: localize("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
      mouseWheelZoom: register(new EditorBooleanOption(74, "mouseWheelZoom", false, { markdownDescription: localize("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.") })),
      multiCursorMergeOverlapping: register(new EditorBooleanOption(75, "multiCursorMergeOverlapping", true, { description: localize("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
      multiCursorModifier: register(new EditorEnumOption(76, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], _multiCursorModifierFromString, {
        markdownEnumDescriptions: [
          localize("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
          localize("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
        ],
        markdownDescription: localize({
          key: "multiCursorModifier",
          comment: [
            "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
            "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
          ]
        }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
      })),
      multiCursorPaste: register(new EditorStringEnumOption(77, "multiCursorPaste", "spread", ["spread", "full"], {
        markdownEnumDescriptions: [
          localize("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
          localize("multiCursorPaste.full", "Each cursor pastes the full text.")
        ],
        markdownDescription: localize("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
      })),
      multiCursorLimit: register(new EditorIntOption(78, "multiCursorLimit", 1e4, 1, 1e5, {
        markdownDescription: localize("multiCursorLimit", "Controls the max number of cursors that can be in an active editor at once.")
      })),
      occurrencesHighlight: register(new EditorBooleanOption(79, "occurrencesHighlight", true, { description: localize("occurrencesHighlight", "Controls whether the editor should highlight semantic symbol occurrences.") })),
      overviewRulerBorder: register(new EditorBooleanOption(80, "overviewRulerBorder", true, { description: localize("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
      overviewRulerLanes: register(new EditorIntOption(81, "overviewRulerLanes", 3, 0, 3)),
      padding: register(new EditorPadding()),
      pasteAs: register(new EditorPasteAs()),
      parameterHints: register(new EditorParameterHints()),
      peekWidgetDefaultFocus: register(new EditorStringEnumOption(85, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
        enumDescriptions: [
          localize("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
          localize("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
        ],
        description: localize("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
      })),
      definitionLinkOpensInPeek: register(new EditorBooleanOption(86, "definitionLinkOpensInPeek", false, { description: localize("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
      quickSuggestions: register(new EditorQuickSuggestions()),
      quickSuggestionsDelay: register(new EditorIntOption(88, "quickSuggestionsDelay", 10, 0, 1073741824, { description: localize("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
      readOnly: register(new EditorBooleanOption(89, "readOnly", false)),
      readOnlyMessage: register(new ReadonlyMessage()),
      renameOnType: register(new EditorBooleanOption(91, "renameOnType", false, { description: localize("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: localize("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
      renderControlCharacters: register(new EditorBooleanOption(92, "renderControlCharacters", true, { description: localize("renderControlCharacters", "Controls whether the editor should render control characters."), restricted: true })),
      renderFinalNewline: register(new EditorStringEnumOption(93, "renderFinalNewline", isLinux ? "dimmed" : "on", ["off", "on", "dimmed"], { description: localize("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
      renderLineHighlight: register(new EditorStringEnumOption(94, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
        enumDescriptions: [
          "",
          "",
          "",
          localize("renderLineHighlight.all", "Highlights both the gutter and the current line.")
        ],
        description: localize("renderLineHighlight", "Controls how the editor should render the current line highlight.")
      })),
      renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(95, "renderLineHighlightOnlyWhenFocus", false, { description: localize("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
      renderValidationDecorations: register(new EditorStringEnumOption(96, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
      renderWhitespace: register(new EditorStringEnumOption(97, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
        enumDescriptions: [
          "",
          localize("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
          localize("renderWhitespace.selection", "Render whitespace characters only on selected text."),
          localize("renderWhitespace.trailing", "Render only trailing whitespace characters."),
          ""
        ],
        description: localize("renderWhitespace", "Controls how the editor should render whitespace characters.")
      })),
      revealHorizontalRightPadding: register(new EditorIntOption(98, "revealHorizontalRightPadding", 15, 0, 1e3)),
      roundedSelection: register(new EditorBooleanOption(99, "roundedSelection", true, { description: localize("roundedSelection", "Controls whether selections should have rounded corners.") })),
      rulers: register(new EditorRulers()),
      scrollbar: register(new EditorScrollbar()),
      scrollBeyondLastColumn: register(new EditorIntOption(102, "scrollBeyondLastColumn", 4, 0, 1073741824, { description: localize("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
      scrollBeyondLastLine: register(new EditorBooleanOption(103, "scrollBeyondLastLine", true, { description: localize("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
      scrollPredominantAxis: register(new EditorBooleanOption(104, "scrollPredominantAxis", true, { description: localize("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
      selectionClipboard: register(new EditorBooleanOption(105, "selectionClipboard", true, {
        description: localize("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
        included: isLinux
      })),
      selectionHighlight: register(new EditorBooleanOption(106, "selectionHighlight", true, { description: localize("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
      selectOnLineNumbers: register(new EditorBooleanOption(107, "selectOnLineNumbers", true)),
      showFoldingControls: register(new EditorStringEnumOption(108, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
        enumDescriptions: [
          localize("showFoldingControls.always", "Always show the folding controls."),
          localize("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
          localize("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
        ],
        description: localize("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
      })),
      showUnused: register(new EditorBooleanOption(109, "showUnused", true, { description: localize("showUnused", "Controls fading out of unused code.") })),
      showDeprecated: register(new EditorBooleanOption(137, "showDeprecated", true, { description: localize("showDeprecated", "Controls strikethrough deprecated variables.") })),
      inlayHints: register(new EditorInlayHints()),
      snippetSuggestions: register(new EditorStringEnumOption(110, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
        enumDescriptions: [
          localize("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
          localize("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
          localize("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
          localize("snippetSuggestions.none", "Do not show snippet suggestions.")
        ],
        description: localize("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
      })),
      smartSelect: register(new SmartSelect()),
      smoothScrolling: register(new EditorBooleanOption(112, "smoothScrolling", false, { description: localize("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
      stopRenderingLineAfter: register(new EditorIntOption(
        115,
        "stopRenderingLineAfter",
        1e4,
        -1,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      )),
      suggest: register(new EditorSuggest()),
      inlineSuggest: register(new InlineEditorSuggest()),
      inlineCompletionsAccessibilityVerbose: register(new EditorBooleanOption(146, "inlineCompletionsAccessibilityVerbose", false, { description: localize("inlineCompletionsAccessibilityVerbose", "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.") })),
      suggestFontSize: register(new EditorIntOption(117, "suggestFontSize", 0, 0, 1e3, { markdownDescription: localize("suggestFontSize", "Font size for the suggest widget. When set to {0}, the value of {1} is used.", "`0`", "`#editor.fontSize#`") })),
      suggestLineHeight: register(new EditorIntOption(118, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: localize("suggestLineHeight", "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", "`0`", "`#editor.lineHeight#`") })),
      suggestOnTriggerCharacters: register(new EditorBooleanOption(119, "suggestOnTriggerCharacters", true, { description: localize("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
      suggestSelection: register(new EditorStringEnumOption(120, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
        markdownEnumDescriptions: [
          localize("suggestSelection.first", "Always select the first suggestion."),
          localize("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
          localize("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
        ],
        description: localize("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
      })),
      tabCompletion: register(new EditorStringEnumOption(121, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
        enumDescriptions: [
          localize("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
          localize("tabCompletion.off", "Disable tab completions."),
          localize("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
        ],
        description: localize("tabCompletion", "Enables tab completions.")
      })),
      tabIndex: register(new EditorIntOption(
        122,
        "tabIndex",
        0,
        -1,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      )),
      unicodeHighlight: register(new UnicodeHighlight()),
      unusualLineTerminators: register(new EditorStringEnumOption(124, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
        enumDescriptions: [
          localize("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
          localize("unusualLineTerminators.off", "Unusual line terminators are ignored."),
          localize("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
        ],
        description: localize("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
      })),
      useShadowDOM: register(new EditorBooleanOption(125, "useShadowDOM", true)),
      useTabStops: register(new EditorBooleanOption(126, "useTabStops", true, { description: localize("useTabStops", "Inserting and deleting whitespace follows tab stops.") })),
      wordBreak: register(new EditorStringEnumOption(127, "wordBreak", "normal", ["normal", "keepAll"], {
        markdownEnumDescriptions: [
          localize("wordBreak.normal", "Use the default line break rule."),
          localize("wordBreak.keepAll", "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.")
        ],
        description: localize("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
      })),
      wordSeparators: register(new EditorStringOption(128, "wordSeparators", USUAL_WORD_SEPARATORS, { description: localize("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
      wordWrap: register(new EditorStringEnumOption(129, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
        markdownEnumDescriptions: [
          localize("wordWrap.off", "Lines will never wrap."),
          localize("wordWrap.on", "Lines will wrap at the viewport width."),
          localize({
            key: "wordWrap.wordWrapColumn",
            comment: [
              "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
            ]
          }, "Lines will wrap at `#editor.wordWrapColumn#`."),
          localize({
            key: "wordWrap.bounded",
            comment: [
              "- viewport means the edge of the visible window size.",
              "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
            ]
          }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
        ],
        description: localize({
          key: "wordWrap",
          comment: [
            "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
            "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
          ]
        }, "Controls how lines should wrap.")
      })),
      wordWrapBreakAfterCharacters: register(new EditorStringOption(
        130,
        "wordWrapBreakAfterCharacters",
        // allow-any-unicode-next-line
        " 	})]?|/&.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣"
      )),
      wordWrapBreakBeforeCharacters: register(new EditorStringOption(
        131,
        "wordWrapBreakBeforeCharacters",
        // allow-any-unicode-next-line
        "([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋"
      )),
      wordWrapColumn: register(new EditorIntOption(132, "wordWrapColumn", 80, 1, 1073741824, {
        markdownDescription: localize({
          key: "wordWrapColumn",
          comment: [
            "- `editor.wordWrap` refers to a different setting and should not be localized.",
            "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
          ]
        }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
      })),
      wordWrapOverride1: register(new EditorStringEnumOption(133, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
      wordWrapOverride2: register(new EditorStringEnumOption(134, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
      // Leave these at the end (because they have dependencies!)
      editorClassName: register(new EditorClassName()),
      defaultColorDecorators: register(new EditorBooleanOption(144, "defaultColorDecorators", false, { markdownDescription: localize("defaultColorDecorators", "Controls whether inline color decorations should be shown using the default document color provider") })),
      pixelRatio: register(new EditorPixelRatio()),
      tabFocusMode: register(new EditorBooleanOption(141, "tabFocusMode", false, { markdownDescription: localize("tabFocusMode", "Controls whether the editor receives tabs or defers them to the workbench for navigation.") })),
      layoutInfo: register(new EditorLayoutInfoComputer()),
      wrappingInfo: register(new EditorWrappingInfoComputer()),
      wrappingIndent: register(new WrappingIndentOption()),
      wrappingStrategy: register(new WrappingStrategy())
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js
function appendEntry(target, key, value) {
  if (target.has(key)) {
    target.get(key).push(value);
  } else {
    target.set(key, [value]);
  }
}
var IndentAction, StandardAutoClosingPairConditional, AutoClosingPairs;
var init_languageConfiguration = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js"() {
    (function(IndentAction2) {
      IndentAction2[IndentAction2["None"] = 0] = "None";
      IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
      IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
      IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
    })(IndentAction || (IndentAction = {}));
    StandardAutoClosingPairConditional = class {
      constructor(source) {
        this._neutralCharacter = null;
        this._neutralCharacterSearched = false;
        this.open = source.open;
        this.close = source.close;
        this._inString = true;
        this._inComment = true;
        this._inRegEx = true;
        if (Array.isArray(source.notIn)) {
          for (let i = 0, len = source.notIn.length; i < len; i++) {
            const notIn = source.notIn[i];
            switch (notIn) {
              case "string":
                this._inString = false;
                break;
              case "comment":
                this._inComment = false;
                break;
              case "regex":
                this._inRegEx = false;
                break;
            }
          }
        }
      }
      isOK(standardToken) {
        switch (standardToken) {
          case 0:
            return true;
          case 1:
            return this._inComment;
          case 2:
            return this._inString;
          case 3:
            return this._inRegEx;
        }
      }
      shouldAutoClose(context, column) {
        if (context.getTokenCount() === 0) {
          return true;
        }
        const tokenIndex = context.findTokenIndexAtOffset(column - 2);
        const standardTokenType = context.getStandardTokenType(tokenIndex);
        return this.isOK(standardTokenType);
      }
      _findNeutralCharacterInRange(fromCharCode, toCharCode) {
        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {
          const character = String.fromCharCode(charCode);
          if (!this.open.includes(character) && !this.close.includes(character)) {
            return character;
          }
        }
        return null;
      }
      /**
       * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
       */
      findNeutralCharacter() {
        if (!this._neutralCharacterSearched) {
          this._neutralCharacterSearched = true;
          if (!this._neutralCharacter) {
            this._neutralCharacter = this._findNeutralCharacterInRange(
              48,
              57
              /* CharCode.Digit9 */
            );
          }
          if (!this._neutralCharacter) {
            this._neutralCharacter = this._findNeutralCharacterInRange(
              97,
              122
              /* CharCode.z */
            );
          }
          if (!this._neutralCharacter) {
            this._neutralCharacter = this._findNeutralCharacterInRange(
              65,
              90
              /* CharCode.Z */
            );
          }
        }
        return this._neutralCharacter;
      }
    };
    AutoClosingPairs = class {
      constructor(autoClosingPairs) {
        this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map();
        this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map();
        this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map();
        this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map();
        this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
        for (const pair of autoClosingPairs) {
          appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);
          appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);
          appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);
          appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);
          if (pair.close.length === 1 && pair.open.length === 1) {
            appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);
          }
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/platform/remote/common/remoteHosts.js
function getRemoteAuthority(uri) {
  return uri.scheme === Schemas.vscodeRemote ? uri.authority : void 0;
}
function getRemoteName(authority) {
  if (!authority) {
    return void 0;
  }
  const pos = authority.indexOf("+");
  if (pos < 0) {
    return authority;
  }
  return authority.substr(0, pos);
}
function getRemoteServerRootPath(product) {
  var _a4, _b2;
  return `/${(_a4 = product.quality) !== null && _a4 !== void 0 ? _a4 : "oss"}-${(_b2 = product.commit) !== null && _b2 !== void 0 ? _b2 : "dev"}`;
}
var init_remoteHosts = __esm({
  "node_modules/monaco-editor/esm/vs/platform/remote/common/remoteHosts.js"() {
    init_network();
  }
});

// node_modules/monaco-editor/esm/vs/platform/extensions/common/extensions.js
var UNDEFINED_PUBLISHER, ALL_EXTENSION_KINDS, EXTENSION_CATEGORIES, ExtensionIdentifier, ExtensionIdentifierSet, ExtensionIdentifierMap, IBuiltinExtensionsScannerService;
var init_extensions = __esm({
  "node_modules/monaco-editor/esm/vs/platform/extensions/common/extensions.js"() {
    init_strings();
    init_instantiation();
    init_remoteHosts();
    UNDEFINED_PUBLISHER = "undefined_publisher";
    ALL_EXTENSION_KINDS = ["ui", "workspace", "web"];
    EXTENSION_CATEGORIES = [
      "Azure",
      "Data Science",
      "Debuggers",
      "Extension Packs",
      "Education",
      "Formatters",
      "Keymaps",
      "Language Packs",
      "Linters",
      "Machine Learning",
      "Notebooks",
      "Programming Languages",
      "SCM Providers",
      "Snippets",
      "Testing",
      "Themes",
      "Visualization",
      "Other"
    ];
    ExtensionIdentifier = class {
      constructor(value) {
        this.value = value;
        this._lower = value.toLowerCase();
      }
      static equals(a, b) {
        if (typeof a === "undefined" || a === null) {
          return typeof b === "undefined" || b === null;
        }
        if (typeof b === "undefined" || b === null) {
          return false;
        }
        if (typeof a === "string" || typeof b === "string") {
          const aValue = typeof a === "string" ? a : a.value;
          const bValue = typeof b === "string" ? b : b.value;
          return equalsIgnoreCase(aValue, bValue);
        }
        return a._lower === b._lower;
      }
      /**
       * Gives the value by which to index (for equality).
       */
      static toKey(id2) {
        if (typeof id2 === "string") {
          return id2.toLowerCase();
        }
        return id2._lower;
      }
    };
    ExtensionIdentifierSet = class {
      get size() {
        return this._set.size;
      }
      constructor(iterable) {
        this._set = /* @__PURE__ */ new Set();
        if (iterable) {
          for (const value of iterable) {
            this.add(value);
          }
        }
      }
      add(id2) {
        this._set.add(ExtensionIdentifier.toKey(id2));
      }
      delete(extensionId) {
        return this._set.delete(ExtensionIdentifier.toKey(extensionId));
      }
      has(id2) {
        return this._set.has(ExtensionIdentifier.toKey(id2));
      }
    };
    ExtensionIdentifierMap = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      clear() {
        this._map.clear();
      }
      delete(id2) {
        this._map.delete(ExtensionIdentifier.toKey(id2));
      }
      get(id2) {
        return this._map.get(ExtensionIdentifier.toKey(id2));
      }
      has(id2) {
        return this._map.has(ExtensionIdentifier.toKey(id2));
      }
      set(id2, value) {
        this._map.set(ExtensionIdentifier.toKey(id2), value);
      }
      values() {
        return this._map.values();
      }
      forEach(callbackfn) {
        this._map.forEach(callbackfn);
      }
      [Symbol.iterator]() {
        return this._map[Symbol.iterator]();
      }
    };
    IBuiltinExtensionsScannerService = createDecorator("IBuiltinExtensionsScannerService");
  }
});

// node_modules/monaco-editor/esm/vs/base/common/codicons.js
function register2(id2, fontCharacter) {
  if (isString(fontCharacter)) {
    const val = _codiconFontCharacters[fontCharacter];
    if (val === void 0) {
      throw new Error(`${id2} references an unknown codicon: ${fontCharacter}`);
    }
    fontCharacter = val;
  }
  _codiconFontCharacters[id2] = fontCharacter;
  return { id: id2 };
}
function getCodiconFontCharacters() {
  return _codiconFontCharacters;
}
var _codiconFontCharacters, Codicon;
var init_codicons = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/codicons.js"() {
    init_types();
    _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
    Codicon = {
      // built-in icons, with image name
      add: register2("add", 6e4),
      plus: register2("plus", 6e4),
      gistNew: register2("gist-new", 6e4),
      repoCreate: register2("repo-create", 6e4),
      lightbulb: register2("lightbulb", 60001),
      lightBulb: register2("light-bulb", 60001),
      repo: register2("repo", 60002),
      repoDelete: register2("repo-delete", 60002),
      gistFork: register2("gist-fork", 60003),
      repoForked: register2("repo-forked", 60003),
      gitPullRequest: register2("git-pull-request", 60004),
      gitPullRequestAbandoned: register2("git-pull-request-abandoned", 60004),
      recordKeys: register2("record-keys", 60005),
      keyboard: register2("keyboard", 60005),
      tag: register2("tag", 60006),
      tagAdd: register2("tag-add", 60006),
      tagRemove: register2("tag-remove", 60006),
      gitPullRequestLabel: register2("git-pull-request-label", 60006),
      person: register2("person", 60007),
      personFollow: register2("person-follow", 60007),
      personOutline: register2("person-outline", 60007),
      personFilled: register2("person-filled", 60007),
      gitBranch: register2("git-branch", 60008),
      gitBranchCreate: register2("git-branch-create", 60008),
      gitBranchDelete: register2("git-branch-delete", 60008),
      sourceControl: register2("source-control", 60008),
      mirror: register2("mirror", 60009),
      mirrorPublic: register2("mirror-public", 60009),
      star: register2("star", 60010),
      starAdd: register2("star-add", 60010),
      starDelete: register2("star-delete", 60010),
      starEmpty: register2("star-empty", 60010),
      comment: register2("comment", 60011),
      commentAdd: register2("comment-add", 60011),
      alert: register2("alert", 60012),
      warning: register2("warning", 60012),
      search: register2("search", 60013),
      searchSave: register2("search-save", 60013),
      logOut: register2("log-out", 60014),
      signOut: register2("sign-out", 60014),
      logIn: register2("log-in", 60015),
      signIn: register2("sign-in", 60015),
      eye: register2("eye", 60016),
      eyeUnwatch: register2("eye-unwatch", 60016),
      eyeWatch: register2("eye-watch", 60016),
      circleFilled: register2("circle-filled", 60017),
      primitiveDot: register2("primitive-dot", 60017),
      closeDirty: register2("close-dirty", 60017),
      debugBreakpoint: register2("debug-breakpoint", 60017),
      debugBreakpointDisabled: register2("debug-breakpoint-disabled", 60017),
      debugHint: register2("debug-hint", 60017),
      primitiveSquare: register2("primitive-square", 60018),
      edit: register2("edit", 60019),
      pencil: register2("pencil", 60019),
      info: register2("info", 60020),
      issueOpened: register2("issue-opened", 60020),
      gistPrivate: register2("gist-private", 60021),
      gitForkPrivate: register2("git-fork-private", 60021),
      lock: register2("lock", 60021),
      mirrorPrivate: register2("mirror-private", 60021),
      close: register2("close", 60022),
      removeClose: register2("remove-close", 60022),
      x: register2("x", 60022),
      repoSync: register2("repo-sync", 60023),
      sync: register2("sync", 60023),
      clone: register2("clone", 60024),
      desktopDownload: register2("desktop-download", 60024),
      beaker: register2("beaker", 60025),
      microscope: register2("microscope", 60025),
      vm: register2("vm", 60026),
      deviceDesktop: register2("device-desktop", 60026),
      file: register2("file", 60027),
      fileText: register2("file-text", 60027),
      more: register2("more", 60028),
      ellipsis: register2("ellipsis", 60028),
      kebabHorizontal: register2("kebab-horizontal", 60028),
      mailReply: register2("mail-reply", 60029),
      reply: register2("reply", 60029),
      organization: register2("organization", 60030),
      organizationFilled: register2("organization-filled", 60030),
      organizationOutline: register2("organization-outline", 60030),
      newFile: register2("new-file", 60031),
      fileAdd: register2("file-add", 60031),
      newFolder: register2("new-folder", 60032),
      fileDirectoryCreate: register2("file-directory-create", 60032),
      trash: register2("trash", 60033),
      trashcan: register2("trashcan", 60033),
      history: register2("history", 60034),
      clock: register2("clock", 60034),
      folder: register2("folder", 60035),
      fileDirectory: register2("file-directory", 60035),
      symbolFolder: register2("symbol-folder", 60035),
      logoGithub: register2("logo-github", 60036),
      markGithub: register2("mark-github", 60036),
      github: register2("github", 60036),
      terminal: register2("terminal", 60037),
      console: register2("console", 60037),
      repl: register2("repl", 60037),
      zap: register2("zap", 60038),
      symbolEvent: register2("symbol-event", 60038),
      error: register2("error", 60039),
      stop: register2("stop", 60039),
      variable: register2("variable", 60040),
      symbolVariable: register2("symbol-variable", 60040),
      array: register2("array", 60042),
      symbolArray: register2("symbol-array", 60042),
      symbolModule: register2("symbol-module", 60043),
      symbolPackage: register2("symbol-package", 60043),
      symbolNamespace: register2("symbol-namespace", 60043),
      symbolObject: register2("symbol-object", 60043),
      symbolMethod: register2("symbol-method", 60044),
      symbolFunction: register2("symbol-function", 60044),
      symbolConstructor: register2("symbol-constructor", 60044),
      symbolBoolean: register2("symbol-boolean", 60047),
      symbolNull: register2("symbol-null", 60047),
      symbolNumeric: register2("symbol-numeric", 60048),
      symbolNumber: register2("symbol-number", 60048),
      symbolStructure: register2("symbol-structure", 60049),
      symbolStruct: register2("symbol-struct", 60049),
      symbolParameter: register2("symbol-parameter", 60050),
      symbolTypeParameter: register2("symbol-type-parameter", 60050),
      symbolKey: register2("symbol-key", 60051),
      symbolText: register2("symbol-text", 60051),
      symbolReference: register2("symbol-reference", 60052),
      goToFile: register2("go-to-file", 60052),
      symbolEnum: register2("symbol-enum", 60053),
      symbolValue: register2("symbol-value", 60053),
      symbolRuler: register2("symbol-ruler", 60054),
      symbolUnit: register2("symbol-unit", 60054),
      activateBreakpoints: register2("activate-breakpoints", 60055),
      archive: register2("archive", 60056),
      arrowBoth: register2("arrow-both", 60057),
      arrowDown: register2("arrow-down", 60058),
      arrowLeft: register2("arrow-left", 60059),
      arrowRight: register2("arrow-right", 60060),
      arrowSmallDown: register2("arrow-small-down", 60061),
      arrowSmallLeft: register2("arrow-small-left", 60062),
      arrowSmallRight: register2("arrow-small-right", 60063),
      arrowSmallUp: register2("arrow-small-up", 60064),
      arrowUp: register2("arrow-up", 60065),
      bell: register2("bell", 60066),
      bold: register2("bold", 60067),
      book: register2("book", 60068),
      bookmark: register2("bookmark", 60069),
      debugBreakpointConditionalUnverified: register2("debug-breakpoint-conditional-unverified", 60070),
      debugBreakpointConditional: register2("debug-breakpoint-conditional", 60071),
      debugBreakpointConditionalDisabled: register2("debug-breakpoint-conditional-disabled", 60071),
      debugBreakpointDataUnverified: register2("debug-breakpoint-data-unverified", 60072),
      debugBreakpointData: register2("debug-breakpoint-data", 60073),
      debugBreakpointDataDisabled: register2("debug-breakpoint-data-disabled", 60073),
      debugBreakpointLogUnverified: register2("debug-breakpoint-log-unverified", 60074),
      debugBreakpointLog: register2("debug-breakpoint-log", 60075),
      debugBreakpointLogDisabled: register2("debug-breakpoint-log-disabled", 60075),
      briefcase: register2("briefcase", 60076),
      broadcast: register2("broadcast", 60077),
      browser: register2("browser", 60078),
      bug: register2("bug", 60079),
      calendar: register2("calendar", 60080),
      caseSensitive: register2("case-sensitive", 60081),
      check: register2("check", 60082),
      checklist: register2("checklist", 60083),
      chevronDown: register2("chevron-down", 60084),
      dropDownButton: register2("drop-down-button", 60084),
      chevronLeft: register2("chevron-left", 60085),
      chevronRight: register2("chevron-right", 60086),
      chevronUp: register2("chevron-up", 60087),
      chromeClose: register2("chrome-close", 60088),
      chromeMaximize: register2("chrome-maximize", 60089),
      chromeMinimize: register2("chrome-minimize", 60090),
      chromeRestore: register2("chrome-restore", 60091),
      circle: register2("circle", 60092),
      circleOutline: register2("circle-outline", 60092),
      debugBreakpointUnverified: register2("debug-breakpoint-unverified", 60092),
      circleSlash: register2("circle-slash", 60093),
      circuitBoard: register2("circuit-board", 60094),
      clearAll: register2("clear-all", 60095),
      clippy: register2("clippy", 60096),
      closeAll: register2("close-all", 60097),
      cloudDownload: register2("cloud-download", 60098),
      cloudUpload: register2("cloud-upload", 60099),
      code: register2("code", 60100),
      collapseAll: register2("collapse-all", 60101),
      colorMode: register2("color-mode", 60102),
      commentDiscussion: register2("comment-discussion", 60103),
      compareChanges: register2("compare-changes", 60157),
      creditCard: register2("credit-card", 60105),
      dash: register2("dash", 60108),
      dashboard: register2("dashboard", 60109),
      database: register2("database", 60110),
      debugContinue: register2("debug-continue", 60111),
      debugDisconnect: register2("debug-disconnect", 60112),
      debugPause: register2("debug-pause", 60113),
      debugRestart: register2("debug-restart", 60114),
      debugStart: register2("debug-start", 60115),
      debugStepInto: register2("debug-step-into", 60116),
      debugStepOut: register2("debug-step-out", 60117),
      debugStepOver: register2("debug-step-over", 60118),
      debugStop: register2("debug-stop", 60119),
      debug: register2("debug", 60120),
      deviceCameraVideo: register2("device-camera-video", 60121),
      deviceCamera: register2("device-camera", 60122),
      deviceMobile: register2("device-mobile", 60123),
      diffAdded: register2("diff-added", 60124),
      diffIgnored: register2("diff-ignored", 60125),
      diffModified: register2("diff-modified", 60126),
      diffRemoved: register2("diff-removed", 60127),
      diffRenamed: register2("diff-renamed", 60128),
      diff: register2("diff", 60129),
      discard: register2("discard", 60130),
      editorLayout: register2("editor-layout", 60131),
      emptyWindow: register2("empty-window", 60132),
      exclude: register2("exclude", 60133),
      extensions: register2("extensions", 60134),
      eyeClosed: register2("eye-closed", 60135),
      fileBinary: register2("file-binary", 60136),
      fileCode: register2("file-code", 60137),
      fileMedia: register2("file-media", 60138),
      filePdf: register2("file-pdf", 60139),
      fileSubmodule: register2("file-submodule", 60140),
      fileSymlinkDirectory: register2("file-symlink-directory", 60141),
      fileSymlinkFile: register2("file-symlink-file", 60142),
      fileZip: register2("file-zip", 60143),
      files: register2("files", 60144),
      filter: register2("filter", 60145),
      flame: register2("flame", 60146),
      foldDown: register2("fold-down", 60147),
      foldUp: register2("fold-up", 60148),
      fold: register2("fold", 60149),
      folderActive: register2("folder-active", 60150),
      folderOpened: register2("folder-opened", 60151),
      gear: register2("gear", 60152),
      gift: register2("gift", 60153),
      gistSecret: register2("gist-secret", 60154),
      gist: register2("gist", 60155),
      gitCommit: register2("git-commit", 60156),
      gitCompare: register2("git-compare", 60157),
      gitMerge: register2("git-merge", 60158),
      githubAction: register2("github-action", 60159),
      githubAlt: register2("github-alt", 60160),
      globe: register2("globe", 60161),
      grabber: register2("grabber", 60162),
      graph: register2("graph", 60163),
      gripper: register2("gripper", 60164),
      heart: register2("heart", 60165),
      home: register2("home", 60166),
      horizontalRule: register2("horizontal-rule", 60167),
      hubot: register2("hubot", 60168),
      inbox: register2("inbox", 60169),
      issueClosed: register2("issue-closed", 60324),
      issueReopened: register2("issue-reopened", 60171),
      issues: register2("issues", 60172),
      italic: register2("italic", 60173),
      jersey: register2("jersey", 60174),
      json: register2("json", 60175),
      bracket: register2("bracket", 60175),
      kebabVertical: register2("kebab-vertical", 60176),
      key: register2("key", 60177),
      law: register2("law", 60178),
      lightbulbAutofix: register2("lightbulb-autofix", 60179),
      linkExternal: register2("link-external", 60180),
      link: register2("link", 60181),
      listOrdered: register2("list-ordered", 60182),
      listUnordered: register2("list-unordered", 60183),
      liveShare: register2("live-share", 60184),
      loading: register2("loading", 60185),
      location: register2("location", 60186),
      mailRead: register2("mail-read", 60187),
      mail: register2("mail", 60188),
      markdown: register2("markdown", 60189),
      megaphone: register2("megaphone", 60190),
      mention: register2("mention", 60191),
      milestone: register2("milestone", 60192),
      gitPullRequestMilestone: register2("git-pull-request-milestone", 60192),
      mortarBoard: register2("mortar-board", 60193),
      move: register2("move", 60194),
      multipleWindows: register2("multiple-windows", 60195),
      mute: register2("mute", 60196),
      noNewline: register2("no-newline", 60197),
      note: register2("note", 60198),
      octoface: register2("octoface", 60199),
      openPreview: register2("open-preview", 60200),
      package_: register2("package", 60201),
      paintcan: register2("paintcan", 60202),
      pin: register2("pin", 60203),
      play: register2("play", 60204),
      run: register2("run", 60204),
      plug: register2("plug", 60205),
      preserveCase: register2("preserve-case", 60206),
      preview: register2("preview", 60207),
      project: register2("project", 60208),
      pulse: register2("pulse", 60209),
      question: register2("question", 60210),
      quote: register2("quote", 60211),
      radioTower: register2("radio-tower", 60212),
      reactions: register2("reactions", 60213),
      references: register2("references", 60214),
      refresh: register2("refresh", 60215),
      regex: register2("regex", 60216),
      remoteExplorer: register2("remote-explorer", 60217),
      remote: register2("remote", 60218),
      remove: register2("remove", 60219),
      replaceAll: register2("replace-all", 60220),
      replace: register2("replace", 60221),
      repoClone: register2("repo-clone", 60222),
      repoForcePush: register2("repo-force-push", 60223),
      repoPull: register2("repo-pull", 60224),
      repoPush: register2("repo-push", 60225),
      report: register2("report", 60226),
      requestChanges: register2("request-changes", 60227),
      rocket: register2("rocket", 60228),
      rootFolderOpened: register2("root-folder-opened", 60229),
      rootFolder: register2("root-folder", 60230),
      rss: register2("rss", 60231),
      ruby: register2("ruby", 60232),
      saveAll: register2("save-all", 60233),
      saveAs: register2("save-as", 60234),
      save: register2("save", 60235),
      screenFull: register2("screen-full", 60236),
      screenNormal: register2("screen-normal", 60237),
      searchStop: register2("search-stop", 60238),
      server: register2("server", 60240),
      settingsGear: register2("settings-gear", 60241),
      settings: register2("settings", 60242),
      shield: register2("shield", 60243),
      smiley: register2("smiley", 60244),
      sortPrecedence: register2("sort-precedence", 60245),
      splitHorizontal: register2("split-horizontal", 60246),
      splitVertical: register2("split-vertical", 60247),
      squirrel: register2("squirrel", 60248),
      starFull: register2("star-full", 60249),
      starHalf: register2("star-half", 60250),
      symbolClass: register2("symbol-class", 60251),
      symbolColor: register2("symbol-color", 60252),
      symbolCustomColor: register2("symbol-customcolor", 60252),
      symbolConstant: register2("symbol-constant", 60253),
      symbolEnumMember: register2("symbol-enum-member", 60254),
      symbolField: register2("symbol-field", 60255),
      symbolFile: register2("symbol-file", 60256),
      symbolInterface: register2("symbol-interface", 60257),
      symbolKeyword: register2("symbol-keyword", 60258),
      symbolMisc: register2("symbol-misc", 60259),
      symbolOperator: register2("symbol-operator", 60260),
      symbolProperty: register2("symbol-property", 60261),
      wrench: register2("wrench", 60261),
      wrenchSubaction: register2("wrench-subaction", 60261),
      symbolSnippet: register2("symbol-snippet", 60262),
      tasklist: register2("tasklist", 60263),
      telescope: register2("telescope", 60264),
      textSize: register2("text-size", 60265),
      threeBars: register2("three-bars", 60266),
      thumbsdown: register2("thumbsdown", 60267),
      thumbsup: register2("thumbsup", 60268),
      tools: register2("tools", 60269),
      triangleDown: register2("triangle-down", 60270),
      triangleLeft: register2("triangle-left", 60271),
      triangleRight: register2("triangle-right", 60272),
      triangleUp: register2("triangle-up", 60273),
      twitter: register2("twitter", 60274),
      unfold: register2("unfold", 60275),
      unlock: register2("unlock", 60276),
      unmute: register2("unmute", 60277),
      unverified: register2("unverified", 60278),
      verified: register2("verified", 60279),
      versions: register2("versions", 60280),
      vmActive: register2("vm-active", 60281),
      vmOutline: register2("vm-outline", 60282),
      vmRunning: register2("vm-running", 60283),
      watch: register2("watch", 60284),
      whitespace: register2("whitespace", 60285),
      wholeWord: register2("whole-word", 60286),
      window: register2("window", 60287),
      wordWrap: register2("word-wrap", 60288),
      zoomIn: register2("zoom-in", 60289),
      zoomOut: register2("zoom-out", 60290),
      listFilter: register2("list-filter", 60291),
      listFlat: register2("list-flat", 60292),
      listSelection: register2("list-selection", 60293),
      selection: register2("selection", 60293),
      listTree: register2("list-tree", 60294),
      debugBreakpointFunctionUnverified: register2("debug-breakpoint-function-unverified", 60295),
      debugBreakpointFunction: register2("debug-breakpoint-function", 60296),
      debugBreakpointFunctionDisabled: register2("debug-breakpoint-function-disabled", 60296),
      debugStackframeActive: register2("debug-stackframe-active", 60297),
      circleSmallFilled: register2("circle-small-filled", 60298),
      debugStackframeDot: register2("debug-stackframe-dot", 60298),
      debugStackframe: register2("debug-stackframe", 60299),
      debugStackframeFocused: register2("debug-stackframe-focused", 60299),
      debugBreakpointUnsupported: register2("debug-breakpoint-unsupported", 60300),
      symbolString: register2("symbol-string", 60301),
      debugReverseContinue: register2("debug-reverse-continue", 60302),
      debugStepBack: register2("debug-step-back", 60303),
      debugRestartFrame: register2("debug-restart-frame", 60304),
      callIncoming: register2("call-incoming", 60306),
      callOutgoing: register2("call-outgoing", 60307),
      menu: register2("menu", 60308),
      expandAll: register2("expand-all", 60309),
      feedback: register2("feedback", 60310),
      gitPullRequestReviewer: register2("git-pull-request-reviewer", 60310),
      groupByRefType: register2("group-by-ref-type", 60311),
      ungroupByRefType: register2("ungroup-by-ref-type", 60312),
      account: register2("account", 60313),
      gitPullRequestAssignee: register2("git-pull-request-assignee", 60313),
      bellDot: register2("bell-dot", 60314),
      debugConsole: register2("debug-console", 60315),
      library: register2("library", 60316),
      output: register2("output", 60317),
      runAll: register2("run-all", 60318),
      syncIgnored: register2("sync-ignored", 60319),
      pinned: register2("pinned", 60320),
      githubInverted: register2("github-inverted", 60321),
      debugAlt: register2("debug-alt", 60305),
      serverProcess: register2("server-process", 60322),
      serverEnvironment: register2("server-environment", 60323),
      pass: register2("pass", 60324),
      stopCircle: register2("stop-circle", 60325),
      playCircle: register2("play-circle", 60326),
      record: register2("record", 60327),
      debugAltSmall: register2("debug-alt-small", 60328),
      vmConnect: register2("vm-connect", 60329),
      cloud: register2("cloud", 60330),
      merge: register2("merge", 60331),
      exportIcon: register2("export", 60332),
      graphLeft: register2("graph-left", 60333),
      magnet: register2("magnet", 60334),
      notebook: register2("notebook", 60335),
      redo: register2("redo", 60336),
      checkAll: register2("check-all", 60337),
      pinnedDirty: register2("pinned-dirty", 60338),
      passFilled: register2("pass-filled", 60339),
      circleLargeFilled: register2("circle-large-filled", 60340),
      circleLarge: register2("circle-large", 60341),
      circleLargeOutline: register2("circle-large-outline", 60341),
      combine: register2("combine", 60342),
      gather: register2("gather", 60342),
      table: register2("table", 60343),
      variableGroup: register2("variable-group", 60344),
      typeHierarchy: register2("type-hierarchy", 60345),
      typeHierarchySub: register2("type-hierarchy-sub", 60346),
      typeHierarchySuper: register2("type-hierarchy-super", 60347),
      gitPullRequestCreate: register2("git-pull-request-create", 60348),
      runAbove: register2("run-above", 60349),
      runBelow: register2("run-below", 60350),
      notebookTemplate: register2("notebook-template", 60351),
      debugRerun: register2("debug-rerun", 60352),
      workspaceTrusted: register2("workspace-trusted", 60353),
      workspaceUntrusted: register2("workspace-untrusted", 60354),
      workspaceUnspecified: register2("workspace-unspecified", 60355),
      terminalCmd: register2("terminal-cmd", 60356),
      terminalDebian: register2("terminal-debian", 60357),
      terminalLinux: register2("terminal-linux", 60358),
      terminalPowershell: register2("terminal-powershell", 60359),
      terminalTmux: register2("terminal-tmux", 60360),
      terminalUbuntu: register2("terminal-ubuntu", 60361),
      terminalBash: register2("terminal-bash", 60362),
      arrowSwap: register2("arrow-swap", 60363),
      copy: register2("copy", 60364),
      personAdd: register2("person-add", 60365),
      filterFilled: register2("filter-filled", 60366),
      wand: register2("wand", 60367),
      debugLineByLine: register2("debug-line-by-line", 60368),
      inspect: register2("inspect", 60369),
      layers: register2("layers", 60370),
      layersDot: register2("layers-dot", 60371),
      layersActive: register2("layers-active", 60372),
      compass: register2("compass", 60373),
      compassDot: register2("compass-dot", 60374),
      compassActive: register2("compass-active", 60375),
      azure: register2("azure", 60376),
      issueDraft: register2("issue-draft", 60377),
      gitPullRequestClosed: register2("git-pull-request-closed", 60378),
      gitPullRequestDraft: register2("git-pull-request-draft", 60379),
      debugAll: register2("debug-all", 60380),
      debugCoverage: register2("debug-coverage", 60381),
      runErrors: register2("run-errors", 60382),
      folderLibrary: register2("folder-library", 60383),
      debugContinueSmall: register2("debug-continue-small", 60384),
      beakerStop: register2("beaker-stop", 60385),
      graphLine: register2("graph-line", 60386),
      graphScatter: register2("graph-scatter", 60387),
      pieChart: register2("pie-chart", 60388),
      bracketDot: register2("bracket-dot", 60389),
      bracketError: register2("bracket-error", 60390),
      lockSmall: register2("lock-small", 60391),
      azureDevops: register2("azure-devops", 60392),
      verifiedFilled: register2("verified-filled", 60393),
      newLine: register2("newline", 60394),
      layout: register2("layout", 60395),
      layoutActivitybarLeft: register2("layout-activitybar-left", 60396),
      layoutActivitybarRight: register2("layout-activitybar-right", 60397),
      layoutPanelLeft: register2("layout-panel-left", 60398),
      layoutPanelCenter: register2("layout-panel-center", 60399),
      layoutPanelJustify: register2("layout-panel-justify", 60400),
      layoutPanelRight: register2("layout-panel-right", 60401),
      layoutPanel: register2("layout-panel", 60402),
      layoutSidebarLeft: register2("layout-sidebar-left", 60403),
      layoutSidebarRight: register2("layout-sidebar-right", 60404),
      layoutStatusbar: register2("layout-statusbar", 60405),
      layoutMenubar: register2("layout-menubar", 60406),
      layoutCentered: register2("layout-centered", 60407),
      layoutSidebarRightOff: register2("layout-sidebar-right-off", 60416),
      layoutPanelOff: register2("layout-panel-off", 60417),
      layoutSidebarLeftOff: register2("layout-sidebar-left-off", 60418),
      target: register2("target", 60408),
      indent: register2("indent", 60409),
      recordSmall: register2("record-small", 60410),
      errorSmall: register2("error-small", 60411),
      arrowCircleDown: register2("arrow-circle-down", 60412),
      arrowCircleLeft: register2("arrow-circle-left", 60413),
      arrowCircleRight: register2("arrow-circle-right", 60414),
      arrowCircleUp: register2("arrow-circle-up", 60415),
      heartFilled: register2("heart-filled", 60420),
      map: register2("map", 60421),
      mapFilled: register2("map-filled", 60422),
      circleSmall: register2("circle-small", 60423),
      bellSlash: register2("bell-slash", 60424),
      bellSlashDot: register2("bell-slash-dot", 60425),
      commentUnresolved: register2("comment-unresolved", 60426),
      gitPullRequestGoToChanges: register2("git-pull-request-go-to-changes", 60427),
      gitPullRequestNewChanges: register2("git-pull-request-new-changes", 60428),
      searchFuzzy: register2("search-fuzzy", 60429),
      commentDraft: register2("comment-draft", 60430),
      send: register2("send", 60431),
      sparkle: register2("sparkle", 60432),
      insert: register2("insert", 60433),
      mic: register2("mic", 60434),
      // derived icons, that could become separate icons
      dialogError: register2("dialog-error", "error"),
      dialogWarning: register2("dialog-warning", "warning"),
      dialogInfo: register2("dialog-info", "info"),
      dialogClose: register2("dialog-close", "close"),
      treeItemExpanded: register2("tree-item-expanded", "chevron-down"),
      treeFilterOnTypeOn: register2("tree-filter-on-type-on", "list-filter"),
      treeFilterOnTypeOff: register2("tree-filter-on-type-off", "list-selection"),
      treeFilterClear: register2("tree-filter-clear", "close"),
      treeItemLoading: register2("tree-item-loading", "loading"),
      menuSelection: register2("menu-selection", "check"),
      menuSubmenu: register2("menu-submenu", "chevron-right"),
      menuBarMore: register2("menubar-more", "more"),
      scrollbarButtonLeft: register2("scrollbar-button-left", "triangle-left"),
      scrollbarButtonRight: register2("scrollbar-button-right", "triangle-right"),
      scrollbarButtonUp: register2("scrollbar-button-up", "triangle-up"),
      scrollbarButtonDown: register2("scrollbar-button-down", "triangle-down"),
      toolBarMore: register2("toolbar-more", "more"),
      quickInputBack: register2("quick-input-back", "arrow-left")
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/themables.js
var ThemeColor, ThemeIcon;
var init_themables = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/themables.js"() {
    init_codicons();
    (function(ThemeColor2) {
      function isThemeColor(obj) {
        return obj && typeof obj === "object" && typeof obj.id === "string";
      }
      ThemeColor2.isThemeColor = isThemeColor;
    })(ThemeColor || (ThemeColor = {}));
    (function(ThemeIcon2) {
      ThemeIcon2.iconNameSegment = "[A-Za-z0-9]+";
      ThemeIcon2.iconNameExpression = "[A-Za-z0-9-]+";
      ThemeIcon2.iconModifierExpression = "~[A-Za-z]+";
      ThemeIcon2.iconNameCharacter = "[A-Za-z0-9~-]";
      const ThemeIconIdRegex = new RegExp(`^(${ThemeIcon2.iconNameExpression})(${ThemeIcon2.iconModifierExpression})?$`);
      function asClassNameArray(icon) {
        const match = ThemeIconIdRegex.exec(icon.id);
        if (!match) {
          return asClassNameArray(Codicon.error);
        }
        const [, id2, modifier] = match;
        const classNames = ["codicon", "codicon-" + id2];
        if (modifier) {
          classNames.push("codicon-modifier-" + modifier.substring(1));
        }
        return classNames;
      }
      ThemeIcon2.asClassNameArray = asClassNameArray;
      function asClassName(icon) {
        return asClassNameArray(icon).join(" ");
      }
      ThemeIcon2.asClassName = asClassName;
      function asCSSSelector(icon) {
        return "." + asClassNameArray(icon).join(".");
      }
      ThemeIcon2.asCSSSelector = asCSSSelector;
      function isThemeIcon(obj) {
        return obj && typeof obj === "object" && typeof obj.id === "string" && (typeof obj.color === "undefined" || ThemeColor.isThemeColor(obj.color));
      }
      ThemeIcon2.isThemeIcon = isThemeIcon;
      const _regexFromString = new RegExp(`^\\$\\((${ThemeIcon2.iconNameExpression}(?:${ThemeIcon2.iconModifierExpression})?)\\)$`);
      function fromString(str) {
        const match = _regexFromString.exec(str);
        if (!match) {
          return void 0;
        }
        const [, name] = match;
        return { id: name };
      }
      ThemeIcon2.fromString = fromString;
      function fromId(id2) {
        return { id: id2 };
      }
      ThemeIcon2.fromId = fromId;
      function modify(icon, modifier) {
        let id2 = icon.id;
        const tildeIndex = id2.lastIndexOf("~");
        if (tildeIndex !== -1) {
          id2 = id2.substring(0, tildeIndex);
        }
        if (modifier) {
          id2 = `${id2}~${modifier}`;
        }
        return { id: id2 };
      }
      ThemeIcon2.modify = modify;
      function getModifier(icon) {
        const tildeIndex = icon.id.lastIndexOf("~");
        if (tildeIndex !== -1) {
          return icon.id.substring(tildeIndex + 1);
        }
        return void 0;
      }
      ThemeIcon2.getModifier = getModifier;
      function isEqual3(ti1, ti2) {
        var _a4, _b2;
        return ti1.id === ti2.id && ((_a4 = ti1.color) === null || _a4 === void 0 ? void 0 : _a4.id) === ((_b2 = ti2.color) === null || _b2 === void 0 ? void 0 : _b2.id);
      }
      ThemeIcon2.isEqual = isEqual3;
    })(ThemeIcon || (ThemeIcon = {}));
  }
});

// node_modules/monaco-editor/esm/vs/base/common/uuid.js
function isUUID(value) {
  return _UUIDPattern.test(value);
}
var _UUIDPattern, generateUuid;
var init_uuid = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/uuid.js"() {
    _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    generateUuid = function() {
      if (typeof crypto === "object" && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID.bind(crypto);
      }
      let getRandomValues;
      if (typeof crypto === "object" && typeof crypto.getRandomValues === "function") {
        getRandomValues = crypto.getRandomValues.bind(crypto);
      } else {
        getRandomValues = function(bucket) {
          for (let i = 0; i < bucket.length; i++) {
            bucket[i] = Math.floor(Math.random() * 256);
          }
          return bucket;
        };
      }
      const _data = new Uint8Array(16);
      const _hex = [];
      for (let i = 0; i < 256; i++) {
        _hex.push(i.toString(16).padStart(2, "0"));
      }
      return function generateUuid2() {
        getRandomValues(_data);
        _data[6] = _data[6] & 15 | 64;
        _data[8] = _data[8] & 63 | 128;
        let i = 0;
        let result = "";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += "-";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += "-";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += "-";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += "-";
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        result += _hex[_data[i++]];
        return result;
      };
    }();
  }
});

// node_modules/monaco-editor/esm/vs/base/common/filters.js
function or(...filter2) {
  return function(word, wordToMatchAgainst) {
    for (let i = 0, len = filter2.length; i < len; i++) {
      const match = filter2[i](word, wordToMatchAgainst);
      if (match) {
        return match;
      }
    }
    return null;
  };
}
function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
    return null;
  }
  let matches;
  if (ignoreCase) {
    matches = startsWithIgnoreCase(wordToMatchAgainst, word);
  } else {
    matches = wordToMatchAgainst.indexOf(word) === 0;
  }
  if (!matches) {
    return null;
  }
  return word.length > 0 ? [{ start: 0, end: word.length }] : [];
}
function matchesContiguousSubString(word, wordToMatchAgainst) {
  const index2 = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
  if (index2 === -1) {
    return null;
  }
  return [{ start: index2, end: index2 + word.length }];
}
function matchesSubString(word, wordToMatchAgainst) {
  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
}
function _matchesSubString(word, wordToMatchAgainst, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === wordToMatchAgainst.length) {
    return null;
  } else {
    if (word[i] === wordToMatchAgainst[j]) {
      let result = null;
      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
        return join2({ start: j, end: j + 1 }, result);
      }
      return null;
    }
    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
  }
}
function isLower(code) {
  return 97 <= code && code <= 122;
}
function isUpper(code) {
  return 65 <= code && code <= 90;
}
function isNumber2(code) {
  return 48 <= code && code <= 57;
}
function isWhitespace(code) {
  return code === 32 || code === 9 || code === 10 || code === 13;
}
function isWordSeparator(code) {
  return isWhitespace(code) || wordSeparators.has(code);
}
function charactersMatch(codeA, codeB) {
  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);
}
function isAlphanumeric(code) {
  return isLower(code) || isUpper(code) || isNumber2(code);
}
function join2(head, tail3) {
  if (tail3.length === 0) {
    tail3 = [head];
  } else if (head.end === tail3[0].start) {
    tail3[0].start = head.start;
  } else {
    tail3.unshift(head);
  }
  return tail3;
}
function nextAnchor(camelCaseWord, start) {
  for (let i = start; i < camelCaseWord.length; i++) {
    const c = camelCaseWord.charCodeAt(i);
    if (isUpper(c) || isNumber2(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {
      return i;
    }
  }
  return camelCaseWord.length;
}
function _matchesCamelCase(word, camelCaseWord, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === camelCaseWord.length) {
    return null;
  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {
    return null;
  } else {
    let result = null;
    let nextUpperIndex = j + 1;
    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
      nextUpperIndex++;
    }
    return result === null ? null : join2({ start: j, end: j + 1 }, result);
  }
}
function analyzeCamelCaseWord(word) {
  let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);
    if (isUpper(code)) {
      upper++;
    }
    if (isLower(code)) {
      lower++;
    }
    if (isAlphanumeric(code)) {
      alpha++;
    }
    if (isNumber2(code)) {
      numeric++;
    }
  }
  const upperPercent = upper / word.length;
  const lowerPercent = lower / word.length;
  const alphaPercent = alpha / word.length;
  const numericPercent = numeric / word.length;
  return { upperPercent, lowerPercent, alphaPercent, numericPercent };
}
function isUpperCaseWord(analysis) {
  const { upperPercent, lowerPercent } = analysis;
  return lowerPercent === 0 && upperPercent > 0.6;
}
function isCamelCaseWord(analysis) {
  const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;
  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
}
function isCamelCasePattern(word) {
  let upper = 0, lower = 0, code = 0, whitespace = 0;
  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);
    if (isUpper(code)) {
      upper++;
    }
    if (isLower(code)) {
      lower++;
    }
    if (isWhitespace(code)) {
      whitespace++;
    }
  }
  if ((upper === 0 || lower === 0) && whitespace === 0) {
    return word.length <= 30;
  } else {
    return upper <= 5;
  }
}
function matchesCamelCase(word, camelCaseWord) {
  if (!camelCaseWord) {
    return null;
  }
  camelCaseWord = camelCaseWord.trim();
  if (camelCaseWord.length === 0) {
    return null;
  }
  if (!isCamelCasePattern(word)) {
    return null;
  }
  if (camelCaseWord.length > 60) {
    return null;
  }
  const analysis = analyzeCamelCaseWord(camelCaseWord);
  if (!isCamelCaseWord(analysis)) {
    if (!isUpperCaseWord(analysis)) {
      return null;
    }
    camelCaseWord = camelCaseWord.toLowerCase();
  }
  let result = null;
  let i = 0;
  word = word.toLowerCase();
  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {
    i = nextAnchor(camelCaseWord, i + 1);
  }
  return result;
}
function matchesWords(word, target, contiguous = false) {
  if (!target || target.length === 0) {
    return null;
  }
  let result = null;
  let i = 0;
  word = word.toLowerCase();
  target = target.toLowerCase();
  while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {
    i = nextWord(target, i + 1);
  }
  return result;
}
function _matchesWords(word, target, i, j, contiguous) {
  if (i === word.length) {
    return [];
  } else if (j === target.length) {
    return null;
  } else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {
    return null;
  } else {
    let result = null;
    let nextWordIndex = j + 1;
    result = _matchesWords(word, target, i + 1, j + 1, contiguous);
    if (!contiguous) {
      while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {
        result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);
        nextWordIndex++;
      }
    }
    if (!result) {
      return null;
    }
    if (word.charCodeAt(i) !== target.charCodeAt(j)) {
      return result;
    }
    return join2({ start: j, end: j + 1 }, result);
  }
}
function nextWord(word, start) {
  for (let i = start; i < word.length; i++) {
    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {
      return i;
    }
  }
  return word.length;
}
function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {
  if (typeof word !== "string" || typeof wordToMatchAgainst !== "string") {
    return null;
  }
  let regexp = fuzzyRegExpCache.get(word);
  if (!regexp) {
    regexp = new RegExp(convertSimple2RegExpPattern(word), "i");
    fuzzyRegExpCache.set(word, regexp);
  }
  const match = regexp.exec(wordToMatchAgainst);
  if (match) {
    return [{ start: match.index, end: match.index + match[0].length }];
  }
  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);
}
function matchesFuzzy2(pattern, word) {
  const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });
  return score ? createMatches(score) : null;
}
function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {
  const max = Math.min(13, pattern.length);
  for (; patternPos < max; patternPos++) {
    const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });
    if (result) {
      return result;
    }
  }
  return [0, wordPos];
}
function createMatches(score) {
  if (typeof score === "undefined") {
    return [];
  }
  const res = [];
  const wordPos = score[1];
  for (let i = score.length - 1; i > 1; i--) {
    const pos = score[i] + wordPos;
    const last = res[res.length - 1];
    if (last && last.end === pos) {
      last.end = pos + 1;
    } else {
      res.push({ start: pos, end: pos + 1 });
    }
  }
  return res;
}
function initTable() {
  const table = [];
  const row = [];
  for (let i = 0; i <= _maxLen; i++) {
    row[i] = 0;
  }
  for (let i = 0; i <= _maxLen; i++) {
    table.push(row.slice(0));
  }
  return table;
}
function initArr(maxLen) {
  const row = [];
  for (let i = 0; i <= maxLen; i++) {
    row[i] = 0;
  }
  return row;
}
function printTable(table, pattern, patternLen, word, wordLen) {
  function pad(s, n, pad2 = " ") {
    while (s.length < n) {
      s = pad2 + s;
    }
    return s;
  }
  let ret = ` |   |${word.split("").map((c) => pad(c, 3)).join("|")}
`;
  for (let i = 0; i <= patternLen; i++) {
    if (i === 0) {
      ret += " |";
    } else {
      ret += `${pattern[i - 1]}|`;
    }
    ret += table[i].slice(0, wordLen + 1).map((n) => pad(n.toString(), 3)).join("|") + "\n";
  }
  return ret;
}
function printTables(pattern, patternStart, word, wordStart) {
  pattern = pattern.substr(patternStart);
  word = word.substr(wordStart);
  console.log(printTable(_table, pattern, pattern.length, word, word.length));
  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));
  console.log(printTable(_diag, pattern, pattern.length, word, word.length));
}
function isSeparatorAtPos(value, index2) {
  if (index2 < 0 || index2 >= value.length) {
    return false;
  }
  const code = value.codePointAt(index2);
  switch (code) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
    case 60:
    case 62:
    case 40:
    case 41:
    case 91:
    case 93:
    case 123:
    case 125:
      return true;
    case void 0:
      return false;
    default:
      if (isEmojiImprecise(code)) {
        return true;
      }
      return false;
  }
}
function isWhitespaceAtPos(value, index2) {
  if (index2 < 0 || index2 >= value.length) {
    return false;
  }
  const code = value.charCodeAt(index2);
  switch (code) {
    case 32:
    case 9:
      return true;
    default:
      return false;
  }
}
function isUpperCaseAtPos(pos, word, wordLow) {
  return word[pos] !== wordLow[pos];
}
function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {
  while (patternPos < patternLen && wordPos < wordLen) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      if (fillMinWordPosArr) {
        _minWordMatchPos[patternPos] = wordPos;
      }
      patternPos += 1;
    }
    wordPos += 1;
  }
  return patternPos === patternLen;
}
function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options = FuzzyScoreOptions.default) {
  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;
  const wordLen = word.length > _maxLen ? _maxLen : word.length;
  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {
    return void 0;
  }
  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {
    return void 0;
  }
  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);
  let row = 1;
  let column = 1;
  let patternPos = patternStart;
  let wordPos = wordStart;
  const hasStrongFirstMatch = [false];
  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {
    const minWordMatchPos = _minWordMatchPos[patternPos];
    const maxWordMatchPos = _maxWordMatchPos[patternPos];
    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;
    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {
      let score = Number.MIN_SAFE_INTEGER;
      let canComeDiag = false;
      if (wordPos <= maxWordMatchPos) {
        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);
      }
      let diagScore = 0;
      if (score !== Number.MAX_SAFE_INTEGER) {
        canComeDiag = true;
        diagScore = score + _table[row - 1][column - 1];
      }
      const canComeLeft = wordPos > minWordMatchPos;
      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0;
      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;
      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0;
      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {
        _table[row][column] = leftLeftScore;
        _arrows[row][column] = 3;
        _diag[row][column] = 0;
      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {
        _table[row][column] = leftScore;
        _arrows[row][column] = 2;
        _diag[row][column] = 0;
      } else if (canComeDiag) {
        _table[row][column] = diagScore;
        _arrows[row][column] = 1;
        _diag[row][column] = _diag[row - 1][column - 1] + 1;
      } else {
        throw new Error(`not possible`);
      }
    }
  }
  if (_debug) {
    printTables(pattern, patternStart, word, wordStart);
  }
  if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {
    return void 0;
  }
  row--;
  column--;
  const result = [_table[row][column], wordStart];
  let backwardsDiagLength = 0;
  let maxMatchColumn = 0;
  while (row >= 1) {
    let diagColumn = column;
    do {
      const arrow = _arrows[row][diagColumn];
      if (arrow === 3) {
        diagColumn = diagColumn - 2;
      } else if (arrow === 2) {
        diagColumn = diagColumn - 1;
      } else {
        break;
      }
    } while (diagColumn >= 1);
    if (backwardsDiagLength > 1 && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) && backwardsDiagLength + 1 > _diag[row][diagColumn]) {
      diagColumn = column;
    }
    if (diagColumn === column) {
      backwardsDiagLength++;
    } else {
      backwardsDiagLength = 1;
    }
    if (!maxMatchColumn) {
      maxMatchColumn = diagColumn;
    }
    row--;
    column = diagColumn - 1;
    result.push(column);
  }
  if (wordLen === patternLen && options.boostFullMatch) {
    result[0] += 2;
  }
  const skippedCharsCount = maxMatchColumn - patternLen;
  result[0] -= skippedCharsCount;
  return result;
}
function _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {
  let patternPos = patternLen - 1;
  let wordPos = wordLen - 1;
  while (patternPos >= patternStart && wordPos >= wordStart) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      _maxWordMatchPos[patternPos] = wordPos;
      patternPos--;
    }
    wordPos--;
  }
}
function _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {
  if (patternLow[patternPos] !== wordLow[wordPos]) {
    return Number.MIN_SAFE_INTEGER;
  }
  let score = 1;
  let isGapLocation = false;
  if (wordPos === patternPos - patternStart) {
    score = pattern[patternPos] === word[wordPos] ? 7 : 5;
  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {
    score = pattern[patternPos] === word[wordPos] ? 7 : 5;
    isGapLocation = true;
  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {
    score = 5;
  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {
    score = 5;
    isGapLocation = true;
  }
  if (score > 1 && patternPos === patternStart) {
    outFirstMatchStrong[0] = true;
  }
  if (!isGapLocation) {
    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);
  }
  if (patternPos === patternStart) {
    if (wordPos > wordStart) {
      score -= isGapLocation ? 3 : 5;
    }
  } else {
    if (newMatchStart) {
      score += isGapLocation ? 2 : 0;
    } else {
      score += isGapLocation ? 0 : 1;
    }
  }
  if (wordPos + 1 === wordLen) {
    score -= isGapLocation ? 3 : 5;
  }
  return score;
}
function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {
  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);
}
function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {
  let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);
  if (top && !aggressive) {
    return top;
  }
  if (pattern.length >= 3) {
    const tries = Math.min(7, pattern.length - 1);
    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {
      const newPattern = nextTypoPermutation(pattern, movingPatternPos);
      if (newPattern) {
        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);
        if (candidate) {
          candidate[0] -= 3;
          if (!top || candidate[0] > top[0]) {
            top = candidate;
          }
        }
      }
    }
  }
  return top;
}
function nextTypoPermutation(pattern, patternPos) {
  if (patternPos + 1 >= pattern.length) {
    return void 0;
  }
  const swap1 = pattern[patternPos];
  const swap2 = pattern[patternPos + 1];
  if (swap1 === swap2) {
    return void 0;
  }
  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);
}
var matchesStrictPrefix, matchesPrefix, wordSeparators, fuzzyContiguousFilter, fuzzySeparateFilter, fuzzyRegExpCache, _maxLen, _minWordMatchPos, _maxWordMatchPos, _diag, _table, _arrows, _debug, FuzzyScore, FuzzyScoreOptions;
var init_filters = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/filters.js"() {
    init_map();
    init_strings();
    matchesStrictPrefix = _matchesPrefix.bind(void 0, false);
    matchesPrefix = _matchesPrefix.bind(void 0, true);
    wordSeparators = /* @__PURE__ */ new Set();
    "()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => wordSeparators.add(s.charCodeAt(0)));
    fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);
    fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);
    fuzzyRegExpCache = new LRUCache(1e4);
    _maxLen = 128;
    _minWordMatchPos = initArr(2 * _maxLen);
    _maxWordMatchPos = initArr(2 * _maxLen);
    _diag = initTable();
    _table = initTable();
    _arrows = initTable();
    _debug = false;
    (function(FuzzyScore2) {
      FuzzyScore2.Default = [-100, 0];
      function isDefault(score) {
        return !score || score.length === 2 && score[0] === -100 && score[1] === 0;
      }
      FuzzyScore2.isDefault = isDefault;
    })(FuzzyScore || (FuzzyScore = {}));
    FuzzyScoreOptions = class {
      constructor(firstMatchCanBeWeak, boostFullMatch) {
        this.firstMatchCanBeWeak = firstMatchCanBeWeak;
        this.boostFullMatch = boostFullMatch;
      }
    };
    FuzzyScoreOptions.default = { boostFullMatch: true, firstMatchCanBeWeak: false };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/iconLabels.js
function escapeIcons(text) {
  return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\${match}`);
}
function markdownEscapeEscapedIcons(text) {
  return text.replace(markdownEscapedIconsRegex, (match) => `\\${match}`);
}
function stripIcons(text) {
  if (text.indexOf(iconStartMarker) === -1) {
    return text;
  }
  return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || "");
}
function getCodiconAriaLabel(text) {
  if (!text) {
    return "";
  }
  return text.replace(/\$\((.*?)\)/g, (_match, codiconName) => ` ${codiconName} `).trim();
}
function parseLabelWithIcons(input) {
  _parseIconsRegex.lastIndex = 0;
  let text = "";
  const iconOffsets = [];
  let iconsOffset = 0;
  while (true) {
    const pos = _parseIconsRegex.lastIndex;
    const match = _parseIconsRegex.exec(input);
    const chars = input.substring(pos, match === null || match === void 0 ? void 0 : match.index);
    if (chars.length > 0) {
      text += chars;
      for (let i = 0; i < chars.length; i++) {
        iconOffsets.push(iconsOffset);
      }
    }
    if (!match) {
      break;
    }
    iconsOffset += match[0].length;
  }
  return { text, iconOffsets };
}
function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {
  const { text, iconOffsets } = target;
  if (!iconOffsets || iconOffsets.length === 0) {
    return matchesFuzzy(query, text, enableSeparateSubstringMatching);
  }
  const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, " ");
  const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;
  const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);
  if (matches) {
    for (const match of matches) {
      const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] + leadingWhitespaceOffset;
      match.start += iconOffset;
      match.end += iconOffset;
    }
  }
  return matches;
}
var iconStartMarker, iconsRegex, escapeIconsRegex, markdownEscapedIconsRegex, stripIconsRegex, _parseIconsRegex;
var init_iconLabels = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/iconLabels.js"() {
    init_filters();
    init_strings();
    init_themables();
    iconStartMarker = "$(";
    iconsRegex = new RegExp(`\\$\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\)`, "g");
    escapeIconsRegex = new RegExp(`(\\\\)?${iconsRegex.source}`, "g");
    markdownEscapedIconsRegex = new RegExp(`\\\\${iconsRegex.source}`, "g");
    stripIconsRegex = new RegExp(`(\\s)?(\\\\)?${iconsRegex.source}(\\s)?`, "g");
    _parseIconsRegex = new RegExp(`\\$\\(${ThemeIcon.iconNameCharacter}+\\)`, "g");
  }
});

// node_modules/monaco-editor/esm/vs/base/common/htmlContent.js
function isEmptyMarkdownString(oneOrMany) {
  if (isMarkdownString(oneOrMany)) {
    return !oneOrMany.value;
  } else if (Array.isArray(oneOrMany)) {
    return oneOrMany.every(isEmptyMarkdownString);
  } else {
    return true;
  }
}
function isMarkdownString(thing) {
  if (thing instanceof MarkdownString) {
    return true;
  } else if (thing && typeof thing === "object") {
    return typeof thing.value === "string" && (typeof thing.isTrusted === "boolean" || typeof thing.isTrusted === "object" || thing.isTrusted === void 0) && (typeof thing.supportThemeIcons === "boolean" || thing.supportThemeIcons === void 0);
  }
  return false;
}
function markdownStringEqual(a, b) {
  if (a === b) {
    return true;
  } else if (!a || !b) {
    return false;
  } else {
    return a.value === b.value && a.isTrusted === b.isTrusted && a.supportThemeIcons === b.supportThemeIcons && a.supportHtml === b.supportHtml && (a.baseUri === b.baseUri || !!a.baseUri && !!b.baseUri && isEqual2(URI.from(a.baseUri), URI.from(b.baseUri)));
  }
}
function escapeMarkdownSyntaxTokens(text) {
  return text.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
}
function escapeDoubleQuotes(input) {
  return input.replace(/"/g, "&quot;");
}
function removeMarkdownEscapes(text) {
  if (!text) {
    return text;
  }
  return text.replace(/\\([\\`*_{}[\]()#+\-.!~])/g, "$1");
}
function parseHrefAndDimensions(href) {
  const dimensions = [];
  const splitted = href.split("|").map((s) => s.trim());
  href = splitted[0];
  const parameters = splitted[1];
  if (parameters) {
    const heightFromParams = /height=(\d+)/.exec(parameters);
    const widthFromParams = /width=(\d+)/.exec(parameters);
    const height = heightFromParams ? heightFromParams[1] : "";
    const width = widthFromParams ? widthFromParams[1] : "";
    const widthIsFinite = isFinite(parseInt(width));
    const heightIsFinite = isFinite(parseInt(height));
    if (widthIsFinite) {
      dimensions.push(`width="${width}"`);
    }
    if (heightIsFinite) {
      dimensions.push(`height="${height}"`);
    }
  }
  return { href, dimensions };
}
var MarkdownString;
var init_htmlContent = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/htmlContent.js"() {
    init_errors();
    init_iconLabels();
    init_resources();
    init_strings();
    init_uri();
    MarkdownString = class {
      constructor(value = "", isTrustedOrOptions = false) {
        var _a4, _b2, _c2;
        this.value = value;
        if (typeof this.value !== "string") {
          throw illegalArgument("value");
        }
        if (typeof isTrustedOrOptions === "boolean") {
          this.isTrusted = isTrustedOrOptions;
          this.supportThemeIcons = false;
          this.supportHtml = false;
        } else {
          this.isTrusted = (_a4 = isTrustedOrOptions.isTrusted) !== null && _a4 !== void 0 ? _a4 : void 0;
          this.supportThemeIcons = (_b2 = isTrustedOrOptions.supportThemeIcons) !== null && _b2 !== void 0 ? _b2 : false;
          this.supportHtml = (_c2 = isTrustedOrOptions.supportHtml) !== null && _c2 !== void 0 ? _c2 : false;
        }
      }
      appendText(value, newlineStyle = 0) {
        this.value += escapeMarkdownSyntaxTokens(this.supportThemeIcons ? escapeIcons(value) : value).replace(/([ \t]+)/g, (_match, g1) => "&nbsp;".repeat(g1.length)).replace(/\>/gm, "\\>").replace(/\n/g, newlineStyle === 1 ? "\\\n" : "\n\n");
        return this;
      }
      appendMarkdown(value) {
        this.value += value;
        return this;
      }
      appendCodeblock(langId, code) {
        this.value += "\n```";
        this.value += langId;
        this.value += "\n";
        this.value += code;
        this.value += "\n```\n";
        return this;
      }
      appendLink(target, label, title) {
        this.value += "[";
        this.value += this._escape(label, "]");
        this.value += "](";
        this.value += this._escape(String(target), ")");
        if (title) {
          this.value += ` "${this._escape(this._escape(title, '"'), ")")}"`;
        }
        this.value += ")";
        return this;
      }
      _escape(value, ch) {
        const r = new RegExp(escapeRegExpCharacters(ch), "g");
        return value.replace(r, (match, offset) => {
          if (value.charAt(offset - 1) !== "\\") {
            return `\\${match}`;
          } else {
            return match;
          }
        });
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/mime.js
function normalizeMimeType(mimeType, strict) {
  var _a4;
  const match = _simplePattern.exec(mimeType);
  if (!match) {
    return strict ? void 0 : mimeType;
  }
  return `${match[1].toLowerCase()}/${match[2].toLowerCase()}${(_a4 = match[3]) !== null && _a4 !== void 0 ? _a4 : ""}`;
}
var Mimes, _simplePattern;
var init_mime = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/mime.js"() {
    init_path();
    Mimes = Object.freeze({
      text: "text/plain",
      binary: "application/octet-stream",
      unknown: "application/unknown",
      markdown: "text/markdown",
      latex: "text/latex",
      uriList: "text/uri-list"
    });
    _simplePattern = /^(.+)\/(.+?)(;.+)?$/;
  }
});

export {
  errorHandler,
  setUnexpectedErrorHandler,
  onUnexpectedError,
  onUnexpectedExternalError,
  transformErrorForSerialization,
  isCancellationError,
  CancellationError,
  canceled,
  illegalArgument,
  illegalState,
  readonly,
  disposed,
  getErrorMessage,
  NotImplementedError,
  NotSupportedError,
  ErrorNoTelemetry,
  BugIndicatingError,
  init_errors,
  once,
  init_functional,
  Iterable,
  init_iterator,
  markAsSingleton,
  isDisposable,
  dispose,
  combinedDisposable,
  toDisposable,
  DisposableStore,
  Disposable,
  MutableDisposable,
  RefCountedDisposable,
  ReferenceCollection,
  AsyncReferenceCollection,
  ImmortalReference,
  DisposableMap,
  init_lifecycle,
  LinkedList,
  init_linkedList,
  StopWatch,
  init_stopwatch,
  Event,
  Emitter,
  createEventDeliveryQueue,
  AsyncEmitter,
  PauseableEmitter,
  DebounceEmitter,
  MicrotaskEmitter,
  EventMultiplexer,
  EventBufferer,
  Relay,
  init_event,
  localize,
  init_nls,
  LANGUAGE_DEFAULT,
  PlatformToString,
  isWindows,
  isMacintosh,
  isLinux,
  isNative,
  isWeb,
  isWebWorker,
  isIOS,
  isMobile,
  platform,
  language,
  Language,
  setTimeout0,
  OS,
  isLittleEndian,
  isChrome,
  isFirefox,
  isSafari,
  init_platform,
  cwd,
  env,
  platform2,
  init_process,
  win32,
  posix,
  normalize,
  isAbsolute,
  join,
  relative,
  dirname,
  basename,
  extname,
  sep,
  init_path,
  URI,
  init_uri,
  CancellationToken,
  CancellationTokenSource,
  init_cancellation,
  CachedFunction,
  init_cache,
  Lazy,
  init_lazy,
  isFalsyOrWhitespace,
  format2 as format,
  format22 as format2,
  escape,
  escapeRegExpCharacters,
  count,
  trim,
  ltrim,
  rtrim,
  stripWildcards,
  createRegExp,
  regExpLeadsToEndlessLoop,
  splitLines,
  firstNonWhitespaceIndex,
  getLeadingWhitespace,
  lastNonWhitespaceIndex,
  replaceAsync,
  compare,
  compareSubstring,
  compareIgnoreCase,
  isAsciiDigit,
  isLowerAsciiLetter,
  isUpperAsciiLetter,
  equalsIgnoreCase,
  startsWithIgnoreCase,
  commonPrefixLength,
  commonSuffixLength,
  isHighSurrogate,
  isLowSurrogate,
  getNextCodePoint,
  CodePointIterator,
  GraphemeIterator,
  nextCharLength,
  prevCharLength,
  getCharContainingOffset,
  containsRTL,
  isBasicASCII,
  UNUSUAL_LINE_TERMINATORS,
  containsUnusualLineTerminators,
  isFullWidthCharacter,
  isEmojiImprecise,
  lcut,
  removeAnsiEscapeCodes,
  UTF8_BOM_CHARACTER,
  startsWithUTF8BOM,
  fuzzyContains,
  containsUppercaseCharacter,
  getNLines,
  singleLetterHash,
  getLeftDeleteOffset,
  noBreakWhitespace,
  AmbiguousCharacters,
  InvisibleCharacters,
  init_strings,
  _util,
  IInstantiationService,
  createDecorator,
  refineServiceDecorator,
  init_instantiation,
  getOrSet,
  ResourceMap,
  ResourceSet,
  LRUCache,
  init_map,
  Schemas,
  RemoteAuthorities,
  nodeModulesPath,
  nodeModulesAsarPath,
  nodeModulesAsarUnpackedPath,
  FileAccess,
  COI,
  init_network,
  getRemoteAuthority,
  getRemoteName,
  getRemoteServerRootPath,
  init_remoteHosts,
  UNDEFINED_PUBLISHER,
  ALL_EXTENSION_KINDS,
  EXTENSION_CATEGORIES,
  ExtensionIdentifier,
  ExtensionIdentifierSet,
  ExtensionIdentifierMap,
  init_extensions,
  isString,
  isStringArray,
  isObject,
  isNumber,
  isIterable,
  isBoolean,
  isUndefined,
  isDefined,
  isUndefinedOrNull,
  assertType,
  assertIsDefined,
  isEmptyObject,
  isFunction,
  validateConstraints,
  validateConstraint,
  init_types,
  toSlashes,
  isUNC,
  isValidBasename,
  isEqual,
  isEqualOrParent,
  hasDriveLetter,
  getDriveLetter,
  indexOfPath,
  parseLineAndColumnAware,
  init_extpath,
  originalFSPath,
  ExtUri,
  extUri,
  extUriBiasedIgnorePathCase,
  extUriIgnorePathCase,
  isEqual2,
  isEqualOrParent2,
  basenameOrAuthority,
  basename2,
  extname2,
  dirname2,
  joinPath,
  normalizePath,
  relativePath,
  resolvePath,
  isAbsolutePath,
  isEqualAuthority,
  removeTrailingPathSeparator,
  distinctParents,
  DataUri,
  toLocalResource,
  init_resources,
  tail,
  tail2,
  equals,
  removeFastWithoutKeepingOrder,
  binarySearch,
  findFirstInSorted,
  quickSelect,
  groupBy,
  sortedDiff,
  delta,
  coalesce,
  coalesceInPlace,
  isFalsyOrEmpty,
  isNonEmptyArray,
  distinct,
  findLast,
  findLastIndex,
  firstOrDefault,
  lastOrDefault,
  flatten,
  range,
  index,
  insert,
  arrayInsert,
  pushToStart,
  pushToEnd,
  pushMany,
  mapArrayOrNot,
  asArray,
  mapFind,
  insertInto,
  splice,
  CompareResult,
  compareBy,
  tieBreakComparators,
  numberComparator,
  booleanComparator,
  reverseOrder,
  findMaxBy,
  findLastMaxBy,
  findMinBy,
  findMaxIdxBy,
  ArrayQueue,
  CallbackIterable,
  init_arrays,
  TernarySearchTree,
  init_ternarySearchTree,
  IFileService,
  FileType,
  FilePermission,
  hasReadWriteCapability,
  hasFileFolderCopyCapability,
  hasFileCloneCapability,
  hasOpenReadWriteCloseCapability,
  hasFileReadStreamCapability,
  hasFileAtomicReadCapability,
  hasReadonlyCapability,
  FileSystemProviderErrorCode,
  FileSystemProviderError,
  createFileSystemProviderError,
  ensureFileSystemProviderError,
  markAsFileSystemProviderError,
  toFileSystemProviderErrorCode,
  toFileOperationResult,
  FileOperationEvent,
  FileChangesEvent,
  FileOperationError,
  TooLargeFileOperationError,
  NotModifiedSinceFileOperationError,
  AutoSaveConfiguration,
  HotExitConfiguration,
  FILES_ASSOCIATIONS_CONFIG,
  FILES_EXCLUDE_CONFIG,
  FILES_READONLY_INCLUDE_CONFIG,
  FILES_READONLY_EXCLUDE_CONFIG,
  FILES_READONLY_FROM_PERMISSIONS_CONFIG,
  FileKind,
  ETAG_DISABLED,
  etag,
  whenProviderRegistered,
  ByteSize,
  init_files,
  toErrorMessage,
  createErrorWithActions,
  init_errorMessage,
  hash,
  doHash,
  stringHash,
  StringSHA1,
  init_hash,
  setConstant,
  ContextKeyExpr,
  validateWhenClauses,
  expressionsAreEqualWithConstantSubstitution,
  ContextKeyEqualsExpr,
  RawContextKey,
  IContextKeyService,
  implies,
  init_contextkey,
  ILogService,
  ILoggerService,
  isLogLevel,
  LogLevel,
  DEFAULT_LOG_LEVEL,
  log,
  AbstractMessageLogger,
  ConsoleLogger,
  MultiplexLogger,
  AbstractLoggerService,
  NullLogger,
  LogLevelToString,
  parseLogLevel,
  CONTEXT_LOG_LEVEL,
  init_log,
  ITelemetryService,
  ICustomEndpointTelemetryService,
  TELEMETRY_SETTING_ID,
  TELEMETRY_CRASH_REPORTER_SETTING_ID,
  TELEMETRY_OLD_SETTING_ID,
  init_telemetry,
  isReadableStream,
  isReadableBufferedStream,
  newWriteableStream,
  peekReadable,
  consumeStream,
  listenStream,
  peekStream,
  transform,
  init_stream,
  VSBuffer,
  readUInt16LE,
  writeUInt16LE,
  readUInt32BE,
  writeUInt32BE,
  readUInt8,
  writeUInt8,
  readableToBuffer,
  bufferToReadable,
  streamToBuffer,
  bufferedStreamToBuffer,
  bufferToStream,
  newWriteableBufferStream,
  prefixedBufferReadable,
  prefixedBufferStream,
  decodeBase64,
  encodeBase64,
  init_buffer,
  getCodiconFontCharacters,
  Codicon,
  init_codicons,
  ThemeColor,
  ThemeIcon,
  init_themables,
  isUUID,
  generateUuid,
  init_uuid,
  deepClone,
  deepFreeze,
  cloneAndChange,
  mixin,
  equals2,
  safeStringify,
  distinct2,
  filter,
  getAllMethodNames,
  createProxyObject,
  init_objects,
  OverviewRulerLane,
  GlyphMarginLane,
  MinimapPosition,
  InjectedTextCursorStops,
  TextModelResolvedOptions,
  FindMatch,
  isITextSnapshot,
  ValidAnnotatedEditOperation,
  SearchData,
  ApplyEditsResult,
  shouldSynchronizeModel,
  init_model,
  or,
  matchesPrefix,
  matchesContiguousSubString,
  matchesSubString,
  isUpper,
  matchesWords,
  matchesFuzzy,
  matchesFuzzy2,
  anyScore,
  createMatches,
  isPatternInWord,
  FuzzyScore,
  FuzzyScoreOptions,
  fuzzyScore,
  fuzzyScoreGracefulAggressive,
  init_filters,
  markdownEscapeEscapedIcons,
  stripIcons,
  getCodiconAriaLabel,
  parseLabelWithIcons,
  matchesFuzzyIconAware,
  init_iconLabels,
  MarkdownString,
  isEmptyMarkdownString,
  isMarkdownString,
  markdownStringEqual,
  escapeDoubleQuotes,
  removeMarkdownEscapes,
  parseHrefAndDimensions,
  init_htmlContent,
  Mimes,
  normalizeMimeType,
  init_mime,
  EDITOR_MODEL_DEFAULTS,
  init_textModelDefaults,
  DEFAULT_WORD_REGEXP,
  ensureValidWordDefinition,
  getWordAtText,
  init_wordHelper,
  MINIMAP_GUTTER_WIDTH,
  ConfigurationChangedEvent,
  ComputeOptionsMemory,
  ApplyUpdateResult,
  boolean,
  clampedInt,
  clampedFloat,
  stringSet,
  TextEditorCursorStyle,
  cursorStyleToString,
  EditorFontLigatures,
  EditorFontVariations,
  EditorLayoutInfoComputer,
  filterValidationDecorations,
  inUntrustedWorkspace,
  unicodeHighlightConfigKeys,
  EDITOR_FONT_DEFAULTS,
  editorOptionsRegistry,
  EditorOptions,
  init_editorOptions,
  IndentAction,
  StandardAutoClosingPairConditional,
  AutoClosingPairs,
  init_languageConfiguration
};
//# sourceMappingURL=chunk-N5MAMNNV.js.map
