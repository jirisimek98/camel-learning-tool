import {
  require_main,
  require_messageReader,
  require_messageWriter
} from "./chunk-H5BWLXIX.js";
import {
  __publicField,
  __toESM
} from "./chunk-PGWBAY6J.js";

// node_modules/vscode-ws-jsonrpc/lib/disposable.js
var DisposableCollection = class {
  constructor() {
    __publicField(this, "disposables", []);
  }
  dispose() {
    while (this.disposables.length !== 0) {
      this.disposables.pop().dispose();
    }
  }
  push(disposable) {
    const disposables = this.disposables;
    disposables.push(disposable);
    return {
      dispose() {
        const index = disposables.indexOf(disposable);
        if (index !== -1) {
          disposables.splice(index, 1);
        }
      }
    };
  }
};

// node_modules/vscode-ws-jsonrpc/lib/socket/reader.js
var import_messageReader = __toESM(require_messageReader(), 1);
var WebSocketMessageReader = class extends import_messageReader.AbstractMessageReader {
  constructor(socket) {
    super();
    __publicField(this, "socket");
    __publicField(this, "state", "initial");
    __publicField(this, "callback");
    __publicField(this, "events", []);
    this.socket = socket;
    this.socket.onMessage((message) => this.readMessage(message));
    this.socket.onError((error) => this.fireError(error));
    this.socket.onClose((code, reason) => {
      if (code !== 1e3) {
        const error = {
          name: "" + code,
          message: `Error during socket reconnect: code = ${code}, reason = ${reason}`
        };
        this.fireError(error);
      }
      this.fireClose();
    });
  }
  listen(callback) {
    if (this.state === "initial") {
      this.state = "listening";
      this.callback = callback;
      while (this.events.length !== 0) {
        const event = this.events.pop();
        if (event.message) {
          this.readMessage(event.message);
        } else if (event.error) {
          this.fireError(event.error);
        } else {
          this.fireClose();
        }
      }
    }
    return {
      dispose: () => {
        if (this.callback === callback) {
          this.callback = void 0;
        }
      }
    };
  }
  readMessage(message) {
    if (this.state === "initial") {
      this.events.splice(0, 0, { message });
    } else if (this.state === "listening") {
      try {
        const data = JSON.parse(message);
        this.callback(data);
      } catch (err) {
        const error = {
          name: "400",
          message: `Error during message parsing, reason = ${typeof err === "object" ? err.message : "unknown"}`
        };
        this.fireError(error);
      }
    }
  }
  fireError(error) {
    if (this.state === "initial") {
      this.events.splice(0, 0, { error });
    } else if (this.state === "listening") {
      super.fireError(error);
    }
  }
  fireClose() {
    if (this.state === "initial") {
      this.events.splice(0, 0, {});
    } else if (this.state === "listening") {
      super.fireClose();
    }
    this.state = "closed";
  }
};

// node_modules/vscode-ws-jsonrpc/lib/socket/writer.js
var import_messageWriter = __toESM(require_messageWriter(), 1);
var WebSocketMessageWriter = class extends import_messageWriter.AbstractMessageWriter {
  constructor(socket) {
    super();
    __publicField(this, "socket");
    __publicField(this, "errorCount", 0);
    this.socket = socket;
  }
  end() {
  }
  async write(msg) {
    try {
      const content = JSON.stringify(msg);
      this.socket.send(content);
    } catch (e) {
      this.errorCount++;
      this.fireError(e, msg, this.errorCount);
    }
  }
};

// node_modules/vscode-ws-jsonrpc/lib/socket/connection.js
var import_vscode_jsonrpc = __toESM(require_main(), 1);
function createWebSocketConnection(socket, logger) {
  const messageReader = new WebSocketMessageReader(socket);
  const messageWriter = new WebSocketMessageWriter(socket);
  const connection = (0, import_vscode_jsonrpc.createMessageConnection)(messageReader, messageWriter, logger);
  connection.onClose(() => connection.dispose());
  return connection;
}

// node_modules/vscode-ws-jsonrpc/lib/logger.js
var ConsoleLogger = class {
  error(message) {
    console.error(message);
  }
  warn(message) {
    console.warn(message);
  }
  info(message) {
    console.info(message);
  }
  log(message) {
    console.log(message);
  }
  debug(message) {
    console.debug(message);
  }
};

// node_modules/vscode-ws-jsonrpc/lib/connection.js
function listen(options) {
  const { webSocket, onConnection } = options;
  const logger = options.logger || new ConsoleLogger();
  webSocket.onopen = () => {
    const socket = toSocket(webSocket);
    const connection = createWebSocketConnection(socket, logger);
    onConnection(connection);
  };
}
function toSocket(webSocket) {
  return {
    send: (content) => webSocket.send(content),
    onMessage: (cb) => {
      webSocket.onmessage = (event) => cb(event.data);
    },
    onError: (cb) => {
      webSocket.onerror = (event) => {
        if ("message" in event) {
          cb(event.message);
        }
      };
    },
    onClose: (cb) => {
      webSocket.onclose = (event) => cb(event.code, event.reason);
    },
    dispose: () => webSocket.close()
  };
}
export {
  ConsoleLogger,
  DisposableCollection,
  WebSocketMessageReader,
  WebSocketMessageWriter,
  createWebSocketConnection,
  listen,
  toSocket
};
//# sourceMappingURL=vscode-ws-jsonrpc.js.map
