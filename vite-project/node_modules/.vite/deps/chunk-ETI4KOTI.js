import {
  __decorate,
  __param,
  getTelemetryLevel,
  init_telemetryUtils,
  init_tslib_es6,
  supportsTelemetry
} from "./chunk-GJDIUAXO.js";
import {
  AccessibilityHelpNLS,
  CodeActionController,
  CodeEditorWidget,
  CommandsRegistry,
  DeferredPromise,
  EditorCommand,
  EditorContextKeys,
  EditorExtensionsRegistry,
  EditorState,
  EventType,
  Extensions,
  Extensions2,
  IAccessibilityService,
  IClipboardService,
  IConfigurationService,
  IContextViewService,
  IEnvironmentService,
  IKeybindingService,
  ILanguageConfigurationService,
  ILanguageFeaturesService,
  ILanguageService,
  ILayoutService,
  IMenuService,
  IModelService,
  IOpenerService,
  IQuickInputService,
  IStorageService,
  IWorkspaceContextService,
  IdleValue,
  KnownSnippetVariableNames,
  LanguageService,
  MenuId,
  Placeholder,
  Range,
  Registry,
  SnippetController2,
  SnippetParser,
  StandardKeyboardEvent,
  Text,
  Variable,
  WorkbenchToolBar,
  addDisposableListener,
  alert,
  clearConfiguredLanguageAssociations,
  createAndFillInActionBarActions,
  getNodeType,
  init_actions,
  init_actions2,
  init_aria,
  init_async,
  init_commands,
  init_configuration,
  init_configurationRegistry,
  init_dom,
  init_editorContextKeys,
  init_editorExtensions,
  init_editorState,
  init_environment,
  init_jsonContributionRegistry,
  init_keyboardEvent,
  init_language,
  init_languageConfigurationRegistry,
  init_languageFeatures,
  init_model,
  init_opener,
  init_platform as init_platform2,
  init_range,
  mark,
  marked,
  parse3 as parse,
  registerConfiguredLanguageAssociation,
  registerEditorCommand,
  registerEditorContribution,
  registerIcon,
  runWhenIdle,
  setSnippetSuggestSupport,
  severity_default,
  showSimpleSuggestions,
  timeout,
  toAction
} from "./chunk-O3SOEW3V.js";
import {
  Codicon,
  ContextKeyExpr,
  Disposable,
  DisposableStore,
  EXTENSION_CATEGORIES,
  Emitter,
  Event,
  ExtensionIdentifier,
  ExtensionIdentifierMap,
  ExtensionIdentifierSet,
  FILES_ASSOCIATIONS_CONFIG,
  FileOperationError,
  FileType,
  IContextKeyService,
  IFileService,
  IInstantiationService,
  ILogService,
  Iterable,
  MarkdownString,
  RawContextKey,
  RemoteAuthorities,
  ResourceMap,
  Schemas,
  StopWatch,
  ThemeIcon,
  UNDEFINED_PUBLISHER,
  URI,
  VSBuffer,
  assertIsDefined,
  basename,
  basename2,
  combinedDisposable,
  compare,
  compareIgnoreCase,
  compareSubstring,
  createDecorator,
  createErrorWithActions,
  dirname2 as dirname,
  extname,
  extname2,
  firstNonWhitespaceIndex,
  format2,
  generateUuid,
  getRemoteServerRootPath,
  getWordAtText,
  init_arrays,
  init_buffer,
  init_codicons,
  init_contextkey,
  init_errorMessage,
  init_errors,
  init_event,
  init_extensions,
  init_files,
  init_filters,
  init_htmlContent,
  init_instantiation,
  init_iterator,
  init_lifecycle,
  init_log,
  init_map,
  init_network,
  init_nls,
  init_path,
  init_platform,
  init_remoteHosts,
  init_resources,
  init_stopwatch,
  init_strings,
  init_themables,
  init_types,
  init_uri,
  init_uuid,
  init_wordHelper,
  insertInto,
  isEqual2 as isEqual,
  isEqualOrParent2 as isEqualOrParent,
  isFalsyOrWhitespace,
  isMacintosh,
  isObject,
  isPatternInWord,
  isStringArray,
  isUUID,
  isUndefinedOrNull,
  isWeb,
  isWindows,
  joinPath,
  localize,
  onUnexpectedError,
  relativePath,
  tail,
  toDisposable
} from "./chunk-N5MAMNNV.js";

// node_modules/vscode/vscode/src/vs/platform/extensionManagement/common/extensionManagementUtil.js
init_strings();
init_extensions();
function areSameExtensions(a, b) {
  if (a.uuid && b.uuid) {
    return a.uuid === b.uuid;
  }
  if (a.id === b.id) {
    return true;
  }
  return compareIgnoreCase(a.id, b.id) === 0;
}
function getExtensionId(publisher, name) {
  return `${publisher}.${name}`;
}
function adoptToGalleryExtensionId(id) {
  return id.toLowerCase();
}
function getGalleryExtensionId(publisher, name) {
  return adoptToGalleryExtensionId(getExtensionId(publisher ?? UNDEFINED_PUBLISHER, name));
}

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensions.js
init_event();
init_uri();

// node_modules/vscode/vscode/src/vs/platform/extensionManagement/common/implicitActivationEvents.js
init_errors();
init_extensions();
var ImplicitActivationEventsImpl = class {
  constructor() {
    this._generators = /* @__PURE__ */ new Map();
    this._cache = /* @__PURE__ */ new WeakMap();
  }
  register(extensionPointName, generator) {
    this._generators.set(extensionPointName, generator);
  }
  readActivationEvents(extensionDescription) {
    if (!this._cache.has(extensionDescription)) {
      this._cache.set(extensionDescription, this._readActivationEvents(extensionDescription));
    }
    return this._cache.get(extensionDescription);
  }
  createActivationEventsMap(extensionDescriptions) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const extensionDescription of extensionDescriptions) {
      const activationEvents = this.readActivationEvents(extensionDescription);
      if (activationEvents.length > 0) {
        result[ExtensionIdentifier.toKey(extensionDescription.identifier)] = activationEvents;
      }
    }
    return result;
  }
  _readActivationEvents(desc) {
    if (typeof desc.main === "undefined" && typeof desc.browser === "undefined") {
      return [];
    }
    const activationEvents = Array.isArray(desc.activationEvents) ? desc.activationEvents.slice(0) : [];
    if (!desc.contributes) {
      return activationEvents;
    }
    for (const extPointName in desc.contributes) {
      const generator = this._generators.get(extPointName);
      if (!generator) {
        continue;
      }
      const contrib = desc.contributes[extPointName];
      const contribArr = Array.isArray(contrib) ? contrib : [contrib];
      try {
        generator(contribArr, activationEvents);
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    return activationEvents;
  }
};
var ImplicitActivationEvents = new ImplicitActivationEventsImpl();

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensions.js
init_extensions();
init_instantiation();
var nullExtensionDescription = Object.freeze({
  identifier: new ExtensionIdentifier("nullExtensionDescription"),
  name: "Null Extension Description",
  version: "0.0.0",
  publisher: "vscode",
  engines: { vscode: "" },
  extensionLocation: URI.parse("void:location"),
  isBuiltin: false,
  targetPlatform: "undefined",
  isUserBuiltin: false,
  isUnderDevelopment: false
});
var IExtensionService = createDecorator("extensionService");
var MissingExtensionDependency = class {
  constructor(dependency) {
    this.dependency = dependency;
  }
};
var ExtensionHostExtensions = class {
  constructor() {
    this._allExtensions = [];
    this._myExtensions = [];
  }
  toDelta() {
    return {
      toRemove: [],
      toAdd: this._allExtensions,
      addActivationEvents: ImplicitActivationEvents.createActivationEventsMap(this._allExtensions),
      myToRemove: [],
      myToAdd: this._myExtensions
    };
  }
  set(allExtensions, myExtensions) {
    const toRemove = [];
    const toAdd = [];
    const myToRemove = [];
    const myToAdd = [];
    const oldExtensionsMap = extensionDescriptionArrayToMap(this._allExtensions);
    const newExtensionsMap = extensionDescriptionArrayToMap(allExtensions);
    const extensionsAreTheSame = (a, b) => {
      return a.extensionLocation.toString() === b.extensionLocation.toString() || a.isBuiltin === b.isBuiltin || a.isUserBuiltin === b.isUserBuiltin || a.isUnderDevelopment === b.isUnderDevelopment;
    };
    for (const oldExtension of this._allExtensions) {
      const newExtension = newExtensionsMap.get(oldExtension.identifier);
      if (!newExtension) {
        toRemove.push(oldExtension.identifier);
        oldExtensionsMap.delete(oldExtension.identifier);
        continue;
      }
      if (!extensionsAreTheSame(oldExtension, newExtension)) {
        toRemove.push(oldExtension.identifier);
        oldExtensionsMap.delete(oldExtension.identifier);
        continue;
      }
    }
    for (const newExtension of allExtensions) {
      const oldExtension = oldExtensionsMap.get(newExtension.identifier);
      if (!oldExtension) {
        toAdd.push(newExtension);
        continue;
      }
      if (!extensionsAreTheSame(oldExtension, newExtension)) {
        toRemove.push(oldExtension.identifier);
        oldExtensionsMap.delete(oldExtension.identifier);
        continue;
      }
    }
    const myOldExtensionsSet = new ExtensionIdentifierSet(this._myExtensions);
    const myNewExtensionsSet = new ExtensionIdentifierSet(myExtensions);
    for (const oldExtensionId of this._myExtensions) {
      if (!myNewExtensionsSet.has(oldExtensionId)) {
        myToRemove.push(oldExtensionId);
      }
    }
    for (const newExtensionId of myExtensions) {
      if (!myOldExtensionsSet.has(newExtensionId)) {
        myToAdd.push(newExtensionId);
      }
    }
    const addActivationEvents = ImplicitActivationEvents.createActivationEventsMap(toAdd);
    const delta = { toRemove, toAdd, addActivationEvents, myToRemove, myToAdd };
    this.delta(delta);
    return delta;
  }
  delta(extensionsDelta) {
    const { toRemove, toAdd, myToRemove, myToAdd } = extensionsDelta;
    const toRemoveSet = new ExtensionIdentifierSet(toRemove);
    const myToRemoveSet = new ExtensionIdentifierSet(myToRemove);
    for (let i = 0; i < this._allExtensions.length; i++) {
      if (toRemoveSet.has(this._allExtensions[i].identifier)) {
        this._allExtensions.splice(i, 1);
        i--;
      }
    }
    for (let i = 0; i < this._myExtensions.length; i++) {
      if (myToRemoveSet.has(this._myExtensions[i])) {
        this._myExtensions.splice(i, 1);
        i--;
      }
    }
    for (const extension of toAdd) {
      this._allExtensions.push(extension);
    }
    for (const extensionId of myToAdd) {
      this._myExtensions.push(extensionId);
    }
  }
  containsExtension(extensionId) {
    for (const myExtensionId of this._myExtensions) {
      if (ExtensionIdentifier.equals(myExtensionId, extensionId)) {
        return true;
      }
    }
    return false;
  }
};
function extensionDescriptionArrayToMap(extensions) {
  const result = new ExtensionIdentifierMap();
  for (const extension of extensions) {
    result.set(extension.identifier, extension);
  }
  return result;
}
function isProposedApiEnabled(extension, proposal) {
  if (!extension.enabledApiProposals) {
    return false;
  }
  return extension.enabledApiProposals.includes(proposal);
}
function checkProposedApiEnabled(extension, proposal) {
  var _a5;
  if (!isProposedApiEnabled(extension, proposal)) {
    throw new Error(`Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.
Its package.json#enabledApiProposals-property declares: ${((_a5 = extension.enabledApiProposals) == null ? void 0 : _a5.join(", ")) ?? "[]"} but NOT ${proposal}.
 The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`);
  }
}
var ActivationTimes = class {
  constructor(codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) {
    this.codeLoadingTime = codeLoadingTime;
    this.activateCallTime = activateCallTime;
    this.activateResolvedTime = activateResolvedTime;
    this.activationReason = activationReason;
  }
};
var ExtensionPointContribution = class {
  constructor(description, value) {
    this.description = description;
    this.value = value;
  }
};
function toExtension(extensionDescription) {
  return {
    type: extensionDescription.isBuiltin ? 0 : 1,
    isBuiltin: extensionDescription.isBuiltin || extensionDescription.isUserBuiltin,
    identifier: { id: getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },
    manifest: extensionDescription,
    location: extensionDescription.extensionLocation,
    targetPlatform: extensionDescription.targetPlatform,
    validations: [],
    isValid: true
  };
}
function toExtensionDescription(extension, isUnderDevelopment) {
  return {
    identifier: new ExtensionIdentifier(getExtensionId(extension.manifest.publisher, extension.manifest.name)),
    isBuiltin: extension.type === 0,
    isUserBuiltin: extension.type === 1 && extension.isBuiltin,
    isUnderDevelopment: !!isUnderDevelopment,
    extensionLocation: extension.location,
    ...extension.manifest,
    uuid: extension.identifier.uuid,
    targetPlatform: extension.targetPlatform
  };
}
var NullExtensionService = class {
  constructor() {
    this.onDidRegisterExtensions = Event.None;
    this.onDidChangeExtensionsStatus = Event.None;
    this.onDidChangeExtensions = Event.None;
    this.onWillActivateByEvent = Event.None;
    this.onDidChangeResponsiveChange = Event.None;
    this.onWillStop = Event.None;
    this.extensions = [];
  }
  activateByEvent(_activationEvent) {
    return Promise.resolve(void 0);
  }
  activationEventIsDone(_activationEvent) {
    return false;
  }
  whenInstalledExtensionsRegistered() {
    return Promise.resolve(true);
  }
  getExtension() {
    return Promise.resolve(void 0);
  }
  readExtensionPointContributions(_extPoint) {
    return Promise.resolve(/* @__PURE__ */ Object.create(null));
  }
  getExtensionsStatus() {
    return /* @__PURE__ */ Object.create(null);
  }
  getInspectPorts(_extensionHostKind, _tryEnableInspector) {
    return Promise.resolve([]);
  }
  stopExtensionHosts() {
  }
  async startExtensionHosts() {
  }
  async setRemoteEnvironment(_env) {
  }
  canAddExtension() {
    return false;
  }
  canRemoveExtension() {
    return false;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/common/contributions.js
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/services/lifecycle/common/lifecycle.js
init_instantiation();
var ILifecycleService = createDecorator("lifecycleService");
function LifecyclePhaseToString(phase) {
  switch (phase) {
    case 1:
      return "Starting";
    case 2:
      return "Ready";
    case 3:
      return "Restored";
    case 4:
      return "Eventually";
  }
}

// node_modules/vscode/vscode/src/vs/workbench/common/contributions.js
init_platform2();
init_async();
init_log();
init_environment();
var Extensions3;
(function(Extensions5) {
  Extensions5.Workbench = "workbench.contributions.kind";
})(Extensions3 || (Extensions3 = {}));
var WorkbenchContributionsRegistry = class {
  constructor() {
    this.contributions = /* @__PURE__ */ new Map();
    this.pendingRestoredContributions = new DeferredPromise();
  }
  registerWorkbenchContribution(contribution, phase = 1) {
    if (this.instantiationService && this.lifecycleService && this.logService && this.environmentService && this.lifecycleService.phase >= phase) {
      this.safeCreateContribution(this.instantiationService, this.logService, this.environmentService, contribution, phase);
    } else {
      let contributions = this.contributions.get(phase);
      if (!contributions) {
        contributions = [];
        this.contributions.set(phase, contributions);
      }
      contributions.push(contribution);
    }
  }
  start(accessor) {
    const instantiationService = this.instantiationService = accessor.get(IInstantiationService);
    const lifecycleService = this.lifecycleService = accessor.get(ILifecycleService);
    const logService = this.logService = accessor.get(ILogService);
    const environmentService = this.environmentService = accessor.get(IEnvironmentService);
    for (const phase of [1, 2, 3, 4]) {
      this.instantiateByPhase(instantiationService, lifecycleService, logService, environmentService, phase);
    }
  }
  instantiateByPhase(instantiationService, lifecycleService, logService, environmentService, phase) {
    if (lifecycleService.phase >= phase) {
      this.doInstantiateByPhase(instantiationService, logService, environmentService, phase);
    } else {
      lifecycleService.when(phase).then(() => this.doInstantiateByPhase(instantiationService, logService, environmentService, phase));
    }
  }
  async doInstantiateByPhase(instantiationService, logService, environmentService, phase) {
    const contributions = this.contributions.get(phase);
    if (contributions) {
      this.contributions.delete(phase);
      switch (phase) {
        case 1:
        case 2: {
          mark(`code/willCreateWorkbenchContributions/${phase}`);
          for (const contribution of contributions) {
            this.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);
          }
          mark(`code/didCreateWorkbenchContributions/${phase}`);
          break;
        }
        case 3:
        case 4: {
          if (phase === 4) {
            await this.pendingRestoredContributions.p;
          }
          this.doInstantiateWhenIdle(contributions, instantiationService, logService, environmentService, phase);
          break;
        }
      }
    }
  }
  doInstantiateWhenIdle(contributions, instantiationService, logService, environmentService, phase) {
    mark(`code/willCreateWorkbenchContributions/${phase}`);
    let i = 0;
    const forcedTimeout = phase === 4 ? 3e3 : 500;
    const instantiateSome = (idle) => {
      while (i < contributions.length) {
        const contribution = contributions[i++];
        this.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);
        if (idle.timeRemaining() < 1) {
          runWhenIdle(instantiateSome, forcedTimeout);
          break;
        }
      }
      if (i === contributions.length) {
        mark(`code/didCreateWorkbenchContributions/${phase}`);
        if (phase === 3) {
          this.pendingRestoredContributions.complete();
        }
      }
    };
    runWhenIdle(instantiateSome, forcedTimeout);
  }
  safeCreateContribution(instantiationService, logService, environmentService, contribution, phase) {
    const now = phase < 3 ? Date.now() : void 0;
    try {
      instantiationService.createInstance(contribution);
    } catch (error) {
      logService.error(`Unable to create workbench contribution ${contribution.name}.`, error);
    }
    if (typeof now === "number" && !environmentService.isBuilt) {
      const time = Date.now() - now;
      if (time > 20) {
        logService.warn(`Workbench contribution ${contribution.name} blocked restore phase by ${time}ms.`);
      }
    }
  }
};
Registry.add(Extensions3.Workbench, new WorkbenchContributionsRegistry());

// node_modules/vscode/vscode/src/vs/workbench/services/textMate/browser/textMateTokenizationFeature.js
init_instantiation();
var ITextMateTokenizationService = createDecorator("textMateTokenizationFeature");

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/menuPreventer.js
init_lifecycle();
init_editorExtensions();
var _MenuPreventer = class _MenuPreventer extends Disposable {
  constructor(editor) {
    super();
    this._editor = editor;
    this._altListeningMouse = false;
    this._altMouseTriggered = false;
    this._register(this._editor.onMouseDown((e2) => {
      if (this._altListeningMouse) {
        this._altMouseTriggered = true;
      }
    }));
    this._register(this._editor.onKeyDown((e2) => {
      if (e2.equals(512)) {
        if (!this._altListeningMouse) {
          this._altMouseTriggered = false;
        }
        this._altListeningMouse = true;
      }
    }));
    this._register(this._editor.onKeyUp((e2) => {
      if (e2.equals(512)) {
        if (this._altMouseTriggered) {
          e2.preventDefault();
        }
        this._altListeningMouse = false;
        this._altMouseTriggered = false;
      }
    }));
  }
};
_MenuPreventer.ID = "editor.contrib.menuPreventer";
var MenuPreventer = _MenuPreventer;
registerEditorContribution(MenuPreventer.ID, MenuPreventer, 2);

// node_modules/vscode/vscode/src/vs/workbench/services/language/common/languageService.js
init_tslib_es6();
init_nls();
init_resources();
init_configuration();
init_environment();
init_files();

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionsRegistry.js
init_nls();
init_errors();

// node_modules/vscode/vscode/src/vs/platform/extensionManagement/common/extensionManagement.js
init_instantiation();
var EXTENSION_IDENTIFIER_PATTERN = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$";
var IExtensionGalleryService = createDecorator("extensionGalleryService");
var ExtensionManagementErrorCode;
(function(ExtensionManagementErrorCode2) {
  ExtensionManagementErrorCode2["Unsupported"] = "Unsupported";
  ExtensionManagementErrorCode2["Deprecated"] = "Deprecated";
  ExtensionManagementErrorCode2["Malicious"] = "Malicious";
  ExtensionManagementErrorCode2["Incompatible"] = "Incompatible";
  ExtensionManagementErrorCode2["IncompatibleTargetPlatform"] = "IncompatibleTargetPlatform";
  ExtensionManagementErrorCode2["ReleaseVersionNotFound"] = "ReleaseVersionNotFound";
  ExtensionManagementErrorCode2["Invalid"] = "Invalid";
  ExtensionManagementErrorCode2["Download"] = "Download";
  ExtensionManagementErrorCode2["Extract"] = "Extract";
  ExtensionManagementErrorCode2["Delete"] = "Delete";
  ExtensionManagementErrorCode2["Rename"] = "Rename";
  ExtensionManagementErrorCode2["CorruptZip"] = "CorruptZip";
  ExtensionManagementErrorCode2["IncompleteZip"] = "IncompleteZip";
  ExtensionManagementErrorCode2["Signature"] = "Signature";
  ExtensionManagementErrorCode2["Internal"] = "Internal";
})(ExtensionManagementErrorCode || (ExtensionManagementErrorCode = {}));
var IExtensionManagementService = createDecorator("extensionManagementService");

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionsRegistry.js
init_jsonContributionRegistry();
init_platform2();
init_extensions();

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionsApiProposals.js
var allApiProposals = Object.freeze({
  aiRelatedInformation: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts",
  authGetSessions: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authGetSessions.d.ts",
  authSession: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts",
  canonicalUriProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts",
  chat: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chat.d.ts",
  chatProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts",
  chatRequestAccess: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatRequestAccess.d.ts",
  chatSlashCommands: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatSlashCommands.d.ts",
  chatVariables: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatVariables.d.ts",
  codiconDecoration: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts",
  commentsDraftState: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts",
  contribCommentEditorActionsMenu: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts",
  contribCommentPeekContext: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts",
  contribCommentThreadAdditionalMenu: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts",
  contribEditSessions: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts",
  contribEditorContentMenu: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts",
  contribLabelFormatterWorkspaceTooltip: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts",
  contribMenuBarHome: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts",
  contribMergeEditorMenus: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts",
  contribNotebookStaticPreloads: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts",
  contribRemoteHelp: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts",
  contribShareMenu: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts",
  contribStatusBarItems: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts",
  contribViewsRemote: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts",
  contribViewsWelcome: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts",
  customEditorMove: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts",
  debugFocus: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugFocus.d.ts",
  diffCommand: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts",
  diffContentOptions: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts",
  documentFiltersExclusive: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts",
  documentPaste: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentPaste.d.ts",
  dropMetadata: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.dropMetadata.d.ts",
  editSessionIdentityProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts",
  editorInsets: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts",
  envShellEvent: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.envShellEvent.d.ts",
  extensionRuntime: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts",
  extensionsAny: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts",
  externalUriOpener: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts",
  fileComments: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileComments.d.ts",
  fileSearchProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts",
  findTextInFiles: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts",
  fsChunks: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts",
  handleIssueUri: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.handleIssueUri.d.ts",
  idToken: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts",
  indentSize: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.indentSize.d.ts",
  inlineCompletionsAdditions: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts",
  interactive: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts",
  interactiveUserActions: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveUserActions.d.ts",
  interactiveWindow: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts",
  ipc: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts",
  languageConfigurationAutoClosingPairs: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageConfigurationAutoClosingPairs.d.ts",
  mappedEditsProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts",
  notebookCellExecutionState: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecutionState.d.ts",
  notebookCodeActions: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCodeActions.d.ts",
  notebookControllerAffinityHidden: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts",
  notebookDeprecated: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts",
  notebookExecution: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts",
  notebookKernelSource: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts",
  notebookLiveShare: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts",
  notebookMessaging: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts",
  notebookMime: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts",
  portsAttributes: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts",
  profileContentHandlers: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts",
  quickDiffProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts",
  quickPickItemTooltip: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts",
  quickPickSortByLabel: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts",
  readonlyMessage: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.readonlyMessage.d.ts",
  resolvers: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts",
  saveEditor: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.saveEditor.d.ts",
  scmActionButton: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts",
  scmSelectedProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts",
  scmTextDocument: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts",
  scmValidation: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts",
  shareProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts",
  showLocal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.showLocal.d.ts",
  tabInputTextMerge: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts",
  taskPresentationGroup: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts",
  telemetry: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts",
  terminalContextMenu: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalContextMenu.d.ts",
  terminalDataWriteEvent: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts",
  terminalDimensions: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts",
  terminalExecuteCommandEvent: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts",
  terminalQuickFixProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts",
  terminalSelection: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts",
  testCoverage: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testCoverage.d.ts",
  testMessageContextValue: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testMessageContextValue.d.ts",
  testObserver: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts",
  textSearchProvider: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts",
  timeline: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts",
  tokenInformation: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts",
  treeViewActiveItem: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts",
  treeViewMarkdownMessage: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts",
  treeViewReveal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts",
  tunnelFactory: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts",
  tunnels: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts",
  windowActivity: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.windowActivity.d.ts",
  workspaceTrust: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts"
});

// node_modules/monaco-editor/esm/vs/platform/product/common/productService.js
init_instantiation();
var IProductService = createDecorator("productService");
var productSchemaId = "vscode://schemas/vscode-product";

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionsRegistry.js
var schemaRegistry = Registry.as(Extensions.JSONContribution);
var ExtensionMessageCollector = class {
  constructor(messageHandler, extension, extensionPointId) {
    this._messageHandler = messageHandler;
    this._extension = extension;
    this._extensionPointId = extensionPointId;
  }
  _msg(type, message) {
    this._messageHandler({
      type,
      message,
      extensionId: this._extension.identifier,
      extensionPointId: this._extensionPointId
    });
  }
  error(message) {
    this._msg(severity_default.Error, message);
  }
  warn(message) {
    this._msg(severity_default.Warning, message);
  }
  info(message) {
    this._msg(severity_default.Info, message);
  }
};
var ExtensionPointUserDelta = class _ExtensionPointUserDelta {
  static _toSet(arr) {
    const result = new ExtensionIdentifierSet();
    for (let i = 0, len = arr.length; i < len; i++) {
      result.add(arr[i].description.identifier);
    }
    return result;
  }
  static compute(previous, current) {
    if (!previous || !previous.length) {
      return new _ExtensionPointUserDelta(current, []);
    }
    if (!current || !current.length) {
      return new _ExtensionPointUserDelta([], previous);
    }
    const previousSet = this._toSet(previous);
    const currentSet = this._toSet(current);
    const added = current.filter((user) => !previousSet.has(user.description.identifier));
    const removed = previous.filter((user) => !currentSet.has(user.description.identifier));
    return new _ExtensionPointUserDelta(added, removed);
  }
  constructor(added, removed) {
    this.added = added;
    this.removed = removed;
  }
};
var ExtensionPoint = class {
  constructor(name, defaultExtensionKind) {
    this.name = name;
    this.defaultExtensionKind = defaultExtensionKind;
    this._handler = null;
    this._users = null;
    this._delta = null;
  }
  setHandler(handler) {
    if (this._handler !== null) {
      throw new Error("Handler already set!");
    }
    this._handler = handler;
    this._handle();
  }
  acceptUsers(users) {
    this._delta = ExtensionPointUserDelta.compute(this._users, users);
    this._users = users;
    this._handle();
  }
  _handle() {
    if (this._handler === null || this._users === null || this._delta === null) {
      return;
    }
    try {
      this._handler(this._users, this._delta);
    } catch (err) {
      onUnexpectedError(err);
    }
  }
};
var extensionKindSchema = {
  type: "string",
  enum: [
    "ui",
    "workspace"
  ],
  enumDescriptions: [
    localize(
      "ui",
      "UI extension kind. In a remote window, such extensions are enabled only when available on the local machine."
    ),
    localize(
      "workspace",
      "Workspace extension kind. In a remote window, such extensions are enabled only when available on the remote."
    )
  ]
};
var schemaId = "vscode://schemas/vscode-extensions";
var schema = {
  properties: {
    engines: {
      type: "object",
      description: localize("vscode.extension.engines", "Engine compatibility."),
      properties: {
        "vscode": {
          type: "string",
          description: localize(
            "vscode.extension.engines.vscode",
            "For VS Code extensions, specifies the VS Code version that the extension is compatible with. Cannot be *. For example: ^0.10.5 indicates compatibility with a minimum VS Code version of 0.10.5."
          ),
          default: "^1.22.0"
        }
      }
    },
    publisher: {
      description: localize("vscode.extension.publisher", "The publisher of the VS Code extension."),
      type: "string"
    },
    displayName: {
      description: localize(
        "vscode.extension.displayName",
        "The display name for the extension used in the VS Code gallery."
      ),
      type: "string"
    },
    categories: {
      description: localize(
        "vscode.extension.categories",
        "The categories used by the VS Code gallery to categorize the extension."
      ),
      type: "array",
      uniqueItems: true,
      items: {
        oneOf: [
          {
            type: "string",
            enum: EXTENSION_CATEGORIES
          },
          {
            type: "string",
            const: "Languages",
            deprecationMessage: localize(
              "vscode.extension.category.languages.deprecated",
              "Use 'Programming  Languages' instead"
            )
          }
        ]
      }
    },
    galleryBanner: {
      type: "object",
      description: localize(
        "vscode.extension.galleryBanner",
        "Banner used in the VS Code marketplace."
      ),
      properties: {
        color: {
          description: localize(
            "vscode.extension.galleryBanner.color",
            "The banner color on the VS Code marketplace page header."
          ),
          type: "string"
        },
        theme: {
          description: localize(
            "vscode.extension.galleryBanner.theme",
            "The color theme for the font used in the banner."
          ),
          type: "string",
          enum: ["dark", "light"]
        }
      }
    },
    contributes: {
      description: localize(
        "vscode.extension.contributes",
        "All contributions of the VS Code extension represented by this package."
      ),
      type: "object",
      properties: {},
      default: {}
    },
    preview: {
      type: "boolean",
      description: localize(
        "vscode.extension.preview",
        "Sets the extension to be flagged as a Preview in the Marketplace."
      )
    },
    enableProposedApi: {
      type: "boolean",
      deprecationMessage: localize(
        "vscode.extension.enableProposedApi.deprecated",
        "Use `enabledApiProposals` instead."
      )
    },
    enabledApiProposals: {
      markdownDescription: localize(
        "vscode.extension.enabledApiProposals",
        "Enable API proposals to try them out. Only valid **during development**. Extensions **cannot be published** with this property. For more details visit: https://code.visualstudio.com/api/advanced-topics/using-proposed-api"
      ),
      type: "array",
      uniqueItems: true,
      items: {
        type: "string",
        enum: Object.keys(allApiProposals),
        markdownEnumDescriptions: Object.values(allApiProposals)
      }
    },
    api: {
      markdownDescription: localize(
        "vscode.extension.api",
        "Describe the API provided by this extension. For more details visit: https://code.visualstudio.com/api/advanced-topics/remote-extensions#handling-dependencies-with-remote-extensions"
      ),
      type: "string",
      enum: ["none"],
      enumDescriptions: [
        localize(
          "vscode.extension.api.none",
          "Give up entirely the ability to export any APIs. This allows other extensions that depend on this extension to run in a separate extension host process or in a remote machine."
        )
      ]
    },
    activationEvents: {
      description: localize(
        "vscode.extension.activationEvents",
        "Activation events for the VS Code extension."
      ),
      type: "array",
      items: {
        type: "string",
        defaultSnippets: [
          {
            label: "onWebviewPanel",
            description: localize(
              "vscode.extension.activationEvents.onWebviewPanel",
              "An activation event emmited when a webview is loaded of a certain viewType"
            ),
            body: "onWebviewPanel:viewType"
          },
          {
            label: "onLanguage",
            description: localize(
              "vscode.extension.activationEvents.onLanguage",
              "An activation event emitted whenever a file that resolves to the specified language gets opened."
            ),
            body: "onLanguage:${1:languageId}"
          },
          {
            label: "onCommand",
            description: localize(
              "vscode.extension.activationEvents.onCommand",
              "An activation event emitted whenever the specified command gets invoked."
            ),
            body: "onCommand:${2:commandId}"
          },
          {
            label: "onDebug",
            description: localize(
              "vscode.extension.activationEvents.onDebug",
              "An activation event emitted whenever a user is about to start debugging or about to setup debug configurations."
            ),
            body: "onDebug"
          },
          {
            label: "onDebugInitialConfigurations",
            description: localize(
              "vscode.extension.activationEvents.onDebugInitialConfigurations",
              'An activation event emitted whenever a "launch.json" needs to be created (and all provideDebugConfigurations methods need to be called).'
            ),
            body: "onDebugInitialConfigurations"
          },
          {
            label: "onDebugDynamicConfigurations",
            description: localize(
              "vscode.extension.activationEvents.onDebugDynamicConfigurations",
              'An activation event emitted whenever a list of all debug configurations needs to be created (and all provideDebugConfigurations methods for the "dynamic" scope need to be called).'
            ),
            body: "onDebugDynamicConfigurations"
          },
          {
            label: "onDebugResolve",
            description: localize(
              "vscode.extension.activationEvents.onDebugResolve",
              "An activation event emitted whenever a debug session with the specific type is about to be launched (and a corresponding resolveDebugConfiguration method needs to be called)."
            ),
            body: "onDebugResolve:${6:type}"
          },
          {
            label: "onDebugAdapterProtocolTracker",
            description: localize(
              "vscode.extension.activationEvents.onDebugAdapterProtocolTracker",
              "An activation event emitted whenever a debug session with the specific type is about to be launched and a debug protocol tracker might be needed."
            ),
            body: "onDebugAdapterProtocolTracker:${6:type}"
          },
          {
            label: "workspaceContains",
            description: localize(
              "vscode.extension.activationEvents.workspaceContains",
              "An activation event emitted whenever a folder is opened that contains at least a file matching the specified glob pattern."
            ),
            body: "workspaceContains:${4:filePattern}"
          },
          {
            label: "onStartupFinished",
            description: localize(
              "vscode.extension.activationEvents.onStartupFinished",
              "An activation event emitted after the start-up finished (after all `*` activated extensions have finished activating)."
            ),
            body: "onStartupFinished"
          },
          {
            label: "onTaskType",
            description: localize(
              "vscode.extension.activationEvents.onTaskType",
              "An activation event emitted whenever tasks of a certain type need to be listed or resolved."
            ),
            body: "onTaskType:${1:taskType}"
          },
          {
            label: "onFileSystem",
            description: localize(
              "vscode.extension.activationEvents.onFileSystem",
              "An activation event emitted whenever a file or folder is accessed with the given scheme."
            ),
            body: "onFileSystem:${1:scheme}"
          },
          {
            label: "onEditSession",
            description: localize(
              "vscode.extension.activationEvents.onEditSession",
              "An activation event emitted whenever an edit session is accessed with the given scheme."
            ),
            body: "onEditSession:${1:scheme}"
          },
          {
            label: "onSearch",
            description: localize(
              "vscode.extension.activationEvents.onSearch",
              "An activation event emitted whenever a search is started in the folder with the given scheme."
            ),
            body: "onSearch:${7:scheme}"
          },
          {
            label: "onView",
            body: "onView:${5:viewId}",
            description: localize(
              "vscode.extension.activationEvents.onView",
              "An activation event emitted whenever the specified view is expanded."
            )
          },
          {
            label: "onUri",
            body: "onUri",
            description: localize(
              "vscode.extension.activationEvents.onUri",
              "An activation event emitted whenever a system-wide Uri directed towards this extension is open."
            )
          },
          {
            label: "onOpenExternalUri",
            body: "onOpenExternalUri",
            description: localize(
              "vscode.extension.activationEvents.onOpenExternalUri",
              "An activation event emitted whenever a external uri (such as an http or https link) is being opened."
            )
          },
          {
            label: "onCustomEditor",
            body: "onCustomEditor:${9:viewType}",
            description: localize(
              "vscode.extension.activationEvents.onCustomEditor",
              "An activation event emitted whenever the specified custom editor becomes visible."
            )
          },
          {
            label: "onNotebook",
            body: "onNotebook:${1:type}",
            description: localize(
              "vscode.extension.activationEvents.onNotebook",
              "An activation event emitted whenever the specified notebook document is opened."
            )
          },
          {
            label: "onAuthenticationRequest",
            body: "onAuthenticationRequest:${11:authenticationProviderId}",
            description: localize(
              "vscode.extension.activationEvents.onAuthenticationRequest",
              "An activation event emitted whenever sessions are requested from the specified authentication provider."
            )
          },
          {
            label: "onRenderer",
            description: localize(
              "vscode.extension.activationEvents.onRenderer",
              "An activation event emitted whenever a notebook output renderer is used."
            ),
            body: "onRenderer:${11:rendererId}"
          },
          {
            label: "onTerminalProfile",
            body: "onTerminalProfile:${1:terminalId}",
            description: localize(
              "vscode.extension.activationEvents.onTerminalProfile",
              "An activation event emitted when a specific terminal profile is launched."
            )
          },
          {
            label: "onTerminalQuickFixRequest",
            body: "onTerminalQuickFixRequest:${1:quickFixId}",
            description: localize(
              "vscode.extension.activationEvents.onTerminalQuickFixRequest",
              "An activation event emitted when a command matches the selector associated with this ID"
            )
          },
          {
            label: "onWalkthrough",
            body: "onWalkthrough:${1:walkthroughID}",
            description: localize(
              "vscode.extension.activationEvents.onWalkthrough",
              "An activation event emitted when a specified walkthrough is opened."
            )
          },
          {
            label: "*",
            description: localize(
              "vscode.extension.activationEvents.star",
              "An activation event emitted on VS Code startup. To ensure a great end user experience, please use this activation event in your extension only when no other activation events combination works in your use-case."
            ),
            body: "*"
          }
        ]
      }
    },
    badges: {
      type: "array",
      description: localize(
        "vscode.extension.badges",
        "Array of badges to display in the sidebar of the Marketplace's extension page."
      ),
      items: {
        type: "object",
        required: ["url", "href", "description"],
        properties: {
          url: {
            type: "string",
            description: localize("vscode.extension.badges.url", "Badge image URL.")
          },
          href: {
            type: "string",
            description: localize("vscode.extension.badges.href", "Badge link.")
          },
          description: {
            type: "string",
            description: localize("vscode.extension.badges.description", "Badge description.")
          }
        }
      }
    },
    markdown: {
      type: "string",
      description: localize(
        "vscode.extension.markdown",
        "Controls the Markdown rendering engine used in the Marketplace. Either github (default) or standard."
      ),
      enum: ["github", "standard"],
      default: "github"
    },
    qna: {
      default: "marketplace",
      description: localize(
        "vscode.extension.qna",
        "Controls the Q&A link in the Marketplace. Set to marketplace to enable the default Marketplace Q & A site. Set to a string to provide the URL of a custom Q & A site. Set to false to disable Q & A altogether."
      ),
      anyOf: [
        {
          type: ["string", "boolean"],
          enum: ["marketplace", false]
        },
        {
          type: "string"
        }
      ]
    },
    extensionDependencies: {
      description: localize(
        "vscode.extension.extensionDependencies",
        "Dependencies to other extensions. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp."
      ),
      type: "array",
      uniqueItems: true,
      items: {
        type: "string",
        pattern: EXTENSION_IDENTIFIER_PATTERN
      }
    },
    extensionPack: {
      description: localize(
        "vscode.extension.contributes.extensionPack",
        "A set of extensions that can be installed together. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp."
      ),
      type: "array",
      uniqueItems: true,
      items: {
        type: "string",
        pattern: EXTENSION_IDENTIFIER_PATTERN
      }
    },
    extensionKind: {
      description: localize(
        "extensionKind",
        "Define the kind of an extension. `ui` extensions are installed and run on the local machine while `workspace` extensions run on the remote."
      ),
      type: "array",
      items: extensionKindSchema,
      default: ["workspace"],
      defaultSnippets: [
        {
          body: ["ui"],
          description: localize(
            "extensionKind.ui",
            "Define an extension which can run only on the local machine when connected to remote window."
          )
        },
        {
          body: ["workspace"],
          description: localize(
            "extensionKind.workspace",
            "Define an extension which can run only on the remote machine when connected remote window."
          )
        },
        {
          body: ["ui", "workspace"],
          description: localize(
            "extensionKind.ui-workspace",
            "Define an extension which can run on either side, with a preference towards running on the local machine."
          )
        },
        {
          body: ["workspace", "ui"],
          description: localize(
            "extensionKind.workspace-ui",
            "Define an extension which can run on either side, with a preference towards running on the remote machine."
          )
        },
        {
          body: [],
          description: localize(
            "extensionKind.empty",
            "Define an extension which cannot run in a remote context, neither on the local, nor on the remote machine."
          )
        }
      ]
    },
    capabilities: {
      description: localize(
        "vscode.extension.capabilities",
        "Declare the set of supported capabilities by the extension."
      ),
      type: "object",
      properties: {
        virtualWorkspaces: {
          description: localize(
            "vscode.extension.capabilities.virtualWorkspaces",
            "Declares whether the extension should be enabled in virtual workspaces. A virtual workspace is a workspace which is not backed by any on-disk resources. When false, this extension will be automatically disabled in virtual workspaces. Default is true."
          ),
          type: ["boolean", "object"],
          defaultSnippets: [
            { label: "limited", body: { supported: "${1:limited}", description: "${2}" } },
            { label: "false", body: { supported: false, description: "${2}" } }
          ],
          default: true.valueOf,
          properties: {
            supported: {
              markdownDescription: localize(
                "vscode.extension.capabilities.virtualWorkspaces.supported",
                "Declares the level of support for virtual workspaces by the extension."
              ),
              type: ["string", "boolean"],
              enum: ["limited", true, false],
              enumDescriptions: [
                localize(
                  "vscode.extension.capabilities.virtualWorkspaces.supported.limited",
                  "The extension will be enabled in virtual workspaces with some functionality disabled."
                ),
                localize(
                  "vscode.extension.capabilities.virtualWorkspaces.supported.true",
                  "The extension will be enabled in virtual workspaces with all functionality enabled."
                ),
                localize(
                  "vscode.extension.capabilities.virtualWorkspaces.supported.false",
                  "The extension will not be enabled in virtual workspaces."
                )
              ]
            },
            description: {
              type: "string",
              markdownDescription: localize(
                "vscode.extension.capabilities.virtualWorkspaces.description",
                "A description of how virtual workspaces affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`."
              )
            }
          }
        },
        untrustedWorkspaces: {
          description: localize(
            "vscode.extension.capabilities.untrustedWorkspaces",
            "Declares how the extension should be handled in untrusted workspaces."
          ),
          type: "object",
          required: ["supported"],
          defaultSnippets: [
            { body: { supported: "${1:limited}", description: "${2}" } }
          ],
          properties: {
            supported: {
              markdownDescription: localize(
                "vscode.extension.capabilities.untrustedWorkspaces.supported",
                "Declares the level of support for untrusted workspaces by the extension."
              ),
              type: ["string", "boolean"],
              enum: ["limited", true, false],
              enumDescriptions: [
                localize(
                  "vscode.extension.capabilities.untrustedWorkspaces.supported.limited",
                  "The extension will be enabled in untrusted workspaces with some functionality disabled."
                ),
                localize(
                  "vscode.extension.capabilities.untrustedWorkspaces.supported.true",
                  "The extension will be enabled in untrusted workspaces with all functionality enabled."
                ),
                localize(
                  "vscode.extension.capabilities.untrustedWorkspaces.supported.false",
                  "The extension will not be enabled in untrusted workspaces."
                )
              ]
            },
            restrictedConfigurations: {
              description: localize(
                "vscode.extension.capabilities.untrustedWorkspaces.restrictedConfigurations",
                "A list of configuration keys contributed by the extension that should not use workspace values in untrusted workspaces."
              ),
              type: "array",
              items: {
                type: "string"
              }
            },
            description: {
              type: "string",
              markdownDescription: localize(
                "vscode.extension.capabilities.untrustedWorkspaces.description",
                "A description of how workspace trust affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`."
              )
            }
          }
        }
      }
    },
    sponsor: {
      description: localize(
        "vscode.extension.contributes.sponsor",
        "Specify the location from where users can sponsor your extension."
      ),
      type: "object",
      defaultSnippets: [
        { body: { url: "${1:https:}" } }
      ],
      properties: {
        "url": {
          description: localize(
            "vscode.extension.contributes.sponsor.url",
            "URL from where users can sponsor your extension. It must be a valid URL with a HTTP or HTTPS protocol. Example value: https://github.com/sponsors/nvaccess"
          ),
          type: "string"
        }
      }
    },
    scripts: {
      type: "object",
      properties: {
        "vscode:prepublish": {
          description: localize(
            "vscode.extension.scripts.prepublish",
            "Script executed before the package is published as a VS Code extension."
          ),
          type: "string"
        },
        "vscode:uninstall": {
          description: localize(
            "vscode.extension.scripts.uninstall",
            "Uninstall hook for VS Code extension. Script that gets executed when the extension is completely uninstalled from VS Code which is when VS Code is restarted (shutdown and start) after the extension is uninstalled. Only Node scripts are supported."
          ),
          type: "string"
        }
      }
    },
    icon: {
      type: "string",
      description: localize("vscode.extension.icon", "The path to a 128x128 pixel icon.")
    },
    l10n: {
      type: "string",
      description: localize({
        key: "vscode.extension.l10n",
        comment: [
          '{Locked="bundle.l10n._locale_.json"}',
          '{Locked="vscode.l10n API"}'
        ]
      }, "The relative path to a folder containing localization (bundle.l10n.*.json) files. Must be specified if you are using the vscode.l10n API.")
    },
    pricing: {
      type: "string",
      markdownDescription: localize(
        "vscode.extension.pricing",
        "The pricing information for the extension. Can be Free (default) or Trial. For more details visit: https://code.visualstudio.com/api/working-with-extensions/publishing-extension#extension-pricing-label"
      ),
      enum: ["Free", "Trial"],
      default: "Free"
    }
  }
};
var ExtensionsRegistryImpl = class {
  constructor() {
    this._extensionPoints = /* @__PURE__ */ new Map();
  }
  registerExtensionPoint(desc) {
    if (this._extensionPoints.has(desc.extensionPoint)) {
      throw new Error("Duplicate extension point: " + desc.extensionPoint);
    }
    const result = new ExtensionPoint(desc.extensionPoint, desc.defaultExtensionKind);
    this._extensionPoints.set(desc.extensionPoint, result);
    if (desc.activationEventsGenerator) {
      ImplicitActivationEvents.register(desc.extensionPoint, desc.activationEventsGenerator);
    }
    schema.properties["contributes"].properties[desc.extensionPoint] = desc.jsonSchema;
    schemaRegistry.registerSchema(schemaId, schema);
    return result;
  }
  getExtensionPoints() {
    return Array.from(this._extensionPoints.values());
  }
};
var PRExtensions = {
  ExtensionsRegistry: "ExtensionsRegistry"
};
Registry.add(PRExtensions.ExtensionsRegistry, new ExtensionsRegistryImpl());
var ExtensionsRegistry = Registry.as(PRExtensions.ExtensionsRegistry);
schemaRegistry.registerSchema(schemaId, schema);
schemaRegistry.registerSchema(productSchemaId, {
  properties: {
    extensionEnabledApiProposals: {
      description: localize(
        "product.extensionEnabledApiProposals",
        "API proposals that the respective extensions can freely use."
      ),
      type: "object",
      properties: {},
      additionalProperties: {
        anyOf: [{
          type: "array",
          uniqueItems: true,
          items: {
            type: "string",
            enum: Object.keys(allApiProposals),
            markdownEnumDescriptions: Object.values(allApiProposals)
          }
        }]
      }
    }
  }
});

// node_modules/vscode/vscode/src/vs/workbench/services/language/common/languageService.js
init_log();
var languagesExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "languages",
  jsonSchema: {
    description: localize(
      "vscode.extension.contributes.languages",
      "Contributes language declarations."
    ),
    type: "array",
    items: {
      type: "object",
      defaultSnippets: [{ body: { id: "${1:languageId}", aliases: ["${2:label}"], extensions: ["${3:extension}"], configuration: "./language-configuration.json" } }],
      properties: {
        id: {
          description: localize("vscode.extension.contributes.languages.id", "ID of the language."),
          type: "string"
        },
        aliases: {
          description: localize(
            "vscode.extension.contributes.languages.aliases",
            "Name aliases for the language."
          ),
          type: "array",
          items: {
            type: "string"
          }
        },
        extensions: {
          description: localize(
            "vscode.extension.contributes.languages.extensions",
            "File extensions associated to the language."
          ),
          default: [".foo"],
          type: "array",
          items: {
            type: "string"
          }
        },
        filenames: {
          description: localize(
            "vscode.extension.contributes.languages.filenames",
            "File names associated to the language."
          ),
          type: "array",
          items: {
            type: "string"
          }
        },
        filenamePatterns: {
          description: localize(
            "vscode.extension.contributes.languages.filenamePatterns",
            "File name glob patterns associated to the language."
          ),
          type: "array",
          items: {
            type: "string"
          }
        },
        mimetypes: {
          description: localize(
            "vscode.extension.contributes.languages.mimetypes",
            "Mime types associated to the language."
          ),
          type: "array",
          items: {
            type: "string"
          }
        },
        firstLine: {
          description: localize(
            "vscode.extension.contributes.languages.firstLine",
            "A regular expression matching the first line of a file of the language."
          ),
          type: "string"
        },
        configuration: {
          description: localize(
            "vscode.extension.contributes.languages.configuration",
            "A relative path to a file containing configuration options for the language."
          ),
          type: "string",
          default: "./language-configuration.json"
        },
        icon: {
          type: "object",
          description: localize(
            "vscode.extension.contributes.languages.icon",
            "A icon to use as file icon, if no icon theme provides one for the language."
          ),
          properties: {
            light: {
              description: localize(
                "vscode.extension.contributes.languages.icon.light",
                "Icon path when a light theme is used"
              ),
              type: "string"
            },
            dark: {
              description: localize(
                "vscode.extension.contributes.languages.icon.dark",
                "Icon path when a dark theme is used"
              ),
              type: "string"
            }
          }
        }
      }
    }
  },
  activationEventsGenerator: (languageContributions, result) => {
    for (const languageContribution of languageContributions) {
      if (languageContribution.id && languageContribution.configuration) {
        result.push(`onLanguage:${languageContribution.id}`);
      }
    }
  }
});
var WorkbenchLanguageService = class WorkbenchLanguageService2 extends LanguageService {
  constructor(extensionService, configurationService, environmentService, logService) {
    super(environmentService.verbose || environmentService.isExtensionDevelopment || !environmentService.isBuilt);
    this.logService = logService;
    this._configurationService = configurationService;
    this._extensionService = extensionService;
    languagesExtPoint.setHandler((extensions) => {
      const allValidLanguages = [];
      for (let i = 0, len = extensions.length; i < len; i++) {
        const extension = extensions[i];
        if (!Array.isArray(extension.value)) {
          extension.collector.error(localize(
            "invalid",
            "Invalid `contributes.{0}`. Expected an array.",
            languagesExtPoint.name
          ));
          continue;
        }
        for (let j = 0, lenJ = extension.value.length; j < lenJ; j++) {
          const ext = extension.value[j];
          if (isValidLanguageExtensionPoint(ext, extension.description, extension.collector)) {
            let configuration2 = void 0;
            if (ext.configuration) {
              configuration2 = joinPath(extension.description.extensionLocation, ext.configuration);
            }
            allValidLanguages.push({
              id: ext.id,
              extensions: ext.extensions,
              filenames: ext.filenames,
              filenamePatterns: ext.filenamePatterns,
              firstLine: ext.firstLine,
              aliases: ext.aliases,
              mimetypes: ext.mimetypes,
              configuration: configuration2,
              icon: ext.icon && {
                light: joinPath(extension.description.extensionLocation, ext.icon.light),
                dark: joinPath(extension.description.extensionLocation, ext.icon.dark)
              }
            });
          }
        }
      }
      this._registry.setDynamicLanguages(allValidLanguages);
    });
    this.updateMime();
    this._configurationService.onDidChangeConfiguration((e2) => {
      if (e2.affectsConfiguration(FILES_ASSOCIATIONS_CONFIG)) {
        this.updateMime();
      }
    });
    this._extensionService.whenInstalledExtensionsRegistered().then(() => {
      this.updateMime();
    });
    this._register(this.onDidRequestRichLanguageFeatures((languageId) => {
      this._extensionService.activateByEvent(`onLanguage:${languageId}`);
      this._extensionService.activateByEvent(`onLanguage`);
    }));
  }
  updateMime() {
    var _a5;
    const configuration2 = this._configurationService.getValue();
    clearConfiguredLanguageAssociations();
    if ((_a5 = configuration2.files) == null ? void 0 : _a5.associations) {
      Object.keys(configuration2.files.associations).forEach((pattern) => {
        const langId = configuration2.files.associations[pattern];
        if (typeof langId !== "string") {
          this.logService.warn(`Ignoring configured 'files.associations' for '${pattern}' because its type is not a string but '${typeof langId}'`);
          return;
        }
        const mimeType = this.getMimeType(langId) || `text/x-${langId}`;
        registerConfiguredLanguageAssociation({ id: langId, mime: mimeType, filepattern: pattern });
      });
    }
    this._onDidChange.fire();
  }
};
WorkbenchLanguageService = __decorate([
  __param(0, IExtensionService),
  __param(1, IConfigurationService),
  __param(2, IEnvironmentService),
  __param(3, ILogService)
], WorkbenchLanguageService);
function isUndefinedOrStringArray(value) {
  if (typeof value === "undefined") {
    return true;
  }
  if (!Array.isArray(value)) {
    return false;
  }
  return value.every((item) => typeof item === "string");
}
function isValidLanguageExtensionPoint(value, extension, collector) {
  if (!value) {
    collector.error(localize(
      "invalid.empty",
      "Empty value for `contributes.{0}`",
      languagesExtPoint.name
    ));
    return false;
  }
  if (typeof value.id !== "string") {
    collector.error(localize(
      "require.id",
      "property `{0}` is mandatory and must be of type `string`",
      "id"
    ));
    return false;
  }
  if (!isUndefinedOrStringArray(value.extensions)) {
    collector.error(localize(
      "opt.extensions",
      "property `{0}` can be omitted and must be of type `string[]`",
      "extensions"
    ));
    return false;
  }
  if (!isUndefinedOrStringArray(value.filenames)) {
    collector.error(localize(
      "opt.filenames",
      "property `{0}` can be omitted and must be of type `string[]`",
      "filenames"
    ));
    return false;
  }
  if (typeof value.firstLine !== "undefined" && typeof value.firstLine !== "string") {
    collector.error(localize(
      "opt.firstLine",
      "property `{0}` can be omitted and must be of type `string`",
      "firstLine"
    ));
    return false;
  }
  if (typeof value.configuration !== "undefined" && typeof value.configuration !== "string") {
    collector.error(localize(
      "opt.configuration",
      "property `{0}` can be omitted and must be of type `string`",
      "configuration"
    ));
    return false;
  }
  if (!isUndefinedOrStringArray(value.aliases)) {
    collector.error(localize(
      "opt.aliases",
      "property `{0}` can be omitted and must be of type `string[]`",
      "aliases"
    ));
    return false;
  }
  if (!isUndefinedOrStringArray(value.mimetypes)) {
    collector.error(localize(
      "opt.mimetypes",
      "property `{0}` can be omitted and must be of type `string[]`",
      "mimetypes"
    ));
    return false;
  }
  if (typeof value.icon !== "undefined") {
    if (typeof value.icon !== "object" || typeof value.icon.light !== "string" || typeof value.icon.dark !== "string") {
      collector.error(localize(
        "opt.icon",
        "property `{0}` can be omitted and must be of type `object` with properties `{1}` and `{2}` of type `string`",
        "icon",
        "light",
        "dark"
      ));
      return false;
    }
  }
  return true;
}

// node_modules/vscode/vscode/src/vs/workbench/common/editor.js
init_nls();
init_types();
init_uri();
init_lifecycle();
init_instantiation();
init_platform2();
init_files();
init_network();
init_errorMessage();
init_actions();
var EditorExtensions = {
  EditorPane: "workbench.contributions.editors",
  EditorFactory: "workbench.contributions.editor.inputFactories"
};
var DEFAULT_EDITOR_ASSOCIATION = {
  id: "default",
  displayName: localize("promptOpenWith.defaultEditor.displayName", "Text Editor"),
  providerDisplayName: localize("builtinProviderDisplayName", "Built-in")
};
var SIDE_BY_SIDE_EDITOR_ID = "workbench.editor.sidebysideEditor";
var TEXT_DIFF_EDITOR_ID = "workbench.editors.textDiffEditor";
var BINARY_DIFF_EDITOR_ID = "workbench.editors.binaryResourceDiffEditor";
function isEditorPaneWithSelection(editorPane) {
  const candidate = editorPane;
  return !!candidate && typeof candidate.getSelection === "function" && !!candidate.onDidChangeSelection;
}
function findViewStateForEditor(input, group, editorService) {
  for (const editorPane of editorService.visibleEditorPanes) {
    if (editorPane.group.id === group && input.matches(editorPane.input)) {
      return editorPane.getViewState();
    }
  }
  return void 0;
}
function isResourceEditorInput(editor) {
  if (isEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  return URI.isUri(candidate == null ? void 0 : candidate.resource);
}
function isResourceDiffEditorInput(editor) {
  if (isEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  return (candidate == null ? void 0 : candidate.original) !== void 0 && candidate.modified !== void 0;
}
function isResourceSideBySideEditorInput(editor) {
  if (isEditorInput(editor)) {
    return false;
  }
  if (isResourceDiffEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  return (candidate == null ? void 0 : candidate.primary) !== void 0 && candidate.secondary !== void 0;
}
function isUntitledResourceEditorInput(editor) {
  if (isEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  if (!candidate) {
    return false;
  }
  return candidate.resource === void 0 || candidate.resource.scheme === Schemas.untitled || candidate.forceUntitled === true;
}
function isResourceMergeEditorInput(editor) {
  var _a5, _b, _c, _d;
  if (isEditorInput(editor)) {
    return false;
  }
  const candidate = editor;
  return URI.isUri((_a5 = candidate == null ? void 0 : candidate.base) == null ? void 0 : _a5.resource) && URI.isUri((_b = candidate == null ? void 0 : candidate.input1) == null ? void 0 : _b.resource) && URI.isUri((_c = candidate == null ? void 0 : candidate.input2) == null ? void 0 : _c.resource) && URI.isUri((_d = candidate == null ? void 0 : candidate.result) == null ? void 0 : _d.resource);
}
var SaveSourceFactory = class {
  constructor() {
    this.mapIdToSaveSource = /* @__PURE__ */ new Map();
  }
  registerSource(id, label) {
    let sourceDescriptor = this.mapIdToSaveSource.get(id);
    if (!sourceDescriptor) {
      sourceDescriptor = { source: id, label };
      this.mapIdToSaveSource.set(id, sourceDescriptor);
    }
    return sourceDescriptor.source;
  }
  getSourceLabel(source) {
    var _a5;
    return ((_a5 = this.mapIdToSaveSource.get(source)) == null ? void 0 : _a5.label) ?? source;
  }
};
var SaveSourceRegistry = new SaveSourceFactory();
var AbstractEditorInput = class extends Disposable {
};
function isEditorInput(editor) {
  return editor instanceof AbstractEditorInput;
}
function isEditorInputWithPreferredResource(editor) {
  const candidate = editor;
  return URI.isUri(candidate == null ? void 0 : candidate.preferredResource);
}
function isSideBySideEditorInput(editor) {
  const candidate = editor;
  return isEditorInput(candidate == null ? void 0 : candidate.primary) && isEditorInput(candidate == null ? void 0 : candidate.secondary);
}
function isDiffEditorInput(editor) {
  const candidate = editor;
  return isEditorInput(candidate == null ? void 0 : candidate.modified) && isEditorInput(candidate == null ? void 0 : candidate.original);
}
function createTooLargeFileError(group, input, options, message, preferencesService) {
  return createEditorOpenError(message, [
    toAction({
      id: "workbench.action.openLargeFile",
      label: localize("openLargeFile", "Open Anyway"),
      run: () => {
        const fileEditorOptions = {
          ...options,
          limits: {
            size: Number.MAX_VALUE
          }
        };
        group.openEditor(input, fileEditorOptions);
      }
    }),
    toAction({
      id: "workbench.action.configureEditorLargeFileConfirmation",
      label: localize("configureEditorLargeFileConfirmation", "Configure Limit"),
      run: () => {
        return preferencesService.openUserSettings({ query: "workbench.editorLargeFileConfirmation" });
      }
    })
  ], {
    forceMessage: true,
    forceSeverity: severity_default.Warning
  });
}
function isEditorIdentifier(identifier) {
  const candidate = identifier;
  return typeof (candidate == null ? void 0 : candidate.groupId) === "number" && isEditorInput(candidate.editor);
}
var EditorCloseContext;
(function(EditorCloseContext2) {
  EditorCloseContext2[EditorCloseContext2["UNKNOWN"] = 0] = "UNKNOWN";
  EditorCloseContext2[EditorCloseContext2["REPLACE"] = 1] = "REPLACE";
  EditorCloseContext2[EditorCloseContext2["MOVE"] = 2] = "MOVE";
  EditorCloseContext2[EditorCloseContext2["UNPIN"] = 3] = "UNPIN";
})(EditorCloseContext || (EditorCloseContext = {}));
var SideBySideEditor;
(function(SideBySideEditor2) {
  SideBySideEditor2[SideBySideEditor2["PRIMARY"] = 1] = "PRIMARY";
  SideBySideEditor2[SideBySideEditor2["SECONDARY"] = 2] = "SECONDARY";
  SideBySideEditor2[SideBySideEditor2["BOTH"] = 3] = "BOTH";
  SideBySideEditor2[SideBySideEditor2["ANY"] = 4] = "ANY";
})(SideBySideEditor || (SideBySideEditor = {}));
var EditorResourceAccessorImpl = class {
  getOriginalUri(editor, options) {
    if (!editor) {
      return void 0;
    }
    if (isResourceMergeEditorInput(editor)) {
      return EditorResourceAccessor.getOriginalUri(editor.result, options);
    }
    if (options == null ? void 0 : options.supportSideBySide) {
      const { primary, secondary } = this.getSideEditors(editor);
      if (primary && secondary) {
        if ((options == null ? void 0 : options.supportSideBySide) === SideBySideEditor.BOTH) {
          return {
            primary: this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }),
            secondary: this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme })
          };
        } else if ((options == null ? void 0 : options.supportSideBySide) === SideBySideEditor.ANY) {
          return this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme });
        }
        editor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;
      }
    }
    if (isResourceDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {
      return void 0;
    }
    const originalResource = isEditorInputWithPreferredResource(editor) ? editor.preferredResource : editor.resource;
    if (!originalResource || !options || !options.filterByScheme) {
      return originalResource;
    }
    return this.filterUri(originalResource, options.filterByScheme);
  }
  getSideEditors(editor) {
    if (isSideBySideEditorInput(editor) || isResourceSideBySideEditorInput(editor)) {
      return { primary: editor.primary, secondary: editor.secondary };
    }
    if (isDiffEditorInput(editor) || isResourceDiffEditorInput(editor)) {
      return { primary: editor.modified, secondary: editor.original };
    }
    return { primary: void 0, secondary: void 0 };
  }
  getCanonicalUri(editor, options) {
    if (!editor) {
      return void 0;
    }
    if (isResourceMergeEditorInput(editor)) {
      return EditorResourceAccessor.getCanonicalUri(editor.result, options);
    }
    if (options == null ? void 0 : options.supportSideBySide) {
      const { primary, secondary } = this.getSideEditors(editor);
      if (primary && secondary) {
        if ((options == null ? void 0 : options.supportSideBySide) === SideBySideEditor.BOTH) {
          return {
            primary: this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }),
            secondary: this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme })
          };
        } else if ((options == null ? void 0 : options.supportSideBySide) === SideBySideEditor.ANY) {
          return this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme });
        }
        editor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;
      }
    }
    if (isResourceDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {
      return void 0;
    }
    const canonicalResource = editor.resource;
    if (!canonicalResource || !options || !options.filterByScheme) {
      return canonicalResource;
    }
    return this.filterUri(canonicalResource, options.filterByScheme);
  }
  filterUri(resource, filter) {
    if (Array.isArray(filter)) {
      if (filter.some((scheme) => resource.scheme === scheme)) {
        return resource;
      }
    } else {
      if (filter === resource.scheme) {
        return resource;
      }
    }
    return void 0;
  }
};
var EditorCloseMethod;
(function(EditorCloseMethod2) {
  EditorCloseMethod2[EditorCloseMethod2["UNKNOWN"] = 0] = "UNKNOWN";
  EditorCloseMethod2[EditorCloseMethod2["KEYBOARD"] = 1] = "KEYBOARD";
  EditorCloseMethod2[EditorCloseMethod2["MOUSE"] = 2] = "MOUSE";
})(EditorCloseMethod || (EditorCloseMethod = {}));
function preventEditorClose(group, editor, method, configuration2) {
  if (!group.isSticky(editor)) {
    return false;
  }
  switch (configuration2.preventPinnedEditorClose) {
    case "keyboardAndMouse":
      return method === EditorCloseMethod.MOUSE || method === EditorCloseMethod.KEYBOARD;
    case "mouse":
      return method === EditorCloseMethod.MOUSE;
    case "keyboard":
      return method === EditorCloseMethod.KEYBOARD;
  }
  return false;
}
var EditorResourceAccessor = new EditorResourceAccessorImpl();
var CloseDirection;
(function(CloseDirection2) {
  CloseDirection2[CloseDirection2["LEFT"] = 0] = "LEFT";
  CloseDirection2[CloseDirection2["RIGHT"] = 1] = "RIGHT";
})(CloseDirection || (CloseDirection = {}));
var EditorFactoryRegistry = class {
  constructor() {
    this.editorSerializerConstructors = /* @__PURE__ */ new Map();
    this.editorSerializerInstances = /* @__PURE__ */ new Map();
  }
  start(accessor) {
    const instantiationService = this.instantiationService = accessor.get(IInstantiationService);
    for (const [key, ctor] of this.editorSerializerConstructors) {
      this.createEditorSerializer(key, ctor, instantiationService);
    }
    this.editorSerializerConstructors.clear();
  }
  createEditorSerializer(editorTypeId, ctor, instantiationService) {
    const instance = instantiationService.createInstance(ctor);
    this.editorSerializerInstances.set(editorTypeId, instance);
  }
  registerFileEditorFactory(factory) {
    if (this.fileEditorFactory) {
      throw new Error("Can only register one file editor factory.");
    }
    this.fileEditorFactory = factory;
  }
  getFileEditorFactory() {
    return assertIsDefined(this.fileEditorFactory);
  }
  registerEditorSerializer(editorTypeId, ctor) {
    if (this.editorSerializerConstructors.has(editorTypeId) || this.editorSerializerInstances.has(editorTypeId)) {
      throw new Error(`A editor serializer with type ID '${editorTypeId}' was already registered.`);
    }
    if (!this.instantiationService) {
      this.editorSerializerConstructors.set(editorTypeId, ctor);
    } else {
      this.createEditorSerializer(editorTypeId, ctor, this.instantiationService);
    }
    return toDisposable(() => {
      this.editorSerializerConstructors.delete(editorTypeId);
      this.editorSerializerInstances.delete(editorTypeId);
    });
  }
  getEditorSerializer(arg1) {
    return this.editorSerializerInstances.get(typeof arg1 === "string" ? arg1 : arg1.typeId);
  }
};
Registry.add(EditorExtensions.EditorFactory, new EditorFactoryRegistry());
async function pathsToEditors(paths, fileService, logService) {
  if (!paths || !paths.length) {
    return [];
  }
  return await Promise.all(paths.map(async (path) => {
    const resource = URI.revive(path.fileUri);
    if (!resource) {
      logService.info("Cannot resolve the path because it is not valid.", path);
      return void 0;
    }
    const canHandleResource = await fileService.canHandleResource(resource);
    if (!canHandleResource) {
      logService.info("Cannot resolve the path because it cannot be handled", path);
      return void 0;
    }
    let exists = path.exists;
    let type = path.type;
    if (typeof exists !== "boolean" || typeof type !== "number") {
      try {
        type = (await fileService.stat(resource)).isDirectory ? FileType.Directory : FileType.Unknown;
        exists = true;
      } catch (error) {
        logService.error(error);
        exists = false;
      }
    }
    if (!exists && path.openOnlyIfExists) {
      logService.info("Cannot resolve the path because it does not exist", path);
      return void 0;
    }
    if (type === FileType.Directory) {
      logService.info("Cannot resolve the path because it is a directory", path);
      return void 0;
    }
    const options = {
      ...path.options,
      pinned: true
    };
    if (!exists) {
      return { resource, options, forceUntitled: true };
    }
    return { resource, options };
  }));
}
var EditorsOrder;
(function(EditorsOrder2) {
  EditorsOrder2[EditorsOrder2["MOST_RECENTLY_ACTIVE"] = 0] = "MOST_RECENTLY_ACTIVE";
  EditorsOrder2[EditorsOrder2["SEQUENTIAL"] = 1] = "SEQUENTIAL";
})(EditorsOrder || (EditorsOrder = {}));
function isTextEditorViewState(candidate) {
  const viewState = candidate;
  if (!viewState) {
    return false;
  }
  const diffEditorViewState = viewState;
  if (diffEditorViewState.modified) {
    return isTextEditorViewState(diffEditorViewState.modified);
  }
  const codeEditorViewState = viewState;
  return !!(codeEditorViewState.contributionsState && codeEditorViewState.viewState && Array.isArray(codeEditorViewState.cursorState));
}
function createEditorOpenError(messageOrError, actions, options) {
  const error = createErrorWithActions(messageOrError, actions);
  error.forceMessage = options == null ? void 0 : options.forceMessage;
  error.forceSeverity = options == null ? void 0 : options.forceSeverity;
  error.allowDialog = options == null ? void 0 : options.allowDialog;
  return error;
}

// node_modules/vscode/vscode/src/vs/workbench/services/editor/common/editorGroupsService.js
init_instantiation();
var IEditorGroupsService = createDecorator("editorGroupsService");
var GroupDirection;
(function(GroupDirection2) {
  GroupDirection2[GroupDirection2["UP"] = 0] = "UP";
  GroupDirection2[GroupDirection2["DOWN"] = 1] = "DOWN";
  GroupDirection2[GroupDirection2["LEFT"] = 2] = "LEFT";
  GroupDirection2[GroupDirection2["RIGHT"] = 3] = "RIGHT";
})(GroupDirection || (GroupDirection = {}));
var GroupOrientation;
(function(GroupOrientation2) {
  GroupOrientation2[GroupOrientation2["HORIZONTAL"] = 0] = "HORIZONTAL";
  GroupOrientation2[GroupOrientation2["VERTICAL"] = 1] = "VERTICAL";
})(GroupOrientation || (GroupOrientation = {}));
var GroupLocation;
(function(GroupLocation2) {
  GroupLocation2[GroupLocation2["FIRST"] = 0] = "FIRST";
  GroupLocation2[GroupLocation2["LAST"] = 1] = "LAST";
  GroupLocation2[GroupLocation2["NEXT"] = 2] = "NEXT";
  GroupLocation2[GroupLocation2["PREVIOUS"] = 3] = "PREVIOUS";
})(GroupLocation || (GroupLocation = {}));
var GroupsArrangement;
(function(GroupsArrangement2) {
  GroupsArrangement2[GroupsArrangement2["MAXIMIZE"] = 0] = "MAXIMIZE";
  GroupsArrangement2[GroupsArrangement2["EVEN"] = 1] = "EVEN";
  GroupsArrangement2[GroupsArrangement2["TOGGLE"] = 2] = "TOGGLE";
})(GroupsArrangement || (GroupsArrangement = {}));
var MergeGroupMode;
(function(MergeGroupMode2) {
  MergeGroupMode2[MergeGroupMode2["COPY_EDITORS"] = 0] = "COPY_EDITORS";
  MergeGroupMode2[MergeGroupMode2["MOVE_EDITORS"] = 1] = "MOVE_EDITORS";
})(MergeGroupMode || (MergeGroupMode = {}));
var GroupsOrder;
(function(GroupsOrder2) {
  GroupsOrder2[GroupsOrder2["CREATION_TIME"] = 0] = "CREATION_TIME";
  GroupsOrder2[GroupsOrder2["MOST_RECENTLY_ACTIVE"] = 1] = "MOST_RECENTLY_ACTIVE";
  GroupsOrder2[GroupsOrder2["GRID_APPEARANCE"] = 2] = "GRID_APPEARANCE";
})(GroupsOrder || (GroupsOrder = {}));
function preferredSideBySideGroupDirection(configurationService) {
  const openSideBySideDirection = configurationService.getValue("workbench.editor.openSideBySideDirection");
  if (openSideBySideDirection === "down") {
    return 1;
  }
  return 3;
}

// node_modules/vscode/vscode/src/vs/workbench/services/editor/common/editorService.js
init_instantiation();
var IEditorService = createDecorator("editorService");
var ACTIVE_GROUP = -1;
var SIDE_GROUP = -2;

// node_modules/vscode/vscode/src/vs/workbench/services/remote/common/remoteAgentService.js
init_instantiation();
init_async();
var IRemoteAgentService = createDecorator("remoteAgentService");
var remoteConnectionLatencyMeasurer = new class {
  constructor() {
    this.maxSampleCount = 5;
    this.sampleDelay = 2e3;
    this.initial = [];
    this.maxInitialCount = 3;
    this.average = [];
    this.maxAverageCount = 100;
    this.highLatencyMultiple = 2;
    this.highLatencyMinThreshold = 500;
    this.highLatencyMaxThreshold = 1500;
    this.lastMeasurement = void 0;
  }
  get latency() {
    return this.lastMeasurement;
  }
  async measure(remoteAgentService) {
    let currentLatency = Infinity;
    for (let i = 0; i < this.maxSampleCount; i++) {
      const rtt = await remoteAgentService.getRoundTripTime();
      if (rtt === void 0) {
        return void 0;
      }
      currentLatency = Math.min(currentLatency, rtt / 2);
      await timeout(this.sampleDelay);
    }
    this.average.push(currentLatency);
    if (this.average.length > this.maxAverageCount) {
      this.average.shift();
    }
    let initialLatency = void 0;
    if (this.initial.length < this.maxInitialCount) {
      this.initial.push(currentLatency);
    } else {
      initialLatency = this.initial.reduce((sum, value) => sum + value, 0) / this.initial.length;
    }
    this.lastMeasurement = {
      initial: initialLatency,
      current: currentLatency,
      average: this.average.reduce((sum, value) => sum + value, 0) / this.average.length,
      high: (() => {
        if (typeof initialLatency === "undefined") {
          return false;
        }
        if (currentLatency > this.highLatencyMaxThreshold) {
          return true;
        }
        if (currentLatency > this.highLatencyMinThreshold && currentLatency > initialLatency * this.highLatencyMultiple) {
          return true;
        }
        return false;
      })()
    };
    return this.lastMeasurement;
  }
}();

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textfiles.js
init_files();
init_instantiation();
init_buffer();
init_types();
var ITextFileService = createDecorator("textFileService");
var TextFileOperationError = class extends FileOperationError {
  static isTextFileOperationError(obj) {
    return obj instanceof Error && !isUndefinedOrNull(obj.textFileOperationResult);
  }
  constructor(message, textFileOperationResult, options) {
    super(message, 10);
    this.textFileOperationResult = textFileOperationResult;
    this.options = options;
  }
};
function stringToSnapshot(value) {
  let done = false;
  return {
    read() {
      if (!done) {
        done = true;
        return value;
      }
      return null;
    }
  };
}
function toBufferOrReadable(value) {
  if (typeof value === "undefined") {
    return void 0;
  }
  if (typeof value === "string") {
    return VSBuffer.fromString(value);
  }
  return {
    read: () => {
      const chunk = value.read();
      if (typeof chunk === "string") {
        return VSBuffer.fromString(chunk);
      }
      return null;
    }
  };
}

// node_modules/vscode/vscode/src/vs/workbench/services/userDataProfile/common/userDataProfile.js
init_nls();
init_instantiation();
init_contextkey();
init_codicons();
var IUserDataProfileService = createDecorator("IUserDataProfileService");
var IUserDataProfileImportExportService = createDecorator("IUserDataProfileImportExportService");
var defaultUserDataProfileIcon = registerIcon("defaultProfile-icon", Codicon.settings, localize("defaultProfileIcon", "Icon for Default Profile."));
var CURRENT_PROFILE_CONTEXT = new RawContextKey("currentProfile", "");

// node_modules/vscode/vscode/src/vs/workbench/contrib/snippets/browser/snippets.js
init_instantiation();
var ISnippetsService = createDecorator("snippetService");

// node_modules/vscode/vscode/src/vs/workbench/common/configuration.js
init_tslib_es6();
init_nls();
init_configurationRegistry();
init_platform2();
init_lifecycle();
init_event();
init_platform();
var workbenchConfigurationNodeBase = Object.freeze({
  "id": "workbench",
  "order": 7,
  "title": localize("workbenchConfigurationTitle", "Workbench"),
  "type": "object"
});
var securityConfigurationNodeBase = Object.freeze({
  "id": "security",
  "scope": 1,
  "title": localize("securityConfigurationTitle", "Security"),
  "type": "object",
  "order": 7
});
var Extensions4 = {
  ConfigurationMigration: "base.contributions.configuration.migration"
};
var ConfigurationMigrationRegistry = class {
  constructor() {
    this.migrations = [];
    this._onDidRegisterConfigurationMigrations = new Emitter();
    this.onDidRegisterConfigurationMigration = this._onDidRegisterConfigurationMigrations.event;
  }
  registerConfigurationMigrations(configurationMigrations) {
    this.migrations.push(...configurationMigrations);
  }
};
var configurationMigrationRegistry = new ConfigurationMigrationRegistry();
Registry.add(Extensions4.ConfigurationMigration, configurationMigrationRegistry);
var DynamicWorkbenchConfigurationWorkbenchContribution = class DynamicWorkbenchConfigurationWorkbenchContribution2 extends Disposable {
  constructor(remoteAgentService) {
    super();
    (async () => {
      if (!isWindows) {
        const remoteEnvironment = await remoteAgentService.getEnvironment();
        if ((remoteEnvironment == null ? void 0 : remoteEnvironment.os) !== 1) {
          return;
        }
      }
      const registry = Registry.as(Extensions2.Configuration);
      registry.registerConfiguration({
        ...securityConfigurationNodeBase,
        "properties": {
          "security.allowedUNCHosts": {
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "^[^\\\\]+$",
              "patternErrorMessage": localize(
                "security.allowedUNCHosts.patternErrorMessage",
                "UNC host names must not contain backslashes."
              )
            },
            "default": [],
            "markdownDescription": localize(
              "security.allowedUNCHosts",
              "A set of UNC host names (without leading or trailing backslash, for example `192.168.0.1` or `my-server`) to allow without user confirmation. If a UNC host is being accessed that is not allowed via this setting or has not been acknowledged via user confirmation, an error will occur and the operation stopped. A restart is required when changing this setting. Find out more about this setting at https://aka.ms/vscode-windows-unc."
            ),
            "scope": 2
          },
          "security.restrictUNCAccess": {
            "type": "boolean",
            "default": true,
            "markdownDescription": localize(
              "security.restrictUNCAccess",
              "If enabled, only allows access to UNC host names that are allowed by the `#security.allowedUNCHosts#` setting or after user confirmation. Find out more about this setting at https://aka.ms/vscode-windows-unc."
            ),
            "scope": 2
          }
        }
      });
    })();
  }
};
DynamicWorkbenchConfigurationWorkbenchContribution = __decorate([
  __param(0, IRemoteAgentService)
], DynamicWorkbenchConfigurationWorkbenchContribution);

// node_modules/vscode/vscode/src/vs/platform/extensionResourceLoader/common/extensionResourceLoader.js
init_platform();
init_strings();
init_uri();
init_instantiation();

// node_modules/vscode/vscode/src/vs/platform/externalServices/common/serviceMachineId.js
init_buffer();
init_uuid();
async function getServiceMachineId(environmentService, fileService, storageService) {
  let uuid = storageService ? storageService.get("storage.serviceMachineId", -1) || null : null;
  if (uuid) {
    return uuid;
  }
  try {
    const contents = await fileService.readFile(environmentService.serviceMachineIdResource);
    const value = contents.value.toString();
    uuid = isUUID(value) ? value : null;
  } catch (e2) {
    uuid = null;
  }
  if (!uuid) {
    uuid = generateUuid();
    try {
      await fileService.writeFile(environmentService.serviceMachineIdResource, VSBuffer.fromString(uuid));
    } catch (error) {
    }
  }
  storageService == null ? void 0 : storageService.store("storage.serviceMachineId", uuid, -1, 1);
  return uuid;
}

// node_modules/vscode/vscode/src/vs/platform/extensionResourceLoader/common/extensionResourceLoader.js
init_telemetryUtils();
init_network();
init_remoteHosts();
var WEB_EXTENSION_RESOURCE_END_POINT = "web-extension-resource";
var IExtensionResourceLoaderService = createDecorator("extensionResourceLoaderService");
var AbstractExtensionResourceLoaderService = class {
  constructor(_fileService, _storageService, _productService, _environmentService, _configurationService) {
    this._fileService = _fileService;
    this._storageService = _storageService;
    this._productService = _productService;
    this._environmentService = _environmentService;
    this._configurationService = _configurationService;
    this._webExtensionResourceEndPoint = `${getRemoteServerRootPath(_productService)}/${WEB_EXTENSION_RESOURCE_END_POINT}/`;
    if (_productService.extensionsGallery) {
      this._extensionGalleryResourceUrlTemplate = _productService.extensionsGallery.resourceUrlTemplate;
      this._extensionGalleryAuthority = this._extensionGalleryResourceUrlTemplate ? this._getExtensionGalleryAuthority(URI.parse(this._extensionGalleryResourceUrlTemplate)) : void 0;
    }
  }
  get supportsExtensionGalleryResources() {
    return this._extensionGalleryResourceUrlTemplate !== void 0;
  }
  getExtensionGalleryResourceURL({ publisher, name, version, targetPlatform }, path) {
    if (this._extensionGalleryResourceUrlTemplate) {
      const uri = URI.parse(format2(this._extensionGalleryResourceUrlTemplate, {
        publisher,
        name,
        version: targetPlatform !== void 0 && targetPlatform !== "undefined" && targetPlatform !== "unknown" && targetPlatform !== "universal" ? `${version}+${targetPlatform}` : version,
        path: "extension"
      }));
      return this._isWebExtensionResourceEndPoint(uri) ? uri.with({ scheme: RemoteAuthorities.getPreferredWebSchema() }) : uri;
    }
    return void 0;
  }
  isExtensionGalleryResource(uri) {
    return !!this._extensionGalleryAuthority && this._extensionGalleryAuthority === this._getExtensionGalleryAuthority(uri);
  }
  async getExtensionGalleryRequestHeaders() {
    const headers = {
      "X-Client-Name": `${this._productService.applicationName}${isWeb ? "-web" : ""}`,
      "X-Client-Version": this._productService.version
    };
    if (supportsTelemetry(this._productService, this._environmentService) && getTelemetryLevel(this._configurationService) === 3) {
      headers["X-Machine-Id"] = await this._getServiceMachineId();
    }
    if (this._productService.commit) {
      headers["X-Client-Commit"] = this._productService.commit;
    }
    return headers;
  }
  _getServiceMachineId() {
    if (!this._serviceMachineIdPromise) {
      this._serviceMachineIdPromise = getServiceMachineId(this._environmentService, this._fileService, this._storageService);
    }
    return this._serviceMachineIdPromise;
  }
  _getExtensionGalleryAuthority(uri) {
    if (this._isWebExtensionResourceEndPoint(uri)) {
      return uri.authority;
    }
    const index = uri.authority.indexOf(".");
    return index !== -1 ? uri.authority.substring(index + 1) : void 0;
  }
  _isWebExtensionResourceEndPoint(uri) {
    return uri.path.startsWith(this._webExtensionResourceEndPoint);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/accessibility/browser/accessibleView.js
init_tslib_es6();
init_dom();
init_keyboardEvent();
init_aria();
init_codicons();
init_lifecycle();
init_platform();
init_themables();
init_uri();
init_editorExtensions();
init_model();
init_nls();
init_actions2();
init_configuration();
init_contextkey();
init_instantiation();
init_opener();

// node_modules/vscode/vscode/src/vs/workbench/contrib/accessibility/browser/accessibilityConfiguration.js
init_nls();
init_configurationRegistry();
init_platform2();
init_contextkey();
var accessibilityHelpIsShown = new RawContextKey("accessibilityHelpIsShown", false, true);
var accessibleViewIsShown = new RawContextKey("accessibleViewIsShown", false, true);
var accessibleViewSupportsNavigation = new RawContextKey("accessibleViewSupportsNavigation", false, true);
var accessibleViewVerbosityEnabled = new RawContextKey("accessibleViewVerbosityEnabled", false, true);
var accessibleViewGoToSymbolSupported = new RawContextKey("accessibleViewGoToSymbolSupported", false, true);
var accessibleViewCurrentProviderId = new RawContextKey("accessibleViewCurrentProviderId", void 0, void 0);
var baseProperty = {
  type: "boolean",
  default: true,
  tags: ["accessibility"]
};
var configuration = {
  id: "accessibility",
  title: localize("accessibilityConfigurationTitle", "Accessibility"),
  type: "object",
  properties: {
    ["accessibility.verbosity.terminal"]: {
      description: localize(
        "verbosity.terminal.description",
        "Provide information about how to access the terminal accessibility help menu when the terminal is focused"
      ),
      ...baseProperty
    },
    ["accessibility.verbosity.diffEditor"]: {
      description: localize(
        "verbosity.diffEditor.description",
        "Provide information about how to navigate changes in the diff editor when it is focused"
      ),
      ...baseProperty
    },
    ["accessibility.verbosity.panelChat"]: {
      description: localize(
        "verbosity.chat.description",
        "Provide information about how to access the chat help menu when the chat input is focused"
      ),
      ...baseProperty
    },
    ["accessibility.verbosity.inlineChat"]: {
      description: localize(
        "verbosity.interactiveEditor.description",
        "Provide information about how to access the inline editor chat accessibility help menu and alert with hints which describe how to use the feature when the input is focused"
      ),
      ...baseProperty
    },
    ["accessibility.verbosity.inlineCompletions"]: {
      description: localize(
        "verbosity.inlineCompletions.description",
        "Provide information about how to access the inline completions hover and accessible view"
      ),
      ...baseProperty
    },
    ["accessibility.verbosity.keybindingsEditor"]: {
      description: localize(
        "verbosity.keybindingsEditor.description",
        "Provide information about how to change a keybinding in the keybindings editor when a row is focused"
      ),
      ...baseProperty
    },
    ["accessibility.verbosity.notebook"]: {
      description: localize(
        "verbosity.notebook",
        "Provide information about how to focus the cell container or inner editor when a notebook cell is focused."
      ),
      ...baseProperty
    },
    ["accessibility.verbosity.hover"]: {
      description: localize(
        "verbosity.hover",
        "Provide information about how to open the hover in an accessible view."
      ),
      ...baseProperty
    },
    ["accessibility.verbosity.notification"]: {
      description: localize(
        "verbosity.notification",
        "Provide information about how to open the notification in an accessible view."
      ),
      ...baseProperty
    },
    ["accessibility.verbosity.untitledHint"]: {
      description: localize(
        "verbosity.untitledhint",
        "Provide information about relevant actions in an untitled text editor."
      ),
      ...baseProperty
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/snippets/browser/tabCompletion.js
init_tslib_es6();
init_contextkey();

// node_modules/vscode/vscode/src/vs/workbench/contrib/snippets/browser/snippetsService.js
init_tslib_es6();
init_lifecycle();
init_resources();
init_strings();
init_language();
init_nls();
init_environment();
init_files();
init_log();

// node_modules/vscode/vscode/src/vs/workbench/contrib/snippets/browser/snippetsFile.js
init_nls();
init_path();
init_async();
init_resources();
init_types();
init_arrays();
init_iterator();
var SnippetBodyInsights = class {
  constructor(body) {
    this.isBogous = false;
    this.isTrivial = false;
    this.usesClipboardVariable = false;
    this.usesSelectionVariable = false;
    this.codeSnippet = body;
    const textmateSnippet = new SnippetParser().parse(body, false);
    const placeholders = /* @__PURE__ */ new Map();
    let placeholderMax = 0;
    for (const placeholder of textmateSnippet.placeholders) {
      placeholderMax = Math.max(placeholderMax, placeholder.index);
    }
    if (textmateSnippet.placeholders.length === 0) {
      this.isTrivial = true;
    } else if (placeholderMax === 0) {
      const last = tail(textmateSnippet.children);
      this.isTrivial = last instanceof Placeholder && last.isFinalTabstop;
    }
    const stack = [...textmateSnippet.children];
    while (stack.length > 0) {
      const marker = stack.shift();
      if (marker instanceof Variable) {
        if (marker.children.length === 0 && !KnownSnippetVariableNames[marker.name]) {
          const index = placeholders.has(marker.name) ? placeholders.get(marker.name) : ++placeholderMax;
          placeholders.set(marker.name, index);
          const synthetic = new Placeholder(index).appendChild(new Text(marker.name));
          textmateSnippet.replace(marker, [synthetic]);
          this.isBogous = true;
        }
        switch (marker.name) {
          case "CLIPBOARD":
            this.usesClipboardVariable = true;
            break;
          case "SELECTION":
          case "TM_SELECTED_TEXT":
            this.usesSelectionVariable = true;
            break;
        }
      } else {
        stack.push(...marker.children);
      }
    }
    if (this.isBogous) {
      this.codeSnippet = textmateSnippet.toTextmateString();
    }
  }
};
var Snippet = class {
  constructor(isFileTemplate, scopes, name, prefix, description, body, source, snippetSource, snippetIdentifier, extensionId) {
    this.isFileTemplate = isFileTemplate;
    this.scopes = scopes;
    this.name = name;
    this.prefix = prefix;
    this.description = description;
    this.body = body;
    this.source = source;
    this.snippetSource = snippetSource;
    this.snippetIdentifier = snippetIdentifier;
    this.extensionId = extensionId;
    this.prefixLow = prefix.toLowerCase();
    this._bodyInsights = new IdleValue(() => new SnippetBodyInsights(this.body));
  }
  get codeSnippet() {
    return this._bodyInsights.value.codeSnippet;
  }
  get isBogous() {
    return this._bodyInsights.value.isBogous;
  }
  get isTrivial() {
    return this._bodyInsights.value.isTrivial;
  }
  get needsClipboard() {
    return this._bodyInsights.value.usesClipboardVariable;
  }
  get usesSelection() {
    return this._bodyInsights.value.usesSelectionVariable;
  }
};
function isJsonSerializedSnippet(thing) {
  return isObject(thing) && Boolean(thing.body);
}
var SnippetFile = class {
  constructor(source, location, defaultScopes, _extension, _fileService, _extensionResourceLoaderService) {
    this.source = source;
    this.location = location;
    this.defaultScopes = defaultScopes;
    this._extension = _extension;
    this._fileService = _fileService;
    this._extensionResourceLoaderService = _extensionResourceLoaderService;
    this.data = [];
    this.isGlobalSnippets = extname(location.path) === ".code-snippets";
    this.isUserSnippets = !this._extension;
  }
  select(selector, bucket) {
    if (this.isGlobalSnippets || !this.isUserSnippets) {
      this._scopeSelect(selector, bucket);
    } else {
      this._filepathSelect(selector, bucket);
    }
  }
  _filepathSelect(selector, bucket) {
    if (selector + ".json" === basename(this.location.path)) {
      bucket.push(...this.data);
    }
  }
  _scopeSelect(selector, bucket) {
    for (const snippet of this.data) {
      const len = snippet.scopes.length;
      if (len === 0) {
        bucket.push(snippet);
      } else {
        for (let i = 0; i < len; i++) {
          if (snippet.scopes[i] === selector) {
            bucket.push(snippet);
            break;
          }
        }
      }
    }
    const idx = selector.lastIndexOf(".");
    if (idx >= 0) {
      this._scopeSelect(selector.substring(0, idx), bucket);
    }
  }
  async _load() {
    if (this._extension) {
      return this._extensionResourceLoaderService.readExtensionResource(this.location);
    } else {
      const content = await this._fileService.readFile(this.location);
      return content.value.toString();
    }
  }
  load() {
    if (!this._loadPromise) {
      this._loadPromise = Promise.resolve(this._load()).then((content) => {
        const data = parse(content);
        if (getNodeType(data) === "object") {
          for (const [name, scopeOrTemplate] of Object.entries(data)) {
            if (isJsonSerializedSnippet(scopeOrTemplate)) {
              this._parseSnippet(name, scopeOrTemplate, this.data);
            } else {
              for (const [name2, template] of Object.entries(scopeOrTemplate)) {
                this._parseSnippet(name2, template, this.data);
              }
            }
          }
        }
        return this;
      });
    }
    return this._loadPromise;
  }
  reset() {
    this._loadPromise = void 0;
    this.data.length = 0;
  }
  _parseSnippet(name, snippet, bucket) {
    var _a5;
    let { isFileTemplate, prefix, body, description } = snippet;
    if (!prefix) {
      prefix = "";
    }
    if (Array.isArray(body)) {
      body = body.join("\n");
    }
    if (typeof body !== "string") {
      return;
    }
    if (Array.isArray(description)) {
      description = description.join("\n");
    }
    let scopes;
    if (this.defaultScopes) {
      scopes = this.defaultScopes;
    } else if (typeof snippet.scope === "string") {
      scopes = snippet.scope.split(",").map((s) => s.trim()).filter(Boolean);
    } else {
      scopes = [];
    }
    let source;
    if (this._extension) {
      source = this._extension.displayName || this._extension.name;
    } else if (this.source === 2) {
      source = localize("source.workspaceSnippetGlobal", "Workspace Snippet");
    } else {
      if (this.isGlobalSnippets) {
        source = localize("source.userSnippetGlobal", "Global User Snippet");
      } else {
        source = localize("source.userSnippet", "User Snippet");
      }
    }
    for (const _prefix of Iterable.wrap(prefix)) {
      bucket.push(new Snippet(
        Boolean(isFileTemplate),
        scopes,
        name,
        _prefix,
        description,
        body,
        source,
        this.source,
        this._extension ? `${relativePath(this._extension.extensionLocation, this.location)}/${name}` : `${basename(this.location.path)}/${name}`,
        (_a5 = this._extension) == null ? void 0 : _a5.identifier
      ));
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/snippets/browser/snippetCompletionProvider.js
init_tslib_es6();
init_htmlContent();
init_strings();
init_range();
init_language();
init_nls();
init_filters();
init_stopwatch();
init_languageConfigurationRegistry();
init_wordHelper();
init_commands();
var markSnippetAsUsed = "_snippet.markAsUsed";
CommandsRegistry.registerCommand(markSnippetAsUsed, (accessor, ...args) => {
  const snippetsService = accessor.get(ISnippetsService);
  const [first] = args;
  if (first instanceof Snippet) {
    snippetsService.updateUsageTimestamp(first);
  }
});
var SnippetCompletion = class {
  constructor(snippet, range) {
    this.snippet = snippet;
    this.label = { label: snippet.prefix, description: snippet.name };
    this.detail = localize(
      "detail.snippet",
      "{0} ({1})",
      snippet.description || snippet.name,
      snippet.source
    );
    this.insertText = snippet.codeSnippet;
    this.extensionId = snippet.extensionId;
    this.range = range;
    this.sortText = `${snippet.snippetSource === 3 ? "z" : "a"}-${snippet.prefix}`;
    this.kind = 27;
    this.insertTextRules = 4;
    this.command = { id: markSnippetAsUsed, title: "", arguments: [snippet] };
  }
  resolve() {
    this.documentation = new MarkdownString().appendCodeblock("", SnippetParser.asInsertText(this.snippet.codeSnippet));
    return this;
  }
  static compareByLabel(a, b) {
    return compare(a.label.label, b.label.label);
  }
};
var SnippetCompletionProvider = class SnippetCompletionProvider2 {
  constructor(_languageService, _snippets, _languageConfigurationService) {
    this._languageService = _languageService;
    this._snippets = _snippets;
    this._languageConfigurationService = _languageConfigurationService;
    this._debugDisplayName = "snippetCompletions";
  }
  async provideCompletionItems(model, position, context) {
    var _a5;
    const sw = new StopWatch();
    const languageId = this._getLanguageIdAtPosition(model, position);
    const languageConfig = this._languageConfigurationService.getLanguageConfiguration(languageId);
    const snippets = new Set(await this._snippets.getSnippets(languageId));
    const lineContentLow = model.getLineContent(position.lineNumber).toLowerCase();
    const wordUntil = model.getWordUntilPosition(position).word.toLowerCase();
    const suggestions = [];
    const columnOffset = position.column - 1;
    const triggerCharacterLow = ((_a5 = context.triggerCharacter) == null ? void 0 : _a5.toLowerCase()) ?? "";
    snippet:
      for (const snippet of snippets) {
        if (context.triggerKind === 1 && !snippet.prefixLow.startsWith(triggerCharacterLow)) {
          continue snippet;
        }
        const word = getWordAtText(1, languageConfig.getWordDefinition(), snippet.prefixLow, 0);
        if (wordUntil && word && !isPatternInWord(wordUntil, 0, wordUntil.length, snippet.prefixLow, 0, snippet.prefixLow.length)) {
          continue snippet;
        }
        const minPos = firstNonWhitespaceIndex(snippet.prefixLow) === 0 ? Math.max(0, model.getLineFirstNonWhitespaceColumn(position.lineNumber) - 1) : 0;
        column:
          for (let pos = Math.max(minPos, columnOffset - snippet.prefixLow.length); pos < lineContentLow.length; pos++) {
            if (!isPatternInWord(lineContentLow, pos, columnOffset, snippet.prefixLow, 0, snippet.prefixLow.length)) {
              continue column;
            }
            const prefixRestLen = snippet.prefixLow.length - (columnOffset - pos);
            const endsWithPrefixRest = compareSubstring(lineContentLow, snippet.prefixLow, columnOffset, columnOffset + prefixRestLen, columnOffset - pos);
            const startPosition = position.with(void 0, pos + 1);
            if (wordUntil && position.equals(startPosition)) {
              continue snippet;
            }
            let endColumn = endsWithPrefixRest === 0 ? position.column + prefixRestLen : position.column;
            if (columnOffset < lineContentLow.length) {
              const autoClosingPairs = languageConfig.getAutoClosingPairs();
              const standardAutoClosingPairConditionals = autoClosingPairs.autoClosingPairsCloseSingleChar.get(lineContentLow[columnOffset]);
              if (standardAutoClosingPairConditionals == null ? void 0 : standardAutoClosingPairConditionals.some((p) => p.open === lineContentLow[startPosition.column - 1] && snippet.prefix.startsWith(p.open) && snippet.prefix[snippet.prefix.length - 1] === p.close)) {
                endColumn++;
              }
            }
            const replace = Range.fromPositions(startPosition, { lineNumber: position.lineNumber, column: endColumn });
            const insert = replace.setEndPosition(position.lineNumber, position.column);
            suggestions.push(new SnippetCompletion(snippet, { replace, insert }));
            snippets.delete(snippet);
            break;
          }
      }
    if (!triggerCharacterLow) {
      const endsInWhitespace = /\s/.test(lineContentLow[position.column - 2]);
      if (endsInWhitespace || !lineContentLow) {
        for (const snippet of snippets) {
          const insert = Range.fromPositions(position);
          const replace = lineContentLow.indexOf(snippet.prefixLow, columnOffset) === columnOffset ? insert.setEndPosition(position.lineNumber, position.column + snippet.prefixLow.length) : insert;
          suggestions.push(new SnippetCompletion(snippet, { replace, insert }));
        }
      }
    }
    suggestions.sort(SnippetCompletion.compareByLabel);
    for (let i = 0; i < suggestions.length; i++) {
      const item = suggestions[i];
      let to = i + 1;
      for (; to < suggestions.length && item.label === suggestions[to].label; to++) {
        suggestions[to].label.label = localize(
          "snippetSuggest.longLabel",
          "{0}, {1}",
          suggestions[to].label.label,
          suggestions[to].snippet.name
        );
      }
      if (to > i + 1) {
        suggestions[i].label.label = localize(
          "snippetSuggest.longLabel",
          "{0}, {1}",
          suggestions[i].label.label,
          suggestions[i].snippet.name
        );
        i = to;
      }
    }
    return {
      suggestions,
      duration: sw.elapsed()
    };
  }
  resolveCompletionItem(item) {
    return item instanceof SnippetCompletion ? item.resolve() : item;
  }
  _getLanguageIdAtPosition(model, position) {
    model.tokenization.tokenizeIfCheap(position.lineNumber);
    let languageId = model.getLanguageIdAtPosition(position.lineNumber, position.column);
    if (!this._languageService.getLanguageName(languageId)) {
      languageId = model.getLanguageId();
    }
    return languageId;
  }
};
SnippetCompletionProvider = __decorate([
  __param(0, ILanguageService),
  __param(1, ISnippetsService),
  __param(2, ILanguageConfigurationService)
], SnippetCompletionProvider);

// node_modules/vscode/vscode/src/vs/workbench/contrib/snippets/browser/snippetsService.js
init_map();
init_types();
init_instantiation();
init_languageConfigurationRegistry();
init_arrays();
var SnippetEnablement_1;
var SnippetUsageTimestamps_1;
var snippetExt;
(function(snippetExt2) {
  function toValidSnippet(extension, snippet, languageService) {
    if (isFalsyOrWhitespace(snippet.path)) {
      extension.collector.error(localize(
        "invalid.path.0",
        "Expected string in `contributes.{0}.path`. Provided value: {1}",
        extension.description.name,
        String(snippet.path)
      ));
      return null;
    }
    if (isFalsyOrWhitespace(snippet.language) && !snippet.path.endsWith(".code-snippets")) {
      extension.collector.error(localize(
        "invalid.language.0",
        "When omitting the language, the value of `contributes.{0}.path` must be a `.code-snippets`-file. Provided value: {1}",
        extension.description.name,
        String(snippet.path)
      ));
      return null;
    }
    if (!isFalsyOrWhitespace(snippet.language) && !languageService.isRegisteredLanguageId(snippet.language)) {
      extension.collector.error(localize(
        "invalid.language",
        "Unknown language in `contributes.{0}.language`. Provided value: {1}",
        extension.description.name,
        String(snippet.language)
      ));
      return null;
    }
    const extensionLocation = extension.description.extensionLocation;
    const snippetLocation = joinPath(extensionLocation, snippet.path);
    if (!isEqualOrParent(snippetLocation, extensionLocation)) {
      extension.collector.error(localize(
        "invalid.path.1",
        "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.",
        extension.description.name,
        snippetLocation.path,
        extensionLocation.path
      ));
      return null;
    }
    return {
      language: snippet.language,
      location: snippetLocation
    };
  }
  snippetExt2.toValidSnippet = toValidSnippet;
  snippetExt2.snippetsContribution = {
    description: localize("vscode.extension.contributes.snippets", "Contributes snippets."),
    type: "array",
    defaultSnippets: [{ body: [{ language: "", path: "" }] }],
    items: {
      type: "object",
      defaultSnippets: [{ body: { language: "${1:id}", path: "./snippets/${2:id}.json." } }],
      properties: {
        language: {
          description: localize(
            "vscode.extension.contributes.snippets-language",
            "Language identifier for which this snippet is contributed to."
          ),
          type: "string"
        },
        path: {
          description: localize(
            "vscode.extension.contributes.snippets-path",
            "Path of the snippets file. The path is relative to the extension folder and typically starts with './snippets/'."
          ),
          type: "string"
        }
      }
    }
  };
  snippetExt2.point = ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: "snippets",
    deps: [languagesExtPoint],
    jsonSchema: snippetExt2.snippetsContribution
  });
})(snippetExt || (snippetExt = {}));
function watch(service, resource, callback) {
  return combinedDisposable(service.watch(resource), service.onDidFilesChange((e2) => {
    if (e2.affects(resource)) {
      callback();
    }
  }));
}
var _a;
var SnippetEnablement = (_a = class {
  constructor(_storageService) {
    this._storageService = _storageService;
    const raw = _storageService.get(SnippetEnablement_1._key, 0, "");
    let data;
    try {
      data = JSON.parse(raw);
    } catch {
    }
    this._ignored = isStringArray(data) ? new Set(data) : /* @__PURE__ */ new Set();
  }
  isIgnored(id) {
    return this._ignored.has(id);
  }
  updateIgnored(id, value) {
    let changed = false;
    if (this._ignored.has(id) && !value) {
      this._ignored.delete(id);
      changed = true;
    } else if (!this._ignored.has(id) && value) {
      this._ignored.add(id);
      changed = true;
    }
    if (changed) {
      this._storageService.store(SnippetEnablement_1._key, JSON.stringify(Array.from(this._ignored)), 0, 0);
    }
  }
}, SnippetEnablement_1 = _a, _a._key = "snippets.ignoredSnippets", _a);
SnippetEnablement = SnippetEnablement_1 = __decorate([
  __param(0, IStorageService)
], SnippetEnablement);
var _a2;
var SnippetUsageTimestamps = (_a2 = class {
  constructor(_storageService) {
    this._storageService = _storageService;
    const raw = _storageService.get(SnippetUsageTimestamps_1._key, 0, "");
    let data;
    try {
      data = JSON.parse(raw);
    } catch {
      data = [];
    }
    this._usages = Array.isArray(data) ? new Map(data) : /* @__PURE__ */ new Map();
  }
  getUsageTimestamp(id) {
    return this._usages.get(id);
  }
  updateUsageTimestamp(id) {
    this._usages.delete(id);
    this._usages.set(id, Date.now());
    const all = [...this._usages].slice(-100);
    this._storageService.store(SnippetUsageTimestamps_1._key, JSON.stringify(all), 0, 0);
  }
}, SnippetUsageTimestamps_1 = _a2, _a2._key = "snippets.usageTimestamps", _a2);
SnippetUsageTimestamps = SnippetUsageTimestamps_1 = __decorate([
  __param(0, IStorageService)
], SnippetUsageTimestamps);
var SnippetsService = class SnippetsService2 {
  constructor(_environmentService, _userDataProfileService, _contextService, _languageService, _logService, _fileService, _textfileService, _extensionResourceLoaderService, lifecycleService, instantiationService, languageConfigurationService) {
    this._environmentService = _environmentService;
    this._userDataProfileService = _userDataProfileService;
    this._contextService = _contextService;
    this._languageService = _languageService;
    this._logService = _logService;
    this._fileService = _fileService;
    this._textfileService = _textfileService;
    this._extensionResourceLoaderService = _extensionResourceLoaderService;
    this._disposables = new DisposableStore();
    this._pendingWork = [];
    this._files = new ResourceMap();
    this._pendingWork.push(Promise.resolve(lifecycleService.when(3).then(() => {
      this._initExtensionSnippets();
      this._initUserSnippets();
      this._initWorkspaceSnippets();
    })));
    setSnippetSuggestSupport(new SnippetCompletionProvider(this._languageService, this, languageConfigurationService));
    this._enablement = instantiationService.createInstance(SnippetEnablement);
    this._usageTimestamps = instantiationService.createInstance(SnippetUsageTimestamps);
  }
  dispose() {
    this._disposables.dispose();
  }
  isEnabled(snippet) {
    return !this._enablement.isIgnored(snippet.snippetIdentifier);
  }
  updateEnablement(snippet, enabled) {
    this._enablement.updateIgnored(snippet.snippetIdentifier, !enabled);
  }
  updateUsageTimestamp(snippet) {
    this._usageTimestamps.updateUsageTimestamp(snippet.snippetIdentifier);
  }
  _joinSnippets() {
    const promises = this._pendingWork.slice(0);
    this._pendingWork.length = 0;
    return Promise.all(promises);
  }
  async getSnippetFiles() {
    await this._joinSnippets();
    return this._files.values();
  }
  async getSnippets(languageId, opts) {
    await this._joinSnippets();
    const result = [];
    const promises = [];
    if (languageId) {
      if (this._languageService.isRegisteredLanguageId(languageId)) {
        for (const file of this._files.values()) {
          promises.push(file.load().then((file2) => file2.select(languageId, result)).catch((err) => this._logService.error(err, file.location.toString())));
        }
      }
    } else {
      for (const file of this._files.values()) {
        promises.push(file.load().then((file2) => insertInto(result, result.length, file2.data)).catch((err) => this._logService.error(err, file.location.toString())));
      }
    }
    await Promise.all(promises);
    return this._filterAndSortSnippets(result, opts);
  }
  getSnippetsSync(languageId, opts) {
    const result = [];
    if (this._languageService.isRegisteredLanguageId(languageId)) {
      for (const file of this._files.values()) {
        file.load().catch((_err) => {
        });
        file.select(languageId, result);
      }
    }
    return this._filterAndSortSnippets(result, opts);
  }
  _filterAndSortSnippets(snippets, opts) {
    const result = [];
    for (const snippet of snippets) {
      if (!snippet.prefix && !(opts == null ? void 0 : opts.includeNoPrefixSnippets)) {
        continue;
      }
      if (!this.isEnabled(snippet) && !(opts == null ? void 0 : opts.includeDisabledSnippets)) {
        continue;
      }
      if (typeof (opts == null ? void 0 : opts.fileTemplateSnippets) === "boolean" && opts.fileTemplateSnippets !== snippet.isFileTemplate) {
        continue;
      }
      result.push(snippet);
    }
    return result.sort((a, b) => {
      let result2 = 0;
      if (!(opts == null ? void 0 : opts.noRecencySort)) {
        const val1 = this._usageTimestamps.getUsageTimestamp(a.snippetIdentifier) ?? -1;
        const val2 = this._usageTimestamps.getUsageTimestamp(b.snippetIdentifier) ?? -1;
        result2 = val2 - val1;
      }
      if (result2 === 0) {
        result2 = this._compareSnippet(a, b);
      }
      return result2;
    });
  }
  _compareSnippet(a, b) {
    if (a.snippetSource < b.snippetSource) {
      return -1;
    } else if (a.snippetSource > b.snippetSource) {
      return 1;
    } else if (a.source < b.source) {
      return -1;
    } else if (a.source > b.source) {
      return 1;
    } else if (a.name > b.name) {
      return 1;
    } else if (a.name < b.name) {
      return -1;
    } else {
      return 0;
    }
  }
  _initExtensionSnippets() {
    snippetExt.point.setHandler((extensions) => {
      for (const [key, value] of this._files) {
        if (value.source === 3) {
          this._files.delete(key);
        }
      }
      for (const extension of extensions) {
        for (const contribution of extension.value) {
          const validContribution = snippetExt.toValidSnippet(extension, contribution, this._languageService);
          if (!validContribution) {
            continue;
          }
          const file = this._files.get(validContribution.location);
          if (file) {
            if (file.defaultScopes) {
              file.defaultScopes.push(validContribution.language);
            } else {
              file.defaultScopes = [];
            }
          } else {
            const file2 = new SnippetFile(
              3,
              validContribution.location,
              validContribution.language ? [validContribution.language] : void 0,
              extension.description,
              this._fileService,
              this._extensionResourceLoaderService
            );
            this._files.set(file2.location, file2);
            if (this._environmentService.isExtensionDevelopment) {
              file2.load().then((file3) => {
                if (file3.data.some((snippet) => snippet.isBogous)) {
                  extension.collector.warn(localize(
                    "badVariableUse",
                    "One or more snippets from the extension '{0}' very likely confuse snippet-variables and snippet-placeholders (see https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax for more details)",
                    extension.description.name
                  ));
                }
              }, (err) => {
                extension.collector.warn(localize(
                  "badFile",
                  'The snippet file "{0}" could not be read.',
                  file2.location.toString()
                ));
              });
            }
          }
        }
      }
    });
  }
  _initWorkspaceSnippets() {
    const disposables = new DisposableStore();
    const updateWorkspaceSnippets = () => {
      disposables.clear();
      this._pendingWork.push(this._initWorkspaceFolderSnippets(this._contextService.getWorkspace(), disposables));
    };
    this._disposables.add(disposables);
    this._disposables.add(this._contextService.onDidChangeWorkspaceFolders(updateWorkspaceSnippets));
    this._disposables.add(this._contextService.onDidChangeWorkbenchState(updateWorkspaceSnippets));
    updateWorkspaceSnippets();
  }
  async _initWorkspaceFolderSnippets(workspace, bucket) {
    const promises = workspace.folders.map(async (folder) => {
      const snippetFolder = folder.toResource(".vscode");
      const value = await this._fileService.exists(snippetFolder);
      if (value) {
        this._initFolderSnippets(2, snippetFolder, bucket);
      } else {
        bucket.add(this._fileService.onDidFilesChange((e2) => {
          if (e2.contains(snippetFolder, 1)) {
            this._initFolderSnippets(2, snippetFolder, bucket);
          }
        }));
      }
    });
    await Promise.all(promises);
  }
  async _initUserSnippets() {
    const disposables = new DisposableStore();
    const updateUserSnippets = async () => {
      disposables.clear();
      const userSnippetsFolder = this._userDataProfileService.currentProfile.snippetsHome;
      await this._fileService.createFolder(userSnippetsFolder);
      await this._initFolderSnippets(1, userSnippetsFolder, disposables);
    };
    this._disposables.add(disposables);
    this._disposables.add(this._userDataProfileService.onDidChangeCurrentProfile((e2) => e2.join((async () => {
      this._pendingWork.push(updateUserSnippets());
    })())));
    await updateUserSnippets();
  }
  _initFolderSnippets(source, folder, bucket) {
    const disposables = new DisposableStore();
    const addFolderSnippets = async () => {
      disposables.clear();
      if (!await this._fileService.exists(folder)) {
        return;
      }
      try {
        const stat = await this._fileService.resolve(folder);
        for (const entry of stat.children || []) {
          disposables.add(this._addSnippetFile(entry.resource, source));
        }
      } catch (err) {
        this._logService.error(`Failed snippets from folder '${folder.toString()}'`, err);
      }
    };
    bucket.add(this._textfileService.files.onDidSave((e2) => {
      if (isEqualOrParent(e2.model.resource, folder)) {
        addFolderSnippets();
      }
    }));
    bucket.add(watch(this._fileService, folder, addFolderSnippets));
    bucket.add(disposables);
    return addFolderSnippets();
  }
  _addSnippetFile(uri, source) {
    const ext = extname2(uri);
    if (source === 1 && ext === ".json") {
      const langName = basename2(uri).replace(/\.json/, "");
      this._files.set(uri, new SnippetFile(
        source,
        uri,
        [langName],
        void 0,
        this._fileService,
        this._extensionResourceLoaderService
      ));
    } else if (ext === ".code-snippets") {
      this._files.set(uri, new SnippetFile(
        source,
        uri,
        void 0,
        void 0,
        this._fileService,
        this._extensionResourceLoaderService
      ));
    }
    return {
      dispose: () => this._files.delete(uri)
    };
  }
};
SnippetsService = __decorate([
  __param(0, IEnvironmentService),
  __param(1, IUserDataProfileService),
  __param(2, IWorkspaceContextService),
  __param(3, ILanguageService),
  __param(4, ILogService),
  __param(5, IFileService),
  __param(6, ITextFileService),
  __param(7, IExtensionResourceLoaderService),
  __param(8, ILifecycleService),
  __param(9, IInstantiationService),
  __param(10, ILanguageConfigurationService)
], SnippetsService);
function getNonWhitespacePrefix(model, position) {
  const MAX_PREFIX_LENGTH = 100;
  const line = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
  const minChIndex = Math.max(0, line.length - MAX_PREFIX_LENGTH);
  for (let chIndex = line.length - 1; chIndex >= minChIndex; chIndex--) {
    const ch = line.charAt(chIndex);
    if (/\s/.test(ch)) {
      return line.substr(chIndex + 1);
    }
  }
  if (minChIndex === 0) {
    return line;
  }
  return "";
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/snippets/browser/tabCompletion.js
init_range();
init_editorExtensions();
init_editorContextKeys();
init_editorState();
init_languageFeatures();
var TabCompletionController_1;
var _a3;
var TabCompletionController = (_a3 = class {
  static get(editor) {
    return editor.getContribution(TabCompletionController_1.ID);
  }
  constructor(_editor, _snippetService, _clipboardService, _languageFeaturesService, contextKeyService) {
    this._editor = _editor;
    this._snippetService = _snippetService;
    this._clipboardService = _clipboardService;
    this._languageFeaturesService = _languageFeaturesService;
    this._activeSnippets = [];
    this._hasSnippets = TabCompletionController_1.ContextKey.bindTo(contextKeyService);
    this._configListener = this._editor.onDidChangeConfiguration((e2) => {
      if (e2.hasChanged(121)) {
        this._update();
      }
    });
    this._update();
  }
  dispose() {
    var _a5;
    this._configListener.dispose();
    (_a5 = this._selectionListener) == null ? void 0 : _a5.dispose();
  }
  _update() {
    var _a5;
    const enabled = this._editor.getOption(121) === "onlySnippets";
    if (this._enabled !== enabled) {
      this._enabled = enabled;
      if (!this._enabled) {
        (_a5 = this._selectionListener) == null ? void 0 : _a5.dispose();
      } else {
        this._selectionListener = this._editor.onDidChangeCursorSelection((e2) => this._updateSnippets());
        if (this._editor.getModel()) {
          this._updateSnippets();
        }
      }
    }
  }
  _updateSnippets() {
    var _a5;
    this._activeSnippets = [];
    (_a5 = this._completionProvider) == null ? void 0 : _a5.dispose();
    if (!this._editor.hasModel()) {
      return;
    }
    const selection = this._editor.getSelection();
    const model = this._editor.getModel();
    model.tokenization.tokenizeIfCheap(selection.positionLineNumber);
    const id = model.getLanguageIdAtPosition(selection.positionLineNumber, selection.positionColumn);
    const snippets = this._snippetService.getSnippetsSync(id);
    if (!snippets) {
      this._hasSnippets.set(false);
      return;
    }
    if (Range.isEmpty(selection)) {
      const prefix = getNonWhitespacePrefix(model, selection.getPosition());
      if (prefix) {
        for (const snippet of snippets) {
          if (prefix.endsWith(snippet.prefix)) {
            this._activeSnippets.push(snippet);
          }
        }
      }
    } else if (!Range.spansMultipleLines(selection) && model.getValueLengthInRange(selection) <= 100) {
      const selected = model.getValueInRange(selection);
      if (selected) {
        for (const snippet of snippets) {
          if (selected === snippet.prefix) {
            this._activeSnippets.push(snippet);
          }
        }
      }
    }
    const len = this._activeSnippets.length;
    if (len === 0) {
      this._hasSnippets.set(false);
    } else if (len === 1) {
      this._hasSnippets.set(true);
    } else {
      this._hasSnippets.set(true);
      this._completionProvider = {
        _debugDisplayName: "tabCompletion",
        dispose: () => {
          registration.dispose();
        },
        provideCompletionItems: (_model, position) => {
          if (_model !== model || !selection.containsPosition(position)) {
            return;
          }
          const suggestions = this._activeSnippets.map((snippet) => {
            const range = Range.fromPositions(position.delta(0, -snippet.prefix.length), position);
            return new SnippetCompletion(snippet, range);
          });
          return { suggestions };
        }
      };
      const registration = this._languageFeaturesService.completionProvider.register({ language: model.getLanguageId(), pattern: model.uri.fsPath, scheme: model.uri.scheme }, this._completionProvider);
    }
  }
  async performSnippetCompletions() {
    var _a5;
    if (!this._editor.hasModel()) {
      return;
    }
    if (this._activeSnippets.length === 1) {
      const [snippet] = this._activeSnippets;
      let clipboardText;
      if (snippet.needsClipboard) {
        const state = new EditorState(
          this._editor,
          1 | 4
        );
        clipboardText = await this._clipboardService.readText();
        if (!state.validate(this._editor)) {
          return;
        }
      }
      (_a5 = SnippetController2.get(this._editor)) == null ? void 0 : _a5.insert(snippet.codeSnippet, {
        overwriteBefore: snippet.prefix.length,
        overwriteAfter: 0,
        clipboardText
      });
    } else if (this._activeSnippets.length > 1) {
      if (this._completionProvider) {
        showSimpleSuggestions(this._editor, this._completionProvider);
      }
    }
  }
}, TabCompletionController_1 = _a3, _a3.ID = "editor.tabCompletionController", _a3.ContextKey = new RawContextKey("hasSnippetCompletions", void 0), _a3);
TabCompletionController = TabCompletionController_1 = __decorate([
  __param(1, ISnippetsService),
  __param(2, IClipboardService),
  __param(3, ILanguageFeaturesService),
  __param(4, IContextKeyService)
], TabCompletionController);
registerEditorContribution(TabCompletionController.ID, TabCompletionController, 0);
var TabCompletionCommand = EditorCommand.bindToContribution(TabCompletionController.get);
registerEditorCommand(new TabCompletionCommand({
  id: "insertSnippet",
  precondition: TabCompletionController.ContextKey,
  handler: (x) => x.performSnippetCompletions(),
  kbOpts: {
    weight: 100,
    kbExpr: ContextKeyExpr.and(
      EditorContextKeys.editorTextFocus,
      EditorContextKeys.tabDoesNotMoveFocus,
      SnippetController2.InSnippetMode.toNegated()
    ),
    primary: 2
  }
}));

// node_modules/vscode/vscode/src/vs/workbench/contrib/codeEditor/browser/simpleEditorOptions.js
init_editorExtensions();
function getSimpleEditorOptions(configurationService) {
  return {
    wordWrap: "on",
    overviewRulerLanes: 0,
    glyphMargin: false,
    lineNumbers: "off",
    folding: false,
    selectOnLineNumbers: false,
    hideCursorInOverviewRuler: true,
    selectionHighlight: false,
    scrollbar: {
      horizontal: "hidden"
    },
    lineDecorationsWidth: 0,
    overviewRulerBorder: false,
    scrollBeyondLastLine: false,
    renderLineHighlight: "none",
    fixedOverflowWidgets: true,
    acceptSuggestionOnEnter: "smart",
    dragAndDrop: false,
    revealHorizontalRightPadding: 5,
    minimap: {
      enabled: false
    },
    guides: {
      indentation: false
    },
    accessibilitySupport: configurationService.getValue("editor.accessibilitySupport"),
    cursorBlinking: configurationService.getValue("editor.cursorBlinking")
  };
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/accessibility/browser/accessibleView.js
var IAccessibleViewService = createDecorator("accessibleViewService");
var AccessibleView = class AccessibleView2 extends Disposable {
  get editorWidget() {
    return this._editorWidget;
  }
  constructor(_openerService, _instantiationService, _configurationService, _modelService, _contextViewService, _contextKeyService, _accessibilityService, _keybindingService, _layoutService, _menuService) {
    super();
    this._openerService = _openerService;
    this._instantiationService = _instantiationService;
    this._configurationService = _configurationService;
    this._modelService = _modelService;
    this._contextViewService = _contextViewService;
    this._contextKeyService = _contextKeyService;
    this._accessibilityService = _accessibilityService;
    this._keybindingService = _keybindingService;
    this._layoutService = _layoutService;
    this._menuService = _menuService;
    this._accessiblityHelpIsShown = accessibilityHelpIsShown.bindTo(this._contextKeyService);
    this._accessibleViewIsShown = accessibleViewIsShown.bindTo(this._contextKeyService);
    this._accessibleViewSupportsNavigation = accessibleViewSupportsNavigation.bindTo(this._contextKeyService);
    this._accessibleViewVerbosityEnabled = accessibleViewVerbosityEnabled.bindTo(this._contextKeyService);
    this._accessibleViewGoToSymbolSupported = accessibleViewGoToSymbolSupported.bindTo(this._contextKeyService);
    this._accessibleViewCurrentProviderId = accessibleViewCurrentProviderId.bindTo(this._contextKeyService);
    this._container = document.createElement("div");
    this._container.classList.add("accessible-view");
    const codeEditorWidgetOptions = {
      contributions: EditorExtensionsRegistry.getEditorContributions().filter((c) => c.id !== CodeActionController.ID)
    };
    const titleBar = document.createElement("div");
    titleBar.classList.add("accessible-view-title-bar");
    this._title = document.createElement("div");
    this._title.classList.add("accessible-view-title");
    titleBar.appendChild(this._title);
    const actionBar = document.createElement("div");
    actionBar.classList.add("accessible-view-action-bar");
    titleBar.appendChild(actionBar);
    this._container.appendChild(titleBar);
    this._toolbar = this._register(_instantiationService.createInstance(WorkbenchToolBar, actionBar, { orientation: 0 }));
    this._toolbar.context = { viewId: "accessibleView" };
    const toolbarElt = this._toolbar.getElement();
    toolbarElt.tabIndex = 0;
    const editorOptions = {
      ...getSimpleEditorOptions(this._configurationService),
      lineDecorationsWidth: 6,
      dragAndDrop: false,
      cursorWidth: 1,
      wrappingStrategy: "advanced",
      wrappingIndent: "none",
      padding: { top: 2, bottom: 2 },
      quickSuggestions: false,
      renderWhitespace: "none",
      dropIntoEditor: { enabled: false },
      readOnly: true,
      fontFamily: "var(--monaco-monospace-font)"
    };
    this._editorWidget = this._register(this._instantiationService.createInstance(CodeEditorWidget, this._container, editorOptions, codeEditorWidgetOptions));
    this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => {
      if (this._currentProvider && this._accessiblityHelpIsShown.get()) {
        this.show(this._currentProvider);
      }
    }));
    this._register(this._configurationService.onDidChangeConfiguration((e2) => {
      if (this._currentProvider && e2.affectsConfiguration(this._currentProvider.verbositySettingKey)) {
        if (this._accessiblityHelpIsShown.get()) {
          this.show(this._currentProvider);
        }
        this._accessibleViewVerbosityEnabled.set(this._configurationService.getValue(this._currentProvider.verbositySettingKey));
        this._updateToolbar(this._currentProvider.actions, this._currentProvider.options.type);
      }
    }));
    this._register(this._editorWidget.onDidDispose(() => this._resetContextKeys()));
  }
  _resetContextKeys() {
    this._accessiblityHelpIsShown.reset();
    this._accessibleViewIsShown.reset();
    this._accessibleViewSupportsNavigation.reset();
    this._accessibleViewVerbosityEnabled.reset();
    this._accessibleViewGoToSymbolSupported.reset();
    this._accessibleViewCurrentProviderId.reset();
  }
  show(provider, symbol, showAccessibleViewHelp) {
    provider = provider ?? this._currentProvider;
    if (!provider) {
      return;
    }
    const delegate = {
      getAnchor: () => {
        return { x: window.innerWidth / 2 - Math.min(this._layoutService.dimension.width * 0.62, 600) / 2, y: this._layoutService.offset.quickPickTop };
      },
      render: (container) => {
        container.classList.add("accessible-view-container");
        return this._render(provider, container, showAccessibleViewHelp);
      },
      onHide: () => {
        if (!showAccessibleViewHelp) {
          this._currentProvider = void 0;
          this._resetContextKeys();
        }
      }
    };
    this._contextViewService.showContextView(delegate);
    if (symbol && this._currentProvider) {
      this.showSymbol(this._currentProvider, symbol);
    }
  }
  previous() {
    var _a5, _b;
    if (!this._currentProvider) {
      return;
    }
    (_b = (_a5 = this._currentProvider).previous) == null ? void 0 : _b.call(_a5);
  }
  next() {
    var _a5, _b;
    if (!this._currentProvider) {
      return;
    }
    (_b = (_a5 = this._currentProvider).next) == null ? void 0 : _b.call(_a5);
  }
  goToSymbol() {
    if (!this._currentProvider) {
      return;
    }
    this._instantiationService.createInstance(AccessibleViewSymbolQuickPick, this).show(this._currentProvider);
  }
  getSymbols() {
    var _a5, _b, _c, _d;
    if (!this._currentProvider || !this._currentContent) {
      return;
    }
    const tokens = this._currentProvider.options.language && this._currentProvider.options.language !== "markdown" ? (_b = (_a5 = this._currentProvider).getSymbols) == null ? void 0 : _b.call(_a5) : marked.lexer(this._currentContent);
    if (!tokens) {
      return;
    }
    const symbols = [];
    let firstListItem;
    for (const token of tokens) {
      let label = void 0;
      if ("type" in token) {
        switch (token.type) {
          case "heading":
          case "paragraph":
          case "code":
            label = token.text;
            break;
          case "list": {
            const firstItem = (_c = token.items) == null ? void 0 : _c[0];
            if (!firstItem) {
              break;
            }
            firstListItem = `- ${firstItem.text}`;
            label = (_d = token.items) == null ? void 0 : _d.map((i) => i.text).join(", ");
            break;
          }
        }
      } else {
        label = token.label;
      }
      if (label) {
        symbols.push({ info: label, label: localize("symbolLabel", "({0}) {1}", token.type, label), ariaLabel: localize("symbolLabelAria", "({0}) {1}", token.type, label), firstListItem });
        firstListItem = void 0;
      }
    }
    return symbols;
  }
  showSymbol(provider, symbol) {
    if (!this._currentContent) {
      return;
    }
    const index = this._currentContent.split("\n").findIndex((line) => line.includes(symbol.info.split("\n")[0]) || symbol.firstListItem && line.includes(symbol.firstListItem)) ?? -1;
    if (index >= 0) {
      this.show(provider);
      this._editorWidget.revealLine(index + 1);
      this._editorWidget.setSelection({ startLineNumber: index + 1, startColumn: 1, endLineNumber: index + 1, endColumn: 1 });
    }
    this._updateContextKeys(provider, true);
  }
  disableHint() {
    var _a5;
    if (!this._currentProvider) {
      return;
    }
    this._configurationService.updateValue((_a5 = this._currentProvider) == null ? void 0 : _a5.verbositySettingKey, false);
    alert(localize(
      "disableAccessibilityHelp",
      "{0} accessibility verbosity is now disabled",
      this._currentProvider.verbositySettingKey
    ));
  }
  _updateContextKeys(provider, shown) {
    var _a5;
    if (provider.options.type === "help") {
      this._accessiblityHelpIsShown.set(shown);
      this._accessibleViewIsShown.reset();
    } else {
      this._accessibleViewIsShown.set(shown);
      this._accessiblityHelpIsShown.reset();
    }
    if (provider.next && provider.previous) {
      this._accessibleViewSupportsNavigation.set(true);
    } else {
      this._accessibleViewSupportsNavigation.reset();
    }
    const verbosityEnabled = this._configurationService.getValue(provider.verbositySettingKey);
    this._accessibleViewVerbosityEnabled.set(verbosityEnabled);
    this._accessibleViewGoToSymbolSupported.set(this._goToSymbolsSupported() ? ((_a5 = this.getSymbols()) == null ? void 0 : _a5.length) > 0 : false);
  }
  _render(provider, container, showAccessibleViewHelp) {
    if (!showAccessibleViewHelp) {
      this._currentProvider = provider;
      this._accessibleViewCurrentProviderId.set(provider.verbositySettingKey.replaceAll("accessibility.verbosity.", ""));
    }
    const value = this._configurationService.getValue(provider.verbositySettingKey);
    const readMoreLink = provider.options.readMoreUrl ? localize(
      "openDoc",
      "\n\nPress H now to open a browser window with more information related to accessibility.\n\n"
    ) : "";
    let disableHelpHint = "";
    if (provider.options.type === "help" && !!value) {
      disableHelpHint = this._getDisableVerbosityHint(provider.verbositySettingKey);
    }
    const accessibilitySupport = this._accessibilityService.isScreenReaderOptimized();
    let message = "";
    if (provider.options.type === "help") {
      const turnOnMessage = isMacintosh ? AccessibilityHelpNLS.changeConfigToOnMac : AccessibilityHelpNLS.changeConfigToOnWinLinux;
      if (accessibilitySupport && provider.verbositySettingKey === "accessibility.verbosity.editor") {
        message = AccessibilityHelpNLS.auto_on;
        message += "\n";
      } else if (!accessibilitySupport) {
        message = AccessibilityHelpNLS.auto_off + "\n" + turnOnMessage;
        message += "\n";
      }
    }
    this._currentContent = message + provider.provideContent() + readMoreLink + disableHelpHint + localize("exit-tip", "\nExit this dialog via the Escape key.");
    this._updateContextKeys(provider, true);
    this._getTextModel(URI.from(
      { path: `accessible-view-${provider.verbositySettingKey}`, scheme: "accessible-view", fragment: this._currentContent }
    )).then((model) => {
      var _a5;
      if (!model) {
        return;
      }
      this._editorWidget.setModel(model);
      const domNode = this._editorWidget.getDomNode();
      if (!domNode) {
        return;
      }
      model.setLanguage(provider.options.language ?? "markdown");
      container.appendChild(this._container);
      let actionsHint = "";
      const verbose = this._configurationService.getValue(provider.verbositySettingKey);
      const hasActions = this._accessibleViewSupportsNavigation.get() || this._accessibleViewVerbosityEnabled.get() || this._accessibleViewGoToSymbolSupported.get() || ((_a5 = this._currentProvider) == null ? void 0 : _a5.actions);
      if (verbose && !showAccessibleViewHelp && hasActions) {
        actionsHint = localize(
          "ariaAccessibleViewActions",
          "Use Shift+Tab to explore actions such as disabling this hint."
        );
      }
      let ariaLabel = provider.options.type === "help" ? localize("accessibility-help", "Accessibility Help") : localize("accessible-view", "Accessible View");
      this._title.textContent = ariaLabel;
      if (actionsHint && provider.options.type === "view") {
        ariaLabel = localize("accessible-view-hint", "Accessible View, {0}", actionsHint);
      } else if (actionsHint) {
        ariaLabel = localize("accessibility-help-hint", "Accessibility Help, {0}", actionsHint);
      }
      this._editorWidget.updateOptions({ ariaLabel });
      this._editorWidget.focus();
    });
    this._updateToolbar(provider.actions, provider.options.type);
    const handleEscape = (e2) => {
      e2.stopPropagation();
      this._contextViewService.hideContextView();
      this._updateContextKeys(provider, false);
      setTimeout(() => provider.onClose(), 100);
    };
    const disposableStore = new DisposableStore();
    disposableStore.add(this._editorWidget.onKeyUp((e2) => {
      var _a5;
      return (_a5 = provider.onKeyUp) == null ? void 0 : _a5.call(provider, e2);
    }));
    disposableStore.add(this._editorWidget.onKeyDown((e2) => {
      if (e2.keyCode === 9) {
        handleEscape(e2);
      } else if (e2.keyCode === 38 && provider.options.readMoreUrl) {
        const url = provider.options.readMoreUrl;
        alert(AccessibilityHelpNLS.openingDocs);
        this._openerService.open(URI.parse(url));
        e2.preventDefault();
        e2.stopPropagation();
      }
    }));
    disposableStore.add(addDisposableListener(this._toolbar.getElement(), EventType.KEY_DOWN, (e2) => {
      const keyboardEvent = new StandardKeyboardEvent(e2);
      if (keyboardEvent.equals(9)) {
        handleEscape(e2);
      }
    }));
    disposableStore.add(this._editorWidget.onDidBlurEditorWidget(() => {
      if (document.activeElement !== this._toolbar.getElement()) {
        this._contextViewService.hideContextView();
      }
    }));
    disposableStore.add(this._editorWidget.onDidContentSizeChange(() => this._layout()));
    disposableStore.add(this._layoutService.onDidLayout(() => this._layout()));
    return disposableStore;
  }
  _updateToolbar(providedActions, type) {
    this._toolbar.setAriaLabel(type === "help" ? localize("accessibleHelpToolbar", "Accessibility Help") : localize("accessibleViewToolbar", "Accessible View"));
    const menuActions = [];
    const toolbarMenu = this._register(this._menuService.createMenu(MenuId.AccessibleView, this._contextKeyService));
    createAndFillInActionBarActions(toolbarMenu, {}, menuActions);
    if (providedActions) {
      for (const providedAction of providedActions) {
        providedAction.class = providedAction.class || ThemeIcon.asClassName(Codicon.primitiveSquare);
        providedAction.checked = void 0;
      }
      this._toolbar.setActions([...providedActions, ...menuActions]);
    } else {
      this._toolbar.setActions(menuActions);
    }
  }
  _layout() {
    const dimension = this._layoutService.dimension;
    const maxHeight = dimension.height && dimension.height * 0.4;
    const height = Math.min(maxHeight, this._editorWidget.getContentHeight());
    const width = Math.min(dimension.width * 0.62, 600);
    this._editorWidget.layout({ width, height });
  }
  async _getTextModel(resource) {
    const existing = this._modelService.getModel(resource);
    if (existing && !existing.isDisposed()) {
      return existing;
    }
    return this._modelService.createModel(resource.fragment, null, resource, false);
  }
  _goToSymbolsSupported() {
    if (!this._currentProvider) {
      return false;
    }
    return this._currentProvider.options.type === "help" || this._currentProvider.options.language === "markdown" || this._currentProvider.options.language === void 0 || !!this._currentProvider.getSymbols;
  }
  showAccessibleViewHelp() {
    if (!this._currentProvider) {
      return;
    }
    const currentProvider = Object.assign({}, this._currentProvider);
    currentProvider.options = Object.assign({}, currentProvider.options);
    const accessibleViewHelpProvider = {
      provideContent: () => this._getAccessibleViewHelpDialogContent(this._goToSymbolsSupported()),
      onClose: () => this.show(currentProvider),
      options: { type: "help" },
      verbositySettingKey: this._currentProvider.verbositySettingKey
    };
    this._contextViewService.hideContextView();
    setTimeout(() => this.show(accessibleViewHelpProvider, void 0, true), 100);
  }
  _getAccessibleViewHelpDialogContent(providerHasSymbols) {
    const navigationHint = this._getNavigationHint();
    const goToSymbolHint = this._getGoToSymbolHint(providerHasSymbols);
    const toolbarHint = localize("toolbar", "Navigate to the toolbar (Shift+Tab))");
    let hint = localize("intro", "In the accessible view, you can:\n");
    if (navigationHint) {
      hint += " - " + navigationHint + "\n";
    }
    if (goToSymbolHint) {
      hint += " - " + goToSymbolHint + "\n";
    }
    if (toolbarHint) {
      hint += " - " + toolbarHint + "\n";
    }
    return hint;
  }
  _getNavigationHint() {
    var _a5, _b;
    let hint = "";
    const nextKeybinding = (_a5 = this._keybindingService.lookupKeybinding("editor.action.accessibleViewNext")) == null ? void 0 : _a5.getAriaLabel();
    const previousKeybinding = (_b = this._keybindingService.lookupKeybinding("editor.action.accessibleViewPrevious")) == null ? void 0 : _b.getAriaLabel();
    if (nextKeybinding && previousKeybinding) {
      hint = localize(
        "accessibleViewNextPreviousHint",
        "Show the next ({0}) or previous ({1}) item",
        nextKeybinding,
        previousKeybinding
      );
    } else {
      hint = localize(
        "chatAccessibleViewNextPreviousHintNoKb",
        "Show the next or previous item by configuring keybindings for the Show Next & Previous in Accessible View commands"
      );
    }
    return hint;
  }
  _getDisableVerbosityHint(verbositySettingKey) {
    var _a5;
    if (!this._configurationService.getValue(verbositySettingKey)) {
      return "";
    }
    let hint = "";
    const disableKeybinding = (_a5 = this._keybindingService.lookupKeybinding("editor.action.accessibleViewDisableHint", this._contextKeyService)) == null ? void 0 : _a5.getAriaLabel();
    if (disableKeybinding) {
      hint = localize(
        "acessibleViewDisableHint",
        "Disable accessibility verbosity for this feature ({0}). This will disable the hint to open the accessible view for example.\n",
        disableKeybinding
      );
    } else {
      hint = localize(
        "accessibleViewDisableHintNoKb",
        "Add a keybinding for the command Disable Accessible View Hint, which disables accessibility verbosity for this feature.\n"
      );
    }
    return hint;
  }
  _getGoToSymbolHint(providerHasSymbols) {
    var _a5;
    const goToSymbolKb = (_a5 = this._keybindingService.lookupKeybinding("editor.action.accessibleViewGoToSymbol")) == null ? void 0 : _a5.getAriaLabel();
    let goToSymbolHint = "";
    if (providerHasSymbols) {
      if (goToSymbolKb) {
        goToSymbolHint = localize("goToSymbolHint", "Go to a symbol ({0})", goToSymbolKb);
      } else {
        goToSymbolHint = localize(
          "goToSymbolHintNoKb",
          "To go to a symbol, configure a keybinding for the command Go To Symbol in Accessible View"
        );
      }
    }
    return goToSymbolHint;
  }
};
AccessibleView = __decorate([
  __param(0, IOpenerService),
  __param(1, IInstantiationService),
  __param(2, IConfigurationService),
  __param(3, IModelService),
  __param(4, IContextViewService),
  __param(5, IContextKeyService),
  __param(6, IAccessibilityService),
  __param(7, IKeybindingService),
  __param(8, ILayoutService),
  __param(9, IMenuService)
], AccessibleView);
var AccessibleViewService = class AccessibleViewService2 extends Disposable {
  constructor(_instantiationService, _configurationService, _keybindingService) {
    super();
    this._instantiationService = _instantiationService;
    this._configurationService = _configurationService;
    this._keybindingService = _keybindingService;
  }
  show(provider) {
    if (!this._accessibleView) {
      this._accessibleView = this._register(this._instantiationService.createInstance(AccessibleView));
    }
    this._accessibleView.show(provider);
  }
  next() {
    var _a5;
    (_a5 = this._accessibleView) == null ? void 0 : _a5.next();
  }
  previous() {
    var _a5;
    (_a5 = this._accessibleView) == null ? void 0 : _a5.previous();
  }
  goToSymbol() {
    var _a5;
    (_a5 = this._accessibleView) == null ? void 0 : _a5.goToSymbol();
  }
  getOpenAriaHint(verbositySettingKey) {
    var _a5;
    if (!this._configurationService.getValue(verbositySettingKey)) {
      return null;
    }
    const keybinding = (_a5 = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) == null ? void 0 : _a5.getAriaLabel();
    let hint = null;
    if (keybinding) {
      hint = localize(
        "acessibleViewHint",
        "Inspect this in the accessible view with {0}",
        keybinding
      );
    } else {
      hint = localize(
        "acessibleViewHintNoKbEither",
        "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding."
      );
    }
    return hint;
  }
  disableHint() {
    var _a5;
    (_a5 = this._accessibleView) == null ? void 0 : _a5.disableHint();
  }
  showAccessibleViewHelp() {
    var _a5;
    (_a5 = this._accessibleView) == null ? void 0 : _a5.showAccessibleViewHelp();
  }
};
AccessibleViewService = __decorate([
  __param(0, IInstantiationService),
  __param(1, IConfigurationService),
  __param(2, IKeybindingService)
], AccessibleViewService);
var AccessibleViewSymbolQuickPick = class AccessibleViewSymbolQuickPick2 {
  constructor(_accessibleView, _quickInputService) {
    this._accessibleView = _accessibleView;
    this._quickInputService = _quickInputService;
  }
  show(provider) {
    const quickPick = this._quickInputService.createQuickPick();
    quickPick.placeholder = localize("accessibleViewSymbolQuickPickPlaceholder", "Type to search symbols");
    quickPick.title = localize("accessibleViewSymbolQuickPickTitle", "Go to Symbol Accessible View");
    const symbols = this._accessibleView.getSymbols();
    if (!symbols) {
      return;
    }
    for (const symbol of symbols) {
    }
    quickPick.canSelectMany = false;
    quickPick.items = symbols;
    quickPick.show();
    quickPick.onDidAccept(() => {
      this._accessibleView.showSymbol(provider, quickPick.selectedItems[0]);
      quickPick.hide();
    });
    quickPick.onDidHide(() => {
      if (quickPick.selectedItems.length === 0) {
        this._accessibleView.show(provider);
      }
    });
  }
};
AccessibleViewSymbolQuickPick = __decorate([
  __param(1, IQuickInputService)
], AccessibleViewSymbolQuickPick);

// node_modules/vscode/vscode/src/vs/workbench/contrib/scm/common/quickDiff.js
init_instantiation();
var IQuickDiffService = createDecorator("quickDiff");

// node_modules/vscode/external/rollup-plugin-styles/dist/runtime/inject-css.js
var e = [];
var t = [];
function n(n2, r) {
  if (n2 && "undefined" != typeof document) {
    var a, s = true === r.prepend ? "prepend" : "append", d = true === r.singleTag, i = "string" == typeof r.container ? document.querySelector(r.container) : document.getElementsByTagName("head")[0];
    if (d) {
      var u = e.indexOf(i);
      -1 === u && (u = e.push(i) - 1, t[u] = {}), a = t[u] && t[u][s] ? t[u][s] : t[u][s] = c();
    } else
      a = c();
    65279 === n2.charCodeAt(0) && (n2 = n2.substring(1)), a.styleSheet ? a.styleSheet.cssText += n2 : a.appendChild(document.createTextNode(n2));
  }
  function c() {
    var e2 = document.createElement("style");
    if (e2.setAttribute("type", "text/css"), r.attributes)
      for (var t2 = Object.keys(r.attributes), n3 = 0; n3 < t2.length; n3++)
        e2.setAttribute(t2[n3], r.attributes[t2[n3]]);
    var a2 = "prepend" === s ? "afterbegin" : "beforeend";
    return i.insertAdjacentElement(a2, e2), e2;
  }
}

// node_modules/vscode/vscode/src/vs/workbench/common/contextkeys.js
init_tslib_es6();
init_lifecycle();
init_nls();
init_contextkey();
init_resources();
init_language();
init_files();
init_model();
init_network();
var ResourceContextKey_1;
var WorkbenchStateContext = new RawContextKey("workbenchState", void 0, { type: "string", description: localize(
  "workbenchState",
  "The kind of workspace opened in the window, either 'empty' (no workspace), 'folder' (single folder) or 'workspace' (multi-root workspace)"
) });
var WorkspaceFolderCountContext = new RawContextKey("workspaceFolderCount", 0, localize("workspaceFolderCount", "The number of root folders in the workspace"));
var OpenFolderWorkspaceSupportContext = new RawContextKey("openFolderWorkspaceSupport", true, true);
var EnterMultiRootWorkspaceSupportContext = new RawContextKey("enterMultiRootWorkspaceSupport", true, true);
var EmptyWorkspaceSupportContext = new RawContextKey("emptyWorkspaceSupport", true, true);
var DirtyWorkingCopiesContext = new RawContextKey("dirtyWorkingCopies", false, localize(
  "dirtyWorkingCopies",
  "Whether there are any working copies with unsaved changes"
));
var RemoteNameContext = new RawContextKey("remoteName", "", localize(
  "remoteName",
  "The name of the remote the window is connected to or an empty string if not connected to any remote"
));
var VirtualWorkspaceContext = new RawContextKey("virtualWorkspace", "", localize(
  "virtualWorkspace",
  "The scheme of the current workspace is from a virtual file system or an empty string."
));
var TemporaryWorkspaceContext = new RawContextKey("temporaryWorkspace", false, localize(
  "temporaryWorkspace",
  "The scheme of the current workspace is from a temporary file system."
));
var IsFullscreenContext = new RawContextKey("isFullscreen", false, localize("isFullscreen", "Whether the window is in fullscreen mode"));
var HasWebFileSystemAccess = new RawContextKey("hasWebFileSystemAccess", false, true);
var EmbedderIdentifierContext = new RawContextKey("embedderIdentifier", void 0, localize(
  "embedderIdentifier",
  "The identifier of the embedder according to the product service, if one is defined"
));
var ActiveEditorDirtyContext = new RawContextKey("activeEditorIsDirty", false, localize("activeEditorIsDirty", "Whether the active editor has unsaved changes"));
var ActiveEditorPinnedContext = new RawContextKey("activeEditorIsNotPreview", false, localize(
  "activeEditorIsNotPreview",
  "Whether the active editor is not in preview mode"
));
var ActiveEditorFirstInGroupContext = new RawContextKey("activeEditorIsFirstInGroup", false, localize(
  "activeEditorIsFirstInGroup",
  "Whether the active editor is the first one in its group"
));
var ActiveEditorLastInGroupContext = new RawContextKey("activeEditorIsLastInGroup", false, localize(
  "activeEditorIsLastInGroup",
  "Whether the active editor is the last one in its group"
));
var ActiveEditorStickyContext = new RawContextKey("activeEditorIsPinned", false, localize("activeEditorIsPinned", "Whether the active editor is pinned"));
var ActiveEditorReadonlyContext = new RawContextKey("activeEditorIsReadonly", false, localize("activeEditorIsReadonly", "Whether the active editor is read-only"));
var ActiveEditorCanToggleReadonlyContext = new RawContextKey("activeEditorCanToggleReadonly", true, localize(
  "activeEditorCanToggleReadonly",
  "Whether the active editor can toggle between being read-only or writeable"
));
var ActiveEditorCanRevertContext = new RawContextKey("activeEditorCanRevert", false, localize("activeEditorCanRevert", "Whether the active editor can revert"));
var ActiveEditorCanSplitInGroupContext = new RawContextKey("activeEditorCanSplitInGroup", true);
var ActiveEditorContext = new RawContextKey("activeEditor", null, { type: "string", description: localize("activeEditor", "The identifier of the active editor") });
var ActiveEditorAvailableEditorIdsContext = new RawContextKey("activeEditorAvailableEditorIds", "", localize(
  "activeEditorAvailableEditorIds",
  "The available editor identifiers that are usable for the active editor"
));
var TextCompareEditorVisibleContext = new RawContextKey("textCompareEditorVisible", false, localize("textCompareEditorVisible", "Whether a text compare editor is visible"));
var TextCompareEditorActiveContext = new RawContextKey("textCompareEditorActive", false, localize("textCompareEditorActive", "Whether a text compare editor is active"));
var SideBySideEditorActiveContext = new RawContextKey("sideBySideEditorActive", false, localize("sideBySideEditorActive", "Whether a side by side editor is active"));
var EditorGroupEditorsCountContext = new RawContextKey("groupEditorsCount", 0, localize("groupEditorsCount", "The number of opened editor groups"));
var ActiveEditorGroupEmptyContext = new RawContextKey("activeEditorGroupEmpty", false, localize("activeEditorGroupEmpty", "Whether the active editor group is empty"));
var ActiveEditorGroupIndexContext = new RawContextKey("activeEditorGroupIndex", 0, localize("activeEditorGroupIndex", "The index of the active editor group"));
var ActiveEditorGroupLastContext = new RawContextKey("activeEditorGroupLast", false, localize(
  "activeEditorGroupLast",
  "Whether the active editor group is the last group"
));
var ActiveEditorGroupLockedContext = new RawContextKey("activeEditorGroupLocked", false, localize("activeEditorGroupLocked", "Whether the active editor group is locked"));
var MultipleEditorGroupsContext = new RawContextKey("multipleEditorGroups", false, localize("multipleEditorGroups", "Whether there are multiple editor groups opened"));
var EditorsVisibleContext = new RawContextKey("editorIsOpen", false, localize("editorIsOpen", "Whether an editor is open"));
var InEditorZenModeContext = new RawContextKey("inZenMode", false, localize("inZenMode", "Whether Zen mode is enabled"));
var IsCenteredLayoutContext = new RawContextKey("isCenteredLayout", false, localize("isCenteredLayout", "Whether centered layout is enabled"));
var SplitEditorsVertically = new RawContextKey("splitEditorsVertically", false, localize("splitEditorsVertically", "Whether editors split vertically"));
var EditorAreaVisibleContext = new RawContextKey("editorAreaVisible", true, localize("editorAreaVisible", "Whether the editor area is visible"));
var EditorTabsVisibleContext = new RawContextKey("editorTabsVisible", true, localize("editorTabsVisible", "Whether editor tabs are visible"));
var SideBarVisibleContext = new RawContextKey("sideBarVisible", false, localize("sideBarVisible", "Whether the sidebar is visible"));
var SidebarFocusContext = new RawContextKey("sideBarFocus", false, localize("sideBarFocus", "Whether the sidebar has keyboard focus"));
var ActiveViewletContext = new RawContextKey("activeViewlet", "", localize("activeViewlet", "The identifier of the active viewlet"));
var StatusBarFocused = new RawContextKey("statusBarFocused", false, localize("statusBarFocused", "Whether the status bar has keyboard focus"));
var BannerFocused = new RawContextKey("bannerFocused", false, localize("bannerFocused", "Whether the banner has keyboard focus"));
var NotificationFocusedContext = new RawContextKey("notificationFocus", true, localize("notificationFocus", "Whether a notification has keyboard focus"));
var NotificationsCenterVisibleContext = new RawContextKey("notificationCenterVisible", false, localize("notificationCenterVisible", "Whether the notifications center is visible"));
var NotificationsToastsVisibleContext = new RawContextKey("notificationToastsVisible", false, localize("notificationToastsVisible", "Whether a notification toast is visible"));
var ActiveAuxiliaryContext = new RawContextKey("activeAuxiliary", "", localize("activeAuxiliary", "The identifier of the active auxiliary panel"));
var AuxiliaryBarFocusContext = new RawContextKey("auxiliaryBarFocus", false, localize("auxiliaryBarFocus", "Whether the auxiliary bar has keyboard focus"));
var AuxiliaryBarVisibleContext = new RawContextKey("auxiliaryBarVisible", false, localize("auxiliaryBarVisible", "Whether the auxiliary bar is visible"));
var ActivePanelContext = new RawContextKey("activePanel", "", localize("activePanel", "The identifier of the active panel"));
var PanelFocusContext = new RawContextKey("panelFocus", false, localize("panelFocus", "Whether the panel has keyboard focus"));
var PanelPositionContext = new RawContextKey("panelPosition", "bottom", localize("panelPosition", "The position of the panel, always 'bottom'"));
var PanelAlignmentContext = new RawContextKey("panelAlignment", "center", localize(
  "panelAlignment",
  "The alignment of the panel, either 'center', 'left', 'right' or 'justify'"
));
var PanelVisibleContext = new RawContextKey("panelVisible", false, localize("panelVisible", "Whether the panel is visible"));
var PanelMaximizedContext = new RawContextKey("panelMaximized", false, localize("panelMaximized", "Whether the panel is maximized"));
var FocusedViewContext = new RawContextKey("focusedView", "", localize("focusedView", "The identifier of the view that has keyboard focus"));
var _a4;
var ResourceContextKey = (_a4 = class {
  constructor(_contextKeyService, _fileService, _languageService, _modelService) {
    this._contextKeyService = _contextKeyService;
    this._fileService = _fileService;
    this._languageService = _languageService;
    this._modelService = _modelService;
    this._disposables = new DisposableStore();
    this._schemeKey = ResourceContextKey_1.Scheme.bindTo(this._contextKeyService);
    this._filenameKey = ResourceContextKey_1.Filename.bindTo(this._contextKeyService);
    this._dirnameKey = ResourceContextKey_1.Dirname.bindTo(this._contextKeyService);
    this._pathKey = ResourceContextKey_1.Path.bindTo(this._contextKeyService);
    this._langIdKey = ResourceContextKey_1.LangId.bindTo(this._contextKeyService);
    this._resourceKey = ResourceContextKey_1.Resource.bindTo(this._contextKeyService);
    this._extensionKey = ResourceContextKey_1.Extension.bindTo(this._contextKeyService);
    this._hasResource = ResourceContextKey_1.HasResource.bindTo(this._contextKeyService);
    this._isFileSystemResource = ResourceContextKey_1.IsFileSystemResource.bindTo(this._contextKeyService);
    this._disposables.add(_fileService.onDidChangeFileSystemProviderRegistrations(() => {
      const resource = this.get();
      this._isFileSystemResource.set(Boolean(resource && _fileService.hasProvider(resource)));
    }));
    this._disposables.add(_modelService.onModelAdded((model) => {
      if (isEqual(model.uri, this.get())) {
        this._setLangId();
      }
    }));
    this._disposables.add(_modelService.onModelLanguageChanged((e2) => {
      if (isEqual(e2.model.uri, this.get())) {
        this._setLangId();
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
  }
  _setLangId() {
    var _a5;
    const value = this.get();
    if (!value) {
      this._langIdKey.set(null);
      return;
    }
    const langId = ((_a5 = this._modelService.getModel(value)) == null ? void 0 : _a5.getLanguageId()) ?? this._languageService.guessLanguageIdByFilepathOrFirstLine(value);
    this._langIdKey.set(langId);
  }
  set(value) {
    value = value ?? void 0;
    if (isEqual(this._value, value)) {
      return;
    }
    this._value = value;
    this._contextKeyService.bufferChangeEvents(() => {
      this._resourceKey.set(value ? value.toString() : null);
      this._schemeKey.set(value ? value.scheme : null);
      this._filenameKey.set(value ? basename2(value) : null);
      this._dirnameKey.set(value ? this.uriToPath(dirname(value)) : null);
      this._pathKey.set(value ? this.uriToPath(value) : null);
      this._setLangId();
      this._extensionKey.set(value ? extname2(value) : null);
      this._hasResource.set(Boolean(value));
      this._isFileSystemResource.set(value ? this._fileService.hasProvider(value) : false);
    });
  }
  uriToPath(uri) {
    if (uri.scheme === Schemas.file) {
      return uri.fsPath;
    }
    return uri.path;
  }
  reset() {
    this._value = void 0;
    this._contextKeyService.bufferChangeEvents(() => {
      this._resourceKey.reset();
      this._schemeKey.reset();
      this._filenameKey.reset();
      this._dirnameKey.reset();
      this._pathKey.reset();
      this._langIdKey.reset();
      this._extensionKey.reset();
      this._hasResource.reset();
      this._isFileSystemResource.reset();
    });
  }
  get() {
    return this._value;
  }
}, ResourceContextKey_1 = _a4, _a4.Scheme = new RawContextKey("resourceScheme", void 0, { type: "string", description: localize("resourceScheme", "The scheme of the resource") }), _a4.Filename = new RawContextKey(
  "resourceFilename",
  void 0,
  { type: "string", description: localize("resourceFilename", "The file name of the resource") }
), _a4.Dirname = new RawContextKey(
  "resourceDirname",
  void 0,
  { type: "string", description: localize("resourceDirname", "The folder name the resource is contained in") }
), _a4.Path = new RawContextKey("resourcePath", void 0, { type: "string", description: localize("resourcePath", "The full path of the resource") }), _a4.LangId = new RawContextKey("resourceLangId", void 0, { type: "string", description: localize("resourceLangId", "The language identifier of the resource") }), _a4.Resource = new RawContextKey("resource", void 0, { type: "URI", description: localize("resource", "The full value of the resource including scheme and path") }), _a4.Extension = new RawContextKey(
  "resourceExtname",
  void 0,
  { type: "string", description: localize("resourceExtname", "The extension name of the resource") }
), _a4.HasResource = new RawContextKey("resourceSet", void 0, { type: "boolean", description: localize("resourceSet", "Whether a resource is present or not") }), _a4.IsFileSystemResource = new RawContextKey(
  "isFileSystemResource",
  void 0,
  { type: "boolean", description: localize(
    "isFileSystemResource",
    "Whether the resource is backed by a file system provider"
  ) }
), _a4);
ResourceContextKey = ResourceContextKey_1 = __decorate([
  __param(0, IContextKeyService),
  __param(1, IFileService),
  __param(2, ILanguageService),
  __param(3, IModelService)
], ResourceContextKey);
function applyAvailableEditorIds(contextKey, editor, editorResolverService) {
  if (!editor) {
    contextKey.set("");
    return;
  }
  const editorResource = editor.resource;
  const editors = editorResource ? editorResolverService.getEditors(editorResource).map((editor2) => editor2.id) : [];
  if ((editorResource == null ? void 0 : editorResource.scheme) === Schemas.untitled && editor.editorId !== DEFAULT_EDITOR_ASSOCIATION.id) {
    contextKey.set("");
  } else {
    contextKey.set(editors.join(","));
  }
}

export {
  areSameExtensions,
  getExtensionId,
  adoptToGalleryExtensionId,
  getGalleryExtensionId,
  ImplicitActivationEvents,
  nullExtensionDescription,
  IExtensionService,
  MissingExtensionDependency,
  ExtensionHostExtensions,
  isProposedApiEnabled,
  checkProposedApiEnabled,
  ActivationTimes,
  ExtensionPointContribution,
  toExtension,
  toExtensionDescription,
  NullExtensionService,
  ILifecycleService,
  LifecyclePhaseToString,
  IProductService,
  IExtensionGalleryService,
  IExtensionManagementService,
  EditorExtensions,
  DEFAULT_EDITOR_ASSOCIATION,
  SIDE_BY_SIDE_EDITOR_ID,
  TEXT_DIFF_EDITOR_ID,
  BINARY_DIFF_EDITOR_ID,
  isEditorPaneWithSelection,
  findViewStateForEditor,
  isResourceEditorInput,
  isResourceDiffEditorInput,
  isResourceSideBySideEditorInput,
  isUntitledResourceEditorInput,
  isResourceMergeEditorInput,
  SaveSourceRegistry,
  AbstractEditorInput,
  isEditorInput,
  isDiffEditorInput,
  createTooLargeFileError,
  isEditorIdentifier,
  EditorCloseContext,
  SideBySideEditor,
  EditorCloseMethod,
  preventEditorClose,
  EditorResourceAccessor,
  pathsToEditors,
  isTextEditorViewState,
  IEditorGroupsService,
  preferredSideBySideGroupDirection,
  IEditorService,
  ACTIVE_GROUP,
  SIDE_GROUP,
  allApiProposals,
  ExtensionMessageCollector,
  ExtensionsRegistry,
  IRemoteAgentService,
  Extensions3 as Extensions,
  ITextFileService,
  TextFileOperationError,
  stringToSnapshot,
  toBufferOrReadable,
  IUserDataProfileService,
  IUserDataProfileImportExportService,
  defaultUserDataProfileIcon,
  ISnippetsService,
  ITextMateTokenizationService,
  workbenchConfigurationNodeBase,
  Extensions4 as Extensions2,
  DynamicWorkbenchConfigurationWorkbenchContribution,
  IExtensionResourceLoaderService,
  AbstractExtensionResourceLoaderService,
  accessibilityHelpIsShown,
  accessibleViewIsShown,
  accessibleViewSupportsNavigation,
  accessibleViewVerbosityEnabled,
  accessibleViewGoToSymbolSupported,
  accessibleViewCurrentProviderId,
  MenuPreventer,
  languagesExtPoint,
  WorkbenchLanguageService,
  TabCompletionController,
  IAccessibleViewService,
  IQuickDiffService,
  n,
  WorkbenchStateContext,
  WorkspaceFolderCountContext,
  OpenFolderWorkspaceSupportContext,
  EnterMultiRootWorkspaceSupportContext,
  EmptyWorkspaceSupportContext,
  DirtyWorkingCopiesContext,
  RemoteNameContext,
  VirtualWorkspaceContext,
  TemporaryWorkspaceContext,
  IsFullscreenContext,
  HasWebFileSystemAccess,
  EmbedderIdentifierContext,
  ActiveEditorReadonlyContext,
  ActiveEditorCanToggleReadonlyContext,
  ActiveEditorCanRevertContext,
  ActiveEditorCanSplitInGroupContext,
  ActiveEditorContext,
  ActiveEditorAvailableEditorIdsContext,
  TextCompareEditorVisibleContext,
  TextCompareEditorActiveContext,
  SideBySideEditorActiveContext,
  ActiveEditorGroupEmptyContext,
  ActiveEditorGroupIndexContext,
  ActiveEditorGroupLastContext,
  ActiveEditorGroupLockedContext,
  MultipleEditorGroupsContext,
  EditorsVisibleContext,
  InEditorZenModeContext,
  IsCenteredLayoutContext,
  SplitEditorsVertically,
  EditorAreaVisibleContext,
  EditorTabsVisibleContext,
  SideBarVisibleContext,
  AuxiliaryBarVisibleContext,
  PanelPositionContext,
  PanelAlignmentContext,
  PanelVisibleContext,
  PanelMaximizedContext,
  FocusedViewContext,
  ResourceContextKey,
  applyAvailableEditorIds
};
//# sourceMappingURL=chunk-ETI4KOTI.js.map
