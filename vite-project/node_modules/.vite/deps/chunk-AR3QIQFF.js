import {
  IDebugService,
  IEditSessionIdentityService,
  IRemoteAuthorityResolverService,
  NotebookCellsChangeType,
  init_debug,
  init_editSessions,
  init_notebookCommon,
  init_remoteAuthorityResolver
} from "./chunk-E2764U5K.js";
import {
  CodeDataTransfers,
  Extensions as Extensions4,
  ITreeViewsDnDService,
  LocalSelectionTransfer,
  TreeViewsDnDService,
  UriList,
  WebFileSystemAccess,
  buildReplaceStringWithCasePreserved,
  containsDragType,
  createWebWorker,
  extractEditorsAndFilesDropData,
  showHistoryKeybindingHint
} from "./chunk-MEAKYGIF.js";
import {
  ACTIVE_GROUP,
  AbstractEditorInput,
  AbstractExtensionResourceLoaderService,
  ActiveEditorCanToggleReadonlyContext,
  ActiveEditorContext,
  BINARY_DIFF_EDITOR_ID,
  DEFAULT_EDITOR_ASSOCIATION,
  EditorCloseContext,
  EditorCloseMethod,
  EditorExtensions,
  EditorResourceAccessor,
  EmptyWorkspaceSupportContext,
  EnterMultiRootWorkspaceSupportContext,
  Extensions,
  Extensions2 as Extensions3,
  ExtensionsRegistry,
  FocusedViewContext,
  IAccessibleViewService,
  IEditorGroupsService,
  IEditorService,
  IExtensionGalleryService,
  IExtensionManagementService,
  IExtensionResourceLoaderService,
  IExtensionService,
  ILifecycleService,
  IProductService,
  IQuickDiffService,
  IRemoteAgentService,
  ISnippetsService,
  ITextFileService,
  ITextMateTokenizationService,
  IUserDataProfileImportExportService,
  IUserDataProfileService,
  LifecyclePhaseToString,
  NullExtensionService,
  OpenFolderWorkspaceSupportContext,
  RemoteNameContext,
  ResourceContextKey,
  SIDE_BY_SIDE_EDITOR_ID,
  SIDE_GROUP,
  SaveSourceRegistry,
  SideBySideEditor,
  TEXT_DIFF_EDITOR_ID,
  TextFileOperationError,
  WorkbenchStateContext,
  WorkspaceFolderCountContext,
  adoptToGalleryExtensionId,
  areSameExtensions,
  createTooLargeFileError,
  defaultUserDataProfileIcon,
  findViewStateForEditor,
  getExtensionId,
  getGalleryExtensionId,
  isDiffEditorInput,
  isEditorIdentifier,
  isEditorInput,
  isEditorPaneWithSelection,
  isResourceDiffEditorInput,
  isResourceEditorInput,
  isResourceMergeEditorInput,
  isResourceSideBySideEditorInput,
  isTextEditorViewState,
  isUntitledResourceEditorInput,
  n,
  pathsToEditors,
  preferredSideBySideGroupDirection,
  preventEditorClose,
  stringToSnapshot,
  toBufferOrReadable,
  workbenchConfigurationNodeBase
} from "./chunk-ETI4KOTI.js";
import {
  NullEndpointTelemetryService,
  __decorate,
  __param,
  init_telemetryUtils,
  init_tslib_es6
} from "./chunk-GJDIUAXO.js";
import {
  $,
  Action,
  Action2,
  ActionBar,
  ActionRunner,
  Barrier,
  BaseActionViewItem,
  Button,
  Categories,
  Color,
  CommandsRegistry,
  ContextScopedHistoryInputBox,
  DataTransfers,
  DeferredPromise,
  DelayedDragHandler,
  Delayer,
  DiffEditorWidget,
  DiffEditorWidget2,
  Dimension,
  DomEmitter,
  DomScrollableElement,
  DragAndDropObserver,
  EditOperation,
  EditorActivation,
  EditorOpenSource,
  ElementsDragAndDropData,
  EventHelper,
  EventType,
  EventType2,
  Extensions2,
  ExternalElementsDragAndDropData,
  ExternalUriOpenerPriority,
  Gesture,
  IAccessibilityService,
  IClipboardService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextMenuService,
  IContextViewService,
  IEditorWorkerService,
  IEnvironmentService,
  IKeybindingService,
  ILabelService,
  ILanguageConfigurationService,
  ILanguageFeaturesService,
  ILanguageService,
  ILayoutService,
  IMenuService,
  IModelService,
  INotificationService,
  IOpenerService,
  IPolicyService,
  IProgressService,
  IQuickInputService,
  IStorageService,
  ITextModelService,
  ITextResourceConfigurationService,
  IThemeService,
  IUriIdentityService,
  IUserDataProfilesService,
  IWorkspaceContextService,
  IWorkspaceTrustEnablementService,
  IWorkspaceTrustManagementService,
  IWorkspaceTrustRequestService,
  IconLabel,
  IdleValue,
  InputBox,
  InputFocusedContextKey,
  IsMacNativeContext,
  IsWebContext,
  ItemActivation,
  KeyChord,
  KeyCodeChord,
  Keybinding,
  LanguageFeatureRegistry,
  Limiter,
  Link,
  MenuId,
  MenuRegistry,
  MenuWorkbenchToolBar,
  ModelDecorationOptions,
  ModifierKeyEmitter,
  NativeDragAndDropData,
  PLAINTEXT_EXTENSION,
  PLAINTEXT_LANGUAGE_ID,
  PieceTreeTextBufferBuilder,
  Position,
  ProgressBar,
  Promises,
  Queue,
  RGBA,
  Range,
  Registry,
  ResourceFileEdit,
  ResourceQueue,
  RunOnceScheduler,
  RunOnceWorker,
  SearchParams,
  Selection,
  ServiceCollection,
  SetMap,
  Severity,
  Sizing,
  SplitView,
  StandaloneServices,
  StandardKeyboardEvent,
  StandardMouseEvent,
  SubmenuEntryActionViewItem,
  SubmenuItemAction,
  SyncDescriptor,
  TaskSequentializer,
  Themable,
  ThrottledDelayer,
  USLayoutResolvedKeybinding,
  WORKSPACE_EXTENSION,
  Widget,
  WillSaveStateReason,
  WorkbenchCompressibleAsyncDataTree,
  WorkbenchList,
  WorkbenchToolBar,
  WorkspaceFolder,
  activeContrastBorder,
  addDisposableListener,
  addMatchMediaChangeListener,
  addStandardDisposableListener,
  after,
  append,
  asCSSPropertyValue,
  asCSSUrl,
  asCssValueWithDefault,
  asCssVariable,
  badgeBackground,
  badgeForeground,
  clearNode,
  compareAnything,
  compareFileExtensionsDefault,
  compareFileExtensionsLower,
  compareFileExtensionsUnicode,
  compareFileExtensionsUpper,
  compareFileNamesDefault,
  compareFileNamesLower,
  compareFileNamesUnicode,
  compareFileNamesUpper,
  contrastBorder,
  createActionViewItem,
  createAndFillInActionBarActions,
  createCSSRule,
  createCancelablePromise,
  createScanner,
  createStyleSheet,
  createTextBufferFactory,
  createTextBufferFactoryFromSnapshot,
  createTextBufferFactoryFromStream,
  darken,
  defaultButtonStyles,
  defaultInputBoxStyles,
  defaultProgressBarStyles,
  diffInserted,
  diffRemoved,
  editorBackground,
  editorConfigurationBaseNode,
  editorErrorForeground,
  editorForeground,
  editorHoverHighlight,
  editorInfoForeground,
  editorWarningForeground,
  editorWidgetBackground,
  editorWidgetBorder,
  editorWidgetForeground,
  errorForeground,
  extractSelection,
  findNodeAtLocation,
  first,
  focusBorder,
  foreground,
  getIconClasses,
  getIconRegistry,
  getLargestChildWidth,
  hasParentWithClass,
  hasWorkspaceFileExtension,
  init_actions,
  init_actions2,
  init_async,
  init_browser,
  init_codeEditorService,
  init_color,
  init_colorRegistry,
  init_commands,
  init_configuration,
  init_configurationRegistry,
  init_descriptors,
  init_dom,
  init_editOperation,
  init_editorBrowser,
  init_editorContextKeys,
  init_editorWorker,
  init_environment,
  init_extensions as init_extensions2,
  init_keyCodes,
  init_keybindings,
  init_keybindingsRegistry,
  init_keyboardEvent,
  init_language,
  init_languageConfigurationRegistry,
  init_languageFeatures,
  init_languages,
  init_model as init_model2,
  init_modesRegistry,
  init_mouseEvent,
  init_opener,
  init_pieceTreeTextBufferBuilder,
  init_platform as init_platform2,
  init_position,
  init_progress,
  init_range,
  init_resolverService,
  init_selection,
  init_textModel,
  init_textModelSearch,
  init_theme,
  init_themeService,
  inputBackground,
  inputBorder,
  inputPlaceholderForeground,
  isAncestor,
  isFirefox,
  isHTMLElement,
  isInputElement,
  isSavedWorkspace,
  isSingleFolderWorkspaceIdentifier,
  isTemporaryWorkspace,
  isThenable,
  lighten,
  listActiveSelectionBackground,
  listActiveSelectionForeground,
  listDeemphasizedForeground,
  listDropBackground,
  listErrorForeground,
  listInvalidItemForeground,
  mark,
  match,
  matchesScheme,
  memoize,
  minimapFindMatch,
  mnemonicButtonLabel,
  multibyteAwareBtoa,
  normalizeDriveLetter,
  overviewRulerFindMatchForeground,
  parse2 as parse,
  parse3 as parse2,
  parseLinkedText,
  parseTree,
  prepareActions,
  quickPickItemScorerAccessor,
  raceCancellablePromises,
  raceCancellation,
  registerAction2,
  registerColor,
  registerIcon,
  registerSingleton,
  removeCSSRulesContainingSelector,
  reset,
  runWhenIdle,
  setParentFlowTo,
  severity_default,
  shorten,
  stringify,
  textLinkForeground,
  themeColorFromId,
  timeout,
  toWorkspaceIdentifier,
  toolbarHoverBackground,
  trackFocus,
  transparent,
  treeIndentGuidesStroke,
  triggerDownload,
  triggerUpload,
  widgetBorder,
  widgetShadow
} from "./chunk-O3SOEW3V.js";
import {
  ALL_EXTENSION_KINDS,
  AbstractLoggerService,
  AsyncEmitter,
  AutoSaveConfiguration,
  ByteSize,
  CONTEXT_LOG_LEVEL,
  CancellationToken,
  CancellationTokenSource,
  Codicon,
  ContextKeyExpr,
  DebounceEmitter,
  Disposable,
  DisposableStore,
  ETAG_DISABLED,
  Emitter,
  ErrorNoTelemetry,
  Event,
  EventMultiplexer,
  ExtUri,
  ExtensionIdentifierMap,
  FILES_ASSOCIATIONS_CONFIG,
  FILES_EXCLUDE_CONFIG,
  FILES_READONLY_EXCLUDE_CONFIG,
  FILES_READONLY_FROM_PERMISSIONS_CONFIG,
  FILES_READONLY_INCLUDE_CONFIG,
  FileAccess,
  FileChangesEvent,
  FileKind,
  FileOperationError,
  FileOperationEvent,
  FilePermission,
  FileSystemProviderError,
  FileSystemProviderErrorCode,
  FileType,
  FindMatch,
  HotExitConfiguration,
  IContextKeyService,
  ICustomEndpointTelemetryService,
  IFileService,
  IInstantiationService,
  ILogService,
  ILoggerService,
  ITelemetryService,
  Iterable,
  LRUCache,
  Lazy,
  LinkedList,
  LogLevel,
  LogLevelToString,
  Mimes,
  MinimapPosition,
  MutableDisposable,
  NotModifiedSinceFileOperationError,
  NullLogger,
  OS,
  OverviewRulerLane,
  PauseableEmitter,
  RawContextKey,
  Relay,
  ResourceMap,
  ResourceSet,
  Schemas,
  StopWatch,
  TernarySearchTree,
  ThemeIcon,
  TooLargeFileOperationError,
  URI,
  VSBuffer,
  asArray,
  assertIsDefined,
  basename,
  basename2,
  basenameOrAuthority,
  bufferToReadable,
  bufferToStream,
  bufferedStreamToBuffer,
  canceled,
  coalesce,
  combinedDisposable,
  compare,
  consumeStream,
  createDecorator,
  createFileSystemProviderError,
  createMatches,
  createRegExp,
  deepClone,
  dirname2 as dirname,
  dispose,
  distinct,
  distinct2,
  distinctParents,
  ensureFileSystemProviderError,
  ensureValidWordDefinition,
  equals2 as equals,
  equalsIgnoreCase,
  etag,
  extUri,
  extUriIgnorePathCase,
  extname,
  extname2,
  firstOrDefault,
  flatten,
  fuzzyScore,
  generateUuid,
  getCharContainingOffset,
  getCodiconAriaLabel,
  getDriveLetter,
  getErrorMessage,
  getNLines,
  getOrSet,
  getRemoteAuthority,
  hasFileAtomicReadCapability,
  hasFileCloneCapability,
  hasFileFolderCopyCapability,
  hasFileReadStreamCapability,
  hasOpenReadWriteCloseCapability,
  hasReadWriteCapability,
  hasReadonlyCapability,
  hash,
  indexOfPath,
  init_arrays,
  init_buffer,
  init_cancellation,
  init_codicons,
  init_contextkey,
  init_errorMessage,
  init_errors,
  init_event,
  init_extensions,
  init_extpath,
  init_files,
  init_filters,
  init_functional,
  init_hash,
  init_iconLabels,
  init_instantiation,
  init_iterator,
  init_lazy,
  init_lifecycle,
  init_linkedList,
  init_log,
  init_map,
  init_mime,
  init_model,
  init_network,
  init_nls,
  init_objects,
  init_path,
  init_platform,
  init_remoteHosts,
  init_resources,
  init_stopwatch,
  init_stream,
  init_strings,
  init_telemetry,
  init_ternarySearchTree,
  init_themables,
  init_types,
  init_uri,
  init_uuid,
  init_wordHelper,
  insert,
  isAbsolute,
  isAbsolutePath,
  isBoolean,
  isCancellationError,
  isEmptyObject,
  isEqual,
  isEqual2,
  isEqualAuthority,
  isEqualOrParent,
  isEqualOrParent2,
  isFalsyOrWhitespace,
  isFunction,
  isLinux,
  isMacintosh,
  isNative,
  isNonEmptyArray,
  isNumber,
  isObject,
  isReadableBufferedStream,
  isReadableStream,
  isString,
  isStringArray,
  isUNC,
  isUndefined,
  isUpper,
  isValidBasename,
  isWeb,
  isWindows,
  joinPath,
  lcut,
  listenStream,
  localize,
  mapArrayOrNot,
  markAsSingleton,
  matchesPrefix,
  mixin,
  newWriteableBufferStream,
  newWriteableStream,
  normalizePath,
  onUnexpectedError,
  once,
  parseLineAndColumnAware,
  peekReadable,
  peekStream,
  posix,
  prefixedBufferReadable,
  prefixedBufferStream,
  readableToBuffer,
  refineServiceDecorator,
  relative,
  relativePath,
  rtrim,
  sep,
  startsWithIgnoreCase,
  streamToBuffer,
  stripWildcards,
  toDisposable,
  toErrorMessage,
  toFileOperationResult,
  toFileSystemProviderErrorCode,
  toLocalResource,
  toSlashes,
  transform,
  trim,
  win32
} from "./chunk-N5MAMNNV.js";

// node_modules/vscode/vscode/src/vs/workbench/services/environment/common/environmentService.js
init_instantiation();
init_environment();
var IWorkbenchEnvironmentService = refineServiceDecorator(IEnvironmentService);

// node_modules/vscode/missing-services.js
init_tslib_es6();
init_event();
init_uri();

// node_modules/vscode/vscode/src/vs/workbench/services/panecomposite/browser/panecomposite.js
init_instantiation();
var IPaneCompositePartService = createDecorator("paneCompositePartService");

// node_modules/vscode/missing-services.js
init_files();

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/workingCopyFileService.js
init_tslib_es6();
init_instantiation();
init_event();
init_async();
init_arrays();
init_lifecycle();
init_files();
init_cancellation();

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/workingCopyService.js
init_instantiation();
init_event();
init_uri();
init_lifecycle();
init_map();
var IWorkingCopyService = createDecorator("workingCopyService");
var WorkingCopyService = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidRegister = this._register(new Emitter());
    this.onDidRegister = this._onDidRegister.event;
    this._onDidUnregister = this._register(new Emitter());
    this.onDidUnregister = this._onDidUnregister.event;
    this._onDidChangeDirty = this._register(new Emitter());
    this.onDidChangeDirty = this._onDidChangeDirty.event;
    this._onDidChangeContent = this._register(new Emitter());
    this.onDidChangeContent = this._onDidChangeContent.event;
    this._onDidSave = this._register(new Emitter());
    this.onDidSave = this._onDidSave.event;
    this._workingCopies = /* @__PURE__ */ new Set();
    this.mapResourceToWorkingCopies = new ResourceMap();
  }
  get workingCopies() {
    return Array.from(this._workingCopies.values());
  }
  registerWorkingCopy(workingCopy) {
    let workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);
    if (workingCopiesForResource == null ? void 0 : workingCopiesForResource.has(workingCopy.typeId)) {
      throw new Error(`Cannot register more than one working copy with the same resource ${workingCopy.resource.toString()} and type ${workingCopy.typeId}.`);
    }
    this._workingCopies.add(workingCopy);
    if (!workingCopiesForResource) {
      workingCopiesForResource = /* @__PURE__ */ new Map();
      this.mapResourceToWorkingCopies.set(workingCopy.resource, workingCopiesForResource);
    }
    workingCopiesForResource.set(workingCopy.typeId, workingCopy);
    const disposables = new DisposableStore();
    disposables.add(workingCopy.onDidChangeContent(() => this._onDidChangeContent.fire(workingCopy)));
    disposables.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));
    disposables.add(workingCopy.onDidSave((e) => this._onDidSave.fire({ workingCopy, ...e })));
    this._onDidRegister.fire(workingCopy);
    if (workingCopy.isDirty()) {
      this._onDidChangeDirty.fire(workingCopy);
    }
    return toDisposable(() => {
      this.unregisterWorkingCopy(workingCopy);
      dispose(disposables);
      this._onDidUnregister.fire(workingCopy);
    });
  }
  unregisterWorkingCopy(workingCopy) {
    this._workingCopies.delete(workingCopy);
    const workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);
    if ((workingCopiesForResource == null ? void 0 : workingCopiesForResource.delete(workingCopy.typeId)) && workingCopiesForResource.size === 0) {
      this.mapResourceToWorkingCopies.delete(workingCopy.resource);
    }
    if (workingCopy.isDirty()) {
      this._onDidChangeDirty.fire(workingCopy);
    }
  }
  has(resourceOrIdentifier) {
    var _a43;
    if (URI.isUri(resourceOrIdentifier)) {
      return this.mapResourceToWorkingCopies.has(resourceOrIdentifier);
    }
    return ((_a43 = this.mapResourceToWorkingCopies.get(resourceOrIdentifier.resource)) == null ? void 0 : _a43.has(resourceOrIdentifier.typeId)) ?? false;
  }
  get(identifier) {
    var _a43;
    return (_a43 = this.mapResourceToWorkingCopies.get(identifier.resource)) == null ? void 0 : _a43.get(identifier.typeId);
  }
  getAll(resource) {
    const workingCopies = this.mapResourceToWorkingCopies.get(resource);
    if (!workingCopies) {
      return void 0;
    }
    return Array.from(workingCopies.values());
  }
  get hasDirty() {
    for (const workingCopy of this._workingCopies) {
      if (workingCopy.isDirty()) {
        return true;
      }
    }
    return false;
  }
  get dirtyCount() {
    let totalDirtyCount = 0;
    for (const workingCopy of this._workingCopies) {
      if (workingCopy.isDirty()) {
        totalDirtyCount++;
      }
    }
    return totalDirtyCount;
  }
  get dirtyWorkingCopies() {
    return this.workingCopies.filter((workingCopy) => workingCopy.isDirty());
  }
  get modifiedCount() {
    let totalModifiedCount = 0;
    for (const workingCopy of this._workingCopies) {
      if (workingCopy.isModified()) {
        totalModifiedCount++;
      }
    }
    return totalModifiedCount;
  }
  get modifiedWorkingCopies() {
    return this.workingCopies.filter((workingCopy) => workingCopy.isModified());
  }
  isDirty(resource, typeId) {
    var _a43;
    const workingCopies = this.mapResourceToWorkingCopies.get(resource);
    if (workingCopies) {
      if (typeof typeId === "string") {
        return ((_a43 = workingCopies.get(typeId)) == null ? void 0 : _a43.isDirty()) ?? false;
      } else {
        for (const [, workingCopy] of workingCopies) {
          if (workingCopy.isDirty()) {
            return true;
          }
        }
      }
    }
    return false;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/workingCopyFileOperationParticipant.js
init_tslib_es6();
init_log();
init_lifecycle();
init_configuration();
init_linkedList();
var WorkingCopyFileOperationParticipant = class WorkingCopyFileOperationParticipant2 extends Disposable {
  constructor(logService, configurationService) {
    super();
    this.logService = logService;
    this.configurationService = configurationService;
    this.participants = new LinkedList();
  }
  addFileOperationParticipant(participant) {
    const remove = this.participants.push(participant);
    return toDisposable(() => remove());
  }
  async participate(files, operation, undoInfo, token) {
    const timeout2 = this.configurationService.getValue("files.participants.timeout");
    if (typeof timeout2 !== "number" || timeout2 <= 0) {
      return;
    }
    for (const participant of this.participants) {
      try {
        await participant.participate(files, operation, undoInfo, timeout2, token);
      } catch (err) {
        this.logService.warn(err);
      }
    }
  }
  dispose() {
    this.participants.clear();
    super.dispose();
  }
};
WorkingCopyFileOperationParticipant = __decorate([
  __param(0, ILogService),
  __param(1, IConfigurationService)
], WorkingCopyFileOperationParticipant);

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/storedFileWorkingCopySaveParticipant.js
init_tslib_es6();
init_nls();
init_async();
init_cancellation();
init_log();
init_progress();
init_lifecycle();
init_arrays();
var StoredFileWorkingCopySaveParticipant = class StoredFileWorkingCopySaveParticipant2 extends Disposable {
  get length() {
    return this.saveParticipants.length;
  }
  constructor(progressService, logService) {
    super();
    this.progressService = progressService;
    this.logService = logService;
    this.saveParticipants = [];
  }
  addSaveParticipant(participant) {
    const remove = insert(this.saveParticipants, participant);
    return toDisposable(() => remove());
  }
  participate(workingCopy, context, token) {
    const cts = new CancellationTokenSource(token);
    return this.progressService.withProgress({
      title: localize("saveParticipants", "Saving '{0}'", workingCopy.name),
      location: 15,
      cancellable: true,
      delay: workingCopy.isDirty() ? 3e3 : 5e3
    }, async (progress) => {
      var _a43, _b;
      (_a43 = workingCopy.model) == null ? void 0 : _a43.pushStackElement();
      for (const saveParticipant of this.saveParticipants) {
        if (cts.token.isCancellationRequested || workingCopy.isDisposed()) {
          break;
        }
        try {
          const promise = saveParticipant.participate(workingCopy, context, progress, cts.token);
          await raceCancellation(promise, cts.token);
        } catch (err) {
          this.logService.warn(err);
        }
      }
      (_b = workingCopy.model) == null ? void 0 : _b.pushStackElement();
    }, () => {
      cts.dispose(true);
    });
  }
  dispose() {
    this.saveParticipants.splice(0, this.saveParticipants.length);
    super.dispose();
  }
};
StoredFileWorkingCopySaveParticipant = __decorate([
  __param(0, IProgressService),
  __param(1, ILogService)
], StoredFileWorkingCopySaveParticipant);

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/workingCopyFileService.js
var IWorkingCopyFileService = createDecorator("workingCopyFileService");
var WorkingCopyFileService = class WorkingCopyFileService2 extends Disposable {
  constructor(fileService, workingCopyService, instantiationService, uriIdentityService) {
    super();
    this.fileService = fileService;
    this.workingCopyService = workingCopyService;
    this.instantiationService = instantiationService;
    this.uriIdentityService = uriIdentityService;
    this._onWillRunWorkingCopyFileOperation = this._register(new AsyncEmitter());
    this.onWillRunWorkingCopyFileOperation = this._onWillRunWorkingCopyFileOperation.event;
    this._onDidFailWorkingCopyFileOperation = this._register(new AsyncEmitter());
    this.onDidFailWorkingCopyFileOperation = this._onDidFailWorkingCopyFileOperation.event;
    this._onDidRunWorkingCopyFileOperation = this._register(new AsyncEmitter());
    this.onDidRunWorkingCopyFileOperation = this._onDidRunWorkingCopyFileOperation.event;
    this.correlationIds = 0;
    this.fileOperationParticipants = this._register(this.instantiationService.createInstance(WorkingCopyFileOperationParticipant));
    this.saveParticipants = this._register(this.instantiationService.createInstance(StoredFileWorkingCopySaveParticipant));
    this.workingCopyProviders = [];
    this._register(this.registerWorkingCopyProvider((resource) => {
      return this.workingCopyService.workingCopies.filter((workingCopy) => {
        if (this.fileService.hasProvider(resource)) {
          return this.uriIdentityService.extUri.isEqualOrParent(workingCopy.resource, resource);
        }
        return this.uriIdentityService.extUri.isEqual(workingCopy.resource, resource);
      });
    }));
  }
  create(operations, token, undoInfo) {
    return this.doCreateFileOrFolder(operations, true, token, undoInfo);
  }
  createFolder(operations, token, undoInfo) {
    return this.doCreateFileOrFolder(operations, false, token, undoInfo);
  }
  async doCreateFileOrFolder(operations, isFile, token, undoInfo) {
    if (operations.length === 0) {
      return [];
    }
    if (isFile) {
      const validateCreates = await Promises.settled(operations.map(
        (operation) => this.fileService.canCreateFile(operation.resource, { overwrite: operation.overwrite })
      ));
      const error = validateCreates.find((validateCreate) => validateCreate instanceof Error);
      if (error instanceof Error) {
        throw error;
      }
    }
    const files = operations.map((operation) => ({ target: operation.resource }));
    await this.runFileOperationParticipants(files, 0, undoInfo, token);
    const event = { correlationId: this.correlationIds++, operation: 0, files };
    await this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None);
    let stats;
    try {
      if (isFile) {
        stats = await Promises.settled(operations.map(
          (operation) => this.fileService.createFile(operation.resource, operation.contents, { overwrite: operation.overwrite })
        ));
      } else {
        stats = await Promises.settled(operations.map((operation) => this.fileService.createFolder(operation.resource)));
      }
    } catch (error) {
      await this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None);
      throw error;
    }
    await this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None);
    return stats;
  }
  async move(operations, token, undoInfo) {
    return this.doMoveOrCopy(operations, true, token, undoInfo);
  }
  async copy(operations, token, undoInfo) {
    return this.doMoveOrCopy(operations, false, token, undoInfo);
  }
  async doMoveOrCopy(operations, move, token, undoInfo) {
    const stats = [];
    for (const { file: { source, target }, overwrite } of operations) {
      const validateMoveOrCopy = await (move ? this.fileService.canMove(source, target, overwrite) : this.fileService.canCopy(source, target, overwrite));
      if (validateMoveOrCopy instanceof Error) {
        throw validateMoveOrCopy;
      }
    }
    const files = operations.map((o) => o.file);
    await this.runFileOperationParticipants(files, move ? 2 : 3, undoInfo, token);
    const event = { correlationId: this.correlationIds++, operation: move ? 2 : 3, files };
    await this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None);
    try {
      for (const { file: { source, target }, overwrite } of operations) {
        if (!this.uriIdentityService.extUri.isEqual(source, target)) {
          const dirtyWorkingCopies = move ? [...this.getDirty(source), ...this.getDirty(target)] : this.getDirty(target);
          await Promises.settled(dirtyWorkingCopies.map((dirtyWorkingCopy) => dirtyWorkingCopy.revert({ soft: true })));
        }
        if (move) {
          stats.push(await this.fileService.move(source, target, overwrite));
        } else {
          stats.push(await this.fileService.copy(source, target, overwrite));
        }
      }
    } catch (error) {
      await this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None);
      throw error;
    }
    await this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None);
    return stats;
  }
  async delete(operations, token, undoInfo) {
    for (const operation of operations) {
      const validateDelete = await this.fileService.canDelete(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });
      if (validateDelete instanceof Error) {
        throw validateDelete;
      }
    }
    const files = operations.map((operation) => ({ target: operation.resource }));
    await this.runFileOperationParticipants(files, 1, undoInfo, token);
    const event = { correlationId: this.correlationIds++, operation: 1, files };
    await this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None);
    for (const operation of operations) {
      const dirtyWorkingCopies = this.getDirty(operation.resource);
      await Promises.settled(dirtyWorkingCopies.map((dirtyWorkingCopy) => dirtyWorkingCopy.revert({ soft: true })));
    }
    try {
      for (const operation of operations) {
        await this.fileService.del(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });
      }
    } catch (error) {
      await this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None);
      throw error;
    }
    await this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None);
  }
  addFileOperationParticipant(participant) {
    return this.fileOperationParticipants.addFileOperationParticipant(participant);
  }
  runFileOperationParticipants(files, operation, undoInfo, token) {
    return this.fileOperationParticipants.participate(files, operation, undoInfo, token);
  }
  get hasSaveParticipants() {
    return this.saveParticipants.length > 0;
  }
  addSaveParticipant(participant) {
    return this.saveParticipants.addSaveParticipant(participant);
  }
  runSaveParticipants(workingCopy, context, token) {
    return this.saveParticipants.participate(workingCopy, context, token);
  }
  registerWorkingCopyProvider(provider) {
    const remove = insert(this.workingCopyProviders, provider);
    return toDisposable(remove);
  }
  getDirty(resource) {
    const dirtyWorkingCopies = /* @__PURE__ */ new Set();
    for (const provider of this.workingCopyProviders) {
      for (const workingCopy of provider(resource)) {
        if (workingCopy.isDirty()) {
          dirtyWorkingCopies.add(workingCopy);
        }
      }
    }
    return Array.from(dirtyWorkingCopies);
  }
};
WorkingCopyFileService = __decorate([
  __param(0, IFileService),
  __param(1, IWorkingCopyService),
  __param(2, IInstantiationService),
  __param(3, IUriIdentityService)
], WorkingCopyFileService);

// node_modules/vscode/vscode/src/vs/workbench/services/path/common/pathService.js
init_tslib_es6();
init_extpath();
init_network();
init_path();
init_platform();
init_resources();
init_uri();
init_instantiation();

// node_modules/vscode/vscode/src/vs/platform/workspace/common/virtualWorkspace.js
init_network();
function isVirtualResource(resource) {
  return resource.scheme !== Schemas.file && resource.scheme !== Schemas.vscodeRemote;
}
function getVirtualWorkspaceLocation(workspace) {
  if (workspace.folders.length) {
    return workspace.folders.every((f) => isVirtualResource(f.uri)) ? workspace.folders[0].uri : void 0;
  } else if (workspace.configuration && isVirtualResource(workspace.configuration)) {
    return workspace.configuration;
  }
  return void 0;
}
function getVirtualWorkspaceScheme(workspace) {
  var _a43;
  return (_a43 = getVirtualWorkspaceLocation(workspace)) == null ? void 0 : _a43.scheme;
}

// node_modules/vscode/vscode/src/vs/workbench/services/path/common/pathService.js
var AbstractPathService_1;
var IPathService = createDecorator("pathService");
var AbstractPathService = AbstractPathService_1 = class AbstractPathService2 {
  constructor(localUserHome, remoteAgentService, environmentService, contextService) {
    this.localUserHome = localUserHome;
    this.remoteAgentService = remoteAgentService;
    this.environmentService = environmentService;
    this.contextService = contextService;
    this.resolveOS = (async () => {
      const env = await this.remoteAgentService.getEnvironment();
      return (env == null ? void 0 : env.os) || OS;
    })();
    this.resolveUserHome = (async () => {
      const env = await this.remoteAgentService.getEnvironment();
      const userHome = this.maybeUnresolvedUserHome = (env == null ? void 0 : env.userHome) ?? localUserHome;
      return userHome;
    })();
  }
  hasValidBasename(resource, arg2, basename3) {
    if (typeof arg2 === "string" || typeof arg2 === "undefined") {
      return this.resolveOS.then((os) => this.doHasValidBasename(resource, os, arg2));
    }
    return this.doHasValidBasename(resource, arg2, basename3);
  }
  doHasValidBasename(resource, os, name) {
    if (resource.scheme === Schemas.file || resource.scheme === Schemas.vscodeRemote) {
      return isValidBasename(name ?? basename2(resource), os === 1);
    }
    return true;
  }
  get defaultUriScheme() {
    return AbstractPathService_1.findDefaultUriScheme(this.environmentService, this.contextService);
  }
  static findDefaultUriScheme(environmentService, contextService) {
    if (environmentService.remoteAuthority) {
      return Schemas.vscodeRemote;
    }
    const virtualWorkspace = getVirtualWorkspaceScheme(contextService.getWorkspace());
    if (virtualWorkspace) {
      return virtualWorkspace;
    }
    const firstFolder = contextService.getWorkspace().folders[0];
    if (firstFolder) {
      return firstFolder.uri.scheme;
    }
    const configuration = contextService.getWorkspace().configuration;
    if (configuration) {
      return configuration.scheme;
    }
    return Schemas.file;
  }
  userHome(options) {
    return (options == null ? void 0 : options.preferLocal) ? this.localUserHome : this.resolveUserHome;
  }
  get resolvedUserHome() {
    return this.maybeUnresolvedUserHome;
  }
  get path() {
    return this.resolveOS.then((os) => {
      return os === 1 ? win32 : posix;
    });
  }
  async fileURI(_path) {
    let authority = "";
    const os = await this.resolveOS;
    if (os === 1) {
      _path = _path.replace(/\\/g, "/");
    }
    if (_path[0] === "/" && _path[1] === "/") {
      const idx = _path.indexOf("/", 2);
      if (idx === -1) {
        authority = _path.substring(2);
        _path = "/";
      } else {
        authority = _path.substring(2, idx);
        _path = _path.substring(idx) || "/";
      }
    }
    return URI.from({
      scheme: Schemas.file,
      authority,
      path: _path,
      query: "",
      fragment: ""
    });
  }
};
AbstractPathService = AbstractPathService_1 = __decorate([
  __param(1, IRemoteAgentService),
  __param(2, IWorkbenchEnvironmentService),
  __param(3, IWorkspaceContextService)
], AbstractPathService);

// node_modules/vscode/missing-services.js
init_extensions2();

// node_modules/vscode/vscode/src/vs/workbench/services/languageStatus/common/languageStatusService.js
init_instantiation();
var ILanguageStatusService = createDecorator("ILanguageStatusService");

// node_modules/vscode/missing-services.js
init_strings();

// node_modules/vscode/vscode/src/vs/workbench/services/host/browser/host.js
init_instantiation();
var IHostService = createDecorator("hostService");

// node_modules/vscode/vscode/src/vs/workbench/services/languageDetection/common/languageDetectionWorkerService.js
init_instantiation();
var ILanguageDetectionService = createDecorator("ILanguageDetectionService");
var LanguageDetectionLanguageEventSource = "languageDetection";

// node_modules/vscode/vscode/src/vs/platform/keyboardLayout/common/keyboardLayout.js
init_instantiation();
var IKeyboardLayoutService = createDecorator("keyboardLayoutService");
function getKeyboardLayoutId(layout) {
  if (layout.name) {
    return layout.name;
  }
  if (layout.id) {
    return layout.id;
  }
  return layout.layout;
}

// node_modules/vscode/missing-services.js
init_platform();
init_environment();

// node_modules/vscode/vscode/src/vs/workbench/services/userData/browser/userDataInit.js
init_tslib_es6();
init_instantiation();
init_platform2();
init_platform();
var IUserDataInitializationService = createDecorator("IUserDataInitializationService");
var InitializeOtherResourcesContribution = class InitializeOtherResourcesContribution2 {
  constructor(userDataInitializeService, instantiationService, extensionService) {
    extensionService.whenInstalledExtensionsRegistered().then(() => this.initializeOtherResource(userDataInitializeService, instantiationService));
  }
  async initializeOtherResource(userDataInitializeService, instantiationService) {
    if (await userDataInitializeService.requiresInitialization()) {
      mark("code/willInitOtherUserData");
      await userDataInitializeService.initializeOtherResources(instantiationService);
      mark("code/didInitOtherUserData");
    }
  }
};
InitializeOtherResourcesContribution = __decorate([
  __param(0, IUserDataInitializationService),
  __param(1, IInstantiationService),
  __param(2, IExtensionService)
], InitializeOtherResourcesContribution);
if (isWeb) {
  const workbenchRegistry2 = Registry.as(Extensions.Workbench);
  workbenchRegistry2.registerWorkbenchContribution(InitializeOtherResourcesContribution, 3);
}

// node_modules/vscode/vscode/src/vs/workbench/services/themes/browser/browserHostColorSchemeService.js
init_event();
init_browser();
init_lifecycle();
var BrowserHostColorSchemeService = class extends Disposable {
  constructor() {
    super();
    this._onDidSchemeChangeEvent = this._register(new Emitter());
    this.registerListeners();
  }
  registerListeners() {
    addMatchMediaChangeListener("(prefers-color-scheme: dark)", () => {
      this._onDidSchemeChangeEvent.fire();
    });
    addMatchMediaChangeListener("(forced-colors: active)", () => {
      this._onDidSchemeChangeEvent.fire();
    });
  }
  get onDidChangeColorScheme() {
    return this._onDidSchemeChangeEvent.event;
  }
  get dark() {
    if (window.matchMedia(`(prefers-color-scheme: light)`).matches) {
      return false;
    } else if (window.matchMedia(`(prefers-color-scheme: dark)`).matches) {
      return true;
    }
    return false;
  }
  get highContrast() {
    if (window.matchMedia(`(forced-colors: active)`).matches) {
      return true;
    }
    return false;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/themes/common/hostColorSchemeService.js
init_instantiation();
var IHostColorSchemeService = createDecorator("hostColorSchemeService");

// node_modules/vscode/vscode/src/vs/workbench/services/preferences/common/preferences.js
init_instantiation();
var SettingValueType;
(function(SettingValueType2) {
  SettingValueType2["Null"] = "null";
  SettingValueType2["Enum"] = "enum";
  SettingValueType2["String"] = "string";
  SettingValueType2["MultilineString"] = "multiline-string";
  SettingValueType2["Integer"] = "integer";
  SettingValueType2["Number"] = "number";
  SettingValueType2["Boolean"] = "boolean";
  SettingValueType2["Array"] = "array";
  SettingValueType2["Exclude"] = "exclude";
  SettingValueType2["Include"] = "include";
  SettingValueType2["Complex"] = "complex";
  SettingValueType2["NullableInteger"] = "nullable-integer";
  SettingValueType2["NullableNumber"] = "nullable-number";
  SettingValueType2["Object"] = "object";
  SettingValueType2["BooleanObject"] = "boolean-object";
  SettingValueType2["LanguageTag"] = "language-tag";
  SettingValueType2["ExtensionToggle"] = "extension-toggle";
})(SettingValueType || (SettingValueType = {}));
var SettingMatchType;
(function(SettingMatchType2) {
  SettingMatchType2[SettingMatchType2["None"] = 0] = "None";
  SettingMatchType2[SettingMatchType2["RemoteMatch"] = 1] = "RemoteMatch";
  SettingMatchType2[SettingMatchType2["WholeWordMatch"] = 2] = "WholeWordMatch";
  SettingMatchType2[SettingMatchType2["KeyMatch"] = 4] = "KeyMatch";
})(SettingMatchType || (SettingMatchType = {}));
var IPreferencesService = createDecorator("preferencesService");

// node_modules/vscode/missing-services.js
init_contextkey();
init_codeEditorService();

// node_modules/vscode/vscode/src/vs/workbench/services/userDataProfile/common/userDataProfileService.js
init_tslib_es6();
init_async();
init_event();
init_lifecycle();
init_objects();
init_themables();
var UserDataProfileService = class UserDataProfileService2 extends Disposable {
  get currentProfile() {
    return this._currentProfile;
  }
  constructor(currentProfile, userDataProfilesService) {
    super();
    this._onDidChangeCurrentProfile = this._register(new Emitter());
    this.onDidChangeCurrentProfile = this._onDidChangeCurrentProfile.event;
    this._currentProfile = currentProfile;
  }
  async updateCurrentProfile(userDataProfile) {
    if (equals(this._currentProfile, userDataProfile)) {
      return;
    }
    const previous = this._currentProfile;
    this._currentProfile = userDataProfile;
    const joiners = [];
    this._onDidChangeCurrentProfile.fire({
      previous,
      profile: userDataProfile,
      join(promise) {
        joiners.push(promise);
      }
    });
    await Promises.settled(joiners);
  }
  getShortName(profile2) {
    if (!profile2.isDefault && profile2.shortName && ThemeIcon.fromId(profile2.shortName)) {
      return profile2.shortName;
    }
    return `$(${defaultUserDataProfileIcon.id})`;
  }
};
UserDataProfileService = __decorate([
  __param(1, IUserDataProfilesService)
], UserDataProfileService);

// node_modules/vscode/missing-services.js
init_log();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/workbench/services/keybinding/common/fallbackKeyboardMapper.js
init_keybindings();
var FallbackKeyboardMapper = class {
  constructor(_mapAltGrToCtrlAlt, _OS) {
    this._mapAltGrToCtrlAlt = _mapAltGrToCtrlAlt;
    this._OS = _OS;
  }
  dumpDebugInfo() {
    return "FallbackKeyboardMapper dispatching on keyCode";
  }
  resolveKeyboardEvent(keyboardEvent) {
    const ctrlKey = keyboardEvent.ctrlKey || this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey;
    const altKey = keyboardEvent.altKey || this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey;
    const chord = new KeyCodeChord(
      ctrlKey,
      keyboardEvent.shiftKey,
      altKey,
      keyboardEvent.metaKey,
      keyboardEvent.keyCode
    );
    const result = this.resolveKeybinding(new Keybinding([chord]));
    return result[0];
  }
  resolveKeybinding(keybinding) {
    return USLayoutResolvedKeybinding.resolveKeybinding(keybinding, this._OS);
  }
};

// node_modules/vscode/missing-services.js
init_debug();

// node_modules/vscode/vscode/src/vs/workbench/services/activity/common/activity.js
init_instantiation();
var IActivityService = createDecorator("activityService");
var BaseBadge = class {
  constructor(descriptorFn) {
    this.descriptorFn = descriptorFn;
    this.descriptorFn = descriptorFn;
  }
  getDescription() {
    return this.descriptorFn(null);
  }
};
var NumberBadge = class extends BaseBadge {
  constructor(number, descriptorFn) {
    super(descriptorFn);
    this.number = number;
    this.number = number;
  }
  getDescription() {
    return this.descriptorFn(this.number);
  }
};

// node_modules/vscode/vscode/src/vs/platform/debug/common/extensionHostDebug.js
init_instantiation();
var IExtensionHostDebugService = createDecorator("extensionHostDebugService");

// node_modules/vscode/vscode/src/vs/workbench/common/views.js
init_event();
init_nls();
init_instantiation();
init_lifecycle();
init_map();
init_platform2();
init_arrays();
init_objects();
init_codicons();
var defaultViewIcon = registerIcon("default-view-icon", Codicon.window, localize("defaultViewIcon", "Default view icon."));
var Extensions5;
(function(Extensions7) {
  Extensions7.ViewContainersRegistry = "workbench.registry.view.containers";
  Extensions7.ViewsRegistry = "workbench.registry.view";
})(Extensions5 || (Extensions5 = {}));
var ViewContainerLocation;
(function(ViewContainerLocation2) {
  ViewContainerLocation2[ViewContainerLocation2["Sidebar"] = 0] = "Sidebar";
  ViewContainerLocation2[ViewContainerLocation2["Panel"] = 1] = "Panel";
  ViewContainerLocation2[ViewContainerLocation2["AuxiliaryBar"] = 2] = "AuxiliaryBar";
})(ViewContainerLocation || (ViewContainerLocation = {}));
function ViewContainerLocationToString(viewContainerLocation) {
  switch (viewContainerLocation) {
    case 0:
      return "sidebar";
    case 1:
      return "panel";
    case 2:
      return "auxiliarybar";
  }
}
var ViewContainersRegistryImpl = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidRegister = this._register(new Emitter());
    this.onDidRegister = this._onDidRegister.event;
    this._onDidDeregister = this._register(new Emitter());
    this.onDidDeregister = this._onDidDeregister.event;
    this.viewContainers = /* @__PURE__ */ new Map();
    this.defaultViewContainers = [];
  }
  get all() {
    return flatten([...this.viewContainers.values()]);
  }
  registerViewContainer(viewContainerDescriptor, viewContainerLocation, options) {
    const existing = this.get(viewContainerDescriptor.id);
    if (existing) {
      return existing;
    }
    const viewContainer = viewContainerDescriptor;
    viewContainer.openCommandActionDescriptor = (options == null ? void 0 : options.doNotRegisterOpenCommand) ? void 0 : viewContainer.openCommandActionDescriptor ?? { id: viewContainer.id };
    const viewContainers = getOrSet(this.viewContainers, viewContainerLocation, []);
    viewContainers.push(viewContainer);
    if (options == null ? void 0 : options.isDefault) {
      this.defaultViewContainers.push(viewContainer);
    }
    this._onDidRegister.fire({ viewContainer, viewContainerLocation });
    return viewContainer;
  }
  deregisterViewContainer(viewContainer) {
    for (const viewContainerLocation of this.viewContainers.keys()) {
      const viewContainers = this.viewContainers.get(viewContainerLocation);
      const index = viewContainers == null ? void 0 : viewContainers.indexOf(viewContainer);
      if (index !== -1) {
        viewContainers == null ? void 0 : viewContainers.splice(index, 1);
        if (viewContainers.length === 0) {
          this.viewContainers.delete(viewContainerLocation);
        }
        this._onDidDeregister.fire({ viewContainer, viewContainerLocation });
        return;
      }
    }
  }
  get(id) {
    return this.all.filter((viewContainer) => viewContainer.id === id)[0];
  }
  getViewContainers(location) {
    return [...this.viewContainers.get(location) || []];
  }
  getViewContainerLocation(container) {
    return [...this.viewContainers.keys()].filter((location) => this.getViewContainers(location).filter((viewContainer) => (viewContainer == null ? void 0 : viewContainer.id) === container.id).length > 0)[0];
  }
  getDefaultViewContainer(location) {
    return this.defaultViewContainers.find((viewContainer) => this.getViewContainerLocation(viewContainer) === location);
  }
};
Registry.add(Extensions5.ViewContainersRegistry, new ViewContainersRegistryImpl());
var ViewContentGroups;
(function(ViewContentGroups2) {
  ViewContentGroups2["Open"] = "2_open";
  ViewContentGroups2["Debug"] = "4_debug";
  ViewContentGroups2["SCM"] = "5_scm";
  ViewContentGroups2["More"] = "9_more";
})(ViewContentGroups || (ViewContentGroups = {}));
function compareViewContentDescriptors(a, b) {
  const aGroup = a.group ?? ViewContentGroups.More;
  const bGroup = b.group ?? ViewContentGroups.More;
  if (aGroup !== bGroup) {
    return aGroup.localeCompare(bGroup);
  }
  return (a.order ?? 5) - (b.order ?? 5);
}
var ViewsRegistry = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onViewsRegistered = this._register(new Emitter());
    this.onViewsRegistered = this._onViewsRegistered.event;
    this._onViewsDeregistered = this._register(new Emitter());
    this.onViewsDeregistered = this._onViewsDeregistered.event;
    this._onDidChangeContainer = this._register(new Emitter());
    this.onDidChangeContainer = this._onDidChangeContainer.event;
    this._onDidChangeViewWelcomeContent = this._register(new Emitter());
    this.onDidChangeViewWelcomeContent = this._onDidChangeViewWelcomeContent.event;
    this._viewContainers = [];
    this._views = /* @__PURE__ */ new Map();
    this._viewWelcomeContents = new SetMap();
  }
  registerViews(views, viewContainer) {
    this.registerViews2([{ views, viewContainer }]);
  }
  registerViews2(views) {
    views.forEach(({ views: views2, viewContainer }) => this.addViews(views2, viewContainer));
    this._onViewsRegistered.fire(views);
  }
  deregisterViews(viewDescriptors, viewContainer) {
    const views = this.removeViews(viewDescriptors, viewContainer);
    if (views.length) {
      this._onViewsDeregistered.fire({ views, viewContainer });
    }
  }
  moveViews(viewsToMove, viewContainer) {
    for (const container of this._views.keys()) {
      if (container !== viewContainer) {
        const views = this.removeViews(viewsToMove, container);
        if (views.length) {
          this.addViews(views, viewContainer);
          this._onDidChangeContainer.fire({ views, from: container, to: viewContainer });
        }
      }
    }
  }
  getViews(loc) {
    return this._views.get(loc) || [];
  }
  getView(id) {
    for (const viewContainer of this._viewContainers) {
      const viewDescriptor = (this._views.get(viewContainer) || []).filter((v) => v.id === id)[0];
      if (viewDescriptor) {
        return viewDescriptor;
      }
    }
    return null;
  }
  getViewContainer(viewId) {
    for (const viewContainer of this._viewContainers) {
      const viewDescriptor = (this._views.get(viewContainer) || []).filter((v) => v.id === viewId)[0];
      if (viewDescriptor) {
        return viewContainer;
      }
    }
    return null;
  }
  registerViewWelcomeContent(id, viewContent) {
    this._viewWelcomeContents.add(id, viewContent);
    this._onDidChangeViewWelcomeContent.fire(id);
    return toDisposable(() => {
      this._viewWelcomeContents.delete(id, viewContent);
      this._onDidChangeViewWelcomeContent.fire(id);
    });
  }
  registerViewWelcomeContent2(id, viewContentMap) {
    const disposables = /* @__PURE__ */ new Map();
    for (const [key, content] of viewContentMap) {
      this._viewWelcomeContents.add(id, content);
      disposables.set(key, toDisposable(() => {
        this._viewWelcomeContents.delete(id, content);
        this._onDidChangeViewWelcomeContent.fire(id);
      }));
    }
    this._onDidChangeViewWelcomeContent.fire(id);
    return disposables;
  }
  getViewWelcomeContent(id) {
    const result = [];
    this._viewWelcomeContents.forEach(id, (descriptor) => result.push(descriptor));
    return result.sort(compareViewContentDescriptors);
  }
  addViews(viewDescriptors, viewContainer) {
    let views = this._views.get(viewContainer);
    if (!views) {
      views = [];
      this._views.set(viewContainer, views);
      this._viewContainers.push(viewContainer);
    }
    for (const viewDescriptor of viewDescriptors) {
      if (this.getView(viewDescriptor.id) !== null) {
        throw new Error(localize("duplicateId", "A view with id '{0}' is already registered", viewDescriptor.id));
      }
      views.push(viewDescriptor);
    }
  }
  removeViews(viewDescriptors, viewContainer) {
    const views = this._views.get(viewContainer);
    if (!views) {
      return [];
    }
    const viewsToDeregister = [];
    const remaningViews = [];
    for (const view of views) {
      if (!viewDescriptors.includes(view)) {
        remaningViews.push(view);
      } else {
        viewsToDeregister.push(view);
      }
    }
    if (viewsToDeregister.length) {
      if (remaningViews.length) {
        this._views.set(viewContainer, remaningViews);
      } else {
        this._views.delete(viewContainer);
        this._viewContainers.splice(this._viewContainers.indexOf(viewContainer), 1);
      }
    }
    return viewsToDeregister;
  }
};
Registry.add(Extensions5.ViewsRegistry, new ViewsRegistry());
var IViewsService = createDecorator("viewsService");
var IViewDescriptorService = createDecorator("viewDescriptorService");
var ViewVisibilityState;
(function(ViewVisibilityState2) {
  ViewVisibilityState2[ViewVisibilityState2["Default"] = 0] = "Default";
  ViewVisibilityState2[ViewVisibilityState2["Expand"] = 1] = "Expand";
})(ViewVisibilityState || (ViewVisibilityState = {}));
var TreeItemCollapsibleState;
(function(TreeItemCollapsibleState2) {
  TreeItemCollapsibleState2[TreeItemCollapsibleState2["None"] = 0] = "None";
  TreeItemCollapsibleState2[TreeItemCollapsibleState2["Collapsed"] = 1] = "Collapsed";
  TreeItemCollapsibleState2[TreeItemCollapsibleState2["Expanded"] = 2] = "Expanded";
})(TreeItemCollapsibleState || (TreeItemCollapsibleState = {}));
var ResolvableTreeItem = class {
  constructor(treeItem, resolve) {
    this.resolved = false;
    this._hasResolve = false;
    mixin(this, treeItem);
    this._hasResolve = !!resolve;
    this.resolve = async (token) => {
      if (resolve && !this.resolved) {
        const resolvedItem = await resolve(token);
        if (resolvedItem) {
          this.tooltip = this.tooltip ?? resolvedItem.tooltip;
          this.command = this.command ?? resolvedItem.command;
        }
      }
      if (!token.isCancellationRequested) {
        this.resolved = true;
      }
    };
  }
  get hasResolve() {
    return this._hasResolve;
  }
  resetResolve() {
    this.resolved = false;
  }
  asTreeItem() {
    return {
      handle: this.handle,
      parentHandle: this.parentHandle,
      collapsibleState: this.collapsibleState,
      label: this.label,
      description: this.description,
      icon: this.icon,
      iconDark: this.iconDark,
      themeIcon: this.themeIcon,
      resourceUri: this.resourceUri,
      tooltip: this.tooltip,
      contextValue: this.contextValue,
      command: this.command,
      children: this.children,
      accessibilityInformation: this.accessibilityInformation
    };
  }
};
var NoTreeViewError = class extends Error {
  constructor(treeViewId) {
    super(localize(
      "treeView.notRegistered",
      "No tree view with id '{0}' registered.",
      treeViewId
    ));
    this.name = "NoTreeViewError";
  }
  static is(err) {
    return err.name === "NoTreeViewError";
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/history/common/history.js
init_instantiation();
var IHistoryService = createDecorator("historyService");
var GoFilter;
(function(GoFilter2) {
  GoFilter2[GoFilter2["NONE"] = 0] = "NONE";
  GoFilter2[GoFilter2["EDITS"] = 1] = "EDITS";
  GoFilter2[GoFilter2["NAVIGATION"] = 2] = "NAVIGATION";
})(GoFilter || (GoFilter = {}));
var GoScope;
(function(GoScope2) {
  GoScope2[GoScope2["DEFAULT"] = 0] = "DEFAULT";
  GoScope2[GoScope2["EDITOR_GROUP"] = 1] = "EDITOR_GROUP";
  GoScope2[GoScope2["EDITOR"] = 2] = "EDITOR";
})(GoScope || (GoScope = {}));

// node_modules/vscode/vscode/src/vs/workbench/contrib/tasks/common/taskService.js
init_nls();
init_instantiation();
init_contextkey();
var CustomExecutionSupportedContext = new RawContextKey("customExecutionSupported", false, localize(
  "tasks.customExecutionSupported",
  "Whether CustomExecution tasks are supported. Consider using in the when clause of a 'taskDefinition' contribution."
));
var ShellExecutionSupportedContext = new RawContextKey("shellExecutionSupported", false, localize(
  "tasks.shellExecutionSupported",
  "Whether ShellExecution tasks are supported. Consider using in the when clause of a 'taskDefinition' contribution."
));
var ProcessExecutionSupportedContext = new RawContextKey("processExecutionSupported", false, localize(
  "tasks.processExecutionSupported",
  "Whether ProcessExecution tasks are supported. Consider using in the when clause of a 'taskDefinition' contribution."
));
var TaskExecutionSupportedContext = ContextKeyExpr.or(ContextKeyExpr.and(ShellExecutionSupportedContext, ProcessExecutionSupportedContext), CustomExecutionSupportedContext);
var ITaskService = createDecorator("taskService");

// node_modules/vscode/vscode/src/vs/workbench/services/configurationResolver/common/configurationResolver.js
init_instantiation();
var IConfigurationResolverService = createDecorator("configurationResolverService");
var VariableKind;
(function(VariableKind2) {
  VariableKind2["Unknown"] = "unknown";
  VariableKind2["Env"] = "env";
  VariableKind2["Config"] = "config";
  VariableKind2["Command"] = "command";
  VariableKind2["Input"] = "input";
  VariableKind2["ExtensionInstallFolder"] = "extensionInstallFolder";
  VariableKind2["WorkspaceFolder"] = "workspaceFolder";
  VariableKind2["Cwd"] = "cwd";
  VariableKind2["WorkspaceFolderBasename"] = "workspaceFolderBasename";
  VariableKind2["UserHome"] = "userHome";
  VariableKind2["LineNumber"] = "lineNumber";
  VariableKind2["SelectedText"] = "selectedText";
  VariableKind2["File"] = "file";
  VariableKind2["FileWorkspaceFolder"] = "fileWorkspaceFolder";
  VariableKind2["RelativeFile"] = "relativeFile";
  VariableKind2["RelativeFileDirname"] = "relativeFileDirname";
  VariableKind2["FileDirname"] = "fileDirname";
  VariableKind2["FileExtname"] = "fileExtname";
  VariableKind2["FileBasename"] = "fileBasename";
  VariableKind2["FileBasenameNoExtension"] = "fileBasenameNoExtension";
  VariableKind2["FileDirnameBasename"] = "fileDirnameBasename";
  VariableKind2["ExecPath"] = "execPath";
  VariableKind2["ExecInstallFolder"] = "execInstallFolder";
  VariableKind2["PathSeparator"] = "pathSeparator";
})(VariableKind || (VariableKind = {}));
var VariableError = class extends Error {
  constructor(variable, message) {
    super(message);
    this.variable = variable;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/path/browser/pathService.js
init_tslib_es6();
init_uri();
init_arrays();
init_resources();
var BrowserPathService = class BrowserPathService2 extends AbstractPathService {
  constructor(remoteAgentService, environmentService, contextService) {
    super(guessLocalUserHome(environmentService, contextService), remoteAgentService, environmentService, contextService);
  }
};
BrowserPathService = __decorate([
  __param(0, IRemoteAgentService),
  __param(1, IWorkbenchEnvironmentService),
  __param(2, IWorkspaceContextService)
], BrowserPathService);
function guessLocalUserHome(environmentService, contextService) {
  const workspace = contextService.getWorkspace();
  const firstFolder = firstOrDefault(workspace.folders);
  if (firstFolder) {
    return firstFolder.uri;
  }
  if (workspace.configuration) {
    return dirname(workspace.configuration);
  }
  return URI.from({
    scheme: AbstractPathService.findDefaultUriScheme(environmentService, contextService),
    authority: environmentService.remoteAuthority,
    path: "/"
  });
}

// node_modules/vscode/missing-services.js
init_telemetry();
init_telemetryUtils();

// node_modules/vscode/vscode/src/vs/workbench/services/search/common/search.js
init_arrays();
init_objects();
init_extpath();
init_strings();
init_instantiation();
init_path();
init_errors();
init_async();
var SEARCH_ELIDED_PREFIX = " ";
var SEARCH_ELIDED_SUFFIX = " characters skipped ";
var SEARCH_ELIDED_MIN_LEN = (SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;
var ISearchService = createDecorator("searchService");
function resultIsMatch(result) {
  return !!result.preview;
}
var TextSearchMatch = class {
  constructor(text, range, previewOptions, webviewIndex) {
    this.ranges = range;
    this.webviewIndex = webviewIndex;
    const ranges = Array.isArray(range) ? range : [range];
    if (previewOptions && previewOptions.matchLines === 1 && isSingleLineRangeList(ranges)) {
      text = getNLines(text, previewOptions.matchLines);
      let result = "";
      let shift = 0;
      let lastEnd = 0;
      const leadingChars = Math.floor(previewOptions.charsPerLine / 5);
      const matches = [];
      for (const range2 of ranges) {
        const previewStart = Math.max(range2.startColumn - leadingChars, 0);
        const previewEnd = range2.startColumn + previewOptions.charsPerLine;
        if (previewStart > lastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN) {
          const elision = SEARCH_ELIDED_PREFIX + (previewStart - lastEnd) + SEARCH_ELIDED_SUFFIX;
          result += elision + text.slice(previewStart, previewEnd);
          shift += previewStart - (lastEnd + elision.length);
        } else {
          result += text.slice(lastEnd, previewEnd);
        }
        matches.push(new OneLineRange(0, range2.startColumn - shift, range2.endColumn - shift));
        lastEnd = previewEnd;
      }
      this.preview = { text: result, matches: Array.isArray(this.ranges) ? matches : matches[0] };
    } else {
      const firstMatchLine = Array.isArray(range) ? range[0].startLineNumber : range.startLineNumber;
      this.preview = {
        text,
        matches: mapArrayOrNot(range, (r) => new SearchRange(
          r.startLineNumber - firstMatchLine,
          r.startColumn,
          r.endLineNumber - firstMatchLine,
          r.endColumn
        ))
      };
    }
  }
};
function isSingleLineRangeList(ranges) {
  const line = ranges[0].startLineNumber;
  for (const r of ranges) {
    if (r.startLineNumber !== line || r.endLineNumber !== line) {
      return false;
    }
  }
  return true;
}
var SearchRange = class {
  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
    this.startLineNumber = startLineNumber;
    this.startColumn = startColumn;
    this.endLineNumber = endLineNumber;
    this.endColumn = endColumn;
  }
};
var OneLineRange = class extends SearchRange {
  constructor(lineNumber, startColumn, endColumn) {
    super(lineNumber, startColumn, lineNumber, endColumn);
  }
};
function getExcludes(configuration, includeSearchExcludes = true) {
  const fileExcludes = configuration && configuration.files && configuration.files.exclude;
  const searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;
  if (!fileExcludes && !searchExcludes) {
    return void 0;
  }
  if (!fileExcludes || !searchExcludes) {
    return fileExcludes || searchExcludes;
  }
  let allExcludes = /* @__PURE__ */ Object.create(null);
  allExcludes = mixin(allExcludes, deepClone(fileExcludes));
  allExcludes = mixin(allExcludes, deepClone(searchExcludes), true);
  return allExcludes;
}
function pathIncludedInQuery(queryProps, fsPath) {
  if (queryProps.excludePattern && match(queryProps.excludePattern, fsPath)) {
    return false;
  }
  if (queryProps.includePattern || queryProps.usingSearchPaths) {
    if (queryProps.includePattern && match(queryProps.includePattern, fsPath)) {
      return true;
    }
    if (queryProps.usingSearchPaths) {
      return !!queryProps.folderQueries && queryProps.folderQueries.some((fq) => {
        const searchPath = fq.folder.fsPath;
        if (isEqualOrParent(fsPath, searchPath)) {
          const relPath = relative(searchPath, fsPath);
          return !fq.includePattern || !!match(fq.includePattern, relPath);
        } else {
          return false;
        }
      });
    }
    return false;
  }
  return true;
}
var SearchErrorCode;
(function(SearchErrorCode2) {
  SearchErrorCode2[SearchErrorCode2["unknownEncoding"] = 1] = "unknownEncoding";
  SearchErrorCode2[SearchErrorCode2["regexParseError"] = 2] = "regexParseError";
  SearchErrorCode2[SearchErrorCode2["globParseError"] = 3] = "globParseError";
  SearchErrorCode2[SearchErrorCode2["invalidLiteral"] = 4] = "invalidLiteral";
  SearchErrorCode2[SearchErrorCode2["rgProcessError"] = 5] = "rgProcessError";
  SearchErrorCode2[SearchErrorCode2["other"] = 6] = "other";
  SearchErrorCode2[SearchErrorCode2["canceled"] = 7] = "canceled";
})(SearchErrorCode || (SearchErrorCode = {}));
function resolvePatternsForProvider(globalPattern, folderPattern) {
  const merged = {
    ...globalPattern || {},
    ...folderPattern || {}
  };
  return Object.keys(merged).filter((key) => {
    const value = merged[key];
    return typeof value === "boolean" && value;
  });
}
var QueryGlobTester = class {
  constructor(config, folderQuery) {
    this._parsedIncludeExpression = null;
    this._excludeExpression = {
      ...config.excludePattern || {},
      ...folderQuery.excludePattern || {}
    };
    this._parsedExcludeExpression = parse(this._excludeExpression);
    let includeExpression = config.includePattern;
    if (folderQuery.includePattern) {
      if (includeExpression) {
        includeExpression = {
          ...includeExpression,
          ...folderQuery.includePattern
        };
      } else {
        includeExpression = folderQuery.includePattern;
      }
    }
    if (includeExpression) {
      this._parsedIncludeExpression = parse(includeExpression);
    }
  }
  matchesExcludesSync(testPath, basename3, hasSibling) {
    if (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename3, hasSibling)) {
      return true;
    }
    return false;
  }
  includedInQuerySync(testPath, basename3, hasSibling) {
    if (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename3, hasSibling)) {
      return false;
    }
    if (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename3, hasSibling)) {
      return false;
    }
    return true;
  }
  includedInQuery(testPath, basename3, hasSibling) {
    const excluded = this._parsedExcludeExpression(testPath, basename3, hasSibling);
    const isIncluded = () => {
      return this._parsedIncludeExpression ? !!this._parsedIncludeExpression(testPath, basename3, hasSibling) : true;
    };
    if (isThenable(excluded)) {
      return excluded.then((excluded2) => {
        if (excluded2) {
          return false;
        }
        return isIncluded();
      });
    }
    return isIncluded();
  }
  hasSiblingExcludeClauses() {
    return hasSiblingClauses(this._excludeExpression);
  }
};
function hasSiblingClauses(pattern) {
  for (const key in pattern) {
    if (typeof pattern[key] !== "boolean") {
      return true;
    }
  }
  return false;
}
function hasSiblingPromiseFn(siblingsFn) {
  if (!siblingsFn) {
    return void 0;
  }
  let siblings;
  return (name) => {
    if (!siblings) {
      siblings = (siblingsFn() || Promise.resolve([])).then((list) => list ? listToMap(list) : {});
    }
    return siblings.then((map) => !!map[name]);
  };
}
function hasSiblingFn(siblingsFn) {
  if (!siblingsFn) {
    return void 0;
  }
  let siblings;
  return (name) => {
    if (!siblings) {
      const list = siblingsFn();
      siblings = list ? listToMap(list) : {};
    }
    return !!siblings[name];
  };
}
function listToMap(list) {
  const map = {};
  for (const key of list) {
    map[key] = true;
  }
  return map;
}

// node_modules/vscode/vscode/src/vs/platform/request/common/request.js
init_errors();
init_lifecycle();
init_nls();
init_instantiation();
init_log();
var IRequestService = createDecorator("requestService");
var LoggableHeaders = class {
  constructor(original) {
    this.original = original;
  }
  toJSON() {
    if (!this.headers) {
      const headers = /* @__PURE__ */ Object.create(null);
      for (const key in this.original) {
        if (key.toLowerCase() === "authorization" || key.toLowerCase() === "proxy-authorization") {
          headers[key] = "*****";
        } else {
          headers[key] = this.original[key];
        }
      }
      this.headers = headers;
    }
    return this.headers;
  }
};
var AbstractRequestService = class extends Disposable {
  constructor(loggerService) {
    super();
    this.counter = 0;
    this.logger = loggerService.createLogger("network", {
      name: localize("request", "Network Requests"),
      when: CONTEXT_LOG_LEVEL.isEqualTo(LogLevelToString(LogLevel.Trace)).serialize()
    });
  }
  async logAndRequest(stack, options, request2) {
    const prefix = `${stack} #${++this.counter}: ${options.url}`;
    this.logger.trace(`${prefix} - begin`, options.type, new LoggableHeaders(options.headers ?? {}));
    try {
      const result = await request2();
      this.logger.trace(`${prefix} - end`, options.type, result.res.statusCode, result.res.headers);
      return result;
    } catch (error) {
      this.logger.error(`${prefix} - error`, options.type, getErrorMessage(error));
      throw error;
    }
  }
};

// node_modules/vscode/missing-services.js
init_editSessions();

// node_modules/vscode/vscode/src/vs/workbench/services/workspaces/common/workspaceEditing.js
init_instantiation();
var IWorkspaceEditingService = createDecorator("workspaceEditingService");

// node_modules/vscode/vscode/src/vs/workbench/services/timer/browser/timerService.js
init_instantiation();
var ITimerService = createDecorator("timerService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/extensions/common/extensions.js
init_instantiation();
var IExtensionsWorkbenchService = createDecorator("extensionsWorkbenchService");

// node_modules/vscode/vscode/src/vs/workbench/services/extensionManagement/common/extensionManagement.js
init_instantiation();
var IProfileAwareExtensionManagementService = refineServiceDecorator(IExtensionManagementService);
var IExtensionManagementServerService = createDecorator("extensionManagementServerService");
var IWorkbenchExtensionManagementService = refineServiceDecorator(IProfileAwareExtensionManagementService);
var IWorkbenchExtensionEnablementService = createDecorator("extensionEnablementService");

// node_modules/vscode/vscode/src/vs/platform/tunnel/common/tunnel.js
init_event();
init_instantiation();
var ITunnelService = createDecorator("tunnelService");
var TunnelProtocol;
(function(TunnelProtocol2) {
  TunnelProtocol2["Http"] = "http";
  TunnelProtocol2["Https"] = "https";
})(TunnelProtocol || (TunnelProtocol = {}));
var TunnelPrivacyId;
(function(TunnelPrivacyId2) {
  TunnelPrivacyId2["ConstantPrivate"] = "constantPrivate";
  TunnelPrivacyId2["Private"] = "private";
  TunnelPrivacyId2["Public"] = "public";
})(TunnelPrivacyId || (TunnelPrivacyId = {}));
var ProvidedOnAutoForward;
(function(ProvidedOnAutoForward2) {
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["Notify"] = 1] = "Notify";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["OpenBrowser"] = 2] = "OpenBrowser";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["OpenPreview"] = 3] = "OpenPreview";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["Silent"] = 4] = "Silent";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["Ignore"] = 5] = "Ignore";
  ProvidedOnAutoForward2[ProvidedOnAutoForward2["OpenBrowserOnce"] = 6] = "OpenBrowserOnce";
})(ProvidedOnAutoForward || (ProvidedOnAutoForward = {}));
var LOCALHOST_ADDRESSES = ["localhost", "127.0.0.1", "0:0:0:0:0:0:0:1", "::1"];
function isLocalhost(host) {
  return LOCALHOST_ADDRESSES.indexOf(host) >= 0;
}
var ALL_INTERFACES_ADDRESSES = ["0.0.0.0", "0:0:0:0:0:0:0:0", "::"];
function isAllInterfaces(host) {
  return ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;
}
var DisposableTunnel = class {
  constructor(remoteAddress, localAddress, _dispose) {
    this.remoteAddress = remoteAddress;
    this.localAddress = localAddress;
    this._dispose = _dispose;
    this._onDispose = new Emitter();
    this.onDidDispose = this._onDispose.event;
  }
  dispose() {
    this._onDispose.fire();
    return this._dispose();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/workingCopyBackup.js
init_instantiation();
var IWorkingCopyBackupService = createDecorator("workingCopyBackupService");

// node_modules/vscode/vscode/src/vs/workbench/services/filesConfiguration/common/filesConfigurationService.js
init_tslib_es6();
init_nls();
init_instantiation();
init_event();
init_lifecycle();
init_contextkey();
init_configuration();
init_files();
init_objects();
init_platform();

// node_modules/vscode/vscode/src/vs/workbench/common/resources.js
init_tslib_es6();
init_uri();
init_objects();
init_path();
init_event();
init_resources();
init_lifecycle();
init_configuration();
init_network();
init_map();
init_extpath();
var ResourceGlobMatcher_1;
var _a;
var ResourceGlobMatcher = (_a = class extends Disposable {
  constructor(getExpression, shouldUpdate, contextService, configurationService) {
    super();
    this.getExpression = getExpression;
    this.shouldUpdate = shouldUpdate;
    this.contextService = contextService;
    this.configurationService = configurationService;
    this._onExpressionChange = this._register(new Emitter());
    this.onExpressionChange = this._onExpressionChange.event;
    this.mapFolderToParsedExpression = /* @__PURE__ */ new Map();
    this.mapFolderToConfiguredExpression = /* @__PURE__ */ new Map();
    this.updateExpressions(false);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (this.shouldUpdate(e)) {
        this.updateExpressions(true);
      }
    }));
    this._register(this.contextService.onDidChangeWorkspaceFolders(() => this.updateExpressions(true)));
  }
  updateExpressions(fromEvent) {
    let changed = false;
    for (const folder of this.contextService.getWorkspace().folders) {
      const folderUriStr = folder.uri.toString();
      const newExpression = this.doGetExpression(folder.uri);
      const currentExpression = this.mapFolderToConfiguredExpression.get(folderUriStr);
      if (newExpression) {
        if (!currentExpression || !equals(currentExpression.expression, newExpression.expression)) {
          changed = true;
          this.mapFolderToParsedExpression.set(folderUriStr, parse(newExpression.expression));
          this.mapFolderToConfiguredExpression.set(folderUriStr, newExpression);
        }
      } else {
        if (currentExpression) {
          changed = true;
          this.mapFolderToParsedExpression.delete(folderUriStr);
          this.mapFolderToConfiguredExpression.delete(folderUriStr);
        }
      }
    }
    const foldersMap = new ResourceSet(this.contextService.getWorkspace().folders.map((folder) => folder.uri));
    for (const [folder] of this.mapFolderToConfiguredExpression) {
      if (folder === ResourceGlobMatcher_1.NO_FOLDER) {
        continue;
      }
      if (!foldersMap.has(URI.parse(folder))) {
        this.mapFolderToParsedExpression.delete(folder);
        this.mapFolderToConfiguredExpression.delete(folder);
        changed = true;
      }
    }
    const globalNewExpression = this.doGetExpression(void 0);
    const globalCurrentExpression = this.mapFolderToConfiguredExpression.get(ResourceGlobMatcher_1.NO_FOLDER);
    if (globalNewExpression) {
      if (!globalCurrentExpression || !equals(globalCurrentExpression.expression, globalNewExpression.expression)) {
        changed = true;
        this.mapFolderToParsedExpression.set(ResourceGlobMatcher_1.NO_FOLDER, parse(globalNewExpression.expression));
        this.mapFolderToConfiguredExpression.set(ResourceGlobMatcher_1.NO_FOLDER, globalNewExpression);
      }
    } else {
      if (globalCurrentExpression) {
        changed = true;
        this.mapFolderToParsedExpression.delete(ResourceGlobMatcher_1.NO_FOLDER);
        this.mapFolderToConfiguredExpression.delete(ResourceGlobMatcher_1.NO_FOLDER);
      }
    }
    if (fromEvent && changed) {
      this._onExpressionChange.fire();
    }
  }
  doGetExpression(resource) {
    const expression = this.getExpression(resource);
    if (!expression) {
      return void 0;
    }
    const keys = Object.keys(expression);
    if (keys.length === 0) {
      return void 0;
    }
    let hasAbsolutePath = false;
    const massagedExpression = /* @__PURE__ */ Object.create(null);
    for (const key of keys) {
      if (!hasAbsolutePath) {
        hasAbsolutePath = isAbsolute(key);
      }
      let massagedKey = key;
      const driveLetter = getDriveLetter(massagedKey, true);
      if (driveLetter) {
        const driveLetterLower = driveLetter.toLowerCase();
        if (driveLetter !== driveLetter.toLowerCase()) {
          massagedKey = `${driveLetterLower}${massagedKey.substring(1)}`;
        }
      }
      massagedExpression[massagedKey] = expression[key];
    }
    return {
      expression: massagedExpression,
      hasAbsolutePath
    };
  }
  matches(resource, hasSibling) {
    if (this.mapFolderToParsedExpression.size === 0) {
      return false;
    }
    const folder = this.contextService.getWorkspaceFolder(resource);
    let expressionForFolder;
    let expressionConfigForFolder;
    if (folder && this.mapFolderToParsedExpression.has(folder.uri.toString())) {
      expressionForFolder = this.mapFolderToParsedExpression.get(folder.uri.toString());
      expressionConfigForFolder = this.mapFolderToConfiguredExpression.get(folder.uri.toString());
    } else {
      expressionForFolder = this.mapFolderToParsedExpression.get(ResourceGlobMatcher_1.NO_FOLDER);
      expressionConfigForFolder = this.mapFolderToConfiguredExpression.get(ResourceGlobMatcher_1.NO_FOLDER);
    }
    if (!expressionForFolder) {
      return false;
    }
    let resourcePathToMatch;
    if (folder) {
      resourcePathToMatch = relativePath(folder.uri, resource);
    } else {
      resourcePathToMatch = this.uriToPath(resource);
    }
    if (typeof resourcePathToMatch === "string" && !!expressionForFolder(resourcePathToMatch, void 0, hasSibling)) {
      return true;
    }
    if (resourcePathToMatch !== this.uriToPath(resource) && (expressionConfigForFolder == null ? void 0 : expressionConfigForFolder.hasAbsolutePath)) {
      return !!expressionForFolder(this.uriToPath(resource), void 0, hasSibling);
    }
    return false;
  }
  uriToPath(uri) {
    if (uri.scheme === Schemas.file) {
      return uri.fsPath;
    }
    return uri.path;
  }
}, ResourceGlobMatcher_1 = _a, _a.NO_FOLDER = null, _a);
ResourceGlobMatcher = ResourceGlobMatcher_1 = __decorate([
  __param(2, IWorkspaceContextService),
  __param(3, IConfigurationService)
], ResourceGlobMatcher);

// node_modules/vscode/vscode/src/vs/workbench/services/filesConfiguration/common/filesConfigurationService.js
init_async();
init_environment();
init_map();
var FilesConfigurationService_1;
var AutoSaveAfterShortDelayContext = new RawContextKey("autoSaveAfterShortDelayContext", false, true);
var IFilesConfigurationService = createDecorator("filesConfigurationService");
var _a2;
var FilesConfigurationService = (_a2 = class extends Disposable {
  constructor(contextKeyService, configurationService, contextService, environmentService, uriIdentityService, fileService) {
    var _a43, _b;
    super();
    this.configurationService = configurationService;
    this.contextService = contextService;
    this.environmentService = environmentService;
    this.uriIdentityService = uriIdentityService;
    this.fileService = fileService;
    this._onAutoSaveConfigurationChange = this._register(new Emitter());
    this.onAutoSaveConfigurationChange = this._onAutoSaveConfigurationChange.event;
    this._onFilesAssociationChange = this._register(new Emitter());
    this.onFilesAssociationChange = this._onFilesAssociationChange.event;
    this._onReadonlyConfigurationChange = this._register(new Emitter());
    this.onReadonlyChange = this._onReadonlyConfigurationChange.event;
    this.readonlyIncludeMatcher = this._register(new IdleValue(() => this.createReadonlyMatcher(FILES_READONLY_INCLUDE_CONFIG)));
    this.readonlyExcludeMatcher = this._register(new IdleValue(() => this.createReadonlyMatcher(FILES_READONLY_EXCLUDE_CONFIG)));
    this.sessionReadonlyOverrides = new ResourceMap((resource) => this.uriIdentityService.extUri.getComparisonKey(resource));
    this.autoSaveAfterShortDelayContext = AutoSaveAfterShortDelayContext.bindTo(contextKeyService);
    const configuration = configurationService.getValue();
    this.currentFilesAssociationConfig = (_a43 = configuration == null ? void 0 : configuration.files) == null ? void 0 : _a43.associations;
    this.currentHotExitConfig = ((_b = configuration == null ? void 0 : configuration.files) == null ? void 0 : _b.hotExit) || HotExitConfiguration.ON_EXIT;
    this.onFilesConfigurationChange(configuration);
    this.registerListeners();
  }
  createReadonlyMatcher(config) {
    const matcher = this._register(new ResourceGlobMatcher(
      (resource) => this.configurationService.getValue(config, { resource }),
      (event) => event.affectsConfiguration(config),
      this.contextService,
      this.configurationService
    ));
    this._register(matcher.onExpressionChange(() => this._onReadonlyConfigurationChange.fire()));
    return matcher;
  }
  isReadonly(resource, stat) {
    const provider = this.fileService.getProvider(resource.scheme);
    if (provider && hasReadonlyCapability(provider)) {
      return provider.readOnlyMessage ?? FilesConfigurationService_1.READONLY_MESSAGES.providerReadonly;
    }
    const sessionReadonlyOverride = this.sessionReadonlyOverrides.get(resource);
    if (typeof sessionReadonlyOverride === "boolean") {
      return sessionReadonlyOverride === true ? FilesConfigurationService_1.READONLY_MESSAGES.sessionReadonly : false;
    }
    if (this.uriIdentityService.extUri.isEqualOrParent(resource, this.environmentService.userRoamingDataHome) || this.uriIdentityService.extUri.isEqual(resource, this.contextService.getWorkspace().configuration ?? void 0)) {
      return false;
    }
    if (this.readonlyIncludeMatcher.value.matches(resource)) {
      return !this.readonlyExcludeMatcher.value.matches(resource) ? FilesConfigurationService_1.READONLY_MESSAGES.configuredReadonly : false;
    }
    if (this.configuredReadonlyFromPermissions && (stat == null ? void 0 : stat.locked)) {
      return FilesConfigurationService_1.READONLY_MESSAGES.fileLocked;
    }
    if (stat == null ? void 0 : stat.readonly) {
      return FilesConfigurationService_1.READONLY_MESSAGES.fileReadonly;
    }
    return false;
  }
  async updateReadonly(resource, readonly) {
    if (readonly === "toggle") {
      let stat = void 0;
      try {
        stat = await this.fileService.resolve(resource, { resolveMetadata: true });
      } catch (error) {
      }
      readonly = !this.isReadonly(resource, stat);
    }
    if (readonly === "reset") {
      this.sessionReadonlyOverrides.delete(resource);
    } else {
      this.sessionReadonlyOverrides.set(resource, readonly);
    }
    this._onReadonlyConfigurationChange.fire();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("files")) {
        this.onFilesConfigurationChange(this.configurationService.getValue());
      }
    }));
  }
  onFilesConfigurationChange(configuration) {
    var _a43, _b, _c, _d, _e;
    const autoSaveMode = ((_a43 = configuration == null ? void 0 : configuration.files) == null ? void 0 : _a43.autoSave) || FilesConfigurationService_1.DEFAULT_AUTO_SAVE_MODE;
    switch (autoSaveMode) {
      case AutoSaveConfiguration.AFTER_DELAY:
        this.configuredAutoSaveDelay = (_b = configuration == null ? void 0 : configuration.files) == null ? void 0 : _b.autoSaveDelay;
        this.configuredAutoSaveOnFocusChange = false;
        this.configuredAutoSaveOnWindowChange = false;
        break;
      case AutoSaveConfiguration.ON_FOCUS_CHANGE:
        this.configuredAutoSaveDelay = void 0;
        this.configuredAutoSaveOnFocusChange = true;
        this.configuredAutoSaveOnWindowChange = false;
        break;
      case AutoSaveConfiguration.ON_WINDOW_CHANGE:
        this.configuredAutoSaveDelay = void 0;
        this.configuredAutoSaveOnFocusChange = false;
        this.configuredAutoSaveOnWindowChange = true;
        break;
      default:
        this.configuredAutoSaveDelay = void 0;
        this.configuredAutoSaveOnFocusChange = false;
        this.configuredAutoSaveOnWindowChange = false;
        break;
    }
    this.autoSaveAfterShortDelayContext.set(this.getAutoSaveMode() === 1);
    this._onAutoSaveConfigurationChange.fire(this.getAutoSaveConfiguration());
    const filesAssociation = (_c = configuration == null ? void 0 : configuration.files) == null ? void 0 : _c.associations;
    if (!equals(this.currentFilesAssociationConfig, filesAssociation)) {
      this.currentFilesAssociationConfig = filesAssociation;
      this._onFilesAssociationChange.fire();
    }
    const hotExitMode = (_d = configuration == null ? void 0 : configuration.files) == null ? void 0 : _d.hotExit;
    if (hotExitMode === HotExitConfiguration.OFF || hotExitMode === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {
      this.currentHotExitConfig = hotExitMode;
    } else {
      this.currentHotExitConfig = HotExitConfiguration.ON_EXIT;
    }
    const readonlyFromPermissions = Boolean((_e = configuration == null ? void 0 : configuration.files) == null ? void 0 : _e.readonlyFromPermissions);
    if (readonlyFromPermissions !== Boolean(this.configuredReadonlyFromPermissions)) {
      this.configuredReadonlyFromPermissions = readonlyFromPermissions;
      this._onReadonlyConfigurationChange.fire();
    }
  }
  getAutoSaveMode() {
    if (this.configuredAutoSaveOnFocusChange) {
      return 3;
    }
    if (this.configuredAutoSaveOnWindowChange) {
      return 4;
    }
    if (typeof this.configuredAutoSaveDelay === "number" && this.configuredAutoSaveDelay >= 0) {
      return this.configuredAutoSaveDelay <= 1e3 ? 1 : 2;
    }
    return 0;
  }
  getAutoSaveConfiguration() {
    return {
      autoSaveDelay: typeof this.configuredAutoSaveDelay === "number" && this.configuredAutoSaveDelay >= 0 ? this.configuredAutoSaveDelay : void 0,
      autoSaveFocusChange: !!this.configuredAutoSaveOnFocusChange,
      autoSaveApplicationChange: !!this.configuredAutoSaveOnWindowChange
    };
  }
  async toggleAutoSave() {
    const currentSetting = this.configurationService.getValue("files.autoSave");
    let newAutoSaveValue;
    if ([AutoSaveConfiguration.AFTER_DELAY, AutoSaveConfiguration.ON_FOCUS_CHANGE, AutoSaveConfiguration.ON_WINDOW_CHANGE].some((setting) => setting === currentSetting)) {
      newAutoSaveValue = AutoSaveConfiguration.OFF;
    } else {
      newAutoSaveValue = AutoSaveConfiguration.AFTER_DELAY;
    }
    return this.configurationService.updateValue("files.autoSave", newAutoSaveValue);
  }
  get isHotExitEnabled() {
    if (this.contextService.getWorkspace().transient) {
      return false;
    }
    return this.currentHotExitConfig !== HotExitConfiguration.OFF;
  }
  get hotExitConfiguration() {
    return this.currentHotExitConfig;
  }
  preventSaveConflicts(resource, language) {
    return this.configurationService.getValue("files.saveConflictResolution", { resource, overrideIdentifier: language }) !== "overwriteFileOnDisk";
  }
}, FilesConfigurationService_1 = _a2, _a2.DEFAULT_AUTO_SAVE_MODE = isWeb ? AutoSaveConfiguration.AFTER_DELAY : AutoSaveConfiguration.OFF, _a2.READONLY_MESSAGES = {
  providerReadonly: { value: localize(
    "providerReadonly",
    "Editor is read-only because the file system of the file is read-only."
  ), isTrusted: true },
  sessionReadonly: { value: localize(
    { key: "sessionReadonly", comment: ['Please do not translate the word "command", it is part of our internal syntax which must not change', '{Locked="](command:{0})"}'] },
    "Editor is read-only because the file was set read-only in this session. [Click here](command:{0}) to set writeable.",
    "workbench.action.files.setActiveEditorWriteableInSession"
  ), isTrusted: true },
  configuredReadonly: { value: localize(
    { key: "configuredReadonly", comment: ['Please do not translate the word "command", it is part of our internal syntax which must not change', '{Locked="](command:{0})"}'] },
    "Editor is read-only because the file was set read-only via settings. [Click here](command:{0}) to configure.",
    `workbench.action.openSettings?${encodeURIComponent('["files.readonly"]')}`
  ), isTrusted: true },
  fileLocked: { value: localize(
    { key: "fileLocked", comment: ['Please do not translate the word "command", it is part of our internal syntax which must not change', '{Locked="](command:{0})"}'] },
    "Editor is read-only because of file permissions. [Click here](command:{0}) to set writeable anyway.",
    "workbench.action.files.setActiveEditorWriteableInSession"
  ), isTrusted: true },
  fileReadonly: { value: localize("fileReadonly", "Editor is read-only because the file is read-only."), isTrusted: true }
}, _a2);
FilesConfigurationService = FilesConfigurationService_1 = __decorate([
  __param(0, IContextKeyService),
  __param(1, IConfigurationService),
  __param(2, IWorkspaceContextService),
  __param(3, IEnvironmentService),
  __param(4, IUriIdentityService),
  __param(5, IFileService)
], FilesConfigurationService);

// node_modules/vscode/vscode/src/vs/workbench/services/untitled/common/untitledTextEditorService.js
init_tslib_es6();
init_uri();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/services/untitled/common/untitledTextEditorModel.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/common/editor/textEditorModel.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/common/editor/editorModel.js
init_event();
init_lifecycle();
var EditorModel = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onWillDispose = this._register(new Emitter());
    this.onWillDispose = this._onWillDispose.event;
    this.disposed = false;
    this.resolved = false;
  }
  async resolve() {
    this.resolved = true;
  }
  isResolved() {
    return this.resolved;
  }
  isDisposed() {
    return this.disposed;
  }
  dispose() {
    this.disposed = true;
    this._onWillDispose.fire();
    super.dispose();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/common/editor/textEditorModel.js
init_language();
init_model2();
init_lifecycle();
init_modesRegistry();
init_async();
init_nls();
var BaseTextEditorModel_1;
var _a3;
var BaseTextEditorModel = (_a3 = class extends EditorModel {
  constructor(modelService, languageService, languageDetectionService, accessibilityService, textEditorModelHandle) {
    super();
    this.modelService = modelService;
    this.languageService = languageService;
    this.languageDetectionService = languageDetectionService;
    this.accessibilityService = accessibilityService;
    this.textEditorModelHandle = void 0;
    this.modelDisposeListener = this._register(new MutableDisposable());
    this.autoDetectLanguageThrottler = this._register(new ThrottledDelayer(BaseTextEditorModel_1.AUTO_DETECT_LANGUAGE_THROTTLE_DELAY));
    this._hasLanguageSetExplicitly = false;
    if (textEditorModelHandle) {
      this.handleExistingModel(textEditorModelHandle);
    }
  }
  handleExistingModel(textEditorModelHandle) {
    const model = this.modelService.getModel(textEditorModelHandle);
    if (!model) {
      throw new Error(`Document with resource ${textEditorModelHandle.toString(true)} does not exist`);
    }
    this.textEditorModelHandle = textEditorModelHandle;
    this.registerModelDisposeListener(model);
  }
  registerModelDisposeListener(model) {
    this.modelDisposeListener.value = model.onWillDispose(() => {
      this.textEditorModelHandle = void 0;
      this.dispose();
    });
  }
  get textEditorModel() {
    return this.textEditorModelHandle ? this.modelService.getModel(this.textEditorModelHandle) : null;
  }
  isReadonly() {
    return true;
  }
  get hasLanguageSetExplicitly() {
    return this._hasLanguageSetExplicitly;
  }
  setLanguageId(languageId, source) {
    this._hasLanguageSetExplicitly = true;
    this.setLanguageIdInternal(languageId, source);
  }
  setLanguageIdInternal(languageId, source) {
    if (!this.isResolved()) {
      return;
    }
    if (!languageId || languageId === this.textEditorModel.getLanguageId()) {
      return;
    }
    this.textEditorModel.setLanguage(this.languageService.createById(languageId), source);
  }
  installModelListeners(model) {
    const disposable = this._register(model.onDidChangeLanguage((e) => {
      if (e.source === LanguageDetectionLanguageEventSource) {
        return;
      }
      this._hasLanguageSetExplicitly = true;
      disposable.dispose();
    }));
  }
  getLanguageId() {
    var _a43;
    return (_a43 = this.textEditorModel) == null ? void 0 : _a43.getLanguageId();
  }
  autoDetectLanguage() {
    return this.autoDetectLanguageThrottler.trigger(() => this.doAutoDetectLanguage());
  }
  async doAutoDetectLanguage() {
    if (this.hasLanguageSetExplicitly || !this.textEditorModelHandle || !this.languageDetectionService.isEnabledForLanguage(this.getLanguageId() ?? PLAINTEXT_LANGUAGE_ID)) {
      return;
    }
    const lang = await this.languageDetectionService.detectLanguage(this.textEditorModelHandle);
    const prevLang = this.getLanguageId();
    if (lang && lang !== prevLang && !this.isDisposed()) {
      this.setLanguageIdInternal(lang, LanguageDetectionLanguageEventSource);
      const languageName = this.languageService.getLanguageName(lang);
      this.accessibilityService.alert(localize(
        "languageAutoDetected",
        "Language {0} was automatically detected and set as the language mode.",
        languageName ?? lang
      ));
    }
  }
  createTextEditorModel(value, resource, preferredLanguageId) {
    const firstLineText = this.getFirstLineText(value);
    const languageSelection = this.getOrCreateLanguage(resource, this.languageService, preferredLanguageId, firstLineText);
    return this.doCreateTextEditorModel(value, languageSelection, resource);
  }
  doCreateTextEditorModel(value, languageSelection, resource) {
    let model = resource && this.modelService.getModel(resource);
    if (!model) {
      model = this.modelService.createModel(value, languageSelection, resource);
      this.createdEditorModel = true;
      this.registerModelDisposeListener(model);
    } else {
      this.updateTextEditorModel(value, languageSelection.languageId);
    }
    this.textEditorModelHandle = model.uri;
    return model;
  }
  getFirstLineText(value) {
    const textBufferFactory = value;
    if (typeof textBufferFactory.getFirstLineText === "function") {
      return textBufferFactory.getFirstLineText(1e3);
    }
    const textSnapshot = value;
    return textSnapshot.getLineContent(1).substr(0, 1e3);
  }
  getOrCreateLanguage(resource, languageService, preferredLanguage, firstLineText) {
    if (!preferredLanguage || preferredLanguage === PLAINTEXT_LANGUAGE_ID) {
      return languageService.createByFilepathOrFirstLine(resource ?? null, firstLineText);
    }
    return languageService.createById(preferredLanguage);
  }
  updateTextEditorModel(newValue, preferredLanguageId) {
    if (!this.isResolved()) {
      return;
    }
    if (newValue) {
      this.modelService.updateModel(this.textEditorModel, newValue);
    }
    if (preferredLanguageId && preferredLanguageId !== PLAINTEXT_LANGUAGE_ID && this.textEditorModel.getLanguageId() !== preferredLanguageId) {
      this.textEditorModel.setLanguage(this.languageService.createById(preferredLanguageId));
    }
  }
  createSnapshot() {
    if (!this.textEditorModel) {
      return null;
    }
    return this.textEditorModel.createSnapshot(true);
  }
  isResolved() {
    return !!this.textEditorModelHandle;
  }
  dispose() {
    this.modelDisposeListener.dispose();
    if (this.textEditorModelHandle && this.createdEditorModel) {
      this.modelService.destroyModel(this.textEditorModelHandle);
    }
    this.textEditorModelHandle = void 0;
    this.createdEditorModel = false;
    super.dispose();
  }
}, BaseTextEditorModel_1 = _a3, _a3.AUTO_DETECT_LANGUAGE_THROTTLE_DELAY = 600, _a3);
BaseTextEditorModel = BaseTextEditorModel_1 = __decorate([
  __param(0, IModelService),
  __param(1, ILanguageService),
  __param(2, ILanguageDetectionService),
  __param(3, IAccessibilityService)
], BaseTextEditorModel);

// node_modules/vscode/vscode/src/vs/workbench/services/untitled/common/untitledTextEditorModel.js
init_language();
init_model2();
init_event();
init_textModel();

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/workingCopy.js
var NO_TYPE_ID = "";

// node_modules/vscode/vscode/src/vs/workbench/services/untitled/common/untitledTextEditorModel.js
init_types();
init_wordHelper();
init_strings();

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/encoding.js
init_stream();
init_buffer();
init_cancellation();
var UTF8 = "utf8";
var UTF8_with_bom = "utf8bom";
var UTF16be = "utf16be";
var UTF16le = "utf16le";
var UTF16be_BOM = [254, 255];
var UTF16le_BOM = [255, 254];
var UTF8_BOM = [239, 187, 191];
var ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512;
var NO_ENCODING_GUESS_MIN_BYTES = 512;
var AUTO_ENCODING_GUESS_MIN_BYTES = 512 * 8;
var AUTO_ENCODING_GUESS_MAX_BYTES = 512 * 128;
var DecodeStreamError = class extends Error {
  constructor(message, decodeStreamErrorKind) {
    super(message);
    this.decodeStreamErrorKind = decodeStreamErrorKind;
  }
};
var DecoderStream = class _DecoderStream {
  static async create(encoding) {
    let decoder2 = void 0;
    if (encoding !== UTF8) {
      const iconv = await import("./iconv-RPG6PRHC.js").then((module) => module.default ?? module);
      decoder2 = iconv.getDecoder(toNodeEncoding(encoding));
    } else {
      const utf8TextDecoder = new TextDecoder();
      decoder2 = {
        write(buffer) {
          return utf8TextDecoder.decode(buffer, {
            stream: true
          });
        },
        end() {
          return utf8TextDecoder.decode();
        }
      };
    }
    return new _DecoderStream(decoder2);
  }
  constructor(iconvLiteDecoder) {
    this.iconvLiteDecoder = iconvLiteDecoder;
  }
  write(buffer) {
    return this.iconvLiteDecoder.write(buffer);
  }
  end() {
    return this.iconvLiteDecoder.end();
  }
};
function toDecodeStream(source, options) {
  const minBytesRequiredForDetection = options.minBytesRequiredForDetection ?? options.guessEncoding ? AUTO_ENCODING_GUESS_MIN_BYTES : NO_ENCODING_GUESS_MIN_BYTES;
  return new Promise((resolve, reject) => {
    const target = newWriteableStream((strings) => strings.join(""));
    const bufferedChunks = [];
    let bytesBuffered = 0;
    let decoder2 = void 0;
    const cts = new CancellationTokenSource();
    const createDecoder = async () => {
      try {
        const detected = await detectEncodingFromBuffer({
          buffer: VSBuffer.concat(bufferedChunks),
          bytesRead: bytesBuffered
        }, options.guessEncoding);
        if (detected.seemsBinary && options.acceptTextOnly) {
          throw new DecodeStreamError("Stream is binary but only text is accepted for decoding", 1);
        }
        detected.encoding = await options.overwriteEncoding(detected.encoding);
        decoder2 = await DecoderStream.create(detected.encoding);
        const decoded = decoder2.write(VSBuffer.concat(bufferedChunks).buffer);
        target.write(decoded);
        bufferedChunks.length = 0;
        bytesBuffered = 0;
        resolve({
          stream: target,
          detected
        });
      } catch (error) {
        cts.cancel();
        target.destroy();
        reject(error);
      }
    };
    listenStream(source, {
      onData: async (chunk) => {
        if (decoder2) {
          target.write(decoder2.write(chunk.buffer));
        } else {
          bufferedChunks.push(chunk);
          bytesBuffered += chunk.byteLength;
          if (bytesBuffered >= minBytesRequiredForDetection) {
            source.pause();
            await createDecoder();
            setTimeout(() => source.resume());
          }
        }
      },
      onError: (error) => target.error(error),
      onEnd: async () => {
        if (!decoder2) {
          await createDecoder();
        }
        target.end(decoder2 == null ? void 0 : decoder2.end());
      }
    }, cts.token);
  });
}
async function toEncodeReadable(readable, encoding, options) {
  const iconv = await import("./iconv-RPG6PRHC.js").then((module) => module.default ?? module);
  const encoder2 = iconv.getEncoder(toNodeEncoding(encoding), options);
  let bytesWritten = false;
  let done = false;
  return {
    read() {
      if (done) {
        return null;
      }
      const chunk = readable.read();
      if (typeof chunk !== "string") {
        done = true;
        if (!bytesWritten && (options == null ? void 0 : options.addBOM)) {
          switch (encoding) {
            case UTF8:
            case UTF8_with_bom:
              return VSBuffer.wrap(Uint8Array.from(UTF8_BOM));
            case UTF16be:
              return VSBuffer.wrap(Uint8Array.from(UTF16be_BOM));
            case UTF16le:
              return VSBuffer.wrap(Uint8Array.from(UTF16le_BOM));
          }
        }
        const leftovers = encoder2.end();
        if (leftovers && leftovers.length > 0) {
          bytesWritten = true;
          return VSBuffer.wrap(leftovers);
        }
        return null;
      }
      bytesWritten = true;
      return VSBuffer.wrap(encoder2.write(chunk));
    }
  };
}
async function encodingExists(encoding) {
  const iconv = await import("./iconv-RPG6PRHC.js").then((module) => module.default ?? module);
  return iconv.encodingExists(toNodeEncoding(encoding));
}
function toNodeEncoding(enc) {
  if (enc === UTF8_with_bom || enc === null) {
    return UTF8;
  }
  return enc;
}
function detectEncodingByBOMFromBuffer(buffer, bytesRead) {
  if (!buffer || bytesRead < UTF16be_BOM.length) {
    return null;
  }
  const b0 = buffer.readUInt8(0);
  const b1 = buffer.readUInt8(1);
  if (b0 === UTF16be_BOM[0] && b1 === UTF16be_BOM[1]) {
    return UTF16be;
  }
  if (b0 === UTF16le_BOM[0] && b1 === UTF16le_BOM[1]) {
    return UTF16le;
  }
  if (bytesRead < UTF8_BOM.length) {
    return null;
  }
  const b2 = buffer.readUInt8(2);
  if (b0 === UTF8_BOM[0] && b1 === UTF8_BOM[1] && b2 === UTF8_BOM[2]) {
    return UTF8_with_bom;
  }
  return null;
}
var IGNORE_ENCODINGS = ["ascii", "utf-16", "utf-32"];
async function guessEncodingByBuffer(buffer) {
  const jschardet = await import("./jschardet-QHZZ2JRU.js").then((module) => module.default ?? module);
  const limitedBuffer = buffer.slice(0, AUTO_ENCODING_GUESS_MAX_BYTES);
  const binaryString = encodeLatin1(limitedBuffer.buffer);
  const guessed = jschardet.detect(binaryString);
  if (!guessed || !guessed.encoding) {
    return null;
  }
  const enc = guessed.encoding.toLowerCase();
  if (0 <= IGNORE_ENCODINGS.indexOf(enc)) {
    return null;
  }
  return toIconvLiteEncoding(guessed.encoding);
}
var JSCHARDET_TO_ICONV_ENCODINGS = {
  "ibm866": "cp866",
  "big5": "cp950"
};
function toIconvLiteEncoding(encodingName) {
  const normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
  const mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];
  return mapped || normalizedEncodingName;
}
function encodeLatin1(buffer) {
  let result = "";
  for (let i = 0; i < buffer.length; i++) {
    result += String.fromCharCode(buffer[i]);
  }
  return result;
}
function detectEncodingFromBuffer({ buffer, bytesRead }, autoGuessEncoding) {
  let encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);
  let seemsBinary = false;
  if (encoding !== UTF16be && encoding !== UTF16le && buffer) {
    let couldBeUTF16LE = true;
    let couldBeUTF16BE = true;
    let containsZeroByte = false;
    for (let i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {
      const isEndian = i % 2 === 1;
      const isZeroByte = buffer.readUInt8(i) === 0;
      if (isZeroByte) {
        containsZeroByte = true;
      }
      if (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {
        couldBeUTF16LE = false;
      }
      if (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {
        couldBeUTF16BE = false;
      }
      if (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {
        break;
      }
    }
    if (containsZeroByte) {
      if (couldBeUTF16LE) {
        encoding = UTF16le;
      } else if (couldBeUTF16BE) {
        encoding = UTF16be;
      } else {
        seemsBinary = true;
      }
    }
  }
  if (autoGuessEncoding && !seemsBinary && !encoding && buffer) {
    return guessEncodingByBuffer(buffer.slice(0, bytesRead)).then((guessedEncoding) => {
      return {
        seemsBinary: false,
        encoding: guessedEncoding
      };
    });
  }
  return { seemsBinary, encoding };
}
var SUPPORTED_ENCODINGS = {
  utf8: {
    labelLong: "UTF-8",
    labelShort: "UTF-8",
    order: 1,
    alias: "utf8bom"
  },
  utf8bom: {
    labelLong: "UTF-8 with BOM",
    labelShort: "UTF-8 with BOM",
    encodeOnly: true,
    order: 2,
    alias: "utf8"
  },
  utf16le: {
    labelLong: "UTF-16 LE",
    labelShort: "UTF-16 LE",
    order: 3
  },
  utf16be: {
    labelLong: "UTF-16 BE",
    labelShort: "UTF-16 BE",
    order: 4
  },
  windows1252: {
    labelLong: "Western (Windows 1252)",
    labelShort: "Windows 1252",
    order: 5
  },
  iso88591: {
    labelLong: "Western (ISO 8859-1)",
    labelShort: "ISO 8859-1",
    order: 6
  },
  iso88593: {
    labelLong: "Western (ISO 8859-3)",
    labelShort: "ISO 8859-3",
    order: 7
  },
  iso885915: {
    labelLong: "Western (ISO 8859-15)",
    labelShort: "ISO 8859-15",
    order: 8
  },
  macroman: {
    labelLong: "Western (Mac Roman)",
    labelShort: "Mac Roman",
    order: 9
  },
  cp437: {
    labelLong: "DOS (CP 437)",
    labelShort: "CP437",
    order: 10
  },
  windows1256: {
    labelLong: "Arabic (Windows 1256)",
    labelShort: "Windows 1256",
    order: 11
  },
  iso88596: {
    labelLong: "Arabic (ISO 8859-6)",
    labelShort: "ISO 8859-6",
    order: 12
  },
  windows1257: {
    labelLong: "Baltic (Windows 1257)",
    labelShort: "Windows 1257",
    order: 13
  },
  iso88594: {
    labelLong: "Baltic (ISO 8859-4)",
    labelShort: "ISO 8859-4",
    order: 14
  },
  iso885914: {
    labelLong: "Celtic (ISO 8859-14)",
    labelShort: "ISO 8859-14",
    order: 15
  },
  windows1250: {
    labelLong: "Central European (Windows 1250)",
    labelShort: "Windows 1250",
    order: 16
  },
  iso88592: {
    labelLong: "Central European (ISO 8859-2)",
    labelShort: "ISO 8859-2",
    order: 17
  },
  cp852: {
    labelLong: "Central European (CP 852)",
    labelShort: "CP 852",
    order: 18
  },
  windows1251: {
    labelLong: "Cyrillic (Windows 1251)",
    labelShort: "Windows 1251",
    order: 19
  },
  cp866: {
    labelLong: "Cyrillic (CP 866)",
    labelShort: "CP 866",
    order: 20
  },
  iso88595: {
    labelLong: "Cyrillic (ISO 8859-5)",
    labelShort: "ISO 8859-5",
    order: 21
  },
  koi8r: {
    labelLong: "Cyrillic (KOI8-R)",
    labelShort: "KOI8-R",
    order: 22
  },
  koi8u: {
    labelLong: "Cyrillic (KOI8-U)",
    labelShort: "KOI8-U",
    order: 23
  },
  iso885913: {
    labelLong: "Estonian (ISO 8859-13)",
    labelShort: "ISO 8859-13",
    order: 24
  },
  windows1253: {
    labelLong: "Greek (Windows 1253)",
    labelShort: "Windows 1253",
    order: 25
  },
  iso88597: {
    labelLong: "Greek (ISO 8859-7)",
    labelShort: "ISO 8859-7",
    order: 26
  },
  windows1255: {
    labelLong: "Hebrew (Windows 1255)",
    labelShort: "Windows 1255",
    order: 27
  },
  iso88598: {
    labelLong: "Hebrew (ISO 8859-8)",
    labelShort: "ISO 8859-8",
    order: 28
  },
  iso885910: {
    labelLong: "Nordic (ISO 8859-10)",
    labelShort: "ISO 8859-10",
    order: 29
  },
  iso885916: {
    labelLong: "Romanian (ISO 8859-16)",
    labelShort: "ISO 8859-16",
    order: 30
  },
  windows1254: {
    labelLong: "Turkish (Windows 1254)",
    labelShort: "Windows 1254",
    order: 31
  },
  iso88599: {
    labelLong: "Turkish (ISO 8859-9)",
    labelShort: "ISO 8859-9",
    order: 32
  },
  windows1258: {
    labelLong: "Vietnamese (Windows 1258)",
    labelShort: "Windows 1258",
    order: 33
  },
  gbk: {
    labelLong: "Simplified Chinese (GBK)",
    labelShort: "GBK",
    order: 34
  },
  gb18030: {
    labelLong: "Simplified Chinese (GB18030)",
    labelShort: "GB18030",
    order: 35
  },
  cp950: {
    labelLong: "Traditional Chinese (Big5)",
    labelShort: "Big5",
    order: 36
  },
  big5hkscs: {
    labelLong: "Traditional Chinese (Big5-HKSCS)",
    labelShort: "Big5-HKSCS",
    order: 37
  },
  shiftjis: {
    labelLong: "Japanese (Shift JIS)",
    labelShort: "Shift JIS",
    order: 38
  },
  eucjp: {
    labelLong: "Japanese (EUC-JP)",
    labelShort: "EUC-JP",
    order: 39
  },
  euckr: {
    labelLong: "Korean (EUC-KR)",
    labelShort: "EUC-KR",
    order: 40
  },
  windows874: {
    labelLong: "Thai (Windows 874)",
    labelShort: "Windows 874",
    order: 41
  },
  iso885911: {
    labelLong: "Latin/Thai (ISO 8859-11)",
    labelShort: "ISO 8859-11",
    order: 42
  },
  koi8ru: {
    labelLong: "Cyrillic (KOI8-RU)",
    labelShort: "KOI8-RU",
    order: 43
  },
  koi8t: {
    labelLong: "Tajik (KOI8-T)",
    labelShort: "KOI8-T",
    order: 44
  },
  gb2312: {
    labelLong: "Simplified Chinese (GB 2312)",
    labelShort: "GB 2312",
    order: 45
  },
  cp865: {
    labelLong: "Nordic DOS (CP 865)",
    labelShort: "CP 865",
    order: 46
  },
  cp850: {
    labelLong: "Western European DOS (CP 850)",
    labelShort: "CP 850",
    order: 47
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/untitled/common/untitledTextEditorModel.js
init_buffer();
var UntitledTextEditorModel_1;
var _a4;
var UntitledTextEditorModel = (_a4 = class extends BaseTextEditorModel {
  get name() {
    if (this.configuredLabelFormat === "content" && !this.hasAssociatedFilePath && this.cachedModelFirstLineWords) {
      return this.cachedModelFirstLineWords;
    }
    return this.labelService.getUriBasenameLabel(this.resource);
  }
  constructor(resource, hasAssociatedFilePath, initialValue, preferredLanguageId, preferredEncoding, languageService, modelService, workingCopyBackupService, textResourceConfigurationService, workingCopyService, textFileService, labelService, editorService, languageDetectionService, accessibilityService) {
    super(modelService, languageService, languageDetectionService, accessibilityService);
    this.resource = resource;
    this.hasAssociatedFilePath = hasAssociatedFilePath;
    this.initialValue = initialValue;
    this.preferredLanguageId = preferredLanguageId;
    this.preferredEncoding = preferredEncoding;
    this.workingCopyBackupService = workingCopyBackupService;
    this.textResourceConfigurationService = textResourceConfigurationService;
    this.workingCopyService = workingCopyService;
    this.textFileService = textFileService;
    this.labelService = labelService;
    this.editorService = editorService;
    this._onDidChangeContent = this._register(new Emitter());
    this.onDidChangeContent = this._onDidChangeContent.event;
    this._onDidChangeName = this._register(new Emitter());
    this.onDidChangeName = this._onDidChangeName.event;
    this._onDidChangeDirty = this._register(new Emitter());
    this.onDidChangeDirty = this._onDidChangeDirty.event;
    this._onDidChangeEncoding = this._register(new Emitter());
    this.onDidChangeEncoding = this._onDidChangeEncoding.event;
    this._onDidSave = this._register(new Emitter());
    this.onDidSave = this._onDidSave.event;
    this._onDidRevert = this._register(new Emitter());
    this.onDidRevert = this._onDidRevert.event;
    this.typeId = NO_TYPE_ID;
    this.capabilities = 2;
    this.configuredLabelFormat = "content";
    this.cachedModelFirstLineWords = void 0;
    this.dirty = this.hasAssociatedFilePath || !!this.initialValue;
    this._register(this.workingCopyService.registerWorkingCopy(this));
    if (preferredLanguageId) {
      this.setLanguageId(preferredLanguageId);
    }
    this.onConfigurationChange(void 0, false);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.textResourceConfigurationService.onDidChangeConfiguration((e) => this.onConfigurationChange(e, true)));
  }
  onConfigurationChange(e, fromEvent) {
    if (!e || e.affectsConfiguration(this.resource, "files.encoding")) {
      const configuredEncoding = this.textResourceConfigurationService.getValue(this.resource, "files.encoding");
      if (this.configuredEncoding !== configuredEncoding && typeof configuredEncoding === "string") {
        this.configuredEncoding = configuredEncoding;
        if (fromEvent && !this.preferredEncoding) {
          this._onDidChangeEncoding.fire();
        }
      }
    }
    if (!e || e.affectsConfiguration(this.resource, "workbench.editor.untitled.labelFormat")) {
      const configuredLabelFormat = this.textResourceConfigurationService.getValue(this.resource, "workbench.editor.untitled.labelFormat");
      if (this.configuredLabelFormat !== configuredLabelFormat && (configuredLabelFormat === "content" || configuredLabelFormat === "name")) {
        this.configuredLabelFormat = configuredLabelFormat;
        if (fromEvent) {
          this._onDidChangeName.fire();
        }
      }
    }
  }
  setLanguageId(languageId, source) {
    const actualLanguage = languageId === UntitledTextEditorModel_1.ACTIVE_EDITOR_LANGUAGE_ID ? this.editorService.activeTextEditorLanguageId : languageId;
    this.preferredLanguageId = actualLanguage;
    if (actualLanguage) {
      super.setLanguageId(actualLanguage, source);
    }
  }
  getLanguageId() {
    if (this.textEditorModel) {
      return this.textEditorModel.getLanguageId();
    }
    return this.preferredLanguageId;
  }
  getEncoding() {
    return this.preferredEncoding || this.configuredEncoding;
  }
  async setEncoding(encoding) {
    const oldEncoding = this.getEncoding();
    this.preferredEncoding = encoding;
    if (oldEncoding !== this.preferredEncoding) {
      this._onDidChangeEncoding.fire();
    }
  }
  isDirty() {
    return this.dirty;
  }
  isModified() {
    return this.isDirty();
  }
  setDirty(dirty) {
    if (this.dirty === dirty) {
      return;
    }
    this.dirty = dirty;
    this._onDidChangeDirty.fire();
  }
  async save(options) {
    const target = await this.textFileService.save(this.resource, options);
    if (target) {
      this._onDidSave.fire({ reason: options == null ? void 0 : options.reason, source: options == null ? void 0 : options.source });
    }
    return !!target;
  }
  async revert() {
    this.setDirty(false);
    this._onDidRevert.fire();
    this.dispose();
  }
  async backup(token) {
    let content = void 0;
    if (this.isResolved()) {
      content = await this.textFileService.getEncodedReadable(this.resource, this.createSnapshot() ?? void 0, { encoding: UTF8 });
    } else if (typeof this.initialValue === "string") {
      content = bufferToReadable(VSBuffer.fromString(this.initialValue));
    }
    return { content };
  }
  async resolve() {
    let createdUntitledModel = false;
    let hasBackup = false;
    if (!this.textEditorModel) {
      let untitledContents;
      const backup = await this.workingCopyBackupService.resolve(this);
      if (backup) {
        untitledContents = backup.value;
        hasBackup = true;
      } else {
        untitledContents = bufferToStream(VSBuffer.fromString(this.initialValue || ""));
      }
      const untitledContentsFactory = await createTextBufferFactoryFromStream(await this.textFileService.getDecodedStream(this.resource, untitledContents, { encoding: UTF8 }));
      this.createTextEditorModel(untitledContentsFactory, this.resource, this.preferredLanguageId);
      createdUntitledModel = true;
    } else {
      this.updateTextEditorModel(void 0, this.preferredLanguageId);
    }
    const textEditorModel = assertIsDefined(this.textEditorModel);
    this.installModelListeners(textEditorModel);
    if (createdUntitledModel) {
      if (hasBackup || this.initialValue) {
        this.updateNameFromFirstLine(textEditorModel);
      }
      this.setDirty(this.hasAssociatedFilePath || !!hasBackup || !!this.initialValue);
      if (hasBackup || this.initialValue) {
        this._onDidChangeContent.fire();
      }
    }
    return super.resolve();
  }
  installModelListeners(model) {
    this._register(model.onDidChangeContent((e) => this.onModelContentChanged(model, e)));
    this._register(model.onDidChangeLanguage(() => this.onConfigurationChange(void 0, true)));
    super.installModelListeners(model);
  }
  onModelContentChanged(textEditorModel, e) {
    if (!this.hasAssociatedFilePath && textEditorModel.getLineCount() === 1 && textEditorModel.getLineContent(1) === "") {
      this.setDirty(false);
    } else {
      this.setDirty(true);
    }
    if (e.changes.some(
      (change) => (change.range.startLineNumber === 1 || change.range.endLineNumber === 1) && change.range.startColumn <= UntitledTextEditorModel_1.FIRST_LINE_NAME_CANDIDATE_MAX_LENGTH
    )) {
      this.updateNameFromFirstLine(textEditorModel);
    }
    this._onDidChangeContent.fire();
    this.autoDetectLanguage();
  }
  updateNameFromFirstLine(textEditorModel) {
    if (this.hasAssociatedFilePath) {
      return;
    }
    let modelFirstWordsCandidate = void 0;
    let firstLineText = textEditorModel.getValueInRange({
      startLineNumber: 1,
      endLineNumber: 1,
      startColumn: 1,
      endColumn: UntitledTextEditorModel_1.FIRST_LINE_NAME_CANDIDATE_MAX_LENGTH + 1
    }).trim().replace(/\s+/g, " ").replace(/\u202E/g, "");
    firstLineText = firstLineText.substr(0, getCharContainingOffset(
      firstLineText,
      UntitledTextEditorModel_1.FIRST_LINE_NAME_MAX_LENGTH
    )[0]);
    if (firstLineText && ensureValidWordDefinition().exec(firstLineText)) {
      modelFirstWordsCandidate = firstLineText;
    }
    if (modelFirstWordsCandidate !== this.cachedModelFirstLineWords) {
      this.cachedModelFirstLineWords = modelFirstWordsCandidate;
      this._onDidChangeName.fire();
    }
  }
  isReadonly() {
    return false;
  }
}, UntitledTextEditorModel_1 = _a4, _a4.FIRST_LINE_NAME_MAX_LENGTH = 40, _a4.FIRST_LINE_NAME_CANDIDATE_MAX_LENGTH = UntitledTextEditorModel_1.FIRST_LINE_NAME_MAX_LENGTH * 10, _a4.ACTIVE_EDITOR_LANGUAGE_ID = "${activeEditorLanguage}", _a4);
UntitledTextEditorModel = UntitledTextEditorModel_1 = __decorate([
  __param(5, ILanguageService),
  __param(6, IModelService),
  __param(7, IWorkingCopyBackupService),
  __param(8, ITextResourceConfigurationService),
  __param(9, IWorkingCopyService),
  __param(10, ITextFileService),
  __param(11, ILabelService),
  __param(12, IEditorService),
  __param(13, ILanguageDetectionService),
  __param(14, IAccessibilityService)
], UntitledTextEditorModel);

// node_modules/vscode/vscode/src/vs/workbench/services/untitled/common/untitledTextEditorService.js
init_configuration();
init_event();
init_map();
init_network();
init_lifecycle();
var UntitledTextEditorService_1;
var IUntitledTextEditorService = createDecorator("untitledTextEditorService");
var _a5;
var UntitledTextEditorService = (_a5 = class extends Disposable {
  constructor(instantiationService, configurationService) {
    super();
    this.instantiationService = instantiationService;
    this.configurationService = configurationService;
    this._onDidChangeDirty = this._register(new Emitter());
    this.onDidChangeDirty = this._onDidChangeDirty.event;
    this._onDidChangeEncoding = this._register(new Emitter());
    this.onDidChangeEncoding = this._onDidChangeEncoding.event;
    this._onWillDispose = this._register(new Emitter());
    this.onWillDispose = this._onWillDispose.event;
    this._onDidChangeLabel = this._register(new Emitter());
    this.onDidChangeLabel = this._onDidChangeLabel.event;
    this.mapResourceToModel = new ResourceMap();
  }
  get(resource) {
    return this.mapResourceToModel.get(resource);
  }
  getValue(resource) {
    var _a43, _b;
    return (_b = (_a43 = this.get(resource)) == null ? void 0 : _a43.textEditorModel) == null ? void 0 : _b.getValue();
  }
  async resolve(options) {
    const model = this.doCreateOrGet(options);
    await model.resolve();
    return model;
  }
  create(options) {
    return this.doCreateOrGet(options);
  }
  doCreateOrGet(options = /* @__PURE__ */ Object.create(null)) {
    const massagedOptions = this.massageOptions(options);
    if (massagedOptions.untitledResource && this.mapResourceToModel.has(massagedOptions.untitledResource)) {
      return this.mapResourceToModel.get(massagedOptions.untitledResource);
    }
    return this.doCreate(massagedOptions);
  }
  massageOptions(options) {
    var _a43, _b;
    const massagedOptions = /* @__PURE__ */ Object.create(null);
    if (options.associatedResource) {
      massagedOptions.untitledResource = URI.from({
        scheme: Schemas.untitled,
        authority: options.associatedResource.authority,
        fragment: options.associatedResource.fragment,
        path: options.associatedResource.path,
        query: options.associatedResource.query
      });
      massagedOptions.associatedResource = options.associatedResource;
    } else {
      if (((_a43 = options.untitledResource) == null ? void 0 : _a43.scheme) === Schemas.untitled) {
        massagedOptions.untitledResource = options.untitledResource;
      }
    }
    if (options.languageId) {
      massagedOptions.languageId = options.languageId;
    } else if (!massagedOptions.associatedResource) {
      const configuration = this.configurationService.getValue();
      if ((_b = configuration.files) == null ? void 0 : _b.defaultLanguage) {
        massagedOptions.languageId = configuration.files.defaultLanguage;
      }
    }
    massagedOptions.encoding = options.encoding;
    massagedOptions.initialValue = options.initialValue;
    return massagedOptions;
  }
  doCreate(options) {
    let untitledResource = options.untitledResource;
    if (!untitledResource) {
      let counter = 1;
      do {
        untitledResource = URI.from({ scheme: Schemas.untitled, path: `Untitled-${counter}` });
        counter++;
      } while (this.mapResourceToModel.has(untitledResource));
    }
    const model = this._register(this.instantiationService.createInstance(UntitledTextEditorModel, untitledResource, !!options.associatedResource, options.initialValue, options.languageId, options.encoding));
    this.registerModel(model);
    return model;
  }
  registerModel(model) {
    const modelListeners = new DisposableStore();
    modelListeners.add(model.onDidChangeDirty(() => this._onDidChangeDirty.fire(model)));
    modelListeners.add(model.onDidChangeName(() => this._onDidChangeLabel.fire(model)));
    modelListeners.add(model.onDidChangeEncoding(() => this._onDidChangeEncoding.fire(model)));
    modelListeners.add(model.onWillDispose(() => this._onWillDispose.fire(model)));
    Event.once(model.onWillDispose)(() => {
      this.mapResourceToModel.delete(model.resource);
      modelListeners.dispose();
    });
    this.mapResourceToModel.set(model.resource, model);
    if (model.isDirty()) {
      this._onDidChangeDirty.fire(model);
    }
  }
  isUntitledWithAssociatedResource(resource) {
    return resource.scheme === Schemas.untitled && resource.path.length > 1 && !UntitledTextEditorService_1.UNTITLED_WITHOUT_ASSOCIATED_RESOURCE_REGEX.test(resource.path);
  }
}, UntitledTextEditorService_1 = _a5, _a5.UNTITLED_WITHOUT_ASSOCIATED_RESOURCE_REGEX = /Untitled-\d+/, _a5);
UntitledTextEditorService = UntitledTextEditorService_1 = __decorate([
  __param(0, IInstantiationService),
  __param(1, IConfigurationService)
], UntitledTextEditorService);

// node_modules/vscode/override/vs/platform/dialogs/common/dialogs.js
var ConfirmResult;
(function(ConfirmResult2) {
  ConfirmResult2[ConfirmResult2["SAVE"] = 0] = "SAVE";
  ConfirmResult2[ConfirmResult2["DONT_SAVE"] = 1] = "DONT_SAVE";
  ConfirmResult2[ConfirmResult2["CANCEL"] = 2] = "CANCEL";
})(ConfirmResult || (ConfirmResult = {}));

// node_modules/vscode/vscode/src/vs/workbench/services/files/common/elevatedFileService.js
init_instantiation();
var IElevatedFileService = createDecorator("elevatedFileService");

// node_modules/vscode/vscode/src/vs/workbench/services/files/browser/elevatedFileService.js
var BrowserElevatedFileService = class {
  isSupported(resource) {
    return false;
  }
  async writeFileElevated(resource, value, options) {
    throw new Error("Unsupported");
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/decorations/common/decorations.js
init_instantiation();
var IDecorationsService = createDecorator("IFileDecorationsService");

// node_modules/vscode/vscode/src/vs/platform/request/browser/requestService.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/base/parts/request/browser/request.js
init_buffer();
init_errors();

// node_modules/vscode/vscode/src/vs/base/parts/request/common/request.js
var offlineName = "Offline";
var OfflineError = class extends Error {
  constructor() {
    super(offlineName);
    this.name = this.message;
  }
};

// node_modules/vscode/vscode/src/vs/base/parts/request/browser/request.js
function request(options, token) {
  if (options.proxyAuthorization) {
    options.headers = {
      ...options.headers || {},
      "Proxy-Authorization": options.proxyAuthorization
    };
  }
  const xhr = new XMLHttpRequest();
  return new Promise((resolve, reject) => {
    xhr.open(options.type || "GET", options.url || "", true, options.user, options.password);
    setRequestHeaders(xhr, options);
    xhr.responseType = "arraybuffer";
    xhr.onerror = (e) => reject(navigator.onLine ? new Error(xhr.statusText && "XHR failed: " + xhr.statusText || "XHR failed") : new OfflineError());
    xhr.onload = (e) => {
      resolve({
        res: {
          statusCode: xhr.status,
          headers: getResponseHeaders(xhr)
        },
        stream: bufferToStream(VSBuffer.wrap(new Uint8Array(xhr.response)))
      });
    };
    xhr.ontimeout = (e) => reject(new Error(`XHR timeout: ${options.timeout}ms`));
    if (options.timeout) {
      xhr.timeout = options.timeout;
    }
    xhr.send(options.data);
    token.onCancellationRequested(() => {
      xhr.abort();
      reject(canceled());
    });
  });
}
function setRequestHeaders(xhr, options) {
  if (options.headers) {
    outer:
      for (const k in options.headers) {
        switch (k) {
          case "User-Agent":
          case "Accept-Encoding":
          case "Content-Length":
            continue outer;
        }
        xhr.setRequestHeader(k, options.headers[k]);
      }
  }
}
function getResponseHeaders(xhr) {
  const headers = /* @__PURE__ */ Object.create(null);
  for (const line of xhr.getAllResponseHeaders().split(/\r\n|\n|\r/g)) {
    if (line) {
      const idx = line.indexOf(":");
      headers[line.substr(0, idx).trim().toLowerCase()] = line.substr(idx + 1).trim();
    }
  }
  return headers;
}

// node_modules/vscode/vscode/src/vs/platform/request/browser/requestService.js
init_configuration();
init_log();
var RequestService = class RequestService2 extends AbstractRequestService {
  constructor(configurationService, loggerService) {
    super(loggerService);
    this.configurationService = configurationService;
  }
  async request(options, token) {
    if (!options.proxyAuthorization) {
      options.proxyAuthorization = this.configurationService.getValue("http.proxyAuthorization");
    }
    return this.logAndRequest("browser", options, () => request(options, token));
  }
  async resolveProxy(url) {
    return void 0;
  }
};
RequestService = __decorate([
  __param(0, IConfigurationService),
  __param(1, ILoggerService)
], RequestService);

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/workingCopyBackupService.js
init_tslib_es6();
init_resources();
init_uri();
init_arrays();
init_objects();
init_async();
init_files();
init_map();
init_stream();
init_buffer();
init_lifecycle();
init_log();
init_network();
init_hash();
init_types();
var WorkingCopyBackupServiceImpl_1;
var WorkingCopyBackupsModel = class _WorkingCopyBackupsModel {
  static async create(backupRoot, fileService) {
    const model = new _WorkingCopyBackupsModel(backupRoot, fileService);
    await model.resolve();
    return model;
  }
  constructor(backupRoot, fileService) {
    this.backupRoot = backupRoot;
    this.fileService = fileService;
    this.cache = new ResourceMap();
  }
  async resolve() {
    try {
      const backupRootStat = await this.fileService.resolve(this.backupRoot);
      if (backupRootStat.children) {
        await Promises.settled(backupRootStat.children.filter((child) => child.isDirectory).map(async (backupSchemaFolder) => {
          const backupSchemaFolderStat = await this.fileService.resolve(backupSchemaFolder.resource);
          if (backupSchemaFolderStat.children) {
            for (const backupForSchema of backupSchemaFolderStat.children) {
              if (!backupForSchema.isDirectory) {
                this.add(backupForSchema.resource);
              }
            }
          }
        }));
      }
    } catch (error) {
    }
  }
  add(resource, versionId = 0, meta) {
    this.cache.set(resource, {
      versionId,
      meta: deepClone(meta)
    });
  }
  update(resource, meta) {
    const entry = this.cache.get(resource);
    if (entry) {
      entry.meta = deepClone(meta);
    }
  }
  count() {
    return this.cache.size;
  }
  has(resource, versionId, meta) {
    const entry = this.cache.get(resource);
    if (!entry) {
      return false;
    }
    if (typeof versionId === "number" && versionId !== entry.versionId) {
      return false;
    }
    if (meta && !equals(meta, entry.meta)) {
      return false;
    }
    return true;
  }
  get() {
    return Array.from(this.cache.keys());
  }
  remove(resource) {
    this.cache.delete(resource);
  }
  clear() {
    this.cache.clear();
  }
};
var _a6;
var WorkingCopyBackupServiceImpl = (_a6 = class extends Disposable {
  constructor(backupWorkspaceHome, fileService, logService) {
    super();
    this.backupWorkspaceHome = backupWorkspaceHome;
    this.fileService = fileService;
    this.logService = logService;
    this.ioOperationQueues = this._register(new ResourceQueue());
    this.model = void 0;
    this.initialize(backupWorkspaceHome);
  }
  initialize(backupWorkspaceResource) {
    this.backupWorkspaceHome = backupWorkspaceResource;
    this.ready = this.doInitialize();
  }
  async doInitialize() {
    this.model = await WorkingCopyBackupsModel.create(this.backupWorkspaceHome, this.fileService);
    return this.model;
  }
  async hasBackups() {
    const model = await this.ready;
    await this.joinBackups();
    return model.count() > 0;
  }
  hasBackupSync(identifier, versionId, meta) {
    if (!this.model) {
      return false;
    }
    const backupResource = this.toBackupResource(identifier);
    return this.model.has(backupResource, versionId, meta);
  }
  async backup(identifier, content, versionId, meta, token) {
    const model = await this.ready;
    if (token == null ? void 0 : token.isCancellationRequested) {
      return;
    }
    const backupResource = this.toBackupResource(identifier);
    if (model.has(backupResource, versionId, meta)) {
      return;
    }
    return this.ioOperationQueues.queueFor(backupResource).queue(async () => {
      if (token == null ? void 0 : token.isCancellationRequested) {
        return;
      }
      if (model.has(backupResource, versionId, meta)) {
        return;
      }
      let preamble = this.createPreamble(identifier, meta);
      if (preamble.length >= WorkingCopyBackupServiceImpl_1.PREAMBLE_MAX_LENGTH) {
        preamble = this.createPreamble(identifier);
      }
      const preambleBuffer = VSBuffer.fromString(preamble);
      let backupBuffer;
      if (isReadableStream(content)) {
        backupBuffer = prefixedBufferStream(preambleBuffer, content);
      } else if (content) {
        backupBuffer = prefixedBufferReadable(preambleBuffer, content);
      } else {
        backupBuffer = VSBuffer.concat([preambleBuffer, VSBuffer.fromString("")]);
      }
      await this.fileService.writeFile(backupResource, backupBuffer);
      model.add(backupResource, versionId, meta);
    });
  }
  createPreamble(identifier, meta) {
    return `${identifier.resource.toString()}${WorkingCopyBackupServiceImpl_1.PREAMBLE_META_SEPARATOR}${JSON.stringify({ ...meta, typeId: identifier.typeId })}${WorkingCopyBackupServiceImpl_1.PREAMBLE_END_MARKER}`;
  }
  async discardBackups(filter) {
    const model = await this.ready;
    const except = filter == null ? void 0 : filter.except;
    if (Array.isArray(except) && except.length > 0) {
      const exceptMap = new ResourceMap();
      for (const exceptWorkingCopy of except) {
        exceptMap.set(this.toBackupResource(exceptWorkingCopy), true);
      }
      await Promises.settled(model.get().map(async (backupResource) => {
        if (!exceptMap.has(backupResource)) {
          await this.doDiscardBackup(backupResource);
        }
      }));
    } else {
      await this.deleteIgnoreFileNotFound(this.backupWorkspaceHome);
      model.clear();
    }
  }
  discardBackup(identifier, token) {
    const backupResource = this.toBackupResource(identifier);
    return this.doDiscardBackup(backupResource, token);
  }
  async doDiscardBackup(backupResource, token) {
    const model = await this.ready;
    if (token == null ? void 0 : token.isCancellationRequested) {
      return;
    }
    return this.ioOperationQueues.queueFor(backupResource).queue(async () => {
      if (token == null ? void 0 : token.isCancellationRequested) {
        return;
      }
      await this.deleteIgnoreFileNotFound(backupResource);
      model.remove(backupResource);
    });
  }
  async deleteIgnoreFileNotFound(backupResource) {
    try {
      await this.fileService.del(backupResource, { recursive: true });
    } catch (error) {
      if (error.fileOperationResult !== 1) {
        throw error;
      }
    }
  }
  async getBackups() {
    const model = await this.ready;
    await this.joinBackups();
    const backups = await Promise.all(model.get().map((backupResource) => this.resolveIdentifier(backupResource, model)));
    return coalesce(backups);
  }
  async resolveIdentifier(backupResource, model) {
    let res = void 0;
    await this.ioOperationQueues.queueFor(backupResource).queue(async () => {
      if (!model.has(backupResource)) {
        return;
      }
      const backupPreamble = await this.readToMatchingString(backupResource, WorkingCopyBackupServiceImpl_1.PREAMBLE_END_MARKER, WorkingCopyBackupServiceImpl_1.PREAMBLE_MAX_LENGTH);
      if (!backupPreamble) {
        return;
      }
      const metaStartIndex = backupPreamble.indexOf(WorkingCopyBackupServiceImpl_1.PREAMBLE_META_SEPARATOR);
      let resourcePreamble;
      let metaPreamble;
      if (metaStartIndex > 0) {
        resourcePreamble = backupPreamble.substring(0, metaStartIndex);
        metaPreamble = backupPreamble.substr(metaStartIndex + 1);
      } else {
        resourcePreamble = backupPreamble;
        metaPreamble = void 0;
      }
      const { typeId, meta } = this.parsePreambleMeta(metaPreamble);
      model.update(backupResource, meta);
      res = {
        typeId: typeId ?? NO_TYPE_ID,
        resource: URI.parse(resourcePreamble)
      };
    });
    return res;
  }
  async readToMatchingString(backupResource, matchingString, maximumBytesToRead) {
    const contents = (await this.fileService.readFile(backupResource, { length: maximumBytesToRead })).value.toString();
    const matchingStringIndex = contents.indexOf(matchingString);
    if (matchingStringIndex >= 0) {
      return contents.substr(0, matchingStringIndex);
    }
    return void 0;
  }
  async resolve(identifier) {
    const backupResource = this.toBackupResource(identifier);
    const model = await this.ready;
    let res = void 0;
    await this.ioOperationQueues.queueFor(backupResource).queue(async () => {
      if (!model.has(backupResource)) {
        return;
      }
      const backupStream = await this.fileService.readFileStream(backupResource);
      const peekedBackupStream = await peekStream(backupStream.value, 1);
      const firstBackupChunk = VSBuffer.concat(peekedBackupStream.buffer);
      const preambleEndIndex = firstBackupChunk.buffer.indexOf(WorkingCopyBackupServiceImpl_1.PREAMBLE_END_MARKER_CHARCODE);
      if (preambleEndIndex === -1) {
        this.logService.trace(`Backup: Could not find meta end marker in ${backupResource}. The file is probably corrupt (filesize: ${backupStream.size}).`);
        return void 0;
      }
      const preambelRaw = firstBackupChunk.slice(0, preambleEndIndex).toString();
      let meta;
      const metaStartIndex = preambelRaw.indexOf(WorkingCopyBackupServiceImpl_1.PREAMBLE_META_SEPARATOR);
      if (metaStartIndex !== -1) {
        meta = this.parsePreambleMeta(preambelRaw.substr(metaStartIndex + 1)).meta;
      }
      model.update(backupResource, meta);
      const firstBackupChunkWithoutPreamble = firstBackupChunk.slice(preambleEndIndex + 1);
      let value;
      if (peekedBackupStream.ended) {
        value = bufferToStream(firstBackupChunkWithoutPreamble);
      } else {
        value = prefixedBufferStream(firstBackupChunkWithoutPreamble, peekedBackupStream.stream);
      }
      res = { value, meta };
    });
    return res;
  }
  parsePreambleMeta(preambleMetaRaw) {
    let typeId = void 0;
    let meta = void 0;
    if (preambleMetaRaw) {
      try {
        meta = JSON.parse(preambleMetaRaw);
        typeId = meta == null ? void 0 : meta.typeId;
        if (typeof (meta == null ? void 0 : meta.typeId) === "string") {
          delete meta.typeId;
          if (isEmptyObject(meta)) {
            meta = void 0;
          }
        }
      } catch (error) {
      }
    }
    return { typeId, meta };
  }
  toBackupResource(identifier) {
    return joinPath(this.backupWorkspaceHome, identifier.resource.scheme, hashIdentifier(identifier));
  }
  joinBackups() {
    return this.ioOperationQueues.whenDrained();
  }
}, WorkingCopyBackupServiceImpl_1 = _a6, _a6.PREAMBLE_END_MARKER = "\n", _a6.PREAMBLE_END_MARKER_CHARCODE = "\n".charCodeAt(0), _a6.PREAMBLE_META_SEPARATOR = " ", _a6.PREAMBLE_MAX_LENGTH = 1e4, _a6);
WorkingCopyBackupServiceImpl = WorkingCopyBackupServiceImpl_1 = __decorate([
  __param(1, IFileService),
  __param(2, ILogService)
], WorkingCopyBackupServiceImpl);
var InMemoryWorkingCopyBackupService = class {
  constructor() {
    this.backups = new ResourceMap();
  }
  async hasBackups() {
    return this.backups.size > 0;
  }
  hasBackupSync(identifier, versionId) {
    const backupResource = this.toBackupResource(identifier);
    return this.backups.has(backupResource);
  }
  async backup(identifier, content, versionId, meta, token) {
    const backupResource = this.toBackupResource(identifier);
    this.backups.set(backupResource, {
      typeId: identifier.typeId,
      content: content instanceof VSBuffer ? content : content ? isReadableStream(content) ? await streamToBuffer(content) : readableToBuffer(content) : VSBuffer.fromString(""),
      meta
    });
  }
  async resolve(identifier) {
    const backupResource = this.toBackupResource(identifier);
    const backup = this.backups.get(backupResource);
    if (backup) {
      return { value: bufferToStream(backup.content), meta: backup.meta };
    }
    return void 0;
  }
  async getBackups() {
    return Array.from(this.backups.entries()).map(([resource, backup]) => ({ typeId: backup.typeId, resource }));
  }
  async discardBackup(identifier) {
    this.backups.delete(this.toBackupResource(identifier));
  }
  async discardBackups(filter) {
    const except = filter == null ? void 0 : filter.except;
    if (Array.isArray(except) && except.length > 0) {
      const exceptMap = new ResourceMap();
      for (const exceptWorkingCopy of except) {
        exceptMap.set(this.toBackupResource(exceptWorkingCopy), true);
      }
      for (const backup of await this.getBackups()) {
        if (!exceptMap.has(this.toBackupResource(backup))) {
          await this.discardBackup(backup);
        }
      }
    } else {
      this.backups.clear();
    }
  }
  toBackupResource(identifier) {
    return URI.from({ scheme: Schemas.inMemory, path: hashIdentifier(identifier) });
  }
  async joinBackups() {
    return;
  }
};
function hashIdentifier(identifier) {
  let resource;
  if (identifier.typeId.length > 0) {
    const typeIdHash = hashString(identifier.typeId);
    if (identifier.resource.path) {
      resource = joinPath(identifier.resource, typeIdHash);
    } else {
      resource = identifier.resource.with({ path: typeIdHash });
    }
  } else {
    resource = identifier.resource;
  }
  return hashPath(resource);
}
function hashPath(resource) {
  const str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();
  return hashString(str);
}
function hashString(str) {
  return hash(str).toString(16);
}

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/browser/browserTextFileService.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/browser/textFileService.js
init_tslib_es6();
init_nls();
init_files();
init_lifecycle();
init_path();

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textFileEditorModelManager.js
init_tslib_es6();
init_nls();
init_errorMessage();
init_event();
init_uri();

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textFileEditorModel.js
init_tslib_es6();
init_nls();
init_event();
init_types();
init_files();
init_language();
init_model2();
init_async();
init_log();
init_path();
init_cancellation();
init_textModel();
init_resources();
init_modesRegistry();
var TextFileEditorModel_1;
var _a7;
var TextFileEditorModel = (_a7 = class extends BaseTextEditorModel {
  constructor(resource, preferredEncoding, preferredLanguageId, languageService, modelService, fileService, textFileService, workingCopyBackupService, logService, workingCopyService, filesConfigurationService, labelService, languageDetectionService, accessibilityService, pathService, extensionService) {
    super(modelService, languageService, languageDetectionService, accessibilityService);
    this.resource = resource;
    this.preferredEncoding = preferredEncoding;
    this.preferredLanguageId = preferredLanguageId;
    this.fileService = fileService;
    this.textFileService = textFileService;
    this.workingCopyBackupService = workingCopyBackupService;
    this.logService = logService;
    this.workingCopyService = workingCopyService;
    this.filesConfigurationService = filesConfigurationService;
    this.labelService = labelService;
    this.pathService = pathService;
    this.extensionService = extensionService;
    this._onDidChangeContent = this._register(new Emitter());
    this.onDidChangeContent = this._onDidChangeContent.event;
    this._onDidResolve = this._register(new Emitter());
    this.onDidResolve = this._onDidResolve.event;
    this._onDidChangeDirty = this._register(new Emitter());
    this.onDidChangeDirty = this._onDidChangeDirty.event;
    this._onDidSaveError = this._register(new Emitter());
    this.onDidSaveError = this._onDidSaveError.event;
    this._onDidSave = this._register(new Emitter());
    this.onDidSave = this._onDidSave.event;
    this._onDidRevert = this._register(new Emitter());
    this.onDidRevert = this._onDidRevert.event;
    this._onDidChangeEncoding = this._register(new Emitter());
    this.onDidChangeEncoding = this._onDidChangeEncoding.event;
    this._onDidChangeOrphaned = this._register(new Emitter());
    this.onDidChangeOrphaned = this._onDidChangeOrphaned.event;
    this._onDidChangeReadonly = this._register(new Emitter());
    this.onDidChangeReadonly = this._onDidChangeReadonly.event;
    this.typeId = NO_TYPE_ID;
    this.capabilities = 0;
    this.name = basename(this.labelService.getUriLabel(this.resource));
    this.resourceHasExtension = !!extUri.extname(this.resource);
    this.versionId = 0;
    this.ignoreDirtyOnModelContentChange = false;
    this.ignoreSaveFromSaveParticipants = false;
    this.lastModelContentChangeFromUndoRedo = void 0;
    this.saveSequentializer = new TaskSequentializer();
    this.dirty = false;
    this.inConflictMode = false;
    this.inOrphanMode = false;
    this.inErrorMode = false;
    this.hasEncodingSetExplicitly = false;
    this._register(this.workingCopyService.registerWorkingCopy(this));
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.fileService.onDidFilesChange((e) => this.onDidFilesChange(e)));
    this._register(this.filesConfigurationService.onFilesAssociationChange(() => this.onFilesAssociationChange()));
    this._register(this.filesConfigurationService.onReadonlyChange(() => this._onDidChangeReadonly.fire()));
  }
  async onDidFilesChange(e) {
    let fileEventImpactsModel = false;
    let newInOrphanModeGuess;
    if (this.inOrphanMode) {
      const modelFileAdded = e.contains(this.resource, 1);
      if (modelFileAdded) {
        newInOrphanModeGuess = false;
        fileEventImpactsModel = true;
      }
    } else {
      const modelFileDeleted = e.contains(this.resource, 2);
      if (modelFileDeleted) {
        newInOrphanModeGuess = true;
        fileEventImpactsModel = true;
      }
    }
    if (fileEventImpactsModel && this.inOrphanMode !== newInOrphanModeGuess) {
      let newInOrphanModeValidated = false;
      if (newInOrphanModeGuess) {
        await timeout(100);
        if (this.isDisposed()) {
          newInOrphanModeValidated = true;
        } else {
          const exists = await this.fileService.exists(this.resource);
          newInOrphanModeValidated = !exists;
        }
      }
      if (this.inOrphanMode !== newInOrphanModeValidated && !this.isDisposed()) {
        this.setOrphaned(newInOrphanModeValidated);
      }
    }
  }
  setOrphaned(orphaned) {
    if (this.inOrphanMode !== orphaned) {
      this.inOrphanMode = orphaned;
      this._onDidChangeOrphaned.fire();
    }
  }
  onFilesAssociationChange() {
    if (!this.isResolved()) {
      return;
    }
    const firstLineText = this.getFirstLineText(this.textEditorModel);
    const languageSelection = this.getOrCreateLanguage(this.resource, this.languageService, this.preferredLanguageId, firstLineText);
    this.textEditorModel.setLanguage(languageSelection);
  }
  setLanguageId(languageId, source) {
    super.setLanguageId(languageId, source);
    this.preferredLanguageId = languageId;
  }
  async backup(token) {
    let meta = void 0;
    if (this.lastResolvedFileStat) {
      meta = {
        mtime: this.lastResolvedFileStat.mtime,
        ctime: this.lastResolvedFileStat.ctime,
        size: this.lastResolvedFileStat.size,
        etag: this.lastResolvedFileStat.etag,
        orphaned: this.inOrphanMode
      };
    }
    const content = await this.textFileService.getEncodedReadable(this.resource, this.createSnapshot() ?? void 0, { encoding: UTF8 });
    return { meta, content };
  }
  async revert(options) {
    if (!this.isResolved()) {
      return;
    }
    const wasDirty = this.dirty;
    const undo = this.doSetDirty(false);
    const softUndo = options == null ? void 0 : options.soft;
    if (!softUndo) {
      try {
        await this.forceResolveFromFile();
      } catch (error) {
        if (error.fileOperationResult !== 1) {
          undo();
          throw error;
        }
      }
    }
    this._onDidRevert.fire();
    if (wasDirty) {
      this._onDidChangeDirty.fire();
    }
  }
  async resolve(options) {
    this.trace("resolve() - enter");
    mark("code/willResolveTextFileEditorModel");
    if (this.isDisposed()) {
      this.trace("resolve() - exit - without resolving because model is disposed");
      return;
    }
    if (!(options == null ? void 0 : options.contents) && (this.dirty || this.saveSequentializer.isRunning())) {
      this.trace("resolve() - exit - without resolving because model is dirty or being saved");
      return;
    }
    await this.doResolve(options);
    mark("code/didResolveTextFileEditorModel");
  }
  async doResolve(options) {
    if (options == null ? void 0 : options.contents) {
      return this.resolveFromBuffer(options.contents, options);
    }
    const isNewModel = !this.isResolved();
    if (isNewModel) {
      const resolvedFromBackup = await this.resolveFromBackup(options);
      if (resolvedFromBackup) {
        return;
      }
    }
    return this.resolveFromFile(options);
  }
  async resolveFromBuffer(buffer, options) {
    this.trace("resolveFromBuffer()");
    let mtime;
    let ctime;
    let size;
    let etag2;
    try {
      const metadata = await this.fileService.stat(this.resource);
      mtime = metadata.mtime;
      ctime = metadata.ctime;
      size = metadata.size;
      etag2 = metadata.etag;
      this.setOrphaned(false);
    } catch (error) {
      mtime = Date.now();
      ctime = Date.now();
      size = 0;
      etag2 = ETAG_DISABLED;
      this.setOrphaned(error.fileOperationResult === 1);
    }
    const preferredEncoding = await this.textFileService.encoding.getPreferredWriteEncoding(this.resource, this.preferredEncoding);
    this.resolveFromContent({
      resource: this.resource,
      name: this.name,
      mtime,
      ctime,
      size,
      etag: etag2,
      value: buffer,
      encoding: preferredEncoding.encoding,
      readonly: false,
      locked: false
    }, true, options);
  }
  async resolveFromBackup(options) {
    const backup = await this.workingCopyBackupService.resolve(this);
    let encoding = UTF8;
    if (backup) {
      encoding = (await this.textFileService.encoding.getPreferredWriteEncoding(this.resource, this.preferredEncoding)).encoding;
    }
    const isNewModel = !this.isResolved();
    if (!isNewModel) {
      this.trace("resolveFromBackup() - exit - without resolving because previously new model got created meanwhile");
      return true;
    }
    if (backup) {
      await this.doResolveFromBackup(backup, encoding, options);
      return true;
    }
    return false;
  }
  async doResolveFromBackup(backup, encoding, options) {
    var _a43;
    this.trace("doResolveFromBackup()");
    this.resolveFromContent({
      resource: this.resource,
      name: this.name,
      mtime: backup.meta ? backup.meta.mtime : Date.now(),
      ctime: backup.meta ? backup.meta.ctime : Date.now(),
      size: backup.meta ? backup.meta.size : 0,
      etag: backup.meta ? backup.meta.etag : ETAG_DISABLED,
      value: await createTextBufferFactoryFromStream(await this.textFileService.getDecodedStream(this.resource, backup.value, { encoding: UTF8 })),
      encoding,
      readonly: false,
      locked: false
    }, true, options);
    if ((_a43 = backup.meta) == null ? void 0 : _a43.orphaned) {
      this.setOrphaned(true);
    }
  }
  async resolveFromFile(options) {
    this.trace("resolveFromFile()");
    const forceReadFromFile = options == null ? void 0 : options.forceReadFromFile;
    const allowBinary = this.isResolved() || (options == null ? void 0 : options.allowBinary);
    let etag2;
    if (forceReadFromFile) {
      etag2 = ETAG_DISABLED;
    } else if (this.lastResolvedFileStat) {
      etag2 = this.lastResolvedFileStat.etag;
    }
    const currentVersionId = this.versionId;
    try {
      const content = await this.textFileService.readStream(this.resource, {
        acceptTextOnly: !allowBinary,
        etag: etag2,
        encoding: this.preferredEncoding,
        limits: options == null ? void 0 : options.limits
      });
      this.setOrphaned(false);
      if (currentVersionId !== this.versionId) {
        this.trace("resolveFromFile() - exit - without resolving because model content changed");
        return;
      }
      return this.resolveFromContent(content, false, options);
    } catch (error) {
      const result = error.fileOperationResult;
      this.setOrphaned(result === 1);
      if (this.isResolved() && result === 2) {
        if (error instanceof NotModifiedSinceFileOperationError) {
          this.updateLastResolvedFileStat(error.stat);
        }
        return;
      }
      if (this.isResolved() && result === 1 && !forceReadFromFile) {
        return;
      }
      throw error;
    }
  }
  resolveFromContent(content, dirty, options) {
    this.trace("resolveFromContent() - enter");
    if (this.isDisposed()) {
      this.trace("resolveFromContent() - exit - because model is disposed");
      return;
    }
    this.updateLastResolvedFileStat({
      resource: this.resource,
      name: content.name,
      mtime: content.mtime,
      ctime: content.ctime,
      size: content.size,
      etag: content.etag,
      readonly: content.readonly,
      locked: content.locked,
      isFile: true,
      isDirectory: false,
      isSymbolicLink: false,
      children: void 0
    });
    const oldEncoding = this.contentEncoding;
    this.contentEncoding = content.encoding;
    if (this.preferredEncoding) {
      this.updatePreferredEncoding(this.contentEncoding);
    } else if (oldEncoding !== this.contentEncoding) {
      this._onDidChangeEncoding.fire();
    }
    if (this.textEditorModel) {
      this.doUpdateTextModel(content.value);
    } else {
      this.doCreateTextModel(content.resource, content.value);
    }
    this.setDirty(!!dirty);
    this._onDidResolve.fire((options == null ? void 0 : options.reason) ?? 3);
  }
  doCreateTextModel(resource, value) {
    this.trace("doCreateTextModel()");
    const textModel = this.createTextEditorModel(value, resource, this.preferredLanguageId);
    this.installModelListeners(textModel);
    this.autoDetectLanguage();
  }
  doUpdateTextModel(value) {
    this.trace("doUpdateTextModel()");
    this.ignoreDirtyOnModelContentChange = true;
    try {
      this.updateTextEditorModel(value, this.preferredLanguageId);
    } finally {
      this.ignoreDirtyOnModelContentChange = false;
    }
  }
  installModelListeners(model) {
    this._register(model.onDidChangeContent((e) => this.onModelContentChanged(model, e.isUndoing || e.isRedoing)));
    this._register(model.onDidChangeLanguage(() => this.onMaybeShouldChangeEncoding()));
    super.installModelListeners(model);
  }
  onModelContentChanged(model, isUndoingOrRedoing) {
    this.trace(`onModelContentChanged() - enter`);
    this.versionId++;
    this.trace(`onModelContentChanged() - new versionId ${this.versionId}`);
    if (isUndoingOrRedoing) {
      this.lastModelContentChangeFromUndoRedo = Date.now();
    }
    if (!this.ignoreDirtyOnModelContentChange && !this.isReadonly()) {
      if (model.getAlternativeVersionId() === this.bufferSavedVersionId) {
        this.trace("onModelContentChanged() - model content changed back to last saved version");
        const wasDirty = this.dirty;
        this.setDirty(false);
        if (wasDirty) {
          this._onDidRevert.fire();
        }
      } else {
        this.trace("onModelContentChanged() - model content changed and marked as dirty");
        this.setDirty(true);
      }
    }
    this._onDidChangeContent.fire();
    this.autoDetectLanguage();
  }
  async autoDetectLanguage() {
    var _a43;
    await ((_a43 = this.extensionService) == null ? void 0 : _a43.whenInstalledExtensionsRegistered());
    const languageId = this.getLanguageId();
    if (this.resource.scheme === this.pathService.defaultUriScheme && (!languageId || languageId === PLAINTEXT_LANGUAGE_ID) && !this.resourceHasExtension) {
      return super.autoDetectLanguage();
    }
  }
  async forceResolveFromFile() {
    if (this.isDisposed()) {
      return;
    }
    await this.textFileService.files.resolve(this.resource, {
      reload: { async: false },
      forceReadFromFile: true
    });
  }
  isDirty() {
    return this.dirty;
  }
  isModified() {
    return this.isDirty();
  }
  setDirty(dirty) {
    if (!this.isResolved()) {
      return;
    }
    const wasDirty = this.dirty;
    this.doSetDirty(dirty);
    if (dirty !== wasDirty) {
      this._onDidChangeDirty.fire();
    }
  }
  doSetDirty(dirty) {
    const wasDirty = this.dirty;
    const wasInConflictMode = this.inConflictMode;
    const wasInErrorMode = this.inErrorMode;
    const oldBufferSavedVersionId = this.bufferSavedVersionId;
    if (!dirty) {
      this.dirty = false;
      this.inConflictMode = false;
      this.inErrorMode = false;
      this.updateSavedVersionId();
    } else {
      this.dirty = true;
    }
    return () => {
      this.dirty = wasDirty;
      this.inConflictMode = wasInConflictMode;
      this.inErrorMode = wasInErrorMode;
      this.bufferSavedVersionId = oldBufferSavedVersionId;
    };
  }
  async save(options = /* @__PURE__ */ Object.create(null)) {
    if (!this.isResolved()) {
      return false;
    }
    if (this.isReadonly()) {
      this.trace("save() - ignoring request for readonly resource");
      return false;
    }
    if ((this.hasState(3) || this.hasState(5)) && (options.reason === 2 || options.reason === 3 || options.reason === 4)) {
      this.trace("save() - ignoring auto save request for model that is in conflict or error");
      return false;
    }
    this.trace("save() - enter");
    await this.doSave(options);
    this.trace("save() - exit");
    return this.hasState(0);
  }
  async doSave(options) {
    if (typeof options.reason !== "number") {
      options.reason = 1;
    }
    let versionId = this.versionId;
    this.trace(`doSave(${versionId}) - enter with versionId ${versionId}`);
    if (this.ignoreSaveFromSaveParticipants) {
      this.trace(`doSave(${versionId}) - exit - refusing to save() recursively from save participant`);
      return;
    }
    if (this.saveSequentializer.isRunning(versionId)) {
      this.trace(`doSave(${versionId}) - exit - found a running save for versionId ${versionId}`);
      return this.saveSequentializer.running;
    }
    if (!options.force && !this.dirty) {
      this.trace(`doSave(${versionId}) - exit - because not dirty and/or versionId is different (this.isDirty: ${this.dirty}, this.versionId: ${this.versionId})`);
      return;
    }
    if (this.saveSequentializer.isRunning()) {
      this.trace(`doSave(${versionId}) - exit - because busy saving`);
      this.saveSequentializer.cancelRunning();
      return this.saveSequentializer.queue(() => this.doSave(options));
    }
    if (this.isResolved()) {
      this.textEditorModel.pushStackElement();
    }
    const saveCancellation = new CancellationTokenSource();
    return this.saveSequentializer.run(versionId, (async () => {
      if (this.isResolved() && !options.skipSaveParticipants) {
        try {
          if (options.reason === 2 && typeof this.lastModelContentChangeFromUndoRedo === "number") {
            const timeFromUndoRedoToSave = Date.now() - this.lastModelContentChangeFromUndoRedo;
            if (timeFromUndoRedoToSave < TextFileEditorModel_1.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD) {
              await timeout(TextFileEditorModel_1.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD - timeFromUndoRedoToSave);
            }
          }
          if (!saveCancellation.token.isCancellationRequested) {
            this.ignoreSaveFromSaveParticipants = true;
            try {
              await this.textFileService.files.runSaveParticipants(this, { reason: options.reason ?? 1 }, saveCancellation.token);
            } finally {
              this.ignoreSaveFromSaveParticipants = false;
            }
          }
        } catch (error) {
          this.logService.error(`[text file model] runSaveParticipants(${versionId}) - resulted in an error: ${error.toString()}`, this.resource.toString());
        }
      }
      if (saveCancellation.token.isCancellationRequested) {
        return;
      } else {
        saveCancellation.dispose();
      }
      if (this.isDisposed()) {
        return;
      }
      if (!this.isResolved()) {
        return;
      }
      versionId = this.versionId;
      this.inErrorMode = false;
      this.trace(`doSave(${versionId}) - before write()`);
      const lastResolvedFileStat = assertIsDefined(this.lastResolvedFileStat);
      const resolvedTextFileEditorModel = this;
      return this.saveSequentializer.run(versionId, (async () => {
        try {
          const stat = await this.textFileService.write(lastResolvedFileStat.resource, resolvedTextFileEditorModel.createSnapshot(), {
            mtime: lastResolvedFileStat.mtime,
            encoding: this.getEncoding(),
            etag: options.ignoreModifiedSince || !this.filesConfigurationService.preventSaveConflicts(lastResolvedFileStat.resource, resolvedTextFileEditorModel.getLanguageId()) ? ETAG_DISABLED : lastResolvedFileStat.etag,
            unlock: options.writeUnlock,
            writeElevated: options.writeElevated
          });
          this.handleSaveSuccess(stat, versionId, options);
        } catch (error) {
          this.handleSaveError(error, versionId, options);
        }
      })());
    })(), () => saveCancellation.cancel());
  }
  handleSaveSuccess(stat, versionId, options) {
    this.updateLastResolvedFileStat(stat);
    if (versionId === this.versionId) {
      this.trace(`handleSaveSuccess(${versionId}) - setting dirty to false because versionId did not change`);
      this.setDirty(false);
    } else {
      this.trace(`handleSaveSuccess(${versionId}) - not setting dirty to false because versionId did change meanwhile`);
    }
    this.setOrphaned(false);
    this._onDidSave.fire({ reason: options.reason, stat, source: options.source });
  }
  handleSaveError(error, versionId, options) {
    (options.ignoreErrorHandler ? this.logService.trace : this.logService.error).apply(this.logService, [`[text file model] handleSaveError(${versionId}) - exit - resulted in a save error: ${error.toString()}`, this.resource.toString()]);
    if (options.ignoreErrorHandler) {
      throw error;
    }
    this.setDirty(true);
    this.inErrorMode = true;
    if (error.fileOperationResult === 3) {
      this.inConflictMode = true;
    }
    this.textFileService.files.saveErrorHandler.onSaveError(error, this);
    this._onDidSaveError.fire();
  }
  updateSavedVersionId() {
    if (this.isResolved()) {
      this.bufferSavedVersionId = this.textEditorModel.getAlternativeVersionId();
    }
  }
  updateLastResolvedFileStat(newFileStat) {
    const oldReadonly = this.isReadonly();
    if (!this.lastResolvedFileStat) {
      this.lastResolvedFileStat = newFileStat;
    } else if (this.lastResolvedFileStat.mtime <= newFileStat.mtime) {
      this.lastResolvedFileStat = newFileStat;
    }
    if (this.isReadonly() !== oldReadonly) {
      this._onDidChangeReadonly.fire();
    }
  }
  hasState(state) {
    switch (state) {
      case 3:
        return this.inConflictMode;
      case 1:
        return this.dirty;
      case 5:
        return this.inErrorMode;
      case 4:
        return this.inOrphanMode;
      case 2:
        return this.saveSequentializer.isRunning();
      case 0:
        return !this.dirty;
    }
  }
  async joinState(state) {
    return this.saveSequentializer.running;
  }
  getLanguageId() {
    if (this.textEditorModel) {
      return this.textEditorModel.getLanguageId();
    }
    return this.preferredLanguageId;
  }
  async onMaybeShouldChangeEncoding() {
    if (this.hasEncodingSetExplicitly) {
      this.trace("onMaybeShouldChangeEncoding() - ignoring because encoding was set explicitly");
      return;
    }
    if (this.contentEncoding === UTF8_with_bom || this.contentEncoding === UTF16be || this.contentEncoding === UTF16le) {
      this.trace("onMaybeShouldChangeEncoding() - ignoring because content encoding has a BOM");
      return;
    }
    const { encoding } = await this.textFileService.encoding.getPreferredReadEncoding(this.resource);
    if (typeof encoding !== "string" || !this.isNewEncoding(encoding)) {
      this.trace(`onMaybeShouldChangeEncoding() - ignoring because preferred encoding ${encoding} is not new`);
      return;
    }
    if (this.isDirty()) {
      this.trace("onMaybeShouldChangeEncoding() - ignoring because model is dirty");
      return;
    }
    this.logService.info(`Adjusting encoding based on configured language override to '${encoding}' for ${this.resource.toString(true)}.`);
    return this.setEncodingInternal(encoding, 1);
  }
  setEncoding(encoding, mode) {
    this.hasEncodingSetExplicitly = true;
    return this.setEncodingInternal(encoding, mode);
  }
  async setEncodingInternal(encoding, mode) {
    if (mode === 0) {
      this.updatePreferredEncoding(encoding);
      if (!this.isDirty()) {
        this.versionId++;
        this.setDirty(true);
      }
      if (!this.inConflictMode) {
        await this.save({ source: TextFileEditorModel_1.TEXTFILE_SAVE_ENCODING_SOURCE });
      }
    } else {
      if (!this.isNewEncoding(encoding)) {
        return;
      }
      if (this.isDirty() && !this.inConflictMode) {
        await this.save();
      }
      this.updatePreferredEncoding(encoding);
      await this.forceResolveFromFile();
    }
  }
  updatePreferredEncoding(encoding) {
    if (!this.isNewEncoding(encoding)) {
      return;
    }
    this.preferredEncoding = encoding;
    this._onDidChangeEncoding.fire();
  }
  isNewEncoding(encoding) {
    if (this.preferredEncoding === encoding) {
      return false;
    }
    if (!this.preferredEncoding && this.contentEncoding === encoding) {
      return false;
    }
    return true;
  }
  getEncoding() {
    return this.preferredEncoding || this.contentEncoding;
  }
  trace(msg) {
    this.logService.trace(`[text file model] ${msg}`, this.resource.toString());
  }
  isResolved() {
    return !!this.textEditorModel;
  }
  isReadonly() {
    return this.filesConfigurationService.isReadonly(this.resource, this.lastResolvedFileStat);
  }
  dispose() {
    this.trace("dispose()");
    this.inConflictMode = false;
    this.inOrphanMode = false;
    this.inErrorMode = false;
    super.dispose();
  }
}, TextFileEditorModel_1 = _a7, _a7.TEXTFILE_SAVE_ENCODING_SOURCE = SaveSourceRegistry.registerSource("textFileEncoding.source", localize("textFileCreate.source", "File Encoding Changed")), _a7.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD = 500, _a7);
TextFileEditorModel = TextFileEditorModel_1 = __decorate([
  __param(3, ILanguageService),
  __param(4, IModelService),
  __param(5, IFileService),
  __param(6, ITextFileService),
  __param(7, IWorkingCopyBackupService),
  __param(8, ILogService),
  __param(9, IWorkingCopyService),
  __param(10, IFilesConfigurationService),
  __param(11, ILabelService),
  __param(12, ILanguageDetectionService),
  __param(13, IAccessibilityService),
  __param(14, IPathService),
  __param(15, IExtensionService)
], TextFileEditorModel);

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textFileEditorModelManager.js
init_lifecycle();
init_instantiation();
init_map();
init_files();
init_async();
init_errors();

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textFileSaveParticipant.js
init_tslib_es6();
init_nls();
init_async();
init_cancellation();
init_log();
init_progress();
init_lifecycle();
init_arrays();
var TextFileSaveParticipant = class TextFileSaveParticipant2 extends Disposable {
  constructor(progressService, logService) {
    super();
    this.progressService = progressService;
    this.logService = logService;
    this.saveParticipants = [];
  }
  addSaveParticipant(participant) {
    const remove = insert(this.saveParticipants, participant);
    return toDisposable(() => remove());
  }
  participate(model, context, token) {
    const cts = new CancellationTokenSource(token);
    return this.progressService.withProgress({
      title: localize("saveParticipants", "Saving '{0}'", model.name),
      location: 15,
      cancellable: true,
      delay: model.isDirty() ? 3e3 : 5e3
    }, async (progress) => {
      var _a43, _b;
      (_a43 = model.textEditorModel) == null ? void 0 : _a43.pushStackElement();
      for (const saveParticipant of this.saveParticipants) {
        if (cts.token.isCancellationRequested || !model.textEditorModel) {
          break;
        }
        try {
          const promise = saveParticipant.participate(model, context, progress, cts.token);
          await raceCancellation(promise, cts.token);
        } catch (err) {
          this.logService.error(err);
        }
      }
      (_b = model.textEditorModel) == null ? void 0 : _b.pushStackElement();
    }, () => {
      cts.cancel();
    }).finally(() => {
      cts.dispose();
    });
  }
  dispose() {
    this.saveParticipants.splice(0, this.saveParticipants.length);
    super.dispose();
  }
};
TextFileSaveParticipant = __decorate([
  __param(0, IProgressService),
  __param(1, ILogService)
], TextFileSaveParticipant);

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textFileEditorModelManager.js
init_resources();
init_textModel();
init_modesRegistry();
var TextFileEditorModelManager = class TextFileEditorModelManager2 extends Disposable {
  get models() {
    return [...this.mapResourceToModel.values()];
  }
  constructor(instantiationService, fileService, notificationService, workingCopyFileService, uriIdentityService) {
    super();
    this.instantiationService = instantiationService;
    this.fileService = fileService;
    this.notificationService = notificationService;
    this.workingCopyFileService = workingCopyFileService;
    this.uriIdentityService = uriIdentityService;
    this._onDidCreate = this._register(new Emitter());
    this.onDidCreate = this._onDidCreate.event;
    this._onDidResolve = this._register(new Emitter());
    this.onDidResolve = this._onDidResolve.event;
    this._onDidRemove = this._register(new Emitter());
    this.onDidRemove = this._onDidRemove.event;
    this._onDidChangeDirty = this._register(new Emitter());
    this.onDidChangeDirty = this._onDidChangeDirty.event;
    this._onDidChangeReadonly = this._register(new Emitter());
    this.onDidChangeReadonly = this._onDidChangeReadonly.event;
    this._onDidChangeOrphaned = this._register(new Emitter());
    this.onDidChangeOrphaned = this._onDidChangeOrphaned.event;
    this._onDidSaveError = this._register(new Emitter());
    this.onDidSaveError = this._onDidSaveError.event;
    this._onDidSave = this._register(new Emitter());
    this.onDidSave = this._onDidSave.event;
    this._onDidRevert = this._register(new Emitter());
    this.onDidRevert = this._onDidRevert.event;
    this._onDidChangeEncoding = this._register(new Emitter());
    this.onDidChangeEncoding = this._onDidChangeEncoding.event;
    this.mapResourceToModel = new ResourceMap();
    this.mapResourceToModelListeners = new ResourceMap();
    this.mapResourceToDisposeListener = new ResourceMap();
    this.mapResourceToPendingModelResolvers = new ResourceMap();
    this.modelResolveQueue = this._register(new ResourceQueue());
    this.saveErrorHandler = (() => {
      const notificationService2 = this.notificationService;
      return {
        onSaveError(error, model) {
          notificationService2.error(localize(
            { key: "genericSaveError", comment: ["{0} is the resource that failed to save and {1} the error message"] },
            "Failed to save '{0}': {1}",
            model.name,
            toErrorMessage(error, false)
          ));
        }
      };
    })();
    this.mapCorrelationIdToModelsToRestore = /* @__PURE__ */ new Map();
    this.saveParticipants = this._register(this.instantiationService.createInstance(TextFileSaveParticipant));
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.fileService.onDidFilesChange((e) => this.onDidFilesChange(e)));
    this._register(this.fileService.onDidChangeFileSystemProviderCapabilities((e) => this.onDidChangeFileSystemProviderCapabilities(e)));
    this._register(this.fileService.onDidChangeFileSystemProviderRegistrations((e) => this.onDidChangeFileSystemProviderRegistrations(e)));
    this._register(this.workingCopyFileService.onWillRunWorkingCopyFileOperation((e) => this.onWillRunWorkingCopyFileOperation(e)));
    this._register(this.workingCopyFileService.onDidFailWorkingCopyFileOperation((e) => this.onDidFailWorkingCopyFileOperation(e)));
    this._register(this.workingCopyFileService.onDidRunWorkingCopyFileOperation((e) => this.onDidRunWorkingCopyFileOperation(e)));
  }
  onDidFilesChange(e) {
    for (const model of this.models) {
      if (model.isDirty()) {
        continue;
      }
      if (e.contains(model.resource, 0, 1)) {
        this.queueModelReload(model);
      }
    }
  }
  onDidChangeFileSystemProviderCapabilities(e) {
    this.queueModelReloads(e.scheme);
  }
  onDidChangeFileSystemProviderRegistrations(e) {
    if (!e.added) {
      return;
    }
    this.queueModelReloads(e.scheme);
  }
  queueModelReloads(scheme) {
    for (const model of this.models) {
      if (model.isDirty()) {
        continue;
      }
      if (scheme === model.resource.scheme) {
        this.queueModelReload(model);
      }
    }
  }
  queueModelReload(model) {
    const queue = this.modelResolveQueue.queueFor(model.resource);
    if (queue.size <= 1) {
      queue.queue(async () => {
        try {
          await this.reload(model);
        } catch (error) {
          onUnexpectedError(error);
        }
      });
    }
  }
  onWillRunWorkingCopyFileOperation(e) {
    if (e.operation === 2 || e.operation === 3) {
      const modelsToRestore = [];
      for (const { source, target } of e.files) {
        if (source) {
          if (this.uriIdentityService.extUri.isEqual(source, target)) {
            continue;
          }
          const sourceModels = [];
          for (const model of this.models) {
            if (this.uriIdentityService.extUri.isEqualOrParent(model.resource, source)) {
              sourceModels.push(model);
            }
          }
          for (const sourceModel of sourceModels) {
            const sourceModelResource = sourceModel.resource;
            let targetModelResource;
            if (this.uriIdentityService.extUri.isEqual(sourceModelResource, source)) {
              targetModelResource = target;
            } else {
              targetModelResource = joinPath(target, sourceModelResource.path.substr(source.path.length + 1));
            }
            modelsToRestore.push({
              source: sourceModelResource,
              target: targetModelResource,
              languageId: sourceModel.getLanguageId(),
              encoding: sourceModel.getEncoding(),
              snapshot: sourceModel.isDirty() ? sourceModel.createSnapshot() : void 0
            });
          }
        }
      }
      this.mapCorrelationIdToModelsToRestore.set(e.correlationId, modelsToRestore);
    }
  }
  onDidFailWorkingCopyFileOperation(e) {
    if (e.operation === 2 || e.operation === 3) {
      const modelsToRestore = this.mapCorrelationIdToModelsToRestore.get(e.correlationId);
      if (modelsToRestore) {
        this.mapCorrelationIdToModelsToRestore.delete(e.correlationId);
        modelsToRestore.forEach((model) => {
          var _a43;
          if (model.snapshot) {
            (_a43 = this.get(model.source)) == null ? void 0 : _a43.setDirty(true);
          }
        });
      }
    }
  }
  onDidRunWorkingCopyFileOperation(e) {
    switch (e.operation) {
      case 0:
        e.waitUntil((async () => {
          for (const { target } of e.files) {
            const model = this.get(target);
            if (model && !model.isDisposed()) {
              await model.revert();
            }
          }
        })());
        break;
      case 2:
      case 3:
        e.waitUntil((async () => {
          const modelsToRestore = this.mapCorrelationIdToModelsToRestore.get(e.correlationId);
          if (modelsToRestore) {
            this.mapCorrelationIdToModelsToRestore.delete(e.correlationId);
            await Promises.settled(modelsToRestore.map(async (modelToRestore) => {
              const restoredModel = await this.resolve(modelToRestore.target, {
                reload: { async: false },
                contents: modelToRestore.snapshot ? createTextBufferFactoryFromSnapshot(modelToRestore.snapshot) : void 0,
                encoding: modelToRestore.encoding
              });
              if (modelToRestore.languageId && modelToRestore.languageId !== PLAINTEXT_LANGUAGE_ID && restoredModel.getLanguageId() === PLAINTEXT_LANGUAGE_ID && extname2(modelToRestore.target) !== PLAINTEXT_EXTENSION) {
                restoredModel.updateTextEditorModel(void 0, modelToRestore.languageId);
              }
            }));
          }
        })());
        break;
    }
  }
  get(resource) {
    return this.mapResourceToModel.get(resource);
  }
  has(resource) {
    return this.mapResourceToModel.has(resource);
  }
  async reload(model) {
    await this.joinPendingResolves(model.resource);
    if (model.isDirty() || model.isDisposed() || !this.has(model.resource)) {
      return;
    }
    await this.doResolve(model, { reload: { async: false } });
  }
  async resolve(resource, options) {
    const pendingResolve = this.joinPendingResolves(resource);
    if (pendingResolve) {
      await pendingResolve;
    }
    return this.doResolve(resource, options);
  }
  async doResolve(resourceOrModel, options) {
    let model;
    let resource;
    if (URI.isUri(resourceOrModel)) {
      resource = resourceOrModel;
      model = this.get(resource);
    } else {
      resource = resourceOrModel.resource;
      model = resourceOrModel;
    }
    let modelResolve;
    let didCreateModel = false;
    if (model) {
      if (options == null ? void 0 : options.contents) {
        modelResolve = model.resolve(options);
      } else if (options == null ? void 0 : options.reload) {
        if (options.reload.async) {
          modelResolve = Promise.resolve();
          (async () => {
            try {
              await model.resolve(options);
            } catch (error) {
              onUnexpectedError(error);
            }
          })();
        } else {
          modelResolve = model.resolve(options);
        }
      } else {
        modelResolve = Promise.resolve();
      }
    } else {
      didCreateModel = true;
      const newModel = model = this.instantiationService.createInstance(TextFileEditorModel, resource, options ? options.encoding : void 0, options ? options.languageId : void 0);
      modelResolve = model.resolve(options);
      this.registerModel(newModel);
    }
    this.mapResourceToPendingModelResolvers.set(resource, modelResolve);
    this.add(resource, model);
    if (didCreateModel) {
      this._onDidCreate.fire(model);
      if (model.isDirty()) {
        this._onDidChangeDirty.fire(model);
      }
    }
    try {
      await modelResolve;
    } catch (error) {
      if (didCreateModel) {
        model.dispose();
      }
      throw error;
    } finally {
      this.mapResourceToPendingModelResolvers.delete(resource);
    }
    if (options == null ? void 0 : options.languageId) {
      model.setLanguageId(options.languageId);
    }
    if (didCreateModel && model.isDirty()) {
      this._onDidChangeDirty.fire(model);
    }
    return model;
  }
  joinPendingResolves(resource) {
    const pendingModelResolve = this.mapResourceToPendingModelResolvers.get(resource);
    if (!pendingModelResolve) {
      return;
    }
    return this.doJoinPendingResolves(resource);
  }
  async doJoinPendingResolves(resource) {
    let currentModelCopyResolve;
    while (this.mapResourceToPendingModelResolvers.has(resource)) {
      const nextPendingModelResolve = this.mapResourceToPendingModelResolvers.get(resource);
      if (nextPendingModelResolve === currentModelCopyResolve) {
        return;
      }
      currentModelCopyResolve = nextPendingModelResolve;
      try {
        await nextPendingModelResolve;
      } catch (error) {
      }
    }
  }
  registerModel(model) {
    const modelListeners = new DisposableStore();
    modelListeners.add(model.onDidResolve((reason) => this._onDidResolve.fire({ model, reason })));
    modelListeners.add(model.onDidChangeDirty(() => this._onDidChangeDirty.fire(model)));
    modelListeners.add(model.onDidChangeReadonly(() => this._onDidChangeReadonly.fire(model)));
    modelListeners.add(model.onDidChangeOrphaned(() => this._onDidChangeOrphaned.fire(model)));
    modelListeners.add(model.onDidSaveError(() => this._onDidSaveError.fire(model)));
    modelListeners.add(model.onDidSave((e) => this._onDidSave.fire({ model, ...e })));
    modelListeners.add(model.onDidRevert(() => this._onDidRevert.fire(model)));
    modelListeners.add(model.onDidChangeEncoding(() => this._onDidChangeEncoding.fire(model)));
    this.mapResourceToModelListeners.set(model.resource, modelListeners);
  }
  add(resource, model) {
    const knownModel = this.mapResourceToModel.get(resource);
    if (knownModel === model) {
      return;
    }
    const disposeListener = this.mapResourceToDisposeListener.get(resource);
    disposeListener == null ? void 0 : disposeListener.dispose();
    this.mapResourceToModel.set(resource, model);
    this.mapResourceToDisposeListener.set(resource, model.onWillDispose(() => this.remove(resource)));
  }
  remove(resource) {
    const removed = this.mapResourceToModel.delete(resource);
    const disposeListener = this.mapResourceToDisposeListener.get(resource);
    if (disposeListener) {
      dispose(disposeListener);
      this.mapResourceToDisposeListener.delete(resource);
    }
    const modelListener = this.mapResourceToModelListeners.get(resource);
    if (modelListener) {
      dispose(modelListener);
      this.mapResourceToModelListeners.delete(resource);
    }
    if (removed) {
      this._onDidRemove.fire(resource);
    }
  }
  addSaveParticipant(participant) {
    return this.saveParticipants.addSaveParticipant(participant);
  }
  runSaveParticipants(model, context, token) {
    return this.saveParticipants.participate(model, context, token);
  }
  canDispose(model) {
    if (model.isDisposed() || !this.mapResourceToPendingModelResolvers.has(model.resource) && !model.isDirty()) {
      return true;
    }
    return this.doCanDispose(model);
  }
  async doCanDispose(model) {
    const pendingResolve = this.joinPendingResolves(model.resource);
    if (pendingResolve) {
      await pendingResolve;
      return this.canDispose(model);
    }
    if (model.isDirty()) {
      await Event.toPromise(model.onDidChangeDirty);
      return this.canDispose(model);
    }
    return true;
  }
  dispose() {
    super.dispose();
    this.mapResourceToModel.clear();
    this.mapResourceToPendingModelResolvers.clear();
    dispose(this.mapResourceToDisposeListener.values());
    this.mapResourceToDisposeListener.clear();
    dispose(this.mapResourceToModelListeners.values());
    this.mapResourceToModelListeners.clear();
  }
};
TextFileEditorModelManager = __decorate([
  __param(0, IInstantiationService),
  __param(1, IFileService),
  __param(2, INotificationService),
  __param(3, IWorkingCopyFileService),
  __param(4, IUriIdentityService)
], TextFileEditorModelManager);

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/browser/textFileService.js
init_instantiation();
init_network();
init_textModel();
init_model2();
init_resources();
init_buffer();
init_modesRegistry();
init_codeEditorService();
init_stream();
init_language();
init_log();
init_cancellation();
init_event();
init_codicons();
init_colorRegistry();
init_arrays();

// node_modules/vscode/vscode/src/vs/platform/dialogs/common/dialogs.js
init_resources();
init_nls();
init_instantiation();
var IDialogService = createDecorator("dialogService");
var DialogKind;
(function(DialogKind2) {
  DialogKind2[DialogKind2["Confirmation"] = 1] = "Confirmation";
  DialogKind2[DialogKind2["Prompt"] = 2] = "Prompt";
  DialogKind2[DialogKind2["Input"] = 3] = "Input";
})(DialogKind || (DialogKind = {}));
var IFileDialogService = createDecorator("fileDialogService");
var MAX_CONFIRM_FILES = 10;
function getFileNamesMessage(fileNamesOrResources) {
  const message = [];
  message.push(...fileNamesOrResources.slice(0, MAX_CONFIRM_FILES).map(
    (fileNameOrResource) => typeof fileNameOrResource === "string" ? fileNameOrResource : basename2(fileNameOrResource)
  ));
  if (fileNamesOrResources.length > MAX_CONFIRM_FILES) {
    if (fileNamesOrResources.length - MAX_CONFIRM_FILES === 1) {
      message.push(localize("moreFile", "...1 additional file not shown"));
    } else {
      message.push(localize(
        "moreFiles",
        "...{0} additional files not shown",
        fileNamesOrResources.length - MAX_CONFIRM_FILES
      ));
    }
  }
  message.push("");
  return message.join("\n");
}

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/browser/textFileService.js
var AbstractTextFileService_1;
var _a8;
var AbstractTextFileService = (_a8 = class extends Disposable {
  constructor(fileService, untitledTextEditorService, lifecycleService, instantiationService, modelService, environmentService, dialogService, fileDialogService, textResourceConfigurationService, filesConfigurationService, codeEditorService, pathService, workingCopyFileService, uriIdentityService, languageService, logService, elevatedFileService, decorationsService) {
    super();
    this.fileService = fileService;
    this.untitledTextEditorService = untitledTextEditorService;
    this.lifecycleService = lifecycleService;
    this.instantiationService = instantiationService;
    this.modelService = modelService;
    this.environmentService = environmentService;
    this.dialogService = dialogService;
    this.fileDialogService = fileDialogService;
    this.textResourceConfigurationService = textResourceConfigurationService;
    this.filesConfigurationService = filesConfigurationService;
    this.codeEditorService = codeEditorService;
    this.pathService = pathService;
    this.workingCopyFileService = workingCopyFileService;
    this.uriIdentityService = uriIdentityService;
    this.languageService = languageService;
    this.logService = logService;
    this.elevatedFileService = elevatedFileService;
    this.decorationsService = decorationsService;
    this.files = this._register(this.instantiationService.createInstance(TextFileEditorModelManager));
    this.untitled = this.untitledTextEditorService;
    this.provideDecorations();
  }
  provideDecorations() {
    const provider = this._register(new class extends Disposable {
      constructor(files) {
        super();
        this.files = files;
        this.label = localize("textFileModelDecorations", "Text File Model Decorations");
        this._onDidChange = this._register(new Emitter());
        this.onDidChange = this._onDidChange.event;
        this.registerListeners();
      }
      registerListeners() {
        this._register(this.files.onDidResolve(({ model }) => {
          if (model.isReadonly() || model.hasState(4)) {
            this._onDidChange.fire([model.resource]);
          }
        }));
        this._register(this.files.onDidRemove((modelUri) => this._onDidChange.fire([modelUri])));
        this._register(this.files.onDidChangeReadonly((model) => this._onDidChange.fire([model.resource])));
        this._register(this.files.onDidChangeOrphaned((model) => this._onDidChange.fire([model.resource])));
      }
      provideDecorations(uri) {
        const model = this.files.get(uri);
        if (!model || model.isDisposed()) {
          return void 0;
        }
        const isReadonly = model.isReadonly();
        const isOrphaned = model.hasState(4);
        if (isReadonly && isOrphaned) {
          return {
            color: listErrorForeground,
            letter: Codicon.lockSmall,
            strikethrough: true,
            tooltip: localize("readonlyAndDeleted", "Deleted, Read-only")
          };
        } else if (isReadonly) {
          return {
            letter: Codicon.lockSmall,
            tooltip: localize("readonly", "Read-only")
          };
        } else if (isOrphaned) {
          return {
            color: listErrorForeground,
            strikethrough: true,
            tooltip: localize("deleted", "Deleted")
          };
        }
        return void 0;
      }
    }(this.files));
    this._register(this.decorationsService.registerDecorationsProvider(provider));
  }
  get encoding() {
    if (!this._encoding) {
      this._encoding = this._register(this.instantiationService.createInstance(EncodingOracle));
    }
    return this._encoding;
  }
  async read(resource, options) {
    const [bufferStream, decoder2] = await this.doRead(resource, {
      ...options,
      preferUnbuffered: true
    });
    return {
      ...bufferStream,
      encoding: decoder2.detected.encoding || UTF8,
      value: await consumeStream(decoder2.stream, (strings) => strings.join(""))
    };
  }
  async readStream(resource, options) {
    const [bufferStream, decoder2] = await this.doRead(resource, options);
    return {
      ...bufferStream,
      encoding: decoder2.detected.encoding || UTF8,
      value: await createTextBufferFactoryFromStream(decoder2.stream)
    };
  }
  async doRead(resource, options) {
    const cts = new CancellationTokenSource();
    let bufferStream;
    if (options == null ? void 0 : options.preferUnbuffered) {
      const content = await this.fileService.readFile(resource, options, cts.token);
      bufferStream = {
        ...content,
        value: bufferToStream(content.value)
      };
    } else {
      bufferStream = await this.fileService.readFileStream(resource, options, cts.token);
    }
    try {
      const decoder2 = await this.doGetDecodedStream(resource, bufferStream.value, options);
      return [bufferStream, decoder2];
    } catch (error) {
      cts.dispose(true);
      if (error.decodeStreamErrorKind === 1) {
        throw new TextFileOperationError(localize("fileBinaryError", "File seems to be binary and cannot be opened as text"), 0, options);
      } else {
        throw error;
      }
    }
  }
  async create(operations, undoInfo) {
    const operationsWithContents = await Promise.all(operations.map(async (operation) => {
      var _a43;
      const contents = await this.getEncodedReadable(operation.resource, operation.value);
      return {
        resource: operation.resource,
        contents,
        overwrite: (_a43 = operation.options) == null ? void 0 : _a43.overwrite
      };
    }));
    return this.workingCopyFileService.create(operationsWithContents, CancellationToken.None, undoInfo);
  }
  async write(resource, value, options) {
    const readable = await this.getEncodedReadable(resource, value, options);
    if ((options == null ? void 0 : options.writeElevated) && this.elevatedFileService.isSupported(resource)) {
      return this.elevatedFileService.writeFileElevated(resource, readable, options);
    }
    return this.fileService.writeFile(resource, readable, options);
  }
  async getEncodedReadable(resource, value, options) {
    const { encoding, addBOM } = await this.encoding.getWriteEncoding(resource, options);
    if (encoding === UTF8 && !addBOM) {
      return typeof value === "undefined" ? void 0 : toBufferOrReadable(value);
    }
    value = value || "";
    const snapshot = typeof value === "string" ? stringToSnapshot(value) : value;
    return toEncodeReadable(snapshot, encoding, { addBOM });
  }
  async getDecodedStream(resource, value, options) {
    return (await this.doGetDecodedStream(resource, value, options)).stream;
  }
  doGetDecodedStream(resource, stream, options) {
    return toDecodeStream(stream, {
      acceptTextOnly: (options == null ? void 0 : options.acceptTextOnly) ?? false,
      guessEncoding: (options == null ? void 0 : options.autoGuessEncoding) || this.textResourceConfigurationService.getValue(resource, "files.autoGuessEncoding"),
      overwriteEncoding: async (detectedEncoding) => {
        const { encoding } = await this.encoding.getPreferredReadEncoding(resource, options, detectedEncoding ?? void 0);
        return encoding;
      }
    });
  }
  async save(resource, options) {
    if (resource.scheme === Schemas.untitled) {
      const model = this.untitled.get(resource);
      if (model) {
        let targetUri;
        if (model.hasAssociatedFilePath) {
          targetUri = await this.suggestSavePath(resource);
        } else {
          targetUri = await this.fileDialogService.pickFileToSave(await this.suggestSavePath(resource), options == null ? void 0 : options.availableFileSystems);
        }
        if (targetUri) {
          return this.saveAs(resource, targetUri, options);
        }
      }
    } else {
      const model = this.files.get(resource);
      if (model) {
        return await model.save(options) ? resource : void 0;
      }
    }
    return void 0;
  }
  async saveAs(source, target, options) {
    if (!target) {
      target = await this.fileDialogService.pickFileToSave(await this.suggestSavePath((options == null ? void 0 : options.suggestedTarget) ?? source), options == null ? void 0 : options.availableFileSystems);
    }
    if (!target) {
      return;
    }
    if (isEqual2(source, target)) {
      return this.save(source, { ...options, force: true });
    }
    if (this.fileService.hasProvider(source) && this.uriIdentityService.extUri.isEqual(source, target) && await this.fileService.exists(source)) {
      await this.workingCopyFileService.move([{ file: { source, target } }], CancellationToken.None);
      const success = await this.save(source, options);
      if (!success) {
        await this.save(target, options);
      }
      return target;
    }
    return this.doSaveAs(source, target, options);
  }
  async doSaveAs(source, target, options) {
    let success = false;
    const textFileModel = this.files.get(source);
    if (textFileModel == null ? void 0 : textFileModel.isResolved()) {
      success = await this.doSaveAsTextFile(textFileModel, source, target, options);
    } else if (this.fileService.hasProvider(source)) {
      await this.fileService.copy(source, target, true);
      success = true;
    } else {
      const textModel = this.modelService.getModel(source);
      if (textModel) {
        success = await this.doSaveAsTextFile(textModel, source, target, options);
      }
    }
    if (!success) {
      return void 0;
    }
    try {
      await this.revert(source);
    } catch (error) {
      this.logService.error(error);
    }
    return target;
  }
  async doSaveAsTextFile(sourceModel, source, target, options) {
    let sourceModelEncoding = void 0;
    const sourceModelWithEncodingSupport = sourceModel;
    if (typeof sourceModelWithEncodingSupport.getEncoding === "function") {
      sourceModelEncoding = sourceModelWithEncodingSupport.getEncoding();
    }
    let targetExists = false;
    let targetModel = this.files.get(target);
    if (targetModel == null ? void 0 : targetModel.isResolved()) {
      targetExists = true;
    } else {
      targetExists = await this.fileService.exists(target);
      if (!targetExists) {
        await this.create([{ resource: target, value: "" }]);
      }
      try {
        targetModel = await this.files.resolve(target, { encoding: sourceModelEncoding });
      } catch (error) {
        if (targetExists) {
          if (error.textFileOperationResult === 0 || error.fileOperationResult === 7) {
            await this.fileService.del(target);
            return this.doSaveAsTextFile(sourceModel, source, target, options);
          }
        }
        throw error;
      }
    }
    let write;
    if (sourceModel instanceof UntitledTextEditorModel && sourceModel.hasAssociatedFilePath && targetExists && this.uriIdentityService.extUri.isEqual(target, toLocalResource(sourceModel.resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme))) {
      write = await this.confirmOverwrite(target);
    } else {
      write = true;
    }
    if (!write) {
      return false;
    }
    let sourceTextModel = void 0;
    if (sourceModel instanceof BaseTextEditorModel) {
      if (sourceModel.isResolved()) {
        sourceTextModel = sourceModel.textEditorModel ?? void 0;
      }
    } else {
      sourceTextModel = sourceModel;
    }
    let targetTextModel = void 0;
    if (targetModel.isResolved()) {
      targetTextModel = targetModel.textEditorModel;
    }
    if (sourceTextModel && targetTextModel) {
      targetModel.updatePreferredEncoding(sourceModelEncoding);
      this.modelService.updateModel(targetTextModel, createTextBufferFactoryFromSnapshot(sourceTextModel.createSnapshot()));
      const sourceLanguageId = sourceTextModel.getLanguageId();
      const targetLanguageId = targetTextModel.getLanguageId();
      if (sourceLanguageId !== PLAINTEXT_LANGUAGE_ID && targetLanguageId === PLAINTEXT_LANGUAGE_ID) {
        targetTextModel.setLanguage(sourceLanguageId);
      }
      const sourceTransientProperties = this.codeEditorService.getTransientModelProperties(sourceTextModel);
      if (sourceTransientProperties) {
        for (const [key, value] of sourceTransientProperties) {
          this.codeEditorService.setTransientModelProperty(targetTextModel, key, value);
        }
      }
    }
    if (!(options == null ? void 0 : options.source)) {
      options = {
        ...options,
        source: targetExists ? AbstractTextFileService_1.TEXTFILE_SAVE_REPLACE_SOURCE : AbstractTextFileService_1.TEXTFILE_SAVE_CREATE_SOURCE
      };
    }
    return targetModel.save(options);
  }
  async confirmOverwrite(resource) {
    const { confirmed } = await this.dialogService.confirm({
      type: "warning",
      message: localize(
        "confirmOverwrite",
        "'{0}' already exists. Do you want to replace it?",
        basename2(resource)
      ),
      detail: localize(
        "irreversible",
        "A file or folder with the name '{0}' already exists in the folder '{1}'. Replacing it will overwrite its current contents.",
        basename2(resource),
        basename2(dirname(resource))
      ),
      primaryButton: localize(
        { key: "replaceButtonLabel", comment: ["&& denotes a mnemonic"] },
        "&&Replace"
      )
    });
    return confirmed;
  }
  async suggestSavePath(resource) {
    if (this.fileService.hasProvider(resource)) {
      return resource;
    }
    const remoteAuthority = this.environmentService.remoteAuthority;
    const defaultFilePath = await this.fileDialogService.defaultFilePath();
    let suggestedFilename = void 0;
    if (resource.scheme === Schemas.untitled) {
      const model = this.untitled.get(resource);
      if (model) {
        if (model.hasAssociatedFilePath) {
          return toLocalResource(resource, remoteAuthority, this.pathService.defaultUriScheme);
        }
        let nameCandidate;
        if (await this.pathService.hasValidBasename(joinPath(defaultFilePath, model.name), model.name)) {
          nameCandidate = model.name;
        } else {
          nameCandidate = basename2(resource);
        }
        const languageId = model.getLanguageId();
        if (languageId && languageId !== PLAINTEXT_LANGUAGE_ID) {
          suggestedFilename = this.suggestFilename(languageId, nameCandidate);
        } else {
          suggestedFilename = nameCandidate;
        }
      }
    }
    if (!suggestedFilename) {
      suggestedFilename = basename2(resource);
    }
    return joinPath(defaultFilePath, suggestedFilename);
  }
  suggestFilename(languageId, untitledName) {
    const languageName = this.languageService.getLanguageName(languageId);
    if (!languageName) {
      return untitledName;
    }
    const untitledExtension = extname(untitledName);
    const extensions = this.languageService.getExtensions(languageId);
    if (extensions.includes(untitledExtension)) {
      return untitledName;
    }
    const primaryExtension = firstOrDefault(extensions);
    if (primaryExtension) {
      if (untitledExtension) {
        return `${untitledName.substring(0, untitledName.indexOf(untitledExtension))}${primaryExtension}`;
      }
      return `${untitledName}${primaryExtension}`;
    }
    const filenames = this.languageService.getFilenames(languageId);
    if (filenames.includes(untitledName)) {
      return untitledName;
    }
    return firstOrDefault(filenames) ?? untitledName;
  }
  async revert(resource, options) {
    if (resource.scheme === Schemas.untitled) {
      const model = this.untitled.get(resource);
      if (model) {
        return model.revert(options);
      }
    } else {
      const model = this.files.get(resource);
      if (model && (model.isDirty() || (options == null ? void 0 : options.force))) {
        return model.revert(options);
      }
    }
  }
  isDirty(resource) {
    const model = resource.scheme === Schemas.untitled ? this.untitled.get(resource) : this.files.get(resource);
    if (model) {
      return model.isDirty();
    }
    return false;
  }
}, AbstractTextFileService_1 = _a8, _a8.TEXTFILE_SAVE_CREATE_SOURCE = SaveSourceRegistry.registerSource("textFileCreate.source", localize("textFileCreate.source", "File Created")), _a8.TEXTFILE_SAVE_REPLACE_SOURCE = SaveSourceRegistry.registerSource("textFileOverwrite.source", localize("textFileOverwrite.source", "File Replaced")), _a8);
AbstractTextFileService = AbstractTextFileService_1 = __decorate([
  __param(0, IFileService),
  __param(1, IUntitledTextEditorService),
  __param(2, ILifecycleService),
  __param(3, IInstantiationService),
  __param(4, IModelService),
  __param(5, IWorkbenchEnvironmentService),
  __param(6, IDialogService),
  __param(7, IFileDialogService),
  __param(8, ITextResourceConfigurationService),
  __param(9, IFilesConfigurationService),
  __param(10, ICodeEditorService),
  __param(11, IPathService),
  __param(12, IWorkingCopyFileService),
  __param(13, IUriIdentityService),
  __param(14, ILanguageService),
  __param(15, ILogService),
  __param(16, IElevatedFileService),
  __param(17, IDecorationsService)
], AbstractTextFileService);
var EncodingOracle = class EncodingOracle2 extends Disposable {
  get encodingOverrides() {
    return this._encodingOverrides;
  }
  set encodingOverrides(value) {
    this._encodingOverrides = value;
  }
  constructor(textResourceConfigurationService, environmentService, contextService, uriIdentityService) {
    super();
    this.textResourceConfigurationService = textResourceConfigurationService;
    this.environmentService = environmentService;
    this.contextService = contextService;
    this.uriIdentityService = uriIdentityService;
    this._encodingOverrides = this.getDefaultEncodingOverrides();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.contextService.onDidChangeWorkspaceFolders(() => this.encodingOverrides = this.getDefaultEncodingOverrides()));
  }
  getDefaultEncodingOverrides() {
    const defaultEncodingOverrides = [];
    defaultEncodingOverrides.push({ parent: this.environmentService.userRoamingDataHome, encoding: UTF8 });
    defaultEncodingOverrides.push({ extension: WORKSPACE_EXTENSION, encoding: UTF8 });
    defaultEncodingOverrides.push({ parent: this.environmentService.untitledWorkspacesHome, encoding: UTF8 });
    this.contextService.getWorkspace().folders.forEach((folder) => {
      defaultEncodingOverrides.push({ parent: joinPath(folder.uri, ".vscode"), encoding: UTF8 });
    });
    return defaultEncodingOverrides;
  }
  async getWriteEncoding(resource, options) {
    const { encoding, hasBOM } = await this.getPreferredWriteEncoding(resource, options ? options.encoding : void 0);
    return { encoding, addBOM: hasBOM };
  }
  async getPreferredWriteEncoding(resource, preferredEncoding) {
    const resourceEncoding = await this.getEncodingForResource(resource, preferredEncoding);
    return {
      encoding: resourceEncoding,
      hasBOM: resourceEncoding === UTF16be || resourceEncoding === UTF16le || resourceEncoding === UTF8_with_bom
    };
  }
  async getPreferredReadEncoding(resource, options, detectedEncoding) {
    let preferredEncoding;
    if (options == null ? void 0 : options.encoding) {
      if (detectedEncoding === UTF8_with_bom && options.encoding === UTF8) {
        preferredEncoding = UTF8_with_bom;
      } else {
        preferredEncoding = options.encoding;
      }
    } else if (typeof detectedEncoding === "string") {
      preferredEncoding = detectedEncoding;
    } else if (this.textResourceConfigurationService.getValue(resource, "files.encoding") === UTF8_with_bom) {
      preferredEncoding = UTF8;
    }
    const encoding = await this.getEncodingForResource(resource, preferredEncoding);
    return {
      encoding,
      hasBOM: encoding === UTF16be || encoding === UTF16le || encoding === UTF8_with_bom
    };
  }
  async getEncodingForResource(resource, preferredEncoding) {
    let fileEncoding;
    const override = this.getEncodingOverride(resource);
    if (override) {
      fileEncoding = override;
    } else if (preferredEncoding) {
      fileEncoding = preferredEncoding;
    } else {
      fileEncoding = this.textResourceConfigurationService.getValue(resource, "files.encoding");
    }
    if (fileEncoding !== UTF8) {
      if (!fileEncoding || !await encodingExists(fileEncoding)) {
        fileEncoding = UTF8;
      }
    }
    return fileEncoding;
  }
  getEncodingOverride(resource) {
    var _a43;
    if ((_a43 = this.encodingOverrides) == null ? void 0 : _a43.length) {
      for (const override of this.encodingOverrides) {
        if (override.parent && this.uriIdentityService.extUri.isEqualOrParent(resource, override.parent)) {
          return override.encoding;
        }
        if (override.extension && extname2(resource) === `.${override.extension}`) {
          return override.encoding;
        }
      }
    }
    return void 0;
  }
};
EncodingOracle = __decorate([
  __param(0, ITextResourceConfigurationService),
  __param(1, IWorkbenchEnvironmentService),
  __param(2, IWorkspaceContextService),
  __param(3, IUriIdentityService)
], EncodingOracle);

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/browser/browserTextFileService.js
init_codeEditorService();
init_model2();
init_language();
init_files();
init_instantiation();
init_log();
var BrowserTextFileService = class BrowserTextFileService2 extends AbstractTextFileService {
  constructor(fileService, untitledTextEditorService, lifecycleService, instantiationService, modelService, environmentService, dialogService, fileDialogService, textResourceConfigurationService, filesConfigurationService, codeEditorService, pathService, workingCopyFileService, uriIdentityService, languageService, elevatedFileService, logService, decorationsService) {
    super(fileService, untitledTextEditorService, lifecycleService, instantiationService, modelService, environmentService, dialogService, fileDialogService, textResourceConfigurationService, filesConfigurationService, codeEditorService, pathService, workingCopyFileService, uriIdentityService, languageService, logService, elevatedFileService, decorationsService);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.lifecycleService.onBeforeShutdown((event) => event.veto(this.onBeforeShutdown(), "veto.textFiles")));
  }
  onBeforeShutdown() {
    if (this.files.models.some((model) => model.hasState(2))) {
      return true;
    }
    return false;
  }
};
BrowserTextFileService = __decorate([
  __param(0, IFileService),
  __param(1, IUntitledTextEditorService),
  __param(2, ILifecycleService),
  __param(3, IInstantiationService),
  __param(4, IModelService),
  __param(5, IWorkbenchEnvironmentService),
  __param(6, IDialogService),
  __param(7, IFileDialogService),
  __param(8, ITextResourceConfigurationService),
  __param(9, IFilesConfigurationService),
  __param(10, ICodeEditorService),
  __param(11, IPathService),
  __param(12, IWorkingCopyFileService),
  __param(13, IUriIdentityService),
  __param(14, ILanguageService),
  __param(15, IElevatedFileService),
  __param(16, ILogService),
  __param(17, IDecorationsService)
], BrowserTextFileService);

// node_modules/vscode/vscode/src/vs/workbench/services/decorations/browser/decorationsService.js
init_tslib_es6();
init_event();
init_ternarySearchTree();
init_lifecycle();
init_async();
init_linkedList();
init_dom();
init_themeService();
init_themables();
init_strings();
init_nls();
init_errors();
init_cancellation();
init_hash();
init_arrays();
init_colorRegistry();
var _DecorationRule = class _DecorationRule {
  static keyOf(data) {
    if (Array.isArray(data)) {
      return data.map(_DecorationRule.keyOf).join(",");
    } else {
      const { color, letter } = data;
      if (ThemeIcon.isThemeIcon(letter)) {
        return `${color}+${letter.id}`;
      } else {
        return `${color}/${letter}`;
      }
    }
  }
  constructor(themeService, data, key) {
    this.themeService = themeService;
    this._refCounter = 0;
    this.data = data;
    const suffix = hash(key).toString(36);
    this.itemColorClassName = `${_DecorationRule._classNamesPrefix}-itemColor-${suffix}`;
    this.itemBadgeClassName = `${_DecorationRule._classNamesPrefix}-itemBadge-${suffix}`;
    this.bubbleBadgeClassName = `${_DecorationRule._classNamesPrefix}-bubbleBadge-${suffix}`;
    this.iconBadgeClassName = `${_DecorationRule._classNamesPrefix}-iconBadge-${suffix}`;
  }
  acquire() {
    this._refCounter += 1;
  }
  release() {
    return --this._refCounter === 0;
  }
  appendCSSRules(element) {
    if (!Array.isArray(this.data)) {
      this._appendForOne(this.data, element);
    } else {
      this._appendForMany(this.data, element);
    }
  }
  _appendForOne(data, element) {
    const { color, letter } = data;
    createCSSRule(`.${this.itemColorClassName}`, `color: ${getColor(color)};`, element);
    if (ThemeIcon.isThemeIcon(letter)) {
      this._createIconCSSRule(letter, color, element);
    } else if (letter) {
      createCSSRule(`.${this.itemBadgeClassName}::after`, `content: "${letter}"; color: ${getColor(color)};`, element);
    }
  }
  _appendForMany(data, element) {
    const { color } = data[0];
    createCSSRule(`.${this.itemColorClassName}`, `color: ${getColor(color)};`, element);
    const letters = [];
    let icon;
    for (const d of data) {
      if (ThemeIcon.isThemeIcon(d.letter)) {
        icon = d.letter;
        break;
      } else if (d.letter) {
        letters.push(d.letter);
      }
    }
    if (icon) {
      this._createIconCSSRule(icon, color, element);
    } else {
      if (letters.length) {
        createCSSRule(`.${this.itemBadgeClassName}::after`, `content: "${letters.join(", ")}"; color: ${getColor(color)};`, element);
      }
      createCSSRule(`.${this.bubbleBadgeClassName}::after`, `content: ""; color: ${getColor(color)}; font-family: codicon; font-size: 14px; margin-right: 14px; opacity: 0.4;`, element);
    }
  }
  _createIconCSSRule(icon, color, element) {
    var _a43;
    const modifier = ThemeIcon.getModifier(icon);
    if (modifier) {
      icon = ThemeIcon.modify(icon, void 0);
    }
    const iconContribution = getIconRegistry().getIcon(icon.id);
    if (!iconContribution) {
      return;
    }
    const definition = this.themeService.getProductIconTheme().getIcon(iconContribution);
    if (!definition) {
      return;
    }
    createCSSRule(`.${this.iconBadgeClassName}::after`, `content: '${definition.fontCharacter}';
			color: ${icon.color ? getColor(icon.color.id) : getColor(color)};
			font-family: ${asCSSPropertyValue(((_a43 = definition.font) == null ? void 0 : _a43.id) ?? "codicon")};
			font-size: 16px;
			margin-right: 14px;
			font-weight: normal;
			${modifier === "spin" ? "animation: codicon-spin 1.5s steps(30) infinite" : ""};
			`, element);
  }
  removeCSSRules(element) {
    removeCSSRulesContainingSelector(this.itemColorClassName, element);
    removeCSSRulesContainingSelector(this.itemBadgeClassName, element);
    removeCSSRulesContainingSelector(this.bubbleBadgeClassName, element);
    removeCSSRulesContainingSelector(this.iconBadgeClassName, element);
  }
};
_DecorationRule._classNamesPrefix = "monaco-decoration";
var DecorationRule = _DecorationRule;
var DecorationStyles = class {
  constructor(_themeService) {
    this._themeService = _themeService;
    this._styleElement = createStyleSheet();
    this._decorationRules = /* @__PURE__ */ new Map();
    this._dispoables = new DisposableStore();
  }
  dispose() {
    this._dispoables.dispose();
    this._styleElement.remove();
  }
  asDecoration(data, onlyChildren) {
    data.sort((a, b) => (b.weight || 0) - (a.weight || 0));
    const key = DecorationRule.keyOf(data);
    let rule = this._decorationRules.get(key);
    if (!rule) {
      rule = new DecorationRule(this._themeService, data, key);
      this._decorationRules.set(key, rule);
      rule.appendCSSRules(this._styleElement);
    }
    rule.acquire();
    const labelClassName = rule.itemColorClassName;
    let badgeClassName = rule.itemBadgeClassName;
    const iconClassName = rule.iconBadgeClassName;
    let tooltip = distinct(data.filter((d) => !isFalsyOrWhitespace(d.tooltip)).map((d) => d.tooltip)).join("  ");
    const strikethrough = data.some((d) => d.strikethrough);
    if (onlyChildren) {
      badgeClassName = rule.bubbleBadgeClassName;
      tooltip = localize("bubbleTitle", "Contains emphasized items");
    }
    return {
      labelClassName,
      badgeClassName,
      iconClassName,
      strikethrough,
      tooltip,
      dispose: () => {
        if (rule == null ? void 0 : rule.release()) {
          this._decorationRules.delete(key);
          rule.removeCSSRules(this._styleElement);
          rule = void 0;
        }
      }
    };
  }
};
var FileDecorationChangeEvent = class {
  constructor(all) {
    this._data = TernarySearchTree.forUris((_uri) => true);
    this._data.fill(true, asArray(all));
  }
  affectsResource(uri) {
    return this._data.hasElementOrSubtree(uri);
  }
};
var DecorationDataRequest = class {
  constructor(source, thenable) {
    this.source = source;
    this.thenable = thenable;
  }
};
function getColor(color) {
  return color ? asCssVariable(color) : "inherit";
}
var DecorationsService = class DecorationsService2 {
  constructor(uriIdentityService, themeService) {
    this._onDidChangeDecorationsDelayed = new DebounceEmitter({ merge: (all) => all.flat() });
    this._onDidChangeDecorations = new Emitter();
    this.onDidChangeDecorations = this._onDidChangeDecorations.event;
    this._provider = new LinkedList();
    this._decorationStyles = new DecorationStyles(themeService);
    this._data = TernarySearchTree.forUris((key) => uriIdentityService.extUri.ignorePathCasing(key));
    this._onDidChangeDecorationsDelayed.event((event) => {
      this._onDidChangeDecorations.fire(new FileDecorationChangeEvent(event));
    });
  }
  dispose() {
    this._onDidChangeDecorations.dispose();
    this._onDidChangeDecorationsDelayed.dispose();
  }
  registerDecorationsProvider(provider) {
    const rm = this._provider.unshift(provider);
    this._onDidChangeDecorations.fire({
      affectsResource() {
        return true;
      }
    });
    const removeAll = () => {
      const uris = [];
      for (const [uri, map] of this._data) {
        if (map.delete(provider)) {
          uris.push(uri);
        }
      }
      if (uris.length > 0) {
        this._onDidChangeDecorationsDelayed.fire(uris);
      }
    };
    const listener = provider.onDidChange((uris) => {
      if (!uris) {
        removeAll();
      } else {
        for (const uri of uris) {
          const map = this._ensureEntry(uri);
          this._fetchData(map, uri, provider);
        }
      }
    });
    return toDisposable(() => {
      rm();
      listener.dispose();
      removeAll();
    });
  }
  _ensureEntry(uri) {
    let map = this._data.get(uri);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      this._data.set(uri, map);
    }
    return map;
  }
  getDecoration(uri, includeChildren) {
    const all = [];
    let containsChildren = false;
    const map = this._ensureEntry(uri);
    for (const provider of this._provider) {
      let data = map.get(provider);
      if (data === void 0) {
        data = this._fetchData(map, uri, provider);
      }
      if (data && !(data instanceof DecorationDataRequest)) {
        all.push(data);
      }
    }
    if (includeChildren) {
      const iter = this._data.findSuperstr(uri);
      if (iter) {
        for (const tuple of iter) {
          for (const data of tuple[1].values()) {
            if (data && !(data instanceof DecorationDataRequest)) {
              if (data.bubble) {
                all.push(data);
                containsChildren = true;
              }
            }
          }
        }
      }
    }
    return all.length === 0 ? void 0 : this._decorationStyles.asDecoration(all, containsChildren);
  }
  _fetchData(map, uri, provider) {
    const pendingRequest = map.get(provider);
    if (pendingRequest instanceof DecorationDataRequest) {
      pendingRequest.source.cancel();
      map.delete(provider);
    }
    const source = new CancellationTokenSource();
    const dataOrThenable = provider.provideDecorations(uri, source.token);
    if (!isThenable(dataOrThenable)) {
      return this._keepItem(map, provider, uri, dataOrThenable);
    } else {
      const request2 = new DecorationDataRequest(source, Promise.resolve(dataOrThenable).then((data) => {
        if (map.get(provider) === request2) {
          this._keepItem(map, provider, uri, data);
        }
      }).catch((err) => {
        if (!isCancellationError(err) && map.get(provider) === request2) {
          map.delete(provider);
        }
      }));
      map.set(provider, request2);
      return null;
    }
  }
  _keepItem(map, provider, uri, data) {
    const deco = data ? data : null;
    const old = map.get(provider);
    map.set(provider, deco);
    if (deco || old) {
      this._onDidChangeDecorationsDelayed.fire(uri);
    }
    return deco;
  }
};
DecorationsService = __decorate([
  __param(0, IUriIdentityService),
  __param(1, IThemeService)
], DecorationsService);

// node_modules/vscode/vscode/src/vs/platform/uriIdentity/common/uriIdentityService.js
init_tslib_es6();
init_files();
init_resources();

// node_modules/vscode/vscode/src/vs/base/common/skipList.js
var _a9;
var Node = class {
  constructor(level, key, value) {
    this.level = level;
    this.key = key;
    this.value = value;
    this.forward = [];
  }
};
var NIL = void 0;
var SkipList = class _SkipList {
  constructor(comparator, capacity = 2 ** 16) {
    this.comparator = comparator;
    this[_a9] = "SkipList";
    this._level = 0;
    this._size = 0;
    this._maxLevel = Math.max(1, Math.log2(capacity) | 0);
    this._header = new Node(this._maxLevel, NIL, NIL);
  }
  get size() {
    return this._size;
  }
  clear() {
    this._header = new Node(this._maxLevel, NIL, NIL);
  }
  has(key) {
    return Boolean(_SkipList._search(this, key, this.comparator));
  }
  get(key) {
    var _a43;
    return (_a43 = _SkipList._search(this, key, this.comparator)) == null ? void 0 : _a43.value;
  }
  set(key, value) {
    if (_SkipList._insert(this, key, value, this.comparator)) {
      this._size += 1;
    }
    return this;
  }
  delete(key) {
    const didDelete = _SkipList._delete(this, key, this.comparator);
    if (didDelete) {
      this._size -= 1;
    }
    return didDelete;
  }
  forEach(callbackfn, thisArg) {
    let node = this._header.forward[0];
    while (node) {
      callbackfn.call(thisArg, node.value, node.key, this);
      node = node.forward[0];
    }
  }
  [(_a9 = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  *entries() {
    let node = this._header.forward[0];
    while (node) {
      yield [node.key, node.value];
      node = node.forward[0];
    }
  }
  *keys() {
    let node = this._header.forward[0];
    while (node) {
      yield node.key;
      node = node.forward[0];
    }
  }
  *values() {
    let node = this._header.forward[0];
    while (node) {
      yield node.value;
      node = node.forward[0];
    }
  }
  toString() {
    let result = "[SkipList]:";
    let node = this._header.forward[0];
    while (node) {
      result += `node(${node.key}, ${node.value}, lvl:${node.level})`;
      node = node.forward[0];
    }
    return result;
  }
  static _search(list, searchKey, comparator) {
    let x = list._header;
    for (let i = list._level - 1; i >= 0; i--) {
      while (x.forward[i] && comparator(x.forward[i].key, searchKey) < 0) {
        x = x.forward[i];
      }
    }
    x = x.forward[0];
    if (x && comparator(x.key, searchKey) === 0) {
      return x;
    }
    return void 0;
  }
  static _insert(list, searchKey, value, comparator) {
    const update = [];
    let x = list._header;
    for (let i = list._level - 1; i >= 0; i--) {
      while (x.forward[i] && comparator(x.forward[i].key, searchKey) < 0) {
        x = x.forward[i];
      }
      update[i] = x;
    }
    x = x.forward[0];
    if (x && comparator(x.key, searchKey) === 0) {
      x.value = value;
      return false;
    } else {
      const lvl = _SkipList._randomLevel(list);
      if (lvl > list._level) {
        for (let i = list._level; i < lvl; i++) {
          update[i] = list._header;
        }
        list._level = lvl;
      }
      x = new Node(lvl, searchKey, value);
      for (let i = 0; i < lvl; i++) {
        x.forward[i] = update[i].forward[i];
        update[i].forward[i] = x;
      }
      return true;
    }
  }
  static _randomLevel(list, p = 0.5) {
    let lvl = 1;
    while (Math.random() < p && lvl < list._maxLevel) {
      lvl += 1;
    }
    return lvl;
  }
  static _delete(list, searchKey, comparator) {
    const update = [];
    let x = list._header;
    for (let i = list._level - 1; i >= 0; i--) {
      while (x.forward[i] && comparator(x.forward[i].key, searchKey) < 0) {
        x = x.forward[i];
      }
      update[i] = x;
    }
    x = x.forward[0];
    if (!x || comparator(x.key, searchKey) !== 0) {
      return false;
    }
    for (let i = 0; i < list._level; i++) {
      if (update[i].forward[i] !== x) {
        break;
      }
      update[i].forward[i] = x.forward[i];
    }
    while (list._level > 0 && list._header.forward[list._level - 1] === NIL) {
      list._level -= 1;
    }
    return true;
  }
};

// node_modules/vscode/vscode/src/vs/platform/uriIdentity/common/uriIdentityService.js
init_event();
init_lifecycle();
var _Entry = class _Entry {
  constructor(uri) {
    this.uri = uri;
    this.time = _Entry._clock++;
  }
  touch() {
    this.time = _Entry._clock++;
    return this;
  }
};
_Entry._clock = 0;
var Entry = _Entry;
var UriIdentityService = class UriIdentityService2 {
  constructor(_fileService) {
    this._fileService = _fileService;
    this._dispooables = new DisposableStore();
    this._limit = 2 ** 16;
    const schemeIgnoresPathCasingCache = /* @__PURE__ */ new Map();
    const ignorePathCasing = (uri) => {
      let ignorePathCasing2 = schemeIgnoresPathCasingCache.get(uri.scheme);
      if (ignorePathCasing2 === void 0) {
        ignorePathCasing2 = _fileService.hasProvider(uri) && !this._fileService.hasCapability(uri, 1024);
        schemeIgnoresPathCasingCache.set(uri.scheme, ignorePathCasing2);
      }
      return ignorePathCasing2;
    };
    this._dispooables.add(Event.any(_fileService.onDidChangeFileSystemProviderRegistrations, _fileService.onDidChangeFileSystemProviderCapabilities)((e) => {
      schemeIgnoresPathCasingCache.delete(e.scheme);
    }));
    this.extUri = new ExtUri(ignorePathCasing);
    this._canonicalUris = new SkipList((a, b) => this.extUri.compare(a, b, true), this._limit);
  }
  dispose() {
    this._dispooables.dispose();
    this._canonicalUris.clear();
  }
  asCanonicalUri(uri) {
    if (this._fileService.hasProvider(uri)) {
      uri = normalizePath(uri);
    }
    const item = this._canonicalUris.get(uri);
    if (item) {
      return item.touch().uri.with({ fragment: uri.fragment });
    }
    this._canonicalUris.set(uri, new Entry(uri));
    this._checkTrim();
    return uri;
  }
  _checkTrim() {
    if (this._canonicalUris.size < this._limit) {
      return;
    }
    const entries = [...this._canonicalUris.entries()].sort((a, b) => {
      if (a[1].time < b[1].time) {
        return 1;
      } else if (a[1].time > b[1].time) {
        return -1;
      } else {
        return 0;
      }
    });
    Entry._clock = 0;
    this._canonicalUris.clear();
    const newSize = this._limit * 0.5;
    for (let i = 0; i < newSize; i++) {
      this._canonicalUris.set(entries[i][0], entries[i][1].touch());
    }
  }
};
UriIdentityService = __decorate([
  __param(0, IFileService)
], UriIdentityService);

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/common/jsonEditing.js
init_instantiation();
var IJSONEditingService = createDecorator("jsonEditingService");
var JSONEditingError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/common/jsonEditingService.js
init_tslib_es6();
init_nls();

// node_modules/vscode/vscode/src/vs/base/common/jsonFormatter.js
function format(documentText, range, options) {
  let initialIndentLevel;
  let formatText;
  let formatTextStart;
  let rangeStart;
  let rangeEnd;
  if (range) {
    rangeStart = range.offset;
    rangeEnd = rangeStart + range.length;
    formatTextStart = rangeStart;
    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
      formatTextStart--;
    }
    let endOffset = rangeEnd;
    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
      endOffset++;
    }
    formatText = documentText.substring(formatTextStart, endOffset);
    initialIndentLevel = computeIndentLevel(formatText, options);
  } else {
    formatText = documentText;
    initialIndentLevel = 0;
    formatTextStart = 0;
    rangeStart = 0;
    rangeEnd = documentText.length;
  }
  const eol = getEOL(options, documentText);
  let lineBreak = false;
  let indentLevel = 0;
  let indentValue;
  if (options.insertSpaces) {
    indentValue = repeat(" ", options.tabSize || 4);
  } else {
    indentValue = "	";
  }
  const scanner = createScanner(formatText, false);
  let hasError = false;
  function newLineAndIndent() {
    return eol + repeat(indentValue, initialIndentLevel + indentLevel);
  }
  function scanNext() {
    let token = scanner.scan();
    lineBreak = false;
    while (token === 15 || token === 14) {
      lineBreak = lineBreak || token === 14;
      token = scanner.scan();
    }
    hasError = token === 16 || scanner.getTokenError() !== 0;
    return token;
  }
  const editOperations = [];
  function addEdit(text, startOffset, endOffset) {
    if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {
      editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
    }
  }
  let firstToken = scanNext();
  if (firstToken !== 17) {
    const firstTokenStart = scanner.getTokenOffset() + formatTextStart;
    const initialIndent = repeat(indentValue, initialIndentLevel);
    addEdit(initialIndent, formatTextStart, firstTokenStart);
  }
  while (firstToken !== 17) {
    let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
    let secondToken = scanNext();
    let replaceContent = "";
    while (!lineBreak && (secondToken === 12 || secondToken === 13)) {
      const commentTokenStart = scanner.getTokenOffset() + formatTextStart;
      addEdit(" ", firstTokenEnd, commentTokenStart);
      firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
      replaceContent = secondToken === 12 ? newLineAndIndent() : "";
      secondToken = scanNext();
    }
    if (secondToken === 2) {
      if (firstToken !== 1) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else if (secondToken === 4) {
      if (firstToken !== 3) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else {
      switch (firstToken) {
        case 3:
        case 1:
          indentLevel++;
          replaceContent = newLineAndIndent();
          break;
        case 5:
        case 12:
          replaceContent = newLineAndIndent();
          break;
        case 13:
          if (lineBreak) {
            replaceContent = newLineAndIndent();
          } else {
            replaceContent = " ";
          }
          break;
        case 6:
          replaceContent = " ";
          break;
        case 10:
          if (secondToken === 6) {
            replaceContent = "";
            break;
          }
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          if (secondToken === 12 || secondToken === 13) {
            replaceContent = " ";
          } else if (secondToken !== 5 && secondToken !== 17) {
            hasError = true;
          }
          break;
        case 16:
          hasError = true;
          break;
      }
      if (lineBreak && (secondToken === 12 || secondToken === 13)) {
        replaceContent = newLineAndIndent();
      }
    }
    const secondTokenStart = scanner.getTokenOffset() + formatTextStart;
    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
    firstToken = secondToken;
  }
  return editOperations;
}
function repeat(s, count) {
  let result = "";
  for (let i = 0; i < count; i++) {
    result += s;
  }
  return result;
}
function computeIndentLevel(content, options) {
  let i = 0;
  let nChars = 0;
  const tabSize = options.tabSize || 4;
  while (i < content.length) {
    const ch = content.charAt(i);
    if (ch === " ") {
      nChars++;
    } else if (ch === "	") {
      nChars += tabSize;
    } else {
      break;
    }
    i++;
  }
  return Math.floor(nChars / tabSize);
}
function getEOL(options, text) {
  for (let i = 0; i < text.length; i++) {
    const ch = text.charAt(i);
    if (ch === "\r") {
      if (i + 1 < text.length && text.charAt(i + 1) === "\n") {
        return "\r\n";
      }
      return "\r";
    } else if (ch === "\n") {
      return "\n";
    }
  }
  return options && options.eol || "\n";
}
function isEOL(text, offset) {
  return "\r\n".indexOf(text.charAt(offset)) !== -1;
}

// node_modules/vscode/vscode/src/vs/base/common/jsonEdit.js
function removeProperty(text, path, formattingOptions) {
  return setProperty(text, path, void 0, formattingOptions);
}
function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {
  const path = originalPath.slice();
  const errors = [];
  const root = parseTree(text, errors);
  let parent = void 0;
  let lastSegment = void 0;
  while (path.length > 0) {
    lastSegment = path.pop();
    parent = findNodeAtLocation(root, path);
    if (parent === void 0 && value !== void 0) {
      if (typeof lastSegment === "string") {
        value = { [lastSegment]: value };
      } else {
        value = [value];
      }
    } else {
      break;
    }
  }
  if (!parent) {
    if (value === void 0) {
      throw new Error("Can not delete in empty document");
    }
    return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);
  } else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
    const existing = findNodeAtLocation(parent, [lastSegment]);
    if (existing !== void 0) {
      if (value === void 0) {
        if (!existing.parent) {
          throw new Error("Malformed AST");
        }
        const propertyIndex = parent.children.indexOf(existing.parent);
        let removeBegin;
        let removeEnd = existing.parent.offset + existing.parent.length;
        if (propertyIndex > 0) {
          const previous = parent.children[propertyIndex - 1];
          removeBegin = previous.offset + previous.length;
        } else {
          removeBegin = parent.offset + 1;
          if (parent.children.length > 1) {
            const next = parent.children[1];
            removeEnd = next.offset;
          }
        }
        return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: "" }, formattingOptions);
      } else {
        return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);
      }
    } else {
      if (value === void 0) {
        return [];
      }
      const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;
      const index = getInsertionIndex ? getInsertionIndex(parent.children.map((p) => p.children[0].value)) : parent.children.length;
      let edit;
      if (index > 0) {
        const previous = parent.children[index - 1];
        edit = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      } else if (parent.children.length === 0) {
        edit = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        edit = { offset: parent.offset + 1, length: 0, content: newProperty + "," };
      }
      return withFormatting(text, edit, formattingOptions);
    }
  } else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
    if (value !== void 0) {
      const newProperty = `${JSON.stringify(value)}`;
      let edit;
      if (parent.children.length === 0 || lastSegment === 0) {
        edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + "," };
      } else {
        const index = lastSegment === -1 || lastSegment > parent.children.length ? parent.children.length : lastSegment;
        const previous = parent.children[index - 1];
        edit = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit, formattingOptions);
    } else {
      const removalIndex = lastSegment;
      const toRemove = parent.children[removalIndex];
      let edit;
      if (parent.children.length === 1) {
        edit = { offset: parent.offset + 1, length: parent.length - 2, content: "" };
      } else if (parent.children.length - 1 === removalIndex) {
        const previous = parent.children[removalIndex - 1];
        const offset = previous.offset + previous.length;
        const parentEndOffset = parent.offset + parent.length;
        edit = { offset, length: parentEndOffset - 2 - offset, content: "" };
      } else {
        edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: "" };
      }
      return withFormatting(text, edit, formattingOptions);
    }
  } else {
    throw new Error(`Can not add ${typeof lastSegment !== "number" ? "index" : "property"} to parent of type ${parent.type}`);
  }
}
function withFormatting(text, edit, formattingOptions) {
  let newText = applyEdit(text, edit);
  let begin = edit.offset;
  let end = edit.offset + edit.content.length;
  if (edit.length === 0 || edit.content.length === 0) {
    while (begin > 0 && !isEOL(newText, begin - 1)) {
      begin--;
    }
    while (end < newText.length && !isEOL(newText, end)) {
      end++;
    }
  }
  const edits = format(newText, { offset: begin, length: end - begin }, formattingOptions);
  for (let i = edits.length - 1; i >= 0; i--) {
    const curr = edits[i];
    newText = applyEdit(newText, curr);
    begin = Math.min(begin, curr.offset);
    end = Math.max(end, curr.offset + curr.length);
    end += curr.content.length - curr.length;
  }
  const editLength = text.length - (newText.length - end) - begin;
  return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit) {
  return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
}
function applyEdits(text, edits) {
  const sortedEdits = edits.slice(0).sort((a, b) => {
    const diff = a.offset - b.offset;
    if (diff === 0) {
      return a.length - b.length;
    }
    return diff;
  });
  let lastModifiedOffset = text.length;
  for (let i = sortedEdits.length - 1; i >= 0; i--) {
    const e = sortedEdits[i];
    if (e.offset + e.length <= lastModifiedOffset) {
      text = applyEdit(text, e);
    } else {
      throw new Error("Overlapping edit");
    }
    lastModifiedOffset = e.offset;
  }
  return text;
}

// node_modules/vscode/vscode/src/vs/workbench/services/configuration/common/jsonEditingService.js
init_async();
init_editOperation();
init_range();
init_selection();
init_files();
init_resolverService();
var JSONEditingService = class JSONEditingService2 {
  constructor(fileService, textModelResolverService, textFileService) {
    this.fileService = fileService;
    this.textModelResolverService = textModelResolverService;
    this.textFileService = textFileService;
    this.queue = new Queue();
  }
  write(resource, values) {
    return Promise.resolve(this.queue.queue(() => this.doWriteConfiguration(resource, values)));
  }
  async doWriteConfiguration(resource, values) {
    const reference = await this.resolveAndValidate(resource, true);
    try {
      await this.writeToBuffer(reference.object.textEditorModel, values);
    } finally {
      reference.dispose();
    }
  }
  async writeToBuffer(model, values) {
    let hasEdits = false;
    for (const value of values) {
      const edit = this.getEdits(model, value)[0];
      hasEdits = !!edit && this.applyEditsToBuffer(edit, model);
    }
    if (hasEdits) {
      return this.textFileService.save(model.uri);
    }
  }
  applyEditsToBuffer(edit, model) {
    const startPosition = model.getPositionAt(edit.offset);
    const endPosition = model.getPositionAt(edit.offset + edit.length);
    const range = new Range(
      startPosition.lineNumber,
      startPosition.column,
      endPosition.lineNumber,
      endPosition.column
    );
    const currentText = model.getValueInRange(range);
    if (edit.content !== currentText) {
      const editOperation = currentText ? EditOperation.replace(range, edit.content) : EditOperation.insert(startPosition, edit.content);
      model.pushEditOperations([new Selection(
        startPosition.lineNumber,
        startPosition.column,
        startPosition.lineNumber,
        startPosition.column
      )], [editOperation], () => []);
      return true;
    }
    return false;
  }
  getEdits(model, configurationValue) {
    const { tabSize, insertSpaces } = model.getOptions();
    const eol = model.getEOL();
    const { path, value } = configurationValue;
    if (!path.length) {
      const content = JSON.stringify(value, null, insertSpaces ? " ".repeat(tabSize) : "	");
      return [{
        content,
        length: content.length,
        offset: 0
      }];
    }
    return setProperty(model.getValue(), path, value, { tabSize, insertSpaces, eol });
  }
  async resolveModelReference(resource) {
    const exists = await this.fileService.exists(resource);
    if (!exists) {
      await this.textFileService.write(resource, "{}", { encoding: "utf8" });
    }
    return this.textModelResolverService.createModelReference(resource);
  }
  hasParseErrors(model) {
    const parseErrors = [];
    parse2(model.getValue(), parseErrors, { allowTrailingComma: true, allowEmptyContent: true });
    return parseErrors.length > 0;
  }
  async resolveAndValidate(resource, checkDirty) {
    const reference = await this.resolveModelReference(resource);
    const model = reference.object.textEditorModel;
    if (this.hasParseErrors(model)) {
      reference.dispose();
      return this.reject(0);
    }
    return reference;
  }
  reject(code) {
    const message = this.toErrorMessage(code);
    return Promise.reject(new JSONEditingError(message, code));
  }
  toErrorMessage(error) {
    switch (error) {
      case 0: {
        return localize(
          "errorInvalidFile",
          "Unable to write into the file. Please open the file to correct errors/warnings in the file and try again."
        );
      }
    }
  }
};
JSONEditingService = __decorate([
  __param(0, IFileService),
  __param(1, ITextModelService),
  __param(2, ITextFileService)
], JSONEditingService);

// node_modules/vscode/vscode/src/vs/platform/workspaces/common/workspaces.js
init_extpath();
init_network();
init_path();
init_platform();
init_resources();
init_uri();
init_instantiation();
init_remoteHosts();
var IWorkspacesService = createDecorator("workspacesService");
function isRecentWorkspace(curr) {
  return curr.hasOwnProperty("workspace");
}
function isRecentFolder(curr) {
  return curr.hasOwnProperty("folderUri");
}
function isRecentFile(curr) {
  return curr.hasOwnProperty("fileUri");
}
function isStoredWorkspaceFolder(obj) {
  return isRawFileWorkspaceFolder(obj) || isRawUriWorkspaceFolder(obj);
}
function isRawFileWorkspaceFolder(obj) {
  const candidate = obj;
  return typeof (candidate == null ? void 0 : candidate.path) === "string" && (!candidate.name || typeof candidate.name === "string");
}
function isRawUriWorkspaceFolder(obj) {
  const candidate = obj;
  return typeof (candidate == null ? void 0 : candidate.uri) === "string" && (!candidate.name || typeof candidate.name === "string");
}
function getStoredWorkspaceFolder(folderURI, forceAbsolute, folderName, targetConfigFolderURI, extUri2) {
  if (folderURI.scheme !== targetConfigFolderURI.scheme) {
    return { name: folderName, uri: folderURI.toString(true) };
  }
  let folderPath = !forceAbsolute ? extUri2.relativePath(targetConfigFolderURI, folderURI) : void 0;
  if (folderPath !== void 0) {
    if (folderPath.length === 0) {
      folderPath = ".";
    } else {
      if (isWindows) {
        folderPath = massagePathForWindows(folderPath);
      }
    }
  } else {
    if (folderURI.scheme === Schemas.file) {
      folderPath = folderURI.fsPath;
      if (isWindows) {
        folderPath = massagePathForWindows(folderPath);
      }
    } else if (!extUri2.isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {
      return { name: folderName, uri: folderURI.toString(true) };
    } else {
      folderPath = folderURI.path;
    }
  }
  return { name: folderName, path: folderPath };
}
function massagePathForWindows(folderPath) {
  folderPath = normalizeDriveLetter(folderPath);
  if (!isUNC(folderPath)) {
    folderPath = toSlashes(folderPath);
  }
  return folderPath;
}
function toWorkspaceFolders(configuredFolders, workspaceConfigFile, extUri2) {
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  const relativeTo = extUri2.dirname(workspaceConfigFile);
  for (const configuredFolder of configuredFolders) {
    let uri = void 0;
    if (isRawFileWorkspaceFolder(configuredFolder)) {
      if (configuredFolder.path) {
        uri = extUri2.resolvePath(relativeTo, configuredFolder.path);
      }
    } else if (isRawUriWorkspaceFolder(configuredFolder)) {
      try {
        uri = URI.parse(configuredFolder.uri);
        if (uri.path[0] !== posix.sep) {
          uri = uri.with({ path: posix.sep + uri.path });
        }
      } catch (e) {
        console.warn(e);
      }
    }
    if (uri) {
      const comparisonKey = extUri2.getComparisonKey(uri);
      if (!seen.has(comparisonKey)) {
        seen.add(comparisonKey);
        const name = configuredFolder.name || extUri2.basenameOrAuthority(uri);
        result.push(new WorkspaceFolder({ uri, name, index: result.length }, configuredFolder));
      }
    }
  }
  return result;
}
function rewriteWorkspaceFileForNewLocation(rawWorkspaceContents, configPathURI, isFromUntitledWorkspace, targetConfigPathURI, extUri2) {
  const storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);
  const sourceConfigFolder = extUri2.dirname(configPathURI);
  const targetConfigFolder = extUri2.dirname(targetConfigPathURI);
  const rewrittenFolders = [];
  for (const folder of storedWorkspace.folders) {
    const folderURI = isRawFileWorkspaceFolder(folder) ? extUri2.resolvePath(sourceConfigFolder, folder.path) : URI.parse(folder.uri);
    let absolute;
    if (isFromUntitledWorkspace) {
      absolute = false;
    } else {
      absolute = !isRawFileWorkspaceFolder(folder) || isAbsolute(folder.path);
    }
    rewrittenFolders.push(getStoredWorkspaceFolder(folderURI, absolute, folder.name, targetConfigFolder, extUri2));
  }
  const formattingOptions = { insertSpaces: false, tabSize: 4, eol: isLinux || isMacintosh ? "\n" : "\r\n" };
  const edits = setProperty(rawWorkspaceContents, ["folders"], rewrittenFolders, formattingOptions);
  let newContent = applyEdits(rawWorkspaceContents, edits);
  if (isEqualAuthority(storedWorkspace.remoteAuthority, getRemoteAuthority(targetConfigPathURI))) {
    newContent = applyEdits(newContent, removeProperty(newContent, ["remoteAuthority"], formattingOptions));
  }
  return newContent;
}
function doParseStoredWorkspace(path, contents) {
  const storedWorkspace = parse2(contents);
  if (storedWorkspace && Array.isArray(storedWorkspace.folders)) {
    storedWorkspace.folders = storedWorkspace.folders.filter((folder) => isStoredWorkspaceFolder(folder));
  } else {
    throw new Error(`${path} looks like an invalid workspace file.`);
  }
  return storedWorkspace;
}
function isSerializedRecentWorkspace(data) {
  return data.workspace && typeof data.workspace === "object" && typeof data.workspace.id === "string" && typeof data.workspace.configPath === "string";
}
function isSerializedRecentFolder(data) {
  return typeof data.folderUri === "string";
}
function isSerializedRecentFile(data) {
  return typeof data.fileUri === "string";
}
function restoreRecentlyOpened(data, logService) {
  const result = { workspaces: [], files: [] };
  if (data) {
    const restoreGracefully = function(entries, onEntry) {
      for (let i = 0; i < entries.length; i++) {
        try {
          onEntry(entries[i], i);
        } catch (e) {
          logService.warn(`Error restoring recent entry ${JSON.stringify(entries[i])}: ${e.toString()}. Skip entry.`);
        }
      }
    };
    const storedRecents = data;
    if (Array.isArray(storedRecents.entries)) {
      restoreGracefully(storedRecents.entries, (entry) => {
        const label = entry.label;
        const remoteAuthority = entry.remoteAuthority;
        if (isSerializedRecentWorkspace(entry)) {
          result.workspaces.push({ label, remoteAuthority, workspace: { id: entry.workspace.id, configPath: URI.parse(entry.workspace.configPath) } });
        } else if (isSerializedRecentFolder(entry)) {
          result.workspaces.push({ label, remoteAuthority, folderUri: URI.parse(entry.folderUri) });
        } else if (isSerializedRecentFile(entry)) {
          result.files.push({ label, remoteAuthority, fileUri: URI.parse(entry.fileUri) });
        }
      });
    }
  }
  return result;
}
function toStoreData(recents) {
  const serialized = { entries: [] };
  for (const recent of recents.workspaces) {
    if (isRecentFolder(recent)) {
      serialized.entries.push({ folderUri: recent.folderUri.toString(), label: recent.label, remoteAuthority: recent.remoteAuthority });
    } else {
      serialized.entries.push({ workspace: { id: recent.workspace.id, configPath: recent.workspace.configPath.toString() }, label: recent.label, remoteAuthority: recent.remoteAuthority });
    }
  }
  for (const recent of recents.files) {
    serialized.entries.push({ fileUri: recent.fileUri.toString(), label: recent.label, remoteAuthority: recent.remoteAuthority });
  }
  return serialized;
}

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textEditorService.js
init_tslib_es6();
init_event();
init_platform2();
init_map();
init_instantiation();
init_network();

// node_modules/vscode/vscode/src/vs/workbench/common/editor/diffEditorInput.js
init_tslib_es6();
init_nls();

// node_modules/vscode/vscode/src/vs/workbench/common/editor/sideBySideEditorInput.js
init_tslib_es6();
init_event();
init_nls();

// node_modules/vscode/vscode/src/vs/workbench/common/editor/editorInput.js
init_event();
init_arrays();
init_resources();
var EditorInput = class extends AbstractEditorInput {
  constructor() {
    super(...arguments);
    this._onDidChangeDirty = this._register(new Emitter());
    this._onDidChangeLabel = this._register(new Emitter());
    this._onDidChangeCapabilities = this._register(new Emitter());
    this._onWillDispose = this._register(new Emitter());
    this.onDidChangeDirty = this._onDidChangeDirty.event;
    this.onDidChangeLabel = this._onDidChangeLabel.event;
    this.onDidChangeCapabilities = this._onDidChangeCapabilities.event;
    this.onWillDispose = this._onWillDispose.event;
    this.disposed = false;
  }
  get editorId() {
    return void 0;
  }
  get capabilities() {
    return 2;
  }
  hasCapability(capability) {
    if (capability === 0) {
      return this.capabilities === 0;
    }
    return (this.capabilities & capability) !== 0;
  }
  isReadonly() {
    return this.hasCapability(2);
  }
  getName() {
    return `Editor ${this.typeId}`;
  }
  getDescription(verbosity) {
    return void 0;
  }
  getTitle(verbosity) {
    return this.getName();
  }
  getLabelExtraClasses() {
    return [];
  }
  getAriaLabel() {
    return this.getTitle(0);
  }
  getTelemetryDescriptor() {
    return { typeId: this.typeId };
  }
  isDirty() {
    return false;
  }
  isModified() {
    return this.isDirty();
  }
  isSaving() {
    return false;
  }
  async resolve(options) {
    return null;
  }
  async save(group, options) {
    return this;
  }
  async saveAs(group, options) {
    return this;
  }
  async revert(group, options) {
  }
  async rename(group, target) {
    return void 0;
  }
  copy() {
    return this;
  }
  matches(otherInput) {
    var _a43;
    if (isEditorInput(otherInput)) {
      return this === otherInput;
    }
    const otherInputEditorId = (_a43 = otherInput.options) == null ? void 0 : _a43.override;
    if (this.editorId !== otherInputEditorId && otherInputEditorId !== void 0 && this.editorId !== void 0) {
      return false;
    }
    return isEqual2(this.resource, EditorResourceAccessor.getCanonicalUri(otherInput));
  }
  prefersEditorPane(editorPanes) {
    return firstOrDefault(editorPanes);
  }
  toUntyped(options) {
    return void 0;
  }
  isDisposed() {
    return this.disposed;
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this._onWillDispose.fire();
    }
    super.dispose();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/common/editor/sideBySideEditorInput.js
var SideBySideEditorInput_1;
var _a10;
var SideBySideEditorInput = (_a10 = class extends EditorInput {
  get typeId() {
    return SideBySideEditorInput_1.ID;
  }
  get capabilities() {
    let capabilities = this.primary.capabilities;
    capabilities &= ~32;
    if (this.secondary.hasCapability(16)) {
      capabilities |= 16;
    }
    if (this.secondary.hasCapability(8)) {
      capabilities |= 8;
    }
    capabilities |= 256;
    return capabilities;
  }
  get resource() {
    if (this.hasIdenticalSides) {
      return this.primary.resource;
    }
    return void 0;
  }
  constructor(preferredName, preferredDescription, secondary, primary, editorService) {
    super();
    this.preferredName = preferredName;
    this.preferredDescription = preferredDescription;
    this.secondary = secondary;
    this.primary = primary;
    this.editorService = editorService;
    this.hasIdenticalSides = this.primary.matches(this.secondary);
    this.registerListeners();
  }
  registerListeners() {
    this._register(Event.once(Event.any(this.primary.onWillDispose, this.secondary.onWillDispose))(() => {
      if (!this.isDisposed()) {
        this.dispose();
      }
    }));
    this._register(this.primary.onDidChangeDirty(() => this._onDidChangeDirty.fire()));
    this._register(this.primary.onDidChangeCapabilities(() => this._onDidChangeCapabilities.fire()));
    this._register(this.secondary.onDidChangeCapabilities(() => this._onDidChangeCapabilities.fire()));
    this._register(this.primary.onDidChangeLabel(() => this._onDidChangeLabel.fire()));
    this._register(this.secondary.onDidChangeLabel(() => this._onDidChangeLabel.fire()));
  }
  getName() {
    const preferredName = this.getPreferredName();
    if (preferredName) {
      return preferredName;
    }
    if (this.hasIdenticalSides) {
      return this.primary.getName();
    }
    return localize(
      "sideBySideLabels",
      "{0} - {1}",
      this.secondary.getName(),
      this.primary.getName()
    );
  }
  getPreferredName() {
    return this.preferredName;
  }
  getDescription(verbosity) {
    const preferredDescription = this.getPreferredDescription();
    if (preferredDescription) {
      return preferredDescription;
    }
    if (this.hasIdenticalSides) {
      return this.primary.getDescription(verbosity);
    }
    return super.getDescription(verbosity);
  }
  getPreferredDescription() {
    return this.preferredDescription;
  }
  getTitle(verbosity) {
    if (this.hasIdenticalSides) {
      return this.primary.getTitle(verbosity) ?? this.getName();
    }
    return super.getTitle(verbosity);
  }
  getLabelExtraClasses() {
    if (this.hasIdenticalSides) {
      return this.primary.getLabelExtraClasses();
    }
    return super.getLabelExtraClasses();
  }
  getAriaLabel() {
    if (this.hasIdenticalSides) {
      return this.primary.getAriaLabel();
    }
    return super.getAriaLabel();
  }
  getTelemetryDescriptor() {
    const descriptor = this.primary.getTelemetryDescriptor();
    return { ...descriptor, ...super.getTelemetryDescriptor() };
  }
  isDirty() {
    return this.primary.isDirty();
  }
  isSaving() {
    return this.primary.isSaving();
  }
  async save(group, options) {
    const primarySaveResult = await this.primary.save(group, options);
    return this.saveResultToEditor(primarySaveResult);
  }
  async saveAs(group, options) {
    const primarySaveResult = await this.primary.saveAs(group, options);
    return this.saveResultToEditor(primarySaveResult);
  }
  saveResultToEditor(primarySaveResult) {
    if (!primarySaveResult || !this.hasIdenticalSides) {
      return primarySaveResult;
    }
    if (this.primary.matches(primarySaveResult)) {
      return this;
    }
    if (primarySaveResult instanceof EditorInput) {
      return new SideBySideEditorInput_1(
        this.preferredName,
        this.preferredDescription,
        primarySaveResult,
        primarySaveResult,
        this.editorService
      );
    }
    if (!isResourceDiffEditorInput(primarySaveResult) && !isResourceSideBySideEditorInput(primarySaveResult) && !isResourceMergeEditorInput(primarySaveResult)) {
      return {
        primary: primarySaveResult,
        secondary: primarySaveResult,
        label: this.preferredName,
        description: this.preferredDescription
      };
    }
    return void 0;
  }
  revert(group, options) {
    return this.primary.revert(group, options);
  }
  async rename(group, target) {
    if (!this.hasIdenticalSides) {
      return;
    }
    const renameResult = await this.primary.rename(group, target);
    if (!renameResult) {
      return void 0;
    }
    if (isEditorInput(renameResult.editor)) {
      return {
        editor: new SideBySideEditorInput_1(
          this.preferredName,
          this.preferredDescription,
          renameResult.editor,
          renameResult.editor,
          this.editorService
        ),
        options: {
          ...renameResult.options,
          viewState: findViewStateForEditor(this, group, this.editorService)
        }
      };
    }
    if (isResourceEditorInput(renameResult.editor)) {
      return {
        editor: {
          label: this.preferredName,
          description: this.preferredDescription,
          primary: renameResult.editor,
          secondary: renameResult.editor,
          options: {
            ...renameResult.options,
            viewState: findViewStateForEditor(this, group, this.editorService)
          }
        }
      };
    }
    return void 0;
  }
  isReadonly() {
    return this.primary.isReadonly();
  }
  toUntyped(options) {
    const primaryResourceEditorInput = this.primary.toUntyped(options);
    const secondaryResourceEditorInput = this.secondary.toUntyped(options);
    if (primaryResourceEditorInput && secondaryResourceEditorInput && !isResourceDiffEditorInput(primaryResourceEditorInput) && !isResourceDiffEditorInput(secondaryResourceEditorInput) && !isResourceSideBySideEditorInput(primaryResourceEditorInput) && !isResourceSideBySideEditorInput(secondaryResourceEditorInput) && !isResourceMergeEditorInput(primaryResourceEditorInput) && !isResourceMergeEditorInput(secondaryResourceEditorInput)) {
      const untypedInput = {
        label: this.preferredName,
        description: this.preferredDescription,
        primary: primaryResourceEditorInput,
        secondary: secondaryResourceEditorInput
      };
      if (typeof (options == null ? void 0 : options.preserveViewState) === "number") {
        untypedInput.options = {
          viewState: findViewStateForEditor(this, options.preserveViewState, this.editorService)
        };
      }
      return untypedInput;
    }
    return void 0;
  }
  matches(otherInput) {
    if (this === otherInput) {
      return true;
    }
    if (isDiffEditorInput(otherInput) || isResourceDiffEditorInput(otherInput)) {
      return false;
    }
    if (otherInput instanceof SideBySideEditorInput_1) {
      return this.primary.matches(otherInput.primary) && this.secondary.matches(otherInput.secondary);
    }
    if (isResourceSideBySideEditorInput(otherInput)) {
      return this.primary.matches(otherInput.primary) && this.secondary.matches(otherInput.secondary);
    }
    return false;
  }
}, SideBySideEditorInput_1 = _a10, _a10.ID = "workbench.editorinputs.sidebysideEditorInput", _a10);
SideBySideEditorInput = SideBySideEditorInput_1 = __decorate([
  __param(4, IEditorService)
], SideBySideEditorInput);

// node_modules/vscode/vscode/src/vs/workbench/common/editor/diffEditorModel.js
var DiffEditorModel = class extends EditorModel {
  get originalModel() {
    return this._originalModel;
  }
  get modifiedModel() {
    return this._modifiedModel;
  }
  constructor(originalModel, modifiedModel) {
    super();
    this._originalModel = originalModel;
    this._modifiedModel = modifiedModel;
  }
  async resolve() {
    var _a43, _b;
    await Promise.all([
      (_a43 = this._originalModel) == null ? void 0 : _a43.resolve(),
      (_b = this._modifiedModel) == null ? void 0 : _b.resolve()
    ]);
  }
  isResolved() {
    var _a43, _b;
    return !!(((_a43 = this.originalModel) == null ? void 0 : _a43.isResolved()) && ((_b = this.modifiedModel) == null ? void 0 : _b.isResolved()));
  }
  dispose() {
    super.dispose();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/common/editor/textDiffEditorModel.js
var TextDiffEditorModel = class extends DiffEditorModel {
  get originalModel() {
    return this._originalModel;
  }
  get modifiedModel() {
    return this._modifiedModel;
  }
  get textDiffEditorModel() {
    return this._textDiffEditorModel;
  }
  constructor(originalModel, modifiedModel) {
    super(originalModel, modifiedModel);
    this._textDiffEditorModel = void 0;
    this._originalModel = originalModel;
    this._modifiedModel = modifiedModel;
    this.updateTextDiffEditorModel();
  }
  async resolve() {
    await super.resolve();
    this.updateTextDiffEditorModel();
  }
  updateTextDiffEditorModel() {
    var _a43, _b;
    if (((_a43 = this.originalModel) == null ? void 0 : _a43.isResolved()) && ((_b = this.modifiedModel) == null ? void 0 : _b.isResolved())) {
      if (!this._textDiffEditorModel) {
        this._textDiffEditorModel = {
          original: this.originalModel.textEditorModel,
          modified: this.modifiedModel.textEditorModel
        };
      } else {
        this._textDiffEditorModel.original = this.originalModel.textEditorModel;
        this._textDiffEditorModel.modified = this.modifiedModel.textEditorModel;
      }
    }
  }
  isResolved() {
    return !!this._textDiffEditorModel;
  }
  isReadonly() {
    return !!this.modifiedModel && this.modifiedModel.isReadonly();
  }
  dispose() {
    this._textDiffEditorModel = void 0;
    super.dispose();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/common/editor/diffEditorInput.js
var DiffEditorInput_1;
var _a11;
var DiffEditorInput = (_a11 = class extends SideBySideEditorInput {
  get typeId() {
    return DiffEditorInput_1.ID;
  }
  get editorId() {
    return this.modified.editorId === this.original.editorId ? this.modified.editorId : void 0;
  }
  get capabilities() {
    let capabilities = super.capabilities;
    if (this.labels.forceDescription) {
      capabilities |= 64;
    }
    return capabilities;
  }
  constructor(preferredName, preferredDescription, original, modified, forceOpenAsBinary, editorService) {
    super(preferredName, preferredDescription, original, modified, editorService);
    this.original = original;
    this.modified = modified;
    this.forceOpenAsBinary = forceOpenAsBinary;
    this.cachedModel = void 0;
    this.labels = this.computeLabels();
  }
  computeLabels() {
    let name;
    let forceDescription = false;
    if (this.preferredName) {
      name = this.preferredName;
    } else {
      const originalName = this.original.getName();
      const modifiedName = this.modified.getName();
      name = localize("sideBySideLabels", "{0}  {1}", originalName, modifiedName);
      forceDescription = originalName === modifiedName;
    }
    let shortDescription;
    let mediumDescription;
    let longDescription;
    if (this.preferredDescription) {
      shortDescription = this.preferredDescription;
      mediumDescription = this.preferredDescription;
      longDescription = this.preferredDescription;
    } else {
      shortDescription = this.computeLabel(this.original.getDescription(0), this.modified.getDescription(0));
      longDescription = this.computeLabel(this.original.getDescription(2), this.modified.getDescription(2));
      const originalMediumDescription = this.original.getDescription(1);
      const modifiedMediumDescription = this.modified.getDescription(1);
      if (typeof originalMediumDescription === "string" && typeof modifiedMediumDescription === "string" && (originalMediumDescription || modifiedMediumDescription)) {
        const [shortenedOriginalMediumDescription, shortenedModifiedMediumDescription] = shorten([originalMediumDescription, modifiedMediumDescription]);
        mediumDescription = this.computeLabel(shortenedOriginalMediumDescription, shortenedModifiedMediumDescription);
      }
    }
    const shortTitle = this.computeLabel(this.original.getTitle(0) ?? this.original.getName(), this.modified.getTitle(0) ?? this.modified.getName(), "  ");
    const mediumTitle = this.computeLabel(this.original.getTitle(1) ?? this.original.getName(), this.modified.getTitle(1) ?? this.modified.getName(), "  ");
    const longTitle = this.computeLabel(this.original.getTitle(2) ?? this.original.getName(), this.modified.getTitle(2) ?? this.modified.getName(), "  ");
    return { name, shortDescription, mediumDescription, longDescription, forceDescription, shortTitle, mediumTitle, longTitle };
  }
  computeLabel(originalLabel, modifiedLabel, separator = " - ") {
    if (!originalLabel || !modifiedLabel) {
      return void 0;
    }
    if (originalLabel === modifiedLabel) {
      return modifiedLabel;
    }
    return `${originalLabel}${separator}${modifiedLabel}`;
  }
  getName() {
    return this.labels.name;
  }
  getDescription(verbosity = 1) {
    switch (verbosity) {
      case 0:
        return this.labels.shortDescription;
      case 2:
        return this.labels.longDescription;
      case 1:
      default:
        return this.labels.mediumDescription;
    }
  }
  getTitle(verbosity) {
    switch (verbosity) {
      case 0:
        return this.labels.shortTitle;
      case 2:
        return this.labels.longTitle;
      default:
      case 1:
        return this.labels.mediumTitle;
    }
  }
  async resolve(options) {
    var _a43;
    const resolvedModel = await this.createModel(options);
    (_a43 = this.cachedModel) == null ? void 0 : _a43.dispose();
    this.cachedModel = resolvedModel;
    return this.cachedModel;
  }
  prefersEditorPane(editorPanes) {
    if (this.forceOpenAsBinary) {
      return editorPanes.find((editorPane) => editorPane.typeId === BINARY_DIFF_EDITOR_ID);
    }
    return editorPanes.find((editorPane) => editorPane.typeId === TEXT_DIFF_EDITOR_ID);
  }
  async createModel(options) {
    const [originalEditorModel, modifiedEditorModel] = await Promise.all([
      this.original.resolve(options),
      this.modified.resolve(options)
    ]);
    if (modifiedEditorModel instanceof BaseTextEditorModel && originalEditorModel instanceof BaseTextEditorModel) {
      return new TextDiffEditorModel(originalEditorModel, modifiedEditorModel);
    }
    return new DiffEditorModel(originalEditorModel ?? void 0, modifiedEditorModel ?? void 0);
  }
  toUntyped(options) {
    const untyped = super.toUntyped(options);
    if (untyped) {
      return {
        ...untyped,
        modified: untyped.primary,
        original: untyped.secondary
      };
    }
    return void 0;
  }
  matches(otherInput) {
    if (this === otherInput) {
      return true;
    }
    if (otherInput instanceof DiffEditorInput_1) {
      return this.modified.matches(otherInput.modified) && this.original.matches(otherInput.original) && otherInput.forceOpenAsBinary === this.forceOpenAsBinary;
    }
    if (isResourceDiffEditorInput(otherInput)) {
      return this.modified.matches(otherInput.modified) && this.original.matches(otherInput.original);
    }
    return false;
  }
  dispose() {
    if (this.cachedModel) {
      this.cachedModel.dispose();
      this.cachedModel = void 0;
    }
    super.dispose();
  }
}, DiffEditorInput_1 = _a11, _a11.ID = "workbench.editors.diffEditorInput", _a11);
DiffEditorInput = DiffEditorInput_1 = __decorate([
  __param(5, IEditorService)
], DiffEditorInput);

// node_modules/vscode/vscode/src/vs/workbench/common/editor/textResourceEditorInput.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/common/editor/resourceEditorInput.js
init_tslib_es6();
init_files();
init_resources();
var AbstractResourceEditorInput = class AbstractResourceEditorInput2 extends EditorInput {
  get capabilities() {
    let capabilities = 32;
    if (this.fileService.hasProvider(this.resource)) {
      if (this.filesConfigurationService.isReadonly(this.resource)) {
        capabilities |= 2;
      }
    } else {
      capabilities |= 4;
    }
    if (!(capabilities & 2)) {
      capabilities |= 128;
    }
    return capabilities;
  }
  get preferredResource() {
    return this._preferredResource;
  }
  constructor(resource, preferredResource, labelService, fileService, filesConfigurationService) {
    super();
    this.resource = resource;
    this.labelService = labelService;
    this.fileService = fileService;
    this.filesConfigurationService = filesConfigurationService;
    this._name = void 0;
    this._shortDescription = void 0;
    this._mediumDescription = void 0;
    this._longDescription = void 0;
    this._shortTitle = void 0;
    this._mediumTitle = void 0;
    this._longTitle = void 0;
    this._preferredResource = preferredResource || resource;
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.labelService.onDidChangeFormatters((e) => this.onLabelEvent(e.scheme)));
    this._register(this.fileService.onDidChangeFileSystemProviderRegistrations((e) => this.onLabelEvent(e.scheme)));
    this._register(this.fileService.onDidChangeFileSystemProviderCapabilities((e) => this.onLabelEvent(e.scheme)));
  }
  onLabelEvent(scheme) {
    if (scheme === this._preferredResource.scheme) {
      this.updateLabel();
    }
  }
  updateLabel() {
    this._name = void 0;
    this._shortDescription = void 0;
    this._mediumDescription = void 0;
    this._longDescription = void 0;
    this._shortTitle = void 0;
    this._mediumTitle = void 0;
    this._longTitle = void 0;
    this._onDidChangeLabel.fire();
  }
  setPreferredResource(preferredResource) {
    if (!isEqual2(preferredResource, this._preferredResource)) {
      this._preferredResource = preferredResource;
      this.updateLabel();
    }
  }
  getName() {
    if (typeof this._name !== "string") {
      this._name = this.labelService.getUriBasenameLabel(this._preferredResource);
    }
    return this._name;
  }
  getDescription(verbosity = 1) {
    switch (verbosity) {
      case 0:
        return this.shortDescription;
      case 2:
        return this.longDescription;
      case 1:
      default:
        return this.mediumDescription;
    }
  }
  get shortDescription() {
    if (typeof this._shortDescription !== "string") {
      this._shortDescription = this.labelService.getUriBasenameLabel(dirname(this._preferredResource));
    }
    return this._shortDescription;
  }
  get mediumDescription() {
    if (typeof this._mediumDescription !== "string") {
      this._mediumDescription = this.labelService.getUriLabel(dirname(this._preferredResource), { relative: true });
    }
    return this._mediumDescription;
  }
  get longDescription() {
    if (typeof this._longDescription !== "string") {
      this._longDescription = this.labelService.getUriLabel(dirname(this._preferredResource));
    }
    return this._longDescription;
  }
  get shortTitle() {
    if (typeof this._shortTitle !== "string") {
      this._shortTitle = this.getName();
    }
    return this._shortTitle;
  }
  get mediumTitle() {
    if (typeof this._mediumTitle !== "string") {
      this._mediumTitle = this.labelService.getUriLabel(this._preferredResource, { relative: true });
    }
    return this._mediumTitle;
  }
  get longTitle() {
    if (typeof this._longTitle !== "string") {
      this._longTitle = this.labelService.getUriLabel(this._preferredResource);
    }
    return this._longTitle;
  }
  getTitle(verbosity) {
    switch (verbosity) {
      case 0:
        return this.shortTitle;
      case 2:
        return this.longTitle;
      default:
      case 1:
        return this.mediumTitle;
    }
  }
  isReadonly() {
    return this.filesConfigurationService.isReadonly(this.resource);
  }
};
AbstractResourceEditorInput = __decorate([
  __param(2, ILabelService),
  __param(3, IFileService),
  __param(4, IFilesConfigurationService)
], AbstractResourceEditorInput);

// node_modules/vscode/vscode/src/vs/workbench/common/editor/textResourceEditorInput.js
init_files();
init_network();
init_resources();
init_resolverService();

// node_modules/vscode/vscode/src/vs/workbench/common/editor/textResourceEditorModel.js
init_tslib_es6();
init_language();
init_model2();
var TextResourceEditorModel = class TextResourceEditorModel2 extends BaseTextEditorModel {
  constructor(resource, languageService, modelService, languageDetectionService, accessibilityService) {
    super(modelService, languageService, languageDetectionService, accessibilityService, resource);
  }
  dispose() {
    if (this.textEditorModelHandle) {
      this.modelService.destroyModel(this.textEditorModelHandle);
    }
    super.dispose();
  }
};
TextResourceEditorModel = __decorate([
  __param(1, ILanguageService),
  __param(2, IModelService),
  __param(3, ILanguageDetectionService),
  __param(4, IAccessibilityService)
], TextResourceEditorModel);

// node_modules/vscode/vscode/src/vs/workbench/common/editor/textResourceEditorInput.js
init_textModel();
var TextResourceEditorInput_1;
var AbstractTextResourceEditorInput = class AbstractTextResourceEditorInput2 extends AbstractResourceEditorInput {
  constructor(resource, preferredResource, editorService, textFileService, labelService, fileService, filesConfigurationService) {
    super(resource, preferredResource, labelService, fileService, filesConfigurationService);
    this.editorService = editorService;
    this.textFileService = textFileService;
  }
  save(group, options) {
    if (this.resource.scheme !== Schemas.untitled && !this.fileService.hasProvider(this.resource)) {
      return this.saveAs(group, options);
    }
    return this.doSave(options, false, group);
  }
  saveAs(group, options) {
    return this.doSave(options, true, group);
  }
  async doSave(options, saveAs, group) {
    let target;
    if (saveAs) {
      target = await this.textFileService.saveAs(this.resource, void 0, { ...options, suggestedTarget: this.preferredResource });
    } else {
      target = await this.textFileService.save(this.resource, options);
    }
    if (!target) {
      return void 0;
    }
    return { resource: target };
  }
  async revert(group, options) {
    await this.textFileService.revert(this.resource, options);
  }
};
AbstractTextResourceEditorInput = __decorate([
  __param(2, IEditorService),
  __param(3, ITextFileService),
  __param(4, ILabelService),
  __param(5, IFileService),
  __param(6, IFilesConfigurationService)
], AbstractTextResourceEditorInput);
var _a12;
var TextResourceEditorInput = (_a12 = class extends AbstractTextResourceEditorInput {
  get typeId() {
    return TextResourceEditorInput_1.ID;
  }
  get editorId() {
    return DEFAULT_EDITOR_ASSOCIATION.id;
  }
  constructor(resource, name, description, preferredLanguageId, preferredContents, textModelResolverService, textFileService, editorService, fileService, labelService, filesConfigurationService) {
    super(resource, void 0, editorService, textFileService, labelService, fileService, filesConfigurationService);
    this.name = name;
    this.description = description;
    this.preferredLanguageId = preferredLanguageId;
    this.preferredContents = preferredContents;
    this.textModelResolverService = textModelResolverService;
    this.cachedModel = void 0;
    this.modelReference = void 0;
  }
  getName() {
    return this.name || super.getName();
  }
  setName(name) {
    if (this.name !== name) {
      this.name = name;
      this._onDidChangeLabel.fire();
    }
  }
  getDescription() {
    return this.description;
  }
  setDescription(description) {
    if (this.description !== description) {
      this.description = description;
      this._onDidChangeLabel.fire();
    }
  }
  setLanguageId(languageId, source) {
    var _a43;
    this.setPreferredLanguageId(languageId);
    (_a43 = this.cachedModel) == null ? void 0 : _a43.setLanguageId(languageId, source);
  }
  setPreferredLanguageId(languageId) {
    this.preferredLanguageId = languageId;
  }
  setPreferredContents(contents) {
    this.preferredContents = contents;
  }
  async resolve() {
    const preferredContents = this.preferredContents;
    const preferredLanguageId = this.preferredLanguageId;
    this.preferredContents = void 0;
    this.preferredLanguageId = void 0;
    if (!this.modelReference) {
      this.modelReference = this.textModelResolverService.createModelReference(this.resource);
    }
    const ref = await this.modelReference;
    const model = ref.object;
    if (!(model instanceof TextResourceEditorModel)) {
      ref.dispose();
      this.modelReference = void 0;
      throw new Error(`Unexpected model for TextResourceEditorInput: ${this.resource}`);
    }
    this.cachedModel = model;
    if (typeof preferredContents === "string" || typeof preferredLanguageId === "string") {
      model.updateTextEditorModel(typeof preferredContents === "string" ? createTextBufferFactory(preferredContents) : void 0, preferredLanguageId);
    }
    return model;
  }
  matches(otherInput) {
    if (this === otherInput) {
      return true;
    }
    if (otherInput instanceof TextResourceEditorInput_1) {
      return isEqual2(otherInput.resource, this.resource);
    }
    if (isResourceEditorInput(otherInput)) {
      return super.matches(otherInput);
    }
    return false;
  }
  dispose() {
    if (this.modelReference) {
      this.modelReference.then((ref) => ref.dispose());
      this.modelReference = void 0;
    }
    this.cachedModel = void 0;
    super.dispose();
  }
}, TextResourceEditorInput_1 = _a12, _a12.ID = "workbench.editors.resourceEditorInput", _a12);
TextResourceEditorInput = TextResourceEditorInput_1 = __decorate([
  __param(5, ITextModelService),
  __param(6, ITextFileService),
  __param(7, IEditorService),
  __param(8, IFileService),
  __param(9, ILabelService),
  __param(10, IFilesConfigurationService)
], TextResourceEditorInput);

// node_modules/vscode/vscode/src/vs/workbench/services/untitled/common/untitledTextEditorInput.js
init_tslib_es6();
init_files();
init_resources();
var UntitledTextEditorInput_1;
var _a13;
var UntitledTextEditorInput = (_a13 = class extends AbstractTextResourceEditorInput {
  get typeId() {
    return UntitledTextEditorInput_1.ID;
  }
  get editorId() {
    return DEFAULT_EDITOR_ASSOCIATION.id;
  }
  constructor(model, textFileService, labelService, editorService, fileService, environmentService, pathService, filesConfigurationService) {
    super(model.resource, void 0, editorService, textFileService, labelService, fileService, filesConfigurationService);
    this.model = model;
    this.environmentService = environmentService;
    this.pathService = pathService;
    this.modelResolve = void 0;
    this.registerModelListeners(model);
  }
  registerModelListeners(model) {
    this._register(model.onDidChangeDirty(() => this._onDidChangeDirty.fire()));
    this._register(model.onDidChangeName(() => this._onDidChangeLabel.fire()));
    this._register(model.onDidRevert(() => this.dispose()));
  }
  getName() {
    return this.model.name;
  }
  getDescription(verbosity = 1) {
    if (!this.model.hasAssociatedFilePath) {
      const descriptionCandidate = this.resource.path;
      if (descriptionCandidate !== this.getName()) {
        return descriptionCandidate;
      }
      return void 0;
    }
    return super.getDescription(verbosity);
  }
  getTitle(verbosity) {
    if (!this.model.hasAssociatedFilePath) {
      const name = this.getName();
      const description = this.getDescription();
      if (description && description !== name) {
        return `${name}  ${description}`;
      }
      return name;
    }
    return super.getTitle(verbosity);
  }
  isDirty() {
    return this.model.isDirty();
  }
  getEncoding() {
    return this.model.getEncoding();
  }
  setEncoding(encoding, mode) {
    return this.model.setEncoding(encoding);
  }
  setLanguageId(languageId, source) {
    this.model.setLanguageId(languageId, source);
  }
  getLanguageId() {
    return this.model.getLanguageId();
  }
  async resolve() {
    if (!this.modelResolve) {
      this.modelResolve = this.model.resolve();
    }
    await this.modelResolve;
    return this.model;
  }
  toUntyped(options) {
    var _a43;
    const untypedInput = {
      resource: this.model.hasAssociatedFilePath ? toLocalResource(this.model.resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme) : this.resource,
      forceUntitled: true,
      options: {
        override: this.editorId
      }
    };
    if (typeof (options == null ? void 0 : options.preserveViewState) === "number") {
      untypedInput.encoding = this.getEncoding();
      untypedInput.languageId = this.getLanguageId();
      untypedInput.contents = this.model.isModified() ? (_a43 = this.model.textEditorModel) == null ? void 0 : _a43.getValue() : void 0;
      untypedInput.options.viewState = findViewStateForEditor(this, options.preserveViewState, this.editorService);
      if (typeof untypedInput.contents === "string" && !this.model.hasAssociatedFilePath) {
        untypedInput.resource = void 0;
      }
    }
    return untypedInput;
  }
  matches(otherInput) {
    if (this === otherInput) {
      return true;
    }
    if (otherInput instanceof UntitledTextEditorInput_1) {
      return isEqual2(otherInput.resource, this.resource);
    }
    if (isUntitledResourceEditorInput(otherInput)) {
      return super.matches(otherInput);
    }
    return false;
  }
  dispose() {
    this.modelResolve = void 0;
    super.dispose();
  }
}, UntitledTextEditorInput_1 = _a13, _a13.ID = "workbench.editors.untitledEditorInput", _a13);
UntitledTextEditorInput = UntitledTextEditorInput_1 = __decorate([
  __param(1, ITextFileService),
  __param(2, ILabelService),
  __param(3, IEditorService),
  __param(4, IFileService),
  __param(5, IWorkbenchEnvironmentService),
  __param(6, IPathService),
  __param(7, IFilesConfigurationService)
], UntitledTextEditorInput);

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textEditorService.js
init_resources();
init_uri();
init_files();

// node_modules/vscode/vscode/src/vs/workbench/services/editor/common/editorResolverService.js
init_network();
init_path();
init_resources();
init_nls();
init_configurationRegistry();
init_instantiation();
init_platform2();
var IEditorResolverService = createDecorator("editorResolverService");
var configurationRegistry = Registry.as(Extensions2.Configuration);
var editorAssociationsConfigurationNode = {
  ...workbenchConfigurationNodeBase,
  properties: {
    "workbench.editorAssociations": {
      type: "object",
      markdownDescription: localize(
        "editor.editorAssociations",
        'Configure [glob patterns](https://aka.ms/vscode-glob-patterns) to editors (for example `"*.hex": "hexEditor.hexedit"`). These have precedence over the default behavior.'
      ),
      additionalProperties: {
        type: "string"
      }
    }
  }
};
configurationRegistry.registerConfiguration(editorAssociationsConfigurationNode);
var RegisteredEditorPriority;
(function(RegisteredEditorPriority2) {
  RegisteredEditorPriority2["builtin"] = "builtin";
  RegisteredEditorPriority2["option"] = "option";
  RegisteredEditorPriority2["exclusive"] = "exclusive";
  RegisteredEditorPriority2["default"] = "default";
})(RegisteredEditorPriority || (RegisteredEditorPriority = {}));

// node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textEditorService.js
init_lifecycle();
var ITextEditorService = createDecorator("textEditorService");
var TextEditorService = class TextEditorService2 extends Disposable {
  constructor(untitledTextEditorService, instantiationService, uriIdentityService, fileService, editorResolverService) {
    super();
    this.untitledTextEditorService = untitledTextEditorService;
    this.instantiationService = instantiationService;
    this.uriIdentityService = uriIdentityService;
    this.fileService = fileService;
    this.editorResolverService = editorResolverService;
    this.editorInputCache = new ResourceMap();
    this.fileEditorFactory = Registry.as(EditorExtensions.EditorFactory).getFileEditorFactory();
    this.registerDefaultEditor();
  }
  registerDefaultEditor() {
    this._register(this.editorResolverService.registerEditor("*", {
      id: DEFAULT_EDITOR_ASSOCIATION.id,
      label: DEFAULT_EDITOR_ASSOCIATION.displayName,
      detail: DEFAULT_EDITOR_ASSOCIATION.providerDisplayName,
      priority: RegisteredEditorPriority.builtin
    }, {}, {
      createEditorInput: (editor) => ({ editor: this.createTextEditor(editor) }),
      createUntitledEditorInput: (untitledEditor) => ({ editor: this.createTextEditor(untitledEditor) }),
      createDiffEditorInput: (diffEditor) => ({ editor: this.createTextEditor(diffEditor) })
    }));
  }
  async resolveTextEditor(input) {
    return this.createTextEditor(input);
  }
  createTextEditor(input) {
    var _a43;
    if (isResourceMergeEditorInput(input)) {
      return this.createTextEditor(input.result);
    }
    if (isResourceDiffEditorInput(input)) {
      const original = this.createTextEditor(input.original);
      const modified = this.createTextEditor(input.modified);
      return this.instantiationService.createInstance(DiffEditorInput, input.label, input.description, original, modified, void 0);
    }
    if (isResourceSideBySideEditorInput(input)) {
      const primary = this.createTextEditor(input.primary);
      const secondary = this.createTextEditor(input.secondary);
      return this.instantiationService.createInstance(SideBySideEditorInput, input.label, input.description, secondary, primary);
    }
    const untitledInput = input;
    if (untitledInput.forceUntitled || !untitledInput.resource || untitledInput.resource.scheme === Schemas.untitled) {
      const untitledOptions = {
        languageId: untitledInput.languageId,
        initialValue: untitledInput.contents,
        encoding: untitledInput.encoding
      };
      let untitledModel;
      if (((_a43 = untitledInput.resource) == null ? void 0 : _a43.scheme) === Schemas.untitled) {
        untitledModel = this.untitledTextEditorService.create({ untitledResource: untitledInput.resource, ...untitledOptions });
      } else {
        untitledModel = this.untitledTextEditorService.create({ associatedResource: untitledInput.resource, ...untitledOptions });
      }
      return this.createOrGetCached(untitledModel.resource, () => {
        const input2 = this.instantiationService.createInstance(UntitledTextEditorInput, untitledModel);
        Event.once(input2.onWillDispose)(() => untitledModel.dispose());
        return input2;
      });
    }
    const textResourceEditorInput = input;
    if (textResourceEditorInput.resource instanceof URI) {
      const label = textResourceEditorInput.label || basename2(textResourceEditorInput.resource);
      const preferredResource = textResourceEditorInput.resource;
      const canonicalResource = this.uriIdentityService.asCanonicalUri(preferredResource);
      return this.createOrGetCached(canonicalResource, () => {
        if (textResourceEditorInput.forceFile || this.fileService.hasProvider(canonicalResource)) {
          return this.fileEditorFactory.createFileEditor(canonicalResource, preferredResource, textResourceEditorInput.label, textResourceEditorInput.description, textResourceEditorInput.encoding, textResourceEditorInput.languageId, textResourceEditorInput.contents, this.instantiationService);
        }
        return this.instantiationService.createInstance(TextResourceEditorInput, canonicalResource, textResourceEditorInput.label, textResourceEditorInput.description, textResourceEditorInput.languageId, textResourceEditorInput.contents);
      }, (cachedInput) => {
        if (cachedInput instanceof UntitledTextEditorInput) {
          return;
        } else if (!(cachedInput instanceof TextResourceEditorInput)) {
          cachedInput.setPreferredResource(preferredResource);
          if (textResourceEditorInput.label) {
            cachedInput.setPreferredName(textResourceEditorInput.label);
          }
          if (textResourceEditorInput.description) {
            cachedInput.setPreferredDescription(textResourceEditorInput.description);
          }
          if (textResourceEditorInput.encoding) {
            cachedInput.setPreferredEncoding(textResourceEditorInput.encoding);
          }
          if (textResourceEditorInput.languageId) {
            cachedInput.setPreferredLanguageId(textResourceEditorInput.languageId);
          }
          if (typeof textResourceEditorInput.contents === "string") {
            cachedInput.setPreferredContents(textResourceEditorInput.contents);
          }
        } else {
          if (label) {
            cachedInput.setName(label);
          }
          if (textResourceEditorInput.description) {
            cachedInput.setDescription(textResourceEditorInput.description);
          }
          if (textResourceEditorInput.languageId) {
            cachedInput.setPreferredLanguageId(textResourceEditorInput.languageId);
          }
          if (typeof textResourceEditorInput.contents === "string") {
            cachedInput.setPreferredContents(textResourceEditorInput.contents);
          }
        }
      });
    }
    throw new Error(`ITextEditorService: Unable to create texteditor from ${JSON.stringify(input)}`);
  }
  createOrGetCached(resource, factoryFn, cachedFn) {
    let input = this.editorInputCache.get(resource);
    if (input) {
      cachedFn == null ? void 0 : cachedFn(input);
      return input;
    }
    input = factoryFn();
    this.editorInputCache.set(resource, input);
    Event.once(input.onWillDispose)(() => this.editorInputCache.delete(resource));
    return input;
  }
};
TextEditorService = __decorate([
  __param(0, IUntitledTextEditorService),
  __param(1, IInstantiationService),
  __param(2, IUriIdentityService),
  __param(3, IFileService),
  __param(4, IEditorResolverService)
], TextEditorService);

// node_modules/vscode/vscode/src/vs/workbench/services/lifecycle/common/lifecycleService.js
init_tslib_es6();
init_event();
init_async();
init_lifecycle();
init_log();
var AbstractLifecycleService_1;
var _a14;
var AbstractLifecycleService = (_a14 = class extends Disposable {
  get startupKind() {
    return this._startupKind;
  }
  get phase() {
    return this._phase;
  }
  constructor(logService, storageService) {
    super();
    this.logService = logService;
    this.storageService = storageService;
    this._onBeforeShutdown = this._register(new Emitter());
    this.onBeforeShutdown = this._onBeforeShutdown.event;
    this._onWillShutdown = this._register(new Emitter());
    this.onWillShutdown = this._onWillShutdown.event;
    this._onDidShutdown = this._register(new Emitter());
    this.onDidShutdown = this._onDidShutdown.event;
    this._onBeforeShutdownError = this._register(new Emitter());
    this.onBeforeShutdownError = this._onBeforeShutdownError.event;
    this._onShutdownVeto = this._register(new Emitter());
    this.onShutdownVeto = this._onShutdownVeto.event;
    this._phase = 1;
    this.phaseWhen = /* @__PURE__ */ new Map();
    this._startupKind = this.resolveStartupKind();
    this.storageService.onWillSaveState((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        this.storageService.store(AbstractLifecycleService_1.LAST_SHUTDOWN_REASON_KEY, this.shutdownReason, 1, 1);
      }
    });
  }
  resolveStartupKind() {
    const lastShutdownReason = this.storageService.getNumber(AbstractLifecycleService_1.LAST_SHUTDOWN_REASON_KEY, 1);
    this.storageService.remove(AbstractLifecycleService_1.LAST_SHUTDOWN_REASON_KEY, 1);
    let startupKind;
    switch (lastShutdownReason) {
      case 3:
        startupKind = 3;
        break;
      case 4:
        startupKind = 4;
        break;
      default:
        startupKind = 1;
    }
    this.logService.trace(`[lifecycle] starting up (startup kind: ${startupKind})`);
    return startupKind;
  }
  set phase(value) {
    if (value < this.phase) {
      throw new Error("Lifecycle cannot go backwards");
    }
    if (this._phase === value) {
      return;
    }
    this.logService.trace(`lifecycle: phase changed (value: ${value})`);
    this._phase = value;
    mark(`code/LifecyclePhase/${LifecyclePhaseToString(value)}`);
    const barrier = this.phaseWhen.get(this._phase);
    if (barrier) {
      barrier.open();
      this.phaseWhen.delete(this._phase);
    }
  }
  async when(phase) {
    if (phase <= this._phase) {
      return;
    }
    let barrier = this.phaseWhen.get(phase);
    if (!barrier) {
      barrier = new Barrier();
      this.phaseWhen.set(phase, barrier);
    }
    await barrier.wait();
  }
}, AbstractLifecycleService_1 = _a14, _a14.LAST_SHUTDOWN_REASON_KEY = "lifecyle.lastShutdownReason", _a14);
AbstractLifecycleService = AbstractLifecycleService_1 = __decorate([
  __param(0, ILogService),
  __param(1, IStorageService)
], AbstractLifecycleService);

// node_modules/vscode/vscode/src/vs/workbench/services/output/common/output.js
init_event();
init_platform2();
init_contextkey();
init_instantiation();
var OUTPUT_MIME = "text/x-code-output";
var OUTPUT_SCHEME = "output";
var OUTPUT_MODE_ID = "Log";
var LOG_MIME = "text/x-code-log-output";
var LOG_SCHEME = "log";
var LOG_MODE_ID = "log";
var OUTPUT_VIEW_ID = "workbench.panel.output";
var CONTEXT_IN_OUTPUT = new RawContextKey("inOutput", false);
var CONTEXT_ACTIVE_LOG_OUTPUT = new RawContextKey("activeLogOutput", false);
var CONTEXT_OUTPUT_SCROLL_LOCK = new RawContextKey(`outputView.scrollLock`, false);
var IOutputService = createDecorator("outputService");
var OutputChannelUpdateMode;
(function(OutputChannelUpdateMode2) {
  OutputChannelUpdateMode2[OutputChannelUpdateMode2["Append"] = 1] = "Append";
  OutputChannelUpdateMode2[OutputChannelUpdateMode2["Replace"] = 2] = "Replace";
  OutputChannelUpdateMode2[OutputChannelUpdateMode2["Clear"] = 3] = "Clear";
})(OutputChannelUpdateMode || (OutputChannelUpdateMode = {}));
var Extensions6 = {
  OutputChannels: "workbench.contributions.outputChannels"
};
var OutputChannelRegistry = class {
  constructor() {
    this.channels = /* @__PURE__ */ new Map();
    this._onDidRegisterChannel = new Emitter();
    this.onDidRegisterChannel = this._onDidRegisterChannel.event;
    this._onDidRemoveChannel = new Emitter();
    this.onDidRemoveChannel = this._onDidRemoveChannel.event;
  }
  registerChannel(descriptor) {
    if (!this.channels.has(descriptor.id)) {
      this.channels.set(descriptor.id, descriptor);
      this._onDidRegisterChannel.fire(descriptor.id);
    }
  }
  getChannels() {
    const result = [];
    this.channels.forEach((value) => result.push(value));
    return result;
  }
  getChannel(id) {
    return this.channels.get(id);
  }
  removeChannel(id) {
    this.channels.delete(id);
    this._onDidRemoveChannel.fire(id);
  }
};
Registry.add(Extensions6.OutputChannels, new OutputChannelRegistry());
var ACTIVE_OUTPUT_CHANNEL_CONTEXT = new RawContextKey("activeOutputChannel", "");

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/browser/outputServices.js
init_tslib_es6();
init_event();
init_uri();
init_lifecycle();
init_instantiation();
init_platform2();

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/browser/outputLinkProvider.js
init_tslib_es6();
init_async();
init_model2();
init_lifecycle();
init_languageConfigurationRegistry();
init_languageFeatures();
var OutputLinkProvider_1;
var _a15;
var OutputLinkProvider = (_a15 = class {
  constructor(contextService, modelService, languageConfigurationService, languageFeaturesService) {
    this.contextService = contextService;
    this.modelService = modelService;
    this.languageConfigurationService = languageConfigurationService;
    this.languageFeaturesService = languageFeaturesService;
    this.disposeWorkerScheduler = new RunOnceScheduler(() => this.disposeWorker(), OutputLinkProvider_1.DISPOSE_WORKER_TIME);
    this.registerListeners();
    this.updateLinkProviderWorker();
  }
  registerListeners() {
    this.contextService.onDidChangeWorkspaceFolders(() => this.updateLinkProviderWorker());
  }
  updateLinkProviderWorker() {
    const folders = this.contextService.getWorkspace().folders;
    if (folders.length > 0) {
      if (!this.linkProviderRegistration) {
        this.linkProviderRegistration = this.languageFeaturesService.linkProvider.register([{ language: OUTPUT_MODE_ID, scheme: "*" }, { language: LOG_MODE_ID, scheme: "*" }], {
          provideLinks: async (model) => {
            const links = await this.provideLinks(model.uri);
            return links && { links };
          }
        });
      }
    } else {
      dispose(this.linkProviderRegistration);
      this.linkProviderRegistration = void 0;
    }
    this.disposeWorker();
    this.disposeWorkerScheduler.cancel();
  }
  getOrCreateWorker() {
    this.disposeWorkerScheduler.schedule();
    if (!this.worker) {
      const createData = {
        workspaceFolders: this.contextService.getWorkspace().folders.map((folder) => folder.uri.toString())
      };
      this.worker = createWebWorker(this.modelService, this.languageConfigurationService, {
        moduleId: "vs/workbench/contrib/output/common/outputLinkComputer",
        createData,
        label: "outputLinkComputer"
      });
    }
    return this.worker;
  }
  async provideLinks(modelUri) {
    const linkComputer = await this.getOrCreateWorker().withSyncedResources([modelUri]);
    return linkComputer.computeLinks(modelUri.toString());
  }
  disposeWorker() {
    if (this.worker) {
      this.worker.dispose();
      this.worker = void 0;
    }
  }
}, OutputLinkProvider_1 = _a15, _a15.DISPOSE_WORKER_TIME = 3 * 60 * 1e3, _a15);
OutputLinkProvider = OutputLinkProvider_1 = __decorate([
  __param(0, IWorkspaceContextService),
  __param(1, IModelService),
  __param(2, ILanguageConfigurationService),
  __param(3, ILanguageFeaturesService)
], OutputLinkProvider);

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/browser/outputServices.js
init_resolverService();
init_log();

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/common/outputChannelModelService.js
init_tslib_es6();
init_instantiation();
init_files();

// node_modules/vscode/vscode/src/vs/base/common/date.js
init_nls();
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var month = day * 30;
var year = day * 365;
function fromNow(date, appendAgoLabel, useFullTimeWords, disallowNow) {
  if (typeof date !== "number") {
    date = date.getTime();
  }
  const seconds = Math.round(((/* @__PURE__ */ new Date()).getTime() - date) / 1e3);
  if (seconds < -30) {
    return localize("date.fromNow.in", "in {0}", fromNow((/* @__PURE__ */ new Date()).getTime() + seconds * 1e3, false));
  }
  if (!disallowNow && seconds < 30) {
    return localize("date.fromNow.now", "now");
  }
  let value;
  if (seconds < minute) {
    value = seconds;
    if (appendAgoLabel) {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.seconds.singular.ago.fullWord", "{0} second ago", value) : localize("date.fromNow.seconds.singular.ago", "{0} sec ago", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.seconds.plural.ago.fullWord", "{0} seconds ago", value) : localize("date.fromNow.seconds.plural.ago", "{0} secs ago", value);
      }
    } else {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.seconds.singular.fullWord", "{0} second", value) : localize("date.fromNow.seconds.singular", "{0} sec", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.seconds.plural.fullWord", "{0} seconds", value) : localize("date.fromNow.seconds.plural", "{0} secs", value);
      }
    }
  }
  if (seconds < hour) {
    value = Math.floor(seconds / minute);
    if (appendAgoLabel) {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.minutes.singular.ago.fullWord", "{0} minute ago", value) : localize("date.fromNow.minutes.singular.ago", "{0} min ago", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.minutes.plural.ago.fullWord", "{0} minutes ago", value) : localize("date.fromNow.minutes.plural.ago", "{0} mins ago", value);
      }
    } else {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.minutes.singular.fullWord", "{0} minute", value) : localize("date.fromNow.minutes.singular", "{0} min", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.minutes.plural.fullWord", "{0} minutes", value) : localize("date.fromNow.minutes.plural", "{0} mins", value);
      }
    }
  }
  if (seconds < day) {
    value = Math.floor(seconds / hour);
    if (appendAgoLabel) {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.hours.singular.ago.fullWord", "{0} hour ago", value) : localize("date.fromNow.hours.singular.ago", "{0} hr ago", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.hours.plural.ago.fullWord", "{0} hours ago", value) : localize("date.fromNow.hours.plural.ago", "{0} hrs ago", value);
      }
    } else {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.hours.singular.fullWord", "{0} hour", value) : localize("date.fromNow.hours.singular", "{0} hr", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.hours.plural.fullWord", "{0} hours", value) : localize("date.fromNow.hours.plural", "{0} hrs", value);
      }
    }
  }
  if (seconds < week) {
    value = Math.floor(seconds / day);
    if (appendAgoLabel) {
      return value === 1 ? localize("date.fromNow.days.singular.ago", "{0} day ago", value) : localize("date.fromNow.days.plural.ago", "{0} days ago", value);
    } else {
      return value === 1 ? localize("date.fromNow.days.singular", "{0} day", value) : localize("date.fromNow.days.plural", "{0} days", value);
    }
  }
  if (seconds < month) {
    value = Math.floor(seconds / week);
    if (appendAgoLabel) {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.weeks.singular.ago.fullWord", "{0} week ago", value) : localize("date.fromNow.weeks.singular.ago", "{0} wk ago", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.weeks.plural.ago.fullWord", "{0} weeks ago", value) : localize("date.fromNow.weeks.plural.ago", "{0} wks ago", value);
      }
    } else {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.weeks.singular.fullWord", "{0} week", value) : localize("date.fromNow.weeks.singular", "{0} wk", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.weeks.plural.fullWord", "{0} weeks", value) : localize("date.fromNow.weeks.plural", "{0} wks", value);
      }
    }
  }
  if (seconds < year) {
    value = Math.floor(seconds / month);
    if (appendAgoLabel) {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.months.singular.ago.fullWord", "{0} month ago", value) : localize("date.fromNow.months.singular.ago", "{0} mo ago", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.months.plural.ago.fullWord", "{0} months ago", value) : localize("date.fromNow.months.plural.ago", "{0} mos ago", value);
      }
    } else {
      if (value === 1) {
        return useFullTimeWords ? localize("date.fromNow.months.singular.fullWord", "{0} month", value) : localize("date.fromNow.months.singular", "{0} mo", value);
      } else {
        return useFullTimeWords ? localize("date.fromNow.months.plural.fullWord", "{0} months", value) : localize("date.fromNow.months.plural", "{0} mos", value);
      }
    }
  }
  value = Math.floor(seconds / year);
  if (appendAgoLabel) {
    if (value === 1) {
      return useFullTimeWords ? localize("date.fromNow.years.singular.ago.fullWord", "{0} year ago", value) : localize("date.fromNow.years.singular.ago", "{0} yr ago", value);
    } else {
      return useFullTimeWords ? localize("date.fromNow.years.plural.ago.fullWord", "{0} years ago", value) : localize("date.fromNow.years.plural.ago", "{0} yrs ago", value);
    }
  } else {
    if (value === 1) {
      return useFullTimeWords ? localize("date.fromNow.years.singular.fullWord", "{0} year", value) : localize("date.fromNow.years.singular", "{0} yr", value);
    } else {
      return useFullTimeWords ? localize("date.fromNow.years.plural.fullWord", "{0} years", value) : localize("date.fromNow.years.plural", "{0} yrs", value);
    }
  }
}
function toLocalISOString(date) {
  return date.getFullYear() + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0") + "T" + String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0") + "." + (date.getMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/common/outputChannelModelService.js
init_resources();

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/common/outputChannelModel.js
init_tslib_es6();
init_instantiation();
init_resources();
init_editorWorker();
init_event();
init_async();
init_files();
init_model2();
init_lifecycle();
init_types();
init_editOperation();
init_position();
init_range();
init_buffer();
init_log();
init_cancellation();
init_errors();
var OutputFileListener = class extends Disposable {
  constructor(file, fileService, logService) {
    super();
    this.file = file;
    this.fileService = fileService;
    this.logService = logService;
    this._onDidContentChange = new Emitter();
    this.onDidContentChange = this._onDidContentChange.event;
    this.watching = false;
    this.syncDelayer = new ThrottledDelayer(500);
  }
  watch(eTag) {
    if (!this.watching) {
      this.etag = eTag;
      this.poll();
      this.logService.trace("Started polling", this.file.toString());
      this.watching = true;
    }
  }
  poll() {
    const loop = () => this.doWatch().then(() => this.poll());
    this.syncDelayer.trigger(loop).catch((error) => {
      if (!isCancellationError(error)) {
        throw error;
      }
    });
  }
  async doWatch() {
    const stat = await this.fileService.stat(this.file);
    if (stat.etag !== this.etag) {
      this.etag = stat.etag;
      this._onDidContentChange.fire(stat.size);
    }
  }
  unwatch() {
    if (this.watching) {
      this.syncDelayer.cancel();
      this.watching = false;
      this.logService.trace("Stopped polling", this.file.toString());
    }
  }
  dispose() {
    this.unwatch();
    super.dispose();
  }
};
var FileOutputChannelModel = class FileOutputChannelModel2 extends Disposable {
  constructor(modelUri, language, file, fileService, modelService, logService, editorWorkerService) {
    super();
    this.modelUri = modelUri;
    this.language = language;
    this.file = file;
    this.fileService = fileService;
    this.modelService = modelService;
    this.editorWorkerService = editorWorkerService;
    this._onDispose = this._register(new Emitter());
    this.onDispose = this._onDispose.event;
    this.etag = "";
    this.loadModelPromise = null;
    this.model = null;
    this.modelUpdateInProgress = false;
    this.modelUpdateCancellationSource = this._register(new MutableDisposable());
    this.appendThrottler = this._register(new ThrottledDelayer(300));
    this.startOffset = 0;
    this.endOffset = 0;
    this.fileHandler = this._register(new OutputFileListener(this.file, this.fileService, logService));
    this._register(this.fileHandler.onDidContentChange((size) => this.onDidContentChange(size)));
    this._register(toDisposable(() => this.fileHandler.unwatch()));
  }
  append(message) {
    throw new Error("Not supported");
  }
  replace(message) {
    throw new Error("Not supported");
  }
  clear() {
    this.update(OutputChannelUpdateMode.Clear, this.endOffset, true);
  }
  update(mode, till, immediate) {
    const loadModelPromise = this.loadModelPromise ? this.loadModelPromise : Promise.resolve();
    loadModelPromise.then(() => this.doUpdate(mode, till, immediate));
  }
  loadModel() {
    this.loadModelPromise = Promises.withAsyncBody(async (c, e) => {
      try {
        let content = "";
        if (await this.fileService.exists(this.file)) {
          const fileContent = await this.fileService.readFile(this.file, { position: this.startOffset });
          this.endOffset = this.startOffset + fileContent.value.byteLength;
          this.etag = fileContent.etag;
          content = fileContent.value.toString();
        } else {
          this.startOffset = 0;
          this.endOffset = 0;
        }
        c(this.createModel(content));
      } catch (error) {
        e(error);
      }
    });
    return this.loadModelPromise;
  }
  createModel(content) {
    if (this.model) {
      this.model.setValue(content);
    } else {
      this.model = this.modelService.createModel(content, this.language, this.modelUri);
      this.fileHandler.watch(this.etag);
      const disposable = this.model.onWillDispose(() => {
        this.cancelModelUpdate();
        this.fileHandler.unwatch();
        this.model = null;
        dispose(disposable);
      });
    }
    return this.model;
  }
  doUpdate(mode, till, immediate) {
    if (mode === OutputChannelUpdateMode.Clear || mode === OutputChannelUpdateMode.Replace) {
      this.startOffset = this.endOffset = isNumber(till) ? till : this.endOffset;
      this.cancelModelUpdate();
    }
    if (!this.model) {
      return;
    }
    this.modelUpdateInProgress = true;
    if (!this.modelUpdateCancellationSource.value) {
      this.modelUpdateCancellationSource.value = new CancellationTokenSource();
    }
    const token = this.modelUpdateCancellationSource.value.token;
    if (mode === OutputChannelUpdateMode.Clear) {
      this.clearContent(this.model);
    } else if (mode === OutputChannelUpdateMode.Replace) {
      this.replacePromise = this.replaceContent(this.model, token).finally(() => this.replacePromise = void 0);
    } else {
      this.appendContent(this.model, immediate, token);
    }
  }
  clearContent(model) {
    this.doUpdateModel(model, [EditOperation.delete(model.getFullModelRange())], VSBuffer.fromString(""));
  }
  appendContent(model, immediate, token) {
    this.appendThrottler.trigger(async () => {
      if (token.isCancellationRequested) {
        return;
      }
      if (this.replacePromise) {
        try {
          await this.replacePromise;
        } catch (e) {
        }
        if (token.isCancellationRequested) {
          return;
        }
      }
      const contentToAppend = await this.getContentToUpdate();
      if (token.isCancellationRequested) {
        return;
      }
      const lastLine = model.getLineCount();
      const lastLineMaxColumn = model.getLineMaxColumn(lastLine);
      const edits = [EditOperation.insert(new Position(lastLine, lastLineMaxColumn), contentToAppend.toString())];
      this.doUpdateModel(model, edits, contentToAppend);
    }, immediate ? 0 : void 0).catch((error) => {
      if (!isCancellationError(error)) {
        throw error;
      }
    });
  }
  async replaceContent(model, token) {
    const contentToReplace = await this.getContentToUpdate();
    if (token.isCancellationRequested) {
      return;
    }
    const edits = await this.getReplaceEdits(model, contentToReplace.toString());
    if (token.isCancellationRequested) {
      return;
    }
    this.doUpdateModel(model, edits, contentToReplace);
  }
  async getReplaceEdits(model, contentToReplace) {
    if (!contentToReplace) {
      return [EditOperation.delete(model.getFullModelRange())];
    }
    if (contentToReplace !== model.getValue()) {
      const edits = await this.editorWorkerService.computeMoreMinimalEdits(model.uri, [{ text: contentToReplace.toString(), range: model.getFullModelRange() }]);
      if (edits == null ? void 0 : edits.length) {
        return edits.map((edit) => EditOperation.replace(Range.lift(edit.range), edit.text));
      }
    }
    return [];
  }
  doUpdateModel(model, edits, content) {
    if (edits.length) {
      model.applyEdits(edits);
    }
    this.endOffset = this.endOffset + content.byteLength;
    this.modelUpdateInProgress = false;
  }
  cancelModelUpdate() {
    var _a43;
    (_a43 = this.modelUpdateCancellationSource.value) == null ? void 0 : _a43.cancel();
    this.modelUpdateCancellationSource.value = void 0;
    this.appendThrottler.cancel();
    this.replacePromise = void 0;
    this.modelUpdateInProgress = false;
  }
  async getContentToUpdate() {
    const content = await this.fileService.readFile(this.file, { position: this.endOffset });
    this.etag = content.etag;
    return content.value;
  }
  onDidContentChange(size) {
    if (this.model) {
      if (!this.modelUpdateInProgress) {
        if (isNumber(size) && this.endOffset > size) {
          this.update(OutputChannelUpdateMode.Clear, 0, true);
        }
      }
      this.update(OutputChannelUpdateMode.Append, void 0, false);
    }
  }
  isVisible() {
    return !!this.model;
  }
  dispose() {
    this._onDispose.fire();
    super.dispose();
  }
};
FileOutputChannelModel = __decorate([
  __param(3, IFileService),
  __param(4, IModelService),
  __param(5, ILogService),
  __param(6, IEditorWorkerService)
], FileOutputChannelModel);
var OutputChannelBackedByFile = class OutputChannelBackedByFile2 extends FileOutputChannelModel {
  constructor(id, modelUri, language, file, fileService, modelService, loggerService, logService, editorWorkerService) {
    super(modelUri, language, file, fileService, modelService, logService, editorWorkerService);
    this.logger = loggerService.createLogger(file, { logLevel: "always", donotRotate: true, donotUseFormatters: true, hidden: true });
    this._offset = 0;
  }
  append(message) {
    this.write(message);
    this.update(OutputChannelUpdateMode.Append, void 0, this.isVisible());
  }
  replace(message) {
    const till = this._offset;
    this.write(message);
    this.update(OutputChannelUpdateMode.Replace, till, true);
  }
  write(content) {
    this._offset += VSBuffer.fromString(content).byteLength;
    this.logger.info(content);
    if (this.isVisible()) {
      this.logger.flush();
    }
  }
};
OutputChannelBackedByFile = __decorate([
  __param(4, IFileService),
  __param(5, IModelService),
  __param(6, ILoggerService),
  __param(7, ILogService),
  __param(8, IEditorWorkerService)
], OutputChannelBackedByFile);
var DelegatedOutputChannelModel = class DelegatedOutputChannelModel2 extends Disposable {
  constructor(id, modelUri, language, outputDir, instantiationService, fileService) {
    super();
    this.instantiationService = instantiationService;
    this.fileService = fileService;
    this._onDispose = this._register(new Emitter());
    this.onDispose = this._onDispose.event;
    this.outputChannelModel = this.createOutputChannelModel(id, modelUri, language, outputDir);
  }
  async createOutputChannelModel(id, modelUri, language, outputDirPromise) {
    const outputDir = await outputDirPromise;
    const file = joinPath(outputDir, `${id.replace(/[\\/:\*\?"<>\|]/g, "")}.log`);
    await this.fileService.createFile(file);
    const outputChannelModel = this._register(this.instantiationService.createInstance(OutputChannelBackedByFile, id, modelUri, language, file));
    this._register(outputChannelModel.onDispose(() => this._onDispose.fire()));
    return outputChannelModel;
  }
  append(output) {
    this.outputChannelModel.then((outputChannelModel) => outputChannelModel.append(output));
  }
  update(mode, till, immediate) {
    this.outputChannelModel.then((outputChannelModel) => outputChannelModel.update(mode, till, immediate));
  }
  loadModel() {
    return this.outputChannelModel.then((outputChannelModel) => outputChannelModel.loadModel());
  }
  clear() {
    this.outputChannelModel.then((outputChannelModel) => outputChannelModel.clear());
  }
  replace(value) {
    this.outputChannelModel.then((outputChannelModel) => outputChannelModel.replace(value));
  }
};
DelegatedOutputChannelModel = __decorate([
  __param(4, IInstantiationService),
  __param(5, IFileService)
], DelegatedOutputChannelModel);

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/common/outputChannelModelService.js
var IOutputChannelModelService = createDecorator("outputChannelModelService");
var OutputChannelModelService = class OutputChannelModelService2 {
  constructor(fileService, instantiationService, environmentService) {
    this.fileService = fileService;
    this.instantiationService = instantiationService;
    this._outputDir = null;
    this.outputLocation = joinPath(environmentService.windowLogsPath, `output_${toLocalISOString(/* @__PURE__ */ new Date()).replace(/-|:|\.\d+Z$/g, "")}`);
  }
  createOutputChannelModel(id, modelUri, language, file) {
    return file ? this.instantiationService.createInstance(FileOutputChannelModel, modelUri, language, file) : this.instantiationService.createInstance(DelegatedOutputChannelModel, id, modelUri, language, this.outputDir);
  }
  get outputDir() {
    if (!this._outputDir) {
      this._outputDir = this.fileService.createFolder(this.outputLocation).then(() => this.outputLocation);
    }
    return this._outputDir;
  }
};
OutputChannelModelService = __decorate([
  __param(0, IFileService),
  __param(1, IInstantiationService),
  __param(2, IWorkbenchEnvironmentService)
], OutputChannelModelService);

// node_modules/vscode/vscode/src/vs/workbench/contrib/output/browser/outputServices.js
init_language();
init_contextkey();
var OUTPUT_ACTIVE_CHANNEL_KEY = "output.activechannel";
var OutputChannel = class OutputChannel2 extends Disposable {
  constructor(outputChannelDescriptor, outputChannelModelService, languageService) {
    super();
    this.outputChannelDescriptor = outputChannelDescriptor;
    this.scrollLock = false;
    this.id = outputChannelDescriptor.id;
    this.label = outputChannelDescriptor.label;
    this.uri = URI.from({ scheme: OUTPUT_SCHEME, path: this.id });
    this.model = this._register(outputChannelModelService.createOutputChannelModel(this.id, this.uri, outputChannelDescriptor.languageId ? languageService.createById(outputChannelDescriptor.languageId) : languageService.createByMimeType(outputChannelDescriptor.log ? LOG_MIME : OUTPUT_MIME), outputChannelDescriptor.file));
  }
  append(output) {
    this.model.append(output);
  }
  update(mode, till) {
    this.model.update(mode, till, true);
  }
  clear() {
    this.model.clear();
  }
  replace(value) {
    this.model.replace(value);
  }
};
OutputChannel = __decorate([
  __param(1, IOutputChannelModelService),
  __param(2, ILanguageService)
], OutputChannel);
var OutputService = class OutputService2 extends Disposable {
  constructor(storageService, instantiationService, textModelResolverService, logService, lifecycleService, viewsService, contextKeyService) {
    super();
    this.storageService = storageService;
    this.instantiationService = instantiationService;
    this.logService = logService;
    this.lifecycleService = lifecycleService;
    this.viewsService = viewsService;
    this.channels = /* @__PURE__ */ new Map();
    this._onActiveOutputChannel = this._register(new Emitter());
    this.onActiveOutputChannel = this._onActiveOutputChannel.event;
    this.activeChannelIdInStorage = this.storageService.get(OUTPUT_ACTIVE_CHANNEL_KEY, 1, "");
    this.activeOutputChannelContext = ACTIVE_OUTPUT_CHANNEL_CONTEXT.bindTo(contextKeyService);
    this.activeOutputChannelContext.set(this.activeChannelIdInStorage);
    this._register(this.onActiveOutputChannel((channel) => this.activeOutputChannelContext.set(channel)));
    this.activeLogOutputChannelContext = CONTEXT_ACTIVE_LOG_OUTPUT.bindTo(contextKeyService);
    textModelResolverService.registerTextModelContentProvider(OUTPUT_SCHEME, this);
    instantiationService.createInstance(OutputLinkProvider);
    const registry2 = Registry.as(Extensions6.OutputChannels);
    for (const channelIdentifier of registry2.getChannels()) {
      this.onDidRegisterChannel(channelIdentifier.id);
    }
    this._register(registry2.onDidRegisterChannel(this.onDidRegisterChannel, this));
    if (!this.activeChannel) {
      const channels = this.getChannelDescriptors();
      this.setActiveChannel(channels && channels.length > 0 ? this.getChannel(channels[0].id) : void 0);
    }
    this._register(Event.filter(this.viewsService.onDidChangeViewVisibility, (e) => e.id === OUTPUT_VIEW_ID && e.visible)(() => {
      var _a43;
      if (this.activeChannel) {
        (_a43 = this.viewsService.getActiveViewWithId(OUTPUT_VIEW_ID)) == null ? void 0 : _a43.showChannel(this.activeChannel, true);
      }
    }));
    this._register(this.lifecycleService.onDidShutdown(() => this.dispose()));
  }
  provideTextContent(resource) {
    const channel = this.getChannel(resource.path);
    if (channel) {
      return channel.model.loadModel();
    }
    return null;
  }
  async showChannel(id, preserveFocus) {
    var _a43;
    const channel = this.getChannel(id);
    if (((_a43 = this.activeChannel) == null ? void 0 : _a43.id) !== (channel == null ? void 0 : channel.id)) {
      this.setActiveChannel(channel);
      this._onActiveOutputChannel.fire(id);
    }
    const outputView = await this.viewsService.openView(OUTPUT_VIEW_ID, !preserveFocus);
    if (outputView && channel) {
      outputView.showChannel(channel, !!preserveFocus);
    }
  }
  getChannel(id) {
    return this.channels.get(id);
  }
  getChannelDescriptor(id) {
    return Registry.as(Extensions6.OutputChannels).getChannel(id);
  }
  getChannelDescriptors() {
    return Registry.as(Extensions6.OutputChannels).getChannels();
  }
  getActiveChannel() {
    return this.activeChannel;
  }
  async onDidRegisterChannel(channelId) {
    const channel = this.createChannel(channelId);
    this.channels.set(channelId, channel);
    if (!this.activeChannel || this.activeChannelIdInStorage === channelId) {
      this.setActiveChannel(channel);
      this._onActiveOutputChannel.fire(channelId);
      const outputView = this.viewsService.getActiveViewWithId(OUTPUT_VIEW_ID);
      outputView == null ? void 0 : outputView.showChannel(channel, true);
    }
  }
  createChannel(id) {
    const channelDisposables = [];
    const channel = this.instantiateChannel(id);
    channel.model.onDispose(() => {
      if (this.activeChannel === channel) {
        const channels = this.getChannelDescriptors();
        const channel2 = channels.length ? this.getChannel(channels[0].id) : void 0;
        if (channel2 && this.viewsService.isViewVisible(OUTPUT_VIEW_ID)) {
          this.showChannel(channel2.id);
        } else {
          this.setActiveChannel(void 0);
        }
      }
      Registry.as(Extensions6.OutputChannels).removeChannel(id);
      dispose(channelDisposables);
    }, channelDisposables);
    return channel;
  }
  instantiateChannel(id) {
    const channelData = Registry.as(Extensions6.OutputChannels).getChannel(id);
    if (!channelData) {
      this.logService.error(`Channel '${id}' is not registered yet`);
      throw new Error(`Channel '${id}' is not registered yet`);
    }
    return this.instantiationService.createInstance(OutputChannel, channelData);
  }
  setActiveChannel(channel) {
    var _a43, _b;
    this.activeChannel = channel;
    this.activeLogOutputChannelContext.set(!!((_a43 = channel == null ? void 0 : channel.outputChannelDescriptor) == null ? void 0 : _a43.file) && ((_b = channel == null ? void 0 : channel.outputChannelDescriptor) == null ? void 0 : _b.log));
    if (this.activeChannel) {
      this.storageService.store(OUTPUT_ACTIVE_CHANNEL_KEY, this.activeChannel.id, 1, 1);
    } else {
      this.storageService.remove(OUTPUT_ACTIVE_CHANNEL_KEY, 1);
    }
  }
};
OutputService = __decorate([
  __param(0, IStorageService),
  __param(1, IInstantiationService),
  __param(2, ITextModelService),
  __param(3, ILogService),
  __param(4, ILifecycleService),
  __param(5, IViewsService),
  __param(6, IContextKeyService)
], OutputService);
var LogContentProvider = class LogContentProvider2 {
  constructor(outputService, outputChannelModelService, languageService) {
    this.outputService = outputService;
    this.outputChannelModelService = outputChannelModelService;
    this.languageService = languageService;
    this.channelModels = /* @__PURE__ */ new Map();
  }
  provideTextContent(resource) {
    if (resource.scheme === LOG_SCHEME) {
      const channelModel = this.getChannelModel(resource);
      if (channelModel) {
        return channelModel.loadModel();
      }
    }
    return null;
  }
  getChannelModel(resource) {
    const channelId = resource.path;
    let channelModel = this.channelModels.get(channelId);
    if (!channelModel) {
      const channelDisposables = [];
      const outputChannelDescriptor = this.outputService.getChannelDescriptors().filter(({ id }) => id === channelId)[0];
      if (outputChannelDescriptor && outputChannelDescriptor.file) {
        channelModel = this.outputChannelModelService.createOutputChannelModel(channelId, resource, outputChannelDescriptor.languageId ? this.languageService.createById(outputChannelDescriptor.languageId) : this.languageService.createByMimeType(outputChannelDescriptor.log ? LOG_MIME : OUTPUT_MIME), outputChannelDescriptor.file);
        channelModel.onDispose(() => dispose(channelDisposables), channelDisposables);
        this.channelModels.set(channelId, channelModel);
      }
    }
    return channelModel;
  }
};
LogContentProvider = __decorate([
  __param(0, IOutputService),
  __param(1, IOutputChannelModelService),
  __param(2, ILanguageService)
], LogContentProvider);

// node_modules/vscode/missing-services.js
init_configuration();

// node_modules/vscode/vscode/src/vs/workbench/services/hover/browser/hover.js
init_instantiation();
var IHoverService = createDecorator("hoverService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/files.js
init_uri();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/common/files.js
init_tslib_es6();
init_files();
init_contextkey();
init_lifecycle();
init_model2();
init_language();
init_functional();
init_nls();
var TextFileContentProvider_1;
var VIEWLET_ID = "workbench.view.explorer";
var VIEW_ID = "workbench.explorer.fileView";
var ExplorerViewletVisibleContext = new RawContextKey(
  "explorerViewletVisible",
  true,
  { type: "boolean", description: localize("explorerViewletVisible", "True when the EXPLORER viewlet is visible.") }
);
var FoldersViewVisibleContext = new RawContextKey("foldersViewVisible", true, { type: "boolean", description: localize(
  "foldersViewVisible",
  "True when the FOLDERS view (the file tree within the explorer view container) is visible."
) });
var ExplorerFolderContext = new RawContextKey(
  "explorerResourceIsFolder",
  false,
  { type: "boolean", description: localize(
    "explorerResourceIsFolder",
    "True when the focused item in the EXPLORER is a folder."
  ) }
);
var ExplorerResourceReadonlyContext = new RawContextKey(
  "explorerResourceReadonly",
  false,
  { type: "boolean", description: localize(
    "explorerResourceReadonly",
    "True when the focused item in the EXPLORER is read-only."
  ) }
);
var ExplorerResourceNotReadonlyContext = ExplorerResourceReadonlyContext.toNegated();
var ExplorerResourceAvailableEditorIdsContext = new RawContextKey("explorerResourceAvailableEditorIds", "");
var ExplorerRootContext = new RawContextKey(
  "explorerResourceIsRoot",
  false,
  { type: "boolean", description: localize(
    "explorerResourceIsRoot",
    "True when the focused item in the EXPLORER is a root folder."
  ) }
);
var ExplorerResourceCut = new RawContextKey(
  "explorerResourceCut",
  false,
  { type: "boolean", description: localize(
    "explorerResourceCut",
    "True when an item in the EXPLORER has been cut for cut and paste."
  ) }
);
var ExplorerResourceMoveableToTrash = new RawContextKey(
  "explorerResourceMoveableToTrash",
  false,
  { type: "boolean", description: localize(
    "explorerResourceMoveableToTrash",
    "True when the focused item in the EXPLORER can be moved to trash."
  ) }
);
var FilesExplorerFocusedContext = new RawContextKey("filesExplorerFocus", true, { type: "boolean", description: localize("filesExplorerFocus", "True when the focus is inside the EXPLORER view.") });
var OpenEditorsFocusedContext = new RawContextKey("openEditorsFocus", true, { type: "boolean", description: localize("openEditorsFocus", "True when the focus is inside the OPEN EDITORS view.") });
var ExplorerFocusedContext = new RawContextKey(
  "explorerViewletFocus",
  true,
  { type: "boolean", description: localize(
    "explorerViewletFocus",
    "True when the focus is inside the EXPLORER viewlet."
  ) }
);
var ExplorerCompressedFocusContext = new RawContextKey(
  "explorerViewletCompressedFocus",
  true,
  { type: "boolean", description: localize(
    "explorerViewletCompressedFocus",
    "True when the focused item in the EXPLORER view is a compact item."
  ) }
);
var ExplorerCompressedFirstFocusContext = new RawContextKey(
  "explorerViewletCompressedFirstFocus",
  true,
  { type: "boolean", description: localize(
    "explorerViewletCompressedFirstFocus",
    "True when the focus is inside a compact item's first part in the EXPLORER view."
  ) }
);
var ExplorerCompressedLastFocusContext = new RawContextKey(
  "explorerViewletCompressedLastFocus",
  true,
  { type: "boolean", description: localize(
    "explorerViewletCompressedLastFocus",
    "True when the focus is inside a compact item's last part in the EXPLORER view."
  ) }
);
var ViewHasSomeCollapsibleRootItemContext = new RawContextKey(
  "viewHasSomeCollapsibleItem",
  false,
  { type: "boolean", description: localize(
    "viewHasSomeCollapsibleItem",
    "True when a workspace in the EXPLORER view has some collapsible root child."
  ) }
);
var FilesExplorerFocusCondition = ContextKeyExpr.and(
  FoldersViewVisibleContext,
  FilesExplorerFocusedContext,
  ContextKeyExpr.not(InputFocusedContextKey)
);
var ExplorerFocusCondition = ContextKeyExpr.and(
  FoldersViewVisibleContext,
  ExplorerFocusedContext,
  ContextKeyExpr.not(InputFocusedContextKey)
);
var TextFileContentProvider = TextFileContentProvider_1 = class TextFileContentProvider2 extends Disposable {
  constructor(textFileService, fileService, languageService, modelService) {
    super();
    this.textFileService = textFileService;
    this.fileService = fileService;
    this.languageService = languageService;
    this.modelService = modelService;
    this.fileWatcherDisposable = this._register(new MutableDisposable());
  }
  static async open(resource, scheme, label, editorService, options) {
    await editorService.openEditor({
      original: { resource: TextFileContentProvider_1.resourceToTextFile(scheme, resource) },
      modified: { resource },
      label,
      options
    });
  }
  static resourceToTextFile(scheme, resource) {
    return resource.with({ scheme, query: JSON.stringify({ scheme: resource.scheme, query: resource.query }) });
  }
  static textFileToResource(resource) {
    const { scheme, query } = JSON.parse(resource.query);
    return resource.with({ scheme, query });
  }
  async provideTextContent(resource) {
    if (!resource.query) {
      return null;
    }
    const savedFileResource = TextFileContentProvider_1.textFileToResource(resource);
    const codeEditorModel = await this.resolveEditorModel(resource);
    if (!this.fileWatcherDisposable.value) {
      this.fileWatcherDisposable.value = this.fileService.onDidFilesChange((changes) => {
        if (changes.contains(savedFileResource, 0)) {
          this.resolveEditorModel(resource, false);
        }
      });
      if (codeEditorModel) {
        once(codeEditorModel.onWillDispose)(() => this.fileWatcherDisposable.clear());
      }
    }
    return codeEditorModel;
  }
  async resolveEditorModel(resource, createAsNeeded = true) {
    const savedFileResource = TextFileContentProvider_1.textFileToResource(resource);
    const content = await this.textFileService.readStream(savedFileResource);
    let codeEditorModel = this.modelService.getModel(resource);
    if (codeEditorModel) {
      this.modelService.updateModel(codeEditorModel, content.value);
    } else if (createAsNeeded) {
      const textFileModel = this.modelService.getModel(savedFileResource);
      let languageSelector;
      if (textFileModel) {
        languageSelector = this.languageService.createById(textFileModel.getLanguageId());
      } else {
        languageSelector = this.languageService.createByFilepathOrFirstLine(savedFileResource);
      }
      codeEditorModel = this.modelService.createModel(content.value, languageSelector, resource);
    }
    return codeEditorModel;
  }
};
TextFileContentProvider = TextFileContentProvider_1 = __decorate([
  __param(0, ITextFileService),
  __param(1, IFileService),
  __param(2, ILanguageService),
  __param(3, IModelService)
], TextFileContentProvider);
var _OpenEditor = class _OpenEditor {
  constructor(_editor, _group) {
    this._editor = _editor;
    this._group = _group;
    this.id = _OpenEditor.COUNTER++;
  }
  get editor() {
    return this._editor;
  }
  get group() {
    return this._group;
  }
  get groupId() {
    return this._group.id;
  }
  getId() {
    return `openeditor:${this.groupId}:${this.id}`;
  }
  isPreview() {
    return !this._group.isPinned(this.editor);
  }
  isSticky() {
    return this._group.isSticky(this.editor);
  }
  getResource() {
    return EditorResourceAccessor.getOriginalUri(this.editor, { supportSideBySide: SideBySideEditor.PRIMARY });
  }
};
_OpenEditor.COUNTER = 0;
var OpenEditor = _OpenEditor;

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/common/explorerModel.js
init_tslib_es6();
init_uri();
init_extpath();
init_path();
init_map();
init_strings();
init_arrays();
init_lifecycle();
init_event();
init_resources();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/common/explorerFileNestingTrie.js
var ExplorerFileNestingTrie = class {
  constructor(config) {
    this.root = new PreTrie();
    for (const [parentPattern, childPatterns] of config) {
      for (const childPattern of childPatterns) {
        this.root.add(parentPattern, childPattern);
      }
    }
  }
  toString() {
    return this.root.toString();
  }
  getAttributes(filename, dirname2) {
    const lastDot = filename.lastIndexOf(".");
    if (lastDot < 1) {
      return {
        dirname: dirname2,
        basename: filename,
        extname: ""
      };
    } else {
      return {
        dirname: dirname2,
        basename: filename.substring(0, lastDot),
        extname: filename.substring(lastDot + 1)
      };
    }
  }
  nest(files, dirname2) {
    const parentFinder = new PreTrie();
    for (const potentialParent of files) {
      const attributes = this.getAttributes(potentialParent, dirname2);
      const children = this.root.get(potentialParent, attributes);
      for (const child of children) {
        parentFinder.add(child, potentialParent);
      }
    }
    const findAllRootAncestors = (file, seen = /* @__PURE__ */ new Set()) => {
      if (seen.has(file)) {
        return [];
      }
      seen.add(file);
      const attributes = this.getAttributes(file, dirname2);
      const ancestors = parentFinder.get(file, attributes);
      if (ancestors.length === 0) {
        return [file];
      }
      if (ancestors.length === 1 && ancestors[0] === file) {
        return [file];
      }
      return ancestors.flatMap((a) => findAllRootAncestors(a, seen));
    };
    const result = /* @__PURE__ */ new Map();
    for (const file of files) {
      let ancestors = findAllRootAncestors(file);
      if (ancestors.length === 0) {
        ancestors = [file];
      }
      for (const ancestor of ancestors) {
        let existing = result.get(ancestor);
        if (!existing) {
          result.set(ancestor, existing = /* @__PURE__ */ new Set());
        }
        if (file !== ancestor) {
          existing.add(file);
        }
      }
    }
    return result;
  }
};
var PreTrie = class _PreTrie {
  constructor() {
    this.value = new SufTrie();
    this.map = /* @__PURE__ */ new Map();
  }
  add(key, value) {
    if (key === "") {
      this.value.add(key, value);
    } else if (key[0] === "*") {
      this.value.add(key, value);
    } else {
      const head = key[0];
      const rest = key.slice(1);
      let existing = this.map.get(head);
      if (!existing) {
        this.map.set(head, existing = new _PreTrie());
      }
      existing.add(rest, value);
    }
  }
  get(key, attributes) {
    const results = [];
    results.push(...this.value.get(key, attributes));
    const head = key[0];
    const rest = key.slice(1);
    const existing = this.map.get(head);
    if (existing) {
      results.push(...existing.get(rest, attributes));
    }
    return results;
  }
  toString(indentation = "") {
    const lines = [];
    if (this.value.hasItems) {
      lines.push("* => \n" + this.value.toString(indentation + "  "));
    }
    return lines.map((l) => indentation + l).join("\n");
  }
};
var SufTrie = class _SufTrie {
  constructor() {
    this.star = [];
    this.epsilon = [];
    this.map = /* @__PURE__ */ new Map();
    this.hasItems = false;
  }
  add(key, value) {
    this.hasItems = true;
    if (key === "*") {
      this.star.push(new SubstitutionString(value));
    } else if (key === "") {
      this.epsilon.push(new SubstitutionString(value));
    } else {
      const tail = key[key.length - 1];
      const rest = key.slice(0, key.length - 1);
      if (tail === "*") {
        throw Error("Unexpected star in SufTrie key: " + key);
      } else {
        let existing = this.map.get(tail);
        if (!existing) {
          this.map.set(tail, existing = new _SufTrie());
        }
        existing.add(rest, value);
      }
    }
  }
  get(key, attributes) {
    const results = [];
    if (key === "") {
      results.push(...this.epsilon.map((ss) => ss.substitute(attributes)));
    }
    if (this.star.length) {
      results.push(...this.star.map((ss) => ss.substitute(attributes, key)));
    }
    const tail = key[key.length - 1];
    const rest = key.slice(0, key.length - 1);
    const existing = this.map.get(tail);
    if (existing) {
      results.push(...existing.get(rest, attributes));
    }
    return results;
  }
  toString(indentation = "") {
    const lines = [];
    if (this.star.length) {
      lines.push("* => " + this.star.join("; "));
    }
    if (this.epsilon.length) {
      lines.push(" => " + this.epsilon.join("; "));
    }
    return lines.map((l) => indentation + l).join("\n");
  }
};
var substitutionStringTokenizer = /\$[({](capture|basename|dirname|extname)[)}]/g;
var SubstitutionString = class {
  constructor(pattern) {
    this.tokens = [];
    substitutionStringTokenizer.lastIndex = 0;
    let token;
    let lastIndex = 0;
    while (token = substitutionStringTokenizer.exec(pattern)) {
      const prefix = pattern.slice(lastIndex, token.index);
      this.tokens.push(prefix);
      const type = token[1];
      switch (type) {
        case "basename":
        case "dirname":
        case "extname":
        case "capture":
          this.tokens.push({ capture: type });
          break;
        default:
          throw Error("unknown substitution type: " + type);
      }
      lastIndex = token.index + token[0].length;
    }
    if (lastIndex !== pattern.length) {
      const suffix = pattern.slice(lastIndex, pattern.length);
      this.tokens.push(suffix);
    }
  }
  substitute(attributes, capture) {
    return this.tokens.map((t) => {
      if (typeof t === "string") {
        return t;
      }
      switch (t.capture) {
        case "basename":
          return attributes.basename;
        case "dirname":
          return attributes.dirname;
        case "extname":
          return attributes.extname;
        case "capture":
          return capture || "";
      }
    }).join("");
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/common/explorerModel.js
init_types();
var ExplorerItem = class _ExplorerItem {
  constructor(resource, fileService, configService, filesConfigService, _parent, _isDirectory, _isSymbolicLink, _readonly, _locked, _name = basenameOrAuthority(resource), _mtime, _unknown = false) {
    this.resource = resource;
    this.fileService = fileService;
    this.configService = configService;
    this.filesConfigService = filesConfigService;
    this._parent = _parent;
    this._isDirectory = _isDirectory;
    this._isSymbolicLink = _isSymbolicLink;
    this._readonly = _readonly;
    this._locked = _locked;
    this._name = _name;
    this._mtime = _mtime;
    this._unknown = _unknown;
    this.error = void 0;
    this._isExcluded = false;
    this._isDirectoryResolved = false;
  }
  get isExcluded() {
    if (this._isExcluded) {
      return true;
    }
    if (!this._parent) {
      return false;
    }
    return this._parent.isExcluded;
  }
  set isExcluded(value) {
    this._isExcluded = value;
  }
  hasChildren(filter) {
    var _a43;
    if (this.hasNests) {
      return ((_a43 = this.nestedChildren) == null ? void 0 : _a43.some((c) => filter(c))) ?? false;
    } else {
      return this.isDirectory;
    }
  }
  get hasNests() {
    var _a43;
    return !!((_a43 = this.nestedChildren) == null ? void 0 : _a43.length);
  }
  get isDirectoryResolved() {
    return this._isDirectoryResolved;
  }
  get isSymbolicLink() {
    return !!this._isSymbolicLink;
  }
  get isDirectory() {
    return !!this._isDirectory;
  }
  get isReadonly() {
    return this.filesConfigService.isReadonly(this.resource, { resource: this.resource, name: this.name, readonly: this._readonly, locked: this._locked });
  }
  get mtime() {
    return this._mtime;
  }
  get name() {
    return this._name;
  }
  get isUnknown() {
    return this._unknown;
  }
  get parent() {
    return this._parent;
  }
  get root() {
    if (!this._parent) {
      return this;
    }
    return this._parent.root;
  }
  get children() {
    return /* @__PURE__ */ new Map();
  }
  updateName(value) {
    var _a43, _b;
    (_a43 = this._parent) == null ? void 0 : _a43.removeChild(this);
    this._name = value;
    (_b = this._parent) == null ? void 0 : _b.addChild(this);
  }
  getId() {
    return this.root.resource.toString() + "::" + this.resource.toString();
  }
  toString() {
    return `ExplorerItem: ${this.name}`;
  }
  get isRoot() {
    return this === this.root;
  }
  static create(fileService, configService, filesConfigService, raw, parent, resolveTo) {
    const stat = new _ExplorerItem(
      raw.resource,
      fileService,
      configService,
      filesConfigService,
      parent,
      raw.isDirectory,
      raw.isSymbolicLink,
      raw.readonly,
      raw.locked,
      raw.name,
      raw.mtime,
      !raw.isFile && !raw.isDirectory
    );
    if (stat.isDirectory) {
      stat._isDirectoryResolved = !!raw.children || !!resolveTo && resolveTo.some((r) => {
        return isEqualOrParent2(r, stat.resource);
      });
      if (raw.children) {
        for (let i = 0, len = raw.children.length; i < len; i++) {
          const child = _ExplorerItem.create(fileService, configService, filesConfigService, raw.children[i], stat, resolveTo);
          stat.addChild(child);
        }
      }
    }
    return stat;
  }
  static mergeLocalWithDisk(disk, local) {
    if (disk.resource.toString() !== local.resource.toString()) {
      return;
    }
    const mergingDirectories = disk.isDirectory || local.isDirectory;
    if (mergingDirectories && local._isDirectoryResolved && !disk._isDirectoryResolved) {
      return;
    }
    local.resource = disk.resource;
    if (!local.isRoot) {
      local.updateName(disk.name);
    }
    local._isDirectory = disk.isDirectory;
    local._mtime = disk.mtime;
    local._isDirectoryResolved = disk._isDirectoryResolved;
    local._isSymbolicLink = disk.isSymbolicLink;
    local.error = disk.error;
    if (mergingDirectories && disk._isDirectoryResolved) {
      const oldLocalChildren = new ResourceMap();
      local.children.forEach((child) => {
        oldLocalChildren.set(child.resource, child);
      });
      local.children.clear();
      disk.children.forEach((diskChild) => {
        const formerLocalChild = oldLocalChildren.get(diskChild.resource);
        if (formerLocalChild) {
          _ExplorerItem.mergeLocalWithDisk(diskChild, formerLocalChild);
          local.addChild(formerLocalChild);
          oldLocalChildren.delete(diskChild.resource);
        } else {
          local.addChild(diskChild);
        }
      });
      oldLocalChildren.forEach((oldChild) => {
        if (oldChild instanceof NewExplorerItem) {
          local.addChild(oldChild);
        }
      });
    }
  }
  addChild(child) {
    child._parent = this;
    child.updateResource(false);
    this.children.set(this.getPlatformAwareName(child.name), child);
  }
  getChild(name) {
    return this.children.get(this.getPlatformAwareName(name));
  }
  fetchChildren(sortOrder) {
    const nestingConfig = this.configService.getValue({ resource: this.root.resource }).explorer.fileNesting;
    if (nestingConfig.enabled && this.nestedChildren) {
      return this.nestedChildren;
    }
    return (async () => {
      if (!this._isDirectoryResolved) {
        const resolveMetadata = sortOrder === "modified";
        this.error = void 0;
        try {
          const stat = await this.fileService.resolve(this.resource, { resolveSingleChildDescendants: true, resolveMetadata });
          const resolved = _ExplorerItem.create(this.fileService, this.configService, this.filesConfigService, stat, this);
          _ExplorerItem.mergeLocalWithDisk(resolved, this);
        } catch (e) {
          this.error = e;
          throw e;
        }
        this._isDirectoryResolved = true;
      }
      const items = [];
      if (nestingConfig.enabled) {
        const fileChildren = [];
        const dirChildren = [];
        for (const child of this.children.entries()) {
          child[1].nestedParent = void 0;
          if (child[1].isDirectory) {
            dirChildren.push(child);
          } else {
            fileChildren.push(child);
          }
        }
        const nested = this.fileNester.nest(fileChildren.map(([name]) => name), this.getPlatformAwareName(this.name));
        for (const [fileEntryName, fileEntryItem] of fileChildren) {
          const nestedItems = nested.get(fileEntryName);
          if (nestedItems !== void 0) {
            fileEntryItem.nestedChildren = [];
            for (const name of nestedItems.keys()) {
              const child = assertIsDefined(this.children.get(name));
              fileEntryItem.nestedChildren.push(child);
              child.nestedParent = fileEntryItem;
            }
            items.push(fileEntryItem);
          } else {
            fileEntryItem.nestedChildren = void 0;
          }
        }
        for (const [_, dirEntryItem] of dirChildren.values()) {
          items.push(dirEntryItem);
        }
      } else {
        this.children.forEach((child) => {
          items.push(child);
        });
      }
      return items;
    })();
  }
  get fileNester() {
    if (!this.root._fileNester) {
      const nestingConfig = this.configService.getValue({ resource: this.root.resource }).explorer.fileNesting;
      const patterns = Object.entries(nestingConfig.patterns).filter((entry) => typeof entry[0] === "string" && typeof entry[1] === "string" && entry[0] && entry[1]).map(([parentPattern, childrenPatterns]) => [
        this.getPlatformAwareName(parentPattern.trim()),
        childrenPatterns.split(",").map((p) => this.getPlatformAwareName(p.trim().replace(/\u200b/g, "").trim())).filter((p) => p !== "")
      ]);
      this.root._fileNester = new ExplorerFileNestingTrie(patterns);
    }
    return this.root._fileNester;
  }
  removeChild(child) {
    this.nestedChildren = void 0;
    this.children.delete(this.getPlatformAwareName(child.name));
  }
  forgetChildren() {
    this.children.clear();
    this.nestedChildren = void 0;
    this._isDirectoryResolved = false;
    this._fileNester = void 0;
  }
  getPlatformAwareName(name) {
    return this.fileService.hasCapability(this.resource, 1024) ? name : name.toLowerCase();
  }
  move(newParent) {
    var _a43, _b;
    (_a43 = this.nestedParent) == null ? void 0 : _a43.removeChild(this);
    (_b = this._parent) == null ? void 0 : _b.removeChild(this);
    newParent.removeChild(this);
    newParent.addChild(this);
    this.updateResource(true);
  }
  updateResource(recursive) {
    if (this._parent) {
      this.resource = joinPath(this._parent.resource, this.name);
    }
    if (recursive) {
      if (this.isDirectory) {
        this.children.forEach((child) => {
          child.updateResource(true);
        });
      }
    }
  }
  rename(renamedStat) {
    this.updateName(renamedStat.name);
    this._mtime = renamedStat.mtime;
    this.updateResource(true);
  }
  find(resource) {
    const ignoreCase = !this.fileService.hasCapability(resource, 1024);
    if (resource && this.resource.scheme === resource.scheme && equalsIgnoreCase(this.resource.authority, resource.authority) && (ignoreCase ? startsWithIgnoreCase(resource.path, this.resource.path) : resource.path.startsWith(this.resource.path))) {
      return this.findByPath(rtrim(resource.path, posix.sep), this.resource.path.length, ignoreCase);
    }
    return null;
  }
  findByPath(path, index, ignoreCase) {
    if (isEqual(rtrim(this.resource.path, posix.sep), path, ignoreCase)) {
      return this;
    }
    if (this.isDirectory) {
      while (index < path.length && path[index] === posix.sep) {
        index++;
      }
      let indexOfNextSep = path.indexOf(posix.sep, index);
      if (indexOfNextSep === -1) {
        indexOfNextSep = path.length;
      }
      const name = path.substring(index, indexOfNextSep);
      const child = this.children.get(this.getPlatformAwareName(name));
      if (child) {
        return child.findByPath(path, indexOfNextSep, ignoreCase);
      }
    }
    return null;
  }
};
ExplorerItem.__decorator = __decorate([
  memoize
], ExplorerItem.prototype, "children", null);
var NewExplorerItem = class extends ExplorerItem {
  constructor(fileService, configService, filesConfigService, parent, isDirectory) {
    super(URI.file(""), fileService, configService, filesConfigService, parent, isDirectory);
    this._isDirectoryResolved = true;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/files.js
init_arrays();
init_instantiation();
var IExplorerService = createDecorator("explorerService");

// node_modules/vscode/vscode/src/vs/platform/extensionManagement/common/extensionStorage.js
init_tslib_es6();
init_instantiation();
init_event();
init_lifecycle();
init_arrays();
init_log();
init_types();
var ExtensionStorageService_1;
var IExtensionStorageService = createDecorator("IExtensionStorageService");
var EXTENSION_KEYS_ID_VERSION_REGEX = /^extensionKeys\/([^.]+\..+)@(\d+\.\d+\.\d+(-.*)?)$/;
var _a16;
var ExtensionStorageService = (_a16 = class extends Disposable {
  static toKey(extension) {
    return `extensionKeys/${adoptToGalleryExtensionId(extension.id)}@${extension.version}`;
  }
  static fromKey(key) {
    const matches = EXTENSION_KEYS_ID_VERSION_REGEX.exec(key);
    if (matches && matches[1]) {
      return { id: matches[1], version: matches[2] };
    }
    return void 0;
  }
  static async removeOutdatedExtensionVersions(extensionManagementService, storageService) {
    var _a43;
    const extensions = await extensionManagementService.getInstalled();
    const extensionVersionsToRemove = [];
    for (const [id, versions] of ExtensionStorageService_1.readAllExtensionsWithKeysForSync(storageService)) {
      const extensionVersion = (_a43 = extensions.find((e) => areSameExtensions(e.identifier, { id }))) == null ? void 0 : _a43.manifest.version;
      for (const version of versions) {
        if (extensionVersion !== version) {
          extensionVersionsToRemove.push(ExtensionStorageService_1.toKey({ id, version }));
        }
      }
    }
    for (const key of extensionVersionsToRemove) {
      storageService.remove(key, 0);
    }
  }
  static readAllExtensionsWithKeysForSync(storageService) {
    const extensionsWithKeysForSync = /* @__PURE__ */ new Map();
    const keys = storageService.keys(0, 1);
    for (const key of keys) {
      const extensionIdWithVersion = ExtensionStorageService_1.fromKey(key);
      if (extensionIdWithVersion) {
        let versions = extensionsWithKeysForSync.get(extensionIdWithVersion.id.toLowerCase());
        if (!versions) {
          extensionsWithKeysForSync.set(extensionIdWithVersion.id.toLowerCase(), versions = []);
        }
        versions.push(extensionIdWithVersion.version);
      }
    }
    return extensionsWithKeysForSync;
  }
  constructor(storageService, productService, logService) {
    super();
    this.storageService = storageService;
    this.productService = productService;
    this.logService = logService;
    this._onDidChangeExtensionStorageToSync = this._register(new Emitter());
    this.onDidChangeExtensionStorageToSync = this._onDidChangeExtensionStorageToSync.event;
    this.extensionsWithKeysForSync = ExtensionStorageService_1.readAllExtensionsWithKeysForSync(storageService);
    this._register(this.storageService.onDidChangeValue(0, void 0, this._register(new DisposableStore()))((e) => this.onDidChangeStorageValue(e)));
  }
  onDidChangeStorageValue(e) {
    if (this.extensionsWithKeysForSync.has(e.key.toLowerCase())) {
      this._onDidChangeExtensionStorageToSync.fire();
      return;
    }
    const extensionIdWithVersion = ExtensionStorageService_1.fromKey(e.key);
    if (extensionIdWithVersion) {
      if (this.storageService.get(e.key, 0) === void 0) {
        this.extensionsWithKeysForSync.delete(extensionIdWithVersion.id.toLowerCase());
      } else {
        let versions = this.extensionsWithKeysForSync.get(extensionIdWithVersion.id.toLowerCase());
        if (!versions) {
          this.extensionsWithKeysForSync.set(extensionIdWithVersion.id.toLowerCase(), versions = []);
        }
        versions.push(extensionIdWithVersion.version);
        this._onDidChangeExtensionStorageToSync.fire();
      }
      return;
    }
  }
  getExtensionId(extension) {
    if (isString(extension)) {
      return extension;
    }
    const publisher = extension.manifest ? extension.manifest.publisher : extension.publisher;
    const name = extension.manifest ? extension.manifest.name : extension.name;
    return getExtensionId(publisher, name);
  }
  getExtensionState(extension, global) {
    const extensionId = this.getExtensionId(extension);
    const jsonValue = this.getExtensionStateRaw(extension, global);
    if (jsonValue) {
      try {
        return JSON.parse(jsonValue);
      } catch (error) {
        this.logService.error(`[mainThreadStorage] unexpected error parsing storage contents (extensionId: ${extensionId}, global: ${global}): ${error}`);
      }
    }
    return void 0;
  }
  getExtensionStateRaw(extension, global) {
    const extensionId = this.getExtensionId(extension);
    const rawState = this.storageService.get(extensionId, global ? 0 : 1);
    if (rawState && (rawState == null ? void 0 : rawState.length) > ExtensionStorageService_1.LARGE_STATE_WARNING_THRESHOLD) {
      this.logService.warn(`[mainThreadStorage] large extension state detected (extensionId: ${extensionId}, global: ${global}): ${rawState.length / 1024}kb. Consider to use 'storageUri' or 'globalStorageUri' to store this data on disk instead.`);
    }
    return rawState;
  }
  setExtensionState(extension, state, global) {
    const extensionId = this.getExtensionId(extension);
    if (state === void 0) {
      this.storageService.remove(extensionId, global ? 0 : 1);
    } else {
      this.storageService.store(extensionId, JSON.stringify(state), global ? 0 : 1, 1);
    }
  }
  setKeysForSync(extensionIdWithVersion, keys) {
    this.storageService.store(ExtensionStorageService_1.toKey(extensionIdWithVersion), JSON.stringify(keys), 0, 1);
  }
  getKeysForSync(extensionIdWithVersion) {
    var _a43;
    const extensionKeysForSyncFromProduct = (_a43 = this.productService.extensionSyncedKeys) == null ? void 0 : _a43[extensionIdWithVersion.id.toLowerCase()];
    const extensionKeysForSyncFromStorageValue = this.storageService.get(ExtensionStorageService_1.toKey(extensionIdWithVersion), 0);
    const extensionKeysForSyncFromStorage = extensionKeysForSyncFromStorageValue ? JSON.parse(extensionKeysForSyncFromStorageValue) : void 0;
    return extensionKeysForSyncFromStorage && extensionKeysForSyncFromProduct ? distinct([...extensionKeysForSyncFromStorage, ...extensionKeysForSyncFromProduct]) : extensionKeysForSyncFromStorage || extensionKeysForSyncFromProduct;
  }
  addToMigrationList(from, to) {
    if (from !== to) {
      const migrationList = this.migrationList.filter((entry) => !entry.includes(from) && !entry.includes(to));
      migrationList.push([from, to]);
      this.migrationList = migrationList;
    }
  }
  getSourceExtensionToMigrate(toExtensionId) {
    const entry = this.migrationList.find(([, to]) => toExtensionId === to);
    return entry ? entry[0] : void 0;
  }
  get migrationList() {
    const value = this.storageService.get("extensionStorage.migrationList", -1, "[]");
    try {
      const migrationList = JSON.parse(value);
      if (Array.isArray(migrationList)) {
        return migrationList;
      }
    } catch (error) {
    }
    return [];
  }
  set migrationList(migrationList) {
    if (migrationList.length) {
      this.storageService.store("extensionStorage.migrationList", JSON.stringify(migrationList), -1, 1);
    } else {
      this.storageService.remove("extensionStorage.migrationList", -1);
    }
  }
}, ExtensionStorageService_1 = _a16, _a16.LARGE_STATE_WARNING_THRESHOLD = 512 * 1024, _a16);
ExtensionStorageService = ExtensionStorageService_1 = __decorate([
  __param(0, IStorageService),
  __param(1, IProductService),
  __param(2, ILogService)
], ExtensionStorageService);

// node_modules/vscode/vscode/src/vs/platform/languagePacks/common/languagePacks.js
init_instantiation();
var ILanguagePackService = createDecorator("languagePackService");

// node_modules/vscode/vscode/src/vs/workbench/services/views/common/treeViewsService.js
var TreeviewsService = class {
  constructor() {
    this._renderedElements = /* @__PURE__ */ new Map();
  }
  getRenderedTreeElement(node) {
    if (this._renderedElements.has(node)) {
      return this._renderedElements.get(node);
    }
    return void 0;
  }
  addRenderedTreeItemElement(node, element) {
    this._renderedElements.set(node, element);
  }
  removeRenderedTreeItemElement(node) {
    if (this._renderedElements.has(node)) {
      this._renderedElements.delete(node);
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/views/browser/treeViewsService.js
init_instantiation();
var ITreeViewsService = createDecorator("treeViewsService");

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/breadcrumbs.js
init_event();
init_nls();
init_configurationRegistry();
init_instantiation();
init_platform2();
var IBreadcrumbsService = createDecorator("IEditorBreadcrumbsService");
var _BreadcrumbsConfig = class _BreadcrumbsConfig {
  constructor() {
  }
  static _stub(name) {
    return {
      bindTo(service) {
        const onDidChange = new Emitter();
        const listener = service.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(name)) {
            onDidChange.fire(void 0);
          }
        });
        return new class {
          constructor() {
            this.name = name;
            this.onDidChange = onDidChange.event;
          }
          getValue(overrides) {
            if (overrides) {
              return service.getValue(name, overrides);
            } else {
              return service.getValue(name);
            }
          }
          updateValue(newValue, overrides) {
            if (overrides) {
              return service.updateValue(name, newValue, overrides);
            } else {
              return service.updateValue(name, newValue);
            }
          }
          dispose() {
            listener.dispose();
            onDidChange.dispose();
          }
        }();
      }
    };
  }
};
_BreadcrumbsConfig.IsEnabled = _BreadcrumbsConfig._stub("breadcrumbs.enabled");
_BreadcrumbsConfig.UseQuickPick = _BreadcrumbsConfig._stub("breadcrumbs.useQuickPick");
_BreadcrumbsConfig.FilePath = _BreadcrumbsConfig._stub("breadcrumbs.filePath");
_BreadcrumbsConfig.SymbolPath = _BreadcrumbsConfig._stub("breadcrumbs.symbolPath");
_BreadcrumbsConfig.SymbolSortOrder = _BreadcrumbsConfig._stub("breadcrumbs.symbolSortOrder");
_BreadcrumbsConfig.Icons = _BreadcrumbsConfig._stub("breadcrumbs.icons");
_BreadcrumbsConfig.TitleScrollbarSizing = _BreadcrumbsConfig._stub("workbench.editor.titleScrollbarSizing");
_BreadcrumbsConfig.FileExcludes = _BreadcrumbsConfig._stub("files.exclude");
var BreadcrumbsConfig = _BreadcrumbsConfig;
Registry.as(Extensions2.Configuration).registerConfiguration({
  id: "breadcrumbs",
  title: localize("title", "Breadcrumb Navigation"),
  order: 101,
  type: "object",
  properties: {
    "breadcrumbs.enabled": {
      description: localize("enabled", "Enable/disable navigation breadcrumbs."),
      type: "boolean",
      default: true
    },
    "breadcrumbs.filePath": {
      description: localize(
        "filepath",
        "Controls whether and how file paths are shown in the breadcrumbs view."
      ),
      type: "string",
      default: "on",
      enum: ["on", "off", "last"],
      enumDescriptions: [
        localize("filepath.on", "Show the file path in the breadcrumbs view."),
        localize("filepath.off", "Do not show the file path in the breadcrumbs view."),
        localize(
          "filepath.last",
          "Only show the last element of the file path in the breadcrumbs view."
        )
      ]
    },
    "breadcrumbs.symbolPath": {
      description: localize(
        "symbolpath",
        "Controls whether and how symbols are shown in the breadcrumbs view."
      ),
      type: "string",
      default: "on",
      enum: ["on", "off", "last"],
      enumDescriptions: [
        localize("symbolpath.on", "Show all symbols in the breadcrumbs view."),
        localize("symbolpath.off", "Do not show symbols in the breadcrumbs view."),
        localize("symbolpath.last", "Only show the current symbol in the breadcrumbs view.")
      ]
    },
    "breadcrumbs.symbolSortOrder": {
      description: localize(
        "symbolSortOrder",
        "Controls how symbols are sorted in the breadcrumbs outline view."
      ),
      type: "string",
      default: "position",
      scope: 5,
      enum: ["position", "name", "type"],
      enumDescriptions: [
        localize("symbolSortOrder.position", "Show symbol outline in file position order."),
        localize("symbolSortOrder.name", "Show symbol outline in alphabetical order."),
        localize("symbolSortOrder.type", "Show symbol outline in symbol type order.")
      ]
    },
    "breadcrumbs.icons": {
      description: localize("icons", "Render breadcrumb items with icons."),
      type: "boolean",
      default: true
    },
    "breadcrumbs.showFiles": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.file", "When enabled breadcrumbs show `file`-symbols.")
    },
    "breadcrumbs.showModules": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.module", "When enabled breadcrumbs show `module`-symbols.")
    },
    "breadcrumbs.showNamespaces": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.namespace",
        "When enabled breadcrumbs show `namespace`-symbols."
      )
    },
    "breadcrumbs.showPackages": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.package",
        "When enabled breadcrumbs show `package`-symbols."
      )
    },
    "breadcrumbs.showClasses": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.class", "When enabled breadcrumbs show `class`-symbols.")
    },
    "breadcrumbs.showMethods": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.method", "When enabled breadcrumbs show `method`-symbols.")
    },
    "breadcrumbs.showProperties": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.property",
        "When enabled breadcrumbs show `property`-symbols."
      )
    },
    "breadcrumbs.showFields": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.field", "When enabled breadcrumbs show `field`-symbols.")
    },
    "breadcrumbs.showConstructors": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.constructor",
        "When enabled breadcrumbs show `constructor`-symbols."
      )
    },
    "breadcrumbs.showEnums": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.enum", "When enabled breadcrumbs show `enum`-symbols.")
    },
    "breadcrumbs.showInterfaces": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.interface",
        "When enabled breadcrumbs show `interface`-symbols."
      )
    },
    "breadcrumbs.showFunctions": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.function",
        "When enabled breadcrumbs show `function`-symbols."
      )
    },
    "breadcrumbs.showVariables": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.variable",
        "When enabled breadcrumbs show `variable`-symbols."
      )
    },
    "breadcrumbs.showConstants": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.constant",
        "When enabled breadcrumbs show `constant`-symbols."
      )
    },
    "breadcrumbs.showStrings": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.string", "When enabled breadcrumbs show `string`-symbols.")
    },
    "breadcrumbs.showNumbers": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.number", "When enabled breadcrumbs show `number`-symbols.")
    },
    "breadcrumbs.showBooleans": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.boolean",
        "When enabled breadcrumbs show `boolean`-symbols."
      )
    },
    "breadcrumbs.showArrays": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.array", "When enabled breadcrumbs show `array`-symbols.")
    },
    "breadcrumbs.showObjects": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.object", "When enabled breadcrumbs show `object`-symbols.")
    },
    "breadcrumbs.showKeys": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.key", "When enabled breadcrumbs show `key`-symbols.")
    },
    "breadcrumbs.showNull": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.null", "When enabled breadcrumbs show `null`-symbols.")
    },
    "breadcrumbs.showEnumMembers": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.enumMember",
        "When enabled breadcrumbs show `enumMember`-symbols."
      )
    },
    "breadcrumbs.showStructs": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.struct", "When enabled breadcrumbs show `struct`-symbols.")
    },
    "breadcrumbs.showEvents": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.event", "When enabled breadcrumbs show `event`-symbols.")
    },
    "breadcrumbs.showOperators": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.operator",
        "When enabled breadcrumbs show `operator`-symbols."
      )
    },
    "breadcrumbs.showTypeParameters": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.typeParameter",
        "When enabled breadcrumbs show `typeParameter`-symbols."
      )
    }
  }
});

// node_modules/vscode/vscode/src/vs/workbench/services/outline/browser/outline.js
init_instantiation();
var IOutlineService = createDecorator("IOutlineService");

// node_modules/vscode/vscode/src/vs/platform/update/common/update.js
init_instantiation();
var State = {
  Uninitialized: { type: "uninitialized" },
  Disabled: (reason) => ({ type: "disabled", reason }),
  Idle: (updateType, error) => ({ type: "idle", updateType, error }),
  CheckingForUpdates: (explicit) => ({ type: "checking for updates", explicit }),
  AvailableForDownload: (update) => ({ type: "available for download", update }),
  Downloading: (update) => ({ type: "downloading", update }),
  Downloaded: (update) => ({ type: "downloaded", update }),
  Updating: (update) => ({ type: "updating", update }),
  Ready: (update) => ({ type: "ready", update })
};
var IUpdateService = createDecorator("updateService");

// node_modules/vscode/vscode/src/vs/workbench/services/statusbar/browser/statusbar.js
init_instantiation();
var IStatusbarService = createDecorator("statusbarService");

// node_modules/vscode/missing-services.js
init_model2();

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/browser/terminal.js
init_instantiation();
var ITerminalService = createDecorator("terminalService");
var ITerminalEditorService = createDecorator("terminalEditorService");
var ITerminalGroupService = createDecorator("terminalGroupService");
var ITerminalInstanceService = createDecorator("terminalInstanceService");
var terminalEditorId = "terminalEditor";

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/common/terminal.js
init_nls();
init_instantiation();
var ITerminalProfileResolverService = createDecorator("terminalProfileResolverService");
var ITerminalProfileService = createDecorator("terminalProfileService");
var terminalContributionsDescriptor = {
  extensionPoint: "terminal",
  defaultExtensionKind: ["workspace"],
  activationEventsGenerator: (contribs, result) => {
    for (const contrib of contribs) {
      for (const profileContrib of contrib.profiles ?? []) {
        result.push(`onTerminalProfile:${profileContrib.id}`);
      }
    }
  },
  jsonSchema: {
    description: localize(
      "vscode.extension.contributes.terminal",
      "Contributes terminal functionality."
    ),
    type: "object",
    properties: {
      profiles: {
        type: "array",
        description: localize(
          "vscode.extension.contributes.terminal.profiles",
          "Defines additional terminal profiles that the user can create."
        ),
        items: {
          type: "object",
          required: ["id", "title"],
          defaultSnippets: [{
            body: {
              id: "$1",
              title: "$2"
            }
          }],
          properties: {
            id: {
              description: localize(
                "vscode.extension.contributes.terminal.profiles.id",
                "The ID of the terminal profile provider."
              ),
              type: "string"
            },
            title: {
              description: localize(
                "vscode.extension.contributes.terminal.profiles.title",
                "Title for this terminal profile."
              ),
              type: "string"
            },
            icon: {
              description: localize(
                "vscode.extension.contributes.terminal.types.icon",
                "A codicon, URI, or light and dark URIs to associate with this terminal type."
              ),
              anyOf: [
                {
                  type: "string"
                },
                {
                  type: "object",
                  properties: {
                    light: {
                      description: localize(
                        "vscode.extension.contributes.terminal.types.icon.light",
                        "Icon path when a light theme is used"
                      ),
                      type: "string"
                    },
                    dark: {
                      description: localize(
                        "vscode.extension.contributes.terminal.types.icon.dark",
                        "Icon path when a dark theme is used"
                      ),
                      type: "string"
                    }
                  }
                }
              ]
            }
          }
        }
      }
    }
  }
};

// node_modules/vscode/vscode/src/vs/platform/terminal/common/terminal.js
init_instantiation();
init_contextkey();
init_platform2();
var terminalTabFocusModeContextKey = new RawContextKey("terminalTabFocusMode", false, true);
var TitleEventSource;
(function(TitleEventSource2) {
  TitleEventSource2[TitleEventSource2["Api"] = 0] = "Api";
  TitleEventSource2[TitleEventSource2["Process"] = 1] = "Process";
  TitleEventSource2[TitleEventSource2["Sequence"] = 2] = "Sequence";
  TitleEventSource2[TitleEventSource2["Config"] = 3] = "Config";
})(TitleEventSource || (TitleEventSource = {}));
var TerminalLocation;
(function(TerminalLocation2) {
  TerminalLocation2[TerminalLocation2["Panel"] = 1] = "Panel";
  TerminalLocation2[TerminalLocation2["Editor"] = 2] = "Editor";
})(TerminalLocation || (TerminalLocation = {}));
var TerminalExitReason;
(function(TerminalExitReason2) {
  TerminalExitReason2[TerminalExitReason2["Unknown"] = 0] = "Unknown";
  TerminalExitReason2[TerminalExitReason2["Shutdown"] = 1] = "Shutdown";
  TerminalExitReason2[TerminalExitReason2["Process"] = 2] = "Process";
  TerminalExitReason2[TerminalExitReason2["User"] = 3] = "User";
  TerminalExitReason2[TerminalExitReason2["Extension"] = 4] = "Extension";
})(TerminalExitReason || (TerminalExitReason = {}));
var TerminalExtensions = {
  Backend: "workbench.contributions.terminal.processBackend"
};
var TerminalBackendRegistry = class {
  constructor() {
    this._backends = /* @__PURE__ */ new Map();
  }
  get backends() {
    return this._backends;
  }
  registerTerminalBackend(backend) {
    const key = this._sanitizeRemoteAuthority(backend.remoteAuthority);
    if (this._backends.has(key)) {
      throw new Error(`A terminal backend with remote authority '${key}' was already registered.`);
    }
    this._backends.set(key, backend);
  }
  getTerminalBackend(remoteAuthority) {
    return this._backends.get(this._sanitizeRemoteAuthority(remoteAuthority));
  }
  _sanitizeRemoteAuthority(remoteAuthority) {
    return (remoteAuthority == null ? void 0 : remoteAuthority.toLowerCase()) ?? "";
  }
};
Registry.add(TerminalExtensions.Backend, new TerminalBackendRegistry());
var ITerminalLogService = createDecorator("terminalLogService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/common/terminalExtensionPoints.js
init_instantiation();
init_uri();
var terminalsExtPoint = ExtensionsRegistry.registerExtensionPoint(terminalContributionsDescriptor);
var ITerminalContributionService = createDecorator("terminalContributionsService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminalContrib/links/browser/links.js
init_instantiation();
var ITerminalLinkProviderService = createDecorator("terminalLinkProviderService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminal/common/environmentVariable.js
init_instantiation();
var IEnvironmentVariableService = createDecorator("environmentVariableService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/terminalContrib/quickFix/browser/quickFix.js
init_instantiation();
var ITerminalQuickFixService = createDecorator("terminalQuickFixService");
var TerminalQuickFixType;
(function(TerminalQuickFixType2) {
  TerminalQuickFixType2[TerminalQuickFixType2["TerminalCommand"] = 0] = "TerminalCommand";
  TerminalQuickFixType2[TerminalQuickFixType2["Opener"] = 1] = "Opener";
  TerminalQuickFixType2[TerminalQuickFixType2["Port"] = 2] = "Port";
  TerminalQuickFixType2[TerminalQuickFixType2["VscodeCommand"] = 3] = "VscodeCommand";
})(TerminalQuickFixType || (TerminalQuickFixType = {}));

// node_modules/vscode/vscode/src/vs/workbench/contrib/preferences/common/preferences.js
init_contextkey();
init_instantiation();
var IPreferencesSearchService = createDecorator("preferencesSearchService");
var CONTEXT_SETTINGS_EDITOR = new RawContextKey("inSettingsEditor", false);
var CONTEXT_SETTINGS_JSON_EDITOR = new RawContextKey("inSettingsJSONEditor", false);
var CONTEXT_SETTINGS_SEARCH_FOCUS = new RawContextKey("inSettingsSearch", false);
var CONTEXT_TOC_ROW_FOCUS = new RawContextKey("settingsTocRowFocus", false);
var CONTEXT_SETTINGS_ROW_FOCUS = new RawContextKey("settingRowFocus", false);
var CONTEXT_KEYBINDINGS_EDITOR = new RawContextKey("inKeybindings", false);
var CONTEXT_KEYBINDINGS_SEARCH_FOCUS = new RawContextKey("inKeybindingsSearch", false);
var CONTEXT_KEYBINDING_FOCUS = new RawContextKey("keybindingFocus", false);
var CONTEXT_WHEN_FOCUS = new RawContextKey("whenFocus", false);

// node_modules/vscode/vscode/src/vs/workbench/services/userDataSync/common/userDataSync.js
init_instantiation();
init_nls();
init_codicons();
var IUserDataSyncWorkbenchService = createDecorator("IUserDataSyncWorkbenchService");
registerIcon("settings-sync-view-icon", Codicon.sync, localize("syncViewIcon", "View icon of the Settings Sync view."));

// node_modules/vscode/vscode/src/vs/platform/userDataSync/common/userDataSync.js
init_arrays();
init_configurationRegistry();
init_instantiation();
init_platform2();
var IUserDataSyncEnablementService = createDecorator("IUserDataSyncEnablementService");
var IUserDataSyncService = createDecorator("IUserDataSyncService");

// node_modules/vscode/vscode/src/vs/workbench/services/keybinding/common/keybindingEditing.js
init_tslib_es6();
init_nls();
init_async();
init_objects();
init_lifecycle();
init_editOperation();
init_range();
init_selection();
init_resolverService();
init_configuration();
init_contextkey();
init_files();
init_instantiation();
var IKeybindingEditingService = createDecorator("keybindingEditingService");
var KeybindingsEditingService = class KeybindingsEditingService2 extends Disposable {
  constructor(textModelResolverService, textFileService, fileService, configurationService, userDataProfileService) {
    super();
    this.textModelResolverService = textModelResolverService;
    this.textFileService = textFileService;
    this.fileService = fileService;
    this.configurationService = configurationService;
    this.userDataProfileService = userDataProfileService;
    this.queue = new Queue();
  }
  addKeybinding(keybindingItem, key, when) {
    return this.queue.queue(() => this.doEditKeybinding(keybindingItem, key, when, true));
  }
  editKeybinding(keybindingItem, key, when) {
    return this.queue.queue(() => this.doEditKeybinding(keybindingItem, key, when, false));
  }
  resetKeybinding(keybindingItem) {
    return this.queue.queue(() => this.doResetKeybinding(keybindingItem));
  }
  removeKeybinding(keybindingItem) {
    return this.queue.queue(() => this.doRemoveKeybinding(keybindingItem));
  }
  async doEditKeybinding(keybindingItem, key, when, add) {
    const reference = await this.resolveAndValidate();
    const model = reference.object.textEditorModel;
    if (add) {
      this.updateKeybinding(keybindingItem, key, when, model, -1);
    } else {
      const userKeybindingEntries = parse2(model.getValue());
      const userKeybindingEntryIndex = this.findUserKeybindingEntryIndex(keybindingItem, userKeybindingEntries);
      this.updateKeybinding(keybindingItem, key, when, model, userKeybindingEntryIndex);
      if (keybindingItem.isDefault && keybindingItem.resolvedKeybinding) {
        this.removeDefaultKeybinding(keybindingItem, model);
      }
    }
    try {
      await this.save();
    } finally {
      reference.dispose();
    }
  }
  doRemoveKeybinding(keybindingItem) {
    return this.resolveAndValidate().then((reference) => {
      const model = reference.object.textEditorModel;
      if (keybindingItem.isDefault) {
        this.removeDefaultKeybinding(keybindingItem, model);
      } else {
        this.removeUserKeybinding(keybindingItem, model);
      }
      return this.save().finally(() => reference.dispose());
    });
  }
  doResetKeybinding(keybindingItem) {
    return this.resolveAndValidate().then((reference) => {
      const model = reference.object.textEditorModel;
      if (!keybindingItem.isDefault) {
        this.removeUserKeybinding(keybindingItem, model);
        this.removeUnassignedDefaultKeybinding(keybindingItem, model);
      }
      return this.save().finally(() => reference.dispose());
    });
  }
  save() {
    return this.textFileService.save(this.userDataProfileService.currentProfile.keybindingsResource);
  }
  updateKeybinding(keybindingItem, newKey, when, model, userKeybindingEntryIndex) {
    const { tabSize, insertSpaces } = model.getOptions();
    const eol = model.getEOL();
    if (userKeybindingEntryIndex !== -1) {
      this.applyEditsToBuffer(setProperty(model.getValue(), [userKeybindingEntryIndex, "key"], newKey, { tabSize, insertSpaces, eol })[0], model);
      const edits = setProperty(model.getValue(), [userKeybindingEntryIndex, "when"], when, { tabSize, insertSpaces, eol });
      if (edits.length > 0) {
        this.applyEditsToBuffer(edits[0], model);
      }
    } else {
      this.applyEditsToBuffer(setProperty(model.getValue(), [-1], this.asObject(newKey, keybindingItem.command, when, false), { tabSize, insertSpaces, eol })[0], model);
    }
  }
  removeUserKeybinding(keybindingItem, model) {
    const { tabSize, insertSpaces } = model.getOptions();
    const eol = model.getEOL();
    const userKeybindingEntries = parse2(model.getValue());
    const userKeybindingEntryIndex = this.findUserKeybindingEntryIndex(keybindingItem, userKeybindingEntries);
    if (userKeybindingEntryIndex !== -1) {
      this.applyEditsToBuffer(setProperty(model.getValue(), [userKeybindingEntryIndex], void 0, { tabSize, insertSpaces, eol })[0], model);
    }
  }
  removeDefaultKeybinding(keybindingItem, model) {
    const { tabSize, insertSpaces } = model.getOptions();
    const eol = model.getEOL();
    const key = keybindingItem.resolvedKeybinding ? keybindingItem.resolvedKeybinding.getUserSettingsLabel() : null;
    if (key) {
      const entry = this.asObject(key, keybindingItem.command, keybindingItem.when ? keybindingItem.when.serialize() : void 0, true);
      const userKeybindingEntries = parse2(model.getValue());
      if (userKeybindingEntries.every((e) => !this.areSame(e, entry))) {
        this.applyEditsToBuffer(setProperty(model.getValue(), [-1], entry, { tabSize, insertSpaces, eol })[0], model);
      }
    }
  }
  removeUnassignedDefaultKeybinding(keybindingItem, model) {
    const { tabSize, insertSpaces } = model.getOptions();
    const eol = model.getEOL();
    const userKeybindingEntries = parse2(model.getValue());
    const indices = this.findUnassignedDefaultKeybindingEntryIndex(keybindingItem, userKeybindingEntries).reverse();
    for (const index of indices) {
      this.applyEditsToBuffer(setProperty(model.getValue(), [index], void 0, { tabSize, insertSpaces, eol })[0], model);
    }
  }
  findUserKeybindingEntryIndex(keybindingItem, userKeybindingEntries) {
    for (let index = 0; index < userKeybindingEntries.length; index++) {
      const keybinding = userKeybindingEntries[index];
      if (keybinding.command === keybindingItem.command) {
        if (!keybinding.when && !keybindingItem.when) {
          return index;
        }
        if (keybinding.when && keybindingItem.when) {
          const contextKeyExpr = ContextKeyExpr.deserialize(keybinding.when);
          if (contextKeyExpr && contextKeyExpr.serialize() === keybindingItem.when.serialize()) {
            return index;
          }
        }
      }
    }
    return -1;
  }
  findUnassignedDefaultKeybindingEntryIndex(keybindingItem, userKeybindingEntries) {
    const indices = [];
    for (let index = 0; index < userKeybindingEntries.length; index++) {
      if (userKeybindingEntries[index].command === `-${keybindingItem.command}`) {
        indices.push(index);
      }
    }
    return indices;
  }
  asObject(key, command, when, negate) {
    const object = { key };
    if (command) {
      object["command"] = negate ? `-${command}` : command;
    }
    if (when) {
      object["when"] = when;
    }
    return object;
  }
  areSame(a, b) {
    if (a.command !== b.command) {
      return false;
    }
    if (a.key !== b.key) {
      return false;
    }
    const whenA = ContextKeyExpr.deserialize(a.when);
    const whenB = ContextKeyExpr.deserialize(b.when);
    if (whenA && !whenB || !whenA && whenB) {
      return false;
    }
    if (whenA && whenB && !whenA.equals(whenB)) {
      return false;
    }
    if (!equals(a.args, b.args)) {
      return false;
    }
    return true;
  }
  applyEditsToBuffer(edit, model) {
    const startPosition = model.getPositionAt(edit.offset);
    const endPosition = model.getPositionAt(edit.offset + edit.length);
    const range = new Range(
      startPosition.lineNumber,
      startPosition.column,
      endPosition.lineNumber,
      endPosition.column
    );
    const currentText = model.getValueInRange(range);
    const editOperation = currentText ? EditOperation.replace(range, edit.content) : EditOperation.insert(startPosition, edit.content);
    model.pushEditOperations([new Selection(
      startPosition.lineNumber,
      startPosition.column,
      startPosition.lineNumber,
      startPosition.column
    )], [editOperation], () => []);
  }
  resolveModelReference() {
    return this.fileService.exists(this.userDataProfileService.currentProfile.keybindingsResource).then((exists) => {
      const EOL = this.configurationService.getValue("files", { overrideIdentifier: "json" })["eol"];
      const result = exists ? Promise.resolve(null) : this.textFileService.write(this.userDataProfileService.currentProfile.keybindingsResource, this.getEmptyContent(EOL), { encoding: "utf8" });
      return result.then(() => this.textModelResolverService.createModelReference(this.userDataProfileService.currentProfile.keybindingsResource));
    });
  }
  resolveAndValidate() {
    if (this.textFileService.isDirty(this.userDataProfileService.currentProfile.keybindingsResource)) {
      return Promise.reject(new Error(localize(
        "errorKeybindingsFileDirty",
        "Unable to write because the keybindings configuration file has unsaved changes. Please save it first and then try again."
      )));
    }
    return this.resolveModelReference().then((reference) => {
      const model = reference.object.textEditorModel;
      const EOL = model.getEOL();
      if (model.getValue()) {
        const parsed = this.parse(model);
        if (parsed.parseErrors.length) {
          reference.dispose();
          return Promise.reject(new Error(localize(
            "parseErrors",
            "Unable to write to the keybindings configuration file. Please open it to correct errors/warnings in the file and try again."
          )));
        }
        if (parsed.result) {
          if (!Array.isArray(parsed.result)) {
            reference.dispose();
            return Promise.reject(new Error(localize(
              "errorInvalidConfiguration",
              "Unable to write to the keybindings configuration file. It has an object which is not of type Array. Please open the file to clean up and try again."
            )));
          }
        } else {
          const content = EOL + "[]";
          this.applyEditsToBuffer({ content, length: content.length, offset: model.getValue().length }, model);
        }
      } else {
        const content = this.getEmptyContent(EOL);
        this.applyEditsToBuffer({ content, length: content.length, offset: 0 }, model);
      }
      return reference;
    });
  }
  parse(model) {
    const parseErrors = [];
    const result = parse2(model.getValue(), parseErrors, { allowTrailingComma: true, allowEmptyContent: true });
    return { result, parseErrors };
  }
  getEmptyContent(EOL) {
    return "// " + localize(
      "emptyKeybindingsHeader",
      "Place your key bindings in this file to override the defaults"
    ) + EOL + "[]";
  }
};
KeybindingsEditingService = __decorate([
  __param(0, ITextModelService),
  __param(1, ITextFileService),
  __param(2, IFileService),
  __param(3, IConfigurationService),
  __param(4, IUserDataProfileService)
], KeybindingsEditingService);

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookService.js
init_instantiation();
var INotebookService = createDecorator("notebookService");
var SimpleNotebookProviderInfo = class {
  constructor(viewType, serializer, extensionData) {
    this.viewType = viewType;
    this.serializer = serializer;
    this.extensionData = extensionData;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/search/common/searchHistoryService.js
init_tslib_es6();
init_event();
init_types();
init_instantiation();
var SearchHistoryService_1;
var ISearchHistoryService = createDecorator("searchHistoryService");
var _a17;
var SearchHistoryService = (_a17 = class {
  constructor(storageService) {
    this.storageService = storageService;
    this._onDidClearHistory = new Emitter();
    this.onDidClearHistory = this._onDidClearHistory.event;
  }
  clearHistory() {
    this.storageService.remove(SearchHistoryService_1.SEARCH_HISTORY_KEY, 1);
    this._onDidClearHistory.fire();
  }
  load() {
    let result;
    const raw = this.storageService.get(SearchHistoryService_1.SEARCH_HISTORY_KEY, 1);
    if (raw) {
      try {
        result = JSON.parse(raw);
      } catch (e) {
      }
    }
    return result || {};
  }
  save(history) {
    if (isEmptyObject(history)) {
      this.storageService.remove(SearchHistoryService_1.SEARCH_HISTORY_KEY, 1);
    } else {
      this.storageService.store(SearchHistoryService_1.SEARCH_HISTORY_KEY, JSON.stringify(history), 1, 0);
    }
  }
}, SearchHistoryService_1 = _a17, _a17.SEARCH_HISTORY_KEY = "workbench.search.history", _a17);
SearchHistoryService = SearchHistoryService_1 = __decorate([
  __param(0, IStorageService)
], SearchHistoryService);

// node_modules/vscode/vscode/src/vs/workbench/contrib/search/browser/replace.js
init_instantiation();
var IReplaceService = createDecorator("replaceService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/search/browser/searchModel.js
init_tslib_es6();
init_async();
init_cancellation();
init_errors();
init_event();
init_lazy();
init_lifecycle();
init_map();
init_network();
init_strings();
init_ternarySearchTree();
init_uri();
init_range();
init_model();
init_textModel();
init_model2();
init_configuration();
init_instantiation();
init_log();
init_telemetry();
init_colorRegistry();
init_themeService();

// node_modules/vscode/override/vs/workbench/contrib/notebook/browser/contrib/find/findMatchDecorationModel.js
var FindMatchDecorationModel = class {
};

// node_modules/vscode/override/vs/workbench/contrib/notebook/browser/notebookEditorWidget.js
var NotebookEditorWidget = class {
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/browser/services/notebookEditorService.js
init_instantiation();
var INotebookEditorService = createDecorator("INotebookEditorWidgetService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/search/browser/searchModel.js
init_notebookCommon();

// node_modules/vscode/vscode/src/vs/workbench/contrib/search/browser/searchNotebookHelpers.js
init_range();
init_pieceTreeTextBufferBuilder();
init_textModelSearch();
init_lifecycle();
function isIFileMatchWithCells(object) {
  return "cellResults" in object;
}
function contentMatchesToTextSearchMatches(contentMatches, cell) {
  return genericCellMatchesToTextSearchMatches(contentMatches, cell instanceof CellSearchModel ? cell.inputTextBuffer : cell.textBuffer);
}
function genericCellMatchesToTextSearchMatches(contentMatches, buffer, cell) {
  let previousEndLine = -1;
  const contextGroupings = [];
  let currentContextGrouping = [];
  contentMatches.forEach((match2) => {
    if (match2.range.startLineNumber !== previousEndLine) {
      if (currentContextGrouping.length > 0) {
        contextGroupings.push([...currentContextGrouping]);
        currentContextGrouping = [];
      }
    }
    currentContextGrouping.push(match2);
    previousEndLine = match2.range.endLineNumber;
  });
  if (currentContextGrouping.length > 0) {
    contextGroupings.push([...currentContextGrouping]);
  }
  const textSearchResults = contextGroupings.map((grouping) => {
    const lineTexts = [];
    const firstLine = grouping[0].range.startLineNumber;
    const lastLine = grouping[grouping.length - 1].range.endLineNumber;
    for (let i = firstLine; i <= lastLine; i++) {
      lineTexts.push(buffer.getLineContent(i));
    }
    return new TextSearchMatch(lineTexts.join("\n") + "\n", grouping.map((m) => new Range(
      m.range.startLineNumber - 1,
      m.range.startColumn - 1,
      m.range.endLineNumber - 1,
      m.range.endColumn - 1
    )));
  });
  return textSearchResults;
}
function webviewMatchesToTextSearchMatches(webviewMatches) {
  return webviewMatches.map((rawMatch) => rawMatch.searchPreviewInfo ? new TextSearchMatch(rawMatch.searchPreviewInfo.line, new Range(
    0,
    rawMatch.searchPreviewInfo.range.start,
    0,
    rawMatch.searchPreviewInfo.range.end
  ), void 0, rawMatch.index) : void 0).filter((e) => !!e);
}
var rawCellPrefix = "rawCell#";
var CellSearchModel = class extends Disposable {
  constructor(_source, _inputTextBuffer, _outputs, _uri, _cellIndex) {
    super();
    this._source = _source;
    this._inputTextBuffer = _inputTextBuffer;
    this._outputs = _outputs;
    this._uri = _uri;
    this._cellIndex = _cellIndex;
    this._outputTextBuffers = void 0;
  }
  get id() {
    return `${rawCellPrefix}${this._cellIndex}`;
  }
  get uri() {
    return this._uri;
  }
  _getFullModelRange(buffer) {
    const lineCount = buffer.getLineCount();
    return new Range(1, 1, lineCount, this._getLineMaxColumn(buffer, lineCount));
  }
  _getLineMaxColumn(buffer, lineNumber) {
    if (lineNumber < 1 || lineNumber > buffer.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return buffer.getLineLength(lineNumber) + 1;
  }
  get inputTextBuffer() {
    if (!this._inputTextBuffer) {
      const builder = new PieceTreeTextBufferBuilder();
      builder.acceptChunk(this._source);
      const bufferFactory = builder.finish(true);
      const { textBuffer, disposable } = bufferFactory.create(1);
      this._inputTextBuffer = textBuffer;
      this._register(disposable);
    }
    return this._inputTextBuffer;
  }
  get outputTextBuffers() {
    if (!this._outputTextBuffers) {
      this._outputTextBuffers = this._outputs.map((output) => {
        const builder = new PieceTreeTextBufferBuilder();
        builder.acceptChunk(output.data.toString());
        const bufferFactory = builder.finish(true);
        const { textBuffer, disposable } = bufferFactory.create(1);
        this._register(disposable);
        return textBuffer;
      });
    }
    return this._outputTextBuffers;
  }
  findInInputs(target) {
    const searchParams = new SearchParams(target, false, false, null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return [];
    }
    const fullInputRange = this._getFullModelRange(this.inputTextBuffer);
    return this.inputTextBuffer.findMatchesLineByLine(fullInputRange, searchData, true, 5e3);
  }
  findInOutputs(target) {
    const searchParams = new SearchParams(target, false, false, null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return [];
    }
    return this.outputTextBuffers.map((buffer) => {
      const matches = buffer.findMatchesLineByLine(this._getFullModelRange(buffer), searchData, true, 5e3);
      if (matches.length === 0) {
        return void 0;
      }
      return {
        textBuffer: buffer,
        matches
      };
    }).filter((item) => !!item);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/search/common/notebookSearch.js
init_instantiation();
var INotebookSearchService = createDecorator("notebookSearchService");

// node_modules/vscode/vscode/src/vs/workbench/services/search/common/replace.js
init_strings();
var ReplacePattern = class {
  constructor(replaceString, arg2, arg3) {
    this._hasParameters = false;
    this._replacePattern = replaceString;
    let searchPatternInfo;
    let parseParameters;
    if (typeof arg2 === "boolean") {
      parseParameters = arg2;
      this._regExp = arg3;
    } else {
      searchPatternInfo = arg2;
      parseParameters = !!searchPatternInfo.isRegExp;
      this._regExp = createRegExp(searchPatternInfo.pattern, !!searchPatternInfo.isRegExp, { matchCase: searchPatternInfo.isCaseSensitive, wholeWord: searchPatternInfo.isWordMatch, multiline: searchPatternInfo.isMultiline, global: false, unicode: true });
    }
    if (parseParameters) {
      this.parseReplaceString(replaceString);
    }
    if (this._regExp.global) {
      this._regExp = createRegExp(this._regExp.source, true, { matchCase: !this._regExp.ignoreCase, wholeWord: false, multiline: this._regExp.multiline, global: false });
    }
    this._caseOpsRegExp = new RegExp(/([\s\S]*?)((?:\\[uUlL])+?|)(\$[0-9]+)([\s\S]*?)/g);
  }
  get hasParameters() {
    return this._hasParameters;
  }
  get pattern() {
    return this._replacePattern;
  }
  get regExp() {
    return this._regExp;
  }
  getReplaceString(text, preserveCase) {
    this._regExp.lastIndex = 0;
    const match2 = this._regExp.exec(text);
    if (match2) {
      if (this.hasParameters) {
        const replaceString = this.replaceWithCaseOperations(text, this._regExp, this.buildReplaceString(match2, preserveCase));
        if (match2[0] === text) {
          return replaceString;
        }
        return replaceString.substr(match2.index, match2[0].length - (text.length - replaceString.length));
      }
      return this.buildReplaceString(match2, preserveCase);
    }
    return null;
  }
  replaceWithCaseOperations(text, regex, replaceString) {
    if (!/\\[uUlL]/.test(replaceString)) {
      return text.replace(regex, replaceString);
    }
    const firstMatch = regex.exec(text);
    if (firstMatch === null) {
      return text.replace(regex, replaceString);
    }
    let patMatch;
    let newReplaceString = "";
    let lastIndex = 0;
    let lastMatch = "";
    while ((patMatch = this._caseOpsRegExp.exec(replaceString)) !== null) {
      lastIndex = patMatch.index;
      const fullMatch = patMatch[0];
      lastMatch = fullMatch;
      let caseOps = patMatch[2];
      const money = patMatch[3];
      if (!caseOps) {
        newReplaceString += fullMatch;
        continue;
      }
      const replacement = firstMatch[parseInt(money.slice(1))];
      if (!replacement) {
        newReplaceString += fullMatch;
        continue;
      }
      const replacementLen = replacement.length;
      newReplaceString += patMatch[1];
      caseOps = caseOps.replace(/\\/g, "");
      let i = 0;
      for (; i < caseOps.length; i++) {
        switch (caseOps[i]) {
          case "U":
            newReplaceString += replacement.slice(i).toUpperCase();
            i = replacementLen;
            break;
          case "u":
            newReplaceString += replacement[i].toUpperCase();
            break;
          case "L":
            newReplaceString += replacement.slice(i).toLowerCase();
            i = replacementLen;
            break;
          case "l":
            newReplaceString += replacement[i].toLowerCase();
            break;
        }
      }
      if (i < replacementLen) {
        newReplaceString += replacement.slice(i);
      }
      newReplaceString += patMatch[4];
    }
    newReplaceString += replaceString.slice(lastIndex + lastMatch.length);
    return text.replace(regex, newReplaceString);
  }
  buildReplaceString(matches, preserveCase) {
    if (preserveCase) {
      return buildReplaceStringWithCasePreserved(matches, this._replacePattern);
    } else {
      return this._replacePattern;
    }
  }
  parseReplaceString(replaceString) {
    if (!replaceString || replaceString.length === 0) {
      return;
    }
    let substrFrom = 0, result = "";
    for (let i = 0, len = replaceString.length; i < len; i++) {
      const chCode = replaceString.charCodeAt(i);
      if (chCode === 92) {
        i++;
        if (i >= len) {
          break;
        }
        const nextChCode = replaceString.charCodeAt(i);
        let replaceWithCharacter = null;
        switch (nextChCode) {
          case 92:
            replaceWithCharacter = "\\";
            break;
          case 110:
            replaceWithCharacter = "\n";
            break;
          case 116:
            replaceWithCharacter = "	";
            break;
        }
        if (replaceWithCharacter) {
          result += replaceString.substring(substrFrom, i - 1) + replaceWithCharacter;
          substrFrom = i + 1;
        }
      }
      if (chCode === 36) {
        i++;
        if (i >= len) {
          break;
        }
        const nextChCode = replaceString.charCodeAt(i);
        let replaceWithCharacter = null;
        switch (nextChCode) {
          case 48:
            replaceWithCharacter = "$&";
            this._hasParameters = true;
            break;
          case 96:
          case 39:
            this._hasParameters = true;
            break;
          default: {
            if (!this.between(nextChCode, 49, 57)) {
              break;
            }
            if (i === replaceString.length - 1) {
              this._hasParameters = true;
              break;
            }
            let charCode = replaceString.charCodeAt(++i);
            if (!this.between(charCode, 48, 57)) {
              this._hasParameters = true;
              --i;
              break;
            }
            if (i === replaceString.length - 1) {
              this._hasParameters = true;
              break;
            }
            charCode = replaceString.charCodeAt(++i);
            if (!this.between(charCode, 48, 57)) {
              this._hasParameters = true;
              --i;
              break;
            }
            break;
          }
        }
        if (replaceWithCharacter) {
          result += replaceString.substring(substrFrom, i - 1) + replaceWithCharacter;
          substrFrom = i + 1;
        }
      }
    }
    if (substrFrom === 0) {
      return;
    }
    this._replacePattern = result + replaceString.substring(substrFrom);
  }
  between(value, from, to) {
    return from <= value && value <= to;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/search/common/searchHelpers.js
init_range();
function editorMatchToTextSearchResult(matches, model, previewOptions) {
  const firstLine = matches[0].range.startLineNumber;
  const lastLine = matches[matches.length - 1].range.endLineNumber;
  const lineTexts = [];
  for (let i = firstLine; i <= lastLine; i++) {
    lineTexts.push(model.getLineContent(i));
  }
  return new TextSearchMatch(lineTexts.join("\n") + "\n", matches.map((m) => new Range(
    m.range.startLineNumber - 1,
    m.range.startColumn - 1,
    m.range.endLineNumber - 1,
    m.range.endColumn - 1
  )), previewOptions);
}
function editorMatchesToTextSearchResults(matches, model, previewOptions) {
  let previousEndLine = -1;
  const groupedMatches = [];
  let currentMatches = [];
  matches.forEach((match2) => {
    if (match2.range.startLineNumber !== previousEndLine) {
      currentMatches = [];
      groupedMatches.push(currentMatches);
    }
    currentMatches.push(match2);
    previousEndLine = match2.range.endLineNumber;
  });
  return groupedMatches.map((sameLineMatches) => {
    return editorMatchToTextSearchResult(sameLineMatches, model, previewOptions);
  });
}
function addContextToEditorMatches(matches, model, query) {
  const results = [];
  let prevLine = -1;
  for (let i = 0; i < matches.length; i++) {
    const { start: matchStartLine, end: matchEndLine } = getMatchStartEnd(matches[i]);
    if (typeof query.beforeContext === "number" && query.beforeContext > 0) {
      const beforeContextStartLine = Math.max(prevLine + 1, matchStartLine - query.beforeContext);
      for (let b = beforeContextStartLine; b < matchStartLine; b++) {
        results.push({
          text: model.getLineContent(b + 1),
          lineNumber: b
        });
      }
    }
    results.push(matches[i]);
    const nextMatch = matches[i + 1];
    const nextMatchStartLine = nextMatch ? getMatchStartEnd(nextMatch).start : Number.MAX_VALUE;
    if (typeof query.afterContext === "number" && query.afterContext > 0) {
      const afterContextToLine = Math.min(nextMatchStartLine - 1, matchEndLine + query.afterContext, model.getLineCount() - 1);
      for (let a = matchEndLine + 1; a <= afterContextToLine; a++) {
        results.push({
          text: model.getLineContent(a + 1),
          lineNumber: a
        });
      }
    }
    prevLine = matchEndLine;
  }
  return results;
}
function getMatchStartEnd(match2) {
  const matchRanges = match2.ranges;
  const matchStartLine = Array.isArray(matchRanges) ? matchRanges[0].startLineNumber : matchRanges.startLineNumber;
  const matchEndLine = Array.isArray(matchRanges) ? matchRanges[matchRanges.length - 1].endLineNumber : matchRanges.endLineNumber;
  return {
    start: matchStartLine,
    end: matchEndLine
  };
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/search/browser/searchModel.js
var FileMatch_1;
var FolderMatch_1;
var RangeHighlightDecorations_1;
var _Match = class _Match {
  constructor(_parent, _fullPreviewLines, _fullPreviewRange, _documentRange) {
    this._parent = _parent;
    this._fullPreviewLines = _fullPreviewLines;
    this._oneLinePreviewText = _fullPreviewLines[_fullPreviewRange.startLineNumber];
    const adjustedEndCol = _fullPreviewRange.startLineNumber === _fullPreviewRange.endLineNumber ? _fullPreviewRange.endColumn : this._oneLinePreviewText.length;
    this._rangeInPreviewText = new OneLineRange(1, _fullPreviewRange.startColumn + 1, adjustedEndCol + 1);
    this._range = new Range(
      _documentRange.startLineNumber + 1,
      _documentRange.startColumn + 1,
      _documentRange.endLineNumber + 1,
      _documentRange.endColumn + 1
    );
    this._fullPreviewRange = _fullPreviewRange;
    this._id = this._parent.id() + ">" + this._range + this.getMatchString();
  }
  id() {
    return this._id;
  }
  parent() {
    return this._parent;
  }
  text() {
    return this._oneLinePreviewText;
  }
  range() {
    return this._range;
  }
  preview() {
    let before = this._oneLinePreviewText.substring(0, this._rangeInPreviewText.startColumn - 1), inside = this.getMatchString(), after2 = this._oneLinePreviewText.substring(this._rangeInPreviewText.endColumn - 1);
    before = lcut(before, 26);
    before = before.trimStart();
    let charsRemaining = _Match.MAX_PREVIEW_CHARS - before.length;
    inside = inside.substr(0, charsRemaining);
    charsRemaining -= inside.length;
    after2 = after2.substr(0, charsRemaining);
    return {
      before,
      inside,
      after: after2
    };
  }
  get replaceString() {
    const searchModel = this.parent().parent().searchModel;
    if (!searchModel.replacePattern) {
      throw new Error("searchModel.replacePattern must be set before accessing replaceString");
    }
    const fullMatchText = this.fullMatchText();
    let replaceString = searchModel.replacePattern.getReplaceString(fullMatchText, searchModel.preserveCase);
    if (replaceString !== null) {
      return replaceString;
    }
    const fullMatchTextWithoutCR = fullMatchText.replace(/\r\n/g, "\n");
    if (fullMatchTextWithoutCR !== fullMatchText) {
      replaceString = searchModel.replacePattern.getReplaceString(fullMatchTextWithoutCR, searchModel.preserveCase);
      if (replaceString !== null) {
        return replaceString;
      }
    }
    const contextMatchTextWithSurroundingContent = this.fullMatchText(true);
    replaceString = searchModel.replacePattern.getReplaceString(contextMatchTextWithSurroundingContent, searchModel.preserveCase);
    if (replaceString !== null) {
      return replaceString;
    }
    const contextMatchTextWithoutCR = contextMatchTextWithSurroundingContent.replace(/\r\n/g, "\n");
    if (contextMatchTextWithoutCR !== contextMatchTextWithSurroundingContent) {
      replaceString = searchModel.replacePattern.getReplaceString(contextMatchTextWithoutCR, searchModel.preserveCase);
      if (replaceString !== null) {
        return replaceString;
      }
    }
    return searchModel.replacePattern.pattern;
  }
  fullMatchText(includeSurrounding = false) {
    let thisMatchPreviewLines;
    if (includeSurrounding) {
      thisMatchPreviewLines = this._fullPreviewLines;
    } else {
      thisMatchPreviewLines = this._fullPreviewLines.slice(this._fullPreviewRange.startLineNumber, this._fullPreviewRange.endLineNumber + 1);
      thisMatchPreviewLines[thisMatchPreviewLines.length - 1] = thisMatchPreviewLines[thisMatchPreviewLines.length - 1].slice(0, this._fullPreviewRange.endColumn);
      thisMatchPreviewLines[0] = thisMatchPreviewLines[0].slice(this._fullPreviewRange.startColumn);
    }
    return thisMatchPreviewLines.join("\n");
  }
  rangeInPreview() {
    return {
      ...this._fullPreviewRange,
      startColumn: this._fullPreviewRange.startColumn + 1,
      endColumn: this._fullPreviewRange.endColumn + 1
    };
  }
  fullPreviewLines() {
    return this._fullPreviewLines.slice(this._fullPreviewRange.startLineNumber, this._fullPreviewRange.endLineNumber + 1);
  }
  getMatchString() {
    return this._oneLinePreviewText.substring(this._rangeInPreviewText.startColumn - 1, this._rangeInPreviewText.endColumn - 1);
  }
};
_Match.MAX_PREVIEW_CHARS = 250;
var Match = _Match;
Match.__decorator = __decorate([
  memoize
], Match.prototype, "preview", null);
var CellMatch = class {
  constructor(_parent, _cell, _cellIndex) {
    this._parent = _parent;
    this._cell = _cell;
    this._cellIndex = _cellIndex;
    this._contentMatches = /* @__PURE__ */ new Map();
    this._webviewMatches = /* @__PURE__ */ new Map();
    this._context = /* @__PURE__ */ new Map();
  }
  get context() {
    return new Map(this._context);
  }
  matches() {
    return [...this._contentMatches.values(), ...this._webviewMatches.values()];
  }
  get contentMatches() {
    return Array.from(this._contentMatches.values());
  }
  get webviewMatches() {
    return Array.from(this._webviewMatches.values());
  }
  remove(matches) {
    if (!Array.isArray(matches)) {
      matches = [matches];
    }
    for (const match2 of matches) {
      this._contentMatches.delete(match2.id());
      this._webviewMatches.delete(match2.id());
    }
  }
  clearAllMatches() {
    this._contentMatches.clear();
    this._webviewMatches.clear();
  }
  addContentMatches(textSearchMatches) {
    const contentMatches = textSearchMatchesToNotebookMatches();
    contentMatches.forEach((match2) => {
      this._contentMatches.set(match2.id(), match2);
    });
    this.addContext(textSearchMatches);
  }
  addContext(textSearchMatches) {
    if (this.cell instanceof CellSearchModel) {
      return;
    }
    this.cell.resolveTextModel().then((textModel) => {
      const textResultsWithContext = addContextToEditorMatches(textSearchMatches, textModel, this.parent.parent().query);
      const contexts = textResultsWithContext.filter((result) => !resultIsMatch(result));
      contexts.map((context) => ({ ...context, lineNumber: context.lineNumber + 1 })).forEach((context) => {
        this._context.set(context.lineNumber, context.text);
      });
    });
  }
  addWebviewMatches(textSearchMatches) {
    const webviewMatches = textSearchMatchesToNotebookMatches();
    webviewMatches.forEach((match2) => {
      this._webviewMatches.set(match2.id(), match2);
    });
  }
  setCellModel(cell) {
    this._cell = cell;
  }
  get parent() {
    return this._parent;
  }
  get id() {
    return this._cell.id;
  }
  get cellIndex() {
    return this._cellIndex;
  }
  get cell() {
    return this._cell;
  }
};
var MatchInNotebook = class extends Match {
  constructor(_cellParent, _fullPreviewLines, _fullPreviewRange, _documentRange, webviewIndex) {
    super(_cellParent.parent, _fullPreviewLines, _fullPreviewRange, _documentRange);
    this._cellParent = _cellParent;
    this._id = this._parent.id() + ">" + this._cellParent.cellIndex + (webviewIndex ? "_" + webviewIndex : "") + "_" + this.notebookMatchTypeString() + this._range + this.getMatchString();
    this._webviewIndex = webviewIndex;
  }
  parent() {
    return this._cellParent.parent;
  }
  get cellParent() {
    return this._cellParent;
  }
  notebookMatchTypeString() {
    return this.isWebviewMatch() ? "webview" : "content";
  }
  isWebviewMatch() {
    return this._webviewIndex !== void 0;
  }
  get cellIndex() {
    return this._cellParent.cellIndex;
  }
  get webviewIndex() {
    return this._webviewIndex;
  }
  get cell() {
    return this._cellParent.cell;
  }
};
var _a18;
var FileMatch = (_a18 = class extends Disposable {
  static getDecorationOption(selected) {
    return selected ? FileMatch_1._CURRENT_FIND_MATCH : FileMatch_1._FIND_MATCH;
  }
  get context() {
    return new Map(this._context);
  }
  get cellContext() {
    const cellContext = /* @__PURE__ */ new Map();
    this._cellMatches.forEach((cellMatch) => {
      cellContext.set(cellMatch.id, cellMatch.context);
    });
    return cellContext;
  }
  constructor(_query, _previewOptions, _maxResults, _parent, rawMatch, _closestRoot, searchInstanceID, modelService, replaceService, labelService, notebookEditorService) {
    super();
    this._query = _query;
    this._previewOptions = _previewOptions;
    this._maxResults = _maxResults;
    this._parent = _parent;
    this.rawMatch = rawMatch;
    this._closestRoot = _closestRoot;
    this.searchInstanceID = searchInstanceID;
    this.modelService = modelService;
    this.replaceService = replaceService;
    this.labelService = labelService;
    this.notebookEditorService = notebookEditorService;
    this._onChange = this._register(new Emitter());
    this.onChange = this._onChange.event;
    this._onDispose = this._register(new Emitter());
    this.onDispose = this._onDispose.event;
    this._model = null;
    this._modelListener = null;
    this._selectedMatch = null;
    this._modelDecorations = [];
    this._context = /* @__PURE__ */ new Map();
    this._notebookEditorWidget = null;
    this._editorWidgetListener = null;
    this.replaceQ = Promise.resolve();
    this._resource = this.rawMatch.resource;
    this._textMatches = /* @__PURE__ */ new Map();
    this._removedTextMatches = /* @__PURE__ */ new Set();
    this._updateScheduler = new RunOnceScheduler(this.updateMatchesForModel.bind(this), 250);
    this._name = new Lazy(() => labelService.getUriBasenameLabel(this.resource));
    this._cellMatches = /* @__PURE__ */ new Map();
    this._notebookUpdateScheduler = new RunOnceScheduler(this.updateMatchesForEditorWidget.bind(this), 250);
    this.createMatches();
  }
  addWebviewMatchesToCell(cellID, webviewMatches) {
    const cellMatch = this.getCellMatch(cellID);
    if (cellMatch !== void 0) {
      cellMatch.addWebviewMatches(webviewMatches);
    }
  }
  addContentMatchesToCell(cellID, contentMatches) {
    const cellMatch = this.getCellMatch(cellID);
    if (cellMatch !== void 0) {
      cellMatch.addContentMatches(contentMatches);
    }
  }
  getCellMatch(cellID) {
    return this._cellMatches.get(cellID);
  }
  addCellMatch(rawCell) {
    const cellMatch = new CellMatch(this, rawCell.cell, rawCell.index);
    this._cellMatches.set(cellMatch.id, cellMatch);
    this.addWebviewMatchesToCell(rawCell.cell.id, rawCell.webviewResults);
    this.addContentMatchesToCell(rawCell.cell.id, rawCell.contentResults);
  }
  get closestRoot() {
    return this._closestRoot;
  }
  hasWebviewMatches() {
    return this.matches().some((m) => m instanceof MatchInNotebook && m.isWebviewMatch());
  }
  createMatches() {
    var _a43;
    const model = this.modelService.getModel(this._resource);
    if (model) {
      this.bindModel(model);
      this.updateMatchesForModel();
    } else {
      const notebookEditorWidgetBorrow = this.notebookEditorService.retrieveExistingWidgetFromURI(this.resource);
      if (notebookEditorWidgetBorrow == null ? void 0 : notebookEditorWidgetBorrow.value) {
        this.bindNotebookEditorWidget(notebookEditorWidgetBorrow.value);
      }
      if (this.rawMatch.results) {
        this.rawMatch.results.filter(resultIsMatch).forEach((rawMatch) => {
          textSearchResultToMatches(rawMatch, this).forEach((m) => this.add(m));
        });
      }
      if (isIFileMatchWithCells(this.rawMatch)) {
        (_a43 = this.rawMatch.cellResults) == null ? void 0 : _a43.forEach((cell) => this.addCellMatch(cell));
        this.setNotebookFindMatchDecorationsUsingCellMatches(this.cellMatches());
        this._onChange.fire({ forceUpdateModel: true });
      }
      this.addContext(this.rawMatch.results);
    }
  }
  bindModel(model) {
    this._model = model;
    this._modelListener = this._model.onDidChangeContent(() => {
      this._updateScheduler.schedule();
    });
    this._model.onWillDispose(() => this.onModelWillDispose());
    this.updateHighlights();
  }
  onModelWillDispose() {
    this.updateMatchesForModel();
    this.unbindModel();
  }
  unbindModel() {
    if (this._model) {
      this._updateScheduler.cancel();
      this._model.changeDecorations((accessor) => {
        this._modelDecorations = accessor.deltaDecorations(this._modelDecorations, []);
      });
      this._model = null;
      this._modelListener.dispose();
    }
  }
  updateMatchesForModel() {
    if (!this._model) {
      return;
    }
    this._textMatches = /* @__PURE__ */ new Map();
    const wordSeparators = this._query.isWordMatch && this._query.wordSeparators ? this._query.wordSeparators : null;
    const matches = this._model.findMatches(this._query.pattern, this._model.getFullModelRange(), !!this._query.isRegExp, !!this._query.isCaseSensitive, wordSeparators, false, this._maxResults ?? Number.MAX_SAFE_INTEGER);
    this.updateMatches(matches, true, this._model);
  }
  async updatesMatchesForLineAfterReplace(lineNumber, modelChange) {
    if (!this._model) {
      return;
    }
    const range = {
      startLineNumber: lineNumber,
      startColumn: this._model.getLineMinColumn(lineNumber),
      endLineNumber: lineNumber,
      endColumn: this._model.getLineMaxColumn(lineNumber)
    };
    const oldMatches = Array.from(this._textMatches.values()).filter((match2) => match2.range().startLineNumber === lineNumber);
    oldMatches.forEach((match2) => this._textMatches.delete(match2.id()));
    const wordSeparators = this._query.isWordMatch && this._query.wordSeparators ? this._query.wordSeparators : null;
    const matches = this._model.findMatches(this._query.pattern, range, !!this._query.isRegExp, !!this._query.isCaseSensitive, wordSeparators, false, this._maxResults ?? Number.MAX_SAFE_INTEGER);
    this.updateMatches(matches, modelChange, this._model);
  }
  updateMatches(matches, modelChange, model) {
    const textSearchResults = editorMatchesToTextSearchResults(matches, model, this._previewOptions);
    textSearchResults.forEach((textSearchResult) => {
      textSearchResultToMatches(textSearchResult, this).forEach((match2) => {
        if (!this._removedTextMatches.has(match2.id())) {
          this.add(match2);
          if (this.isMatchSelected(match2)) {
            this._selectedMatch = match2;
          }
        }
      });
    });
    this.addContext(addContextToEditorMatches(textSearchResults, model, this.parent().parent().query).filter((result) => !resultIsMatch(result)).map((context) => ({ ...context, lineNumber: context.lineNumber + 1 })));
    this._onChange.fire({ forceUpdateModel: modelChange });
    this.updateHighlights();
  }
  updateHighlights() {
    if (!this._model) {
      return;
    }
    this._model.changeDecorations((accessor) => {
      const newDecorations = this.parent().showHighlights ? this.matches().map((match2) => ({
        range: match2.range(),
        options: FileMatch_1.getDecorationOption(this.isMatchSelected(match2))
      })) : [];
      this._modelDecorations = accessor.deltaDecorations(this._modelDecorations, newDecorations);
    });
  }
  id() {
    return this.resource.toString();
  }
  parent() {
    return this._parent;
  }
  matches() {
    const cellMatches = Array.from(this._cellMatches.values()).flatMap((e) => e.matches());
    return [...this._textMatches.values(), ...cellMatches];
  }
  textMatches() {
    return Array.from(this._textMatches.values());
  }
  cellMatches() {
    return Array.from(this._cellMatches.values());
  }
  remove(matches) {
    if (!Array.isArray(matches)) {
      matches = [matches];
    }
    for (const match2 of matches) {
      this.removeMatch(match2);
      this._removedTextMatches.add(match2.id());
    }
    this._onChange.fire({ didRemove: true });
  }
  async replace(toReplace) {
    return this.replaceQ = this.replaceQ.finally(async () => {
      await this.replaceService.replace(toReplace);
      await this.updatesMatchesForLineAfterReplace(toReplace.range().startLineNumber, false);
    });
  }
  setSelectedMatch(match2) {
    if (match2) {
      if (!this.isMatchSelected(match2) && match2 instanceof MatchInNotebook) {
        this._selectedMatch = match2;
        return;
      }
      if (!this._textMatches.has(match2.id())) {
        return;
      }
      if (this.isMatchSelected(match2)) {
        return;
      }
    }
    this._selectedMatch = match2;
    this.updateHighlights();
  }
  getSelectedMatch() {
    return this._selectedMatch;
  }
  isMatchSelected(match2) {
    return !!this._selectedMatch && this._selectedMatch.id() === match2.id();
  }
  count() {
    return this.matches().length;
  }
  get resource() {
    return this._resource;
  }
  name() {
    return this._name.value;
  }
  addContext(results) {
    if (!results) {
      return;
    }
    const contexts = results.filter((result) => !resultIsMatch(result));
    return contexts.forEach((context) => this._context.set(context.lineNumber, context.text));
  }
  add(match2, trigger) {
    this._textMatches.set(match2.id(), match2);
    if (trigger) {
      this._onChange.fire({ forceUpdateModel: true });
    }
  }
  removeMatch(match2) {
    var _a43;
    if (match2 instanceof MatchInNotebook) {
      match2.cellParent.remove(match2);
      if (match2.cellParent.matches().length === 0) {
        this._cellMatches.delete(match2.cellParent.id);
      }
    } else {
      this._textMatches.delete(match2.id());
    }
    if (this.isMatchSelected(match2)) {
      this.setSelectedMatch(null);
      (_a43 = this._findMatchDecorationModel) == null ? void 0 : _a43.clearCurrentFindMatchDecoration();
    } else {
      this.updateHighlights();
    }
    if (match2 instanceof MatchInNotebook) {
      this.setNotebookFindMatchDecorationsUsingCellMatches(this.cellMatches());
    }
  }
  async resolveFileStat(fileService) {
    this._fileStat = await fileService.stat(this.resource).catch(() => void 0);
  }
  get fileStat() {
    return this._fileStat;
  }
  set fileStat(stat) {
    this._fileStat = stat;
  }
  dispose() {
    this.setSelectedMatch(null);
    this.unbindModel();
    this.unbindNotebookEditorWidget();
    this._onDispose.fire();
    super.dispose();
  }
  hasOnlyReadOnlyMatches() {
    return this.matches().every((match2) => match2 instanceof MatchInNotebook && match2.isWebviewMatch());
  }
  bindNotebookEditorWidget(widget) {
    var _a43;
    if (this._notebookEditorWidget === widget) {
      return;
    }
    this._notebookEditorWidget = widget;
    this._editorWidgetListener = ((_a43 = this._notebookEditorWidget.textModel) == null ? void 0 : _a43.onDidChangeContent((e) => {
      if (!e.rawEvents.some(
        (event) => event.kind === NotebookCellsChangeType.ChangeCellContent || event.kind === NotebookCellsChangeType.ModelChange
      )) {
        return;
      }
      this._notebookUpdateScheduler.schedule();
    })) ?? null;
    this._addNotebookHighlights();
  }
  unbindNotebookEditorWidget(widget) {
    var _a43;
    if (widget && this._notebookEditorWidget !== widget) {
      return;
    }
    if (this._notebookEditorWidget) {
      this._notebookUpdateScheduler.cancel();
      (_a43 = this._editorWidgetListener) == null ? void 0 : _a43.dispose();
    }
    this._removeNotebookHighlights();
    this._notebookEditorWidget = null;
  }
  updateNotebookHighlights() {
    if (this.parent().showHighlights) {
      this._addNotebookHighlights();
      this.setNotebookFindMatchDecorationsUsingCellMatches(Array.from(this._cellMatches.values()));
    } else {
      this._removeNotebookHighlights();
    }
  }
  _addNotebookHighlights() {
    var _a43, _b;
    if (!this._notebookEditorWidget) {
      return;
    }
    (_a43 = this._findMatchDecorationModel) == null ? void 0 : _a43.stopWebviewFind();
    (_b = this._findMatchDecorationModel) == null ? void 0 : _b.dispose();
    this._findMatchDecorationModel = new FindMatchDecorationModel(this._notebookEditorWidget, this.searchInstanceID);
    if (this._selectedMatch instanceof MatchInNotebook) {
      this.highlightCurrentFindMatchDecoration(this._selectedMatch);
    }
  }
  _removeNotebookHighlights() {
    var _a43, _b;
    if (this._findMatchDecorationModel) {
      (_a43 = this._findMatchDecorationModel) == null ? void 0 : _a43.stopWebviewFind();
      (_b = this._findMatchDecorationModel) == null ? void 0 : _b.dispose();
      this._findMatchDecorationModel = void 0;
    }
  }
  updateNotebookMatches(matches, modelChange) {
    var _a43;
    if (!this._notebookEditorWidget) {
      return;
    }
    const oldCellMatches = new Map(this._cellMatches);
    if (this._notebookEditorWidget.getId() !== this._lastEditorWidgetIdForUpdate) {
      this._cellMatches.clear();
      this._lastEditorWidgetIdForUpdate = this._notebookEditorWidget.getId();
    }
    matches.forEach((match2) => {
      let existingCell = this._cellMatches.get(match2.cell.id);
      if (this._notebookEditorWidget && !existingCell) {
        const index = this._notebookEditorWidget.getCellIndex(match2.cell);
        const existingRawCell = oldCellMatches.get(`${rawCellPrefix}${index}`);
        if (existingRawCell) {
          existingRawCell.setCellModel(match2.cell);
          existingRawCell.clearAllMatches();
          existingCell = existingRawCell;
        }
      }
      const cell = existingCell ?? new CellMatch(this, match2.cell, match2.index);
      cell.addContentMatches(contentMatchesToTextSearchMatches(match2.contentMatches, match2.cell));
      cell.addWebviewMatches(webviewMatchesToTextSearchMatches(match2.webviewMatches));
      this._cellMatches.set(cell.id, cell);
    });
    (_a43 = this._findMatchDecorationModel) == null ? void 0 : _a43.setAllFindMatchesDecorations(matches);
    if (this._selectedMatch instanceof MatchInNotebook) {
      this.highlightCurrentFindMatchDecoration(this._selectedMatch);
    }
    this._onChange.fire({ forceUpdateModel: modelChange });
  }
  setNotebookFindMatchDecorationsUsingCellMatches(cells) {
    if (!this._findMatchDecorationModel) {
      return;
    }
    const cellFindMatch = cells.map((cell) => {
      const webviewMatches = cell.webviewMatches.map((match2) => {
        return {
          index: match2.webviewIndex
        };
      });
      const findMatches = cell.contentMatches.map((match2) => {
        return new FindMatch(match2.range(), [match2.text()]);
      });
      return {
        cell: cell.cell,
        index: cell.cellIndex,
        contentMatches: findMatches,
        webviewMatches
      };
    });
    try {
      this._findMatchDecorationModel.setAllFindMatchesDecorations(cellFindMatch);
    } catch (e) {
    }
  }
  async updateMatchesForEditorWidget() {
    var _a43, _b, _c, _d;
    if (!this._notebookEditorWidget) {
      return;
    }
    this._textMatches = /* @__PURE__ */ new Map();
    const wordSeparators = this._query.isWordMatch && this._query.wordSeparators ? this._query.wordSeparators : null;
    const allMatches = await this._notebookEditorWidget.find(this._query.pattern, {
      regex: this._query.isRegExp,
      wholeWord: this._query.isWordMatch,
      caseSensitive: this._query.isCaseSensitive,
      wordSeparators: wordSeparators ?? void 0,
      includeMarkupInput: (_a43 = this._query.notebookInfo) == null ? void 0 : _a43.isInNotebookMarkdownInput,
      includeMarkupPreview: (_b = this._query.notebookInfo) == null ? void 0 : _b.isInNotebookMarkdownPreview,
      includeCodeInput: (_c = this._query.notebookInfo) == null ? void 0 : _c.isInNotebookCellInput,
      includeOutput: (_d = this._query.notebookInfo) == null ? void 0 : _d.isInNotebookCellOutput
    }, CancellationToken.None, false, true, this.searchInstanceID);
    this.updateNotebookMatches(allMatches, true);
  }
  async showMatch(match2) {
    const offset = await this.highlightCurrentFindMatchDecoration(match2);
    this.setSelectedMatch(match2);
    this.revealCellRange(match2, offset);
  }
  async highlightCurrentFindMatchDecoration(match2) {
    if (!this._findMatchDecorationModel || match2.cell instanceof CellSearchModel) {
      return null;
    }
    if (match2.webviewIndex === void 0) {
      return this._findMatchDecorationModel.highlightCurrentFindMatchDecorationInCell(match2.cell, match2.range());
    } else {
      return this._findMatchDecorationModel.highlightCurrentFindMatchDecorationInWebview(match2.cell, match2.webviewIndex);
    }
  }
  revealCellRange(match2, outputOffset) {
    if (!this._notebookEditorWidget || match2.cell instanceof CellSearchModel) {
      return;
    }
    if (match2.webviewIndex !== void 0) {
      const index = this._notebookEditorWidget.getCellIndex(match2.cell);
      if (index !== void 0) {
        this._notebookEditorWidget.revealCellOffsetInCenterAsync(match2.cell, outputOffset ?? 0);
      }
    } else {
      match2.cell.updateEditState(match2.cell.getEditState(), "focusNotebookCell");
      this._notebookEditorWidget.setCellEditorSelection(match2.cell, match2.range());
      this._notebookEditorWidget.revealRangeInCenterIfOutsideViewportAsync(match2.cell, match2.range());
    }
  }
}, FileMatch_1 = _a18, _a18._CURRENT_FIND_MATCH = ModelDecorationOptions.register({
  description: "search-current-find-match",
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
}), _a18._FIND_MATCH = ModelDecorationOptions.register({
  description: "search-find-match",
  stickiness: 1,
  className: "findMatch",
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
}), _a18);
FileMatch = FileMatch_1 = __decorate([
  __param(7, IModelService),
  __param(8, IReplaceService),
  __param(9, ILabelService),
  __param(10, INotebookEditorService)
], FileMatch);
var FolderMatch = FolderMatch_1 = class FolderMatch2 extends Disposable {
  constructor(_resource, _id, _index, _query, _parent, _searchResult, _closestRoot, replaceService, instantiationService, labelService, uriIdentityService) {
    super();
    this._resource = _resource;
    this._id = _id;
    this._index = _index;
    this._query = _query;
    this._parent = _parent;
    this._searchResult = _searchResult;
    this._closestRoot = _closestRoot;
    this.replaceService = replaceService;
    this.instantiationService = instantiationService;
    this.uriIdentityService = uriIdentityService;
    this._onChange = this._register(new Emitter());
    this.onChange = this._onChange.event;
    this._onDispose = this._register(new Emitter());
    this.onDispose = this._onDispose.event;
    this._replacingAll = false;
    this._fileMatches = new ResourceMap();
    this._folderMatches = new ResourceMap();
    this._folderMatchesMap = TernarySearchTree.forUris((key) => this.uriIdentityService.extUri.ignorePathCasing(key));
    this._unDisposedFileMatches = new ResourceMap();
    this._unDisposedFolderMatches = new ResourceMap();
    this._name = new Lazy(() => this.resource ? labelService.getUriBasenameLabel(this.resource) : "");
  }
  get searchModel() {
    return this._searchResult.searchModel;
  }
  get showHighlights() {
    return this._parent.showHighlights;
  }
  get closestRoot() {
    return this._closestRoot;
  }
  set replacingAll(b) {
    this._replacingAll = b;
  }
  id() {
    return this._id;
  }
  get resource() {
    return this._resource;
  }
  index() {
    return this._index;
  }
  name() {
    return this._name.value;
  }
  parent() {
    return this._parent;
  }
  bindModel(model) {
    const fileMatch = this._fileMatches.get(model.uri);
    if (fileMatch) {
      fileMatch.bindModel(model);
    } else {
      const folderMatch = this.getFolderMatch(model.uri);
      const match2 = folderMatch == null ? void 0 : folderMatch.getDownstreamFileMatch(model.uri);
      match2 == null ? void 0 : match2.bindModel(model);
    }
  }
  async bindNotebookEditorWidget(editor, resource) {
    const fileMatch = this._fileMatches.get(resource);
    if (fileMatch) {
      fileMatch.bindNotebookEditorWidget(editor);
      await fileMatch.updateMatchesForEditorWidget();
    } else {
      const folderMatches = this.folderMatchesIterator();
      for (const elem of folderMatches) {
        await elem.bindNotebookEditorWidget(editor, resource);
      }
    }
  }
  unbindNotebookEditorWidget(editor, resource) {
    const fileMatch = this._fileMatches.get(resource);
    if (fileMatch) {
      fileMatch.unbindNotebookEditorWidget(editor);
    } else {
      const folderMatches = this.folderMatchesIterator();
      for (const elem of folderMatches) {
        elem.unbindNotebookEditorWidget(editor, resource);
      }
    }
  }
  createIntermediateFolderMatch(resource, id, index, query, baseWorkspaceFolder) {
    const folderMatch = this.instantiationService.createInstance(FolderMatchWithResource, resource, id, index, query, this, this._searchResult, baseWorkspaceFolder);
    this.configureIntermediateMatch(folderMatch);
    this.doAddFolder(folderMatch);
    return folderMatch;
  }
  configureIntermediateMatch(folderMatch) {
    const disposable = folderMatch.onChange((event) => this.onFolderChange(folderMatch, event));
    folderMatch.onDispose(() => disposable.dispose());
  }
  clear(clearingAll = false) {
    const changed = this.allDownstreamFileMatches();
    this.disposeMatches();
    this._onChange.fire({ elements: changed, removed: true, added: false, clearingAll });
  }
  remove(matches) {
    if (!Array.isArray(matches)) {
      matches = [matches];
    }
    const allMatches = getFileMatches(matches);
    this.doRemoveFile(allMatches);
  }
  async replace(match2) {
    return this.replaceService.replace([match2]).then(() => {
      this.doRemoveFile([match2], true, true, true);
    });
  }
  replaceAll() {
    const matches = this.matches();
    return this.batchReplace(matches);
  }
  matches() {
    return [...this.fileMatchesIterator(), ...this.folderMatchesIterator()];
  }
  fileMatchesIterator() {
    return this._fileMatches.values();
  }
  folderMatchesIterator() {
    return this._folderMatches.values();
  }
  isEmpty() {
    return this.fileCount() + this.folderCount() === 0;
  }
  getDownstreamFileMatch(uri) {
    const directChildFileMatch = this._fileMatches.get(uri);
    if (directChildFileMatch) {
      return directChildFileMatch;
    }
    const folderMatch = this.getFolderMatch(uri);
    const match2 = folderMatch == null ? void 0 : folderMatch.getDownstreamFileMatch(uri);
    if (match2) {
      return match2;
    }
    return null;
  }
  allDownstreamFileMatches() {
    let recursiveChildren = [];
    const iterator = this.folderMatchesIterator();
    for (const elem of iterator) {
      recursiveChildren = recursiveChildren.concat(elem.allDownstreamFileMatches());
    }
    return [...this.fileMatchesIterator(), ...recursiveChildren];
  }
  fileCount() {
    return this._fileMatches.size;
  }
  folderCount() {
    return this._folderMatches.size;
  }
  count() {
    return this.fileCount() + this.folderCount();
  }
  recursiveFileCount() {
    return this.allDownstreamFileMatches().length;
  }
  recursiveMatchCount() {
    return this.allDownstreamFileMatches().reduce((prev, match2) => prev + match2.count(), 0);
  }
  get query() {
    return this._query;
  }
  addFileMatch(raw, silent, searchInstanceID) {
    const added = [];
    const updated = [];
    raw.forEach((rawFileMatch) => {
      var _a43;
      const existingFileMatch = this.getDownstreamFileMatch(rawFileMatch.resource);
      if (existingFileMatch) {
        if (rawFileMatch.results) {
          rawFileMatch.results.filter(resultIsMatch).forEach((m) => {
            textSearchResultToMatches(m, existingFileMatch).forEach((m2) => existingFileMatch.add(m2));
          });
        }
        if (isIFileMatchWithCells(rawFileMatch)) {
          (_a43 = rawFileMatch.cellResults) == null ? void 0 : _a43.forEach((rawCellMatch) => {
            const existingCellMatch = existingFileMatch.getCellMatch(rawCellMatch.cell.id);
            if (existingCellMatch) {
              existingCellMatch.addContentMatches(rawCellMatch.contentResults);
              existingCellMatch.addWebviewMatches(rawCellMatch.webviewResults);
            } else {
              existingFileMatch.addCellMatch(rawCellMatch);
            }
          });
        }
        updated.push(existingFileMatch);
        existingFileMatch.addContext(rawFileMatch.results);
      } else {
        if (this instanceof FolderMatchWorkspaceRoot || this instanceof FolderMatchNoRoot) {
          const fileMatch = this.createAndConfigureFileMatch(rawFileMatch, searchInstanceID);
          added.push(fileMatch);
        }
      }
    });
    const elements = [...added, ...updated];
    if (!silent && elements.length) {
      this._onChange.fire({ elements, added: !!added.length });
    }
  }
  doAddFile(fileMatch) {
    this._fileMatches.set(fileMatch.resource, fileMatch);
    if (this._unDisposedFileMatches.has(fileMatch.resource)) {
      this._unDisposedFileMatches.delete(fileMatch.resource);
    }
  }
  hasOnlyReadOnlyMatches() {
    return Array.from(this._fileMatches.values()).every((fm) => fm.hasOnlyReadOnlyMatches());
  }
  uriHasParent(parent, child) {
    return this.uriIdentityService.extUri.isEqualOrParent(child, parent) && !this.uriIdentityService.extUri.isEqual(child, parent);
  }
  isInParentChain(folderMatch) {
    let matchItem = this;
    while (matchItem instanceof FolderMatch_1) {
      if (matchItem.id() === folderMatch.id()) {
        return true;
      }
      matchItem = matchItem.parent();
    }
    return false;
  }
  getFolderMatch(resource) {
    const folderMatch = this._folderMatchesMap.findSubstr(resource);
    return folderMatch;
  }
  doAddFolder(folderMatch) {
    if (this instanceof FolderMatchWithResource && !this.uriHasParent(this.resource, folderMatch.resource)) {
      throw Error(`${folderMatch.resource} does not belong as a child of ${this.resource}`);
    } else if (this.isInParentChain(folderMatch)) {
      throw Error(`${folderMatch.resource} is a parent of ${this.resource}`);
    }
    this._folderMatches.set(folderMatch.resource, folderMatch);
    this._folderMatchesMap.set(folderMatch.resource, folderMatch);
    if (this._unDisposedFolderMatches.has(folderMatch.resource)) {
      this._unDisposedFolderMatches.delete(folderMatch.resource);
    }
  }
  async batchReplace(matches) {
    const allMatches = getFileMatches(matches);
    await this.replaceService.replace(allMatches);
    this.doRemoveFile(allMatches, true, true, true);
  }
  onFileChange(fileMatch, removed = false) {
    let added = false;
    if (!this._fileMatches.has(fileMatch.resource)) {
      this.doAddFile(fileMatch);
      added = true;
    }
    if (fileMatch.count() === 0) {
      this.doRemoveFile([fileMatch], false, false);
      added = false;
      removed = true;
    }
    if (!this._replacingAll) {
      this._onChange.fire({ elements: [fileMatch], added, removed });
    }
  }
  onFolderChange(folderMatch, event) {
    if (!this._folderMatches.has(folderMatch.resource)) {
      this.doAddFolder(folderMatch);
    }
    if (folderMatch.isEmpty()) {
      this._folderMatches.delete(folderMatch.resource);
      folderMatch.dispose();
    }
    this._onChange.fire(event);
  }
  doRemoveFile(fileMatches, dispose2 = true, trigger = true, keepReadonly = false) {
    const removed = [];
    for (const match2 of fileMatches) {
      if (this._fileMatches.get(match2.resource)) {
        if (keepReadonly && match2.hasWebviewMatches()) {
          continue;
        }
        this._fileMatches.delete(match2.resource);
        if (dispose2) {
          match2.dispose();
        } else {
          this._unDisposedFileMatches.set(match2.resource, match2);
        }
        removed.push(match2);
      } else {
        const folder = this.getFolderMatch(match2.resource);
        if (folder) {
          folder.doRemoveFile([match2], dispose2, trigger);
        } else {
          throw Error(`FileMatch ${match2.resource} is not located within FolderMatch ${this.resource}`);
        }
      }
    }
    if (trigger) {
      this._onChange.fire({ elements: removed, removed: true });
    }
  }
  disposeMatches() {
    [...this._fileMatches.values()].forEach((fileMatch) => fileMatch.dispose());
    [...this._folderMatches.values()].forEach((folderMatch) => folderMatch.disposeMatches());
    [...this._unDisposedFileMatches.values()].forEach((fileMatch) => fileMatch.dispose());
    [...this._unDisposedFolderMatches.values()].forEach((folderMatch) => folderMatch.disposeMatches());
    this._fileMatches.clear();
    this._folderMatches.clear();
    this._unDisposedFileMatches.clear();
    this._unDisposedFolderMatches.clear();
  }
  dispose() {
    this.disposeMatches();
    this._onDispose.fire();
    super.dispose();
  }
};
FolderMatch = FolderMatch_1 = __decorate([
  __param(7, IReplaceService),
  __param(8, IInstantiationService),
  __param(9, ILabelService),
  __param(10, IUriIdentityService)
], FolderMatch);
var FolderMatchWithResource = class FolderMatchWithResource2 extends FolderMatch {
  constructor(_resource, _id, _index, _query, _parent, _searchResult, _closestRoot, replaceService, instantiationService, labelService, uriIdentityService) {
    super(_resource, _id, _index, _query, _parent, _searchResult, _closestRoot, replaceService, instantiationService, labelService, uriIdentityService);
    this._normalizedResource = new Lazy(
      () => this.uriIdentityService.extUri.removeTrailingPathSeparator(this.uriIdentityService.extUri.normalizePath(this.resource))
    );
  }
  get resource() {
    return this._resource;
  }
  get normalizedResource() {
    return this._normalizedResource.value;
  }
};
FolderMatchWithResource = __decorate([
  __param(7, IReplaceService),
  __param(8, IInstantiationService),
  __param(9, ILabelService),
  __param(10, IUriIdentityService)
], FolderMatchWithResource);
var FolderMatchWorkspaceRoot = class FolderMatchWorkspaceRoot2 extends FolderMatchWithResource {
  constructor(_resource, _id, _index, _query, _parent, replaceService, instantiationService, labelService, uriIdentityService) {
    super(_resource, _id, _index, _query, _parent, _parent, null, replaceService, instantiationService, labelService, uriIdentityService);
  }
  normalizedUriParent(uri) {
    return this.uriIdentityService.extUri.normalizePath(this.uriIdentityService.extUri.dirname(uri));
  }
  uriEquals(uri1, ur2) {
    return this.uriIdentityService.extUri.isEqual(uri1, ur2);
  }
  createFileMatch(query, previewOptions, maxResults, parent, rawFileMatch, closestRoot, searchInstanceID) {
    const fileMatch = this.instantiationService.createInstance(FileMatch, query, previewOptions, maxResults, parent, rawFileMatch, closestRoot, searchInstanceID);
    parent.doAddFile(fileMatch);
    const disposable = fileMatch.onChange(({ didRemove }) => parent.onFileChange(fileMatch, didRemove));
    fileMatch.onDispose(() => disposable.dispose());
    return fileMatch;
  }
  createAndConfigureFileMatch(rawFileMatch, searchInstanceID) {
    if (!this.uriHasParent(this.resource, rawFileMatch.resource)) {
      throw Error(`${rawFileMatch.resource} is not a descendant of ${this.resource}`);
    }
    const fileMatchParentParts = [];
    let uri = this.normalizedUriParent(rawFileMatch.resource);
    while (!this.uriEquals(this.normalizedResource, uri)) {
      fileMatchParentParts.unshift(uri);
      const prevUri = uri;
      uri = this.uriIdentityService.extUri.removeTrailingPathSeparator(this.normalizedUriParent(uri));
      if (this.uriEquals(prevUri, uri)) {
        throw Error(`${rawFileMatch.resource} is not correctly configured as a child of ${this.normalizedResource}`);
      }
    }
    const root = this.closestRoot ?? this;
    let parent = this;
    for (let i = 0; i < fileMatchParentParts.length; i++) {
      let folderMatch = parent.getFolderMatch(fileMatchParentParts[i]);
      if (!folderMatch) {
        folderMatch = parent.createIntermediateFolderMatch(fileMatchParentParts[i], fileMatchParentParts[i].toString(), -1, this._query, root);
      }
      parent = folderMatch;
    }
    return this.createFileMatch(this._query.contentPattern, this._query.previewOptions, this._query.maxResults, parent, rawFileMatch, root, searchInstanceID);
  }
};
FolderMatchWorkspaceRoot = __decorate([
  __param(5, IReplaceService),
  __param(6, IInstantiationService),
  __param(7, ILabelService),
  __param(8, IUriIdentityService)
], FolderMatchWorkspaceRoot);
var FolderMatchNoRoot = class FolderMatchNoRoot2 extends FolderMatch {
  constructor(_id, _index, _query, _parent, replaceService, instantiationService, labelService, uriIdentityService) {
    super(null, _id, _index, _query, _parent, _parent, null, replaceService, instantiationService, labelService, uriIdentityService);
  }
  createAndConfigureFileMatch(rawFileMatch, searchInstanceID) {
    const fileMatch = this.instantiationService.createInstance(FileMatch, this._query.contentPattern, this._query.previewOptions, this._query.maxResults, this, rawFileMatch, null, searchInstanceID);
    this.doAddFile(fileMatch);
    const disposable = fileMatch.onChange(({ didRemove }) => this.onFileChange(fileMatch, didRemove));
    fileMatch.onDispose(() => disposable.dispose());
    return fileMatch;
  }
};
FolderMatchNoRoot = __decorate([
  __param(4, IReplaceService),
  __param(5, IInstantiationService),
  __param(6, ILabelService),
  __param(7, IUriIdentityService)
], FolderMatchNoRoot);
var SearchResult = class SearchResult2 extends Disposable {
  constructor(searchModel, replaceService, instantiationService, modelService, uriIdentityService, notebookEditorService) {
    super();
    this.searchModel = searchModel;
    this.replaceService = replaceService;
    this.instantiationService = instantiationService;
    this.modelService = modelService;
    this.uriIdentityService = uriIdentityService;
    this.notebookEditorService = notebookEditorService;
    this._onChange = this._register(new PauseableEmitter({
      merge: mergeSearchResultEvents
    }));
    this.onChange = this._onChange.event;
    this._folderMatches = [];
    this._otherFilesMatch = null;
    this._folderMatchesMap = TernarySearchTree.forUris((key) => this.uriIdentityService.extUri.ignorePathCasing(key));
    this._showHighlights = false;
    this._query = null;
    this.disposePastResults = () => {
    };
    this._isDirty = false;
    this._rangeHighlightDecorations = this.instantiationService.createInstance(RangeHighlightDecorations);
    this._register(this.modelService.onModelAdded((model) => this.onModelAdded(model)));
    this._register(this.notebookEditorService.onDidAddNotebookEditor((widget) => {
      if (widget instanceof NotebookEditorWidget) {
        this.onDidAddNotebookEditorWidget(widget);
      }
    }));
    this._register(this.onChange((e) => {
      if (e.removed) {
        this._isDirty = !this.isEmpty();
      }
    }));
  }
  async batchReplace(elementsToReplace) {
    try {
      this._onChange.pause();
      await Promise.all(elementsToReplace.map(async (elem) => {
        const parent = elem.parent();
        if ((parent instanceof FolderMatch || parent instanceof FileMatch) && arrayContainsElementOrParent(parent, elementsToReplace)) {
          return;
        }
        if (elem instanceof FileMatch) {
          await elem.parent().replace(elem);
        } else if (elem instanceof Match) {
          await elem.parent().replace(elem);
        } else if (elem instanceof FolderMatch) {
          await elem.replaceAll();
        }
      }));
    } finally {
      this._onChange.resume();
    }
  }
  batchRemove(elementsToRemove) {
    const removedElems = [];
    try {
      this._onChange.pause();
      elementsToRemove.forEach((currentElement) => {
        if (!arrayContainsElementOrParent(currentElement, removedElems)) {
          currentElement.parent().remove(currentElement);
          removedElems.push(currentElement);
        }
      });
    } finally {
      this._onChange.resume();
    }
  }
  get isDirty() {
    return this._isDirty;
  }
  get query() {
    return this._query;
  }
  set query(query) {
    const oldFolderMatches = this.folderMatches();
    new Promise((resolve) => this.disposePastResults = resolve).then(() => oldFolderMatches.forEach((match2) => match2.clear())).then(() => oldFolderMatches.forEach((match2) => match2.dispose())).then(() => this._isDirty = false);
    this._rangeHighlightDecorations.removeHighlightRange();
    this._folderMatchesMap = TernarySearchTree.forUris((key) => this.uriIdentityService.extUri.ignorePathCasing(key));
    if (!query) {
      return;
    }
    this._folderMatches = (query && query.folderQueries || []).map((fq) => fq.folder).map((resource, index) => this._createBaseFolderMatch(resource, resource.toString(), index, query));
    this._folderMatches.forEach((fm) => this._folderMatchesMap.set(fm.resource, fm));
    this._otherFilesMatch = this._createBaseFolderMatch(null, "otherFiles", this._folderMatches.length + 1, query);
    this._query = query;
  }
  onDidAddNotebookEditorWidget(widget) {
    var _a43, _b;
    (_a43 = this._onWillChangeModelListener) == null ? void 0 : _a43.dispose();
    this._onWillChangeModelListener = widget.onWillChangeModel((model) => {
      if (model) {
        this.onNotebookEditorWidgetRemoved(widget, model == null ? void 0 : model.uri);
      }
    });
    (_b = this._onDidChangeModelListener) == null ? void 0 : _b.dispose();
    this._onDidChangeModelListener = widget.onDidAttachViewModel(() => {
      if (widget.hasModel()) {
        this.onNotebookEditorWidgetAdded(widget, widget.textModel.uri);
      }
    });
  }
  onModelAdded(model) {
    const folderMatch = this._folderMatchesMap.findSubstr(model.uri);
    folderMatch == null ? void 0 : folderMatch.bindModel(model);
  }
  async onNotebookEditorWidgetAdded(editor, resource) {
    const folderMatch = this._folderMatchesMap.findSubstr(resource);
    await (folderMatch == null ? void 0 : folderMatch.bindNotebookEditorWidget(editor, resource));
  }
  onNotebookEditorWidgetRemoved(editor, resource) {
    const folderMatch = this._folderMatchesMap.findSubstr(resource);
    folderMatch == null ? void 0 : folderMatch.unbindNotebookEditorWidget(editor, resource);
  }
  _createBaseFolderMatch(resource, id, index, query) {
    let folderMatch;
    if (resource) {
      folderMatch = this.instantiationService.createInstance(FolderMatchWorkspaceRoot, resource, id, index, query, this);
    } else {
      folderMatch = this.instantiationService.createInstance(FolderMatchNoRoot, id, index, query, this);
    }
    const disposable = folderMatch.onChange((event) => this._onChange.fire(event));
    folderMatch.onDispose(() => disposable.dispose());
    return folderMatch;
  }
  add(allRaw, searchInstanceID, silent = false) {
    var _a43;
    const { byFolder, other } = this.groupFilesByFolder(allRaw);
    byFolder.forEach((raw) => {
      if (!raw.length) {
        return;
      }
      const folderMatch = this.getFolderMatch(raw[0].resource);
      folderMatch == null ? void 0 : folderMatch.addFileMatch(raw, silent, searchInstanceID);
    });
    (_a43 = this._otherFilesMatch) == null ? void 0 : _a43.addFileMatch(other, silent, searchInstanceID);
    this.disposePastResults();
  }
  clear() {
    this.folderMatches().forEach((folderMatch) => folderMatch.clear(true));
    this.disposeMatches();
    this._folderMatches = [];
    this._otherFilesMatch = null;
  }
  remove(matches) {
    if (!Array.isArray(matches)) {
      matches = [matches];
    }
    matches.forEach((m) => {
      if (m instanceof FolderMatch) {
        m.clear();
      }
    });
    const fileMatches = matches.filter((m) => m instanceof FileMatch);
    const { byFolder, other } = this.groupFilesByFolder(fileMatches);
    byFolder.forEach((matches2) => {
      if (!matches2.length) {
        return;
      }
      this.getFolderMatch(matches2[0].resource).remove(matches2);
    });
    if (other.length) {
      this.getFolderMatch(other[0].resource).remove(other);
    }
  }
  replace(match2) {
    return this.getFolderMatch(match2.resource).replace(match2);
  }
  replaceAll(progress) {
    this.replacingAll = true;
    const promise = this.replaceService.replace(this.matches(), progress);
    return promise.then(() => {
      this.replacingAll = false;
      this.clear();
    }, () => {
      this.replacingAll = false;
    });
  }
  folderMatches() {
    return this._otherFilesMatch ? [
      ...this._folderMatches,
      this._otherFilesMatch
    ] : [
      ...this._folderMatches
    ];
  }
  matches() {
    const matches = [];
    this.folderMatches().forEach((folderMatch) => {
      matches.push(folderMatch.allDownstreamFileMatches());
    });
    return [].concat(...matches);
  }
  isEmpty() {
    return this.folderMatches().every((folderMatch) => folderMatch.isEmpty());
  }
  fileCount() {
    return this.folderMatches().reduce((prev, match2) => prev + match2.recursiveFileCount(), 0);
  }
  count() {
    return this.matches().reduce((prev, match2) => prev + match2.count(), 0);
  }
  get showHighlights() {
    return this._showHighlights;
  }
  toggleHighlights(value) {
    if (this._showHighlights === value) {
      return;
    }
    this._showHighlights = value;
    let selectedMatch = null;
    this.matches().forEach((fileMatch) => {
      fileMatch.updateHighlights();
      fileMatch.updateNotebookHighlights();
      if (!selectedMatch) {
        selectedMatch = fileMatch.getSelectedMatch();
      }
    });
    if (this._showHighlights && selectedMatch) {
      this._rangeHighlightDecorations.highlightRange(selectedMatch.parent().resource, selectedMatch.range());
    } else {
      this._rangeHighlightDecorations.removeHighlightRange();
    }
  }
  get rangeHighlightDecorations() {
    return this._rangeHighlightDecorations;
  }
  getFolderMatch(resource) {
    const folderMatch = this._folderMatchesMap.findSubstr(resource);
    return folderMatch ? folderMatch : this._otherFilesMatch;
  }
  set replacingAll(running) {
    this.folderMatches().forEach((folderMatch) => {
      folderMatch.replacingAll = running;
    });
  }
  groupFilesByFolder(fileMatches) {
    const rawPerFolder = new ResourceMap();
    const otherFileMatches = [];
    this._folderMatches.forEach((fm) => rawPerFolder.set(fm.resource, []));
    fileMatches.forEach((rawFileMatch) => {
      const folderMatch = this.getFolderMatch(rawFileMatch.resource);
      if (!folderMatch) {
        return;
      }
      const resource = folderMatch.resource;
      if (resource) {
        rawPerFolder.get(resource).push(rawFileMatch);
      } else {
        otherFileMatches.push(rawFileMatch);
      }
    });
    return {
      byFolder: rawPerFolder,
      other: otherFileMatches
    };
  }
  disposeMatches() {
    this.folderMatches().forEach((folderMatch) => folderMatch.dispose());
    this._folderMatches = [];
    this._folderMatchesMap = TernarySearchTree.forUris((key) => this.uriIdentityService.extUri.ignorePathCasing(key));
    this._rangeHighlightDecorations.removeHighlightRange();
  }
  dispose() {
    var _a43, _b;
    (_a43 = this._onWillChangeModelListener) == null ? void 0 : _a43.dispose();
    (_b = this._onDidChangeModelListener) == null ? void 0 : _b.dispose();
    this.disposePastResults();
    this.disposeMatches();
    this._rangeHighlightDecorations.dispose();
    super.dispose();
  }
};
SearchResult = __decorate([
  __param(1, IReplaceService),
  __param(2, IInstantiationService),
  __param(3, IModelService),
  __param(4, IUriIdentityService),
  __param(5, INotebookEditorService)
], SearchResult);
var SearchModel = class SearchModel2 extends Disposable {
  constructor(searchService, telemetryService, configurationService, instantiationService, logService, notebookSearchService) {
    super();
    this.searchService = searchService;
    this.telemetryService = telemetryService;
    this.configurationService = configurationService;
    this.instantiationService = instantiationService;
    this.logService = logService;
    this.notebookSearchService = notebookSearchService;
    this._searchQuery = null;
    this._replaceActive = false;
    this._replaceString = null;
    this._replacePattern = null;
    this._preserveCase = false;
    this._startStreamDelay = Promise.resolve();
    this._resultQueue = [];
    this._onReplaceTermChanged = this._register(new Emitter());
    this.onReplaceTermChanged = this._onReplaceTermChanged.event;
    this._onSearchResultChanged = this._register(new PauseableEmitter({
      merge: mergeSearchResultEvents
    }));
    this.onSearchResultChanged = this._onSearchResultChanged.event;
    this.currentCancelTokenSource = null;
    this.searchCancelledForNewSearch = false;
    this._searchResult = this.instantiationService.createInstance(SearchResult, this);
    this._searchResultChangedListener = this._register(this._searchResult.onChange((e) => this._onSearchResultChanged.fire(e)));
  }
  isReplaceActive() {
    return this._replaceActive;
  }
  set replaceActive(replaceActive) {
    this._replaceActive = replaceActive;
  }
  get replacePattern() {
    return this._replacePattern;
  }
  get replaceString() {
    return this._replaceString || "";
  }
  set preserveCase(value) {
    this._preserveCase = value;
  }
  get preserveCase() {
    return this._preserveCase;
  }
  set replaceString(replaceString) {
    this._replaceString = replaceString;
    if (this._searchQuery) {
      this._replacePattern = new ReplacePattern(replaceString, this._searchQuery.contentPattern);
    }
    this._onReplaceTermChanged.fire();
  }
  get searchResult() {
    return this._searchResult;
  }
  set searchResult(searchResult) {
    this._searchResult.dispose();
    this._searchResultChangedListener.dispose();
    this._searchResult = searchResult;
    this._searchResult.searchModel = this;
    this._searchResultChangedListener = this._register(this._searchResult.onChange((e) => this._onSearchResultChanged.fire(e)));
  }
  doSearch(query, progressEmitter, searchQuery, searchInstanceID, onProgress, callerToken) {
    const asyncGenerateOnProgress = async (p) => {
      progressEmitter.fire();
      this.onSearchProgress(p, searchInstanceID, false);
      onProgress == null ? void 0 : onProgress(p);
    };
    const syncGenerateOnProgress = (p) => {
      progressEmitter.fire();
      this.onSearchProgress(p, searchInstanceID, true);
      onProgress == null ? void 0 : onProgress(p);
    };
    const tokenSource = this.currentCancelTokenSource = new CancellationTokenSource(callerToken);
    const notebookResult = this.notebookSearchService.notebookSearch(query, tokenSource.token, searchInstanceID, asyncGenerateOnProgress);
    const textResult = this.searchService.textSearchSplitSyncAsync(searchQuery, this.currentCancelTokenSource.token, asyncGenerateOnProgress, notebookResult.openFilesToScan, notebookResult.allScannedFiles);
    const syncResults = textResult.syncResults.results;
    syncResults.forEach((p) => {
      if (p) {
        syncGenerateOnProgress(p);
      }
    });
    const getAsyncResults = async () => {
      const searchStart = Date.now();
      const allClosedEditorResults = await textResult.asyncResults;
      const resolvedNotebookResults = await notebookResult.completeData;
      tokenSource.dispose();
      const searchLength = Date.now() - searchStart;
      const resolvedResult = {
        results: [...allClosedEditorResults.results, ...resolvedNotebookResults.results],
        messages: [...allClosedEditorResults.messages, ...resolvedNotebookResults.messages],
        limitHit: allClosedEditorResults.limitHit || resolvedNotebookResults.limitHit,
        exit: allClosedEditorResults.exit,
        stats: allClosedEditorResults.stats
      };
      this.logService.trace(`whole search time | ${searchLength}ms`);
      return resolvedResult;
    };
    return {
      asyncResults: getAsyncResults(),
      syncResults
    };
  }
  search(query, onProgress, callerToken) {
    this.cancelSearch(true);
    this._searchQuery = query;
    if (!this.searchConfig.searchOnType) {
      this.searchResult.clear();
    }
    const searchInstanceID = Date.now().toString();
    this._searchResult.query = this._searchQuery;
    const progressEmitter = new Emitter();
    this._replacePattern = new ReplacePattern(this.replaceString, this._searchQuery.contentPattern);
    this._startStreamDelay = new Promise((resolve) => setTimeout(resolve, this.searchConfig.searchOnType ? 150 : 0));
    const req = this.doSearch(query, progressEmitter, this._searchQuery, searchInstanceID, onProgress, callerToken);
    const asyncResults = req.asyncResults;
    const syncResults = req.syncResults;
    if (onProgress) {
      syncResults.forEach((p) => {
        if (p) {
          onProgress(p);
        }
      });
    }
    const start = Date.now();
    Promise.race([asyncResults, Event.toPromise(progressEmitter.event)]).finally(() => {
      this.telemetryService.publicLog("searchResultsFirstRender", { duration: Date.now() - start });
    });
    try {
      return {
        asyncResults: asyncResults.then((value) => {
          this.onSearchCompleted(value, Date.now() - start, searchInstanceID);
          return value;
        }, (e) => {
          this.onSearchError(e, Date.now() - start);
          throw e;
        }),
        syncResults
      };
    } finally {
      this.telemetryService.publicLog("searchResultsFinished", { duration: Date.now() - start });
    }
  }
  onSearchCompleted(completed, duration, searchInstanceID) {
    if (!this._searchQuery) {
      throw new Error("onSearchCompleted must be called after a search is started");
    }
    this._searchResult.add(this._resultQueue, searchInstanceID);
    this._resultQueue.length = 0;
    const options = Object.assign({}, this._searchQuery.contentPattern);
    delete options.pattern;
    const stats = completed && completed.stats;
    const fileSchemeOnly = this._searchQuery.folderQueries.every((fq) => fq.folder.scheme === Schemas.file);
    const otherSchemeOnly = this._searchQuery.folderQueries.every((fq) => fq.folder.scheme !== Schemas.file);
    const scheme = fileSchemeOnly ? Schemas.file : otherSchemeOnly ? "other" : "mixed";
    this.telemetryService.publicLog("searchResultsShown", {
      count: this._searchResult.count(),
      fileCount: this._searchResult.fileCount(),
      options,
      duration,
      type: stats && stats.type,
      scheme,
      searchOnTypeEnabled: this.searchConfig.searchOnType
    });
    return completed;
  }
  onSearchError(e, duration) {
    if (isCancellationError(e)) {
      this.onSearchCompleted(this.searchCancelledForNewSearch ? { exit: 1, results: [], messages: [] } : null, duration, "");
      this.searchCancelledForNewSearch = false;
    }
  }
  onSearchProgress(p, searchInstanceID, sync = true) {
    if (p.resource) {
      this._resultQueue.push(p);
      if (sync) {
        if (this._resultQueue.length) {
          this._searchResult.add(this._resultQueue, searchInstanceID, true);
          this._resultQueue.length = 0;
        }
      } else {
        this._startStreamDelay.then(() => {
          if (this._resultQueue.length) {
            this._searchResult.add(this._resultQueue, searchInstanceID, true);
            this._resultQueue.length = 0;
          }
        });
      }
    }
  }
  get searchConfig() {
    return this.configurationService.getValue("search");
  }
  cancelSearch(cancelledForNewSearch = false) {
    if (this.currentCancelTokenSource) {
      this.searchCancelledForNewSearch = cancelledForNewSearch;
      this.currentCancelTokenSource.cancel();
      return true;
    }
    return false;
  }
  dispose() {
    this.cancelSearch();
    this.searchResult.dispose();
    super.dispose();
  }
  transferSearchResult(other) {
    other.searchResult = this._searchResult;
    this._searchResult = this.instantiationService.createInstance(SearchResult, this);
  }
};
SearchModel = __decorate([
  __param(0, ISearchService),
  __param(1, ITelemetryService),
  __param(2, IConfigurationService),
  __param(3, IInstantiationService),
  __param(4, ILogService),
  __param(5, INotebookSearchService)
], SearchModel);
var SearchViewModelWorkbenchService = class SearchViewModelWorkbenchService2 {
  constructor(instantiationService) {
    this.instantiationService = instantiationService;
    this._searchModel = null;
  }
  get searchModel() {
    if (!this._searchModel) {
      this._searchModel = this.instantiationService.createInstance(SearchModel);
    }
    return this._searchModel;
  }
};
SearchViewModelWorkbenchService = __decorate([
  __param(0, IInstantiationService)
], SearchViewModelWorkbenchService);
var ISearchViewModelWorkbenchService = createDecorator("searchViewModelWorkbenchService");
var _a19;
var RangeHighlightDecorations = (_a19 = class {
  constructor(_modelService) {
    this._modelService = _modelService;
    this._decorationId = null;
    this._model = null;
    this._modelDisposables = new DisposableStore();
  }
  removeHighlightRange() {
    if (this._model && this._decorationId) {
      const decorationId = this._decorationId;
      this._model.changeDecorations((accessor) => {
        accessor.removeDecoration(decorationId);
      });
    }
    this._decorationId = null;
  }
  highlightRange(resource, range, ownerId = 0) {
    let model;
    if (URI.isUri(resource)) {
      model = this._modelService.getModel(resource);
    } else {
      model = resource;
    }
    if (model) {
      this.doHighlightRange(model, range);
    }
  }
  doHighlightRange(model, range) {
    this.removeHighlightRange();
    model.changeDecorations((accessor) => {
      this._decorationId = accessor.addDecoration(range, RangeHighlightDecorations_1._RANGE_HIGHLIGHT_DECORATION);
    });
    this.setModel(model);
  }
  setModel(model) {
    if (this._model !== model) {
      this.clearModelListeners();
      this._model = model;
      this._modelDisposables.add(this._model.onDidChangeDecorations((e) => {
        this.clearModelListeners();
        this.removeHighlightRange();
        this._model = null;
      }));
      this._modelDisposables.add(this._model.onWillDispose(() => {
        this.clearModelListeners();
        this.removeHighlightRange();
        this._model = null;
      }));
    }
  }
  clearModelListeners() {
    this._modelDisposables.clear();
  }
  dispose() {
    if (this._model) {
      this.removeHighlightRange();
      this._modelDisposables.dispose();
      this._model = null;
    }
  }
}, RangeHighlightDecorations_1 = _a19, _a19._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
  description: "search-range-highlight",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: true
}), _a19);
RangeHighlightDecorations = RangeHighlightDecorations_1 = __decorate([
  __param(0, IModelService)
], RangeHighlightDecorations);
function textSearchResultToMatches(rawMatch, fileMatch) {
  const previewLines = rawMatch.preview.text.split("\n");
  if (Array.isArray(rawMatch.ranges)) {
    return rawMatch.ranges.map((r, i) => {
      const previewRange = rawMatch.preview.matches[i];
      return new Match(fileMatch, previewLines, previewRange, r);
    });
  } else {
    const previewRange = rawMatch.preview.matches;
    const match2 = new Match(fileMatch, previewLines, previewRange, rawMatch.ranges);
    return [match2];
  }
}
function textSearchMatchesToNotebookMatches(textSearchMatches, cell) {
  const notebookMatches = [];
  return notebookMatches;
}
function arrayContainsElementOrParent(element, testArray) {
  do {
    if (testArray.includes(element)) {
      return true;
    }
  } while (!(element.parent() instanceof SearchResult) && (element = element.parent()));
  return false;
}
function getFileMatches(matches) {
  const folderMatches = [];
  const fileMatches = [];
  matches.forEach((e) => {
    if (e instanceof FileMatch) {
      fileMatches.push(e);
    } else {
      folderMatches.push(e);
    }
  });
  return fileMatches.concat(folderMatches.map((e) => e.allDownstreamFileMatches()).flat());
}
function mergeSearchResultEvents(events) {
  const retEvent = {
    elements: [],
    added: false,
    removed: false
  };
  events.forEach((e) => {
    if (e.added) {
      retEvent.added = true;
    }
    if (e.removed) {
      retEvent.removed = true;
    }
    retEvent.elements = retEvent.elements.concat(e.elements);
  });
  return retEvent;
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookEditorModelResolverService.js
init_instantiation();
var INotebookEditorModelResolverService = createDecorator("INotebookModelResolverService");

// node_modules/vscode/vscode/src/vs/workbench/services/workingCopy/common/workingCopyEditorService.js
init_tslib_es6();
init_event();
init_instantiation();
init_lifecycle();
var IWorkingCopyEditorService = createDecorator("workingCopyEditorService");
var WorkingCopyEditorService = class WorkingCopyEditorService2 extends Disposable {
  constructor(editorService) {
    super();
    this.editorService = editorService;
    this._onDidRegisterHandler = this._register(new Emitter());
    this.onDidRegisterHandler = this._onDidRegisterHandler.event;
    this.handlers = /* @__PURE__ */ new Set();
  }
  registerHandler(handler) {
    this.handlers.add(handler);
    this._onDidRegisterHandler.fire(handler);
    return toDisposable(() => this.handlers.delete(handler));
  }
  findEditor(workingCopy) {
    for (const editorIdentifier of this.editorService.getEditors(0)) {
      if (this.isOpen(workingCopy, editorIdentifier.editor)) {
        return editorIdentifier;
      }
    }
    return void 0;
  }
  isOpen(workingCopy, editor) {
    for (const handler of this.handlers) {
      if (handler.isOpen(workingCopy, editor)) {
        return true;
      }
    }
    return false;
  }
};
WorkingCopyEditorService = __decorate([
  __param(0, IEditorService)
], WorkingCopyEditorService);

// node_modules/vscode/vscode/src/vs/workbench/services/userActivity/common/userActivityService.js
init_tslib_es6();
init_async();
init_event();
init_lifecycle();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/services/userActivity/common/userActivityRegistry.js
var UserActivityRegistry = class {
  constructor() {
    this.todo = [];
    this.add = (ctor) => {
      this.todo.push(ctor);
    };
  }
  take(userActivityService, instantiation) {
    this.add = (ctor) => instantiation.createInstance(ctor, userActivityService);
    this.todo.forEach(this.add);
    this.todo = [];
  }
};
var userActivityRegistry = new UserActivityRegistry();

// node_modules/vscode/vscode/src/vs/workbench/services/userActivity/common/userActivityService.js
var IUserActivityService = createDecorator("IUserActivityService");
var UserActivityService = class UserActivityService2 extends Disposable {
  constructor(instantiationService) {
    super();
    this.markInactive = this._register(new RunOnceScheduler(() => {
      this.isActive = false;
      this.changeEmitter.fire(false);
    }, 1e4));
    this.changeEmitter = this._register(new Emitter());
    this.active = 0;
    this.isActive = true;
    this.onDidChangeIsActive = this.changeEmitter.event;
    this._register(runWhenIdle(() => userActivityRegistry.take(this, instantiationService)));
  }
  markActive() {
    if (++this.active === 1) {
      this.isActive = true;
      this.changeEmitter.fire(true);
      this.markInactive.cancel();
    }
    return toDisposable(() => {
      if (--this.active === 0) {
        this.markInactive.schedule();
      }
    });
  }
};
UserActivityService = __decorate([
  __param(0, IInstantiationService)
], UserActivityService);

// node_modules/vscode/vscode/src/vs/workbench/services/workspaces/common/canonicalUriService.js
var CanonicalUriService = class {
  constructor() {
    this._providers = /* @__PURE__ */ new Map();
  }
  registerCanonicalUriProvider(provider) {
    this._providers.set(provider.scheme, provider);
    return {
      dispose: () => this._providers.delete(provider.scheme)
    };
  }
  async provideCanonicalUri(uri, targetScheme, token) {
    const provider = this._providers.get(uri.scheme);
    if (provider) {
      return provider.provideCanonicalUri(uri, targetScheme, token);
    }
    return void 0;
  }
};

// node_modules/vscode/vscode/src/vs/platform/workspace/common/canonicalUri.js
init_instantiation();
var ICanonicalUriService = createDecorator("canonicalUriIdentityService");

// node_modules/vscode/vscode/src/vs/workbench/api/browser/statusBarExtensionPoint.js
init_tslib_es6();
init_lifecycle();
init_instantiation();
init_iconLabels();
init_hash();
init_event();
init_extensions2();

// node_modules/vscode/vscode/src/vs/workbench/common/theme.js
init_nls();
init_colorRegistry();
init_color();
init_theme();
var TAB_ACTIVE_BACKGROUND = registerColor("tab.activeBackground", {
  dark: editorBackground,
  light: editorBackground,
  hcDark: editorBackground,
  hcLight: editorBackground
}, localize(
  "tabActiveBackground",
  "Active tab background color in an active group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_ACTIVE_BACKGROUND = registerColor("tab.unfocusedActiveBackground", {
  dark: TAB_ACTIVE_BACKGROUND,
  light: TAB_ACTIVE_BACKGROUND,
  hcDark: TAB_ACTIVE_BACKGROUND,
  hcLight: TAB_ACTIVE_BACKGROUND
}, localize(
  "tabUnfocusedActiveBackground",
  "Active tab background color in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_INACTIVE_BACKGROUND = registerColor("tab.inactiveBackground", {
  dark: "#2D2D2D",
  light: "#ECECEC",
  hcDark: null,
  hcLight: null
}, localize(
  "tabInactiveBackground",
  "Inactive tab background color in an active group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_INACTIVE_BACKGROUND = registerColor("tab.unfocusedInactiveBackground", {
  dark: TAB_INACTIVE_BACKGROUND,
  light: TAB_INACTIVE_BACKGROUND,
  hcDark: TAB_INACTIVE_BACKGROUND,
  hcLight: TAB_INACTIVE_BACKGROUND
}, localize(
  "tabUnfocusedInactiveBackground",
  "Inactive tab background color in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_ACTIVE_FOREGROUND = registerColor("tab.activeForeground", {
  dark: Color.white,
  light: "#333333",
  hcDark: Color.white,
  hcLight: "#292929"
}, localize(
  "tabActiveForeground",
  "Active tab foreground color in an active group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_INACTIVE_FOREGROUND = registerColor("tab.inactiveForeground", {
  dark: transparent(TAB_ACTIVE_FOREGROUND, 0.5),
  light: transparent(TAB_ACTIVE_FOREGROUND, 0.7),
  hcDark: Color.white,
  hcLight: "#292929"
}, localize(
  "tabInactiveForeground",
  "Inactive tab foreground color in an active group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_ACTIVE_FOREGROUND = registerColor("tab.unfocusedActiveForeground", {
  dark: transparent(TAB_ACTIVE_FOREGROUND, 0.5),
  light: transparent(TAB_ACTIVE_FOREGROUND, 0.7),
  hcDark: Color.white,
  hcLight: "#292929"
}, localize(
  "tabUnfocusedActiveForeground",
  "Active tab foreground color in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_INACTIVE_FOREGROUND = registerColor("tab.unfocusedInactiveForeground", {
  dark: transparent(TAB_INACTIVE_FOREGROUND, 0.5),
  light: transparent(TAB_INACTIVE_FOREGROUND, 0.5),
  hcDark: Color.white,
  hcLight: "#292929"
}, localize(
  "tabUnfocusedInactiveForeground",
  "Inactive tab foreground color in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_HOVER_BACKGROUND = registerColor("tab.hoverBackground", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "tabHoverBackground",
  "Tab background color when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_HOVER_BACKGROUND = registerColor("tab.unfocusedHoverBackground", {
  dark: transparent(TAB_HOVER_BACKGROUND, 0.5),
  light: transparent(TAB_HOVER_BACKGROUND, 0.7),
  hcDark: null,
  hcLight: null
}, localize(
  "tabUnfocusedHoverBackground",
  "Tab background color in an unfocused group when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_HOVER_FOREGROUND = registerColor("tab.hoverForeground", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "tabHoverForeground",
  "Tab foreground color when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_HOVER_FOREGROUND = registerColor("tab.unfocusedHoverForeground", {
  dark: transparent(TAB_HOVER_FOREGROUND, 0.5),
  light: transparent(TAB_HOVER_FOREGROUND, 0.5),
  hcDark: null,
  hcLight: null
}, localize(
  "tabUnfocusedHoverForeground",
  "Tab foreground color in an unfocused group when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_BORDER = registerColor("tab.border", {
  dark: "#252526",
  light: "#F3F3F3",
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "tabBorder",
  "Border to separate tabs from each other. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_LAST_PINNED_BORDER = registerColor("tab.lastPinnedBorder", {
  dark: treeIndentGuidesStroke,
  light: treeIndentGuidesStroke,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "lastPinnedTabBorder",
  "Border to separate pinned tabs from other tabs. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_ACTIVE_BORDER = registerColor("tab.activeBorder", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "tabActiveBorder",
  "Border on the bottom of an active tab. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_ACTIVE_BORDER = registerColor("tab.unfocusedActiveBorder", {
  dark: transparent(TAB_ACTIVE_BORDER, 0.5),
  light: transparent(TAB_ACTIVE_BORDER, 0.7),
  hcDark: null,
  hcLight: null
}, localize(
  "tabActiveUnfocusedBorder",
  "Border on the bottom of an active tab in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_ACTIVE_BORDER_TOP = registerColor("tab.activeBorderTop", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: "#B5200D"
}, localize(
  "tabActiveBorderTop",
  "Border to the top of an active tab. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_ACTIVE_BORDER_TOP = registerColor("tab.unfocusedActiveBorderTop", {
  dark: transparent(TAB_ACTIVE_BORDER_TOP, 0.5),
  light: transparent(TAB_ACTIVE_BORDER_TOP, 0.7),
  hcDark: null,
  hcLight: "#B5200D"
}, localize(
  "tabActiveUnfocusedBorderTop",
  "Border to the top of an active tab in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_HOVER_BORDER = registerColor("tab.hoverBorder", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "tabHoverBorder",
  "Border to highlight tabs when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_HOVER_BORDER = registerColor("tab.unfocusedHoverBorder", {
  dark: transparent(TAB_HOVER_BORDER, 0.5),
  light: transparent(TAB_HOVER_BORDER, 0.7),
  hcDark: null,
  hcLight: contrastBorder
}, localize(
  "tabUnfocusedHoverBorder",
  "Border to highlight tabs in an unfocused group when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_ACTIVE_MODIFIED_BORDER = registerColor("tab.activeModifiedBorder", {
  dark: "#3399CC",
  light: "#33AAEE",
  hcDark: null,
  hcLight: contrastBorder
}, localize(
  "tabActiveModifiedBorder",
  "Border on the top of modified active tabs in an active group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_INACTIVE_MODIFIED_BORDER = registerColor("tab.inactiveModifiedBorder", {
  dark: transparent(TAB_ACTIVE_MODIFIED_BORDER, 0.5),
  light: transparent(TAB_ACTIVE_MODIFIED_BORDER, 0.5),
  hcDark: Color.white,
  hcLight: contrastBorder
}, localize(
  "tabInactiveModifiedBorder",
  "Border on the top of modified inactive tabs in an active group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_ACTIVE_MODIFIED_BORDER = registerColor("tab.unfocusedActiveModifiedBorder", {
  dark: transparent(TAB_ACTIVE_MODIFIED_BORDER, 0.5),
  light: transparent(TAB_ACTIVE_MODIFIED_BORDER, 0.7),
  hcDark: Color.white,
  hcLight: contrastBorder
}, localize(
  "unfocusedActiveModifiedBorder",
  "Border on the top of modified active tabs in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var TAB_UNFOCUSED_INACTIVE_MODIFIED_BORDER = registerColor("tab.unfocusedInactiveModifiedBorder", {
  dark: transparent(TAB_INACTIVE_MODIFIED_BORDER, 0.5),
  light: transparent(TAB_INACTIVE_MODIFIED_BORDER, 0.5),
  hcDark: Color.white,
  hcLight: contrastBorder
}, localize(
  "unfocusedINactiveModifiedBorder",
  "Border on the top of modified inactive tabs in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."
));
var EDITOR_PANE_BACKGROUND = registerColor("editorPane.background", {
  dark: editorBackground,
  light: editorBackground,
  hcDark: editorBackground,
  hcLight: editorBackground
}, localize(
  "editorPaneBackground",
  "Background color of the editor pane visible on the left and right side of the centered editor layout."
));
var EDITOR_GROUP_EMPTY_BACKGROUND = registerColor("editorGroup.emptyBackground", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "editorGroupEmptyBackground",
  "Background color of an empty editor group. Editor groups are the containers of editors."
));
registerColor("editorGroup.focusedEmptyBorder", {
  dark: null,
  light: null,
  hcDark: focusBorder,
  hcLight: focusBorder
}, localize(
  "editorGroupFocusedEmptyBorder",
  "Border color of an empty editor group that is focused. Editor groups are the containers of editors."
));
var EDITOR_GROUP_HEADER_TABS_BACKGROUND = registerColor("editorGroupHeader.tabsBackground", {
  dark: "#252526",
  light: "#F3F3F3",
  hcDark: null,
  hcLight: null
}, localize(
  "tabsContainerBackground",
  "Background color of the editor group title header when tabs are enabled. Editor groups are the containers of editors."
));
var EDITOR_GROUP_HEADER_TABS_BORDER = registerColor("editorGroupHeader.tabsBorder", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "tabsContainerBorder",
  "Border color of the editor group title header when tabs are enabled. Editor groups are the containers of editors."
));
var EDITOR_GROUP_HEADER_NO_TABS_BACKGROUND = registerColor("editorGroupHeader.noTabsBackground", {
  dark: editorBackground,
  light: editorBackground,
  hcDark: editorBackground,
  hcLight: editorBackground
}, localize(
  "editorGroupHeaderBackground",
  'Background color of the editor group title header when tabs are disabled (`"workbench.editor.showTabs": false`). Editor groups are the containers of editors.'
));
var EDITOR_GROUP_HEADER_BORDER = registerColor("editorGroupHeader.border", {
  dark: null,
  light: null,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "editorTitleContainerBorder",
  "Border color of the editor group title header. Editor groups are the containers of editors."
));
var EDITOR_GROUP_BORDER = registerColor("editorGroup.border", {
  dark: "#444444",
  light: "#E7E7E7",
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "editorGroupBorder",
  "Color to separate multiple editor groups from each other. Editor groups are the containers of editors."
));
var EDITOR_DRAG_AND_DROP_BACKGROUND = registerColor("editorGroup.dropBackground", {
  dark: Color.fromHex("#53595D").transparent(0.5),
  light: Color.fromHex("#2677CB").transparent(0.18),
  hcDark: null,
  hcLight: Color.fromHex("#0F4A85").transparent(0.5)
}, localize(
  "editorDragAndDropBackground",
  "Background color when dragging editors around. The color should have transparency so that the editor contents can still shine through."
));
var EDITOR_DROP_INTO_PROMPT_FOREGROUND = registerColor("editorGroup.dropIntoPromptForeground", {
  dark: editorWidgetForeground,
  light: editorWidgetForeground,
  hcDark: editorWidgetForeground,
  hcLight: editorWidgetForeground
}, localize(
  "editorDropIntoPromptForeground",
  "Foreground color of text shown over editors when dragging files. This text informs the user that they can hold shift to drop into the editor."
));
var EDITOR_DROP_INTO_PROMPT_BACKGROUND = registerColor("editorGroup.dropIntoPromptBackground", {
  dark: editorWidgetBackground,
  light: editorWidgetBackground,
  hcDark: editorWidgetBackground,
  hcLight: editorWidgetBackground
}, localize(
  "editorDropIntoPromptBackground",
  "Background color of text shown over editors when dragging files. This text informs the user that they can hold shift to drop into the editor."
));
var EDITOR_DROP_INTO_PROMPT_BORDER = registerColor("editorGroup.dropIntoPromptBorder", {
  dark: null,
  light: null,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "editorDropIntoPromptBorder",
  "Border color of text shown over editors when dragging files. This text informs the user that they can hold shift to drop into the editor."
));
var SIDE_BY_SIDE_EDITOR_HORIZONTAL_BORDER = registerColor("sideBySideEditor.horizontalBorder", {
  dark: EDITOR_GROUP_BORDER,
  light: EDITOR_GROUP_BORDER,
  hcDark: EDITOR_GROUP_BORDER,
  hcLight: EDITOR_GROUP_BORDER
}, localize(
  "sideBySideEditor.horizontalBorder",
  "Color to separate two editors from each other when shown side by side in an editor group from top to bottom."
));
var SIDE_BY_SIDE_EDITOR_VERTICAL_BORDER = registerColor("sideBySideEditor.verticalBorder", {
  dark: EDITOR_GROUP_BORDER,
  light: EDITOR_GROUP_BORDER,
  hcDark: EDITOR_GROUP_BORDER,
  hcLight: EDITOR_GROUP_BORDER
}, localize(
  "sideBySideEditor.verticalBorder",
  "Color to separate two editors from each other when shown side by side in an editor group from left to right."
));
var PANEL_BACKGROUND = registerColor("panel.background", {
  dark: editorBackground,
  light: editorBackground,
  hcDark: editorBackground,
  hcLight: editorBackground
}, localize(
  "panelBackground",
  "Panel background color. Panels are shown below the editor area and contain views like output and integrated terminal."
));
var PANEL_BORDER = registerColor("panel.border", {
  dark: Color.fromHex("#808080").transparent(0.35),
  light: Color.fromHex("#808080").transparent(0.35),
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "panelBorder",
  "Panel border color to separate the panel from the editor. Panels are shown below the editor area and contain views like output and integrated terminal."
));
var PANEL_ACTIVE_TITLE_FOREGROUND = registerColor("panelTitle.activeForeground", {
  dark: "#E7E7E7",
  light: "#424242",
  hcDark: Color.white,
  hcLight: editorForeground
}, localize(
  "panelActiveTitleForeground",
  "Title color for the active panel. Panels are shown below the editor area and contain views like output and integrated terminal."
));
var PANEL_INACTIVE_TITLE_FOREGROUND = registerColor("panelTitle.inactiveForeground", {
  dark: transparent(PANEL_ACTIVE_TITLE_FOREGROUND, 0.6),
  light: transparent(PANEL_ACTIVE_TITLE_FOREGROUND, 0.75),
  hcDark: Color.white,
  hcLight: editorForeground
}, localize(
  "panelInactiveTitleForeground",
  "Title color for the inactive panel. Panels are shown below the editor area and contain views like output and integrated terminal."
));
var PANEL_ACTIVE_TITLE_BORDER = registerColor("panelTitle.activeBorder", {
  dark: PANEL_ACTIVE_TITLE_FOREGROUND,
  light: PANEL_ACTIVE_TITLE_FOREGROUND,
  hcDark: contrastBorder,
  hcLight: "#B5200D"
}, localize(
  "panelActiveTitleBorder",
  "Border color for the active panel title. Panels are shown below the editor area and contain views like output and integrated terminal."
));
registerColor("panelInput.border", {
  dark: inputBorder,
  light: Color.fromHex("#ddd"),
  hcDark: inputBorder,
  hcLight: inputBorder
}, localize("panelInputBorder", "Input box border for inputs in the panel."));
var PANEL_DRAG_AND_DROP_BORDER = registerColor("panel.dropBorder", {
  dark: PANEL_ACTIVE_TITLE_FOREGROUND,
  light: PANEL_ACTIVE_TITLE_FOREGROUND,
  hcDark: PANEL_ACTIVE_TITLE_FOREGROUND,
  hcLight: PANEL_ACTIVE_TITLE_FOREGROUND
}, localize(
  "panelDragAndDropBorder",
  "Drag and drop feedback color for the panel titles. Panels are shown below the editor area and contain views like output and integrated terminal."
));
var PANEL_SECTION_DRAG_AND_DROP_BACKGROUND = registerColor("panelSection.dropBackground", {
  dark: EDITOR_DRAG_AND_DROP_BACKGROUND,
  light: EDITOR_DRAG_AND_DROP_BACKGROUND,
  hcDark: EDITOR_DRAG_AND_DROP_BACKGROUND,
  hcLight: EDITOR_DRAG_AND_DROP_BACKGROUND
}, localize(
  "panelSectionDragAndDropBackground",
  "Drag and drop feedback color for the panel sections. The color should have transparency so that the panel sections can still shine through. Panels are shown below the editor area and contain views like output and integrated terminal. Panel sections are views nested within the panels."
));
var PANEL_SECTION_HEADER_BACKGROUND = registerColor("panelSectionHeader.background", {
  dark: Color.fromHex("#808080").transparent(0.2),
  light: Color.fromHex("#808080").transparent(0.2),
  hcDark: null,
  hcLight: null
}, localize(
  "panelSectionHeaderBackground",
  "Panel section header background color. Panels are shown below the editor area and contain views like output and integrated terminal. Panel sections are views nested within the panels."
));
var PANEL_SECTION_HEADER_FOREGROUND = registerColor("panelSectionHeader.foreground", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "panelSectionHeaderForeground",
  "Panel section header foreground color. Panels are shown below the editor area and contain views like output and integrated terminal. Panel sections are views nested within the panels."
));
var PANEL_SECTION_HEADER_BORDER = registerColor("panelSectionHeader.border", {
  dark: contrastBorder,
  light: contrastBorder,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "panelSectionHeaderBorder",
  "Panel section header border color used when multiple views are stacked vertically in the panel. Panels are shown below the editor area and contain views like output and integrated terminal. Panel sections are views nested within the panels."
));
var PANEL_SECTION_BORDER = registerColor("panelSection.border", {
  dark: PANEL_BORDER,
  light: PANEL_BORDER,
  hcDark: PANEL_BORDER,
  hcLight: PANEL_BORDER
}, localize(
  "panelSectionBorder",
  "Panel section border color used when multiple views are stacked horizontally in the panel. Panels are shown below the editor area and contain views like output and integrated terminal. Panel sections are views nested within the panels."
));
registerColor("banner.background", {
  dark: listActiveSelectionBackground,
  light: darken(listActiveSelectionBackground, 0.3),
  hcDark: listActiveSelectionBackground,
  hcLight: listActiveSelectionBackground
}, localize(
  "banner.background",
  "Banner background color. The banner is shown under the title bar of the window."
));
registerColor("banner.foreground", {
  dark: listActiveSelectionForeground,
  light: listActiveSelectionForeground,
  hcDark: listActiveSelectionForeground,
  hcLight: listActiveSelectionForeground
}, localize(
  "banner.foreground",
  "Banner foreground color. The banner is shown under the title bar of the window."
));
registerColor("banner.iconForeground", {
  dark: editorInfoForeground,
  light: editorInfoForeground,
  hcDark: editorInfoForeground,
  hcLight: editorInfoForeground
}, localize(
  "banner.iconForeground",
  "Banner icon color. The banner is shown under the title bar of the window."
));
var STATUS_BAR_FOREGROUND = registerColor("statusBar.foreground", {
  dark: "#FFFFFF",
  light: "#FFFFFF",
  hcDark: "#FFFFFF",
  hcLight: editorForeground
}, localize(
  "statusBarForeground",
  "Status bar foreground color when a workspace or folder is opened. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_NO_FOLDER_FOREGROUND = registerColor("statusBar.noFolderForeground", {
  dark: STATUS_BAR_FOREGROUND,
  light: STATUS_BAR_FOREGROUND,
  hcDark: STATUS_BAR_FOREGROUND,
  hcLight: STATUS_BAR_FOREGROUND
}, localize(
  "statusBarNoFolderForeground",
  "Status bar foreground color when no folder is opened. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_BACKGROUND = registerColor("statusBar.background", {
  dark: "#007ACC",
  light: "#007ACC",
  hcDark: null,
  hcLight: null
}, localize(
  "statusBarBackground",
  "Status bar background color when a workspace or folder is opened. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_NO_FOLDER_BACKGROUND = registerColor("statusBar.noFolderBackground", {
  dark: "#68217A",
  light: "#68217A",
  hcDark: null,
  hcLight: null
}, localize(
  "statusBarNoFolderBackground",
  "Status bar background color when no folder is opened. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_BORDER = registerColor("statusBar.border", {
  dark: null,
  light: null,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "statusBarBorder",
  "Status bar border color separating to the sidebar and editor. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_FOCUS_BORDER = registerColor("statusBar.focusBorder", {
  dark: STATUS_BAR_FOREGROUND,
  light: STATUS_BAR_FOREGROUND,
  hcDark: null,
  hcLight: STATUS_BAR_FOREGROUND
}, localize(
  "statusBarFocusBorder",
  "Status bar border color when focused on keyboard navigation. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_NO_FOLDER_BORDER = registerColor("statusBar.noFolderBorder", {
  dark: STATUS_BAR_BORDER,
  light: STATUS_BAR_BORDER,
  hcDark: STATUS_BAR_BORDER,
  hcLight: STATUS_BAR_BORDER
}, localize(
  "statusBarNoFolderBorder",
  "Status bar border color separating to the sidebar and editor when no folder is opened. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.activeBackground", {
  dark: Color.white.transparent(0.18),
  light: Color.white.transparent(0.18),
  hcDark: Color.white.transparent(0.18),
  hcLight: Color.black.transparent(0.18)
}, localize(
  "statusBarItemActiveBackground",
  "Status bar item background color when clicking. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_ITEM_FOCUS_BORDER = registerColor("statusBarItem.focusBorder", {
  dark: STATUS_BAR_FOREGROUND,
  light: STATUS_BAR_FOREGROUND,
  hcDark: null,
  hcLight: activeContrastBorder
}, localize(
  "statusBarItemFocusBorder",
  "Status bar item border color when focused on keyboard navigation. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_ITEM_HOVER_BACKGROUND = registerColor("statusBarItem.hoverBackground", {
  dark: Color.white.transparent(0.12),
  light: Color.white.transparent(0.12),
  hcDark: Color.white.transparent(0.12),
  hcLight: Color.black.transparent(0.12)
}, localize(
  "statusBarItemHoverBackground",
  "Status bar item background color when hovering. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_ITEM_HOVER_FOREGROUND = registerColor("statusBarItem.hoverForeground", {
  dark: STATUS_BAR_FOREGROUND,
  light: STATUS_BAR_FOREGROUND,
  hcDark: STATUS_BAR_FOREGROUND,
  hcLight: STATUS_BAR_FOREGROUND
}, localize(
  "statusBarItemHoverForeground",
  "Status bar item foreground color when hovering. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_ITEM_COMPACT_HOVER_BACKGROUND = registerColor("statusBarItem.compactHoverBackground", {
  dark: Color.white.transparent(0.2),
  light: Color.white.transparent(0.2),
  hcDark: Color.white.transparent(0.2),
  hcLight: Color.black.transparent(0.2)
}, localize(
  "statusBarItemCompactHoverBackground",
  "Status bar item background color when hovering an item that contains two hovers. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.prominentForeground", {
  dark: STATUS_BAR_FOREGROUND,
  light: STATUS_BAR_FOREGROUND,
  hcDark: STATUS_BAR_FOREGROUND,
  hcLight: STATUS_BAR_FOREGROUND
}, localize(
  "statusBarProminentItemForeground",
  "Status bar prominent items foreground color. Prominent items stand out from other status bar entries to indicate importance. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.prominentBackground", {
  dark: Color.black.transparent(0.5),
  light: Color.black.transparent(0.5),
  hcDark: Color.black.transparent(0.5),
  hcLight: Color.black.transparent(0.5)
}, localize(
  "statusBarProminentItemBackground",
  "Status bar prominent items background color. Prominent items stand out from other status bar entries to indicate importance. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.prominentHoverForeground", {
  dark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  light: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcDark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcLight: STATUS_BAR_ITEM_HOVER_FOREGROUND
}, localize(
  "statusBarProminentItemHoverForeground",
  "Status bar prominent items foreground color when hovering. Prominent items stand out from other status bar entries to indicate importance. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.prominentHoverBackground", {
  dark: Color.black.transparent(0.3),
  light: Color.black.transparent(0.3),
  hcDark: Color.black.transparent(0.3),
  hcLight: null
}, localize(
  "statusBarProminentItemHoverBackground",
  "Status bar prominent items background color when hovering. Prominent items stand out from other status bar entries to indicate importance. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_ERROR_ITEM_BACKGROUND = registerColor("statusBarItem.errorBackground", {
  dark: darken(errorForeground, 0.4),
  light: darken(errorForeground, 0.4),
  hcDark: null,
  hcLight: "#B5200D"
}, localize(
  "statusBarErrorItemBackground",
  "Status bar error items background color. Error items stand out from other status bar entries to indicate error conditions. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.errorForeground", {
  dark: Color.white,
  light: Color.white,
  hcDark: Color.white,
  hcLight: Color.white
}, localize(
  "statusBarErrorItemForeground",
  "Status bar error items foreground color. Error items stand out from other status bar entries to indicate error conditions. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.errorHoverForeground", {
  dark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  light: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcDark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcLight: STATUS_BAR_ITEM_HOVER_FOREGROUND
}, localize(
  "statusBarErrorItemHoverForeground",
  "Status bar error items foreground color when hovering. Error items stand out from other status bar entries to indicate error conditions. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.errorHoverBackground", {
  dark: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  light: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  hcDark: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  hcLight: STATUS_BAR_ITEM_HOVER_BACKGROUND
}, localize(
  "statusBarErrorItemHoverBackground",
  "Status bar error items background color when hovering. Error items stand out from other status bar entries to indicate error conditions. The status bar is shown in the bottom of the window."
));
var STATUS_BAR_WARNING_ITEM_BACKGROUND = registerColor("statusBarItem.warningBackground", {
  dark: darken(editorWarningForeground, 0.4),
  light: darken(editorWarningForeground, 0.4),
  hcDark: null,
  hcLight: "#895503"
}, localize(
  "statusBarWarningItemBackground",
  "Status bar warning items background color. Warning items stand out from other status bar entries to indicate warning conditions. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.warningForeground", {
  dark: Color.white,
  light: Color.white,
  hcDark: Color.white,
  hcLight: Color.white
}, localize(
  "statusBarWarningItemForeground",
  "Status bar warning items foreground color. Warning items stand out from other status bar entries to indicate warning conditions. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.warningHoverForeground", {
  dark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  light: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcDark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcLight: STATUS_BAR_ITEM_HOVER_FOREGROUND
}, localize(
  "statusBarWarningItemHoverForeground",
  "Status bar warning items foreground color when hovering. Warning items stand out from other status bar entries to indicate warning conditions. The status bar is shown in the bottom of the window."
));
registerColor("statusBarItem.warningHoverBackground", {
  dark: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  light: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  hcDark: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  hcLight: STATUS_BAR_ITEM_HOVER_BACKGROUND
}, localize(
  "statusBarWarningItemHoverBackground",
  "Status bar warning items background color when hovering. Warning items stand out from other status bar entries to indicate warning conditions. The status bar is shown in the bottom of the window."
));
var ACTIVITY_BAR_BACKGROUND = registerColor("activityBar.background", {
  dark: "#333333",
  light: "#2C2C2C",
  hcDark: "#000000",
  hcLight: "#FFFFFF"
}, localize(
  "activityBarBackground",
  "Activity bar background color. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
var ACTIVITY_BAR_FOREGROUND = registerColor("activityBar.foreground", {
  dark: Color.white,
  light: Color.white,
  hcDark: Color.white,
  hcLight: editorForeground
}, localize(
  "activityBarForeground",
  "Activity bar item foreground color when it is active. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
var ACTIVITY_BAR_INACTIVE_FOREGROUND = registerColor("activityBar.inactiveForeground", {
  dark: transparent(ACTIVITY_BAR_FOREGROUND, 0.4),
  light: transparent(ACTIVITY_BAR_FOREGROUND, 0.4),
  hcDark: Color.white,
  hcLight: editorForeground
}, localize(
  "activityBarInActiveForeground",
  "Activity bar item foreground color when it is inactive. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
var ACTIVITY_BAR_BORDER = registerColor("activityBar.border", {
  dark: null,
  light: null,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "activityBarBorder",
  "Activity bar border color separating to the side bar. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
var ACTIVITY_BAR_ACTIVE_BORDER = registerColor("activityBar.activeBorder", {
  dark: ACTIVITY_BAR_FOREGROUND,
  light: ACTIVITY_BAR_FOREGROUND,
  hcDark: null,
  hcLight: contrastBorder
}, localize(
  "activityBarActiveBorder",
  "Activity bar border color for the active item. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
var ACTIVITY_BAR_ACTIVE_FOCUS_BORDER = registerColor("activityBar.activeFocusBorder", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: "#B5200D"
}, localize(
  "activityBarActiveFocusBorder",
  "Activity bar focus border color for the active item. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
var ACTIVITY_BAR_ACTIVE_BACKGROUND = registerColor("activityBar.activeBackground", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "activityBarActiveBackground",
  "Activity bar background color for the active item. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
var ACTIVITY_BAR_DRAG_AND_DROP_BORDER = registerColor("activityBar.dropBorder", {
  dark: ACTIVITY_BAR_FOREGROUND,
  light: ACTIVITY_BAR_FOREGROUND,
  hcDark: null,
  hcLight: null
}, localize(
  "activityBarDragAndDropBorder",
  "Drag and drop feedback color for the activity bar items. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
var ACTIVITY_BAR_BADGE_BACKGROUND = registerColor("activityBarBadge.background", {
  dark: "#007ACC",
  light: "#007ACC",
  hcDark: "#000000",
  hcLight: "#0F4A85"
}, localize(
  "activityBarBadgeBackground",
  "Activity notification badge background color. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
var ACTIVITY_BAR_BADGE_FOREGROUND = registerColor("activityBarBadge.foreground", {
  dark: Color.white,
  light: Color.white,
  hcDark: Color.white,
  hcLight: Color.white
}, localize(
  "activityBarBadgeForeground",
  "Activity notification badge foreground color. The activity bar is showing on the far left or right and allows to switch between views of the side bar."
));
registerColor("profileBadge.background", {
  dark: "#4D4D4D",
  light: "#C4C4C4",
  hcDark: Color.white,
  hcLight: Color.black
}, localize(
  "profileBadgeBackground",
  "Profile badge background color. The profile badge shows on top of the settings gear icon in the activity bar."
));
registerColor("profileBadge.foreground", {
  dark: Color.white,
  light: "#333333",
  hcDark: Color.black,
  hcLight: Color.white
}, localize(
  "profileBadgeForeground",
  "Profile badge foreground color. The profile badge shows on top of the settings gear icon in the activity bar."
));
var STATUS_BAR_REMOTE_ITEM_BACKGROUND = registerColor("statusBarItem.remoteBackground", {
  dark: ACTIVITY_BAR_BADGE_BACKGROUND,
  light: ACTIVITY_BAR_BADGE_BACKGROUND,
  hcDark: ACTIVITY_BAR_BADGE_BACKGROUND,
  hcLight: ACTIVITY_BAR_BADGE_BACKGROUND
}, localize(
  "statusBarItemHostBackground",
  "Background color for the remote indicator on the status bar."
));
var STATUS_BAR_REMOTE_ITEM_FOREGROUND = registerColor("statusBarItem.remoteForeground", {
  dark: ACTIVITY_BAR_BADGE_FOREGROUND,
  light: ACTIVITY_BAR_BADGE_FOREGROUND,
  hcDark: ACTIVITY_BAR_BADGE_FOREGROUND,
  hcLight: ACTIVITY_BAR_BADGE_FOREGROUND
}, localize(
  "statusBarItemHostForeground",
  "Foreground color for the remote indicator on the status bar."
));
registerColor("statusBarItem.remoteHoverForeground", {
  dark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  light: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcDark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcLight: STATUS_BAR_ITEM_HOVER_FOREGROUND
}, localize(
  "statusBarRemoteItemHoverForeground",
  "Foreground color for the remote indicator on the status bar when hovering."
));
registerColor("statusBarItem.remoteHoverBackground", {
  dark: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  light: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  hcDark: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  hcLight: null
}, localize(
  "statusBarRemoteItemHoverBackground",
  "Background color for the remote indicator on the status bar when hovering."
));
registerColor("statusBarItem.offlineBackground", {
  dark: "#6c1717",
  light: "#6c1717",
  hcDark: "#6c1717",
  hcLight: "#6c1717"
}, localize(
  "statusBarItemOfflineBackground",
  "Status bar item background color when the workbench is offline."
));
registerColor("statusBarItem.offlineForeground", {
  dark: STATUS_BAR_REMOTE_ITEM_FOREGROUND,
  light: STATUS_BAR_REMOTE_ITEM_FOREGROUND,
  hcDark: STATUS_BAR_REMOTE_ITEM_FOREGROUND,
  hcLight: STATUS_BAR_REMOTE_ITEM_FOREGROUND
}, localize(
  "statusBarItemOfflineForeground",
  "Status bar item foreground color when the workbench is offline."
));
registerColor("statusBarItem.offlineHoverForeground", {
  dark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  light: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcDark: STATUS_BAR_ITEM_HOVER_FOREGROUND,
  hcLight: STATUS_BAR_ITEM_HOVER_FOREGROUND
}, localize(
  "statusBarOfflineItemHoverForeground",
  "Status bar item foreground hover color when the workbench is offline."
));
registerColor("statusBarItem.offlineHoverBackground", {
  dark: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  light: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  hcDark: STATUS_BAR_ITEM_HOVER_BACKGROUND,
  hcLight: null
}, localize(
  "statusBarOfflineItemHoverBackground",
  "Status bar item background hover color when the workbench is offline."
));
registerColor("extensionBadge.remoteBackground", {
  dark: ACTIVITY_BAR_BADGE_BACKGROUND,
  light: ACTIVITY_BAR_BADGE_BACKGROUND,
  hcDark: ACTIVITY_BAR_BADGE_BACKGROUND,
  hcLight: ACTIVITY_BAR_BADGE_BACKGROUND
}, localize(
  "extensionBadge.remoteBackground",
  "Background color for the remote badge in the extensions view."
));
registerColor("extensionBadge.remoteForeground", {
  dark: ACTIVITY_BAR_BADGE_FOREGROUND,
  light: ACTIVITY_BAR_BADGE_FOREGROUND,
  hcDark: ACTIVITY_BAR_BADGE_FOREGROUND,
  hcLight: ACTIVITY_BAR_BADGE_FOREGROUND
}, localize(
  "extensionBadge.remoteForeground",
  "Foreground color for the remote badge in the extensions view."
));
var SIDE_BAR_BACKGROUND = registerColor("sideBar.background", {
  dark: "#252526",
  light: "#F3F3F3",
  hcDark: "#000000",
  hcLight: "#FFFFFF"
}, localize(
  "sideBarBackground",
  "Side bar background color. The side bar is the container for views like explorer and search."
));
var SIDE_BAR_FOREGROUND = registerColor("sideBar.foreground", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "sideBarForeground",
  "Side bar foreground color. The side bar is the container for views like explorer and search."
));
var SIDE_BAR_BORDER = registerColor("sideBar.border", {
  dark: null,
  light: null,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "sideBarBorder",
  "Side bar border color on the side separating to the editor. The side bar is the container for views like explorer and search."
));
var SIDE_BAR_TITLE_FOREGROUND = registerColor("sideBarTitle.foreground", {
  dark: SIDE_BAR_FOREGROUND,
  light: SIDE_BAR_FOREGROUND,
  hcDark: SIDE_BAR_FOREGROUND,
  hcLight: SIDE_BAR_FOREGROUND
}, localize(
  "sideBarTitleForeground",
  "Side bar title foreground color. The side bar is the container for views like explorer and search."
));
var SIDE_BAR_DRAG_AND_DROP_BACKGROUND = registerColor("sideBar.dropBackground", {
  dark: EDITOR_DRAG_AND_DROP_BACKGROUND,
  light: EDITOR_DRAG_AND_DROP_BACKGROUND,
  hcDark: EDITOR_DRAG_AND_DROP_BACKGROUND,
  hcLight: EDITOR_DRAG_AND_DROP_BACKGROUND
}, localize(
  "sideBarDragAndDropBackground",
  "Drag and drop feedback color for the side bar sections. The color should have transparency so that the side bar sections can still shine through. The side bar is the container for views like explorer and search. Side bar sections are views nested within the side bar."
));
var SIDE_BAR_SECTION_HEADER_BACKGROUND = registerColor("sideBarSectionHeader.background", {
  dark: Color.fromHex("#808080").transparent(0.2),
  light: Color.fromHex("#808080").transparent(0.2),
  hcDark: null,
  hcLight: null
}, localize(
  "sideBarSectionHeaderBackground",
  "Side bar section header background color. The side bar is the container for views like explorer and search. Side bar sections are views nested within the side bar."
));
var SIDE_BAR_SECTION_HEADER_FOREGROUND = registerColor("sideBarSectionHeader.foreground", {
  dark: SIDE_BAR_FOREGROUND,
  light: SIDE_BAR_FOREGROUND,
  hcDark: SIDE_BAR_FOREGROUND,
  hcLight: SIDE_BAR_FOREGROUND
}, localize(
  "sideBarSectionHeaderForeground",
  "Side bar section header foreground color. The side bar is the container for views like explorer and search. Side bar sections are views nested within the side bar."
));
var SIDE_BAR_SECTION_HEADER_BORDER = registerColor("sideBarSectionHeader.border", {
  dark: contrastBorder,
  light: contrastBorder,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "sideBarSectionHeaderBorder",
  "Side bar section header border color. The side bar is the container for views like explorer and search. Side bar sections are views nested within the side bar."
));
var TITLE_BAR_ACTIVE_FOREGROUND = registerColor("titleBar.activeForeground", {
  dark: "#CCCCCC",
  light: "#333333",
  hcDark: "#FFFFFF",
  hcLight: "#292929"
}, localize(
  "titleBarActiveForeground",
  "Title bar foreground when the window is active."
));
var TITLE_BAR_INACTIVE_FOREGROUND = registerColor("titleBar.inactiveForeground", {
  dark: transparent(TITLE_BAR_ACTIVE_FOREGROUND, 0.6),
  light: transparent(TITLE_BAR_ACTIVE_FOREGROUND, 0.6),
  hcDark: null,
  hcLight: "#292929"
}, localize(
  "titleBarInactiveForeground",
  "Title bar foreground when the window is inactive."
));
var TITLE_BAR_ACTIVE_BACKGROUND = registerColor("titleBar.activeBackground", {
  dark: "#3C3C3C",
  light: "#DDDDDD",
  hcDark: "#000000",
  hcLight: "#FFFFFF"
}, localize(
  "titleBarActiveBackground",
  "Title bar background when the window is active."
));
var TITLE_BAR_INACTIVE_BACKGROUND = registerColor("titleBar.inactiveBackground", {
  dark: transparent(TITLE_BAR_ACTIVE_BACKGROUND, 0.6),
  light: transparent(TITLE_BAR_ACTIVE_BACKGROUND, 0.6),
  hcDark: null,
  hcLight: null
}, localize(
  "titleBarInactiveBackground",
  "Title bar background when the window is inactive."
));
var TITLE_BAR_BORDER = registerColor("titleBar.border", {
  dark: null,
  light: null,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize("titleBarBorder", "Title bar border color."));
var MENUBAR_SELECTION_FOREGROUND = registerColor("menubar.selectionForeground", {
  dark: TITLE_BAR_ACTIVE_FOREGROUND,
  light: TITLE_BAR_ACTIVE_FOREGROUND,
  hcDark: TITLE_BAR_ACTIVE_FOREGROUND,
  hcLight: TITLE_BAR_ACTIVE_FOREGROUND
}, localize(
  "menubarSelectionForeground",
  "Foreground color of the selected menu item in the menubar."
));
var MENUBAR_SELECTION_BACKGROUND = registerColor("menubar.selectionBackground", {
  dark: toolbarHoverBackground,
  light: toolbarHoverBackground,
  hcDark: null,
  hcLight: null
}, localize(
  "menubarSelectionBackground",
  "Background color of the selected menu item in the menubar."
));
registerColor("menubar.selectionBorder", {
  dark: null,
  light: null,
  hcDark: activeContrastBorder,
  hcLight: activeContrastBorder
}, localize(
  "menubarSelectionBorder",
  "Border color of the selected menu item in the menubar."
));
var NOTIFICATIONS_CENTER_BORDER = registerColor("notificationCenter.border", {
  dark: widgetBorder,
  light: widgetBorder,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "notificationCenterBorder",
  "Notifications center border color. Notifications slide in from the bottom right of the window."
));
var NOTIFICATIONS_TOAST_BORDER = registerColor("notificationToast.border", {
  dark: widgetBorder,
  light: widgetBorder,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "notificationToastBorder",
  "Notification toast border color. Notifications slide in from the bottom right of the window."
));
registerColor("notifications.foreground", {
  dark: editorWidgetForeground,
  light: editorWidgetForeground,
  hcDark: editorWidgetForeground,
  hcLight: editorWidgetForeground
}, localize(
  "notificationsForeground",
  "Notifications foreground color. Notifications slide in from the bottom right of the window."
));
var NOTIFICATIONS_BACKGROUND = registerColor("notifications.background", {
  dark: editorWidgetBackground,
  light: editorWidgetBackground,
  hcDark: editorWidgetBackground,
  hcLight: editorWidgetBackground
}, localize(
  "notificationsBackground",
  "Notifications background color. Notifications slide in from the bottom right of the window."
));
registerColor("notificationLink.foreground", {
  dark: textLinkForeground,
  light: textLinkForeground,
  hcDark: textLinkForeground,
  hcLight: textLinkForeground
}, localize(
  "notificationsLink",
  "Notification links foreground color. Notifications slide in from the bottom right of the window."
));
var NOTIFICATIONS_CENTER_HEADER_FOREGROUND = registerColor("notificationCenterHeader.foreground", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, localize(
  "notificationCenterHeaderForeground",
  "Notifications center header foreground color. Notifications slide in from the bottom right of the window."
));
var NOTIFICATIONS_CENTER_HEADER_BACKGROUND = registerColor("notificationCenterHeader.background", {
  dark: lighten(NOTIFICATIONS_BACKGROUND, 0.3),
  light: darken(NOTIFICATIONS_BACKGROUND, 0.05),
  hcDark: NOTIFICATIONS_BACKGROUND,
  hcLight: NOTIFICATIONS_BACKGROUND
}, localize(
  "notificationCenterHeaderBackground",
  "Notifications center header background color. Notifications slide in from the bottom right of the window."
));
registerColor("notifications.border", {
  dark: NOTIFICATIONS_CENTER_HEADER_BACKGROUND,
  light: NOTIFICATIONS_CENTER_HEADER_BACKGROUND,
  hcDark: NOTIFICATIONS_CENTER_HEADER_BACKGROUND,
  hcLight: NOTIFICATIONS_CENTER_HEADER_BACKGROUND
}, localize(
  "notificationsBorder",
  "Notifications border color separating from other notifications in the notifications center. Notifications slide in from the bottom right of the window."
));
registerColor("notificationsErrorIcon.foreground", {
  dark: editorErrorForeground,
  light: editorErrorForeground,
  hcDark: editorErrorForeground,
  hcLight: editorErrorForeground
}, localize(
  "notificationsErrorIconForeground",
  "The color used for the icon of error notifications. Notifications slide in from the bottom right of the window."
));
registerColor("notificationsWarningIcon.foreground", {
  dark: editorWarningForeground,
  light: editorWarningForeground,
  hcDark: editorWarningForeground,
  hcLight: editorWarningForeground
}, localize(
  "notificationsWarningIconForeground",
  "The color used for the icon of warning notifications. Notifications slide in from the bottom right of the window."
));
registerColor("notificationsInfoIcon.foreground", {
  dark: editorInfoForeground,
  light: editorInfoForeground,
  hcDark: editorInfoForeground,
  hcLight: editorInfoForeground
}, localize(
  "notificationsInfoIconForeground",
  "The color used for the icon of info notifications. Notifications slide in from the bottom right of the window."
));
registerColor("window.activeBorder", {
  dark: null,
  light: null,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "windowActiveBorder",
  "The color used for the border of the window when it is active. Only supported in the macOS and Linux desktop client when using the custom title bar."
));
registerColor("window.inactiveBorder", {
  dark: null,
  light: null,
  hcDark: contrastBorder,
  hcLight: contrastBorder
}, localize(
  "windowInactiveBorder",
  "The color used for the border of the window when it is inactive. Only supported in the macOS and Linux desktop client when using the custom title bar."
));

// node_modules/vscode/vscode/src/vs/workbench/api/browser/statusBarExtensionPoint.js
var IExtensionStatusBarItemService = createDecorator("IExtensionStatusBarItemService");
var ExtensionStatusBarItemService = class ExtensionStatusBarItemService2 {
  constructor(_statusbarService) {
    this._statusbarService = _statusbarService;
    this._entries = /* @__PURE__ */ new Map();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  dispose() {
    this._entries.forEach((entry) => entry.accessor.dispose());
    this._entries.clear();
    this._onDidChange.dispose();
  }
  setOrUpdateEntry(entryId, id, extensionId, name, text, tooltip, command, color, backgroundColor, alignLeft, priority, accessibilityInformation) {
    let ariaLabel;
    let role = void 0;
    if (accessibilityInformation) {
      ariaLabel = accessibilityInformation.label;
      role = accessibilityInformation.role;
    } else {
      ariaLabel = getCodiconAriaLabel(text);
      if (tooltip) {
        const tooltipString = typeof tooltip === "string" ? tooltip : tooltip.value;
        ariaLabel += `, ${tooltipString}`;
      }
    }
    let kind = void 0;
    switch (backgroundColor == null ? void 0 : backgroundColor.id) {
      case STATUS_BAR_ERROR_ITEM_BACKGROUND:
      case STATUS_BAR_WARNING_ITEM_BACKGROUND:
        kind = backgroundColor.id === STATUS_BAR_ERROR_ITEM_BACKGROUND ? "error" : "warning";
        color = void 0;
        backgroundColor = void 0;
    }
    const entry = { name, text, tooltip, command, color, backgroundColor, ariaLabel, role, kind };
    if (typeof priority === "undefined") {
      priority = 0;
    }
    let alignment = alignLeft ? 0 : 1;
    const existingEntry = this._entries.get(entryId);
    if (existingEntry) {
      alignment = existingEntry.alignment;
      priority = existingEntry.priority;
    }
    if (!existingEntry) {
      let entryPriority;
      if (typeof extensionId === "string") {
        entryPriority = { primary: priority, secondary: hash(extensionId) };
      } else {
        entryPriority = priority;
      }
      const accessor = this._statusbarService.addEntry(entry, id, alignment, entryPriority);
      this._entries.set(entryId, {
        accessor,
        entry,
        alignment,
        priority,
        disposable: toDisposable(() => {
          accessor.dispose();
          this._entries.delete(entryId);
          this._onDidChange.fire({ removed: entryId });
        })
      });
      this._onDidChange.fire({ added: [entryId, { entry, alignment, priority }] });
      return 0;
    } else {
      existingEntry.accessor.update(entry);
      existingEntry.entry = entry;
      return 1;
    }
  }
  unsetEntry(entryId) {
    var _a43;
    (_a43 = this._entries.get(entryId)) == null ? void 0 : _a43.disposable.dispose();
    this._entries.delete(entryId);
  }
  getEntries() {
    return this._entries.entries();
  }
};
ExtensionStatusBarItemService = __decorate([
  __param(0, IStatusbarService)
], ExtensionStatusBarItemService);
registerSingleton(IExtensionStatusBarItemService, ExtensionStatusBarItemService, 1);

// node_modules/vscode/vscode/src/vs/workbench/services/assignment/common/assignmentService.js
init_nls();
init_instantiation();
init_platform2();
init_configurationRegistry();
var IWorkbenchAssignmentService = createDecorator("WorkbenchAssignmentService");
var registry = Registry.as(Extensions2.Configuration);
registry.registerConfiguration({
  ...workbenchConfigurationNodeBase,
  "properties": {
    "workbench.enableExperiments": {
      "type": "boolean",
      "description": localize(
        "workbench.enableExperiments",
        "Fetches experiments to run from a Microsoft online service."
      ),
      "default": true,
      "scope": 1,
      "restricted": true,
      "tags": ["usesOnlineServices"]
    }
  }
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/chat/common/chatService.js
init_instantiation();
var IChatService = createDecorator("IChatService");

// node_modules/vscode/vscode/src/vs/workbench/services/terminal/common/embedderTerminalService.js
init_instantiation();
var IEmbedderTerminalService = createDecorator("embedderTerminalService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/customEditor/common/customEditor.js
init_arrays();
init_nls();
init_contextkey();
init_instantiation();
var ICustomEditorService = createDecorator("customEditorService");
var CONTEXT_ACTIVE_CUSTOM_EDITOR_ID = new RawContextKey("activeCustomEditorId", "", {
  type: "string",
  description: localize(
    "context.customEditor",
    "The viewType of the currently active custom editor."
  )
});
var CONTEXT_FOCUSED_CUSTOM_EDITOR_IS_EDITABLE = new RawContextKey("focusedCustomEditorIsEditable", false);

// node_modules/vscode/vscode/src/vs/workbench/contrib/webviewPanel/browser/webviewWorkbenchService.js
init_tslib_es6();
init_async();
init_cancellation();
init_errors();
init_event();
init_iterator();
init_lifecycle();
init_contextkey();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/contrib/webview/browser/webview.js
init_tslib_es6();
init_arrays();
init_resources();
init_uuid();
init_contextkey();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/common/memento.js
init_types();
init_errors();
var _Memento = class _Memento {
  constructor(id, storageService) {
    this.storageService = storageService;
    this.id = _Memento.COMMON_PREFIX + id;
  }
  getMemento(scope, target) {
    switch (scope) {
      case 1: {
        let workspaceMemento = _Memento.workspaceMementos.get(this.id);
        if (!workspaceMemento) {
          workspaceMemento = new ScopedMemento(this.id, scope, target, this.storageService);
          _Memento.workspaceMementos.set(this.id, workspaceMemento);
        }
        return workspaceMemento.getMemento();
      }
      case 0: {
        let profileMemento = _Memento.profileMementos.get(this.id);
        if (!profileMemento) {
          profileMemento = new ScopedMemento(this.id, scope, target, this.storageService);
          _Memento.profileMementos.set(this.id, profileMemento);
        }
        return profileMemento.getMemento();
      }
      case -1: {
        let applicationMemento = _Memento.applicationMementos.get(this.id);
        if (!applicationMemento) {
          applicationMemento = new ScopedMemento(this.id, scope, target, this.storageService);
          _Memento.applicationMementos.set(this.id, applicationMemento);
        }
        return applicationMemento.getMemento();
      }
    }
  }
  saveMemento() {
    var _a43, _b, _c;
    (_a43 = _Memento.workspaceMementos.get(this.id)) == null ? void 0 : _a43.save();
    (_b = _Memento.profileMementos.get(this.id)) == null ? void 0 : _b.save();
    (_c = _Memento.applicationMementos.get(this.id)) == null ? void 0 : _c.save();
  }
  static clear(scope) {
    switch (scope) {
      case 1:
        _Memento.workspaceMementos.clear();
        break;
      case 0:
        _Memento.profileMementos.clear();
        break;
      case -1:
        _Memento.applicationMementos.clear();
        break;
    }
  }
};
_Memento.applicationMementos = /* @__PURE__ */ new Map();
_Memento.profileMementos = /* @__PURE__ */ new Map();
_Memento.workspaceMementos = /* @__PURE__ */ new Map();
_Memento.COMMON_PREFIX = "memento/";
var Memento = _Memento;
var ScopedMemento = class {
  constructor(id, scope, target, storageService) {
    this.id = id;
    this.scope = scope;
    this.target = target;
    this.storageService = storageService;
    this.mementoObj = this.load();
  }
  getMemento() {
    return this.mementoObj;
  }
  load() {
    const memento = this.storageService.get(this.id, this.scope);
    if (memento) {
      try {
        return JSON.parse(memento);
      } catch (error) {
        onUnexpectedError(`[memento]: failed to parse contents: ${error} (id: ${this.id}, scope: ${this.scope}, contents: ${memento})`);
      }
    }
    return {};
  }
  save() {
    if (!isEmptyObject(this.mementoObj)) {
      this.storageService.store(this.id, JSON.stringify(this.mementoObj), this.scope, this.target);
    } else {
      this.storageService.remove(this.id, this.scope);
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/webview/browser/webview.js
var KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_VISIBLE = new RawContextKey("webviewFindWidgetVisible", false);
var KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_FOCUSED = new RawContextKey("webviewFindWidgetFocused", false);
var KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_ENABLED = new RawContextKey("webviewFindWidgetEnabled", false);
var IWebviewService = createDecorator("webviewService");
var WebviewOriginStore = class WebviewOriginStore2 {
  constructor(rootStorageKey, storageService) {
    this._memento = new Memento(rootStorageKey, storageService);
    this._state = this._memento.getMemento(-1, 1);
  }
  getOrigin(viewType, additionalKey) {
    const key = this._getKey(viewType, additionalKey);
    const existing = this._state[key];
    if (existing && typeof existing === "string") {
      return existing;
    }
    const newOrigin = generateUuid();
    this._state[key] = newOrigin;
    this._memento.saveMemento();
    return newOrigin;
  }
  _getKey(viewType, additionalKey) {
    return JSON.stringify({ viewType, key: additionalKey });
  }
};
WebviewOriginStore = __decorate([
  __param(1, IStorageService)
], WebviewOriginStore);
var ExtensionKeyedWebviewOriginStore = class ExtensionKeyedWebviewOriginStore2 {
  constructor(rootStorageKey, storageService) {
    this._store = new WebviewOriginStore(rootStorageKey, storageService);
  }
  getOrigin(viewType, extId) {
    return this._store.getOrigin(viewType, extId.value);
  }
};
ExtensionKeyedWebviewOriginStore = __decorate([
  __param(1, IStorageService)
], ExtensionKeyedWebviewOriginStore);

// node_modules/vscode/vscode/src/vs/workbench/contrib/webviewPanel/browser/webviewEditor.js
init_tslib_es6();
init_dom();
init_event();
init_lifecycle();
init_platform();
init_uuid();
init_nls();
init_contextkey();
init_telemetry();
init_themeService();

// node_modules/vscode/vscode/src/vs/workbench/browser/composite.js
init_actions();

// node_modules/vscode/vscode/src/vs/workbench/common/component.js
init_themeService();
var Component = class extends Themable {
  constructor(id, themeService, storageService) {
    super(themeService);
    this.id = id;
    this.id = id;
    this.memento = new Memento(this.id, storageService);
    this._register(storageService.onWillSaveState(() => {
      this.saveState();
      this.memento.saveMemento();
    }));
  }
  getId() {
    return this.id;
  }
  getMemento(scope, target) {
    return this.memento.getMemento(scope, target);
  }
  saveState() {
  }
};

// node_modules/vscode/vscode/src/vs/workbench/browser/composite.js
init_event();
init_dom();
init_lifecycle();
init_types();
var Composite = class extends Component {
  get onDidFocus() {
    if (!this._onDidFocus) {
      this._onDidFocus = this.registerFocusTrackEvents().onDidFocus;
    }
    return this._onDidFocus.event;
  }
  fireOnDidFocus() {
    var _a43;
    (_a43 = this._onDidFocus) == null ? void 0 : _a43.fire();
  }
  get onDidBlur() {
    if (!this._onDidBlur) {
      this._onDidBlur = this.registerFocusTrackEvents().onDidBlur;
    }
    return this._onDidBlur.event;
  }
  hasFocus() {
    return this._hasFocus;
  }
  registerFocusTrackEvents() {
    const container = assertIsDefined(this.getContainer());
    const focusTracker = this._register(trackFocus(container));
    const onDidFocus = this._onDidFocus = this._register(new Emitter());
    this._register(focusTracker.onDidFocus(() => {
      this._hasFocus = true;
      onDidFocus.fire();
    }));
    const onDidBlur = this._onDidBlur = this._register(new Emitter());
    this._register(focusTracker.onDidBlur(() => {
      this._hasFocus = false;
      onDidBlur.fire();
    }));
    return { onDidFocus, onDidBlur };
  }
  get telemetryService() {
    return this._telemetryService;
  }
  constructor(id, telemetryService, themeService, storageService) {
    super(id, themeService, storageService);
    this._onTitleAreaUpdate = this._register(new Emitter());
    this.onTitleAreaUpdate = this._onTitleAreaUpdate.event;
    this._hasFocus = false;
    this._telemetryService = telemetryService;
    this.visible = false;
  }
  getTitle() {
    return void 0;
  }
  create(parent) {
    this.parent = parent;
  }
  getContainer() {
    return this.parent;
  }
  setVisible(visible) {
    if (this.visible !== !!visible) {
      this.visible = visible;
    }
  }
  focus() {
  }
  updateStyles() {
    super.updateStyles();
  }
  getMenuIds() {
    return [];
  }
  getActions() {
    return [];
  }
  getSecondaryActions() {
    return [];
  }
  getContextMenuActions() {
    return [];
  }
  getActionViewItem(action) {
    return void 0;
  }
  getActionsContext() {
    return null;
  }
  getActionRunner() {
    if (!this.actionRunner) {
      this.actionRunner = this._register(new ActionRunner());
    }
    return this.actionRunner;
  }
  updateTitleArea() {
    this._onTitleAreaUpdate.fire();
  }
  isVisible() {
    return this.visible;
  }
  getControl() {
    return void 0;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorPane.js
init_map();
init_uri();
init_event();
init_types();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editor.js
init_dom();
init_types();
var DEFAULT_EDITOR_MIN_DIMENSIONS = new Dimension(220, 70);
var DEFAULT_EDITOR_MAX_DIMENSIONS = new Dimension(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorPane.js
init_resources();
init_extpath();
init_lifecycle();
var _EditorPane = class _EditorPane extends Composite {
  get minimumWidth() {
    return DEFAULT_EDITOR_MIN_DIMENSIONS.width;
  }
  get maximumWidth() {
    return DEFAULT_EDITOR_MAX_DIMENSIONS.width;
  }
  get minimumHeight() {
    return DEFAULT_EDITOR_MIN_DIMENSIONS.height;
  }
  get maximumHeight() {
    return DEFAULT_EDITOR_MAX_DIMENSIONS.height;
  }
  get input() {
    return this._input;
  }
  get options() {
    return this._options;
  }
  get group() {
    return this._group;
  }
  get scopedContextKeyService() {
    return void 0;
  }
  constructor(id, telemetryService, themeService, storageService) {
    super(id, telemetryService, themeService, storageService);
    this.onDidChangeSizeConstraints = Event.None;
    this._onDidChangeControl = this._register(new Emitter());
    this.onDidChangeControl = this._onDidChangeControl.event;
  }
  create(parent) {
    super.create(parent);
    this.createEditor(parent);
  }
  async setInput(input, options, context, token) {
    this._input = input;
    this._options = options;
  }
  clearInput() {
    this._input = void 0;
    this._options = void 0;
  }
  setOptions(options) {
    this._options = options;
  }
  setVisible(visible, group) {
    super.setVisible(visible);
    this.setEditorVisible(visible, group);
  }
  setEditorVisible(visible, group) {
    this._group = group;
  }
  setBoundarySashes(_sashes) {
  }
  getEditorMemento(editorGroupService, configurationService, key, limit = 10) {
    const mementoKey = `${this.getId()}${key}`;
    let editorMemento = _EditorPane.EDITOR_MEMENTOS.get(mementoKey);
    if (!editorMemento) {
      editorMemento = this._register(new EditorMemento(
        this.getId(),
        key,
        this.getMemento(1, 1),
        limit,
        editorGroupService,
        configurationService
      ));
      _EditorPane.EDITOR_MEMENTOS.set(mementoKey, editorMemento);
    }
    return editorMemento;
  }
  getViewState() {
    return void 0;
  }
  saveState() {
    for (const [, editorMemento] of _EditorPane.EDITOR_MEMENTOS) {
      if (editorMemento.id === this.getId()) {
        editorMemento.saveState();
      }
    }
    super.saveState();
  }
  dispose() {
    this._input = void 0;
    this._options = void 0;
    super.dispose();
  }
};
_EditorPane.EDITOR_MEMENTOS = /* @__PURE__ */ new Map();
var EditorPane = _EditorPane;
var _EditorMemento = class _EditorMemento extends Disposable {
  constructor(id, key, memento, limit, editorGroupService, configurationService) {
    super();
    this.id = id;
    this.key = key;
    this.memento = memento;
    this.limit = limit;
    this.editorGroupService = editorGroupService;
    this.configurationService = configurationService;
    this.cleanedUp = false;
    this.shareEditorState = false;
    this.updateConfiguration(void 0);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.updateConfiguration(e)));
  }
  updateConfiguration(e) {
    if (!e || e.affectsConfiguration(void 0, "workbench.editor.sharedViewState")) {
      this.shareEditorState = this.configurationService.getValue(void 0, "workbench.editor.sharedViewState") === true;
    }
  }
  saveEditorState(group, resourceOrEditor, state) {
    const resource = this.doGetResource(resourceOrEditor);
    if (!resource || !group) {
      return;
    }
    const cache = this.doLoad();
    let mementosForResource = cache.get(resource.toString());
    if (!mementosForResource) {
      mementosForResource = /* @__PURE__ */ Object.create(null);
      cache.set(resource.toString(), mementosForResource);
    }
    mementosForResource[group.id] = state;
    if (this.shareEditorState) {
      mementosForResource[_EditorMemento.SHARED_EDITOR_STATE] = state;
    }
    if (isEditorInput(resourceOrEditor)) {
      this.clearEditorStateOnDispose(resource, resourceOrEditor);
    }
  }
  loadEditorState(group, resourceOrEditor) {
    const resource = this.doGetResource(resourceOrEditor);
    if (!resource || !group) {
      return;
    }
    const cache = this.doLoad();
    const mementosForResource = cache.get(resource.toString());
    if (mementosForResource) {
      const mementoForResourceAndGroup = mementosForResource[group.id];
      if (mementoForResourceAndGroup) {
        return mementoForResourceAndGroup;
      }
      if (this.shareEditorState) {
        return mementosForResource[_EditorMemento.SHARED_EDITOR_STATE];
      }
    }
    return void 0;
  }
  clearEditorState(resourceOrEditor, group) {
    var _a43;
    if (isEditorInput(resourceOrEditor)) {
      (_a43 = this.editorDisposables) == null ? void 0 : _a43.delete(resourceOrEditor);
    }
    const resource = this.doGetResource(resourceOrEditor);
    if (resource) {
      const cache = this.doLoad();
      if (group) {
        const mementosForResource = cache.get(resource.toString());
        if (mementosForResource) {
          delete mementosForResource[group.id];
          if (isEmptyObject(mementosForResource)) {
            cache.delete(resource.toString());
          }
        }
      } else {
        cache.delete(resource.toString());
      }
    }
  }
  clearEditorStateOnDispose(resource, editor) {
    if (!this.editorDisposables) {
      this.editorDisposables = /* @__PURE__ */ new Map();
    }
    if (!this.editorDisposables.has(editor)) {
      this.editorDisposables.set(editor, Event.once(editor.onWillDispose)(() => {
        var _a43;
        this.clearEditorState(resource);
        (_a43 = this.editorDisposables) == null ? void 0 : _a43.delete(editor);
      }));
    }
  }
  moveEditorState(source, target, comparer) {
    const cache = this.doLoad();
    const cacheKeys = [...cache.keys()];
    for (const cacheKey of cacheKeys) {
      const resource = URI.parse(cacheKey);
      if (!comparer.isEqualOrParent(resource, source)) {
        continue;
      }
      let targetResource;
      if (isEqual2(source, resource)) {
        targetResource = target;
      } else {
        const index = indexOfPath(resource.path, source.path);
        targetResource = joinPath(target, resource.path.substr(index + source.path.length + 1));
      }
      const value = cache.get(cacheKey, 0);
      if (value) {
        cache.delete(cacheKey);
        cache.set(targetResource.toString(), value);
      }
    }
  }
  doGetResource(resourceOrEditor) {
    if (isEditorInput(resourceOrEditor)) {
      return resourceOrEditor.resource;
    }
    return resourceOrEditor;
  }
  doLoad() {
    if (!this.cache) {
      this.cache = new LRUCache(this.limit);
      const rawEditorMemento = this.memento[this.key];
      if (Array.isArray(rawEditorMemento)) {
        this.cache.fromJSON(rawEditorMemento);
      }
    }
    return this.cache;
  }
  saveState() {
    const cache = this.doLoad();
    if (!this.cleanedUp) {
      this.cleanUp();
      this.cleanedUp = true;
    }
    this.memento[this.key] = cache.toJSON();
  }
  cleanUp() {
    const cache = this.doLoad();
    const entries = [...cache.entries()];
    for (const [resource, mapGroupToMementos] of entries) {
      for (const group of Object.keys(mapGroupToMementos)) {
        const groupId = Number(group);
        if (groupId === _EditorMemento.SHARED_EDITOR_STATE && this.shareEditorState) {
          continue;
        }
        if (!this.editorGroupService.getGroup(groupId)) {
          delete mapGroupToMementos[groupId];
          if (isEmptyObject(mapGroupToMementos)) {
            cache.delete(resource);
          }
        }
      }
    }
  }
};
_EditorMemento.SHARED_EDITOR_STATE = -1;
var EditorMemento = _EditorMemento;

// node_modules/vscode/vscode/src/vs/workbench/contrib/webview/browser/webviewWindowDragMonitor.js
init_dom();
init_lifecycle();
var WebviewWindowDragMonitor = class extends Disposable {
  constructor(getWebview) {
    super();
    this._register(addDisposableListener(window, EventType.DRAG_START, () => {
      var _a43;
      (_a43 = getWebview()) == null ? void 0 : _a43.windowDidDragStart();
    }));
    const onDragEnd = () => {
      var _a43;
      (_a43 = getWebview()) == null ? void 0 : _a43.windowDidDragEnd();
    };
    this._register(addDisposableListener(window, EventType.DRAG_END, onDragEnd));
    this._register(addDisposableListener(window, EventType.MOUSE_MOVE, (currentEvent) => {
      if (currentEvent.buttons === 0) {
        onDragEnd();
      }
    }));
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/webviewPanel/browser/webviewEditorInput.js
init_network();
init_uri();
init_uuid();
var _WebviewInput = class _WebviewInput extends EditorInput {
  get typeId() {
    return _WebviewInput.typeId;
  }
  get editorId() {
    return this.viewType;
  }
  get capabilities() {
    return 2 | 8 | 128;
  }
  get resource() {
    return URI.from({
      scheme: Schemas.webviewPanel,
      path: `webview-panel/webview-${this._resourceId}`
    });
  }
  constructor(init, webview, _iconManager) {
    super();
    this._iconManager = _iconManager;
    this._resourceId = generateUuid();
    this._hasTransfered = false;
    this.viewType = init.viewType;
    this.providedId = init.providedId;
    this._name = init.name;
    this._webview = webview;
  }
  dispose() {
    var _a43;
    if (!this.isDisposed()) {
      if (!this._hasTransfered) {
        (_a43 = this._webview) == null ? void 0 : _a43.dispose();
      }
    }
    super.dispose();
  }
  getName() {
    return this._name;
  }
  getTitle(_verbosity) {
    return this.getName();
  }
  getDescription() {
    return void 0;
  }
  setName(value) {
    this._name = value;
    this.webview.setTitle(value);
    this._onDidChangeLabel.fire();
  }
  get webview() {
    return this._webview;
  }
  get extension() {
    return this.webview.extension;
  }
  get iconPath() {
    return this._iconPath;
  }
  set iconPath(value) {
    this._iconPath = value;
    this._iconManager.setIcons(this._resourceId, value);
  }
  matches(other) {
    return super.matches(other) || other === this;
  }
  get group() {
    return this._group;
  }
  updateGroup(group) {
    this._group = group;
  }
  transfer(other) {
    if (this._hasTransfered) {
      return void 0;
    }
    this._hasTransfered = true;
    other._webview = this._webview;
    return other;
  }
};
_WebviewInput.typeId = "workbench.editors.webviewInput";
var WebviewInput = _WebviewInput;

// node_modules/vscode/vscode/src/vs/workbench/services/editor/browser/editorDropService.js
init_instantiation();
var IEditorDropService = createDecorator("editorDropService");

// node_modules/vscode/vscode/src/vs/workbench/services/layout/browser/layoutService.js
init_instantiation();
var IWorkbenchLayoutService = refineServiceDecorator(ILayoutService);
var Parts;
(function(Parts2) {
  Parts2["TITLEBAR_PART"] = "workbench.parts.titlebar";
  Parts2["BANNER_PART"] = "workbench.parts.banner";
  Parts2["ACTIVITYBAR_PART"] = "workbench.parts.activitybar";
  Parts2["SIDEBAR_PART"] = "workbench.parts.sidebar";
  Parts2["PANEL_PART"] = "workbench.parts.panel";
  Parts2["AUXILIARYBAR_PART"] = "workbench.parts.auxiliarybar";
  Parts2["EDITOR_PART"] = "workbench.parts.editor";
  Parts2["STATUSBAR_PART"] = "workbench.parts.statusbar";
})(Parts || (Parts = {}));
function positionToString(position) {
  switch (position) {
    case 0:
      return "left";
    case 1:
      return "right";
    case 2:
      return "bottom";
    default:
      return "bottom";
  }
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/webviewPanel/browser/webviewEditor.js
var WebviewEditor_1;
var CONTEXT_ACTIVE_WEBVIEW_PANEL_ID = new RawContextKey("activeWebviewPanelId", "", {
  type: "string",
  description: localize(
    "context.activeWebviewId",
    "The viewType of the currently active webview panel."
  )
});
var _a20;
var WebviewEditor = (_a20 = class extends EditorPane {
  get onDidFocus() {
    return this._onDidFocusWebview.event;
  }
  constructor(telemetryService, themeService, storageService, editorGroupsService, _editorService, _workbenchLayoutService, _editorDropService, _hostService, _contextKeyService) {
    super(WebviewEditor_1.ID, telemetryService, themeService, storageService);
    this._editorService = _editorService;
    this._workbenchLayoutService = _workbenchLayoutService;
    this._editorDropService = _editorDropService;
    this._hostService = _hostService;
    this._contextKeyService = _contextKeyService;
    this._visible = false;
    this._isDisposed = false;
    this._webviewVisibleDisposables = this._register(new DisposableStore());
    this._onFocusWindowHandler = this._register(new MutableDisposable());
    this._onDidFocusWebview = this._register(new Emitter());
    this._scopedContextKeyService = this._register(new MutableDisposable());
    this._register(Event.any(editorGroupsService.onDidScroll, editorGroupsService.onDidAddGroup, editorGroupsService.onDidRemoveGroup, editorGroupsService.onDidMoveGroup)(() => {
      if (this.webview && this._visible) {
        this.synchronizeWebviewContainerDimensions(this.webview);
      }
    }));
  }
  get webview() {
    return this.input instanceof WebviewInput ? this.input.webview : void 0;
  }
  get scopedContextKeyService() {
    return this._scopedContextKeyService.value;
  }
  createEditor(parent) {
    const element = document.createElement("div");
    this._element = element;
    this._element.id = `webview-editor-element-${generateUuid()}`;
    parent.appendChild(element);
    this._scopedContextKeyService.value = this._contextKeyService.createScoped(element);
  }
  dispose() {
    var _a43;
    this._isDisposed = true;
    (_a43 = this._element) == null ? void 0 : _a43.remove();
    this._element = void 0;
    super.dispose();
  }
  layout(dimension) {
    this._dimension = dimension;
    if (this.webview && this._visible) {
      this.synchronizeWebviewContainerDimensions(this.webview, dimension);
    }
  }
  focus() {
    var _a43;
    super.focus();
    if (!this._onFocusWindowHandler.value && !isWeb) {
      this._onFocusWindowHandler.value = this._hostService.onDidChangeFocus((focused) => {
        if (focused && this._editorService.activeEditorPane === this && this._workbenchLayoutService.hasFocus("workbench.parts.editor")) {
          this.focus();
        }
      });
    }
    (_a43 = this.webview) == null ? void 0 : _a43.focus();
  }
  setEditorVisible(visible, group) {
    this._visible = visible;
    if (this.input instanceof WebviewInput && this.webview) {
      if (visible) {
        this.claimWebview(this.input);
      } else {
        this.webview.release(this);
      }
    }
    super.setEditorVisible(visible, group);
  }
  clearInput() {
    if (this.webview) {
      this.webview.release(this);
      this._webviewVisibleDisposables.clear();
    }
    super.clearInput();
  }
  async setInput(input, options, context, token) {
    if (this.input && input.matches(this.input)) {
      return;
    }
    const alreadyOwnsWebview = input instanceof WebviewInput && input.webview === this.webview;
    if (this.webview && !alreadyOwnsWebview) {
      this.webview.release(this);
    }
    await super.setInput(input, options, context, token);
    await input.resolve(options);
    if (token.isCancellationRequested || this._isDisposed) {
      return;
    }
    if (input instanceof WebviewInput) {
      if (this.group) {
        input.updateGroup(this.group.id);
      }
      if (!alreadyOwnsWebview) {
        this.claimWebview(input);
      }
      if (this._dimension) {
        this.layout(this._dimension);
      }
    }
  }
  claimWebview(input) {
    input.webview.claim(this, this.scopedContextKeyService);
    if (this._element) {
      this._element.setAttribute("aria-flowto", input.webview.container.id);
      setParentFlowTo(input.webview.container, this._element);
    }
    this._webviewVisibleDisposables.clear();
    this._webviewVisibleDisposables.add(this._editorDropService.createEditorDropTarget(input.webview.container, {
      containsGroup: (group) => {
        var _a43;
        return ((_a43 = this.group) == null ? void 0 : _a43.id) === group.id;
      }
    }));
    this._webviewVisibleDisposables.add(new WebviewWindowDragMonitor(() => this.webview));
    this.synchronizeWebviewContainerDimensions(input.webview);
    this._webviewVisibleDisposables.add(this.trackFocus(input.webview));
  }
  synchronizeWebviewContainerDimensions(webview, dimension) {
    var _a43;
    if (!((_a43 = this._element) == null ? void 0 : _a43.isConnected)) {
      return;
    }
    const rootContainer = this._workbenchLayoutService.getContainer("workbench.parts.editor");
    webview.layoutWebviewOverElement(this._element.parentElement, dimension, rootContainer);
  }
  trackFocus(webview) {
    const store = new DisposableStore();
    const webviewContentFocusTracker = trackFocus(webview.container);
    store.add(webviewContentFocusTracker);
    store.add(webviewContentFocusTracker.onDidFocus(() => this._onDidFocusWebview.fire()));
    store.add(webview.onDidFocus(() => this._onDidFocusWebview.fire()));
    return store;
  }
}, WebviewEditor_1 = _a20, _a20.ID = "WebviewEditor", _a20);
WebviewEditor = WebviewEditor_1 = __decorate([
  __param(0, ITelemetryService),
  __param(1, IThemeService),
  __param(2, IStorageService),
  __param(3, IEditorGroupsService),
  __param(4, IEditorService),
  __param(5, IWorkbenchLayoutService),
  __param(6, IEditorDropService),
  __param(7, IHostService),
  __param(8, IContextKeyService)
], WebviewEditor);

// node_modules/vscode/vscode/src/vs/workbench/contrib/webviewPanel/browser/webviewIconManager.js
init_tslib_es6();
init_dom();
init_configuration();
var WebviewIconManager = class WebviewIconManager2 {
  constructor(_lifecycleService, _configService) {
    this._lifecycleService = _lifecycleService;
    this._configService = _configService;
    this._icons = /* @__PURE__ */ new Map();
    this._configService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("workbench.iconTheme")) {
        this.updateStyleSheet();
      }
    });
  }
  dispose() {
    var _a43;
    (_a43 = this._styleElement) == null ? void 0 : _a43.remove();
    this._styleElement = void 0;
  }
  get styleElement() {
    if (!this._styleElement) {
      this._styleElement = createStyleSheet();
      this._styleElement.className = "webview-icons";
    }
    return this._styleElement;
  }
  setIcons(webviewId, iconPath) {
    if (iconPath) {
      this._icons.set(webviewId, iconPath);
    } else {
      this._icons.delete(webviewId);
    }
    this.updateStyleSheet();
  }
  async updateStyleSheet() {
    await this._lifecycleService.when(1);
    const cssRules = [];
    if (this._configService.getValue("workbench.iconTheme") !== null) {
      for (const [key, value] of this._icons) {
        const webviewSelector = `.show-file-icons .webview-${key}-name-file-icon::before`;
        try {
          cssRules.push(`.monaco-workbench.vs ${webviewSelector}, .monaco-workbench.hc-light ${webviewSelector} { content: ""; background-image: ${asCSSUrl(value.light)}; }`, `.monaco-workbench.vs-dark ${webviewSelector}, .monaco-workbench.hc-black ${webviewSelector} { content: ""; background-image: ${asCSSUrl(value.dark)}; }`);
        } catch {
        }
      }
    }
    this.styleElement.textContent = cssRules.join("\n");
  }
};
WebviewIconManager = __decorate([
  __param(0, ILifecycleService),
  __param(1, IConfigurationService)
], WebviewIconManager);

// node_modules/vscode/vscode/src/vs/workbench/contrib/webviewPanel/browser/webviewWorkbenchService.js
var IWebviewWorkbenchService = createDecorator("webviewEditorService");
function canRevive(reviver, webview) {
  return reviver.canResolve(webview);
}
var LazilyResolvedWebviewEditorInput = class LazilyResolvedWebviewEditorInput2 extends WebviewInput {
  constructor(init, webview, _webviewWorkbenchService) {
    super(init, webview, _webviewWorkbenchService.iconManager);
    this._webviewWorkbenchService = _webviewWorkbenchService;
    this._resolved = false;
  }
  dispose() {
    var _a43;
    super.dispose();
    (_a43 = this._resolvePromise) == null ? void 0 : _a43.cancel();
    this._resolvePromise = void 0;
  }
  async resolve() {
    if (!this._resolved) {
      this._resolved = true;
      this._resolvePromise = createCancelablePromise((token) => this._webviewWorkbenchService.resolveWebview(this, token));
      try {
        await this._resolvePromise;
      } catch (e) {
        if (!isCancellationError(e)) {
          throw e;
        }
      }
    }
    return super.resolve();
  }
  transfer(other) {
    if (!super.transfer(other)) {
      return;
    }
    other._resolved = this._resolved;
    return other;
  }
};
LazilyResolvedWebviewEditorInput.__decorator = __decorate([
  memoize
], LazilyResolvedWebviewEditorInput.prototype, "resolve", null);
LazilyResolvedWebviewEditorInput = __decorate([
  __param(2, IWebviewWorkbenchService)
], LazilyResolvedWebviewEditorInput);
var RevivalPool = class {
  constructor() {
    this._awaitingRevival = [];
  }
  enqueueForRestoration(input, token) {
    const promise = new DeferredPromise();
    const remove = () => {
      const index = this._awaitingRevival.findIndex((entry) => input === entry.input);
      if (index >= 0) {
        this._awaitingRevival.splice(index, 1);
      }
    };
    const disposable = combinedDisposable(input.webview.onDidDispose(remove), token.onCancellationRequested(() => {
      remove();
      promise.cancel();
    }));
    this._awaitingRevival.push({ input, promise, disposable });
    return promise.p;
  }
  reviveFor(reviver, token) {
    const toRevive = this._awaitingRevival.filter(({ input }) => canRevive(reviver, input));
    this._awaitingRevival = this._awaitingRevival.filter(({ input }) => !canRevive(reviver, input));
    for (const { input, promise: resolve, disposable } of toRevive) {
      reviver.resolveWebview(input, token).then((x) => resolve.complete(x), (err) => resolve.error(err)).finally(() => {
        disposable.dispose();
      });
    }
  }
};
var WebviewEditorService = class WebviewEditorService2 extends Disposable {
  constructor(contextKeyService, _editorService, _instantiationService, _webviewService) {
    super();
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._webviewService = _webviewService;
    this._revivers = /* @__PURE__ */ new Set();
    this._revivalPool = new RevivalPool();
    this._onDidChangeActiveWebviewEditor = this._register(new Emitter());
    this.onDidChangeActiveWebviewEditor = this._onDidChangeActiveWebviewEditor.event;
    this._activeWebviewPanelIdContext = CONTEXT_ACTIVE_WEBVIEW_PANEL_ID.bindTo(contextKeyService);
    this._iconManager = this._register(this._instantiationService.createInstance(WebviewIconManager));
    this._register(_editorService.onDidActiveEditorChange(() => {
      this.updateActiveWebview();
    }));
    this._register(_webviewService.onDidChangeActiveWebview(() => {
      this.updateActiveWebview();
    }));
    this.updateActiveWebview();
  }
  get iconManager() {
    return this._iconManager;
  }
  updateActiveWebview() {
    const activeInput = this._editorService.activeEditor;
    let newActiveWebview;
    if (activeInput instanceof WebviewInput) {
      newActiveWebview = activeInput;
    } else if (activeInput instanceof DiffEditorInput) {
      if (activeInput.primary instanceof WebviewInput && activeInput.primary.webview === this._webviewService.activeWebview) {
        newActiveWebview = activeInput.primary;
      } else if (activeInput.secondary instanceof WebviewInput && activeInput.secondary.webview === this._webviewService.activeWebview) {
        newActiveWebview = activeInput.secondary;
      }
    }
    if (newActiveWebview) {
      this._activeWebviewPanelIdContext.set(newActiveWebview.webview.providedViewType ?? "");
    } else {
      this._activeWebviewPanelIdContext.reset();
    }
    if (newActiveWebview !== this._activeWebview) {
      this._activeWebview = newActiveWebview;
      this._onDidChangeActiveWebviewEditor.fire(newActiveWebview);
    }
  }
  openWebview(webviewInitInfo, viewType, title, showOptions) {
    const webview = this._webviewService.createWebviewOverlay(webviewInitInfo);
    const webviewInput = this._instantiationService.createInstance(WebviewInput, { viewType, name: title, providedId: webviewInitInfo.providedViewType }, webview, this.iconManager);
    this._editorService.openEditor(webviewInput, {
      pinned: true,
      preserveFocus: showOptions.preserveFocus,
      activation: showOptions.preserveFocus ? EditorActivation.RESTORE : void 0
    }, showOptions.group);
    return webviewInput;
  }
  revealWebview(webview, group, preserveFocus) {
    const topLevelEditor = this.findTopLevelEditorForWebview(webview);
    this._editorService.openEditor(topLevelEditor, {
      preserveFocus,
      activation: preserveFocus ? EditorActivation.RESTORE : void 0
    }, group);
  }
  findTopLevelEditorForWebview(webview) {
    for (const editor of this._editorService.editors) {
      if (editor === webview) {
        return editor;
      }
      if (editor instanceof DiffEditorInput) {
        if (webview === editor.primary || webview === editor.secondary) {
          return editor;
        }
      }
    }
    return webview;
  }
  openRevivedWebview(options) {
    const webview = this._webviewService.createWebviewOverlay(options.webviewInitInfo);
    webview.state = options.state;
    const webviewInput = this._instantiationService.createInstance(LazilyResolvedWebviewEditorInput, { viewType: options.viewType, providedId: options.webviewInitInfo.providedViewType, name: options.title }, webview);
    webviewInput.iconPath = options.iconPath;
    if (typeof options.group === "number") {
      webviewInput.updateGroup(options.group);
    }
    return webviewInput;
  }
  registerResolver(reviver) {
    this._revivers.add(reviver);
    const cts = new CancellationTokenSource();
    this._revivalPool.reviveFor(reviver, cts.token);
    return toDisposable(() => {
      this._revivers.delete(reviver);
      cts.dispose(true);
    });
  }
  shouldPersist(webview) {
    if (webview instanceof LazilyResolvedWebviewEditorInput) {
      return true;
    }
    return Iterable.some(this._revivers.values(), (reviver) => canRevive(reviver, webview));
  }
  async tryRevive(webview, token) {
    for (const reviver of this._revivers.values()) {
      if (canRevive(reviver, webview)) {
        await reviver.resolveWebview(webview, token);
        return true;
      }
    }
    return false;
  }
  async resolveWebview(webview, token) {
    const didRevive = await this.tryRevive(webview, token);
    if (!didRevive && !token.isCancellationRequested) {
      return this._revivalPool.enqueueForRestoration(webview, token);
    }
  }
  setIcons(id, iconPath) {
    this._iconManager.setIcons(id, iconPath);
  }
};
WebviewEditorService = __decorate([
  __param(0, IContextKeyService),
  __param(1, IEditorService),
  __param(2, IInstantiationService),
  __param(3, IWebviewService)
], WebviewEditorService);

// node_modules/vscode/vscode/src/vs/workbench/contrib/webviewView/browser/webviewViewService.js
init_cancellation();
init_event();
init_lifecycle();
init_instantiation();
var IWebviewViewService = createDecorator("webviewViewService");

// node_modules/vscode/missing-services.js
init_remoteAuthorityResolver();

// node_modules/vscode/vscode/src/vs/workbench/contrib/externalUriOpener/common/externalUriOpenerService.js
init_tslib_es6();
init_arrays();
init_iterator();
init_lifecycle();
init_linkedList();
init_platform();
init_uri();
init_languages();
init_nls();
init_configuration();
init_instantiation();
init_log();
init_opener();

// node_modules/vscode/vscode/src/vs/workbench/contrib/externalUriOpener/common/configuration.js
init_configurationRegistry();
init_nls();
init_platform2();
var defaultExternalUriOpenerId = "default";
var externalUriOpenersSettingId = "workbench.externalUriOpeners";
var externalUriOpenerIdSchemaAddition = {
  type: "string",
  enum: []
};
var exampleUriPatterns = `
- \`https://microsoft.com\`: Matches this specific domain using https
- \`https://microsoft.com:8080\`: Matches this specific domain on this port using https
- \`https://microsoft.com:*\`: Matches this specific domain on any port using https
- \`https://microsoft.com/foo\`: Matches \`https://microsoft.com/foo\` and \`https://microsoft.com/foo/bar\`, but not \`https://microsoft.com/foobar\` or \`https://microsoft.com/bar\`
- \`https://*.microsoft.com\`: Match all domains ending in \`microsoft.com\` using https
- \`microsoft.com\`: Match this specific domain using either http or https
- \`*.microsoft.com\`: Match all domains ending in \`microsoft.com\` using either http or https
- \`http://192.168.0.1\`: Matches this specific IP using http
- \`http://192.168.0.*\`: Matches all IP's with this prefix using http
- \`*\`: Match all domains using either http or https`;
var externalUriOpenersConfigurationNode = {
  ...workbenchConfigurationNodeBase,
  properties: {
    [externalUriOpenersSettingId]: {
      type: "object",
      markdownDescription: localize(
        "externalUriOpeners",
        "Configure the opener to use for external URIs (http, https)."
      ),
      defaultSnippets: [{
        body: {
          "example.com": "$1"
        }
      }],
      additionalProperties: {
        anyOf: [
          {
            type: "string",
            markdownDescription: localize(
              "externalUriOpeners.uri",
              "Map URI pattern to an opener id.\nExample patterns: \n{0}",
              exampleUriPatterns
            )
          },
          {
            type: "string",
            markdownDescription: localize(
              "externalUriOpeners.uri",
              "Map URI pattern to an opener id.\nExample patterns: \n{0}",
              exampleUriPatterns
            ),
            enum: [defaultExternalUriOpenerId],
            enumDescriptions: [localize("externalUriOpeners.defaultId", "Open using VS Code's standard opener.")]
          },
          externalUriOpenerIdSchemaAddition
        ]
      }
    }
  }
};
function updateContributedOpeners(enumValues, enumDescriptions) {
  externalUriOpenerIdSchemaAddition.enum = enumValues;
  externalUriOpenerIdSchemaAddition.enumDescriptions = enumDescriptions;
  Registry.as(Extensions2.Configuration).notifyConfigurationSchemaUpdated(externalUriOpenersConfigurationNode);
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/url/common/urlGlob.js
var testUrlMatchesGlob = (uri, globUrl) => {
  var _a43;
  let url = uri.with({ query: null, fragment: null }).toString(true);
  const normalize = (url2) => url2.replace(/\/+$/, "");
  globUrl = normalize(globUrl);
  url = normalize(url);
  const memo = Array.from({ length: url.length + 1 }).map(() => Array.from({ length: globUrl.length + 1 }).map(() => void 0));
  if (/^[^./:]*:\/\//.test(globUrl)) {
    return doUrlMatch(memo, url, globUrl, 0, 0);
  }
  const scheme = (_a43 = /^(https?):\/\//.exec(url)) == null ? void 0 : _a43[1];
  if (scheme) {
    return doUrlMatch(memo, url, `${scheme}://${globUrl}`, 0, 0);
  }
  return false;
};
var doUrlMatch = (memo, url, globUrl, urlOffset, globUrlOffset) => {
  var _a43;
  if (((_a43 = memo[urlOffset]) == null ? void 0 : _a43[globUrlOffset]) !== void 0) {
    return memo[urlOffset][globUrlOffset];
  }
  const options = [];
  if (urlOffset === url.length) {
    return globUrlOffset === globUrl.length;
  }
  if (globUrlOffset === globUrl.length) {
    const remaining = url.slice(urlOffset);
    return remaining[0] === "/";
  }
  if (url[urlOffset] === globUrl[globUrlOffset]) {
    options.push(doUrlMatch(memo, url, globUrl, urlOffset + 1, globUrlOffset + 1));
  }
  if (globUrl[globUrlOffset] + globUrl[globUrlOffset + 1] === "*.") {
    if (!["/", ":"].includes(url[urlOffset])) {
      options.push(doUrlMatch(memo, url, globUrl, urlOffset + 1, globUrlOffset));
    }
    options.push(doUrlMatch(memo, url, globUrl, urlOffset, globUrlOffset + 2));
  }
  if (globUrl[globUrlOffset] === "*") {
    if (urlOffset + 1 === url.length) {
      options.push(doUrlMatch(memo, url, globUrl, urlOffset + 1, globUrlOffset + 1));
    } else {
      options.push(doUrlMatch(memo, url, globUrl, urlOffset + 1, globUrlOffset));
    }
    options.push(doUrlMatch(memo, url, globUrl, urlOffset, globUrlOffset + 1));
  }
  if (globUrl[globUrlOffset] + globUrl[globUrlOffset + 1] === ":*") {
    if (url[urlOffset] === ":") {
      let endPortIndex = urlOffset + 1;
      do {
        endPortIndex++;
      } while (/[0-9]/.test(url[endPortIndex]));
      options.push(doUrlMatch(memo, url, globUrl, endPortIndex, globUrlOffset + 2));
    } else {
      options.push(doUrlMatch(memo, url, globUrl, urlOffset, globUrlOffset + 2));
    }
  }
  return memo[urlOffset][globUrlOffset] = options.some((a) => a === true);
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/externalUriOpener/common/externalUriOpenerService.js
var IExternalUriOpenerService = createDecorator("externalUriOpenerService");
var ExternalUriOpenerService = class ExternalUriOpenerService2 extends Disposable {
  constructor(openerService, configurationService, logService, preferencesService, quickInputService) {
    super();
    this.configurationService = configurationService;
    this.logService = logService;
    this.preferencesService = preferencesService;
    this.quickInputService = quickInputService;
    this._providers = new LinkedList();
    this._register(openerService.registerExternalOpener(this));
  }
  registerExternalOpenerProvider(provider) {
    const remove = this._providers.push(provider);
    return { dispose: remove };
  }
  async getOpeners(targetUri, allowOptional, ctx, token) {
    const allOpeners = await this.getAllOpenersForUri(targetUri);
    if (allOpeners.size === 0) {
      return [];
    }
    if (ctx.preferredOpenerId) {
      if (ctx.preferredOpenerId === defaultExternalUriOpenerId) {
        return [];
      }
      const preferredOpener = allOpeners.get(ctx.preferredOpenerId);
      if (preferredOpener) {
        return [preferredOpener];
      }
    }
    const configuredOpener = this.getConfiguredOpenerForUri(allOpeners, targetUri);
    if (configuredOpener) {
      return configuredOpener === defaultExternalUriOpenerId ? [] : [configuredOpener];
    }
    const validOpeners = [];
    await Promise.all(Array.from(allOpeners.values()).map(async (opener) => {
      let priority;
      try {
        priority = await opener.canOpen(ctx.sourceUri, token);
      } catch (e) {
        this.logService.error(e);
        return;
      }
      switch (priority) {
        case ExternalUriOpenerPriority.Option:
        case ExternalUriOpenerPriority.Default:
        case ExternalUriOpenerPriority.Preferred:
          validOpeners.push({ opener, priority });
          break;
      }
    }));
    if (validOpeners.length === 0) {
      return [];
    }
    const preferred = firstOrDefault(validOpeners.filter((x) => x.priority === ExternalUriOpenerPriority.Preferred));
    if (preferred) {
      return [preferred.opener];
    }
    if (!allowOptional && validOpeners.every((x) => x.priority === ExternalUriOpenerPriority.Option)) {
      return [];
    }
    return validOpeners.map((value) => value.opener);
  }
  async openExternal(href, ctx, token) {
    const targetUri = typeof href === "string" ? URI.parse(href) : href;
    const allOpeners = await this.getOpeners(targetUri, false, ctx, token);
    if (allOpeners.length === 0) {
      return false;
    } else if (allOpeners.length === 1) {
      return allOpeners[0].openExternalUri(targetUri, ctx, token);
    }
    return this.showOpenerPrompt(allOpeners, targetUri, ctx, token);
  }
  async getOpener(targetUri, ctx, token) {
    const allOpeners = await this.getOpeners(targetUri, true, ctx, token);
    if (allOpeners.length >= 1) {
      return allOpeners[0];
    }
    return void 0;
  }
  async getAllOpenersForUri(targetUri) {
    const allOpeners = /* @__PURE__ */ new Map();
    await Promise.all(Iterable.map(this._providers, async (provider) => {
      for await (const opener of provider.getOpeners(targetUri)) {
        allOpeners.set(opener.id, opener);
      }
    }));
    return allOpeners;
  }
  getConfiguredOpenerForUri(openers, targetUri) {
    const config = this.configurationService.getValue(externalUriOpenersSettingId) || {};
    for (const [uriGlob, id] of Object.entries(config)) {
      if (testUrlMatchesGlob(targetUri, uriGlob)) {
        if (id === defaultExternalUriOpenerId) {
          return "default";
        }
        const entry = openers.get(id);
        if (entry) {
          return entry;
        }
      }
    }
    return void 0;
  }
  async showOpenerPrompt(openers, targetUri, ctx, token) {
    const items = openers.map((opener) => {
      return {
        label: opener.label,
        opener
      };
    });
    items.push({
      label: isWeb ? localize("selectOpenerDefaultLabel.web", "Open in new browser window") : localize("selectOpenerDefaultLabel", "Open in default browser"),
      opener: void 0
    }, { type: "separator" }, {
      label: localize("selectOpenerConfigureTitle", "Configure default opener..."),
      opener: "configureDefault"
    });
    const picked = await this.quickInputService.pick(items, {
      placeHolder: localize(
        "selectOpenerPlaceHolder",
        "How would you like to open: {0}",
        targetUri.toString()
      )
    });
    if (!picked) {
      return true;
    }
    if (typeof picked.opener === "undefined") {
      return false;
    } else if (picked.opener === "configureDefault") {
      await this.preferencesService.openUserSettings({
        jsonEditor: true,
        revealSetting: { key: externalUriOpenersSettingId, edit: true }
      });
      return true;
    } else {
      return picked.opener.openExternalUri(targetUri, ctx, token);
    }
  }
};
ExternalUriOpenerService = __decorate([
  __param(0, IOpenerService),
  __param(1, IConfigurationService),
  __param(2, ILogService),
  __param(3, IPreferencesService),
  __param(4, IQuickInputService)
], ExternalUriOpenerService);

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionManifestPropertiesService.js
init_tslib_es6();
init_configuration();
init_extensions();
init_arrays();
init_instantiation();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/workbench/services/workspaces/common/workspaceTrust.js
init_tslib_es6();
init_event();
init_lifecycle();
init_linkedList();
init_network();
init_uri();
init_configuration();
init_remoteAuthorityResolver();
init_remoteHosts();
init_resources();
init_platform();
init_files();
var WORKSPACE_TRUST_ENABLED = "security.workspace.trust.enabled";
var WORKSPACE_TRUST_UNTRUSTED_FILES = "security.workspace.trust.untrustedFiles";
var WORKSPACE_TRUST_EMPTY_WINDOW = "security.workspace.trust.emptyWindow";
var WORKSPACE_TRUST_EXTENSION_SUPPORT = "extensions.supportUntrustedWorkspaces";
var WORKSPACE_TRUST_STORAGE_KEY = "content.trust.model.key";
var CanonicalWorkspace = class {
  constructor(originalWorkspace, canonicalFolderUris, canonicalConfiguration) {
    this.originalWorkspace = originalWorkspace;
    this.canonicalFolderUris = canonicalFolderUris;
    this.canonicalConfiguration = canonicalConfiguration;
  }
  get folders() {
    return this.originalWorkspace.folders.map((folder, index) => {
      return {
        index: folder.index,
        name: folder.name,
        toResource: folder.toResource,
        uri: this.canonicalFolderUris[index]
      };
    });
  }
  get transient() {
    return this.originalWorkspace.transient;
  }
  get configuration() {
    return this.canonicalConfiguration ?? this.originalWorkspace.configuration;
  }
  get id() {
    return this.originalWorkspace.id;
  }
};
var WorkspaceTrustEnablementService = class WorkspaceTrustEnablementService2 extends Disposable {
  constructor(configurationService, environmentService) {
    super();
    this.configurationService = configurationService;
    this.environmentService = environmentService;
  }
  isWorkspaceTrustEnabled() {
    if (this.environmentService.disableWorkspaceTrust) {
      return false;
    }
    return !!this.configurationService.getValue(WORKSPACE_TRUST_ENABLED);
  }
};
WorkspaceTrustEnablementService = __decorate([
  __param(0, IConfigurationService),
  __param(1, IWorkbenchEnvironmentService)
], WorkspaceTrustEnablementService);
var WorkspaceTrustManagementService = class WorkspaceTrustManagementService2 extends Disposable {
  constructor(configurationService, remoteAuthorityResolverService, storageService, uriIdentityService, environmentService, workspaceService, workspaceTrustEnablementService, fileService) {
    super();
    this.configurationService = configurationService;
    this.remoteAuthorityResolverService = remoteAuthorityResolverService;
    this.storageService = storageService;
    this.uriIdentityService = uriIdentityService;
    this.environmentService = environmentService;
    this.workspaceService = workspaceService;
    this.workspaceTrustEnablementService = workspaceTrustEnablementService;
    this.fileService = fileService;
    this.storageKey = WORKSPACE_TRUST_STORAGE_KEY;
    this._onDidChangeTrust = this._register(new Emitter());
    this.onDidChangeTrust = this._onDidChangeTrust.event;
    this._onDidChangeTrustedFolders = this._register(new Emitter());
    this.onDidChangeTrustedFolders = this._onDidChangeTrustedFolders.event;
    this._canonicalStartupFiles = [];
    this._canonicalUrisResolved = false;
    this._canonicalWorkspace = this.workspaceService.getWorkspace();
    this._workspaceResolvedPromise = new Promise((resolve) => {
      this._workspaceResolvedPromiseResolve = resolve;
    });
    this._workspaceTrustInitializedPromise = new Promise((resolve) => {
      this._workspaceTrustInitializedPromiseResolve = resolve;
    });
    this._storedTrustState = new WorkspaceTrustMemento(isWeb && this.isEmptyWorkspace() ? void 0 : this.storageService);
    this._trustTransitionManager = this._register(new WorkspaceTrustTransitionManager());
    this._trustStateInfo = this.loadTrustInfo();
    this._isTrusted = this.calculateWorkspaceTrust();
    this.initializeWorkspaceTrust();
    this.registerListeners();
  }
  initializeWorkspaceTrust() {
    this.resolveCanonicalUris().then(async () => {
      this._canonicalUrisResolved = true;
      await this.updateWorkspaceTrust();
    }).finally(() => {
      this._workspaceResolvedPromiseResolve();
      if (!this.environmentService.remoteAuthority) {
        this._workspaceTrustInitializedPromiseResolve();
      }
    });
    if (this.environmentService.remoteAuthority) {
      this.remoteAuthorityResolverService.resolveAuthority(this.environmentService.remoteAuthority).then(async (result) => {
        this._remoteAuthority = result;
        await this.fileService.activateProvider(Schemas.vscodeRemote);
        await this.updateWorkspaceTrust();
      }).finally(() => {
        this._workspaceTrustInitializedPromiseResolve();
      });
    }
    if (this.isEmptyWorkspace()) {
      this._workspaceTrustInitializedPromise.then(() => {
        if (this._storedTrustState.isEmptyWorkspaceTrusted === void 0) {
          this._storedTrustState.isEmptyWorkspaceTrusted = this.isWorkspaceTrusted();
        }
      });
    }
  }
  registerListeners() {
    this._register(this.workspaceService.onDidChangeWorkspaceFolders(async () => await this.updateWorkspaceTrust()));
    this._register(this.storageService.onDidChangeValue(-1, this.storageKey, this._register(new DisposableStore()))(async () => {
      if (JSON.stringify(this._trustStateInfo) !== JSON.stringify(this.loadTrustInfo())) {
        this._trustStateInfo = this.loadTrustInfo();
        this._onDidChangeTrustedFolders.fire();
        await this.updateWorkspaceTrust();
      }
    }));
  }
  async getCanonicalUri(uri) {
    let canonicalUri = uri;
    if (this.environmentService.remoteAuthority && uri.scheme === Schemas.vscodeRemote) {
      canonicalUri = await this.remoteAuthorityResolverService.getCanonicalURI(uri);
    } else if (uri.scheme === "vscode-vfs") {
      const index = uri.authority.indexOf("+");
      if (index !== -1) {
        canonicalUri = uri.with({ authority: uri.authority.substr(0, index) });
      }
    }
    return canonicalUri.with({ query: null, fragment: null });
  }
  async resolveCanonicalUris() {
    const filesToOpen = [];
    if (this.environmentService.filesToOpenOrCreate) {
      filesToOpen.push(...this.environmentService.filesToOpenOrCreate);
    }
    if (this.environmentService.filesToDiff) {
      filesToOpen.push(...this.environmentService.filesToDiff);
    }
    if (this.environmentService.filesToMerge) {
      filesToOpen.push(...this.environmentService.filesToMerge);
    }
    if (filesToOpen.length) {
      const filesToOpenOrCreateUris = filesToOpen.filter((f) => !!f.fileUri).map((f) => f.fileUri);
      const canonicalFilesToOpen = await Promise.all(filesToOpenOrCreateUris.map((uri) => this.getCanonicalUri(uri)));
      this._canonicalStartupFiles.push(...canonicalFilesToOpen.filter((uri) => this._canonicalStartupFiles.every((u) => !this.uriIdentityService.extUri.isEqual(uri, u))));
    }
    const workspaceUris = this.workspaceService.getWorkspace().folders.map((f) => f.uri);
    const canonicalWorkspaceFolders = await Promise.all(workspaceUris.map((uri) => this.getCanonicalUri(uri)));
    let canonicalWorkspaceConfiguration = this.workspaceService.getWorkspace().configuration;
    if (canonicalWorkspaceConfiguration && isSavedWorkspace(canonicalWorkspaceConfiguration, this.environmentService)) {
      canonicalWorkspaceConfiguration = await this.getCanonicalUri(canonicalWorkspaceConfiguration);
    }
    this._canonicalWorkspace = new CanonicalWorkspace(
      this.workspaceService.getWorkspace(),
      canonicalWorkspaceFolders,
      canonicalWorkspaceConfiguration
    );
  }
  loadTrustInfo() {
    const infoAsString = this.storageService.get(this.storageKey, -1);
    let result;
    try {
      if (infoAsString) {
        result = JSON.parse(infoAsString);
      }
    } catch {
    }
    if (!result) {
      result = {
        uriTrustInfo: []
      };
    }
    if (!result.uriTrustInfo) {
      result.uriTrustInfo = [];
    }
    result.uriTrustInfo = result.uriTrustInfo.map((info) => {
      return { uri: URI.revive(info.uri), trusted: info.trusted };
    });
    result.uriTrustInfo = result.uriTrustInfo.filter((info) => info.trusted);
    return result;
  }
  async saveTrustInfo() {
    this.storageService.store(this.storageKey, JSON.stringify(this._trustStateInfo), -1, 1);
    this._onDidChangeTrustedFolders.fire();
    await this.updateWorkspaceTrust();
  }
  getWorkspaceUris() {
    const workspaceUris = this._canonicalWorkspace.folders.map((f) => f.uri);
    const workspaceConfiguration = this._canonicalWorkspace.configuration;
    if (workspaceConfiguration && isSavedWorkspace(workspaceConfiguration, this.environmentService)) {
      workspaceUris.push(workspaceConfiguration);
    }
    return workspaceUris;
  }
  calculateWorkspaceTrust() {
    var _a43, _b;
    if (!this.workspaceTrustEnablementService.isWorkspaceTrustEnabled()) {
      return true;
    }
    if (!this._canonicalUrisResolved) {
      return false;
    }
    if (this.environmentService.remoteAuthority && ((_b = (_a43 = this._remoteAuthority) == null ? void 0 : _a43.options) == null ? void 0 : _b.isTrusted)) {
      return this._remoteAuthority.options.isTrusted;
    }
    if (this.isEmptyWorkspace()) {
      if (this._storedTrustState.isEmptyWorkspaceTrusted !== void 0) {
        return this._storedTrustState.isEmptyWorkspaceTrusted;
      }
      if (this._canonicalStartupFiles.length) {
        return this.getUrisTrust(this._canonicalStartupFiles);
      }
      return !!this.configurationService.getValue(WORKSPACE_TRUST_EMPTY_WINDOW);
    }
    return this.getUrisTrust(this.getWorkspaceUris());
  }
  async updateWorkspaceTrust(trusted) {
    if (!this.workspaceTrustEnablementService.isWorkspaceTrustEnabled()) {
      return;
    }
    if (trusted === void 0) {
      await this.resolveCanonicalUris();
      trusted = this.calculateWorkspaceTrust();
    }
    if (this.isWorkspaceTrusted() === trusted) {
      return;
    }
    this.isTrusted = trusted;
    await this._trustTransitionManager.participate(trusted);
    this._onDidChangeTrust.fire(trusted);
  }
  getUrisTrust(uris) {
    let state = true;
    for (const uri of uris) {
      const { trusted } = this.doGetUriTrustInfo(uri);
      if (!trusted) {
        state = trusted;
        return state;
      }
    }
    return state;
  }
  doGetUriTrustInfo(uri) {
    if (!this.workspaceTrustEnablementService.isWorkspaceTrustEnabled()) {
      return { trusted: true, uri };
    }
    if (this.isTrustedVirtualResource(uri)) {
      return { trusted: true, uri };
    }
    if (this.isTrustedByRemote(uri)) {
      return { trusted: true, uri };
    }
    let resultState = false;
    let maxLength = -1;
    let resultUri = uri;
    for (const trustInfo of this._trustStateInfo.uriTrustInfo) {
      if (this.uriIdentityService.extUri.isEqualOrParent(uri, trustInfo.uri)) {
        const fsPath = trustInfo.uri.fsPath;
        if (fsPath.length > maxLength) {
          maxLength = fsPath.length;
          resultState = trustInfo.trusted;
          resultUri = trustInfo.uri;
        }
      }
    }
    return { trusted: resultState, uri: resultUri };
  }
  async doSetUrisTrust(uris, trusted) {
    let changed = false;
    for (const uri of uris) {
      if (trusted) {
        if (this.isTrustedVirtualResource(uri)) {
          continue;
        }
        if (this.isTrustedByRemote(uri)) {
          continue;
        }
        const foundItem = this._trustStateInfo.uriTrustInfo.find((trustInfo) => this.uriIdentityService.extUri.isEqual(trustInfo.uri, uri));
        if (!foundItem) {
          this._trustStateInfo.uriTrustInfo.push({ uri, trusted: true });
          changed = true;
        }
      } else {
        const previousLength = this._trustStateInfo.uriTrustInfo.length;
        this._trustStateInfo.uriTrustInfo = this._trustStateInfo.uriTrustInfo.filter((trustInfo) => !this.uriIdentityService.extUri.isEqual(trustInfo.uri, uri));
        if (previousLength !== this._trustStateInfo.uriTrustInfo.length) {
          changed = true;
        }
      }
    }
    if (changed) {
      await this.saveTrustInfo();
    }
  }
  isEmptyWorkspace() {
    if (this.workspaceService.getWorkbenchState() === 1) {
      return true;
    }
    const workspace = this.workspaceService.getWorkspace();
    if (workspace) {
      return isTemporaryWorkspace(this.workspaceService.getWorkspace()) && workspace.folders.length === 0;
    }
    return false;
  }
  isTrustedVirtualResource(uri) {
    return isVirtualResource(uri) && uri.scheme !== "vscode-vfs";
  }
  isTrustedByRemote(uri) {
    var _a43;
    if (!this.environmentService.remoteAuthority) {
      return false;
    }
    if (!this._remoteAuthority) {
      return false;
    }
    return isEqualAuthority(getRemoteAuthority(uri), this._remoteAuthority.authority.authority) && !!((_a43 = this._remoteAuthority.options) == null ? void 0 : _a43.isTrusted);
  }
  set isTrusted(value) {
    this._isTrusted = value;
    if (!value) {
      this._storedTrustState.acceptsOutOfWorkspaceFiles = false;
    }
    if (this.isEmptyWorkspace()) {
      this._storedTrustState.isEmptyWorkspaceTrusted = value;
    }
  }
  get workspaceResolved() {
    return this._workspaceResolvedPromise;
  }
  get workspaceTrustInitialized() {
    return this._workspaceTrustInitializedPromise;
  }
  get acceptsOutOfWorkspaceFiles() {
    return this._storedTrustState.acceptsOutOfWorkspaceFiles;
  }
  set acceptsOutOfWorkspaceFiles(value) {
    this._storedTrustState.acceptsOutOfWorkspaceFiles = value;
  }
  isWorkspaceTrusted() {
    return this._isTrusted;
  }
  isWorkspaceTrustForced() {
    var _a43;
    if (this.environmentService.remoteAuthority && this._remoteAuthority && ((_a43 = this._remoteAuthority.options) == null ? void 0 : _a43.isTrusted) !== void 0) {
      return true;
    }
    const workspaceUris = this.getWorkspaceUris().filter((uri) => !this.isTrustedVirtualResource(uri));
    if (workspaceUris.length === 0) {
      return true;
    }
    return false;
  }
  canSetParentFolderTrust() {
    const workspaceIdentifier = toWorkspaceIdentifier(this._canonicalWorkspace);
    if (!isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return false;
    }
    if (workspaceIdentifier.uri.scheme !== Schemas.file && workspaceIdentifier.uri.scheme !== Schemas.vscodeRemote) {
      return false;
    }
    const parentFolder = this.uriIdentityService.extUri.dirname(workspaceIdentifier.uri);
    if (this.uriIdentityService.extUri.isEqual(workspaceIdentifier.uri, parentFolder)) {
      return false;
    }
    return true;
  }
  async setParentFolderTrust(trusted) {
    if (this.canSetParentFolderTrust()) {
      const workspaceUri = toWorkspaceIdentifier(this._canonicalWorkspace).uri;
      const parentFolder = this.uriIdentityService.extUri.dirname(workspaceUri);
      await this.setUrisTrust([parentFolder], trusted);
    }
  }
  canSetWorkspaceTrust() {
    var _a43;
    if (this.environmentService.remoteAuthority && (!this._remoteAuthority || ((_a43 = this._remoteAuthority.options) == null ? void 0 : _a43.isTrusted) !== void 0)) {
      return false;
    }
    if (this.isEmptyWorkspace()) {
      return true;
    }
    const workspaceUris = this.getWorkspaceUris().filter((uri) => !this.isTrustedVirtualResource(uri));
    if (workspaceUris.length === 0) {
      return false;
    }
    if (!this.isWorkspaceTrusted()) {
      return true;
    }
    const workspaceIdentifier = toWorkspaceIdentifier(this._canonicalWorkspace);
    if (!isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return false;
    }
    if (workspaceIdentifier.uri.scheme !== Schemas.file && workspaceIdentifier.uri.scheme !== "vscode-vfs") {
      return false;
    }
    const trustInfo = this.doGetUriTrustInfo(workspaceIdentifier.uri);
    if (!trustInfo.trusted || !this.uriIdentityService.extUri.isEqual(workspaceIdentifier.uri, trustInfo.uri)) {
      return false;
    }
    if (this.canSetParentFolderTrust()) {
      const parentFolder = this.uriIdentityService.extUri.dirname(workspaceIdentifier.uri);
      const parentPathTrustInfo = this.doGetUriTrustInfo(parentFolder);
      if (parentPathTrustInfo.trusted) {
        return false;
      }
    }
    return true;
  }
  async setWorkspaceTrust(trusted) {
    if (this.isEmptyWorkspace()) {
      await this.updateWorkspaceTrust(trusted);
      return;
    }
    const workspaceFolders = this.getWorkspaceUris();
    await this.setUrisTrust(workspaceFolders, trusted);
  }
  async getUriTrustInfo(uri) {
    if (!this.workspaceTrustEnablementService.isWorkspaceTrustEnabled()) {
      return { trusted: true, uri };
    }
    if (this.isTrustedByRemote(uri)) {
      return { trusted: true, uri };
    }
    return this.doGetUriTrustInfo(await this.getCanonicalUri(uri));
  }
  async setUrisTrust(uris, trusted) {
    this.doSetUrisTrust(await Promise.all(uris.map((uri) => this.getCanonicalUri(uri))), trusted);
  }
  getTrustedUris() {
    return this._trustStateInfo.uriTrustInfo.map((info) => info.uri);
  }
  async setTrustedUris(uris) {
    this._trustStateInfo.uriTrustInfo = [];
    for (const uri of uris) {
      const canonicalUri = await this.getCanonicalUri(uri);
      const cleanUri = this.uriIdentityService.extUri.removeTrailingPathSeparator(canonicalUri);
      let added = false;
      for (const addedUri of this._trustStateInfo.uriTrustInfo) {
        if (this.uriIdentityService.extUri.isEqual(addedUri.uri, cleanUri)) {
          added = true;
          break;
        }
      }
      if (added) {
        continue;
      }
      this._trustStateInfo.uriTrustInfo.push({
        trusted: true,
        uri: cleanUri
      });
    }
    await this.saveTrustInfo();
  }
  addWorkspaceTrustTransitionParticipant(participant) {
    return this._trustTransitionManager.addWorkspaceTrustTransitionParticipant(participant);
  }
};
WorkspaceTrustManagementService = __decorate([
  __param(0, IConfigurationService),
  __param(1, IRemoteAuthorityResolverService),
  __param(2, IStorageService),
  __param(3, IUriIdentityService),
  __param(4, IWorkbenchEnvironmentService),
  __param(5, IWorkspaceContextService),
  __param(6, IWorkspaceTrustEnablementService),
  __param(7, IFileService)
], WorkspaceTrustManagementService);
var WorkspaceTrustRequestService = class WorkspaceTrustRequestService2 extends Disposable {
  constructor(configurationService, workspaceTrustManagementService) {
    super();
    this.configurationService = configurationService;
    this.workspaceTrustManagementService = workspaceTrustManagementService;
    this._onDidInitiateOpenFilesTrustRequest = this._register(new Emitter());
    this.onDidInitiateOpenFilesTrustRequest = this._onDidInitiateOpenFilesTrustRequest.event;
    this._onDidInitiateWorkspaceTrustRequest = this._register(new Emitter());
    this.onDidInitiateWorkspaceTrustRequest = this._onDidInitiateWorkspaceTrustRequest.event;
    this._onDidInitiateWorkspaceTrustRequestOnStartup = this._register(new Emitter());
    this.onDidInitiateWorkspaceTrustRequestOnStartup = this._onDidInitiateWorkspaceTrustRequestOnStartup.event;
  }
  get untrustedFilesSetting() {
    return this.configurationService.getValue(WORKSPACE_TRUST_UNTRUSTED_FILES);
  }
  set untrustedFilesSetting(value) {
    this.configurationService.updateValue(WORKSPACE_TRUST_UNTRUSTED_FILES, value);
  }
  async completeOpenFilesTrustRequest(result, saveResponse) {
    if (!this._openFilesTrustRequestResolver) {
      return;
    }
    if (result === 1) {
      this.workspaceTrustManagementService.acceptsOutOfWorkspaceFiles = true;
    }
    if (saveResponse) {
      if (result === 1) {
        this.untrustedFilesSetting = "open";
      }
      if (result === 2) {
        this.untrustedFilesSetting = "newWindow";
      }
    }
    this._openFilesTrustRequestResolver(result);
    this._openFilesTrustRequestResolver = void 0;
    this._openFilesTrustRequestPromise = void 0;
  }
  async requestOpenFilesTrust(uris) {
    if (!this.workspaceTrustManagementService.isWorkspaceTrusted()) {
      return 1;
    }
    const openFilesTrustInfo = await Promise.all(uris.map((uri) => this.workspaceTrustManagementService.getUriTrustInfo(uri)));
    if (openFilesTrustInfo.map((info) => info.trusted).every((trusted) => trusted)) {
      return 1;
    }
    if (this.untrustedFilesSetting !== "prompt") {
      if (this.untrustedFilesSetting === "newWindow") {
        return 2;
      }
      if (this.untrustedFilesSetting === "open") {
        return 1;
      }
    }
    if (this.workspaceTrustManagementService.acceptsOutOfWorkspaceFiles) {
      return 1;
    }
    if (!this._openFilesTrustRequestPromise) {
      this._openFilesTrustRequestPromise = new Promise((resolve) => {
        this._openFilesTrustRequestResolver = resolve;
      });
    } else {
      return this._openFilesTrustRequestPromise;
    }
    this._onDidInitiateOpenFilesTrustRequest.fire();
    return this._openFilesTrustRequestPromise;
  }
  resolveWorkspaceTrustRequest(trusted) {
    if (this._workspaceTrustRequestResolver) {
      this._workspaceTrustRequestResolver(trusted ?? this.workspaceTrustManagementService.isWorkspaceTrusted());
      this._workspaceTrustRequestResolver = void 0;
      this._workspaceTrustRequestPromise = void 0;
    }
  }
  cancelWorkspaceTrustRequest() {
    if (this._workspaceTrustRequestResolver) {
      this._workspaceTrustRequestResolver(void 0);
      this._workspaceTrustRequestResolver = void 0;
      this._workspaceTrustRequestPromise = void 0;
    }
  }
  async completeWorkspaceTrustRequest(trusted) {
    if (trusted === void 0 || trusted === this.workspaceTrustManagementService.isWorkspaceTrusted()) {
      this.resolveWorkspaceTrustRequest(trusted);
      return;
    }
    Event.once(this.workspaceTrustManagementService.onDidChangeTrust)((trusted2) => this.resolveWorkspaceTrustRequest(trusted2));
    await this.workspaceTrustManagementService.setWorkspaceTrust(trusted);
  }
  async requestWorkspaceTrust(options) {
    if (this.workspaceTrustManagementService.isWorkspaceTrusted()) {
      return this.workspaceTrustManagementService.isWorkspaceTrusted();
    }
    if (!this._workspaceTrustRequestPromise) {
      this._workspaceTrustRequestPromise = new Promise((resolve) => {
        this._workspaceTrustRequestResolver = resolve;
      });
    } else {
      return this._workspaceTrustRequestPromise;
    }
    this._onDidInitiateWorkspaceTrustRequest.fire(options);
    return this._workspaceTrustRequestPromise;
  }
  requestWorkspaceTrustOnStartup() {
    if (!this._workspaceTrustRequestPromise) {
      this._workspaceTrustRequestPromise = new Promise((resolve) => {
        this._workspaceTrustRequestResolver = resolve;
      });
    }
    this._onDidInitiateWorkspaceTrustRequestOnStartup.fire();
  }
};
WorkspaceTrustRequestService = __decorate([
  __param(0, IConfigurationService),
  __param(1, IWorkspaceTrustManagementService)
], WorkspaceTrustRequestService);
var WorkspaceTrustTransitionManager = class extends Disposable {
  constructor() {
    super(...arguments);
    this.participants = new LinkedList();
  }
  addWorkspaceTrustTransitionParticipant(participant) {
    const remove = this.participants.push(participant);
    return toDisposable(() => remove());
  }
  async participate(trusted) {
    for (const participant of this.participants) {
      await participant.participate(trusted);
    }
  }
  dispose() {
    this.participants.clear();
  }
};
var WorkspaceTrustMemento = class {
  constructor(storageService) {
    this._acceptsOutOfWorkspaceFilesKey = "acceptsOutOfWorkspaceFiles";
    this._isEmptyWorkspaceTrustedKey = "isEmptyWorkspaceTrusted";
    if (storageService) {
      this._memento = new Memento("workspaceTrust", storageService);
      this._mementoObject = this._memento.getMemento(1, 1);
    } else {
      this._mementoObject = {};
    }
  }
  get acceptsOutOfWorkspaceFiles() {
    return this._mementoObject[this._acceptsOutOfWorkspaceFilesKey] ?? false;
  }
  set acceptsOutOfWorkspaceFiles(value) {
    var _a43;
    this._mementoObject[this._acceptsOutOfWorkspaceFilesKey] = value;
    (_a43 = this._memento) == null ? void 0 : _a43.saveMemento();
  }
  get isEmptyWorkspaceTrusted() {
    return this._mementoObject[this._isEmptyWorkspaceTrustedKey];
  }
  set isEmptyWorkspaceTrusted(value) {
    var _a43;
    this._mementoObject[this._isEmptyWorkspaceTrustedKey] = value;
    (_a43 = this._memento) == null ? void 0 : _a43.saveMemento();
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionManifestPropertiesService.js
init_types();
init_log();
init_platform();
var IExtensionManifestPropertiesService = createDecorator("extensionManifestPropertiesService");
var ExtensionManifestPropertiesService = class ExtensionManifestPropertiesService2 extends Disposable {
  constructor(productService, configurationService, workspaceTrustEnablementService, logService) {
    super();
    this.productService = productService;
    this.configurationService = configurationService;
    this.workspaceTrustEnablementService = workspaceTrustEnablementService;
    this.logService = logService;
    this._extensionPointExtensionKindsMap = null;
    this._productExtensionKindsMap = null;
    this._configuredExtensionKindsMap = null;
    this._productVirtualWorkspaceSupportMap = null;
    this._configuredVirtualWorkspaceSupportMap = null;
    this._configuredExtensionWorkspaceTrustRequestMap = new ExtensionIdentifierMap();
    const configuredExtensionWorkspaceTrustRequests = configurationService.inspect(WORKSPACE_TRUST_EXTENSION_SUPPORT).userValue || {};
    for (const id of Object.keys(configuredExtensionWorkspaceTrustRequests)) {
      this._configuredExtensionWorkspaceTrustRequestMap.set(id, configuredExtensionWorkspaceTrustRequests[id]);
    }
    this._productExtensionWorkspaceTrustRequestMap = /* @__PURE__ */ new Map();
    if (productService.extensionUntrustedWorkspaceSupport) {
      for (const id of Object.keys(productService.extensionUntrustedWorkspaceSupport)) {
        this._productExtensionWorkspaceTrustRequestMap.set(id, productService.extensionUntrustedWorkspaceSupport[id]);
      }
    }
  }
  prefersExecuteOnUI(manifest) {
    const extensionKind = this.getExtensionKind(manifest);
    return extensionKind.length > 0 && extensionKind[0] === "ui";
  }
  prefersExecuteOnWorkspace(manifest) {
    const extensionKind = this.getExtensionKind(manifest);
    return extensionKind.length > 0 && extensionKind[0] === "workspace";
  }
  prefersExecuteOnWeb(manifest) {
    const extensionKind = this.getExtensionKind(manifest);
    return extensionKind.length > 0 && extensionKind[0] === "web";
  }
  canExecuteOnUI(manifest) {
    const extensionKind = this.getExtensionKind(manifest);
    return extensionKind.some((kind) => kind === "ui");
  }
  canExecuteOnWorkspace(manifest) {
    const extensionKind = this.getExtensionKind(manifest);
    return extensionKind.some((kind) => kind === "workspace");
  }
  canExecuteOnWeb(manifest) {
    const extensionKind = this.getExtensionKind(manifest);
    return extensionKind.some((kind) => kind === "web");
  }
  getExtensionKind(manifest) {
    const deducedExtensionKind = this.deduceExtensionKind(manifest);
    const configuredExtensionKind = this.getConfiguredExtensionKind(manifest);
    if (configuredExtensionKind && configuredExtensionKind.length > 0) {
      const result = [];
      for (const extensionKind of configuredExtensionKind) {
        if (extensionKind !== "-web") {
          result.push(extensionKind);
        }
      }
      if (configuredExtensionKind.includes("-web") && !result.length) {
        result.push("ui");
        result.push("workspace");
      }
      if (isWeb && !configuredExtensionKind.includes("-web") && !configuredExtensionKind.includes("web") && deducedExtensionKind.includes("web")) {
        result.push("web");
      }
      return result;
    }
    return deducedExtensionKind;
  }
  getUserConfiguredExtensionKind(extensionIdentifier) {
    if (this._configuredExtensionKindsMap === null) {
      const configuredExtensionKindsMap = new ExtensionIdentifierMap();
      const configuredExtensionKinds = this.configurationService.getValue("remote.extensionKind") || {};
      for (const id of Object.keys(configuredExtensionKinds)) {
        configuredExtensionKindsMap.set(id, configuredExtensionKinds[id]);
      }
      this._configuredExtensionKindsMap = configuredExtensionKindsMap;
    }
    const userConfiguredExtensionKind = this._configuredExtensionKindsMap.get(extensionIdentifier.id);
    return userConfiguredExtensionKind ? this.toArray(userConfiguredExtensionKind) : void 0;
  }
  getExtensionUntrustedWorkspaceSupportType(manifest) {
    var _a43, _b;
    if (!this.workspaceTrustEnablementService.isWorkspaceTrustEnabled() || !manifest.main) {
      return true;
    }
    const configuredWorkspaceTrustRequest = this.getConfiguredExtensionWorkspaceTrustRequest(manifest);
    const productWorkspaceTrustRequest = this.getProductExtensionWorkspaceTrustRequest(manifest);
    if (configuredWorkspaceTrustRequest !== void 0) {
      return configuredWorkspaceTrustRequest;
    }
    if ((productWorkspaceTrustRequest == null ? void 0 : productWorkspaceTrustRequest.override) !== void 0) {
      return productWorkspaceTrustRequest.override;
    }
    if (((_b = (_a43 = manifest.capabilities) == null ? void 0 : _a43.untrustedWorkspaces) == null ? void 0 : _b.supported) !== void 0) {
      return manifest.capabilities.untrustedWorkspaces.supported;
    }
    if ((productWorkspaceTrustRequest == null ? void 0 : productWorkspaceTrustRequest.default) !== void 0) {
      return productWorkspaceTrustRequest.default;
    }
    return false;
  }
  getExtensionVirtualWorkspaceSupportType(manifest) {
    var _a43;
    const userConfiguredVirtualWorkspaceSupport = this.getConfiguredVirtualWorkspaceSupport(manifest);
    if (userConfiguredVirtualWorkspaceSupport !== void 0) {
      return userConfiguredVirtualWorkspaceSupport;
    }
    const productConfiguredWorkspaceSchemes = this.getProductVirtualWorkspaceSupport(manifest);
    if ((productConfiguredWorkspaceSchemes == null ? void 0 : productConfiguredWorkspaceSchemes.override) !== void 0) {
      return productConfiguredWorkspaceSchemes.override;
    }
    const virtualWorkspaces = (_a43 = manifest.capabilities) == null ? void 0 : _a43.virtualWorkspaces;
    if (isBoolean(virtualWorkspaces)) {
      return virtualWorkspaces;
    } else if (virtualWorkspaces) {
      const supported = virtualWorkspaces.supported;
      if (isBoolean(supported) || supported === "limited") {
        return supported;
      }
    }
    if ((productConfiguredWorkspaceSchemes == null ? void 0 : productConfiguredWorkspaceSchemes.default) !== void 0) {
      return productConfiguredWorkspaceSchemes.default;
    }
    return true;
  }
  deduceExtensionKind(manifest) {
    if (manifest.main) {
      if (manifest.browser) {
        return isWeb ? ["workspace", "web"] : ["workspace"];
      }
      return ["workspace"];
    }
    if (manifest.browser) {
      return ["web"];
    }
    let result = [...ALL_EXTENSION_KINDS];
    if (isNonEmptyArray(manifest.extensionPack) || isNonEmptyArray(manifest.extensionDependencies)) {
      result = isWeb ? ["workspace", "web"] : ["workspace"];
    }
    if (manifest.contributes) {
      for (const contribution of Object.keys(manifest.contributes)) {
        const supportedExtensionKinds = this.getSupportedExtensionKindsForExtensionPoint(contribution);
        if (supportedExtensionKinds.length) {
          result = result.filter((extensionKind) => supportedExtensionKinds.includes(extensionKind));
        }
      }
    }
    if (!result.length) {
      this.logService.warn("Cannot deduce extensionKind for extension", getGalleryExtensionId(manifest.publisher, manifest.name));
    }
    return result;
  }
  getSupportedExtensionKindsForExtensionPoint(extensionPoint) {
    if (this._extensionPointExtensionKindsMap === null) {
      const extensionPointExtensionKindsMap = /* @__PURE__ */ new Map();
      ExtensionsRegistry.getExtensionPoints().forEach((e) => extensionPointExtensionKindsMap.set(e.name, e.defaultExtensionKind || []));
      this._extensionPointExtensionKindsMap = extensionPointExtensionKindsMap;
    }
    let extensionPointExtensionKind = this._extensionPointExtensionKindsMap.get(extensionPoint);
    if (extensionPointExtensionKind) {
      return extensionPointExtensionKind;
    }
    extensionPointExtensionKind = this.productService.extensionPointExtensionKind ? this.productService.extensionPointExtensionKind[extensionPoint] : void 0;
    if (extensionPointExtensionKind) {
      return extensionPointExtensionKind;
    }
    return isWeb ? ["workspace", "web"] : ["workspace"];
  }
  getConfiguredExtensionKind(manifest) {
    const extensionIdentifier = { id: getGalleryExtensionId(manifest.publisher, manifest.name) };
    let result = this.getUserConfiguredExtensionKind(extensionIdentifier);
    if (typeof result !== "undefined") {
      return this.toArray(result);
    }
    result = this.getProductExtensionKind(manifest);
    if (typeof result !== "undefined") {
      return result;
    }
    result = manifest.extensionKind;
    if (typeof result !== "undefined") {
      result = this.toArray(result);
      return result.filter((r) => ["ui", "workspace"].includes(r));
    }
    return null;
  }
  getProductExtensionKind(manifest) {
    if (this._productExtensionKindsMap === null) {
      const productExtensionKindsMap = new ExtensionIdentifierMap();
      if (this.productService.extensionKind) {
        for (const id of Object.keys(this.productService.extensionKind)) {
          productExtensionKindsMap.set(id, this.productService.extensionKind[id]);
        }
      }
      this._productExtensionKindsMap = productExtensionKindsMap;
    }
    const extensionId = getGalleryExtensionId(manifest.publisher, manifest.name);
    return this._productExtensionKindsMap.get(extensionId);
  }
  getProductVirtualWorkspaceSupport(manifest) {
    if (this._productVirtualWorkspaceSupportMap === null) {
      const productWorkspaceSchemesMap = new ExtensionIdentifierMap();
      if (this.productService.extensionVirtualWorkspacesSupport) {
        for (const id of Object.keys(this.productService.extensionVirtualWorkspacesSupport)) {
          productWorkspaceSchemesMap.set(id, this.productService.extensionVirtualWorkspacesSupport[id]);
        }
      }
      this._productVirtualWorkspaceSupportMap = productWorkspaceSchemesMap;
    }
    const extensionId = getGalleryExtensionId(manifest.publisher, manifest.name);
    return this._productVirtualWorkspaceSupportMap.get(extensionId);
  }
  getConfiguredVirtualWorkspaceSupport(manifest) {
    if (this._configuredVirtualWorkspaceSupportMap === null) {
      const configuredWorkspaceSchemesMap = new ExtensionIdentifierMap();
      const configuredWorkspaceSchemes = this.configurationService.getValue("extensions.supportVirtualWorkspaces") || {};
      for (const id of Object.keys(configuredWorkspaceSchemes)) {
        if (configuredWorkspaceSchemes[id] !== void 0) {
          configuredWorkspaceSchemesMap.set(id, configuredWorkspaceSchemes[id]);
        }
      }
      this._configuredVirtualWorkspaceSupportMap = configuredWorkspaceSchemesMap;
    }
    const extensionId = getGalleryExtensionId(manifest.publisher, manifest.name);
    return this._configuredVirtualWorkspaceSupportMap.get(extensionId);
  }
  getConfiguredExtensionWorkspaceTrustRequest(manifest) {
    const extensionId = getGalleryExtensionId(manifest.publisher, manifest.name);
    const extensionWorkspaceTrustRequest = this._configuredExtensionWorkspaceTrustRequestMap.get(extensionId);
    if (extensionWorkspaceTrustRequest && (extensionWorkspaceTrustRequest.version === void 0 || extensionWorkspaceTrustRequest.version === manifest.version)) {
      return extensionWorkspaceTrustRequest.supported;
    }
    return void 0;
  }
  getProductExtensionWorkspaceTrustRequest(manifest) {
    const extensionId = getGalleryExtensionId(manifest.publisher, manifest.name);
    return this._productExtensionWorkspaceTrustRequestMap.get(extensionId);
  }
  toArray(extensionKind) {
    if (Array.isArray(extensionKind)) {
      return extensionKind;
    }
    return extensionKind === "ui" ? ["ui", "workspace"] : [extensionKind];
  }
};
ExtensionManifestPropertiesService = __decorate([
  __param(0, IProductService),
  __param(1, IConfigurationService),
  __param(2, IWorkspaceTrustEnablementService),
  __param(3, ILogService)
], ExtensionManifestPropertiesService);

// node_modules/vscode/vscode/src/vs/platform/remote/common/remoteExtensionsScanner.js
init_instantiation();
var IRemoteExtensionsScannerService = createDecorator("IRemoteExtensionsScannerService");

// node_modules/vscode/vscode/src/vs/workbench/services/url/browser/urlService.js
init_tslib_es6();
init_uri();

// node_modules/vscode/vscode/src/vs/platform/url/common/urlService.js
init_async();
init_lifecycle();
var AbstractURLService = class extends Disposable {
  constructor() {
    super(...arguments);
    this.handlers = /* @__PURE__ */ new Set();
  }
  open(uri, options) {
    const handlers = [...this.handlers.values()];
    return first(handlers.map((h) => () => h.handleURL(uri, options)), void 0, false).then((val) => val || false);
  }
  registerHandler(handler) {
    this.handlers.add(handler);
    return toDisposable(() => this.handlers.delete(handler));
  }
};

// node_modules/vscode/vscode/src/vs/workbench/services/environment/browser/environmentService.js
init_tslib_es6();
init_network();
init_resources();
init_uri();
init_environment();
init_errors();
init_extpath();
init_log();
init_types();
init_instantiation();

// node_modules/vscode/vscode/src/vs/platform/environment/common/environmentService.js
var EXTENSION_IDENTIFIER_WITH_LOG_REGEX = /^([^.]+\..+):(.+)$/;

// node_modules/vscode/vscode/src/vs/workbench/services/environment/browser/environmentService.js
var IBrowserWorkbenchEnvironmentService = refineServiceDecorator(IEnvironmentService);
var BrowserWorkbenchEnvironmentService = class {
  get remoteAuthority() {
    return this.options.remoteAuthority;
  }
  get expectsResolverExtension() {
    var _a43;
    return !!((_a43 = this.options.remoteAuthority) == null ? void 0 : _a43.includes("+")) && !this.options.webSocketFactory;
  }
  get isBuilt() {
    return !!this.productService.commit;
  }
  get logLevel() {
    var _a43, _b, _c;
    const logLevelFromPayload = (_a43 = this.payload) == null ? void 0 : _a43.get("logLevel");
    if (logLevelFromPayload) {
      return logLevelFromPayload.split(",").find((entry) => !EXTENSION_IDENTIFIER_WITH_LOG_REGEX.test(entry));
    }
    return ((_b = this.options.developmentOptions) == null ? void 0 : _b.logLevel) !== void 0 ? LogLevelToString((_c = this.options.developmentOptions) == null ? void 0 : _c.logLevel) : void 0;
  }
  get extensionLogLevel() {
    var _a43, _b, _c;
    const logLevelFromPayload = (_a43 = this.payload) == null ? void 0 : _a43.get("logLevel");
    if (logLevelFromPayload) {
      const result = [];
      for (const entry of logLevelFromPayload.split(",")) {
        const matches = EXTENSION_IDENTIFIER_WITH_LOG_REGEX.exec(entry);
        if (matches && matches[1] && matches[2]) {
          result.push([matches[1], matches[2]]);
        }
      }
      return result.length ? result : void 0;
    }
    return ((_b = this.options.developmentOptions) == null ? void 0 : _b.extensionLogLevel) !== void 0 ? (_c = this.options.developmentOptions) == null ? void 0 : _c.extensionLogLevel.map(([extension, logLevel]) => [extension, LogLevelToString(logLevel)]) : void 0;
  }
  get profDurationMarkers() {
    var _a43;
    const profDurationMarkersFromPayload = (_a43 = this.payload) == null ? void 0 : _a43.get("profDurationMarkers");
    if (profDurationMarkersFromPayload) {
      const result = [];
      for (const entry of profDurationMarkersFromPayload.split(",")) {
        result.push(entry);
      }
      return result.length === 2 ? result : void 0;
    }
    return void 0;
  }
  get windowLogsPath() {
    return this.logsHome;
  }
  get logFile() {
    return joinPath(this.windowLogsPath, "window.log");
  }
  get userRoamingDataHome() {
    return URI.file("/User").with({ scheme: Schemas.vscodeUserData });
  }
  get argvResource() {
    return joinPath(this.userRoamingDataHome, "argv.json");
  }
  get cacheHome() {
    return joinPath(this.userRoamingDataHome, "caches");
  }
  get workspaceStorageHome() {
    return joinPath(this.userRoamingDataHome, "workspaceStorage");
  }
  get localHistoryHome() {
    return joinPath(this.userRoamingDataHome, "History");
  }
  get stateResource() {
    return joinPath(this.userRoamingDataHome, "State", "storage.json");
  }
  get userDataSyncHome() {
    return joinPath(this.userRoamingDataHome, "sync", this.workspaceId);
  }
  get sync() {
    return void 0;
  }
  get keyboardLayoutResource() {
    return joinPath(this.userRoamingDataHome, "keyboardLayout.json");
  }
  get untitledWorkspacesHome() {
    return joinPath(this.userRoamingDataHome, "Workspaces");
  }
  get serviceMachineIdResource() {
    return joinPath(this.userRoamingDataHome, "machineid");
  }
  get extHostLogsPath() {
    return joinPath(this.logsHome, "exthost");
  }
  get extHostTelemetryLogFile() {
    return joinPath(this.extHostLogsPath, "extensionTelemetry.log");
  }
  get debugExtensionHost() {
    if (!this.extensionHostDebugEnvironment) {
      this.extensionHostDebugEnvironment = this.resolveExtensionHostDebugEnvironment();
    }
    return this.extensionHostDebugEnvironment.params;
  }
  get isExtensionDevelopment() {
    if (!this.extensionHostDebugEnvironment) {
      this.extensionHostDebugEnvironment = this.resolveExtensionHostDebugEnvironment();
    }
    return this.extensionHostDebugEnvironment.isExtensionDevelopment;
  }
  get extensionDevelopmentLocationURI() {
    if (!this.extensionHostDebugEnvironment) {
      this.extensionHostDebugEnvironment = this.resolveExtensionHostDebugEnvironment();
    }
    return this.extensionHostDebugEnvironment.extensionDevelopmentLocationURI;
  }
  get extensionDevelopmentLocationKind() {
    if (!this.extensionHostDebugEnvironment) {
      this.extensionHostDebugEnvironment = this.resolveExtensionHostDebugEnvironment();
    }
    return this.extensionHostDebugEnvironment.extensionDevelopmentKind;
  }
  get extensionTestsLocationURI() {
    if (!this.extensionHostDebugEnvironment) {
      this.extensionHostDebugEnvironment = this.resolveExtensionHostDebugEnvironment();
    }
    return this.extensionHostDebugEnvironment.extensionTestsLocationURI;
  }
  get extensionEnabledProposedApi() {
    if (!this.extensionHostDebugEnvironment) {
      this.extensionHostDebugEnvironment = this.resolveExtensionHostDebugEnvironment();
    }
    return this.extensionHostDebugEnvironment.extensionEnabledProposedApi;
  }
  get debugRenderer() {
    if (!this.extensionHostDebugEnvironment) {
      this.extensionHostDebugEnvironment = this.resolveExtensionHostDebugEnvironment();
    }
    return this.extensionHostDebugEnvironment.debugRenderer;
  }
  get enableSmokeTestDriver() {
    var _a43;
    return (_a43 = this.options.developmentOptions) == null ? void 0 : _a43.enableSmokeTestDriver;
  }
  get disableExtensions() {
    var _a43;
    return ((_a43 = this.payload) == null ? void 0 : _a43.get("disableExtensions")) === "true";
  }
  get enableExtensions() {
    return this.options.enabledExtensions;
  }
  get webviewExternalEndpoint() {
    var _a43;
    const endpoint = this.options.webviewEndpoint || this.productService.webviewContentExternalBaseUrlTemplate || "https://{{uuid}}.vscode-cdn.net/{{quality}}/{{commit}}/out/vs/workbench/contrib/webview/browser/pre/";
    const webviewExternalEndpointCommit = (_a43 = this.payload) == null ? void 0 : _a43.get("webviewExternalEndpointCommit");
    return endpoint.replace("{{commit}}", webviewExternalEndpointCommit ?? this.productService.commit ?? "ef65ac1ba57f57f2a3961bfe94aa20481caca4c6").replace("{{quality}}", (webviewExternalEndpointCommit ? "insider" : this.productService.quality) ?? "insider");
  }
  get extensionTelemetryLogResource() {
    return joinPath(this.logsHome, "extensionTelemetry.log");
  }
  get disableTelemetry() {
    return false;
  }
  get verbose() {
    var _a43;
    return ((_a43 = this.payload) == null ? void 0 : _a43.get("verbose")) === "true";
  }
  get logExtensionHostCommunication() {
    var _a43;
    return ((_a43 = this.payload) == null ? void 0 : _a43.get("logExtensionHostCommunication")) === "true";
  }
  get skipReleaseNotes() {
    var _a43;
    return ((_a43 = this.payload) == null ? void 0 : _a43.get("skipReleaseNotes")) === "true";
  }
  get skipWelcome() {
    var _a43;
    return ((_a43 = this.payload) == null ? void 0 : _a43.get("skipWelcome")) === "true";
  }
  get disableWorkspaceTrust() {
    return !this.options.enableWorkspaceTrust;
  }
  get lastActiveProfile() {
    var _a43;
    return (_a43 = this.payload) == null ? void 0 : _a43.get("lastActiveProfile");
  }
  constructor(workspaceId, logsHome, options, productService) {
    this.workspaceId = workspaceId;
    this.logsHome = logsHome;
    this.options = options;
    this.productService = productService;
    this.extensionHostDebugEnvironment = void 0;
    this.editSessionId = this.options.editSessionId;
    if (options.workspaceProvider && Array.isArray(options.workspaceProvider.payload)) {
      try {
        this.payload = new Map(options.workspaceProvider.payload);
      } catch (error) {
        onUnexpectedError(error);
      }
    }
  }
  resolveExtensionHostDebugEnvironment() {
    var _a43;
    const extensionHostDebugEnvironment = {
      params: {
        port: null,
        break: false
      },
      debugRenderer: false,
      isExtensionDevelopment: false,
      extensionDevelopmentLocationURI: void 0,
      extensionDevelopmentKind: void 0
    };
    if (this.payload) {
      for (const [key, value] of this.payload) {
        switch (key) {
          case "extensionDevelopmentPath":
            if (!extensionHostDebugEnvironment.extensionDevelopmentLocationURI) {
              extensionHostDebugEnvironment.extensionDevelopmentLocationURI = [];
            }
            extensionHostDebugEnvironment.extensionDevelopmentLocationURI.push(URI.parse(value));
            extensionHostDebugEnvironment.isExtensionDevelopment = true;
            break;
          case "extensionDevelopmentKind":
            extensionHostDebugEnvironment.extensionDevelopmentKind = [value];
            break;
          case "extensionTestsPath":
            extensionHostDebugEnvironment.extensionTestsLocationURI = URI.parse(value);
            break;
          case "debugRenderer":
            extensionHostDebugEnvironment.debugRenderer = value === "true";
            break;
          case "debugId":
            extensionHostDebugEnvironment.params.debugId = value;
            break;
          case "inspect-brk-extensions":
            extensionHostDebugEnvironment.params.port = parseInt(value);
            extensionHostDebugEnvironment.params.break = true;
            break;
          case "inspect-extensions":
            extensionHostDebugEnvironment.params.port = parseInt(value);
            break;
          case "enableProposedApi":
            extensionHostDebugEnvironment.extensionEnabledProposedApi = [];
            break;
        }
      }
    }
    const developmentOptions = this.options.developmentOptions;
    if (developmentOptions && !extensionHostDebugEnvironment.isExtensionDevelopment) {
      if ((_a43 = developmentOptions.extensions) == null ? void 0 : _a43.length) {
        extensionHostDebugEnvironment.extensionDevelopmentLocationURI = developmentOptions.extensions.map((e) => URI.revive(e));
        extensionHostDebugEnvironment.isExtensionDevelopment = true;
      }
      if (developmentOptions.extensionTestsPath) {
        extensionHostDebugEnvironment.extensionTestsLocationURI = URI.revive(developmentOptions.extensionTestsPath);
      }
    }
    return extensionHostDebugEnvironment;
  }
  get filesToOpenOrCreate() {
    if (this.payload) {
      const fileToOpen = this.payload.get("openFile");
      if (fileToOpen) {
        const fileUri = URI.parse(fileToOpen);
        if (this.payload.has("gotoLineMode")) {
          const pathColumnAware = parseLineAndColumnAware(fileUri.path);
          return [{
            fileUri: fileUri.with({ path: pathColumnAware.path }),
            options: {
              selection: !isUndefined(pathColumnAware.line) ? { startLineNumber: pathColumnAware.line, startColumn: pathColumnAware.column || 1 } : void 0
            }
          }];
        }
        return [{ fileUri }];
      }
    }
    return void 0;
  }
  get filesToDiff() {
    if (this.payload) {
      const fileToDiffPrimary = this.payload.get("diffFilePrimary");
      const fileToDiffSecondary = this.payload.get("diffFileSecondary");
      if (fileToDiffPrimary && fileToDiffSecondary) {
        return [
          { fileUri: URI.parse(fileToDiffSecondary) },
          { fileUri: URI.parse(fileToDiffPrimary) }
        ];
      }
    }
    return void 0;
  }
  get filesToMerge() {
    if (this.payload) {
      const fileToMerge1 = this.payload.get("mergeFile1");
      const fileToMerge2 = this.payload.get("mergeFile2");
      const fileToMergeBase = this.payload.get("mergeFileBase");
      const fileToMergeResult = this.payload.get("mergeFileResult");
      if (fileToMerge1 && fileToMerge2 && fileToMergeBase && fileToMergeResult) {
        return [
          { fileUri: URI.parse(fileToMerge1) },
          { fileUri: URI.parse(fileToMerge2) },
          { fileUri: URI.parse(fileToMergeBase) },
          { fileUri: URI.parse(fileToMergeResult) }
        ];
      }
    }
    return void 0;
  }
};
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "remoteAuthority", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "expectsResolverExtension", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "isBuilt", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "logLevel", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "windowLogsPath", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "logFile", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "userRoamingDataHome", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "argvResource", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "cacheHome", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "workspaceStorageHome", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "localHistoryHome", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "stateResource", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "userDataSyncHome", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "sync", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "keyboardLayoutResource", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "untitledWorkspacesHome", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "serviceMachineIdResource", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "extHostLogsPath", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "extHostTelemetryLogFile", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "debugExtensionHost", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "isExtensionDevelopment", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "extensionDevelopmentLocationURI", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "extensionDevelopmentLocationKind", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "extensionTestsLocationURI", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "extensionEnabledProposedApi", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "debugRenderer", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "enableSmokeTestDriver", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "disableExtensions", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "enableExtensions", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "webviewExternalEndpoint", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "extensionTelemetryLogResource", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "disableTelemetry", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "verbose", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "logExtensionHostCommunication", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "skipReleaseNotes", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "skipWelcome", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "disableWorkspaceTrust", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "lastActiveProfile", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "filesToOpenOrCreate", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "filesToDiff", null);
BrowserWorkbenchEnvironmentService.__decorator = __decorate([
  memoize
], BrowserWorkbenchEnvironmentService.prototype, "filesToMerge", null);

// node_modules/vscode/vscode/src/vs/workbench/services/url/browser/urlService.js
init_opener();
var BrowserURLOpener = class {
  constructor(urlService, productService) {
    this.urlService = urlService;
    this.productService = productService;
  }
  async open(resource, options) {
    if (options == null ? void 0 : options.openExternal) {
      return false;
    }
    if (!matchesScheme(resource, this.productService.urlProtocol)) {
      return false;
    }
    if (typeof resource === "string") {
      resource = URI.parse(resource);
    }
    return this.urlService.open(resource, { trusted: true });
  }
};
var BrowserURLService = class BrowserURLService2 extends AbstractURLService {
  constructor(environmentService, openerService, productService) {
    var _a43;
    super();
    this.provider = (_a43 = environmentService.options) == null ? void 0 : _a43.urlCallbackProvider;
    if (this.provider) {
      this._register(this.provider.onCallback((uri) => this.open(uri, { trusted: true })));
    }
    this._register(openerService.registerOpener(new BrowserURLOpener(this, productService)));
  }
  create(options) {
    if (this.provider) {
      return this.provider.create(options);
    }
    return URI.parse("unsupported://");
  }
};
BrowserURLService = __decorate([
  __param(0, IBrowserWorkbenchEnvironmentService),
  __param(1, IOpenerService),
  __param(2, IProductService)
], BrowserURLService);

// node_modules/vscode/vscode/src/vs/platform/url/common/url.js
init_instantiation();
var IURLService = createDecorator("urlService");

// node_modules/vscode/vscode/src/vs/platform/credentials/common/credentials.js
init_instantiation();
var ICredentialsService = createDecorator("credentialsService");

// node_modules/vscode/vscode/src/vs/platform/remote/common/remoteSocketFactoryService.js
init_lifecycle();
init_instantiation();
var IRemoteSocketFactoryService = createDecorator("remoteSocketFactoryService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/scm/common/scm.js
init_instantiation();
var ISCMService = createDecorator("scm");
var ISCMViewService = createDecorator("scmView");

// node_modules/vscode/vscode/src/vs/platform/download/common/download.js
init_instantiation();
var IDownloadService = createDecorator("downloadService");

// node_modules/vscode/vscode/src/vs/workbench/services/extensions/browser/extensionUrlHandler.js
init_tslib_es6();
init_nls();
init_instantiation();
init_platform2();
init_actions2();
var ExtensionUrlBootstrapHandler_1;
var USER_TRUSTED_EXTENSIONS_STORAGE_KEY = "extensionUrlHandler.confirmedExtensions";
function isExtensionId(value) {
  return /^[a-z0-9][a-z0-9\-]*\.[a-z0-9][a-z0-9\-]*$/i.test(value);
}
var UserTrustedExtensionIdStorage = class {
  get extensions() {
    const userTrustedExtensionIdsJson = this.storageService.get(USER_TRUSTED_EXTENSIONS_STORAGE_KEY, 0, "[]");
    try {
      return JSON.parse(userTrustedExtensionIdsJson);
    } catch {
      return [];
    }
  }
  constructor(storageService) {
    this.storageService = storageService;
  }
  has(id) {
    return this.extensions.indexOf(id) > -1;
  }
  add(id) {
    this.set([...this.extensions, id]);
  }
  set(ids) {
    this.storageService.store(USER_TRUSTED_EXTENSIONS_STORAGE_KEY, JSON.stringify(ids), 0, 1);
  }
};
var IExtensionUrlHandler = createDecorator("extensionUrlHandler");
var _a21;
var ExtensionUrlBootstrapHandler = (_a21 = class {
  static get cache() {
    ExtensionUrlBootstrapHandler_1.disposable.dispose();
    const result = ExtensionUrlBootstrapHandler_1._cache;
    ExtensionUrlBootstrapHandler_1._cache = [];
    return result;
  }
  constructor(urlService) {
    ExtensionUrlBootstrapHandler_1.disposable = urlService.registerHandler(this);
  }
  async handleURL(uri, options) {
    if (!isExtensionId(uri.authority)) {
      return false;
    }
    ExtensionUrlBootstrapHandler_1._cache.push([uri, options]);
    return true;
  }
}, ExtensionUrlBootstrapHandler_1 = _a21, _a21._cache = [], _a21);
ExtensionUrlBootstrapHandler = ExtensionUrlBootstrapHandler_1 = __decorate([
  __param(0, IURLService)
], ExtensionUrlBootstrapHandler);
var workbenchRegistry = Registry.as(Extensions.Workbench);
workbenchRegistry.registerWorkbenchContribution(ExtensionUrlBootstrapHandler, 2);
var ManageAuthorizedExtensionURIsAction = class extends Action2 {
  constructor() {
    super({
      id: "workbench.extensions.action.manageAuthorizedExtensionURIs",
      title: { value: localize("manage", "Manage Authorized Extension URIs..."), original: "Manage Authorized Extension URIs..." },
      category: { value: localize("extensions", "Extensions"), original: "Extensions" },
      menu: {
        id: MenuId.CommandPalette,
        when: IsWebContext.toNegated()
      }
    });
  }
  async run(accessor) {
    const storageService = accessor.get(IStorageService);
    const quickInputService = accessor.get(IQuickInputService);
    const storage = new UserTrustedExtensionIdStorage(storageService);
    const items = storage.extensions.map((label) => ({ label, picked: true }));
    if (items.length === 0) {
      await quickInputService.pick([{ label: localize("no", "There are currently no authorized extension URIs.") }]);
      return;
    }
    const result = await quickInputService.pick(items, { canPickMany: true });
    if (!result) {
      return;
    }
    storage.set(result.map((item) => item.label));
  }
};
registerAction2(ManageAuthorizedExtensionURIsAction);

// node_modules/vscode/vscode/src/vs/workbench/contrib/comments/browser/commentService.js
init_instantiation();
var ICommentService = createDecorator("commentService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookCellStatusBarService.js
init_instantiation();
var INotebookCellStatusBarService = createDecorator("notebookCellStatusBarService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookKernelService.js
init_instantiation();
var INotebookKernelService = createDecorator("INotebookKernelService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookRendererMessagingService.js
init_instantiation();
var INotebookRendererMessagingService = createDecorator("INotebookRendererMessagingService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/interactive/browser/interactiveDocumentService.js
init_instantiation();
var IInteractiveDocumentService = createDecorator("IInteractiveDocumentService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/inlineChat/common/inlineChat.js
init_nls();
init_actions2();
init_configurationRegistry();
init_instantiation();
init_platform2();
init_colorRegistry();
var IInlineChatService = createDecorator("IInlineChatService");
MenuId.for("inlineChatWidget");
MenuId.for("inlineChatWidget.markdownMessage");
MenuId.for("inlineChatWidget.status");
MenuId.for("inlineChatWidget.feedback");
MenuId.for("inlineChatWidget.undo");
MenuId.for("inlineChatWidget.toggle");
registerColor("inlineChat.background", { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, localize(
  "inlineChat.background",
  "Background color of the interactive editor widget"
));
registerColor("inlineChat.border", { dark: editorWidgetBorder, light: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, localize("inlineChat.border", "Border color of the interactive editor widget"));
registerColor("inlineChat.shadow", { dark: widgetShadow, light: widgetShadow, hcDark: widgetShadow, hcLight: widgetShadow }, localize("inlineChat.shadow", "Shadow color of the interactive editor widget"));
registerColor("inlineChat.regionHighlight", { dark: editorHoverHighlight, light: editorHoverHighlight, hcDark: editorHoverHighlight, hcLight: editorHoverHighlight }, localize(
  "inlineChat.regionHighlight",
  "Background highlighting of the current interactive region. Must be transparent."
), true);
registerColor("inlineChatInput.border", { dark: editorWidgetBorder, light: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, localize("inlineChatInput.border", "Border color of the interactive editor input"));
registerColor("inlineChatInput.focusBorder", { dark: focusBorder, light: focusBorder, hcDark: focusBorder, hcLight: focusBorder }, localize(
  "inlineChatInput.focusBorder",
  "Border color of the interactive editor input when focused"
));
registerColor("inlineChatInput.placeholderForeground", { dark: inputPlaceholderForeground, light: inputPlaceholderForeground, hcDark: inputPlaceholderForeground, hcLight: inputPlaceholderForeground }, localize(
  "inlineChatInput.placeholderForeground",
  "Foreground color of the interactive editor input placeholder"
));
registerColor("inlineChatInput.background", { dark: inputBackground, light: inputBackground, hcDark: inputBackground, hcLight: inputBackground }, localize(
  "inlineChatInput.background",
  "Background color of the interactive editor input"
));
registerColor("inlineChatDiff.inserted", { dark: transparent(diffInserted, 0.5), light: transparent(diffInserted, 0.5), hcDark: transparent(diffInserted, 0.5), hcLight: transparent(diffInserted, 0.5) }, localize(
  "inlineChatDiff.inserted",
  "Background color of inserted text in the interactive editor input"
));
registerColor("inlineChatDiff.removed", { dark: transparent(diffRemoved, 0.5), light: transparent(diffRemoved, 0.5), hcDark: transparent(diffRemoved, 0.5), hcLight: transparent(diffRemoved, 0.5) }, localize(
  "inlineChatDiff.removed",
  "Background color of removed text in the interactive editor input"
));
Registry.as(Extensions3.ConfigurationMigration).registerConfigurationMigrations([{
  key: "interactiveEditor.editMode",
  migrateFn: (value) => {
    return [["inlineChat.mode", { value }]];
  }
}]);
Registry.as(Extensions2.Configuration).registerConfiguration({
  id: "editor",
  properties: {
    "inlineChat.mode": {
      description: localize(
        "mode",
        "Configure if changes crafted in the interactive editor are applied directly to the document or are previewed first."
      ),
      default: "livePreview",
      type: "string",
      enum: ["livePreview", "preview", "live"],
      markdownEnumDescriptions: [
        localize(
          "mode.livePreview",
          "Changes are applied directly to the document and are highlighted visually via inline or side-by-side diffs. Ending a session will keep the changes."
        ),
        localize(
          "mode.preview",
          "Changes are previewed only and need to be accepted via the apply button. Ending a session will discard the changes."
        ),
        localize(
          "mode.live",
          "Changes are applied directly to the document but can be highlighted via inline diffs. Ending a session will keep the changes."
        )
      ]
    },
    "inlineChat.showDiff": {
      description: localize(
        "showDiff",
        "Enable/disable showing the diff when edits are generated. Works only with inlineChat.mode equal to live or livePreview."
      ),
      default: true,
      type: "boolean"
    }
  }
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/chat/browser/chat.js
init_instantiation();
var IChatWidgetService = createDecorator("chatWidgetService");
var IQuickChatService = createDecorator("quickChatService");

// node_modules/vscode/vscode/src/vs/workbench/services/remote/common/remoteExplorerService.js
init_instantiation();
var IRemoteExplorerService = createDecorator("remoteExplorerService");
var PORT_AUTO_FORWARD_SETTING = "remote.autoForwardPorts";
var PORT_AUTO_SOURCE_SETTING = "remote.autoForwardPortsSource";
var PORT_AUTO_SOURCE_SETTING_OUTPUT = "output";
var TunnelType;
(function(TunnelType2) {
  TunnelType2["Candidate"] = "Candidate";
  TunnelType2["Detected"] = "Detected";
  TunnelType2["Forwarded"] = "Forwarded";
  TunnelType2["Add"] = "Add";
})(TunnelType || (TunnelType = {}));
var TunnelEditId;
(function(TunnelEditId2) {
  TunnelEditId2[TunnelEditId2["None"] = 0] = "None";
  TunnelEditId2[TunnelEditId2["New"] = 1] = "New";
  TunnelEditId2[TunnelEditId2["Label"] = 2] = "Label";
  TunnelEditId2[TunnelEditId2["LocalPort"] = 3] = "LocalPort";
})(TunnelEditId || (TunnelEditId = {}));

// node_modules/vscode/vscode/src/vs/workbench/services/authentication/common/authentication.js
init_instantiation();
var IAuthenticationService = createDecorator("IAuthenticationService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/timeline/common/timeline.js
init_instantiation();
var TIMELINE_SERVICE_ID = "timeline";
var ITimelineService = createDecorator(TIMELINE_SERVICE_ID);

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testService.js
init_instantiation();
var ITestService = createDecorator("testService");

// node_modules/vscode/vscode/src/vs/platform/secrets/common/secrets.js
init_instantiation();
var ISecretStorageService = createDecorator("secretStorageService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/share/common/share.js
init_instantiation();
var IShareService = createDecorator("shareService");

// node_modules/vscode/vscode/src/vs/workbench/services/issue/common/issue.js
init_instantiation();
var IWorkbenchIssueService = createDecorator("workbenchIssueService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookExecutionStateService.js
init_instantiation();
var NotebookExecutionType;
(function(NotebookExecutionType2) {
  NotebookExecutionType2[NotebookExecutionType2["cell"] = 0] = "cell";
  NotebookExecutionType2[NotebookExecutionType2["notebook"] = 1] = "notebook";
})(NotebookExecutionType || (NotebookExecutionType = {}));
var INotebookExecutionStateService = createDecorator("INotebookExecutionStateService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/chat/common/chatContributionService.js
init_instantiation();
var IChatContributionService = createDecorator("IChatContributionService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testProfileService.js
init_instantiation();
var ITestProfileService = createDecorator("testProfileService");

// node_modules/vscode/vscode/src/vs/platform/encryption/common/encryptionService.js
init_instantiation();
var IEncryptionService = createDecorator("encryptionService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testResultService.js
init_instantiation();
var ITestResultService = createDecorator("testResultService");

// node_modules/vscode/vscode/src/vs/platform/diagnostics/common/diagnostics.js
init_instantiation();
var ID = "diagnosticsService";
var IDiagnosticsService = createDecorator(ID);
var NullDiagnosticsService = class {
  async getPerformanceInfo(mainProcessInfo, remoteInfo) {
    return {};
  }
  async getSystemInfo(mainProcessInfo, remoteInfo) {
    return {
      processArgs: "nullProcessArgs",
      gpuStatus: "nullGpuStatus",
      screenReader: "nullScreenReader",
      remoteData: [],
      os: "nullOs",
      memory: "nullMemory",
      vmHint: "nullVmHint"
    };
  }
  async getDiagnostics(mainProcessInfo, remoteInfo) {
    return "";
  }
  async getWorkspaceFileExtensions(workspace) {
    return { extensions: [] };
  }
  async reportWorkspaceStats(workspace) {
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/chat/common/chatProvider.js
init_instantiation();
var IChatProviderService = createDecorator("chatProviderService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/chat/common/chatSlashCommands.js
init_instantiation();
var IChatSlashCommandService = createDecorator("chatSlashCommandService");

// node_modules/vscode/vscode/src/vs/workbench/contrib/chat/common/chatVariables.js
init_instantiation();
var IChatVariablesService = createDecorator("IChatVariablesService");

// node_modules/vscode/vscode/src/vs/workbench/services/aiRelatedInformation/common/aiRelatedInformation.js
init_instantiation();
var IAiRelatedInformationService = createDecorator("IAiRelatedInformationService");
var RelatedInformationType;
(function(RelatedInformationType2) {
  RelatedInformationType2[RelatedInformationType2["SymbolInformation"] = 1] = "SymbolInformation";
  RelatedInformationType2[RelatedInformationType2["CommandInformation"] = 2] = "CommandInformation";
  RelatedInformationType2[RelatedInformationType2["SearchInformation"] = 3] = "SearchInformation";
  RelatedInformationType2[RelatedInformationType2["SettingInformation"] = 4] = "SettingInformation";
})(RelatedInformationType || (RelatedInformationType = {}));

// node_modules/vscode/vscode/src/vs/workbench/services/aiEmbeddingVector/common/aiEmbeddingVectorService.js
init_tslib_es6();
init_instantiation();
init_async();
init_stopwatch();
init_log();
var AiEmbeddingVectorService_1;
var IAiEmbeddingVectorService = createDecorator("IAiEmbeddingVectorService");
var _a22;
var AiEmbeddingVectorService = (_a22 = class {
  constructor(logService) {
    this.logService = logService;
    this._providers = [];
  }
  isEnabled() {
    return this._providers.length > 0;
  }
  registerAiEmbeddingVectorProvider(model, provider) {
    this._providers.push(provider);
    return {
      dispose: () => {
        const index = this._providers.indexOf(provider);
        if (index >= 0) {
          this._providers.splice(index, 1);
        }
      }
    };
  }
  async getEmbeddingVector(strings, token) {
    if (this._providers.length === 0) {
      throw new Error("No embedding vector providers registered");
    }
    const stopwatch = StopWatch.create();
    const cancellablePromises = [];
    const timer = timeout(AiEmbeddingVectorService_1.DEFAULT_TIMEOUT);
    const disposable = token.onCancellationRequested(() => {
      disposable.dispose();
      timer.cancel();
    });
    for (const provider of this._providers) {
      cancellablePromises.push(createCancelablePromise(async (t) => {
        try {
          return await provider.provideAiEmbeddingVector(Array.isArray(strings) ? strings : [strings], t);
        } catch (e) {
        }
        await timer;
        throw new Error("Embedding vector provider timed out");
      }));
    }
    cancellablePromises.push(createCancelablePromise(async (t) => {
      const disposable2 = t.onCancellationRequested(() => {
        timer.cancel();
        disposable2.dispose();
      });
      await timer;
      throw new Error("Embedding vector provider timed out");
    }));
    try {
      const result = await raceCancellablePromises(cancellablePromises);
      if (result.length === 1) {
        return result[0];
      }
      return result;
    } finally {
      stopwatch.stop();
      this.logService.trace(`[AiEmbeddingVectorService]: getEmbeddingVector took ${stopwatch.elapsed()}ms`);
    }
  }
}, AiEmbeddingVectorService_1 = _a22, _a22.DEFAULT_TIMEOUT = 1e3 * 10, _a22);
AiEmbeddingVectorService = AiEmbeddingVectorService_1 = __decorate([
  __param(0, ILogService)
], AiEmbeddingVectorService);

// node_modules/vscode/missing-services.js
init_map();

// node_modules/vscode/vscode/src/vs/platform/sign/common/sign.js
init_instantiation();
var SIGN_SERVICE_ID = "signService";
var ISignService = createDecorator(SIGN_SERVICE_ID);

// node_modules/vscode/vscode/src/vs/workbench/services/host/browser/browserHostService.js
init_tslib_es6();
init_event();
init_configuration();

// node_modules/vscode/vscode/src/vs/platform/window/common/window.js
init_platform();
function isWorkspaceToOpen(uriToOpen) {
  return !!uriToOpen.workspaceUri;
}
function isFolderToOpen(uriToOpen) {
  return !!uriToOpen.folderUri;
}
function isFileToOpen(uriToOpen) {
  return !!uriToOpen.fileUri;
}

// node_modules/vscode/vscode/src/vs/workbench/browser/editor.js
init_nls();
init_platform2();
init_lifecycle();
init_async();
init_network();
init_iterator();
var EditorPaneDescriptor = class _EditorPaneDescriptor {
  static create(ctor, typeId, name) {
    return new _EditorPaneDescriptor(ctor, typeId, name);
  }
  constructor(ctor, typeId, name) {
    this.ctor = ctor;
    this.typeId = typeId;
    this.name = name;
  }
  instantiate(instantiationService) {
    return instantiationService.createInstance(this.ctor);
  }
  describes(editorPane) {
    return editorPane.getId() === this.typeId;
  }
};
var EditorPaneRegistry = class {
  constructor() {
    this.mapEditorPanesToEditors = /* @__PURE__ */ new Map();
  }
  registerEditorPane(editorPaneDescriptor, editorDescriptors) {
    this.mapEditorPanesToEditors.set(editorPaneDescriptor, editorDescriptors);
    return toDisposable(() => {
      this.mapEditorPanesToEditors.delete(editorPaneDescriptor);
    });
  }
  getEditorPane(editor) {
    const descriptors = this.findEditorPaneDescriptors(editor);
    if (descriptors.length === 0) {
      return void 0;
    }
    if (descriptors.length === 1) {
      return descriptors[0];
    }
    return editor.prefersEditorPane(descriptors);
  }
  findEditorPaneDescriptors(editor, byInstanceOf) {
    const matchingEditorPaneDescriptors = [];
    for (const editorPane of this.mapEditorPanesToEditors.keys()) {
      const editorDescriptors = this.mapEditorPanesToEditors.get(editorPane) || [];
      for (const editorDescriptor of editorDescriptors) {
        const editorClass = editorDescriptor.ctor;
        if (!byInstanceOf && editor.constructor === editorClass) {
          matchingEditorPaneDescriptors.push(editorPane);
          break;
        } else if (byInstanceOf && editor instanceof editorClass) {
          matchingEditorPaneDescriptors.push(editorPane);
          break;
        }
      }
    }
    if (!byInstanceOf && matchingEditorPaneDescriptors.length === 0) {
      return this.findEditorPaneDescriptors(editor, true);
    }
    return matchingEditorPaneDescriptors;
  }
  getEditorPaneByType(typeId) {
    return Iterable.find(this.mapEditorPanesToEditors.keys(), (editor) => editor.typeId === typeId);
  }
  getEditorPanes() {
    return Array.from(this.mapEditorPanesToEditors.keys());
  }
  getEditors() {
    const editorClasses = [];
    for (const editorPane of this.mapEditorPanesToEditors.keys()) {
      const editorDescriptors = this.mapEditorPanesToEditors.get(editorPane);
      if (editorDescriptors) {
        editorClasses.push(...editorDescriptors.map((editorDescriptor) => editorDescriptor.ctor));
      }
    }
    return editorClasses;
  }
};
Registry.add(EditorExtensions.EditorPane, new EditorPaneRegistry());
function whenEditorClosed(accessor, resources) {
  const editorService = accessor.get(IEditorService);
  const uriIdentityService = accessor.get(IUriIdentityService);
  const workingCopyService = accessor.get(IWorkingCopyService);
  return new Promise((resolve) => {
    let remainingResources = [...resources];
    const listener = editorService.onDidCloseEditor(async (event) => {
      if (event.context === EditorCloseContext.MOVE) {
        return;
      }
      let primaryResource = EditorResourceAccessor.getOriginalUri(event.editor, { supportSideBySide: SideBySideEditor.PRIMARY });
      let secondaryResource = EditorResourceAccessor.getOriginalUri(event.editor, { supportSideBySide: SideBySideEditor.SECONDARY });
      if (event.context === EditorCloseContext.REPLACE) {
        const newPrimaryResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
        const newSecondaryResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.SECONDARY });
        if (uriIdentityService.extUri.isEqual(primaryResource, newPrimaryResource)) {
          primaryResource = void 0;
        }
        if (uriIdentityService.extUri.isEqual(secondaryResource, newSecondaryResource)) {
          secondaryResource = void 0;
        }
      }
      remainingResources = remainingResources.filter((resource) => {
        if (uriIdentityService.extUri.isEqual(resource, primaryResource) || uriIdentityService.extUri.isEqual(resource, secondaryResource)) {
          return false;
        }
        if (event.context !== EditorCloseContext.REPLACE) {
          if ((primaryResource == null ? void 0 : primaryResource.scheme) === Schemas.untitled && uriIdentityService.extUri.isEqual(resource, primaryResource.with({ scheme: resource.scheme })) || (secondaryResource == null ? void 0 : secondaryResource.scheme) === Schemas.untitled && uriIdentityService.extUri.isEqual(resource, secondaryResource.with({ scheme: resource.scheme }))) {
            return false;
          }
        }
        return true;
      });
      if (remainingResources.length === 0) {
        const dirtyResources = resources.filter((resource) => workingCopyService.isDirty(resource));
        if (dirtyResources.length > 0) {
          await Promises.settled(dirtyResources.map(async (resource) => await new Promise((resolve2) => {
            if (!workingCopyService.isDirty(resource)) {
              return resolve2();
            }
            const listener2 = workingCopyService.onDidChangeDirty((workingCopy) => {
              if (!workingCopy.isDirty() && uriIdentityService.extUri.isEqual(resource, workingCopy.resource)) {
                listener2.dispose();
                return resolve2();
              }
            });
          })));
        }
        listener.dispose();
        return resolve();
      }
    });
  });
}
function computeEditorAriaLabel(input, index, group, groupCount) {
  let ariaLabel = input.getAriaLabel();
  if (group && !group.isPinned(input)) {
    ariaLabel = localize("preview", "{0}, preview", ariaLabel);
  }
  if (group == null ? void 0 : group.isSticky(index ?? input)) {
    ariaLabel = localize("pinned", "{0}, pinned", ariaLabel);
  }
  if (group && typeof groupCount === "number" && groupCount > 1) {
    ariaLabel = `${ariaLabel}, ${group.ariaLabel}`;
  }
  return ariaLabel;
}

// node_modules/vscode/vscode/src/vs/workbench/services/host/browser/browserHostService.js
init_files();
init_dom();
init_lifecycle();
init_extpath();
init_instantiation();
init_log();

// node_modules/vscode/vscode/src/vs/workbench/services/workspaces/browser/workspaces.js
init_hash();
function getWorkspaceIdentifier(workspaceUri) {
  return {
    id: getWorkspaceId(workspaceUri),
    configPath: workspaceUri
  };
}
function getWorkspaceId(uri) {
  return hash(uri.toString()).toString(16);
}

// node_modules/vscode/vscode/src/vs/workbench/services/host/browser/browserHostService.js
init_nls();
init_types();
init_network();
init_arrays();
var HostShutdownReason;
(function(HostShutdownReason2) {
  HostShutdownReason2[HostShutdownReason2["Unknown"] = 1] = "Unknown";
  HostShutdownReason2[HostShutdownReason2["Keyboard"] = 2] = "Keyboard";
  HostShutdownReason2[HostShutdownReason2["Api"] = 3] = "Api";
})(HostShutdownReason || (HostShutdownReason = {}));
var BrowserHostService = class BrowserHostService2 extends Disposable {
  constructor(layoutService, configurationService, fileService, labelService, environmentService, instantiationService, lifecycleService, logService, dialogService, contextService, userDataProfileService) {
    var _a43;
    super();
    this.layoutService = layoutService;
    this.configurationService = configurationService;
    this.fileService = fileService;
    this.labelService = labelService;
    this.environmentService = environmentService;
    this.instantiationService = instantiationService;
    this.lifecycleService = lifecycleService;
    this.logService = logService;
    this.dialogService = dialogService;
    this.contextService = contextService;
    this.userDataProfileService = userDataProfileService;
    this.shutdownReason = HostShutdownReason.Unknown;
    if ((_a43 = environmentService.options) == null ? void 0 : _a43.workspaceProvider) {
      this.workspaceProvider = environmentService.options.workspaceProvider;
    } else {
      this.workspaceProvider = new class {
        constructor() {
          this.workspace = void 0;
          this.trusted = void 0;
        }
        async open() {
          return true;
        }
      }();
    }
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.lifecycleService.onBeforeShutdown((e) => this.onBeforeShutdown(e)));
    this._register(ModifierKeyEmitter.getInstance().event(() => this.updateShutdownReasonFromEvent()));
  }
  onBeforeShutdown(e) {
    switch (this.shutdownReason) {
      case HostShutdownReason.Unknown:
      case HostShutdownReason.Keyboard: {
        const confirmBeforeClose = this.configurationService.getValue("window.confirmBeforeClose");
        if (confirmBeforeClose === "always" || confirmBeforeClose === "keyboardOnly" && this.shutdownReason === HostShutdownReason.Keyboard) {
          e.veto(true, "veto.confirmBeforeClose");
        }
        break;
      }
    }
    this.shutdownReason = HostShutdownReason.Unknown;
  }
  updateShutdownReasonFromEvent() {
    if (this.shutdownReason === HostShutdownReason.Api) {
      return;
    }
    if (ModifierKeyEmitter.getInstance().isModifierPressed) {
      this.shutdownReason = HostShutdownReason.Keyboard;
    } else {
      this.shutdownReason = HostShutdownReason.Unknown;
    }
  }
  get onDidChangeFocus() {
    const focusTracker = this._register(trackFocus(window));
    const onVisibilityChange = this._register(new DomEmitter(window.document, "visibilitychange"));
    return Event.latch(Event.any(Event.map(focusTracker.onDidFocus, () => this.hasFocus), Event.map(focusTracker.onDidBlur, () => this.hasFocus), Event.map(onVisibilityChange.event, () => this.hasFocus)));
  }
  get hasFocus() {
    return document.hasFocus();
  }
  async hadLastFocus() {
    return true;
  }
  async focus() {
    window.focus();
  }
  openWindow(arg1, arg2) {
    if (Array.isArray(arg1)) {
      return this.doOpenWindow(arg1, arg2);
    }
    return this.doOpenEmptyWindow(arg1);
  }
  async doOpenWindow(toOpen, options) {
    const payload = this.preservePayload(false);
    const fileOpenables = [];
    const foldersToAdd = [];
    for (const openable of toOpen) {
      openable.label = openable.label || this.getRecentLabel(openable);
      if (isFolderToOpen(openable)) {
        if (options == null ? void 0 : options.addMode) {
          foldersToAdd.push({ uri: openable.folderUri });
        } else {
          this.doOpen({ folderUri: openable.folderUri }, { reuse: this.shouldReuse(options, false), payload });
        }
      } else if (isWorkspaceToOpen(openable)) {
        this.doOpen({ workspaceUri: openable.workspaceUri }, { reuse: this.shouldReuse(options, false), payload });
      } else if (isFileToOpen(openable)) {
        fileOpenables.push(openable);
      }
    }
    if (foldersToAdd.length > 0) {
      this.withServices((accessor) => {
        const workspaceEditingService = accessor.get(IWorkspaceEditingService);
        workspaceEditingService.addFolders(foldersToAdd);
      });
    }
    if (fileOpenables.length > 0) {
      this.withServices(async (accessor) => {
        const editorService = accessor.get(IEditorService);
        if ((options == null ? void 0 : options.mergeMode) && fileOpenables.length === 4) {
          const editors = coalesce(await pathsToEditors(fileOpenables, this.fileService, this.logService));
          if (editors.length !== 4 || !isResourceEditorInput(editors[0]) || !isResourceEditorInput(editors[1]) || !isResourceEditorInput(editors[2]) || !isResourceEditorInput(editors[3])) {
            return;
          }
          if (this.shouldReuse(options, true)) {
            editorService.openEditor({
              input1: { resource: editors[0].resource },
              input2: { resource: editors[1].resource },
              base: { resource: editors[2].resource },
              result: { resource: editors[3].resource },
              options: { pinned: true }
            });
          } else {
            const environment = /* @__PURE__ */ new Map();
            environment.set("mergeFile1", editors[0].resource.toString());
            environment.set("mergeFile2", editors[1].resource.toString());
            environment.set("mergeFileBase", editors[2].resource.toString());
            environment.set("mergeFileResult", editors[3].resource.toString());
            this.doOpen(void 0, { payload: Array.from(environment.entries()) });
          }
        }
        if ((options == null ? void 0 : options.diffMode) && fileOpenables.length === 2) {
          const editors = coalesce(await pathsToEditors(fileOpenables, this.fileService, this.logService));
          if (editors.length !== 2 || !isResourceEditorInput(editors[0]) || !isResourceEditorInput(editors[1])) {
            return;
          }
          if (this.shouldReuse(options, true)) {
            editorService.openEditor({
              original: { resource: editors[0].resource },
              modified: { resource: editors[1].resource },
              options: { pinned: true }
            });
          } else {
            const environment = /* @__PURE__ */ new Map();
            environment.set("diffFileSecondary", editors[0].resource.toString());
            environment.set("diffFilePrimary", editors[1].resource.toString());
            this.doOpen(void 0, { payload: Array.from(environment.entries()) });
          }
        } else {
          for (const openable of fileOpenables) {
            if (this.shouldReuse(options, true)) {
              let openables = [];
              if (options == null ? void 0 : options.gotoLineMode) {
                const pathColumnAware = parseLineAndColumnAware(openable.fileUri.path);
                openables = [{
                  fileUri: openable.fileUri.with({ path: pathColumnAware.path }),
                  options: {
                    selection: !isUndefined(pathColumnAware.line) ? { startLineNumber: pathColumnAware.line, startColumn: pathColumnAware.column || 1 } : void 0
                  }
                }];
              } else {
                openables = [openable];
              }
              editorService.openEditors(coalesce(await pathsToEditors(openables, this.fileService, this.logService)), void 0, { validateTrust: true });
            } else {
              const environment = /* @__PURE__ */ new Map();
              environment.set("openFile", openable.fileUri.toString());
              if (options == null ? void 0 : options.gotoLineMode) {
                environment.set("gotoLineMode", "true");
              }
              this.doOpen(void 0, { payload: Array.from(environment.entries()) });
            }
          }
        }
        const waitMarkerFileURI = options == null ? void 0 : options.waitMarkerFileURI;
        if (waitMarkerFileURI) {
          (async () => {
            await this.instantiationService.invokeFunction((accessor2) => whenEditorClosed(accessor2, fileOpenables.map((fileOpenable) => fileOpenable.fileUri)));
            await this.fileService.del(waitMarkerFileURI);
          })();
        }
      });
    }
  }
  withServices(fn) {
    this.instantiationService.invokeFunction((accessor) => fn(accessor));
  }
  preservePayload(isEmptyWindow) {
    const newPayload = new Array();
    if (!isEmptyWindow && this.environmentService.extensionDevelopmentLocationURI) {
      newPayload.push(["extensionDevelopmentPath", this.environmentService.extensionDevelopmentLocationURI.toString()]);
      if (this.environmentService.debugExtensionHost.debugId) {
        newPayload.push(["debugId", this.environmentService.debugExtensionHost.debugId]);
      }
      if (this.environmentService.debugExtensionHost.port) {
        newPayload.push(["inspect-brk-extensions", String(this.environmentService.debugExtensionHost.port)]);
      }
    }
    if (!this.userDataProfileService.currentProfile.isDefault) {
      newPayload.push(["lastActiveProfile", this.userDataProfileService.currentProfile.id]);
    }
    return newPayload.length ? newPayload : void 0;
  }
  getRecentLabel(openable) {
    if (isFolderToOpen(openable)) {
      return this.labelService.getWorkspaceLabel(openable.folderUri, { verbose: 2 });
    }
    if (isWorkspaceToOpen(openable)) {
      return this.labelService.getWorkspaceLabel(getWorkspaceIdentifier(openable.workspaceUri), { verbose: 2 });
    }
    return this.labelService.getUriLabel(openable.fileUri);
  }
  shouldReuse(options = /* @__PURE__ */ Object.create(null), isFile) {
    if (options.waitMarkerFileURI) {
      return true;
    }
    const windowConfig = this.configurationService.getValue("window");
    const openInNewWindowConfig = isFile ? (windowConfig == null ? void 0 : windowConfig.openFilesInNewWindow) || "off" : (windowConfig == null ? void 0 : windowConfig.openFoldersInNewWindow) || "default";
    let openInNewWindow = (options.preferNewWindow || !!options.forceNewWindow) && !options.forceReuseWindow;
    if (!options.forceNewWindow && !options.forceReuseWindow && (openInNewWindowConfig === "on" || openInNewWindowConfig === "off")) {
      openInNewWindow = openInNewWindowConfig === "on";
    }
    return !openInNewWindow;
  }
  async doOpenEmptyWindow(options) {
    return this.doOpen(void 0, {
      reuse: options == null ? void 0 : options.forceReuseWindow,
      payload: this.preservePayload(true)
    });
  }
  async doOpen(workspace, options) {
    if (workspace && isFolderToOpen(workspace) && workspace.folderUri.scheme === Schemas.file && isTemporaryWorkspace(this.contextService.getWorkspace())) {
      this.withServices(async (accessor) => {
        const workspaceEditingService = accessor.get(IWorkspaceEditingService);
        await workspaceEditingService.updateFolders(0, this.contextService.getWorkspace().folders.length, [{ uri: workspace.folderUri }]);
      });
      return;
    }
    if (options == null ? void 0 : options.reuse) {
      await this.handleExpectedShutdown(4);
    }
    const opened = await this.workspaceProvider.open(workspace, options);
    if (!opened) {
      const { confirmed } = await this.dialogService.confirm({
        type: severity_default.Warning,
        message: localize(
          "unableToOpenExternal",
          "The browser interrupted the opening of a new tab or window. Press 'Open' to open it anyway."
        ),
        primaryButton: localize({ key: "open", comment: ["&& denotes a mnemonic"] }, "&&Open")
      });
      if (confirmed) {
        await this.workspaceProvider.open(workspace, options);
      }
    }
  }
  async toggleFullScreen() {
    const target = this.layoutService.container;
    if (document.fullscreen !== void 0) {
      if (!document.fullscreen) {
        try {
          return await target.requestFullscreen();
        } catch (error) {
          this.logService.warn("toggleFullScreen(): requestFullscreen failed");
        }
      } else {
        try {
          return await document.exitFullscreen();
        } catch (error) {
          this.logService.warn("toggleFullScreen(): exitFullscreen failed");
        }
      }
    }
    if (document.webkitIsFullScreen !== void 0) {
      try {
        if (!document.webkitIsFullScreen) {
          target.webkitRequestFullscreen();
        } else {
          document.webkitExitFullscreen();
        }
      } catch {
        this.logService.warn("toggleFullScreen(): requestFullscreen/exitFullscreen failed");
      }
    }
  }
  async restart() {
    this.reload();
  }
  async reload() {
    await this.handleExpectedShutdown(3);
    window.location.reload();
  }
  async close() {
    await this.handleExpectedShutdown(1);
    window.close();
  }
  async withExpectedShutdown(expectedShutdownTask) {
    const previousShutdownReason = this.shutdownReason;
    try {
      this.shutdownReason = HostShutdownReason.Api;
      return await expectedShutdownTask();
    } finally {
      this.shutdownReason = previousShutdownReason;
    }
  }
  async handleExpectedShutdown(reason) {
    this.shutdownReason = HostShutdownReason.Api;
    return this.lifecycleService.withExpectedShutdown(reason);
  }
};
BrowserHostService.__decorator = __decorate([
  memoize
], BrowserHostService.prototype, "onDidChangeFocus", null);
BrowserHostService = __decorate([
  __param(0, ILayoutService),
  __param(1, IConfigurationService),
  __param(2, IFileService),
  __param(3, ILabelService),
  __param(4, IBrowserWorkbenchEnvironmentService),
  __param(5, IInstantiationService),
  __param(6, ILifecycleService),
  __param(7, ILogService),
  __param(8, IDialogService),
  __param(9, IWorkspaceContextService),
  __param(10, IUserDataProfileService)
], BrowserHostService);

// node_modules/vscode/vscode/src/vs/workbench/services/banner/browser/bannerService.js
init_instantiation();
var IBannerService = createDecorator("bannerService");

// node_modules/vscode/vscode/src/vs/workbench/services/title/common/titleService.js
init_instantiation();
var ITitleService = createDecorator("titleService");

// node_modules/vscode/tools.js
function unsupported() {
  throw new Error("unsupported");
}
function memoized(fct) {
  let v = null;
  return (...args) => {
    if (v == null) {
      v = fct(...args);
    }
    return v;
  };
}
function memoizedConstructor(ctor) {
  return new Proxy(ctor, {
    construct: memoized((target, args) => {
      return Reflect.construct(ctor, args);
    })
  });
}

// node_modules/vscode/missing-services.js
var _a23;
var NullLoggerService = class extends AbstractLoggerService {
  constructor() {
    super(LogLevel.Info, URI.file("logs.log"));
  }
  doCreateLogger() {
    return new NullLogger();
  }
};
registerSingleton(ILoggerService, NullLoggerService, 0);
registerSingleton(IEditorService, class EditorService {
  constructor() {
    this._serviceBrand = void 0;
    this.onDidActiveEditorChange = Event.None;
    this.onDidVisibleEditorsChange = Event.None;
    this.onDidEditorsChange = Event.None;
    this.onDidCloseEditor = Event.None;
    this.activeEditorPane = void 0;
    this.activeEditor = void 0;
    this.activeTextEditorLanguageId = void 0;
    this.visibleEditorPanes = [];
    this.visibleEditors = [];
    this.visibleTextEditorControls = [];
    this.editors = [];
    this.count = 0;
    this.getEditors = () => [];
    this.openEditor = unsupported;
    this.openEditors = unsupported;
    this.replaceEditors = async () => {
    };
    this.isOpened = () => false;
    this.isVisible = () => false;
    this.closeEditor = async () => {
    };
    this.closeEditors = async () => {
    };
    this.findEditors = () => [];
    this.save = async () => ({ success: false, editors: [] });
    this.saveAll = async () => ({ success: false, editors: [] });
    this.revert = async () => false;
    this.revertAll = async () => false;
  }
  get activeTextEditorControl() {
    return StandaloneServices.get(ICodeEditorService).getFocusedCodeEditor() ?? void 0;
  }
}, 0);
registerSingleton(IPaneCompositePartService, class PaneCompositePartService {
  constructor() {
    this._serviceBrand = void 0;
    this.onDidPaneCompositeOpen = Event.None;
    this.onDidPaneCompositeClose = Event.None;
    this.openPaneComposite = async () => void 0;
    this.getActivePaneComposite = () => void 0;
    this.getPaneComposite = () => void 0;
    this.getPaneComposites = () => [];
    this.getPinnedPaneCompositeIds = () => [];
    this.getVisiblePaneCompositeIds = () => [];
    this.getProgressIndicator = () => void 0;
    this.hideActivePaneComposite = () => {
    };
    this.getLastActivePaneCompositeId = unsupported;
    this.showActivity = () => Disposable.None;
  }
}, 0);
registerSingleton(IUriIdentityService, UriIdentityService, 1);
registerSingleton(ITextFileService, BrowserTextFileService, 0);
registerSingleton(IFileService, class FileService {
  constructor() {
    this._serviceBrand = void 0;
    this.onDidChangeFileSystemProviderRegistrations = Event.None;
    this.onDidChangeFileSystemProviderCapabilities = Event.None;
    this.onWillActivateFileSystemProvider = Event.None;
    this.registerProvider = unsupported;
    this.getProvider = function() {
      return void 0;
    };
    this.activateProvider = async () => {
    };
    this.canHandleResource = async () => false;
    this.hasProvider = () => false;
    this.hasCapability = () => false;
    this.listCapabilities = () => [];
    this.onDidFilesChange = Event.None;
    this.onDidRunOperation = Event.None;
    this.resolve = unsupported;
    this.resolveAll = unsupported;
    this.stat = unsupported;
    this.exists = async () => false;
    this.readFile = unsupported;
    this.readFileStream = unsupported;
    this.writeFile = unsupported;
    this.move = unsupported;
    this.canMove = unsupported;
    this.copy = unsupported;
    this.canCopy = unsupported;
    this.cloneFile = unsupported;
    this.createFile = unsupported;
    this.canCreateFile = unsupported;
    this.createFolder = unsupported;
    this.del = unsupported;
    this.canDelete = unsupported;
    this.onDidWatchError = Event.None;
    this.watch = unsupported;
  }
  dispose() {
  }
}, 0);
var EmptyEditorGroup = class {
  constructor() {
    this.onDidFocus = Event.None;
    this.onDidOpenEditorFail = Event.None;
    this.whenRestored = Promise.resolve();
    this.disposed = false;
    this.setActive = unsupported;
    this.notifyIndexChanged = unsupported;
    this.relayout = unsupported;
    this.dispose = unsupported;
    this.toJSON = unsupported;
    this.minimumWidth = 0;
    this.maximumWidth = Number.POSITIVE_INFINITY;
    this.minimumHeight = 0;
    this.maximumHeight = Number.POSITIVE_INFINITY;
    this.onDidChange = Event.None;
    this.layout = unsupported;
    this.onDidModelChange = Event.None;
    this.onWillDispose = Event.None;
    this.onDidActiveEditorChange = Event.None;
    this.onWillCloseEditor = Event.None;
    this.onDidCloseEditor = Event.None;
    this.onWillMoveEditor = Event.None;
    this.onWillOpenEditor = Event.None;
    this.id = 0;
    this.index = 0;
    this.label = "main";
    this.ariaLabel = "main";
    this.activeEditorPane = void 0;
    this.activeEditor = null;
    this.previewEditor = null;
    this.count = 0;
    this.isEmpty = false;
    this.isLocked = false;
    this.stickyCount = 0;
    this.editors = [];
    this.getEditors = () => [];
    this.findEditors = () => [];
    this.getEditorByIndex = () => void 0;
    this.getIndexOfEditor = unsupported;
    this.openEditor = unsupported;
    this.openEditors = unsupported;
    this.isPinned = () => false;
    this.isSticky = () => false;
    this.isActive = () => false;
    this.contains = () => false;
    this.moveEditor = unsupported;
    this.moveEditors = unsupported;
    this.copyEditor = unsupported;
    this.copyEditors = unsupported;
    this.closeEditor = unsupported;
    this.closeEditors = unsupported;
    this.closeAllEditors = unsupported;
    this.replaceEditors = unsupported;
    this.pinEditor = unsupported;
    this.stickEditor = unsupported;
    this.unstickEditor = unsupported;
    this.lock = unsupported;
    this.isFirst = unsupported;
    this.isLast = unsupported;
  }
  get titleHeight() {
    return unsupported();
  }
  get element() {
    return unsupported();
  }
  get scopedContextKeyService() {
    return StandaloneServices.get(IContextKeyService);
  }
  focus() {
  }
};
var fakeActiveGroup = new EmptyEditorGroup();
var EmptyEditorGroupsService = class {
  constructor() {
    this._serviceBrand = void 0;
    this.getLayout = unsupported;
    this.onDidChangeActiveGroup = Event.None;
    this.onDidAddGroup = Event.None;
    this.onDidRemoveGroup = Event.None;
    this.onDidMoveGroup = Event.None;
    this.onDidActivateGroup = Event.None;
    this.onDidLayout = Event.None;
    this.onDidScroll = Event.None;
    this.onDidChangeGroupIndex = Event.None;
    this.onDidChangeGroupLocked = Event.None;
    this.activeGroup = fakeActiveGroup;
    this.groups = [fakeActiveGroup];
    this.count = 0;
    this.orientation = 0;
    this.isReady = false;
    this.whenReady = Promise.resolve();
    this.whenRestored = Promise.resolve();
    this.hasRestorableState = false;
    this.getGroups = () => [];
    this.getGroup = () => void 0;
    this.activateGroup = unsupported;
    this.getSize = unsupported;
    this.setSize = unsupported;
    this.arrangeGroups = unsupported;
    this.applyLayout = unsupported;
    this.centerLayout = unsupported;
    this.isLayoutCentered = () => false;
    this.setGroupOrientation = unsupported;
    this.findGroup = () => void 0;
    this.addGroup = unsupported;
    this.removeGroup = unsupported;
    this.moveGroup = unsupported;
    this.mergeGroup = unsupported;
    this.mergeAllGroups = unsupported;
    this.copyGroup = unsupported;
    this.partOptions = {};
    this.onDidChangeEditorPartOptions = Event.None;
    this.enforcePartOptions = unsupported;
  }
  get contentDimension() {
    return unsupported();
  }
  get sideGroup() {
    return unsupported();
  }
};
registerSingleton(IEditorGroupsService, EmptyEditorGroupsService, 0);
registerSingleton(IBannerService, class BannerService {
  focus() {
  }
  focusNextAction() {
  }
  focusPreviousAction() {
  }
  hide() {
  }
  show() {
  }
}, 0);
registerSingleton(ITitleService, class TitleService {
  constructor() {
    this.onMenubarVisibilityChange = Event.None;
    this.isCommandCenterVisible = false;
    this.onDidChangeCommandCenterVisibility = Event.None;
  }
  updateProperties() {
  }
}, 0);
registerSingleton(IWorkingCopyFileService, WorkingCopyFileService, 0);
registerSingleton(IPathService, BrowserPathService, 1);
registerSingleton(IProductService, class ProductService {
  constructor() {
    this._serviceBrand = void 0;
    this.version = "1.82.0";
    this.commit = "16e9205452dd417e32f164325b589b94892846b4";
    this.nameShort = "Code - OSS Dev";
    this.nameLong = "Code - OSS Dev";
    this.applicationName = "code-oss";
    this.dataFolderName = ".vscode-oss";
    this.urlProtocol = "code-oss";
    this.reportIssueUrl = "https://github.com/microsoft/vscode/issues/new";
    this.licenseName = "MIT";
    this.licenseUrl = "https://github.com/microsoft/vscode/blob/main/LICENSE.txt";
    this.serverApplicationName = "code-server-oss";
  }
}, 0);
registerSingleton(ILanguageStatusService, class LanguageStatusServiceImpl {
  constructor() {
    this._provider = new LanguageFeatureRegistry();
    this.onDidChange = this._provider.onDidChange;
  }
  addStatus(status) {
    return this._provider.register(status.selector, status);
  }
  getLanguageStatus(model) {
    return this._provider.ordered(model).sort((a, b) => {
      let res = b.severity - a.severity;
      if (res === 0) {
        res = compare(a.source, b.source);
      }
      if (res === 0) {
        res = compare(a.id, b.id);
      }
      return res;
    });
  }
}, 0);
registerSingleton(IHostService, BrowserHostService, 0);
registerSingleton(ILifecycleService, class LifecycleService extends AbstractLifecycleService {
  constructor() {
    super(...arguments);
    this.shutdown = unsupported;
  }
}, 0);
registerSingleton(ILanguageDetectionService, class LanguageDetectionService {
  isEnabledForLanguage() {
    return false;
  }
  async detectLanguage() {
    return void 0;
  }
}, 0);
registerSingleton(IExtensionService, NullExtensionService, 0);
registerSingleton(IKeyboardLayoutService, class KeyboardLayoutService {
  constructor() {
    this.onDidChangeKeyboardLayout = Event.None;
    this.getRawKeyboardMapping = () => null;
    this.getCurrentKeyboardLayout = () => null;
    this.getAllKeyboardLayouts = () => [];
    this.getKeyboardMapper = () => new FallbackKeyboardMapper(false, OS);
    this.validateCurrentKeyboardMapping = () => {
    };
  }
}, 1);
registerSingleton(IUserDataInitializationService, class NullUserDataInitializationService {
  async requiresInitialization() {
    return false;
  }
  async whenInitializationFinished() {
  }
  async initializeRequiredResources() {
  }
  async initializeInstalledExtensions() {
  }
  async initializeOtherResources() {
  }
}, 0);
registerSingleton(IHostColorSchemeService, BrowserHostColorSchemeService, 0);
registerSingleton(IPreferencesService, class PreferencesService {
  constructor() {
    this.userSettingsResource = profile.settingsResource;
    this.workspaceSettingsResource = null;
    this.getFolderSettingsResource = unsupported;
    this.createPreferencesEditorModel = unsupported;
    this.resolveModel = unsupported;
    this.createSettings2EditorModel = unsupported;
    this.openRawDefaultSettings = unsupported;
    this.openSettings = unsupported;
    this.openUserSettings = unsupported;
    this.openRemoteSettings = unsupported;
    this.openWorkspaceSettings = unsupported;
    this.openFolderSettings = unsupported;
    this.openGlobalKeybindingSettings = unsupported;
    this.openDefaultKeybindingsFile = unsupported;
    this.getEditableSettingsURI = unsupported;
    this.createSplitJsonEditorInput = unsupported;
    this.openApplicationSettings = unsupported;
    this.openLanguageSpecificSettings = unsupported;
  }
}, 0);
registerSingleton(ITextMateTokenizationService, class NullTextMateService {
  constructor() {
    this.onDidEncounterLanguage = Event.None;
    this.createGrammar = unsupported;
    this.startDebugMode = unsupported;
    this.createTokenizer = unsupported;
  }
}, 0);
var profile = {
  id: "default",
  isDefault: true,
  name: "default",
  location: URI.from({ scheme: "user", path: "/profile.json" }),
  globalStorageHome: URI.from({ scheme: "user", path: "/globalStorage" }),
  settingsResource: URI.from({ scheme: "user", path: "/settings.json" }),
  keybindingsResource: URI.from({ scheme: "user", path: "/keybindings.json" }),
  tasksResource: URI.from({ scheme: "user", path: "/tasks.json" }),
  snippetsHome: URI.from({ scheme: "user", path: "/snippets" }),
  extensionsResource: URI.from({ scheme: "user", path: "/extensions.json" }),
  cacheHome: URI.from({ scheme: "cache", path: "/" })
};
registerSingleton(IUserDataProfilesService, class UserDataProfilesService {
  constructor() {
    this.onDidResetWorkspaces = Event.None;
    this.isEnabled = () => false;
    this.createNamedProfile = unsupported;
    this.createTransientProfile = unsupported;
    this.resetWorkspaces = unsupported;
    this.cleanUp = unsupported;
    this.cleanUpTransientProfiles = unsupported;
    this.defaultProfile = profile;
    this.onDidChangeProfiles = Event.None;
    this.profiles = [profile];
    this.createProfile = unsupported;
    this.updateProfile = unsupported;
    this.setProfileForWorkspace = unsupported;
    this.getProfile = () => profile;
    this.removeProfile = unsupported;
  }
  get profilesHome() {
    return unsupported();
  }
}, 0);
var InjectedUserDataProfileService = class InjectedUserDataProfileService2 extends UserDataProfileService {
  constructor(userDataProfilesService) {
    super(profile, userDataProfilesService);
  }
};
InjectedUserDataProfileService = __decorate([
  __param(0, IUserDataProfilesService)
], InjectedUserDataProfileService);
registerSingleton(IUserDataProfileService, InjectedUserDataProfileService, 0);
registerSingleton(IPolicyService, class PolicyService {
  constructor() {
    this.updatePolicyDefinitions = unsupported;
    this.onDidChange = Event.None;
    this.registerPolicyDefinitions = unsupported;
    this.getPolicyValue = () => void 0;
    this.serialize = () => void 0;
  }
}, 0);
registerSingleton(ISnippetsService, class SnippetsService {
  constructor() {
    this.getSnippetFiles = unsupported;
    this.isEnabled = unsupported;
    this.updateEnablement = unsupported;
    this.updateUsageTimestamp = unsupported;
    this.getSnippets = async () => [];
    this.getSnippetsSync = unsupported;
  }
}, 0);
var debugModel = {
  getSession: () => void 0,
  getSessions: () => [],
  getBreakpoints: () => [],
  areBreakpointsActivated: () => false,
  getFunctionBreakpoints: () => [],
  getDataBreakpoints: () => [],
  getExceptionBreakpoints: () => [],
  getExceptionBreakpointsForSession: () => [],
  getInstructionBreakpoints: () => [],
  getWatchExpressions: () => [],
  onDidChangeBreakpoints: Event.None,
  onDidChangeCallStack: Event.None,
  onDidChangeWatchExpressions: Event.None,
  fetchCallstack: unsupported,
  getId: unsupported
};
var FakeViewModel = class {
  constructor() {
    this.getId = unsupported;
    this.focusedSession = void 0;
    this.focusedThread = void 0;
    this.focusedStackFrame = void 0;
    this.getSelectedExpression = unsupported;
    this.setSelectedExpression = unsupported;
    this.updateViews = unsupported;
    this.isMultiSessionView = unsupported;
    this.onDidFocusSession = Event.None;
    this.onDidFocusStackFrame = Event.None;
    this.onDidSelectExpression = Event.None;
    this.onDidEvaluateLazyExpression = Event.None;
    this.onWillUpdateViews = Event.None;
    this.onDidFocusThread = Event.None;
    this.evaluateLazyExpression = unsupported;
  }
};
var FakeAdapterManager = class {
  constructor() {
    this.onDidRegisterDebugger = Event.None;
    this.hasEnabledDebuggers = () => false;
    this.getDebugAdapterDescriptor = unsupported;
    this.getDebuggerLabel = unsupported;
    this.someDebuggerInterestedInLanguage = () => false;
    this.getDebugger = () => void 0;
    this.activateDebuggers = unsupported;
    this.registerDebugAdapterFactory = () => Disposable.None;
    this.createDebugAdapter = unsupported;
    this.registerDebugAdapterDescriptorFactory = unsupported;
    this.unregisterDebugAdapterDescriptorFactory = unsupported;
    this.substituteVariables = unsupported;
    this.runInTerminal = unsupported;
    this.getEnabledDebugger = unsupported;
    this.guessDebugger = unsupported;
    this.onDidDebuggersExtPointRead = Event.None;
  }
};
registerSingleton(IDebugService, class DebugService {
  constructor() {
    this.onDidChangeState = Event.None;
    this.onDidNewSession = Event.None;
    this.onWillNewSession = Event.None;
    this.onDidEndSession = Event.None;
    this.getConfigurationManager = unsupported;
    this.getAdapterManager = () => new FakeAdapterManager();
    this.focusStackFrame = unsupported;
    this.canSetBreakpointsIn = unsupported;
    this.addBreakpoints = unsupported;
    this.updateBreakpoints = unsupported;
    this.enableOrDisableBreakpoints = unsupported;
    this.setBreakpointsActivated = unsupported;
    this.removeBreakpoints = unsupported;
    this.addFunctionBreakpoint = unsupported;
    this.updateFunctionBreakpoint = unsupported;
    this.removeFunctionBreakpoints = unsupported;
    this.addDataBreakpoint = unsupported;
    this.removeDataBreakpoints = unsupported;
    this.addInstructionBreakpoint = unsupported;
    this.removeInstructionBreakpoints = unsupported;
    this.setExceptionBreakpointCondition = unsupported;
    this.setExceptionBreakpointsForSession = unsupported;
    this.sendAllBreakpoints = unsupported;
    this.addWatchExpression = unsupported;
    this.renameWatchExpression = unsupported;
    this.moveWatchExpression = unsupported;
    this.removeWatchExpressions = unsupported;
    this.startDebugging = unsupported;
    this.restartSession = unsupported;
    this.stopSession = unsupported;
    this.sourceIsNotAvailable = unsupported;
    this.getModel = () => debugModel;
    this.getViewModel = () => new FakeViewModel();
    this.runTo = unsupported;
  }
  get state() {
    return unsupported();
  }
}, 0);
registerSingleton(IRequestService, RequestService, 0);
registerSingleton(IWorkspaceTrustRequestService, class WorkspaceTrustRequestService3 {
  constructor() {
    this.onDidInitiateOpenFilesTrustRequest = Event.None;
    this.onDidInitiateWorkspaceTrustRequest = Event.None;
    this.onDidInitiateWorkspaceTrustRequestOnStartup = Event.None;
    this.completeOpenFilesTrustRequest = unsupported;
    this.requestOpenFilesTrust = async () => 1;
    this.cancelWorkspaceTrustRequest = unsupported;
    this.completeWorkspaceTrustRequest = unsupported;
    this.requestWorkspaceTrust = async () => true;
    this.requestWorkspaceTrustOnStartup = () => null;
  }
}, 0);
registerSingleton(IActivityService, class ActivityService {
  constructor() {
    this.showViewContainerActivity = () => Disposable.None;
    this.showViewActivity = () => Disposable.None;
    this.showAccountsActivity = () => Disposable.None;
    this.showGlobalActivity = () => Disposable.None;
  }
}, 0);
registerSingleton(IExtensionHostDebugService, class ExtensionHostDebugService {
  constructor() {
    this.reload = unsupported;
    this.onReload = Event.None;
    this.close = unsupported;
    this.onClose = Event.None;
    this.attachSession = unsupported;
    this.onAttachSession = Event.None;
    this.terminateSession = unsupported;
    this.onTerminateSession = Event.None;
    this.openExtensionDevelopmentHostWindow = unsupported;
  }
}, 0);
registerSingleton(IViewsService, class ViewsService {
  constructor() {
    this.getFocusedViewName = unsupported;
    this.onDidChangeFocusedView = Event.None;
    this.onDidChangeViewContainerVisibility = Event.None;
    this.isViewContainerVisible = () => false;
    this.openViewContainer = unsupported;
    this.closeViewContainer = unsupported;
    this.getVisibleViewContainer = unsupported;
    this.getActiveViewPaneContainerWithId = () => null;
    this.onDidChangeViewVisibility = Event.None;
    this.isViewVisible = () => false;
    this.openView = async () => null;
    this.closeView = unsupported;
    this.getActiveViewWithId = () => null;
    this.getViewWithId = () => null;
    this.getViewProgressIndicator = () => void 0;
  }
}, 0);
registerSingleton(IViewDescriptorService, class ViewDescriptorService {
  constructor() {
    this.viewContainers = [];
    this.onDidChangeViewContainers = Event.None;
    this.getDefaultViewContainer = () => void 0;
    this.getViewContainerById = () => null;
    this.isViewContainerRemovedPermanently = unsupported;
    this.getDefaultViewContainerLocation = () => null;
    this.getViewContainerLocation = () => null;
    this.getViewContainersByLocation = unsupported;
    this.getViewContainerModel = () => ({
      onDidChangeAllViewDescriptors: Event.None,
      visibleViewDescriptors: []
    });
    this.onDidChangeContainerLocation = Event.None;
    this.moveViewContainerToLocation = unsupported;
    this.getViewContainerBadgeEnablementState = unsupported;
    this.setViewContainerBadgeEnablementState = unsupported;
    this.getViewDescriptorById = () => null;
    this.getViewContainerByViewId = () => null;
    this.getDefaultContainerById = () => null;
    this.getViewLocationById = () => null;
    this.onDidChangeContainer = Event.None;
    this.moveViewsToContainer = unsupported;
    this.onDidChangeLocation = Event.None;
    this.moveViewToLocation = () => null;
    this.reset = () => null;
  }
}, 0);
registerSingleton(IHistoryService, class HistoryService {
  constructor() {
    this.goForward = unsupported;
    this.goBack = unsupported;
    this.goPrevious = unsupported;
    this.goLast = unsupported;
    this.reopenLastClosedEditor = unsupported;
    this.getHistory = () => [];
    this.removeFromHistory = unsupported;
    this.getLastActiveWorkspaceRoot = () => void 0;
    this.getLastActiveFile = () => void 0;
    this.openNextRecentlyUsedEditor = unsupported;
    this.openPreviouslyUsedEditor = unsupported;
    this.clear = unsupported;
    this.clearRecentlyOpened = unsupported;
  }
}, 0);
registerSingleton(ITaskService, class TaskService {
  constructor() {
    this.onDidStateChange = Event.None;
    this.supportsMultipleTaskExecutions = false;
    this.configureAction = unsupported;
    this.run = unsupported;
    this.inTerminal = () => false;
    this.getActiveTasks = async () => [];
    this.getBusyTasks = unsupported;
    this.terminate = unsupported;
    this.tasks = unsupported;
    this.taskTypes = unsupported;
    this.getWorkspaceTasks = unsupported;
    this.getSavedTasks = unsupported;
    this.removeRecentlyUsedTask = unsupported;
    this.getTask = unsupported;
    this.tryResolveTask = unsupported;
    this.createSorter = unsupported;
    this.getTaskDescription = unsupported;
    this.customize = unsupported;
    this.openConfig = unsupported;
    this.registerTaskProvider = unsupported;
    this.registerTaskSystem = () => {
    };
    this.onDidChangeTaskSystemInfo = Event.None;
    this.hasTaskSystemInfo = false;
    this.registerSupportedExecutions = () => {
    };
    this.extensionCallbackTaskComplete = unsupported;
  }
}, 0);
registerSingleton(IConfigurationResolverService, class ConfigurationResolverService {
  constructor() {
    this.resolveWithEnvironment = unsupported;
    this.resolveAsync = unsupported;
    this.resolveAnyAsync = unsupported;
    this.resolveAnyMap = unsupported;
    this.resolveWithInteractionReplace = unsupported;
    this.resolveWithInteraction = unsupported;
    this.contributeVariable = unsupported;
  }
}, 0);
registerSingleton(IRemoteAgentService, class RemoteAgentService {
  constructor() {
    this.getConnection = () => null;
    this.getEnvironment = async () => null;
    this.getRawEnvironment = async () => null;
    this.getExtensionHostExitInfo = async () => null;
    this.getRoundTripTime = async () => void 0;
    this.whenExtensionsReady = async () => void 0;
    this.scanExtensions = async () => [];
    this.scanSingleExtension = async () => null;
    this.getDiagnosticInfo = async () => void 0;
    this.updateTelemetryLevel = async () => void 0;
    this.logTelemetry = async () => void 0;
    this.flushTelemetry = async () => void 0;
  }
}, 0);
registerSingleton(ICustomEndpointTelemetryService, NullEndpointTelemetryService, 0);
var MonacoSearchService = class MonacoSearchService2 {
  constructor(modelService) {
    this.modelService = modelService;
    this.textSearchSplitSyncAsync = unsupported;
    this.registerSearchResultProvider = unsupported;
  }
  async textSearch() {
    return {
      results: [],
      messages: []
    };
  }
  async fileSearch() {
    return {
      results: this.modelService.getModels().map((model) => ({
        resource: model.uri
      })),
      messages: []
    };
  }
  async clearCache() {
  }
};
MonacoSearchService = __decorate([
  __param(0, IModelService)
], MonacoSearchService);
registerSingleton(ISearchService, MonacoSearchService, 0);
registerSingleton(IEditSessionIdentityService, class EditSessionIdentityService {
  constructor() {
    this.registerEditSessionIdentityProvider = unsupported;
    this.getEditSessionIdentifier = unsupported;
    this.provideEditSessionIdentityMatch = unsupported;
    this.addEditSessionIdentityCreateParticipant = () => new DisposableStore();
    this.onWillCreateEditSessionIdentity = unsupported;
  }
}, 0);
registerSingleton(IWorkspaceEditingService, class WorkspaceEditingService {
  constructor() {
    this.addFolders = unsupported;
    this.removeFolders = unsupported;
    this.updateFolders = unsupported;
    this.enterWorkspace = unsupported;
    this.createAndEnterWorkspace = unsupported;
    this.saveAndEnterWorkspace = unsupported;
    this.copyWorkspaceSettings = unsupported;
    this.pickNewWorkspacePath = unsupported;
  }
}, 0);
registerSingleton(ITimerService, class TimerService {
  constructor() {
    this.whenReady = unsupported;
    this.setPerformanceMarks = () => {
    };
    this.getPerformanceMarks = unsupported;
    this.getDuration = unsupported;
  }
  get perfBaseline() {
    return unsupported();
  }
  get startupMetrics() {
    return unsupported();
  }
}, 0);
registerSingleton(IExtensionsWorkbenchService, class ExtensionsWorkbenchService {
  constructor() {
    this.toggleApplyExtensionToAllProfiles = unsupported;
    this.whenInitialized = Promise.resolve();
    this.onChange = Event.None;
    this.onReset = Event.None;
    this.preferPreReleases = false;
    this.local = [];
    this.installed = [];
    this.outdated = [];
    this.queryLocal = unsupported;
    this.queryGallery = unsupported;
    this.getExtensions = unsupported;
    this.canInstall = unsupported;
    this.install = unsupported;
    this.installInServer = unsupported;
    this.uninstall = unsupported;
    this.installVersion = unsupported;
    this.reinstall = unsupported;
    this.canSetLanguage = unsupported;
    this.setLanguage = unsupported;
    this.setEnablement = unsupported;
    this.pinExtension = unsupported;
    this.open = unsupported;
    this.checkForUpdates = unsupported;
    this.getExtensionStatus = unsupported;
    this.isExtensionIgnoredToSync = unsupported;
    this.toggleExtensionIgnoredToSync = unsupported;
  }
}, 0);
registerSingleton(IWorkbenchExtensionEnablementService, class WorkbenchExtensionEnablementService {
  constructor() {
    this.onEnablementChanged = Event.None;
    this.getEnablementState = () => 8;
    this.getEnablementStates = (extensions) => extensions.map(() => 8);
    this.getDependenciesEnablementStates = () => [];
    this.canChangeEnablement = () => false;
    this.canChangeWorkspaceEnablement = () => false;
    this.isEnabled = () => true;
    this.isEnabledEnablementState = () => true;
    this.isDisabledGlobally = () => false;
    this.setEnablement = unsupported;
    this.updateExtensionsEnablementsWhenWorkspaceTrustChanges = unsupported;
  }
}, 0);
registerSingleton(ITunnelService, class TunnelService {
  constructor() {
    this.tunnels = Promise.resolve([]);
    this.canChangePrivacy = false;
    this.privacyOptions = [];
    this.onTunnelOpened = Event.None;
    this.onTunnelClosed = Event.None;
    this.canElevate = false;
    this.hasTunnelProvider = false;
    this.onAddedTunnelProvider = Event.None;
    this.canTunnel = () => false;
    this.openTunnel = unsupported;
    this.getExistingTunnel = async () => void 0;
    this.setEnvironmentTunnel = unsupported;
    this.closeTunnel = unsupported;
    this.setTunnelProvider = unsupported;
    this.setTunnelFeatures = unsupported;
    this.isPortPrivileged = () => false;
  }
}, 0);
registerSingleton(IFilesConfigurationService, FilesConfigurationService, 0);
registerSingleton(IUntitledTextEditorService, class UntitledTextEditorService2 {
  constructor() {
    this.isUntitledWithAssociatedResource = () => false;
    this.onDidChangeDirty = Event.None;
    this.onDidChangeEncoding = Event.None;
    this.onDidChangeLabel = Event.None;
    this.onWillDispose = Event.None;
    this.create = unsupported;
    this.get = () => void 0;
    this.getValue = () => void 0;
    this.resolve = unsupported;
  }
}, 0);
registerSingleton(IWorkingCopyBackupService, InMemoryWorkingCopyBackupService, 0);
registerSingleton(IWorkingCopyService, WorkingCopyService, 0);
registerSingleton(IDecorationsService, DecorationsService, 0);
registerSingleton(IElevatedFileService, BrowserElevatedFileService, 0);
registerSingleton(IFileDialogService, class FileDialogService {
  constructor() {
    this.preferredHome = unsupported;
    this.defaultFilePath = unsupported;
    this.defaultFolderPath = unsupported;
    this.defaultWorkspacePath = unsupported;
    this.pickFileFolderAndOpen = unsupported;
    this.pickFileAndOpen = unsupported;
    this.pickFolderAndOpen = unsupported;
    this.pickWorkspaceAndOpen = unsupported;
    this.pickFileToSave = unsupported;
    this.showSaveDialog = unsupported;
    this.showSaveConfirm = unsupported;
    this.showOpenDialog = unsupported;
  }
}, 0);
registerSingleton(IJSONEditingService, JSONEditingService, 1);
registerSingleton(IWorkspacesService, class WorkspacesService {
  constructor() {
    this.enterWorkspace = unsupported;
    this.createUntitledWorkspace = unsupported;
    this.deleteUntitledWorkspace = unsupported;
    this.getWorkspaceIdentifier = unsupported;
    this.onDidChangeRecentlyOpened = Event.None;
    this.addRecentlyOpened = unsupported;
    this.removeRecentlyOpened = unsupported;
    this.clearRecentlyOpened = unsupported;
    this.getRecentlyOpened = unsupported;
    this.getDirtyWorkspaces = unsupported;
  }
}, 1);
registerSingleton(ITextEditorService, class TextEditorService3 {
  constructor() {
    this.createTextEditor = unsupported;
    this.resolveTextEditor = unsupported;
  }
}, 0);
registerSingleton(IEditorResolverService, class EditorResolverService {
  constructor() {
    this.getAssociationsForResource = unsupported;
    this.updateUserAssociations = unsupported;
    this.onDidChangeEditorRegistrations = Event.None;
    this.bufferChangeEvents = unsupported;
    this.resolveEditor = unsupported;
    this.getEditors = () => [];
  }
  registerEditor() {
    return {
      dispose: () => {
      }
    };
  }
}, 0);
registerSingleton(IOutputService, OutputService, 1);
registerSingleton(IOutputChannelModelService, OutputChannelModelService, 1);
var SimpleExtensionResourceLoaderService = class SimpleExtensionResourceLoaderService2 extends AbstractExtensionResourceLoaderService {
  constructor(fileService, storageService, productService, environmentService, configurationService) {
    super(fileService, storageService, productService, environmentService, configurationService);
  }
  async readExtensionResource(uri) {
    const result = await this._fileService.readFile(uri);
    return result.value.toString();
  }
};
SimpleExtensionResourceLoaderService = __decorate([
  __param(0, IFileService),
  __param(1, IStorageService),
  __param(2, IProductService),
  __param(3, IEnvironmentService),
  __param(4, IConfigurationService)
], SimpleExtensionResourceLoaderService);
registerSingleton(IExtensionResourceLoaderService, SimpleExtensionResourceLoaderService, 0);
registerSingleton(IHoverService, class HoverService {
  constructor() {
    this.showAndFocusLastHover = unsupported;
    this.showHover = unsupported;
    this.hideHover = unsupported;
  }
}, 0);
registerSingleton(IExplorerService, class ExplorerService {
  constructor() {
    this.roots = [];
    this.getContext = unsupported;
    this.hasViewFocus = unsupported;
    this.setEditable = unsupported;
    this.getEditable = unsupported;
    this.getEditableData = unsupported;
    this.isEditable = unsupported;
    this.findClosest = unsupported;
    this.findClosestRoot = unsupported;
    this.refresh = unsupported;
    this.setToCopy = unsupported;
    this.isCut = unsupported;
    this.applyBulkEdit = unsupported;
    this.select = unsupported;
    this.registerView = unsupported;
  }
  get sortOrderConfiguration() {
    return unsupported();
  }
}, 1);
registerSingleton(IExtensionStorageService, ExtensionStorageService, 1);
registerSingleton(ILanguagePackService, class LanguagePackService {
  async getAvailableLanguages() {
    return [];
  }
  async getInstalledLanguages() {
    return [];
  }
  async getBuiltInExtensionTranslationsUri() {
    return void 0;
  }
}, 1);
registerSingleton(ITreeViewsDnDService, TreeViewsDnDService, 1);
registerSingleton(ITreeViewsService, TreeviewsService, 1);
registerSingleton(IBreadcrumbsService, class BreadcrumbsService {
  constructor() {
    this.register = unsupported;
    this.getWidget = () => void 0;
  }
}, 0);
registerSingleton(IOutlineService, class OutlineService {
  constructor() {
    this.onDidChange = Event.None;
    this.canCreateOutline = () => false;
    this.createOutline = async () => void 0;
    this.registerOutlineCreator = unsupported;
  }
}, 0);
registerSingleton(IUpdateService, class UpdateService {
  constructor() {
    this.onStateChange = Event.None;
    this.state = State.Uninitialized;
    this.checkForUpdates = unsupported;
    this.downloadUpdate = unsupported;
    this.applyUpdate = unsupported;
    this.quitAndInstall = unsupported;
    this.isLatestVersion = unsupported;
    this._applySpecificUpdate = unsupported;
  }
}, 0);
registerSingleton(IStatusbarService, class StatusbarService {
  constructor() {
    this.onDidChangeEntryVisibility = Event.None;
    this.addEntry = () => ({
      dispose: () => {
      },
      update: () => {
      }
    });
    this.isEntryVisible = () => false;
    this.updateEntryVisibility = () => {
    };
    this.focus = () => {
    };
    this.focusNextEntry = () => {
    };
    this.focusPreviousEntry = () => {
    };
    this.isEntryFocused = () => false;
    this.overrideStyle = () => Disposable.None;
  }
}, 0);
registerSingleton(IExtensionGalleryService, class ExtensionGalleryService {
  constructor() {
    this.isEnabled = () => false;
    this.query = unsupported;
    this.getExtensions = unsupported;
    this.isExtensionCompatible = unsupported;
    this.getCompatibleExtension = unsupported;
    this.getAllCompatibleVersions = unsupported;
    this.download = unsupported;
    this.downloadSignatureArchive = unsupported;
    this.reportStatistic = unsupported;
    this.getReadme = unsupported;
    this.getManifest = unsupported;
    this.getChangelog = unsupported;
    this.getCoreTranslation = unsupported;
    this.getExtensionsControlManifest = unsupported;
  }
}, 0);
registerSingleton(ITerminalService, class TerminalService {
  constructor() {
    this.onInstanceEvent = unsupported;
    this.onInstanceCapabilityEvent = unsupported;
    this.onDidChangeSelection = Event.None;
    this.detachedXterms = [];
    this.restoredGroupCount = 0;
    this.createDetachedXterm = unsupported;
    this.instances = [];
    this.revealActiveTerminal = unsupported;
    this.isProcessSupportRegistered = false;
    this.connectionState = 1;
    this.defaultLocation = TerminalLocation.Panel;
    this.onDidChangeActiveGroup = Event.None;
    this.onDidDisposeGroup = Event.None;
    this.onDidCreateInstance = Event.None;
    this.onDidReceiveProcessId = Event.None;
    this.onDidChangeInstanceDimensions = Event.None;
    this.onDidMaximumDimensionsChange = Event.None;
    this.onDidRequestStartExtensionTerminal = Event.None;
    this.onDidChangeInstanceTitle = Event.None;
    this.onDidChangeInstanceIcon = Event.None;
    this.onDidChangeInstanceColor = Event.None;
    this.onDidChangeInstancePrimaryStatus = Event.None;
    this.onDidInputInstanceData = Event.None;
    this.onDidRegisterProcessSupport = Event.None;
    this.onDidChangeConnectionState = Event.None;
    this.createTerminal = unsupported;
    this.getInstanceFromId = unsupported;
    this.getInstanceFromIndex = unsupported;
    this.getReconnectedTerminals = unsupported;
    this.getActiveOrCreateInstance = unsupported;
    this.moveToEditor = unsupported;
    this.moveToTerminalView = unsupported;
    this.getPrimaryBackend = unsupported;
    this.refreshActiveGroup = unsupported;
    this.registerProcessSupport = () => {
    };
    this.showProfileQuickPick = unsupported;
    this.setContainers = unsupported;
    this.requestStartExtensionTerminal = unsupported;
    this.isAttachedToTerminal = unsupported;
    this.getEditableData = unsupported;
    this.setEditable = unsupported;
    this.isEditable = unsupported;
    this.safeDisposeTerminal = unsupported;
    this.getDefaultInstanceHost = unsupported;
    this.getInstanceHost = unsupported;
    this.resolveLocation = unsupported;
    this.setNativeDelegate = unsupported;
    this.toggleEscapeSequenceLogging = unsupported;
    this.getEditingTerminal = unsupported;
    this.setEditingTerminal = unsupported;
    this.activeInstance = void 0;
    this.onDidDisposeInstance = Event.None;
    this.onDidFocusInstance = Event.None;
    this.onDidChangeActiveInstance = Event.None;
    this.onDidChangeInstances = Event.None;
    this.onDidChangeInstanceCapability = Event.None;
    this.setActiveInstance = unsupported;
    this.focusActiveInstance = unsupported;
    this.getInstanceFromResource = unsupported;
  }
  async createDetachedTerminal() {
    unsupported();
  }
  get whenConnected() {
    return (async () => {
      unsupported();
    })();
  }
  get configHelper() {
    return unsupported();
  }
}, 1);
registerSingleton(ITerminalEditorService, class TerminalEditorService {
  constructor() {
    this.instances = [];
    this.openEditor = unsupported;
    this.detachActiveEditorInstance = unsupported;
    this.detachInstance = unsupported;
    this.splitInstance = unsupported;
    this.revealActiveEditor = unsupported;
    this.resolveResource = unsupported;
    this.reviveInput = unsupported;
    this.getInputFromResource = unsupported;
    this.activeInstance = void 0;
    this.onDidDisposeInstance = Event.None;
    this.onDidFocusInstance = Event.None;
    this.onDidChangeActiveInstance = Event.None;
    this.onDidChangeInstances = Event.None;
    this.onDidChangeInstanceCapability = Event.None;
    this.setActiveInstance = unsupported;
    this.focusActiveInstance = unsupported;
    this.getInstanceFromResource = unsupported;
  }
}, 1);
registerSingleton(ITerminalGroupService, class TerminalGroupService {
  constructor() {
    this.lastAccessedMenu = "inline-tab";
    this.instances = [];
    this.groups = [];
    this.activeGroup = void 0;
    this.activeGroupIndex = 0;
    this.onDidChangeActiveGroup = Event.None;
    this.onDidDisposeGroup = Event.None;
    this.onDidChangeGroups = Event.None;
    this.onDidShow = Event.None;
    this.onDidChangePanelOrientation = Event.None;
    this.createGroup = unsupported;
    this.getGroupForInstance = unsupported;
    this.moveGroup = unsupported;
    this.moveGroupToEnd = unsupported;
    this.moveInstance = unsupported;
    this.unsplitInstance = unsupported;
    this.joinInstances = unsupported;
    this.instanceIsSplit = unsupported;
    this.getGroupLabels = unsupported;
    this.setActiveGroupByIndex = unsupported;
    this.setActiveGroupToNext = unsupported;
    this.setActiveGroupToPrevious = unsupported;
    this.setActiveInstanceByIndex = unsupported;
    this.setContainer = unsupported;
    this.showPanel = unsupported;
    this.hidePanel = unsupported;
    this.focusTabs = unsupported;
    this.focusHover = unsupported;
    this.showTabs = unsupported;
    this.updateVisibility = unsupported;
    this.onDidDisposeInstance = Event.None;
    this.onDidFocusInstance = Event.None;
    this.onDidChangeActiveInstance = Event.None;
    this.onDidChangeInstances = Event.None;
    this.onDidChangeInstanceCapability = Event.None;
    this.setActiveInstance = unsupported;
    this.focusActiveInstance = unsupported;
    this.getInstanceFromResource = unsupported;
  }
}, 1);
registerSingleton(ITerminalInstanceService, class TerminalInstanceService {
  constructor() {
    this.getRegisteredBackends = () => [].values();
    this.onDidCreateInstance = Event.None;
    this.convertProfileToShellLaunchConfig = unsupported;
    this.createInstance = unsupported;
    this.getBackend = unsupported;
    this.didRegisterBackend = unsupported;
  }
}, 1);
registerSingleton(ITerminalProfileService, class TerminalProfileService {
  constructor() {
    this.availableProfiles = [];
    this.contributedProfiles = [];
    this.profilesReady = Promise.resolve();
    this.getPlatformKey = unsupported;
    this.refreshAvailableProfiles = unsupported;
    this.getDefaultProfileName = () => void 0;
    this.getDefaultProfile = () => void 0;
    this.onDidChangeAvailableProfiles = Event.None;
    this.getContributedDefaultProfile = unsupported;
    this.registerContributedProfile = unsupported;
    this.getContributedProfileProvider = unsupported;
    this.registerTerminalProfileProvider = unsupported;
  }
}, 1);
registerSingleton(ITerminalLogService, class TerminalLogService {
  constructor() {
    this.onDidChangeLogLevel = Event.None;
    this.getLevel = unsupported;
    this.setLevel = unsupported;
    this.trace = unsupported;
    this.debug = unsupported;
    this.info = unsupported;
    this.warn = unsupported;
    this.error = unsupported;
    this.flush = unsupported;
    this.dispose = unsupported;
  }
}, 1);
registerSingleton(ITerminalLinkProviderService, class TerminalLinkProviderService {
  constructor() {
    this.linkProviders = /* @__PURE__ */ new Set([]);
    this.onDidAddLinkProvider = Event.None;
    this.onDidRemoveLinkProvider = Event.None;
    this.registerLinkProvider = unsupported;
  }
}, 1);
registerSingleton(ITerminalContributionService, class TerminalContributionService {
  constructor() {
    this.terminalProfiles = [];
  }
}, 1);
registerSingleton(ITerminalProfileResolverService, class TerminalProfileResolverService {
  constructor() {
    this.resolveIcon = unsupported;
    this.resolveShellLaunchConfig = unsupported;
    this.getDefaultProfile = async () => ({
      profileName: "bash",
      path: "/bin/bash",
      isDefault: true
    });
    this.getDefaultShell = unsupported;
    this.getDefaultShellArgs = unsupported;
    this.getDefaultIcon = unsupported;
    this.getEnvironment = unsupported;
    this.createProfileFromShellAndShellArgs = unsupported;
  }
}, 1);
registerSingleton(IEnvironmentVariableService, class EnvironmentVariableService {
  constructor() {
    this.collections = /* @__PURE__ */ new Map();
    this.onDidChangeCollections = Event.None;
    this.set = unsupported;
    this.delete = unsupported;
  }
  get mergedCollection() {
    return unsupported();
  }
}, 1);
registerSingleton(ITerminalQuickFixService, class TerminalQuickFixService {
  constructor() {
    this.onDidRegisterProvider = Event.None;
    this.onDidRegisterCommandSelector = Event.None;
    this.onDidUnregisterProvider = Event.None;
    this.extensionQuickFixes = Promise.resolve([]);
    this.providers = /* @__PURE__ */ new Map();
    this.registerQuickFixProvider = unsupported;
    this.registerCommandSelector = unsupported;
  }
}, 1);
registerSingleton(IExtensionManagementService, class ExtensionManagementService {
  constructor() {
    this.toggleAppliationScope = async (extension) => extension;
    this.installGalleryExtensions = unsupported;
    this.onInstallExtension = Event.None;
    this.onDidInstallExtensions = Event.None;
    this.onUninstallExtension = Event.None;
    this.onDidUninstallExtension = Event.None;
    this.onDidUpdateExtensionMetadata = Event.None;
    this.zip = unsupported;
    this.unzip = unsupported;
    this.getManifest = unsupported;
    this.install = unsupported;
    this.canInstall = unsupported;
    this.installFromGallery = unsupported;
    this.installFromLocation = unsupported;
    this.installExtensionsFromProfile = unsupported;
    this.uninstall = unsupported;
    this.reinstallFromGallery = unsupported;
    this.getInstalled = async () => [];
    this.getExtensionsControlManifest = unsupported;
    this.copyExtensions = unsupported;
    this.updateMetadata = unsupported;
    this.download = unsupported;
    this.registerParticipant = unsupported;
    this.getTargetPlatform = unsupported;
    this.cleanUp = unsupported;
  }
}, 1);
registerSingleton(IUserDataSyncWorkbenchService, class UserDataSyncWorkbenchService {
  constructor() {
    this.enabled = false;
    this.authenticationProviders = [];
    this.all = [];
    this.current = void 0;
    this.accountStatus = "uninitialized";
    this.onDidChangeAccountStatus = Event.None;
    this.turnOn = unsupported;
    this.turnoff = unsupported;
    this.signIn = unsupported;
    this.resetSyncedData = unsupported;
    this.showSyncActivity = unsupported;
    this.syncNow = unsupported;
    this.synchroniseUserDataSyncStoreType = unsupported;
    this.showConflicts = unsupported;
    this.accept = unsupported;
  }
}, 1);
registerSingleton(IUserDataSyncEnablementService, class UserDataSyncEnablementService {
  constructor() {
    this.onDidChangeEnablement = Event.None;
    this.isEnabled = () => false;
    this.canToggleEnablement = () => false;
    this.setEnablement = unsupported;
    this.onDidChangeResourceEnablement = Event.None;
    this.isResourceEnabled = () => false;
    this.setResourceEnablement = unsupported;
    this.getResourceSyncStateVersion = () => void 0;
  }
}, 1);
registerSingleton(IKeybindingEditingService, class KeybindingEditingService {
  constructor() {
    this.addKeybinding = unsupported;
    this.editKeybinding = unsupported;
    this.removeKeybinding = unsupported;
    this.resetKeybinding = unsupported;
  }
}, 1);
registerSingleton(IPreferencesSearchService, class PreferencesSearchService {
  constructor() {
    this.getLocalSearchProvider = unsupported;
    this.getRemoteSearchProvider = unsupported;
  }
}, 1);
registerSingleton(INotebookService, class NotebookService {
  constructor() {
    this.canResolve = async () => false;
    this.onAddViewType = Event.None;
    this.onWillRemoveViewType = Event.None;
    this.onDidChangeOutputRenderers = Event.None;
    this.onWillAddNotebookDocument = Event.None;
    this.onDidAddNotebookDocument = Event.None;
    this.onWillRemoveNotebookDocument = Event.None;
    this.onDidRemoveNotebookDocument = Event.None;
    this.registerNotebookSerializer = unsupported;
    this.withNotebookDataProvider = unsupported;
    this.getOutputMimeTypeInfo = unsupported;
    this.getViewTypeProvider = () => void 0;
    this.getRendererInfo = () => void 0;
    this.getRenderers = () => [];
    this.getStaticPreloads = unsupported;
    this.updateMimePreferredRenderer = unsupported;
    this.saveMimeDisplayOrder = unsupported;
    this.createNotebookTextModel = unsupported;
    this.getNotebookTextModel = () => void 0;
    this.getNotebookTextModels = unsupported;
    this.listNotebookDocuments = () => [];
    this.registerContributedNotebookType = unsupported;
    this.getContributedNotebookType = unsupported;
    this.getContributedNotebookTypes = () => [];
    this.getNotebookProviderResourceRoots = () => [];
    this.setToCopy = unsupported;
    this.getToCopy = unsupported;
    this.clearEditorCache = unsupported;
  }
}, 1);
registerSingleton(IReplaceService, class ReplaceService {
  constructor() {
    this.replace = unsupported;
    this.openReplacePreview = unsupported;
    this.updateReplacePreview = unsupported;
  }
}, 1);
registerSingleton(ISearchHistoryService, class SearchHistoryService2 {
  constructor() {
    this.onDidClearHistory = Event.None;
    this.clearHistory = unsupported;
    this.load = unsupported;
    this.save = unsupported;
  }
}, 1);
registerSingleton(INotebookEditorService, class NotebookEditorService {
  constructor() {
    this.retrieveWidget = unsupported;
    this.retrieveExistingWidgetFromURI = () => void 0;
    this.retrieveAllExistingWidgets = () => [];
    this.onDidAddNotebookEditor = Event.None;
    this.onDidRemoveNotebookEditor = Event.None;
    this.addNotebookEditor = unsupported;
    this.removeNotebookEditor = unsupported;
    this.getNotebookEditor = () => void 0;
    this.listNotebookEditors = () => [];
  }
}, 1);
registerSingleton(ISearchViewModelWorkbenchService, class SearchWorkbenchService {
  get searchModel() {
    return unsupported();
  }
}, 1);
registerSingleton(INotebookEditorModelResolverService, class NotebookEditorModelResolverService {
  constructor() {
    this.onDidSaveNotebook = Event.None;
    this.onDidChangeDirty = Event.None;
    this.onWillFailWithConflict = Event.None;
    this.isDirty = unsupported;
    this.resolve = unsupported;
  }
}, 1);
registerSingleton(IWorkingCopyEditorService, WorkingCopyEditorService, 1);
registerSingleton(IUserActivityService, UserActivityService, 1);
registerSingleton(ICanonicalUriService, CanonicalUriService, 1);
registerSingleton(IExtensionStatusBarItemService, ExtensionStatusBarItemService, 1);
registerSingleton(IWorkbenchAssignmentService, class WorkbenchAssignmentService {
  constructor() {
    this.getCurrentExperiments = async () => [];
    this.getTreatment = async () => void 0;
  }
}, 1);
registerSingleton(IChatService, class ChatService {
  constructor() {
    this.transferredSessionData = void 0;
    this.onDidSubmitSlashCommand = Event.None;
    this.getSessionId = () => void 0;
    this.transferredSessionId = void 0;
    this.transferChatSession = unsupported;
    this.registerProvider = unsupported;
    this.registerSlashCommandProvider = unsupported;
    this.getProviderInfos = () => [];
    this.startSession = unsupported;
    this.getSession = () => void 0;
    this.getOrRestoreSession = () => void 0;
    this.loadSessionFromContent = () => void 0;
    this.sendRequest = unsupported;
    this.removeRequest = unsupported;
    this.cancelCurrentRequestForSession = unsupported;
    this.getSlashCommands = unsupported;
    this.clearSession = unsupported;
    this.addRequest = unsupported;
    this.addCompleteRequest = unsupported;
    this.sendRequestToProvider = unsupported;
    this.getHistory = () => [];
    this.removeHistoryEntry = unsupported;
    this.onDidPerformUserAction = Event.None;
    this.notifyUserAction = unsupported;
  }
}, 1);
registerSingleton(IQuickChatService, class QuickChatService {
  constructor() {
    this.onDidClose = Event.None;
    this.enabled = false;
    this.toggle = unsupported;
    this.focus = unsupported;
    this.open = unsupported;
    this.close = unsupported;
    this.openInChatView = unsupported;
  }
}, 1);
registerSingleton(IEmbedderTerminalService, class EmbedderTerminalService {
  constructor() {
    this.onDidCreateTerminal = Event.None;
    this.createTerminal = unsupported;
  }
}, 1);
registerSingleton(ICustomEditorService, class CustomEditorService {
  constructor() {
    this.getCustomEditor = unsupported;
    this.getAllCustomEditors = unsupported;
    this.getContributedCustomEditors = unsupported;
    this.getUserConfiguredCustomEditors = unsupported;
    this.registerCustomEditorCapabilities = unsupported;
    this.getCustomEditorCapabilities = unsupported;
  }
  get models() {
    return unsupported();
  }
}, 1);
registerSingleton(IWebviewService, class WebviewService {
  constructor() {
    this.webviews = [];
    this.onDidChangeActiveWebview = Event.None;
    this.createWebviewElement = unsupported;
    this.createWebviewOverlay = unsupported;
  }
}, 1);
registerSingleton(IWebviewViewService, class WebviewService2 {
  constructor() {
    this.onNewResolverRegistered = Event.None;
    this.register = unsupported;
    this.resolve = unsupported;
  }
}, 1);
registerSingleton(IWebviewWorkbenchService, class WebviewWorkbenchService {
  constructor() {
    this.onDidChangeActiveWebviewEditor = Event.None;
    this.openWebview = unsupported;
    this.openRevivedWebview = unsupported;
    this.revealWebview = unsupported;
    this.registerResolver = () => Disposable.None;
    this.shouldPersist = unsupported;
    this.resolveWebview = unsupported;
  }
  get iconManager() {
    return unsupported();
  }
}, 1);
registerSingleton(IEditorDropService, class EditorDropService {
  constructor() {
    this.createEditorDropTarget = unsupported;
  }
}, 1);
registerSingleton(IRemoteAuthorityResolverService, class RemoteAuthorityResolverService {
  constructor() {
    this.onDidChangeConnectionData = Event.None;
    this.resolveAuthority = unsupported;
    this.getConnectionData = unsupported;
    this.getCanonicalURI = unsupported;
    this._clearResolvedAuthority = unsupported;
    this._setResolvedAuthority = unsupported;
    this._setResolvedAuthorityError = unsupported;
    this._setAuthorityConnectionToken = unsupported;
    this._setCanonicalURIProvider = unsupported;
  }
}, 1);
registerSingleton(IExternalUriOpenerService, ExternalUriOpenerService, 1);
registerSingleton(IAccessibleViewService, class AccessibleViewService {
  constructor() {
    this.showAccessibleViewHelp = unsupported;
    this.goToSymbol = unsupported;
    this.disableHint = unsupported;
    this.next = unsupported;
    this.previous = unsupported;
    this.getOpenAriaHint = unsupported;
    this.show = unsupported;
    this.registerProvider = unsupported;
  }
}, 1);
registerSingleton(IWorkbenchExtensionManagementService, class WorkbenchExtensionManagementService {
  constructor() {
    this.toggleAppliationScope = async (extension) => extension;
    this.onInstallExtension = Event.None;
    this.onDidInstallExtensions = Event.None;
    this.onUninstallExtension = Event.None;
    this.onDidUninstallExtension = Event.None;
    this.onDidChangeProfile = Event.None;
    this.installVSIX = unsupported;
    this.installFromLocation = unsupported;
    this.updateFromGallery = unsupported;
    this.onDidUpdateExtensionMetadata = Event.None;
    this.zip = unsupported;
    this.unzip = unsupported;
    this.getManifest = unsupported;
    this.install = unsupported;
    this.canInstall = unsupported;
    this.installFromGallery = unsupported;
    this.installGalleryExtensions = unsupported;
    this.installExtensionsFromProfile = unsupported;
    this.uninstall = unsupported;
    this.reinstallFromGallery = unsupported;
    this.getInstalled = unsupported;
    this.getExtensionsControlManifest = unsupported;
    this.copyExtensions = unsupported;
    this.updateMetadata = unsupported;
    this.download = unsupported;
    this.registerParticipant = unsupported;
    this.getTargetPlatform = unsupported;
    this.cleanUp = unsupported;
  }
}, 1);
registerSingleton(IExtensionManifestPropertiesService, class ExtensionManifestPropertiesService3 {
  constructor() {
    this.prefersExecuteOnUI = unsupported;
    this.prefersExecuteOnWorkspace = unsupported;
    this.prefersExecuteOnWeb = unsupported;
    this.canExecuteOnUI = unsupported;
    this.canExecuteOnWorkspace = unsupported;
    this.canExecuteOnWeb = unsupported;
    this.getExtensionKind = unsupported;
    this.getUserConfiguredExtensionKind = unsupported;
    this.getExtensionUntrustedWorkspaceSupportType = unsupported;
    this.getExtensionVirtualWorkspaceSupportType = unsupported;
  }
}, 1);
registerSingleton(IWorkspaceTrustEnablementService, class WorkspaceTrustEnablementService3 {
  isWorkspaceTrustEnabled() {
    return false;
  }
}, 1);
registerSingleton(IRemoteExtensionsScannerService, class RemoteExtensionsScannerService {
  whenExtensionsReady() {
    throw new Error("Method not implemented.");
  }
  async scanExtensions() {
    return [];
  }
  async scanSingleExtension() {
    return null;
  }
}, 1);
registerSingleton(IURLService, BrowserURLService, 1);
registerSingleton(ICredentialsService, class CredentialsService {
  constructor() {
    this.onDidChangePassword = Event.None;
    this.getSecretStoragePrefix = async () => "code-oss";
    this.getPassword = unsupported;
    this.setPassword = unsupported;
    this.deletePassword = unsupported;
    this.findPassword = unsupported;
    this.findCredentials = unsupported;
  }
}, 1);
registerSingleton(IRemoteSocketFactoryService, class RemoteSocketFactoryService {
  constructor() {
    this.register = unsupported;
    this.connect = unsupported;
  }
}, 1);
registerSingleton(IQuickDiffService, class QuickDiffService {
  constructor() {
    this.onDidChangeQuickDiffProviders = Event.None;
    this.addQuickDiffProvider = unsupported;
    this.getQuickDiffs = unsupported;
  }
}, 1);
registerSingleton(ISCMService, class SCMService {
  constructor() {
    this.onDidAddRepository = Event.None;
    this.onDidRemoveRepository = Event.None;
    this.repositories = [];
    this.repositoryCount = 0;
    this.registerSCMProvider = unsupported;
    this.getRepository = unsupported;
  }
}, 1);
registerSingleton(IDownloadService, class DownloadService {
  constructor() {
    this.download = unsupported;
  }
}, 1);
registerSingleton(IExtensionUrlHandler, class ExtensionUrlHandler {
  constructor() {
    this.registerExtensionHandler = unsupported;
    this.unregisterExtensionHandler = unsupported;
  }
}, 1);
registerSingleton(ICommentService, class CommentService {
  constructor() {
    this.onDidSetResourceCommentInfos = Event.None;
    this.onDidSetAllCommentThreads = Event.None;
    this.onDidUpdateCommentThreads = Event.None;
    this.onDidUpdateNotebookCommentThreads = Event.None;
    this.onDidChangeActiveCommentThread = Event.None;
    this.onDidChangeCurrentCommentThread = Event.None;
    this.onDidUpdateCommentingRanges = Event.None;
    this.onDidChangeActiveCommentingRange = Event.None;
    this.onDidSetDataProvider = Event.None;
    this.onDidDeleteDataProvider = Event.None;
    this.onDidChangeCommentingEnabled = Event.None;
    this.isCommentingEnabled = false;
    this.setDocumentComments = unsupported;
    this.setWorkspaceComments = unsupported;
    this.removeWorkspaceComments = unsupported;
    this.registerCommentController = unsupported;
    this.unregisterCommentController = () => {
    };
    this.getCommentController = unsupported;
    this.createCommentThreadTemplate = unsupported;
    this.updateCommentThreadTemplate = unsupported;
    this.getCommentMenus = unsupported;
    this.updateComments = unsupported;
    this.updateNotebookComments = unsupported;
    this.disposeCommentThread = unsupported;
    this.getDocumentComments = unsupported;
    this.getNotebookComments = unsupported;
    this.updateCommentingRanges = unsupported;
    this.hasReactionHandler = unsupported;
    this.toggleReaction = unsupported;
    this.setActiveCommentThread = unsupported;
    this.setCurrentCommentThread = unsupported;
    this.enableCommenting = unsupported;
  }
}, 1);
registerSingleton(INotebookCellStatusBarService, class NotebookCellStatusBarService {
  constructor() {
    this.onDidChangeProviders = Event.None;
    this.onDidChangeItems = Event.None;
    this.registerCellStatusBarItemProvider = unsupported;
    this.getStatusBarItemsForCell = unsupported;
  }
}, 1);
registerSingleton(INotebookKernelService, class NotebookKernelService {
  constructor() {
    this.onDidAddKernel = Event.None;
    this.onDidRemoveKernel = Event.None;
    this.onDidChangeSelectedNotebooks = Event.None;
    this.onDidChangeNotebookAffinity = Event.None;
    this.registerKernel = unsupported;
    this.getMatchingKernel = unsupported;
    this.getSelectedOrSuggestedKernel = unsupported;
    this.selectKernelForNotebook = unsupported;
    this.preselectKernelForNotebook = unsupported;
    this.updateKernelNotebookAffinity = unsupported;
    this.onDidChangeKernelDetectionTasks = Event.None;
    this.registerNotebookKernelDetectionTask = unsupported;
    this.getKernelDetectionTasks = unsupported;
    this.onDidChangeSourceActions = Event.None;
    this.getSourceActions = unsupported;
    this.getRunningSourceActions = unsupported;
    this.registerKernelSourceActionProvider = unsupported;
    this.getKernelSourceActions2 = unsupported;
  }
}, 1);
registerSingleton(INotebookRendererMessagingService, class NotebookRendererMessagingService {
  constructor() {
    this.onShouldPostMessage = Event.None;
    this.prepare = unsupported;
    this.getScoped = unsupported;
    this.receiveMessage = unsupported;
  }
}, 1);
registerSingleton(IInteractiveDocumentService, class InteractiveDocumentService {
  constructor() {
    this.onWillAddInteractiveDocument = Event.None;
    this.onWillRemoveInteractiveDocument = Event.None;
    this.willCreateInteractiveDocument = unsupported;
    this.willRemoveInteractiveDocument = unsupported;
  }
}, 1);
registerSingleton(IInlineChatService, class InlineChatService {
  constructor() {
    this.onDidChangeProviders = Event.None;
    this.addProvider = unsupported;
    this.getAllProvider = () => [];
  }
}, 1);
registerSingleton(IChatWidgetService, class ChatWidgetService {
  constructor() {
    this.getWidgetBySessionId = () => void 0;
    this.lastFocusedWidget = void 0;
    this.revealViewForProvider = unsupported;
    this.getWidgetByInputUri = unsupported;
  }
}, 1);
registerSingleton(IRemoteExplorerService, class RemoteExplorerService {
  constructor() {
    this.onDidChangeTargetType = Event.None;
    this.targetType = [];
    this.onDidChangeEditable = Event.None;
    this.setEditable = unsupported;
    this.getEditableData = unsupported;
    this.forward = unsupported;
    this.close = unsupported;
    this.setTunnelInformation = unsupported;
    this.setCandidateFilter = unsupported;
    this.onFoundNewCandidates = unsupported;
    this.restore = unsupported;
    this.enablePortsFeatures = unsupported;
    this.onEnabledPortsFeatures = Event.None;
    this.portsFeaturesEnabled = false;
    this.namedProcesses = /* @__PURE__ */ new Map();
  }
  get tunnelModel() {
    return unsupported();
  }
}, 1);
registerSingleton(IAuthenticationService, class AuthenticationService {
  constructor() {
    this.isAuthenticationProviderRegistered = () => false;
    this.getProviderIds = () => [];
    this.registerAuthenticationProvider = unsupported;
    this.unregisterAuthenticationProvider = unsupported;
    this.isAccessAllowed = () => false;
    this.updateAllowedExtension = unsupported;
    this.updateSessionPreference = unsupported;
    this.getSessionPreference = () => void 0;
    this.removeSessionPreference = unsupported;
    this.showGetSessionPrompt = unsupported;
    this.selectSession = unsupported;
    this.requestSessionAccess = unsupported;
    this.completeSessionAccessRequest = unsupported;
    this.requestNewSession = unsupported;
    this.sessionsUpdate = unsupported;
    this.onDidRegisterAuthenticationProvider = Event.None;
    this.onDidUnregisterAuthenticationProvider = Event.None;
    this.onDidChangeSessions = Event.None;
    this.declaredProviders = [];
    this.onDidChangeDeclaredProviders = Event.None;
    this.getSessions = async () => [];
    this.getLabel = unsupported;
    this.supportsMultipleAccounts = () => false;
    this.createSession = unsupported;
    this.removeSession = unsupported;
    this.manageTrustedExtensionsForAccount = unsupported;
    this.removeAccountSessions = unsupported;
  }
}, 1);
registerSingleton(ITimelineService, class TimelineService {
  constructor() {
    this.onDidChangeProviders = Event.None;
    this.onDidChangeTimeline = Event.None;
    this.onDidChangeUri = Event.None;
    this.registerTimelineProvider = unsupported;
    this.unregisterTimelineProvider = unsupported;
    this.getSources = () => [];
    this.getTimeline = unsupported;
    this.setUri = unsupported;
  }
}, 1);
registerSingleton(ITestService, class TestService {
  constructor() {
    this.onDidCancelTestRun = Event.None;
    this.onWillProcessDiff = Event.None;
    this.onDidProcessDiff = Event.None;
    this.registerTestController = unsupported;
    this.getTestController = () => void 0;
    this.refreshTests = unsupported;
    this.cancelRefreshTests = unsupported;
    this.startContinuousRun = unsupported;
    this.runTests = unsupported;
    this.runResolvedTests = unsupported;
    this.syncTests = unsupported;
    this.cancelTestRun = unsupported;
    this.publishDiff = unsupported;
  }
  get excluded() {
    return unsupported();
  }
  get collection() {
    return unsupported();
  }
  get showInlineOutput() {
    return unsupported();
  }
}, 1);
registerSingleton(ISecretStorageService, class SecretStorageService {
  constructor() {
    this.onDidChangeSecret = Event.None;
    this.type = "in-memory";
    this.get = async () => void 0;
    this.set = unsupported;
    this.delete = unsupported;
  }
}, 1);
registerSingleton(IShareService, class ShareService {
  constructor() {
    this.registerShareProvider = unsupported;
    this.getShareActions = () => [];
    this.provideShare = async () => void 0;
  }
}, 1);
registerSingleton(IUserDataProfileImportExportService, class UserDataProfileImportExportService {
  constructor() {
    this.createProfile = unsupported;
    this.editProfile = unsupported;
    this.registerProfileContentHandler = unsupported;
    this.unregisterProfileContentHandler = unsupported;
    this.exportProfile = unsupported;
    this.importProfile = unsupported;
    this.showProfileContents = unsupported;
    this.createFromCurrentProfile = unsupported;
    this.createTroubleshootProfile = unsupported;
    this.setProfile = unsupported;
  }
}, 1);
registerSingleton(IWorkbenchIssueService, class WorkbenchIssueService {
  constructor() {
    this.openReporter = unsupported;
    this.openProcessExplorer = unsupported;
    this.registerIssueUriRequestHandler = unsupported;
  }
}, 1);
registerSingleton(ISCMViewService, class SCMViewService {
  constructor() {
    this.repositories = [];
    this.onDidChangeRepositories = Event.None;
    this.visibleRepositories = [];
    this.onDidChangeVisibleRepositories = Event.None;
    this.isVisible = () => false;
    this.toggleVisibility = unsupported;
    this.toggleSortKey = unsupported;
    this.focusedRepository = void 0;
    this.onDidFocusRepository = Event.None;
    this.focus = unsupported;
  }
  get menus() {
    return unsupported();
  }
}, 1);
registerSingleton(INotebookExecutionStateService, class NotebookExecutionStateService {
  constructor() {
    this.onDidChangeExecution = Event.None;
    this.onDidChangeLastRunFailState = Event.None;
    this.forceCancelNotebookExecutions = unsupported;
    this.getCellExecutionsForNotebook = unsupported;
    this.getCellExecutionsByHandleForNotebook = unsupported;
    this.getCellExecution = unsupported;
    this.createCellExecution = unsupported;
    this.getExecution = unsupported;
    this.createExecution = unsupported;
    this.getLastFailedCellForNotebook = unsupported;
  }
}, 1);
registerSingleton(IChatContributionService, class ChatContributionService {
  constructor() {
    this.registeredProviders = [];
    this.getViewIdForProvider = unsupported;
  }
}, 1);
registerSingleton(ITestProfileService, class TestProfileService {
  constructor() {
    this.onDidChange = Event.None;
    this.addProfile = unsupported;
    this.updateProfile = unsupported;
    this.removeProfile = unsupported;
    this.capabilitiesForTest = unsupported;
    this.configure = unsupported;
    this.all = () => [];
    this.getGroupDefaultProfiles = () => [];
    this.setGroupDefaultProfiles = unsupported;
    this.getControllerProfiles = () => [];
  }
}, 1);
registerSingleton(IEncryptionService, class EncryptionService {
  constructor() {
    this.setUsePlainTextEncryption = unsupported;
    this.getKeyStorageProvider = unsupported;
    this.encrypt = unsupported;
    this.decrypt = unsupported;
    this.isEncryptionAvailable = unsupported;
  }
}, 1);
registerSingleton(ITestResultService, class TestResultService {
  constructor() {
    this.onResultsChanged = Event.None;
    this.onTestChanged = Event.None;
    this.results = [];
    this.clear = unsupported;
    this.createLiveResult = unsupported;
    this.push = unsupported;
    this.getResult = () => void 0;
    this.getStateById = () => void 0;
  }
}, 1);
registerSingleton(IUserDataInitializationService, class UserDataInitializationService {
  constructor() {
    this.requiresInitialization = async () => false;
    this.whenInitializationFinished = async () => {
    };
    this.initializeRequiredResources = async () => {
    };
    this.initializeInstalledExtensions = async () => {
    };
    this.initializeOtherResources = async () => {
    };
  }
}, 1);
registerSingleton(IDiagnosticsService, NullDiagnosticsService, 1);
registerSingleton(INotebookSearchService, class NotebookSearchService {
  notebookSearch() {
    return {
      openFilesToScan: new ResourceSet(),
      completeData: Promise.resolve({
        results: [],
        messages: []
      }),
      allScannedFiles: Promise.resolve(new ResourceSet())
    };
  }
}, 1);
registerSingleton(IChatProviderService, class ChatProviderService {
  constructor() {
    this.registerChatResponseProvider = unsupported;
    this.fetchChatResponse = unsupported;
  }
}, 1);
registerSingleton(IChatSlashCommandService, class ChatSlashCommandService {
  constructor() {
    this.onDidChangeCommands = unsupported;
    this.registerSlashData = unsupported;
    this.registerSlashCallback = unsupported;
    this.registerSlashCommand = unsupported;
    this.executeCommand = unsupported;
    this.getCommands = unsupported;
    this.hasCommand = unsupported;
  }
}, 1);
registerSingleton(IChatVariablesService, class ChatVariablesService {
  constructor() {
    this.registerVariable = unsupported;
    this.getVariables = unsupported;
    this.resolveVariables = unsupported;
  }
}, 1);
registerSingleton(IAiRelatedInformationService, class AiRelatedInformationService {
  constructor() {
    this.isEnabled = () => false;
    this.getRelatedInformation = unsupported;
    this.registerAiRelatedInformationProvider = unsupported;
  }
}, 1);
registerSingleton(IAiEmbeddingVectorService, class AiEmbeddingVectorService2 {
  constructor() {
    this.isEnabled = () => false;
    this.getEmbeddingVector = unsupported;
    this.registerAiEmbeddingVectorProvider = unsupported;
  }
}, 1);
registerSingleton(ISignService, (_a23 = class SignService {
  async createNewMessage(value) {
    const id = String(_a23._nextId++);
    return {
      id,
      data: value
    };
  }
  async validate() {
    return true;
  }
  async sign(value) {
    return value;
  }
}, _a23._nextId = 1, _a23), 1);

// node_modules/vscode/service-override/files.js
init_tslib_es6();
init_descriptors();

// node_modules/vscode/vscode/src/vs/platform/files/common/fileService.js
init_tslib_es6();
init_arrays();
init_async();
init_buffer();
init_cancellation();
init_event();
init_hash();
init_iterator();
init_lifecycle();
init_ternarySearchTree();
init_network();
init_resources();
init_stream();
init_nls();
init_files();

// node_modules/vscode/vscode/src/vs/platform/files/common/io.js
init_buffer();
init_errors();
init_nls();
init_files();
async function readFileIntoStream(provider, resource, target, transformer, options, token) {
  let error = void 0;
  try {
    await doReadFileIntoStream(provider, resource, target, transformer, options, token);
  } catch (err) {
    error = err;
  } finally {
    if (error && options.errorTransformer) {
      error = options.errorTransformer(error);
    }
    if (typeof error !== "undefined") {
      target.error(error);
    }
    target.end();
  }
}
async function doReadFileIntoStream(provider, resource, target, transformer, options, token) {
  throwIfCancelled(token);
  const handle = await provider.open(resource, { create: false });
  try {
    throwIfCancelled(token);
    let totalBytesRead = 0;
    let bytesRead = 0;
    let allowedRemainingBytes = options && typeof options.length === "number" ? options.length : void 0;
    let buffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === "number" ? allowedRemainingBytes : options.bufferSize));
    let posInFile = options && typeof options.position === "number" ? options.position : 0;
    let posInBuffer = 0;
    do {
      bytesRead = await provider.read(handle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);
      posInFile += bytesRead;
      posInBuffer += bytesRead;
      totalBytesRead += bytesRead;
      if (typeof allowedRemainingBytes === "number") {
        allowedRemainingBytes -= bytesRead;
      }
      if (posInBuffer === buffer.byteLength) {
        await target.write(transformer(buffer));
        buffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === "number" ? allowedRemainingBytes : options.bufferSize));
        posInBuffer = 0;
      }
    } while (bytesRead > 0 && (typeof allowedRemainingBytes !== "number" || allowedRemainingBytes > 0) && throwIfCancelled(token) && throwIfTooLarge(totalBytesRead, options));
    if (posInBuffer > 0) {
      let lastChunkLength = posInBuffer;
      if (typeof allowedRemainingBytes === "number") {
        lastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);
      }
      target.write(transformer(buffer.slice(0, lastChunkLength)));
    }
  } catch (error) {
    throw ensureFileSystemProviderError(error);
  } finally {
    await provider.close(handle);
  }
}
function throwIfCancelled(token) {
  if (token.isCancellationRequested) {
    throw canceled();
  }
  return true;
}
function throwIfTooLarge(totalBytesRead, options) {
  var _a43;
  if (typeof ((_a43 = options == null ? void 0 : options.limits) == null ? void 0 : _a43.size) === "number" && totalBytesRead > options.limits.size) {
    throw createFileSystemProviderError(localize("fileTooLargeError", "File is too large to open"), FileSystemProviderErrorCode.FileTooLarge);
  }
  return true;
}

// node_modules/vscode/vscode/src/vs/platform/files/common/fileService.js
init_log();
init_errors();
var FileService2 = class FileService3 extends Disposable {
  constructor(logService) {
    super();
    this.logService = logService;
    this.BUFFER_SIZE = 256 * 1024;
    this._onDidChangeFileSystemProviderRegistrations = this._register(new Emitter());
    this.onDidChangeFileSystemProviderRegistrations = this._onDidChangeFileSystemProviderRegistrations.event;
    this._onWillActivateFileSystemProvider = this._register(new Emitter());
    this.onWillActivateFileSystemProvider = this._onWillActivateFileSystemProvider.event;
    this._onDidChangeFileSystemProviderCapabilities = this._register(new Emitter());
    this.onDidChangeFileSystemProviderCapabilities = this._onDidChangeFileSystemProviderCapabilities.event;
    this.provider = /* @__PURE__ */ new Map();
    this._onDidRunOperation = this._register(new Emitter());
    this.onDidRunOperation = this._onDidRunOperation.event;
    this._onDidFilesChange = this._register(new Emitter());
    this.onDidFilesChange = this._onDidFilesChange.event;
    this._onDidWatchError = this._register(new Emitter());
    this.onDidWatchError = this._onDidWatchError.event;
    this.activeWatchers = /* @__PURE__ */ new Map();
    this.writeQueue = this._register(new ResourceQueue());
  }
  registerProvider(scheme, provider) {
    if (this.provider.has(scheme)) {
      throw new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);
    }
    mark(`code/registerFilesystem/${scheme}`);
    const providerDisposables = new DisposableStore();
    this.provider.set(scheme, provider);
    this._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme, provider });
    providerDisposables.add(provider.onDidChangeFile((changes) => this._onDidFilesChange.fire(new FileChangesEvent(changes, !this.isPathCaseSensitive(provider)))));
    if (typeof provider.onDidWatchError === "function") {
      providerDisposables.add(provider.onDidWatchError((error) => this._onDidWatchError.fire(new Error(error))));
    }
    providerDisposables.add(provider.onDidChangeCapabilities(() => this._onDidChangeFileSystemProviderCapabilities.fire({ provider, scheme })));
    return toDisposable(() => {
      this._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme, provider });
      this.provider.delete(scheme);
      dispose(providerDisposables);
    });
  }
  getProvider(scheme) {
    return this.provider.get(scheme);
  }
  async activateProvider(scheme) {
    const joiners = [];
    this._onWillActivateFileSystemProvider.fire({
      scheme,
      join(promise) {
        joiners.push(promise);
      }
    });
    if (this.provider.has(scheme)) {
      return;
    }
    await Promises.settled(joiners);
  }
  async canHandleResource(resource) {
    await this.activateProvider(resource.scheme);
    return this.hasProvider(resource);
  }
  hasProvider(resource) {
    return this.provider.has(resource.scheme);
  }
  hasCapability(resource, capability) {
    const provider = this.provider.get(resource.scheme);
    return !!(provider && provider.capabilities & capability);
  }
  listCapabilities() {
    return Iterable.map(
      this.provider,
      ([scheme, provider]) => ({ scheme, capabilities: provider.capabilities })
    );
  }
  async withProvider(resource) {
    if (!isAbsolutePath(resource)) {
      throw new FileOperationError(localize("invalidPath", "Unable to resolve filesystem provider with relative file path '{0}'", this.resourceForError(resource)), 8);
    }
    await this.activateProvider(resource.scheme);
    const provider = this.provider.get(resource.scheme);
    if (!provider) {
      const error = new ErrorNoTelemetry();
      error.message = localize(
        "noProviderFound",
        "ENOPRO: No file system provider found for resource '{0}'",
        resource.toString()
      );
      throw error;
    }
    return provider;
  }
  async withReadProvider(resource) {
    const provider = await this.withProvider(resource);
    if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider) || hasFileReadStreamCapability(provider)) {
      return provider;
    }
    throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);
  }
  async withWriteProvider(resource) {
    const provider = await this.withProvider(resource);
    if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {
      return provider;
    }
    throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);
  }
  async resolve(resource, options) {
    try {
      return await this.doResolveFile(resource, options);
    } catch (error) {
      if (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {
        throw new FileOperationError(localize("fileNotFoundError", "Unable to resolve nonexistent file '{0}'", this.resourceForError(resource)), 1);
      }
      throw ensureFileSystemProviderError(error);
    }
  }
  async doResolveFile(resource, options) {
    const provider = await this.withProvider(resource);
    const isPathCaseSensitive = this.isPathCaseSensitive(provider);
    const resolveTo = options == null ? void 0 : options.resolveTo;
    const resolveSingleChildDescendants = options == null ? void 0 : options.resolveSingleChildDescendants;
    const resolveMetadata = options == null ? void 0 : options.resolveMetadata;
    const stat = await provider.stat(resource);
    let trie;
    return this.toFileStat(provider, resource, stat, void 0, !!resolveMetadata, (stat2, siblings) => {
      if (!trie) {
        trie = TernarySearchTree.forUris(() => !isPathCaseSensitive);
        trie.set(resource, true);
        if (resolveTo) {
          trie.fill(true, resolveTo);
        }
      }
      if (trie.get(stat2.resource) || trie.findSuperstr(stat2.resource.with({ query: null, fragment: null }))) {
        return true;
      }
      if (stat2.isDirectory && resolveSingleChildDescendants) {
        return siblings === 1;
      }
      return false;
    });
  }
  async toFileStat(provider, resource, stat, siblings, resolveMetadata, recurse) {
    const { providerExtUri } = this.getExtUri(provider);
    const fileStat = {
      resource,
      name: providerExtUri.basename(resource),
      isFile: (stat.type & FileType.File) !== 0,
      isDirectory: (stat.type & FileType.Directory) !== 0,
      isSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,
      mtime: stat.mtime,
      ctime: stat.ctime,
      size: stat.size,
      readonly: Boolean((stat.permissions ?? 0) & FilePermission.Readonly) || Boolean(provider.capabilities & 2048),
      locked: Boolean((stat.permissions ?? 0) & FilePermission.Locked),
      etag: etag({ mtime: stat.mtime, size: stat.size }),
      children: void 0
    };
    if (fileStat.isDirectory && recurse(fileStat, siblings)) {
      try {
        const entries = await provider.readdir(resource);
        const resolvedEntries = await Promises.settled(entries.map(async ([name, type]) => {
          try {
            const childResource = providerExtUri.joinPath(resource, name);
            const childStat = resolveMetadata ? await provider.stat(childResource) : { type };
            return await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);
          } catch (error) {
            this.logService.trace(error);
            return null;
          }
        }));
        fileStat.children = coalesce(resolvedEntries);
      } catch (error) {
        this.logService.trace(error);
        fileStat.children = [];
      }
      return fileStat;
    }
    return fileStat;
  }
  async resolveAll(toResolve) {
    return Promises.settled(toResolve.map(async (entry) => {
      try {
        return { stat: await this.doResolveFile(entry.resource, entry.options), success: true };
      } catch (error) {
        this.logService.trace(error);
        return { stat: void 0, success: false };
      }
    }));
  }
  async stat(resource) {
    const provider = await this.withProvider(resource);
    const stat = await provider.stat(resource);
    return this.toFileStat(provider, resource, stat, void 0, true, () => false);
  }
  async exists(resource) {
    const provider = await this.withProvider(resource);
    try {
      const stat = await provider.stat(resource);
      return !!stat;
    } catch (error) {
      return false;
    }
  }
  async canCreateFile(resource, options) {
    try {
      await this.doValidateCreateFile(resource, options);
    } catch (error) {
      return error;
    }
    return true;
  }
  async doValidateCreateFile(resource, options) {
    if (!(options == null ? void 0 : options.overwrite) && await this.exists(resource)) {
      throw new FileOperationError(localize("fileExists", "Unable to create file '{0}' that already exists when overwrite flag is not set", this.resourceForError(resource)), 3, options);
    }
  }
  async createFile(resource, bufferOrReadableOrStream = VSBuffer.fromString(""), options) {
    await this.doValidateCreateFile(resource, options);
    const fileStat = await this.writeFile(resource, bufferOrReadableOrStream);
    this._onDidRunOperation.fire(new FileOperationEvent(resource, 0, fileStat));
    return fileStat;
  }
  async writeFile(resource, bufferOrReadableOrStream, options) {
    var _a43;
    const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);
    const { providerExtUri } = this.getExtUri(provider);
    try {
      const stat = await this.validateWriteFile(provider, resource, options);
      if (!stat) {
        await this.mkdirp(provider, providerExtUri.dirname(resource));
      }
      let bufferOrReadableOrStreamOrBufferedStream;
      if (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof VSBuffer)) {
        if (isReadableStream(bufferOrReadableOrStream)) {
          const bufferedStream = await peekStream(bufferOrReadableOrStream, 3);
          if (bufferedStream.ended) {
            bufferOrReadableOrStreamOrBufferedStream = VSBuffer.concat(bufferedStream.buffer);
          } else {
            bufferOrReadableOrStreamOrBufferedStream = bufferedStream;
          }
        } else {
          bufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, (data) => VSBuffer.concat(data), 3);
        }
      } else {
        bufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;
      }
      if (!hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) {
        await this.doWriteUnbuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream);
      } else {
        const contents = bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer ? bufferToReadable(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream;
        if ((options == null ? void 0 : options.atomic) !== false && ((_a43 = options == null ? void 0 : options.atomic) == null ? void 0 : _a43.postfix)) {
          await this.doWriteBufferedAtomic(provider, resource, joinPath(dirname(resource), `${basename2(resource)}${options.atomic.postfix}`), options, contents);
        } else {
          await this.doWriteBuffered(provider, resource, options, contents);
        }
      }
      this._onDidRunOperation.fire(new FileOperationEvent(resource, 4));
    } catch (error) {
      throw new FileOperationError(localize("err.write", "Unable to write file '{0}' ({1})", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options);
    }
    return this.resolve(resource, { resolveMetadata: true });
  }
  async validateWriteFile(provider, resource, options) {
    const unlock = !!(options == null ? void 0 : options.unlock);
    if (unlock && !(provider.capabilities & 8192)) {
      throw new Error(localize("writeFailedUnlockUnsupported", "Unable to unlock file '{0}' because provider does not support it.", this.resourceForError(resource)));
    }
    const atomic = !!(options == null ? void 0 : options.atomic);
    if (atomic) {
      if (!(provider.capabilities & 32768)) {
        throw new Error(localize("writeFailedAtomicUnsupported", "Unable to atomically write file '{0}' because provider does not support it.", this.resourceForError(resource)));
      }
      if (unlock) {
        throw new Error(localize("writeFailedAtomicUnlock", "Unable to unlock file '{0}' because atomic write is enabled.", this.resourceForError(resource)));
      }
    }
    let stat = void 0;
    try {
      stat = await provider.stat(resource);
    } catch (error) {
      return void 0;
    }
    if ((stat.type & FileType.Directory) !== 0) {
      throw new FileOperationError(localize("fileIsDirectoryWriteError", "Unable to write file '{0}' that is actually a directory", this.resourceForError(resource)), 0, options);
    }
    this.throwIfFileIsReadonly(resource, stat);
    if (typeof (options == null ? void 0 : options.mtime) === "number" && typeof options.etag === "string" && options.etag !== ETAG_DISABLED && typeof stat.mtime === "number" && typeof stat.size === "number" && options.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime, size: stat.size })) {
      throw new FileOperationError(localize("fileModifiedError", "File Modified Since"), 3, options);
    }
    return stat;
  }
  async readFile(resource, options, token) {
    const provider = await this.withReadProvider(resource);
    if (options == null ? void 0 : options.atomic) {
      return this.doReadFileAtomic(provider, resource, options, token);
    }
    return this.doReadFile(provider, resource, options, token);
  }
  async doReadFileAtomic(provider, resource, options, token) {
    return new Promise((resolve, reject) => {
      this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {
        try {
          const content = await this.doReadFile(provider, resource, options, token);
          resolve(content);
        } catch (error) {
          reject(error);
        }
      });
    });
  }
  async doReadFile(provider, resource, options, token) {
    const stream = await this.doReadFileStream(provider, resource, {
      ...options,
      preferUnbuffered: true
    }, token);
    return {
      ...stream,
      value: await streamToBuffer(stream.value)
    };
  }
  async readFileStream(resource, options, token) {
    const provider = await this.withReadProvider(resource);
    return this.doReadFileStream(provider, resource, options, token);
  }
  async doReadFileStream(provider, resource, options, token) {
    const cancellableSource = new CancellationTokenSource(token);
    const statPromise = this.validateReadFile(resource, options).then((stat) => stat, (error) => {
      cancellableSource.cancel();
      throw error;
    });
    let fileStream = void 0;
    try {
      if (typeof (options == null ? void 0 : options.etag) === "string" && options.etag !== ETAG_DISABLED) {
        await statPromise;
      }
      if ((options == null ? void 0 : options.atomic) && hasFileAtomicReadCapability(provider) || !(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) || hasReadWriteCapability(provider) && (options == null ? void 0 : options.preferUnbuffered)) {
        fileStream = this.readFileUnbuffered(provider, resource, options);
      } else if (hasFileReadStreamCapability(provider)) {
        fileStream = this.readFileStreamed(provider, resource, cancellableSource.token, options);
      } else {
        fileStream = this.readFileBuffered(provider, resource, cancellableSource.token, options);
      }
      const fileStat = await statPromise;
      return {
        ...fileStat,
        value: fileStream
      };
    } catch (error) {
      if (fileStream) {
        await consumeStream(fileStream);
      }
      throw this.restoreReadError(error, resource, options);
    }
  }
  restoreReadError(error, resource, options) {
    const message = localize(
      "err.read",
      "Unable to read file '{0}' ({1})",
      this.resourceForError(resource),
      ensureFileSystemProviderError(error).toString()
    );
    if (error instanceof NotModifiedSinceFileOperationError) {
      return new NotModifiedSinceFileOperationError(message, error.stat, options);
    }
    if (error instanceof TooLargeFileOperationError) {
      return new TooLargeFileOperationError(message, error.fileOperationResult, error.size, error.options);
    }
    return new FileOperationError(message, toFileOperationResult(error), options);
  }
  readFileStreamed(provider, resource, token, options = /* @__PURE__ */ Object.create(null)) {
    const fileStream = provider.readFileStream(resource, options, token);
    return transform(fileStream, {
      data: (data) => data instanceof VSBuffer ? data : VSBuffer.wrap(data),
      error: (error) => this.restoreReadError(error, resource, options)
    }, (data) => VSBuffer.concat(data));
  }
  readFileBuffered(provider, resource, token, options = /* @__PURE__ */ Object.create(null)) {
    const stream = newWriteableBufferStream();
    readFileIntoStream(provider, resource, stream, (data) => data, {
      ...options,
      bufferSize: this.BUFFER_SIZE,
      errorTransformer: (error) => this.restoreReadError(error, resource, options)
    }, token);
    return stream;
  }
  readFileUnbuffered(provider, resource, options) {
    const stream = newWriteableStream((data) => VSBuffer.concat(data));
    (async () => {
      try {
        let buffer;
        if ((options == null ? void 0 : options.atomic) && hasFileAtomicReadCapability(provider)) {
          buffer = await provider.readFile(resource, { atomic: true });
        } else {
          buffer = await provider.readFile(resource);
        }
        if (typeof (options == null ? void 0 : options.position) === "number") {
          buffer = buffer.slice(options.position);
        }
        if (typeof (options == null ? void 0 : options.length) === "number") {
          buffer = buffer.slice(0, options.length);
        }
        this.validateReadFileLimits(resource, buffer.byteLength, options);
        stream.end(VSBuffer.wrap(buffer));
      } catch (err) {
        stream.error(err);
        stream.end();
      }
    })();
    return stream;
  }
  async validateReadFile(resource, options) {
    const stat = await this.resolve(resource, { resolveMetadata: true });
    if (stat.isDirectory) {
      throw new FileOperationError(localize("fileIsDirectoryReadError", "Unable to read file '{0}' that is actually a directory", this.resourceForError(resource)), 0, options);
    }
    if (typeof (options == null ? void 0 : options.etag) === "string" && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {
      throw new NotModifiedSinceFileOperationError(localize("fileNotModifiedError", "File not modified since"), stat, options);
    }
    this.validateReadFileLimits(resource, stat.size, options);
    return stat;
  }
  validateReadFileLimits(resource, size, options) {
    var _a43;
    if (typeof ((_a43 = options == null ? void 0 : options.limits) == null ? void 0 : _a43.size) === "number" && size > options.limits.size) {
      throw new TooLargeFileOperationError(localize("fileTooLargeError", "Unable to read file '{0}' that is too large to open", this.resourceForError(resource)), 7, size, options);
    }
  }
  async canMove(source, target, overwrite) {
    return this.doCanMoveCopy(source, target, "move", overwrite);
  }
  async canCopy(source, target, overwrite) {
    return this.doCanMoveCopy(source, target, "copy", overwrite);
  }
  async doCanMoveCopy(source, target, mode, overwrite) {
    if (source.toString() !== target.toString()) {
      try {
        const sourceProvider = mode === "move" ? this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source) : await this.withReadProvider(source);
        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);
        await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);
      } catch (error) {
        return error;
      }
    }
    return true;
  }
  async move(source, target, overwrite) {
    const sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);
    const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);
    const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, "move", !!overwrite);
    const fileStat = await this.resolve(target, { resolveMetadata: true });
    this._onDidRunOperation.fire(new FileOperationEvent(
      source,
      mode === "move" ? 2 : 3,
      fileStat
    ));
    return fileStat;
  }
  async copy(source, target, overwrite) {
    const sourceProvider = await this.withReadProvider(source);
    const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);
    const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, "copy", !!overwrite);
    const fileStat = await this.resolve(target, { resolveMetadata: true });
    this._onDidRunOperation.fire(new FileOperationEvent(
      source,
      mode === "copy" ? 3 : 2,
      fileStat
    ));
    return fileStat;
  }
  async doMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite) {
    if (source.toString() === target.toString()) {
      return mode;
    }
    const { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);
    if (exists && !isSameResourceWithDifferentPathCase && overwrite) {
      await this.del(target, { recursive: true });
    }
    await this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));
    if (mode === "copy") {
      if (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {
        await sourceProvider.copy(source, target, { overwrite });
      } else {
        const sourceFile = await this.resolve(source);
        if (sourceFile.isDirectory) {
          await this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);
        } else {
          await this.doCopyFile(sourceProvider, source, targetProvider, target);
        }
      }
      return mode;
    } else {
      if (sourceProvider === targetProvider) {
        await sourceProvider.rename(source, target, { overwrite });
        return mode;
      } else {
        await this.doMoveCopy(sourceProvider, source, targetProvider, target, "copy", overwrite);
        await this.del(source, { recursive: true });
        return "copy";
      }
    }
  }
  async doCopyFile(sourceProvider, source, targetProvider, target) {
    if (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {
      return this.doPipeBuffered(sourceProvider, source, targetProvider, target);
    }
    if (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {
      return this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);
    }
    if (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {
      return this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);
    }
    if (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {
      return this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);
    }
  }
  async doCopyFolder(sourceProvider, sourceFolder, targetProvider, targetFolder) {
    await targetProvider.mkdir(targetFolder);
    if (Array.isArray(sourceFolder.children)) {
      await Promises.settled(sourceFolder.children.map(async (sourceChild) => {
        const targetChild = this.getExtUri(targetProvider).providerExtUri.joinPath(targetFolder, sourceChild.name);
        if (sourceChild.isDirectory) {
          return this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);
        } else {
          return this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);
        }
      }));
    }
  }
  async doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite) {
    let isSameResourceWithDifferentPathCase = false;
    if (sourceProvider === targetProvider) {
      const { providerExtUri, isPathCaseSensitive } = this.getExtUri(sourceProvider);
      if (!isPathCaseSensitive) {
        isSameResourceWithDifferentPathCase = providerExtUri.isEqual(source, target);
      }
      if (isSameResourceWithDifferentPathCase && mode === "copy") {
        throw new Error(localize("unableToMoveCopyError1", "Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system", this.resourceForError(source), this.resourceForError(target)));
      }
      if (!isSameResourceWithDifferentPathCase && providerExtUri.isEqualOrParent(target, source)) {
        throw new Error(localize("unableToMoveCopyError2", "Unable to move/copy when source '{0}' is parent of target '{1}'.", this.resourceForError(source), this.resourceForError(target)));
      }
    }
    const exists = await this.exists(target);
    if (exists && !isSameResourceWithDifferentPathCase) {
      if (!overwrite) {
        throw new FileOperationError(localize("unableToMoveCopyError3", "Unable to move/copy '{0}' because target '{1}' already exists at destination.", this.resourceForError(source), this.resourceForError(target)), 4);
      }
      if (sourceProvider === targetProvider) {
        const { providerExtUri } = this.getExtUri(sourceProvider);
        if (providerExtUri.isEqualOrParent(source, target)) {
          throw new Error(localize("unableToMoveCopyError4", "Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.", this.resourceForError(source), this.resourceForError(target)));
        }
      }
    }
    return { exists, isSameResourceWithDifferentPathCase };
  }
  getExtUri(provider) {
    const isPathCaseSensitive = this.isPathCaseSensitive(provider);
    return {
      providerExtUri: isPathCaseSensitive ? extUri : extUriIgnorePathCase,
      isPathCaseSensitive
    };
  }
  isPathCaseSensitive(provider) {
    return !!(provider.capabilities & 1024);
  }
  async createFolder(resource) {
    const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);
    await this.mkdirp(provider, resource);
    const fileStat = await this.resolve(resource, { resolveMetadata: true });
    this._onDidRunOperation.fire(new FileOperationEvent(resource, 0, fileStat));
    return fileStat;
  }
  async mkdirp(provider, directory) {
    const directoriesToCreate = [];
    const { providerExtUri } = this.getExtUri(provider);
    while (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {
      try {
        const stat = await provider.stat(directory);
        if ((stat.type & FileType.Directory) === 0) {
          throw new Error(localize("mkdirExistsError", "Unable to create folder '{0}' that already exists but is not a directory", this.resourceForError(directory)));
        }
        break;
      } catch (error) {
        if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {
          throw error;
        }
        directoriesToCreate.push(providerExtUri.basename(directory));
        directory = providerExtUri.dirname(directory);
      }
    }
    for (let i = directoriesToCreate.length - 1; i >= 0; i--) {
      directory = providerExtUri.joinPath(directory, directoriesToCreate[i]);
      try {
        await provider.mkdir(directory);
      } catch (error) {
        if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {
          throw error;
        }
      }
    }
  }
  async canDelete(resource, options) {
    try {
      await this.doValidateDelete(resource, options);
    } catch (error) {
      return error;
    }
    return true;
  }
  async doValidateDelete(resource, options) {
    const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);
    const useTrash = !!(options == null ? void 0 : options.useTrash);
    if (useTrash && !(provider.capabilities & 4096)) {
      throw new Error(localize("deleteFailedTrashUnsupported", "Unable to delete file '{0}' via trash because provider does not support it.", this.resourceForError(resource)));
    }
    const atomic = options == null ? void 0 : options.atomic;
    if (atomic && !(provider.capabilities & 65536)) {
      throw new Error(localize("deleteFailedAtomicUnsupported", "Unable to delete file '{0}' atomically because provider does not support it.", this.resourceForError(resource)));
    }
    if (useTrash && atomic) {
      throw new Error(localize("deleteFailedTrashAndAtomicUnsupported", "Unable to atomically delete file '{0}' because using trash is enabled.", this.resourceForError(resource)));
    }
    let stat = void 0;
    try {
      stat = await provider.stat(resource);
    } catch (error) {
    }
    if (stat) {
      this.throwIfFileIsReadonly(resource, stat);
    } else {
      throw new FileOperationError(localize("deleteFailedNotFound", "Unable to delete nonexistent file '{0}'", this.resourceForError(resource)), 1);
    }
    const recursive = !!(options == null ? void 0 : options.recursive);
    if (!recursive) {
      const stat2 = await this.resolve(resource);
      if (stat2.isDirectory && Array.isArray(stat2.children) && stat2.children.length > 0) {
        throw new Error(localize("deleteFailedNonEmptyFolder", "Unable to delete non-empty folder '{0}'.", this.resourceForError(resource)));
      }
    }
    return provider;
  }
  async del(resource, options) {
    const provider = await this.doValidateDelete(resource, options);
    const useTrash = !!(options == null ? void 0 : options.useTrash);
    const recursive = !!(options == null ? void 0 : options.recursive);
    const atomic = (options == null ? void 0 : options.atomic) ?? false;
    await provider.delete(resource, { recursive, useTrash, atomic });
    this._onDidRunOperation.fire(new FileOperationEvent(resource, 1));
  }
  async cloneFile(source, target) {
    const sourceProvider = await this.withProvider(source);
    const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);
    if (sourceProvider === targetProvider && this.getExtUri(sourceProvider).providerExtUri.isEqual(source, target)) {
      return;
    }
    if (sourceProvider === targetProvider && hasFileCloneCapability(sourceProvider)) {
      return sourceProvider.cloneFile(source, target);
    }
    await this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));
    const sourceWriteQueue = this.writeQueue.queueFor(source, this.getExtUri(sourceProvider).providerExtUri);
    if (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {
      return sourceWriteQueue.queue(() => sourceProvider.copy(source, target, { overwrite: true }));
    }
    return sourceWriteQueue.queue(() => this.doCopyFile(sourceProvider, source, targetProvider, target));
  }
  watch(resource, options = { recursive: false, excludes: [] }) {
    const disposables = new DisposableStore();
    let watchDisposed = false;
    let disposeWatch = () => {
      watchDisposed = true;
    };
    disposables.add(toDisposable(() => disposeWatch()));
    (async () => {
      try {
        const disposable = await this.doWatch(resource, options);
        if (watchDisposed) {
          dispose(disposable);
        } else {
          disposeWatch = () => dispose(disposable);
        }
      } catch (error) {
        this.logService.error(error);
      }
    })();
    return disposables;
  }
  async doWatch(resource, options) {
    const provider = await this.withProvider(resource);
    const watchHash = hash([this.getExtUri(provider).providerExtUri.getComparisonKey(resource), options]);
    let watcher = this.activeWatchers.get(watchHash);
    if (!watcher) {
      watcher = {
        count: 0,
        disposable: provider.watch(resource, options)
      };
      this.activeWatchers.set(watchHash, watcher);
    }
    watcher.count += 1;
    return toDisposable(() => {
      if (watcher) {
        watcher.count--;
        if (watcher.count === 0) {
          dispose(watcher.disposable);
          this.activeWatchers.delete(watchHash);
        }
      }
    });
  }
  dispose() {
    super.dispose();
    for (const [, watcher] of this.activeWatchers) {
      dispose(watcher.disposable);
    }
    this.activeWatchers.clear();
  }
  async doWriteBufferedAtomic(provider, resource, tempResource, options, readableOrStreamOrBufferedStream) {
    await this.doWriteBuffered(provider, tempResource, options, readableOrStreamOrBufferedStream);
    try {
      await provider.rename(tempResource, resource, { overwrite: true });
    } catch (error) {
      try {
        await provider.delete(tempResource, { recursive: false, useTrash: false, atomic: false });
      } catch (error2) {
      }
      throw error;
    }
  }
  async doWriteBuffered(provider, resource, options, readableOrStreamOrBufferedStream) {
    return this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {
      const handle = await provider.open(resource, { create: true, unlock: (options == null ? void 0 : options.unlock) ?? false });
      try {
        if (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {
          await this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);
        } else {
          await this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);
        }
      } catch (error) {
        throw ensureFileSystemProviderError(error);
      } finally {
        await provider.close(handle);
      }
    });
  }
  async doWriteStreamBufferedQueued(provider, handle, streamOrBufferedStream) {
    let posInFile = 0;
    let stream;
    if (isReadableBufferedStream(streamOrBufferedStream)) {
      if (streamOrBufferedStream.buffer.length > 0) {
        const chunk = VSBuffer.concat(streamOrBufferedStream.buffer);
        await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);
        posInFile += chunk.byteLength;
      }
      if (streamOrBufferedStream.ended) {
        return;
      }
      stream = streamOrBufferedStream.stream;
    } else {
      stream = streamOrBufferedStream;
    }
    return new Promise((resolve, reject) => {
      listenStream(stream, {
        onData: async (chunk) => {
          stream.pause();
          try {
            await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);
          } catch (error) {
            return reject(error);
          }
          posInFile += chunk.byteLength;
          setTimeout(() => stream.resume());
        },
        onError: (error) => reject(error),
        onEnd: () => resolve()
      });
    });
  }
  async doWriteReadableBufferedQueued(provider, handle, readable) {
    let posInFile = 0;
    let chunk;
    while ((chunk = readable.read()) !== null) {
      await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);
      posInFile += chunk.byteLength;
    }
  }
  async doWriteBuffer(provider, handle, buffer, length, posInFile, posInBuffer) {
    let totalBytesWritten = 0;
    while (totalBytesWritten < length) {
      const bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);
      totalBytesWritten += bytesWritten;
    }
  }
  async doWriteUnbuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream) {
    return this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(() => this.doWriteUnbufferedQueued(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream));
  }
  async doWriteUnbufferedQueued(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream) {
    let buffer;
    if (bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) {
      buffer = bufferOrReadableOrStreamOrBufferedStream;
    } else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {
      buffer = await streamToBuffer(bufferOrReadableOrStreamOrBufferedStream);
    } else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {
      buffer = await bufferedStreamToBuffer(bufferOrReadableOrStreamOrBufferedStream);
    } else {
      buffer = readableToBuffer(bufferOrReadableOrStreamOrBufferedStream);
    }
    await provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true, unlock: (options == null ? void 0 : options.unlock) ?? false, atomic: (options == null ? void 0 : options.atomic) ?? false });
  }
  async doPipeBuffered(sourceProvider, source, targetProvider, target) {
    return this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));
  }
  async doPipeBufferedQueued(sourceProvider, source, targetProvider, target) {
    let sourceHandle = void 0;
    let targetHandle = void 0;
    try {
      sourceHandle = await sourceProvider.open(source, { create: false });
      targetHandle = await targetProvider.open(target, { create: true, unlock: false });
      const buffer = VSBuffer.alloc(this.BUFFER_SIZE);
      let posInFile = 0;
      let posInBuffer = 0;
      let bytesRead = 0;
      do {
        bytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);
        await this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);
        posInFile += bytesRead;
        posInBuffer += bytesRead;
        if (posInBuffer === buffer.byteLength) {
          posInBuffer = 0;
        }
      } while (bytesRead > 0);
    } catch (error) {
      throw ensureFileSystemProviderError(error);
    } finally {
      await Promises.settled([
        typeof sourceHandle === "number" ? sourceProvider.close(sourceHandle) : Promise.resolve(),
        typeof targetHandle === "number" ? targetProvider.close(targetHandle) : Promise.resolve()
      ]);
    }
  }
  async doPipeUnbuffered(sourceProvider, source, targetProvider, target) {
    return this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));
  }
  async doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target) {
    return targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true, unlock: false, atomic: false });
  }
  async doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target) {
    return this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));
  }
  async doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target) {
    const targetHandle = await targetProvider.open(target, { create: true, unlock: false });
    try {
      const buffer = await sourceProvider.readFile(source);
      await this.doWriteBuffer(targetProvider, targetHandle, VSBuffer.wrap(buffer), buffer.byteLength, 0, 0);
    } catch (error) {
      throw ensureFileSystemProviderError(error);
    } finally {
      await targetProvider.close(targetHandle);
    }
  }
  async doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target) {
    const buffer = await streamToBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));
    await this.doWriteUnbuffered(targetProvider, target, void 0, buffer);
  }
  throwIfFileSystemIsReadonly(provider, resource) {
    if (provider.capabilities & 2048) {
      throw new FileOperationError(localize("err.readonly", "Unable to modify read-only file '{0}'", this.resourceForError(resource)), 6);
    }
    return provider;
  }
  throwIfFileIsReadonly(resource, stat) {
    if ((stat.permissions ?? 0) & FilePermission.Readonly) {
      throw new FileOperationError(localize("err.readonly", "Unable to modify read-only file '{0}'", this.resourceForError(resource)), 6);
    }
  }
  resourceForError(resource) {
    if (resource.scheme === Schemas.file) {
      return resource.fsPath;
    }
    return resource.toString(true);
  }
};
FileService2 = __decorate([
  __param(0, ILogService)
], FileService2);

// node_modules/vscode/service-override/files.js
init_log();

// node_modules/vscode/vscode/src/vs/platform/files/common/inMemoryFilesystemProvider.js
init_event();
init_lifecycle();
init_resources();
init_files();
var File = class {
  constructor(name) {
    this.type = FileType.File;
    this.ctime = Date.now();
    this.mtime = Date.now();
    this.size = 0;
    this.name = name;
  }
};
var Directory = class {
  constructor(name) {
    this.type = FileType.Directory;
    this.ctime = Date.now();
    this.mtime = Date.now();
    this.size = 0;
    this.name = name;
    this.entries = /* @__PURE__ */ new Map();
  }
};
var InMemoryFileSystemProvider = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidChangeCapabilities = this._register(new Emitter());
    this.onDidChangeCapabilities = this._onDidChangeCapabilities.event;
    this._capabilities = 2 | 1024;
    this.root = new Directory("");
    this._onDidChangeFile = this._register(new Emitter());
    this.onDidChangeFile = this._onDidChangeFile.event;
    this._bufferedChanges = [];
  }
  get capabilities() {
    return this._capabilities;
  }
  setReadOnly(readonly) {
    const isReadonly = !!(this._capabilities & 2048);
    if (readonly !== isReadonly) {
      this._capabilities = readonly ? 2048 | 1024 | 2 : 2 | 1024;
      this._onDidChangeCapabilities.fire();
    }
  }
  async stat(resource) {
    return this._lookup(resource, false);
  }
  async readdir(resource) {
    const entry = this._lookupAsDirectory(resource, false);
    const result = [];
    entry.entries.forEach((child, name) => result.push([name, child.type]));
    return result;
  }
  async readFile(resource) {
    const data = this._lookupAsFile(resource, false).data;
    if (data) {
      return data;
    }
    throw createFileSystemProviderError("file not found", FileSystemProviderErrorCode.FileNotFound);
  }
  async writeFile(resource, content, opts) {
    const basename3 = basename2(resource);
    const parent = this._lookupParentDirectory(resource);
    let entry = parent.entries.get(basename3);
    if (entry instanceof Directory) {
      throw createFileSystemProviderError("file is directory", FileSystemProviderErrorCode.FileIsADirectory);
    }
    if (!entry && !opts.create) {
      throw createFileSystemProviderError("file not found", FileSystemProviderErrorCode.FileNotFound);
    }
    if (entry && opts.create && !opts.overwrite) {
      throw createFileSystemProviderError("file exists already", FileSystemProviderErrorCode.FileExists);
    }
    if (!entry) {
      entry = new File(basename3);
      parent.entries.set(basename3, entry);
      this._fireSoon({ type: 1, resource });
    }
    entry.mtime = Date.now();
    entry.size = content.byteLength;
    entry.data = content;
    this._fireSoon({ type: 0, resource });
  }
  async rename(from, to, opts) {
    if (!opts.overwrite && this._lookup(to, true)) {
      throw createFileSystemProviderError("file exists already", FileSystemProviderErrorCode.FileExists);
    }
    const entry = this._lookup(from, false);
    const oldParent = this._lookupParentDirectory(from);
    const newParent = this._lookupParentDirectory(to);
    const newName = basename2(to);
    oldParent.entries.delete(entry.name);
    entry.name = newName;
    newParent.entries.set(newName, entry);
    this._fireSoon({ type: 2, resource: from }, { type: 1, resource: to });
  }
  async delete(resource, opts) {
    const dirname2 = dirname(resource);
    const basename3 = basename2(resource);
    const parent = this._lookupAsDirectory(dirname2, false);
    if (parent.entries.has(basename3)) {
      parent.entries.delete(basename3);
      parent.mtime = Date.now();
      parent.size -= 1;
      this._fireSoon({ type: 0, resource: dirname2 }, { resource, type: 2 });
    }
  }
  async mkdir(resource) {
    if (this._lookup(resource, true)) {
      throw createFileSystemProviderError("file exists already", FileSystemProviderErrorCode.FileExists);
    }
    const basename3 = basename2(resource);
    const dirname2 = dirname(resource);
    const parent = this._lookupAsDirectory(dirname2, false);
    const entry = new Directory(basename3);
    parent.entries.set(entry.name, entry);
    parent.mtime = Date.now();
    parent.size += 1;
    this._fireSoon({ type: 0, resource: dirname2 }, { type: 1, resource });
  }
  _lookup(uri, silent) {
    const parts = uri.path.split("/");
    let entry = this.root;
    for (const part of parts) {
      if (!part) {
        continue;
      }
      let child;
      if (entry instanceof Directory) {
        child = entry.entries.get(part);
      }
      if (!child) {
        if (!silent) {
          throw createFileSystemProviderError("file not found", FileSystemProviderErrorCode.FileNotFound);
        } else {
          return void 0;
        }
      }
      entry = child;
    }
    return entry;
  }
  _lookupAsDirectory(uri, silent) {
    const entry = this._lookup(uri, silent);
    if (entry instanceof Directory) {
      return entry;
    }
    throw createFileSystemProviderError("file not a directory", FileSystemProviderErrorCode.FileNotADirectory);
  }
  _lookupAsFile(uri, silent) {
    const entry = this._lookup(uri, silent);
    if (entry instanceof File) {
      return entry;
    }
    throw createFileSystemProviderError("file is a directory", FileSystemProviderErrorCode.FileIsADirectory);
  }
  _lookupParentDirectory(uri) {
    const dirname2 = dirname(uri);
    return this._lookupAsDirectory(dirname2, false);
  }
  watch(resource, opts) {
    return Disposable.None;
  }
  _fireSoon(...changes) {
    this._bufferedChanges.push(...changes);
    if (this._fireSoonHandle) {
      clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() => {
      this._onDidChangeFile.fire(this._bufferedChanges);
      this._bufferedChanges.length = 0;
    }, 5);
  }
};

// node_modules/vscode/service-override/files.js
init_uri();

// node_modules/vscode/vscode/src/vs/platform/files/common/files.js
init_types();
init_nls();
var FileType2;
(function(FileType3) {
  FileType3[FileType3["Unknown"] = 0] = "Unknown";
  FileType3[FileType3["File"] = 1] = "File";
  FileType3[FileType3["Directory"] = 2] = "Directory";
  FileType3[FileType3["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType2 || (FileType2 = {}));
var FilePermission2;
(function(FilePermission3) {
  FilePermission3[FilePermission3["Readonly"] = 1] = "Readonly";
  FilePermission3[FilePermission3["Locked"] = 2] = "Locked";
})(FilePermission2 || (FilePermission2 = {}));
var FileSystemProviderCapabilities;
(function(FileSystemProviderCapabilities2) {
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["None"] = 0] = "None";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileReadWrite"] = 2] = "FileReadWrite";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileOpenReadWriteClose"] = 4] = "FileOpenReadWriteClose";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileReadStream"] = 16] = "FileReadStream";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileFolderCopy"] = 8] = "FileFolderCopy";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["PathCaseSensitive"] = 1024] = "PathCaseSensitive";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["Readonly"] = 2048] = "Readonly";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["Trash"] = 4096] = "Trash";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileWriteUnlock"] = 8192] = "FileWriteUnlock";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileAtomicRead"] = 16384] = "FileAtomicRead";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileAtomicWrite"] = 32768] = "FileAtomicWrite";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileAtomicDelete"] = 65536] = "FileAtomicDelete";
  FileSystemProviderCapabilities2[FileSystemProviderCapabilities2["FileClone"] = 131072] = "FileClone";
})(FileSystemProviderCapabilities || (FileSystemProviderCapabilities = {}));
var FileChangeType;
(function(FileChangeType2) {
  FileChangeType2[FileChangeType2["UPDATED"] = 0] = "UPDATED";
  FileChangeType2[FileChangeType2["ADDED"] = 1] = "ADDED";
  FileChangeType2[FileChangeType2["DELETED"] = 2] = "DELETED";
})(FileChangeType || (FileChangeType = {}));
var _ByteSize = class _ByteSize {
  static formatSize(size) {
    if (!isNumber(size)) {
      size = 0;
    }
    if (size < _ByteSize.KB) {
      return localize("sizeB", "{0}B", size.toFixed(0));
    }
    if (size < _ByteSize.MB) {
      return localize("sizeKB", "{0}KB", (size / _ByteSize.KB).toFixed(2));
    }
    if (size < _ByteSize.GB) {
      return localize("sizeMB", "{0}MB", (size / _ByteSize.MB).toFixed(2));
    }
    if (size < _ByteSize.TB) {
      return localize("sizeGB", "{0}GB", (size / _ByteSize.GB).toFixed(2));
    }
    return localize("sizeTB", "{0}TB", (size / _ByteSize.TB).toFixed(2));
  }
};
_ByteSize.KB = 1024;
_ByteSize.MB = _ByteSize.KB * _ByteSize.KB;
_ByteSize.GB = _ByteSize.MB * _ByteSize.KB;
_ByteSize.TB = _ByteSize.GB * _ByteSize.KB;
var ByteSize2 = _ByteSize;

// node_modules/vscode/service-override/files.js
init_files();
init_files();
init_lifecycle();
init_resources();
init_event();
init_path();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/files.contribution.js
init_nls();
init_platform2();
init_configurationRegistry();
init_files();
init_platform();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/explorerViewlet.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/media/explorerviewlet.css.js
var css = ".explorer-folders-view{height:100%}.explorer-item-hover{cursor:pointer!important;font-size:13px!important;height:22px;padding-left:6px;user-select:none!important}.explorer-folders-view .monaco-list-row{padding-left:4px}.explorer-folders-view .explorer-folders-view.highlight .monaco-list .explorer-item:not(.explorer-item-edited),.explorer-folders-view .explorer-folders-view.highlight .monaco-list .monaco-tl-twistie{opacity:.3}.explorer-folders-view .editor-group,.explorer-folders-view .explorer-item{height:22px;line-height:22px}.explorer-folders-view .explorer-item{display:flex;flex-wrap:nowrap}.explorer-folders-view .editor-group,.explorer-folders-view .explorer-item>a{overflow:hidden;text-overflow:ellipsis}.explorer-folders-view .explorer-item,.explorer-folders-view .explorer-item .monaco-inputbox{flex:1}.explorer-folders-view .explorer-item.cut{opacity:.5}.explorer-folders-view .explorer-item.explorer-item-edited .label-name{flex:0}.explorer-folders-view .explorer-item.nonexistent-root{opacity:.5}.explorer-folders-view .explorer-item .monaco-inputbox{line-height:normal;width:100%}.explorer-folders-view .explorer-item .monaco-icon-name-container.multiple>.label-name>.monaco-highlighted-label{border-radius:3px}.explorer-folders-view .explorer-item .monaco-icon-name-container.multiple>.label-name:hover>.monaco-highlighted-label,.explorer-folders-view .monaco-list .monaco-list-row.focused .explorer-item .monaco-icon-name-container.multiple>.label-name.active>.monaco-highlighted-label{text-decoration:underline}.explorer-folders-view .explorer-item .monaco-icon-name-container.multiple>.label-name.drop-target>.monaco-highlighted-label{background-color:var(--vscode-list-dropBackground)}.explorer-folders-view .explorer-item.align-nest-icon-with-parent-icon{margin-left:var(--vscode-explorer-align-offset-margin-left)}.monaco-workbench.linux .explorer-folders-view .explorer-item .monaco-inputbox,.monaco-workbench.mac .explorer-folders-view .explorer-item .monaco-inputbox{height:22px}.monaco-workbench .explorer-folders-view .explorer-item .monaco-inputbox>.ibwrapper>.input{height:20px;padding:0}.monaco-workbench.hc-black .explorer-folders-view .explorer-item,.monaco-workbench.hc-light .explorer-folders-view .explorer-item{line-height:20px}.monaco-workbench .explorer-folders-view .explorer-item .monaco-inputbox input[type=text]{opacity:1;outline-color:var(--vscode-focusBorder);outline-offset:-1px;outline-style:solid;outline-width:1px}.monaco-workbench.context-menu-visible .explorer-folders-view.highlight .monaco-list-row{outline:none!important}";
n(css, {});

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/explorerViewlet.js
init_nls();
init_configuration();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerView.js
init_tslib_es6();
init_nls();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/fileActions.js
init_tslib_es6();
init_nls();
init_platform();
init_path();
init_resources();
init_uri();
init_errorMessage();
init_actions();
init_lifecycle();
init_files();
init_instantiation();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/fileConstants.js
init_nls();
init_contextkey();
var REVEAL_IN_EXPLORER_COMMAND_ID = "revealInExplorer";
var SAVE_FILE_AS_LABEL = localize("saveAs", "Save As...");
var SAVE_FILE_LABEL = localize("save", "Save");
var SAVE_FILE_WITHOUT_FORMATTING_LABEL = localize("saveWithoutFormatting", "Save without Formatting");
var SAVE_ALL_IN_GROUP_COMMAND_ID = "workbench.files.action.saveAllInGroup";
var OpenEditorsGroupContext = new RawContextKey("groupFocusedInOpenEditors", false);
var OpenEditorsDirtyEditorContext = new RawContextKey("dirtyEditorFocusedInOpenEditors", false);
var OpenEditorsReadonlyEditorContext = new RawContextKey("readonlyEditorFocusedInOpenEditors", false);
var ResourceSelectedForCompareContext = new RawContextKey("resourceSelectedForCompare", false);
var REMOVE_ROOT_FOLDER_LABEL = localize("removeFolderFromWorkspace", "Remove Folder from Workspace");
var NEW_UNTITLED_FILE_COMMAND_ID = "workbench.action.files.newUntitledFile";
var NEW_UNTITLED_FILE_LABEL = localize("newUntitledFile", "New Untitled Text File");

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/fileActions.js
init_resolverService();
init_configuration();
init_language();
init_model2();
init_commands();
init_contextkey();
init_network();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorCommands.js
init_nls();
init_types();
init_instantiation();
init_keybindingsRegistry();

// node_modules/vscode/vscode/src/vs/workbench/services/editor/common/editorGroupColumn.js
function columnToEditorGroup(editorGroupService, configurationService, column = ACTIVE_GROUP) {
  if (column === ACTIVE_GROUP || column === SIDE_GROUP) {
    return column;
  }
  let groupInColumn = editorGroupService.getGroups(2)[column];
  if (!groupInColumn && column < 9) {
    for (let i = 0; i <= column; i++) {
      const editorGroups = editorGroupService.getGroups(2);
      if (!editorGroups[i]) {
        editorGroupService.addGroup(editorGroups[i - 1], preferredSideBySideGroupDirection(configurationService));
      }
    }
    groupInColumn = editorGroupService.getGroups(2)[column];
  }
  return (groupInColumn == null ? void 0 : groupInColumn.id) ?? SIDE_GROUP;
}
function editorGroupToColumn(editorGroupService, editorGroup) {
  const group = typeof editorGroup === "number" ? editorGroupService.getGroup(editorGroup) : editorGroup;
  return editorGroupService.getGroups(2).indexOf(group ?? editorGroupService.activeGroup);
}

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorCommands.js
init_editorContextKeys();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/textDiffEditor.js
init_tslib_es6();
init_nls();
init_objects();
init_types();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/textEditor.js
init_tslib_es6();
init_nls();
init_objects();
init_event();
init_types();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorWithViewState.js
init_tslib_es6();
init_event();
init_instantiation();
init_telemetry();
init_themeService();
init_lifecycle();
var AbstractEditorWithViewState = class AbstractEditorWithViewState2 extends EditorPane {
  constructor(id, viewStateStorageKey, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorService, editorGroupService) {
    super(id, telemetryService, themeService, storageService);
    this.instantiationService = instantiationService;
    this.textResourceConfigurationService = textResourceConfigurationService;
    this.editorService = editorService;
    this.editorGroupService = editorGroupService;
    this.groupListener = this._register(new MutableDisposable());
    this.viewState = this.getEditorMemento(editorGroupService, textResourceConfigurationService, viewStateStorageKey, 100);
  }
  setEditorVisible(visible, group) {
    this.groupListener.value = group == null ? void 0 : group.onWillCloseEditor((e) => this.onWillCloseEditor(e));
    super.setEditorVisible(visible, group);
  }
  onWillCloseEditor(e) {
    const editor = e.editor;
    if (editor === this.input) {
      this.updateEditorViewState(editor);
    }
  }
  clearInput() {
    this.updateEditorViewState(this.input);
    super.clearInput();
  }
  saveState() {
    this.updateEditorViewState(this.input);
    super.saveState();
  }
  updateEditorViewState(input) {
    if (!input || !this.tracksEditorViewState(input)) {
      return;
    }
    const resource = this.toEditorViewStateResource(input);
    if (!resource) {
      return;
    }
    if (!this.tracksDisposedEditorViewState()) {
      if (!this.editorViewStateDisposables) {
        this.editorViewStateDisposables = /* @__PURE__ */ new Map();
      }
      if (!this.editorViewStateDisposables.has(input)) {
        this.editorViewStateDisposables.set(input, Event.once(input.onWillDispose)(() => {
          var _a43;
          this.clearEditorViewState(resource, this.group);
          (_a43 = this.editorViewStateDisposables) == null ? void 0 : _a43.delete(input);
        }));
      }
    }
    if (input.isDisposed() && !this.tracksDisposedEditorViewState() || !this.shouldRestoreEditorViewState(input) && (!this.group || !this.group.contains(input))) {
      this.clearEditorViewState(resource, this.group);
    } else if (!input.isDisposed()) {
      this.saveEditorViewState(resource);
    }
  }
  shouldRestoreEditorViewState(input, context) {
    if (context == null ? void 0 : context.newInGroup) {
      return this.textResourceConfigurationService.getValue(EditorResourceAccessor.getOriginalUri(input, { supportSideBySide: SideBySideEditor.PRIMARY }), "workbench.editor.restoreViewState") === false ? false : true;
    }
    return true;
  }
  getViewState() {
    const input = this.input;
    if (!input || !this.tracksEditorViewState(input)) {
      return;
    }
    const resource = this.toEditorViewStateResource(input);
    if (!resource) {
      return;
    }
    return this.computeEditorViewState(resource);
  }
  saveEditorViewState(resource) {
    if (!this.group) {
      return;
    }
    const editorViewState = this.computeEditorViewState(resource);
    if (!editorViewState) {
      return;
    }
    this.viewState.saveEditorState(this.group, resource, editorViewState);
  }
  loadEditorViewState(input, context) {
    if (!input || !this.group) {
      return void 0;
    }
    if (!this.tracksEditorViewState(input)) {
      return void 0;
    }
    if (!this.shouldRestoreEditorViewState(input, context)) {
      return void 0;
    }
    const resource = this.toEditorViewStateResource(input);
    if (!resource) {
      return;
    }
    return this.viewState.loadEditorState(this.group, resource);
  }
  moveEditorViewState(source, target, comparer) {
    return this.viewState.moveEditorState(source, target, comparer);
  }
  clearEditorViewState(resource, group) {
    this.viewState.clearEditorState(resource, group);
  }
  dispose() {
    super.dispose();
    if (this.editorViewStateDisposables) {
      for (const [, disposables] of this.editorViewStateDisposables) {
        disposables.dispose();
      }
      this.editorViewStateDisposables = void 0;
    }
  }
  tracksDisposedEditorViewState() {
    return false;
  }
};
AbstractEditorWithViewState = __decorate([
  __param(2, ITelemetryService),
  __param(3, IInstantiationService),
  __param(4, IStorageService),
  __param(5, ITextResourceConfigurationService),
  __param(6, IThemeService),
  __param(7, IEditorService),
  __param(8, IEditorGroupsService)
], AbstractEditorWithViewState);

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/textEditor.js
init_instantiation();
init_telemetry();
init_themeService();
init_files();
var AbstractTextEditor_1;
var _a24;
var AbstractTextEditor = (_a24 = class extends AbstractEditorWithViewState {
  constructor(id, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorService, editorGroupService, fileService) {
    super(id, AbstractTextEditor_1.VIEW_STATE_PREFERENCE_KEY, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorService, editorGroupService);
    this.fileService = fileService;
    this._onDidChangeSelection = this._register(new Emitter());
    this.onDidChangeSelection = this._onDidChangeSelection.event;
    this.inputListener = this._register(new MutableDisposable());
    this._register(this.textResourceConfigurationService.onDidChangeConfiguration((e) => this.handleConfigurationChangeEvent(e)));
    this._register(Event.any(this.editorGroupService.onDidAddGroup, this.editorGroupService.onDidRemoveGroup)(() => {
      var _a43;
      const ariaLabel = this.computeAriaLabel();
      (_a43 = this.editorContainer) == null ? void 0 : _a43.setAttribute("aria-label", ariaLabel);
      this.updateEditorControlOptions({ ariaLabel });
    }));
    this._register(this.fileService.onDidChangeFileSystemProviderCapabilities((e) => this.onDidChangeFileSystemProvider(e.scheme)));
    this._register(this.fileService.onDidChangeFileSystemProviderRegistrations((e) => this.onDidChangeFileSystemProvider(e.scheme)));
  }
  handleConfigurationChangeEvent(e) {
    const resource = this.getActiveResource();
    if (!this.shouldHandleConfigurationChangeEvent(e, resource)) {
      return;
    }
    if (this.isVisible()) {
      this.updateEditorConfiguration(resource);
    } else {
      this.hasPendingConfigurationChange = true;
    }
  }
  shouldHandleConfigurationChangeEvent(e, resource) {
    return e.affectsConfiguration(resource, "editor");
  }
  consumePendingConfigurationChangeEvent() {
    if (this.hasPendingConfigurationChange) {
      this.updateEditorConfiguration();
      this.hasPendingConfigurationChange = false;
    }
  }
  computeConfiguration(configuration) {
    const editorConfiguration = isObject(configuration.editor) ? deepClone(configuration.editor) : /* @__PURE__ */ Object.create(null);
    Object.assign(editorConfiguration, this.getConfigurationOverrides());
    editorConfiguration.ariaLabel = this.computeAriaLabel();
    return editorConfiguration;
  }
  computeAriaLabel() {
    return this._input ? computeEditorAriaLabel(this._input, void 0, this.group, this.editorGroupService.count) : localize("editor", "Editor");
  }
  onDidChangeFileSystemProvider(scheme) {
    var _a43;
    if (!this.input) {
      return;
    }
    if (((_a43 = this.getActiveResource()) == null ? void 0 : _a43.scheme) === scheme) {
      this.updateReadonly(this.input);
    }
  }
  onDidChangeInputCapabilities(input) {
    if (this.input === input) {
      this.updateReadonly(input);
    }
  }
  updateReadonly(input) {
    this.updateEditorControlOptions({ ...this.getReadonlyConfiguration(input.isReadonly()) });
  }
  getReadonlyConfiguration(isReadonly) {
    return {
      readOnly: !!isReadonly,
      readOnlyMessage: typeof isReadonly !== "boolean" ? isReadonly : void 0
    };
  }
  getConfigurationOverrides() {
    var _a43;
    return {
      overviewRulerLanes: 3,
      lineNumbersMinChars: 3,
      fixedOverflowWidgets: true,
      ...this.getReadonlyConfiguration((_a43 = this.input) == null ? void 0 : _a43.isReadonly()),
      renderValidationDecorations: "on"
    };
  }
  createEditor(parent) {
    this.editorContainer = parent;
    this.createEditorControl(parent, this.computeConfiguration(this.textResourceConfigurationService.getValue(this.getActiveResource())));
    this.registerCodeEditorListeners();
  }
  registerCodeEditorListeners() {
    const mainControl = this.getMainControl();
    if (mainControl) {
      this._register(mainControl.onDidChangeModelLanguage(() => this.updateEditorConfiguration()));
      this._register(mainControl.onDidChangeModel(() => this.updateEditorConfiguration()));
      this._register(mainControl.onDidChangeCursorPosition((e) => this._onDidChangeSelection.fire({ reason: this.toEditorPaneSelectionChangeReason(e) })));
      this._register(mainControl.onDidChangeModelContent(() => this._onDidChangeSelection.fire({ reason: 3 })));
    }
  }
  toEditorPaneSelectionChangeReason(e) {
    switch (e.source) {
      case "api":
        return 1;
      case "code.navigation":
        return 4;
      case "code.jump":
        return 5;
      default:
        return 2;
    }
  }
  getSelection() {
    const mainControl = this.getMainControl();
    if (mainControl) {
      const selection = mainControl.getSelection();
      if (selection) {
        return new TextEditorPaneSelection(selection);
      }
    }
    return void 0;
  }
  async setInput(input, options, context, token) {
    await super.setInput(input, options, context, token);
    this.inputListener.value = input.onDidChangeCapabilities(() => this.onDidChangeInputCapabilities(input));
    this.updateEditorConfiguration();
    const editorContainer = assertIsDefined(this.editorContainer);
    editorContainer.setAttribute("aria-label", this.computeAriaLabel());
  }
  clearInput() {
    this.inputListener.clear();
    super.clearInput();
  }
  setEditorVisible(visible, group) {
    if (visible) {
      this.consumePendingConfigurationChangeEvent();
    }
    super.setEditorVisible(visible, group);
  }
  toEditorViewStateResource(input) {
    return input.resource;
  }
  updateEditorConfiguration(resource = this.getActiveResource()) {
    let configuration = void 0;
    if (resource) {
      configuration = this.textResourceConfigurationService.getValue(resource);
    }
    if (!configuration) {
      return;
    }
    const editorConfiguration = this.computeConfiguration(configuration);
    let editorSettingsToApply = editorConfiguration;
    if (this.lastAppliedEditorOptions) {
      editorSettingsToApply = distinct2(this.lastAppliedEditorOptions, editorSettingsToApply);
    }
    if (Object.keys(editorSettingsToApply).length > 0) {
      this.lastAppliedEditorOptions = editorConfiguration;
      this.updateEditorControlOptions(editorSettingsToApply);
    }
  }
  getActiveResource() {
    const mainControl = this.getMainControl();
    if (mainControl) {
      const model = mainControl.getModel();
      if (model) {
        return model.uri;
      }
    }
    if (this.input) {
      return this.input.resource;
    }
    return void 0;
  }
  dispose() {
    this.lastAppliedEditorOptions = void 0;
    super.dispose();
  }
}, AbstractTextEditor_1 = _a24, _a24.VIEW_STATE_PREFERENCE_KEY = "textEditorViewState", _a24);
AbstractTextEditor = AbstractTextEditor_1 = __decorate([
  __param(1, ITelemetryService),
  __param(2, IInstantiationService),
  __param(3, IStorageService),
  __param(4, ITextResourceConfigurationService),
  __param(5, IThemeService),
  __param(6, IEditorService),
  __param(7, IEditorGroupsService),
  __param(8, IFileService)
], AbstractTextEditor);
var _TextEditorPaneSelection = class _TextEditorPaneSelection {
  constructor(textSelection) {
    this.textSelection = textSelection;
  }
  compare(other) {
    if (!(other instanceof _TextEditorPaneSelection)) {
      return 3;
    }
    const thisLineNumber = Math.min(this.textSelection.selectionStartLineNumber, this.textSelection.positionLineNumber);
    const otherLineNumber = Math.min(other.textSelection.selectionStartLineNumber, other.textSelection.positionLineNumber);
    if (thisLineNumber === otherLineNumber) {
      return 1;
    }
    if (Math.abs(thisLineNumber - otherLineNumber) < _TextEditorPaneSelection.TEXT_EDITOR_SELECTION_THRESHOLD) {
      return 2;
    }
    return 3;
  }
  restore(options) {
    const textEditorOptions = {
      ...options,
      selection: this.textSelection,
      selectionRevealType: 1
    };
    return textEditorOptions;
  }
  log() {
    return `line: ${this.textSelection.startLineNumber}-${this.textSelection.endLineNumber}, col:  ${this.textSelection.startColumn}-${this.textSelection.endColumn}`;
  }
};
_TextEditorPaneSelection.TEXT_EDITOR_SELECTION_THRESHOLD = 10;
var TextEditorPaneSelection = _TextEditorPaneSelection;

// node_modules/vscode/override/vs/workbench/browser/parts/editor/textEditor.weak.js
var AbstractTextEditor2 = class {
};
var FakeAbstractTextEditor = class {
  static [Symbol.hasInstance](instance) {
    return AbstractTextEditor2 != null && instance instanceof AbstractTextEditor2;
  }
};
function setAbstractTextEditor(_AbstractTextEditor) {
  AbstractTextEditor2 = _AbstractTextEditor;
}

// node_modules/vscode/override/vs/workbench/browser/parts/editor/textEditor.js
setAbstractTextEditor(AbstractTextEditor);

// node_modules/vscode/vscode/src/vs/workbench/common/editor/editorOptions.js
function applyTextEditorOptions(options, editor, scrollType) {
  let applied = false;
  const viewState = massageEditorViewState(options);
  if (isTextEditorViewState(viewState)) {
    editor.restoreViewState(viewState);
    applied = true;
  }
  if (options.selection) {
    const range = {
      startLineNumber: options.selection.startLineNumber,
      startColumn: options.selection.startColumn,
      endLineNumber: options.selection.endLineNumber ?? options.selection.startLineNumber,
      endColumn: options.selection.endColumn ?? options.selection.startColumn
    };
    editor.setSelection(range, options.selectionSource ?? "code.navigation");
    if (options.selectionRevealType === 2) {
      editor.revealRangeNearTop(range, scrollType);
    } else if (options.selectionRevealType === 3) {
      editor.revealRangeNearTopIfOutsideViewport(range, scrollType);
    } else if (options.selectionRevealType === 1) {
      editor.revealRangeInCenterIfOutsideViewport(range, scrollType);
    } else {
      editor.revealRangeInCenter(range, scrollType);
    }
    applied = true;
  }
  return applied;
}
function massageEditorViewState(options) {
  if (!options.selection || !options.viewState) {
    return options.viewState;
  }
  const candidateDiffViewState = options.viewState;
  if (candidateDiffViewState.modified) {
    candidateDiffViewState.modified.cursorState = [];
    return candidateDiffViewState;
  }
  const candidateEditorViewState = options.viewState;
  if (candidateEditorViewState.cursorState) {
    candidateEditorViewState.cursorState = [];
  }
  return candidateEditorViewState;
}

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/textDiffEditor.js
init_telemetry();
init_instantiation();
init_themeService();
init_lifecycle();
init_platform2();
init_uri();
init_contextkey();
init_resources();
init_dom();
init_files();
init_stopwatch();
var TextDiffEditor_1;
var _a25;
var TextDiffEditor = (_a25 = class extends AbstractTextEditor {
  get scopedContextKeyService() {
    if (!this.diffEditorControl) {
      return void 0;
    }
    const originalEditor = this.diffEditorControl.getOriginalEditor();
    const modifiedEditor = this.diffEditorControl.getModifiedEditor();
    return (originalEditor.hasTextFocus() ? originalEditor : modifiedEditor).invokeWithinContext((accessor) => accessor.get(IContextKeyService));
  }
  constructor(telemetryService, instantiationService, storageService, configurationService, editorService, themeService, editorGroupService, fileService, preferencesService) {
    super(TextDiffEditor_1.ID, telemetryService, instantiationService, storageService, configurationService, themeService, editorService, editorGroupService, fileService);
    this.preferencesService = preferencesService;
    this.diffEditorControl = void 0;
    this.diffNavigatorDisposables = this._register(new DisposableStore());
    this.inputLifecycleStopWatch = void 0;
  }
  getTitle() {
    if (this.input) {
      return this.input.getName();
    }
    return localize("textDiffEditor", "Text Diff Editor");
  }
  createEditorControl(parent, configuration) {
    TextDiffEditor_1.widgetCounter++;
    let useVersion2 = this.textResourceConfigurationService.getValue(void 0, "diffEditor.experimental.useVersion2");
    if (useVersion2 === "first") {
      useVersion2 = TextDiffEditor_1.widgetCounter === 1;
    }
    if (useVersion2) {
      this.diffEditorControl = this._register(this.instantiationService.createInstance(DiffEditorWidget2, parent, configuration, {}));
    } else {
      this.diffEditorControl = this._register(this.instantiationService.createInstance(DiffEditorWidget, parent, configuration, {}));
    }
  }
  updateEditorControlOptions(options) {
    var _a43;
    (_a43 = this.diffEditorControl) == null ? void 0 : _a43.updateOptions(options);
  }
  getMainControl() {
    var _a43;
    return (_a43 = this.diffEditorControl) == null ? void 0 : _a43.getModifiedEditor();
  }
  async setInput(input, options, context, token) {
    var _a43, _b;
    this.inputLifecycleStopWatch = void 0;
    this.diffNavigatorDisposables.clear();
    await super.setInput(input, options, context, token);
    try {
      const resolvedModel = await input.resolve(options);
      if (token.isCancellationRequested) {
        return void 0;
      }
      if (!(resolvedModel instanceof TextDiffEditorModel)) {
        this.openAsBinary(input, options);
        return void 0;
      }
      const control = assertIsDefined(this.diffEditorControl);
      const resolvedDiffEditorModel = resolvedModel;
      const vm = resolvedDiffEditorModel.textDiffEditorModel ? control.createViewModel(resolvedDiffEditorModel.textDiffEditorModel) : null;
      await (vm == null ? void 0 : vm.waitForDiff());
      control.setModel(vm);
      let hasPreviousViewState = false;
      if (!isTextEditorViewState(options == null ? void 0 : options.viewState)) {
        hasPreviousViewState = this.restoreTextDiffEditorViewState(input, options, context, control);
      }
      let optionsGotApplied = false;
      if (options) {
        optionsGotApplied = applyTextEditorOptions(options, control, 1);
      }
      if (!optionsGotApplied && !hasPreviousViewState) {
        control.revealFirstDiff();
      }
      control.updateOptions({
        ...this.getReadonlyConfiguration((_a43 = resolvedDiffEditorModel.modifiedModel) == null ? void 0 : _a43.isReadonly()),
        originalEditable: !((_b = resolvedDiffEditorModel.originalModel) == null ? void 0 : _b.isReadonly())
      });
      this.inputLifecycleStopWatch = new StopWatch(false);
    } catch (error) {
      await this.handleSetInputError(error, input, options);
    }
  }
  async handleSetInputError(error, input, options) {
    if (this.isFileBinaryError(error)) {
      return this.openAsBinary(input, options);
    }
    if (error.fileOperationResult === 7 && this.group) {
      let message;
      if (error instanceof TooLargeFileOperationError) {
        message = localize(
          "fileTooLargeForHeapErrorWithSize",
          "At least one file is not displayed in the text compare editor because it is very large ({0}).",
          ByteSize.formatSize(error.size)
        );
      } else {
        message = localize(
          "fileTooLargeForHeapErrorWithoutSize",
          "At least one file is not displayed in the text compare editor because it is very large."
        );
      }
      throw createTooLargeFileError(this.group, input, options, message, this.preferencesService);
    }
    throw error;
  }
  restoreTextDiffEditorViewState(editor, options, context, control) {
    const editorViewState = this.loadEditorViewState(editor, context);
    if (editorViewState) {
      if ((options == null ? void 0 : options.selection) && editorViewState.modified) {
        editorViewState.modified.cursorState = [];
      }
      control.restoreViewState(editorViewState);
      return true;
    }
    return false;
  }
  openAsBinary(input, options) {
    var _a43, _b;
    const original = input.original;
    const modified = input.modified;
    const binaryDiffInput = this.instantiationService.createInstance(DiffEditorInput, input.getName(), input.getDescription(), original, modified, true);
    const fileEditorFactory = Registry.as(EditorExtensions.EditorFactory).getFileEditorFactory();
    if (fileEditorFactory.isFileEditor(original)) {
      original.setForceOpenAsBinary();
    }
    if (fileEditorFactory.isFileEditor(modified)) {
      modified.setForceOpenAsBinary();
    }
    (this.group ?? this.editorGroupService.activeGroup).replaceEditors([{
      editor: input,
      replacement: binaryDiffInput,
      options: {
        ...options,
        activation: EditorActivation.PRESERVE,
        pinned: (_a43 = this.group) == null ? void 0 : _a43.isPinned(input),
        sticky: (_b = this.group) == null ? void 0 : _b.isSticky(input)
      }
    }]);
  }
  setOptions(options) {
    super.setOptions(options);
    if (options) {
      applyTextEditorOptions(options, assertIsDefined(this.diffEditorControl), 0);
    }
  }
  shouldHandleConfigurationChangeEvent(e, resource) {
    if (super.shouldHandleConfigurationChangeEvent(e, resource)) {
      return true;
    }
    return e.affectsConfiguration(resource, "diffEditor") || e.affectsConfiguration(resource, "accessibility.verbosity.diffEditor");
  }
  computeConfiguration(configuration) {
    var _a43, _b;
    const editorConfiguration = super.computeConfiguration(configuration);
    if (isObject(configuration.diffEditor)) {
      const diffEditorConfiguration = deepClone(configuration.diffEditor);
      diffEditorConfiguration.diffCodeLens = diffEditorConfiguration.codeLens;
      delete diffEditorConfiguration.codeLens;
      diffEditorConfiguration.diffWordWrap = diffEditorConfiguration.wordWrap;
      delete diffEditorConfiguration.wordWrap;
      Object.assign(editorConfiguration, diffEditorConfiguration);
    }
    const verbose = ((_b = (_a43 = configuration.accessibility) == null ? void 0 : _a43.verbosity) == null ? void 0 : _b.diffEditor) ?? false;
    editorConfiguration.accessibilityVerbose = verbose;
    return editorConfiguration;
  }
  getConfigurationOverrides() {
    var _a43;
    return {
      ...super.getConfigurationOverrides(),
      ...this.getReadonlyConfiguration((_a43 = this.input) == null ? void 0 : _a43.isReadonly()),
      originalEditable: this.input instanceof DiffEditorInput && !this.input.original.isReadonly(),
      lineDecorationsWidth: "2ch"
    };
  }
  updateReadonly(input) {
    var _a43;
    if (input instanceof DiffEditorInput) {
      (_a43 = this.diffEditorControl) == null ? void 0 : _a43.updateOptions({
        ...this.getReadonlyConfiguration(input.isReadonly()),
        originalEditable: !input.original.isReadonly()
      });
    } else {
      super.updateReadonly(input);
    }
  }
  isFileBinaryError(error) {
    if (Array.isArray(error)) {
      const errors = error;
      return errors.some((error2) => this.isFileBinaryError(error2));
    }
    return error.textFileOperationResult === 0;
  }
  clearInput() {
    var _a43, _b, _c, _d, _e;
    super.clearInput();
    const inputLifecycleElapsed = (_a43 = this.inputLifecycleStopWatch) == null ? void 0 : _a43.elapsed();
    this.inputLifecycleStopWatch = void 0;
    if (typeof inputLifecycleElapsed === "number") {
      this.logInputLifecycleTelemetry(inputLifecycleElapsed, (_d = (_c = (_b = this.getControl()) == null ? void 0 : _b.getModel()) == null ? void 0 : _c.modified) == null ? void 0 : _d.getLanguageId());
    }
    this.diffNavigatorDisposables.clear();
    (_e = this.diffEditorControl) == null ? void 0 : _e.setModel(null);
  }
  logInputLifecycleTelemetry(duration, languageId) {
    let collapseUnchangedRegions = false;
    if (this.diffEditorControl instanceof DiffEditorWidget2) {
      collapseUnchangedRegions = this.diffEditorControl.collapseUnchangedRegions;
    }
    this.telemetryService.publicLog2("diffEditor.editorVisibleTime", {
      editorVisibleTimeMs: duration,
      languageId: languageId ?? "",
      collapseUnchangedRegions
    });
  }
  getControl() {
    return this.diffEditorControl;
  }
  focus() {
    var _a43;
    (_a43 = this.diffEditorControl) == null ? void 0 : _a43.focus();
  }
  hasFocus() {
    var _a43;
    return ((_a43 = this.diffEditorControl) == null ? void 0 : _a43.hasTextFocus()) || super.hasFocus();
  }
  setEditorVisible(visible, group) {
    var _a43, _b;
    super.setEditorVisible(visible, group);
    if (visible) {
      (_a43 = this.diffEditorControl) == null ? void 0 : _a43.onVisible();
    } else {
      (_b = this.diffEditorControl) == null ? void 0 : _b.onHide();
    }
  }
  layout(dimension) {
    var _a43;
    (_a43 = this.diffEditorControl) == null ? void 0 : _a43.layout(dimension);
  }
  setBoundarySashes(sashes) {
    var _a43;
    (_a43 = this.diffEditorControl) == null ? void 0 : _a43.setBoundarySashes(sashes);
  }
  tracksEditorViewState(input) {
    return input instanceof DiffEditorInput;
  }
  computeEditorViewState(resource) {
    if (!this.diffEditorControl) {
      return void 0;
    }
    const model = this.diffEditorControl.getModel();
    if (!model || !model.modified || !model.original) {
      return void 0;
    }
    const modelUri = this.toEditorViewStateResource(model);
    if (!modelUri) {
      return void 0;
    }
    if (!isEqual2(modelUri, resource)) {
      return void 0;
    }
    return this.diffEditorControl.saveViewState() ?? void 0;
  }
  toEditorViewStateResource(modelOrInput) {
    let original;
    let modified;
    if (modelOrInput instanceof DiffEditorInput) {
      original = modelOrInput.original.resource;
      modified = modelOrInput.modified.resource;
    } else if (!isEditorInput(modelOrInput)) {
      original = modelOrInput.original.uri;
      modified = modelOrInput.modified.uri;
    }
    if (!original || !modified) {
      return void 0;
    }
    return URI.from({ scheme: "diff", path: `${multibyteAwareBtoa(original.toString())}${multibyteAwareBtoa(modified.toString())}` });
  }
}, TextDiffEditor_1 = _a25, _a25.ID = TEXT_DIFF_EDITOR_ID, _a25.widgetCounter = 0, _a25);
TextDiffEditor = TextDiffEditor_1 = __decorate([
  __param(0, ITelemetryService),
  __param(1, IInstantiationService),
  __param(2, IStorageService),
  __param(3, ITextResourceConfigurationService),
  __param(4, IEditorService),
  __param(5, IThemeService),
  __param(6, IEditorGroupsService),
  __param(7, IFileService),
  __param(8, IPreferencesService)
], TextDiffEditor);

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorCommands.js
init_keyCodes();
init_uri();
init_arrays();
init_contextkey();
init_configuration();
init_commands();
init_actions2();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorQuickAccess.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/media/editorquickaccess.css.js
var css2 = '.quick-input-list .quick-input-list-entry.has-actions:hover .quick-input-list-entry-action-bar .action-label.dirty-editor:before{content:"\\ea76"}';
n(css2, {});

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorQuickAccess.js
init_nls();

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js
init_async();
init_cancellation();
init_lifecycle();
init_types();
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TriggerAction;
(function(TriggerAction2) {
  TriggerAction2[TriggerAction2["NO_ACTION"] = 0] = "NO_ACTION";
  TriggerAction2[TriggerAction2["CLOSE_PICKER"] = 1] = "CLOSE_PICKER";
  TriggerAction2[TriggerAction2["REFRESH_PICKER"] = 2] = "REFRESH_PICKER";
  TriggerAction2[TriggerAction2["REMOVE_ITEM"] = 3] = "REMOVE_ITEM";
})(TriggerAction || (TriggerAction = {}));
function isPicksWithActive(obj) {
  const candidate = obj;
  return Array.isArray(candidate.items);
}
function isFastAndSlowPicks(obj) {
  const candidate = obj;
  return !!candidate.picks && candidate.additionalPicks instanceof Promise;
}
var PickerQuickAccessProvider = class extends Disposable {
  constructor(prefix, options) {
    super();
    this.prefix = prefix;
    this.options = options;
  }
  provide(picker, token, runOptions) {
    var _a43;
    const disposables = new DisposableStore();
    picker.canAcceptInBackground = !!((_a43 = this.options) === null || _a43 === void 0 ? void 0 : _a43.canAcceptInBackground);
    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
    let picksCts = void 0;
    const picksDisposable = disposables.add(new MutableDisposable());
    const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {
      const picksDisposables = picksDisposable.value = new DisposableStore();
      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
      picker.busy = false;
      picksCts = new CancellationTokenSource(token);
      const picksToken = picksCts.token;
      const picksFilter = picker.value.substr(this.prefix.length).trim();
      const providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken, runOptions);
      const applyPicks = (picks, skipEmpty) => {
        var _a44;
        let items;
        let activeItem = void 0;
        if (isPicksWithActive(picks)) {
          items = picks.items;
          activeItem = picks.active;
        } else {
          items = picks;
        }
        if (items.length === 0) {
          if (skipEmpty) {
            return false;
          }
          if ((picksFilter.length > 0 || picker.hideInput) && ((_a44 = this.options) === null || _a44 === void 0 ? void 0 : _a44.noResultsPick)) {
            if (isFunction(this.options.noResultsPick)) {
              items = [this.options.noResultsPick(picksFilter)];
            } else {
              items = [this.options.noResultsPick];
            }
          }
        }
        picker.items = items;
        if (activeItem) {
          picker.activeItems = [activeItem];
        }
        return true;
      };
      const applyFastAndSlowPicks = (fastAndSlowPicks) => __awaiter(this, void 0, void 0, function* () {
        let fastPicksApplied = false;
        let slowPicksApplied = false;
        yield Promise.all([
          // Fast Picks: if `mergeDelay` is configured, in order to reduce
          // amount of flicker, we race against the slow picks over some delay
          // and then set the fast picks.
          // If the slow picks are faster, we reduce the flicker by only
          // setting the items once.
          (() => __awaiter(this, void 0, void 0, function* () {
            if (typeof fastAndSlowPicks.mergeDelay === "number") {
              yield timeout(fastAndSlowPicks.mergeDelay);
              if (picksToken.isCancellationRequested) {
                return;
              }
            }
            if (!slowPicksApplied) {
              fastPicksApplied = applyPicks(
                fastAndSlowPicks.picks,
                true
                /* skip over empty to reduce flicker */
              );
            }
          }))(),
          // Slow Picks: we await the slow picks and then set them at
          // once together with the fast picks, but only if we actually
          // have additional results.
          (() => __awaiter(this, void 0, void 0, function* () {
            picker.busy = true;
            try {
              const awaitedAdditionalPicks = yield fastAndSlowPicks.additionalPicks;
              if (picksToken.isCancellationRequested) {
                return;
              }
              let picks;
              let activePick = void 0;
              if (isPicksWithActive(fastAndSlowPicks.picks)) {
                picks = fastAndSlowPicks.picks.items;
                activePick = fastAndSlowPicks.picks.active;
              } else {
                picks = fastAndSlowPicks.picks;
              }
              let additionalPicks;
              let additionalActivePick = void 0;
              if (isPicksWithActive(awaitedAdditionalPicks)) {
                additionalPicks = awaitedAdditionalPicks.items;
                additionalActivePick = awaitedAdditionalPicks.active;
              } else {
                additionalPicks = awaitedAdditionalPicks;
              }
              if (additionalPicks.length > 0 || !fastPicksApplied) {
                let fallbackActivePick = void 0;
                if (!activePick && !additionalActivePick) {
                  const fallbackActivePickCandidate = picker.activeItems[0];
                  if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {
                    fallbackActivePick = fallbackActivePickCandidate;
                  }
                }
                applyPicks({
                  items: [...picks, ...additionalPicks],
                  active: activePick || additionalActivePick || fallbackActivePick
                });
              }
            } finally {
              if (!picksToken.isCancellationRequested) {
                picker.busy = false;
              }
              slowPicksApplied = true;
            }
          }))()
        ]);
      });
      if (providedPicks === null) {
      } else if (isFastAndSlowPicks(providedPicks)) {
        yield applyFastAndSlowPicks(providedPicks);
      } else if (!(providedPicks instanceof Promise)) {
        applyPicks(providedPicks);
      } else {
        picker.busy = true;
        try {
          const awaitedPicks = yield providedPicks;
          if (picksToken.isCancellationRequested) {
            return;
          }
          if (isFastAndSlowPicks(awaitedPicks)) {
            yield applyFastAndSlowPicks(awaitedPicks);
          } else {
            applyPicks(awaitedPicks);
          }
        } finally {
          if (!picksToken.isCancellationRequested) {
            picker.busy = false;
          }
        }
      }
    });
    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
    updatePickerItems();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (typeof (item === null || item === void 0 ? void 0 : item.accept) === "function") {
        if (!event.inBackground) {
          picker.hide();
        }
        item.accept(picker.keyMods, event);
      }
    }));
    disposables.add(picker.onDidTriggerItemButton(({ button, item }) => __awaiter(this, void 0, void 0, function* () {
      var _b, _c;
      if (typeof item.trigger === "function") {
        const buttonIndex = (_c = (_b = item.buttons) === null || _b === void 0 ? void 0 : _b.indexOf(button)) !== null && _c !== void 0 ? _c : -1;
        if (buttonIndex >= 0) {
          const result = item.trigger(buttonIndex, picker.keyMods);
          const action = typeof result === "number" ? result : yield result;
          if (token.isCancellationRequested) {
            return;
          }
          switch (action) {
            case TriggerAction.NO_ACTION:
              break;
            case TriggerAction.CLOSE_PICKER:
              picker.hide();
              break;
            case TriggerAction.REFRESH_PICKER:
              updatePickerItems();
              break;
            case TriggerAction.REMOVE_ITEM: {
              const index = picker.items.indexOf(item);
              if (index !== -1) {
                const items = picker.items.slice();
                const removed = items.splice(index, 1);
                const activeItems = picker.activeItems.filter((activeItem) => activeItem !== removed[0]);
                const keepScrollPositionBefore = picker.keepScrollPosition;
                picker.keepScrollPosition = true;
                picker.items = items;
                if (activeItems) {
                  picker.activeItems = activeItems;
                }
                picker.keepScrollPosition = keepScrollPositionBefore;
              }
              break;
            }
          }
        }
      }
    })));
    return disposables;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorQuickAccess.js
init_model2();
init_language();

// node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js
init_filters();
init_hash();
init_path();
init_platform();
init_strings();
var NO_MATCH = 0;
var NO_SCORE = [NO_MATCH, []];
function scoreFuzzy(target, query, queryLower, allowNonContiguousMatches) {
  if (!target || !query) {
    return NO_SCORE;
  }
  const targetLength = target.length;
  const queryLength = query.length;
  if (targetLength < queryLength) {
    return NO_SCORE;
  }
  const targetLower = target.toLowerCase();
  const res = doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches);
  return res;
}
function doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches) {
  const scores = [];
  const matches = [];
  for (let queryIndex2 = 0; queryIndex2 < queryLength; queryIndex2++) {
    const queryIndexOffset = queryIndex2 * targetLength;
    const queryIndexPreviousOffset = queryIndexOffset - targetLength;
    const queryIndexGtNull = queryIndex2 > 0;
    const queryCharAtIndex = query[queryIndex2];
    const queryLowerCharAtIndex = queryLower[queryIndex2];
    for (let targetIndex2 = 0; targetIndex2 < targetLength; targetIndex2++) {
      const targetIndexGtNull = targetIndex2 > 0;
      const currentIndex = queryIndexOffset + targetIndex2;
      const leftIndex = currentIndex - 1;
      const diagIndex = queryIndexPreviousOffset + targetIndex2 - 1;
      const leftScore = targetIndexGtNull ? scores[leftIndex] : 0;
      const diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;
      const matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;
      let score;
      if (!diagScore && queryIndexGtNull) {
        score = 0;
      } else {
        score = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex2, matchesSequenceLength);
      }
      const isValidScore = score && diagScore + score >= leftScore;
      if (isValidScore && // We don't need to check if it's contiguous if we allow non-contiguous matches
      (allowNonContiguousMatches || // We must be looking for a contiguous match.
      // Looking at an index higher than 0 in the query means we must have already
      // found out this is contiguous otherwise there wouldn't have been a score
      queryIndexGtNull || // lastly check if the query is completely contiguous at this index in the target
      targetLower.startsWith(queryLower, targetIndex2))) {
        matches[currentIndex] = matchesSequenceLength + 1;
        scores[currentIndex] = diagScore + score;
      } else {
        matches[currentIndex] = NO_MATCH;
        scores[currentIndex] = leftScore;
      }
    }
  }
  const positions = [];
  let queryIndex = queryLength - 1;
  let targetIndex = targetLength - 1;
  while (queryIndex >= 0 && targetIndex >= 0) {
    const currentIndex = queryIndex * targetLength + targetIndex;
    const match2 = matches[currentIndex];
    if (match2 === NO_MATCH) {
      targetIndex--;
    } else {
      positions.push(targetIndex);
      queryIndex--;
      targetIndex--;
    }
  }
  return [scores[queryLength * targetLength - 1], positions.reverse()];
}
function computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength) {
  let score = 0;
  if (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {
    return score;
  }
  score += 1;
  if (matchesSequenceLength > 0) {
    score += matchesSequenceLength * 5;
  }
  if (queryCharAtIndex === target[targetIndex]) {
    score += 1;
  }
  if (targetIndex === 0) {
    score += 8;
  } else {
    const separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));
    if (separatorBonus) {
      score += separatorBonus;
    } else if (isUpper(target.charCodeAt(targetIndex)) && matchesSequenceLength === 0) {
      score += 2;
    }
  }
  return score;
}
function considerAsEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (a === "/" || a === "\\") {
    return b === "/" || b === "\\";
  }
  return false;
}
function scoreSeparatorAtPos(charCode) {
  switch (charCode) {
    case 47:
    case 92:
      return 5;
    case 95:
    case 45:
    case 46:
    case 32:
    case 39:
    case 34:
    case 58:
      return 4;
    default:
      return 0;
  }
}
var NO_SCORE2 = [void 0, []];
function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {
  const preparedQuery = query;
  if (preparedQuery.values && preparedQuery.values.length > 1) {
    return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);
  }
  return doScoreFuzzy2Single(target, query, patternStart, wordStart);
}
function doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {
  let totalScore = 0;
  const totalMatches = [];
  for (const queryPiece of query) {
    const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);
    if (typeof score !== "number") {
      return NO_SCORE2;
    }
    totalScore += score;
    totalMatches.push(...matches);
  }
  return [totalScore, normalizeMatches(totalMatches)];
}
function doScoreFuzzy2Single(target, query, patternStart, wordStart) {
  const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, { firstMatchCanBeWeak: true, boostFullMatch: true });
  if (!score) {
    return NO_SCORE2;
  }
  return [score[0], createMatches(score)];
}
var NO_ITEM_SCORE = Object.freeze({ score: 0 });
var PATH_IDENTITY_SCORE = 1 << 18;
var LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;
var LABEL_SCORE_THRESHOLD = 1 << 16;
function getCacheHash(label, description, allowNonContiguousMatches, query) {
  const values = query.values ? query.values : [query];
  const cacheHash = hash({
    [query.normalized]: {
      values: values.map((v) => ({ value: v.normalized, expectContiguousMatch: v.expectContiguousMatch })),
      label,
      description,
      allowNonContiguousMatches
    }
  });
  return cacheHash;
}
function scoreItemFuzzy(item, query, allowNonContiguousMatches, accessor, cache) {
  if (!item || !query.normalized) {
    return NO_ITEM_SCORE;
  }
  const label = accessor.getItemLabel(item);
  if (!label) {
    return NO_ITEM_SCORE;
  }
  const description = accessor.getItemDescription(item);
  const cacheHash = getCacheHash(label, description, allowNonContiguousMatches, query);
  const cached = cache[cacheHash];
  if (cached) {
    return cached;
  }
  const itemScore = doScoreItemFuzzy(label, description, accessor.getItemPath(item), query, allowNonContiguousMatches);
  cache[cacheHash] = itemScore;
  return itemScore;
}
function doScoreItemFuzzy(label, description, path, query, allowNonContiguousMatches) {
  const preferLabelMatches = !path || !query.containsPathSeparator;
  if (path && (isLinux ? query.pathNormalized === path : equalsIgnoreCase(query.pathNormalized, path))) {
    return { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : void 0 };
  }
  if (query.values && query.values.length > 1) {
    return doScoreItemFuzzyMultiple(label, description, path, query.values, preferLabelMatches, allowNonContiguousMatches);
  }
  return doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches);
}
function doScoreItemFuzzyMultiple(label, description, path, query, preferLabelMatches, allowNonContiguousMatches) {
  let totalScore = 0;
  const totalLabelMatches = [];
  const totalDescriptionMatches = [];
  for (const queryPiece of query) {
    const { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(label, description, path, queryPiece, preferLabelMatches, allowNonContiguousMatches);
    if (score === NO_MATCH) {
      return NO_ITEM_SCORE;
    }
    totalScore += score;
    if (labelMatch) {
      totalLabelMatches.push(...labelMatch);
    }
    if (descriptionMatch) {
      totalDescriptionMatches.push(...descriptionMatch);
    }
  }
  return {
    score: totalScore,
    labelMatch: normalizeMatches(totalLabelMatches),
    descriptionMatch: normalizeMatches(totalDescriptionMatches)
  };
}
function doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches) {
  if (preferLabelMatches || !description) {
    const [labelScore, labelPositions] = scoreFuzzy(label, query.normalized, query.normalizedLowercase, allowNonContiguousMatches && !query.expectContiguousMatch);
    if (labelScore) {
      const labelPrefixMatch = matchesPrefix(query.normalized, label);
      let baseScore;
      if (labelPrefixMatch) {
        baseScore = LABEL_PREFIX_SCORE_THRESHOLD;
        const prefixLengthBoost = Math.round(query.normalized.length / label.length * 100);
        baseScore += prefixLengthBoost;
      } else {
        baseScore = LABEL_SCORE_THRESHOLD;
      }
      return { score: baseScore + labelScore, labelMatch: labelPrefixMatch || createMatches2(labelPositions) };
    }
  }
  if (description) {
    let descriptionPrefix = description;
    if (!!path) {
      descriptionPrefix = `${description}${sep}`;
    }
    const descriptionPrefixLength = descriptionPrefix.length;
    const descriptionAndLabel = `${descriptionPrefix}${label}`;
    const [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(descriptionAndLabel, query.normalized, query.normalizedLowercase, allowNonContiguousMatches && !query.expectContiguousMatch);
    if (labelDescriptionScore) {
      const labelDescriptionMatches = createMatches2(labelDescriptionPositions);
      const labelMatch = [];
      const descriptionMatch = [];
      labelDescriptionMatches.forEach((h) => {
        if (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {
          labelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });
          descriptionMatch.push({ start: h.start, end: descriptionPrefixLength });
        } else if (h.start >= descriptionPrefixLength) {
          labelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });
        } else {
          descriptionMatch.push(h);
        }
      });
      return { score: labelDescriptionScore, labelMatch, descriptionMatch };
    }
  }
  return NO_ITEM_SCORE;
}
function createMatches2(offsets) {
  const ret = [];
  if (!offsets) {
    return ret;
  }
  let last;
  for (const pos of offsets) {
    if (last && last.end === pos) {
      last.end += 1;
    } else {
      last = { start: pos, end: pos + 1 };
      ret.push(last);
    }
  }
  return ret;
}
function normalizeMatches(matches) {
  const sortedMatches = matches.sort((matchA, matchB) => {
    return matchA.start - matchB.start;
  });
  const normalizedMatches = [];
  let currentMatch = void 0;
  for (const match2 of sortedMatches) {
    if (!currentMatch || !matchOverlaps(currentMatch, match2)) {
      currentMatch = match2;
      normalizedMatches.push(match2);
    } else {
      currentMatch.start = Math.min(currentMatch.start, match2.start);
      currentMatch.end = Math.max(currentMatch.end, match2.end);
    }
  }
  return normalizedMatches;
}
function matchOverlaps(matchA, matchB) {
  if (matchA.end < matchB.start) {
    return false;
  }
  if (matchB.end < matchA.start) {
    return false;
  }
  return true;
}
function compareItemsByFuzzyScore(itemA, itemB, query, allowNonContiguousMatches, accessor, cache) {
  const itemScoreA = scoreItemFuzzy(itemA, query, allowNonContiguousMatches, accessor, cache);
  const itemScoreB = scoreItemFuzzy(itemB, query, allowNonContiguousMatches, accessor, cache);
  const scoreA = itemScoreA.score;
  const scoreB = itemScoreB.score;
  if (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {
    if (scoreA !== scoreB) {
      return scoreA === PATH_IDENTITY_SCORE ? -1 : 1;
    }
  }
  if (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {
    if (scoreA !== scoreB) {
      return scoreA > scoreB ? -1 : 1;
    }
    if (scoreA < LABEL_PREFIX_SCORE_THRESHOLD && scoreB < LABEL_PREFIX_SCORE_THRESHOLD) {
      const comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);
      if (comparedByMatchLength !== 0) {
        return comparedByMatchLength;
      }
    }
    const labelA = accessor.getItemLabel(itemA) || "";
    const labelB = accessor.getItemLabel(itemB) || "";
    if (labelA.length !== labelB.length) {
      return labelA.length - labelB.length;
    }
  }
  if (scoreA !== scoreB) {
    return scoreA > scoreB ? -1 : 1;
  }
  const itemAHasLabelMatches = Array.isArray(itemScoreA.labelMatch) && itemScoreA.labelMatch.length > 0;
  const itemBHasLabelMatches = Array.isArray(itemScoreB.labelMatch) && itemScoreB.labelMatch.length > 0;
  if (itemAHasLabelMatches && !itemBHasLabelMatches) {
    return -1;
  } else if (itemBHasLabelMatches && !itemAHasLabelMatches) {
    return 1;
  }
  const itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);
  const itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);
  if (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {
    return itemBMatchDistance > itemAMatchDistance ? -1 : 1;
  }
  return fallbackCompare(itemA, itemB, query, accessor);
}
function computeLabelAndDescriptionMatchDistance(item, score, accessor) {
  let matchStart = -1;
  let matchEnd = -1;
  if (score.descriptionMatch && score.descriptionMatch.length) {
    matchStart = score.descriptionMatch[0].start;
  } else if (score.labelMatch && score.labelMatch.length) {
    matchStart = score.labelMatch[0].start;
  }
  if (score.labelMatch && score.labelMatch.length) {
    matchEnd = score.labelMatch[score.labelMatch.length - 1].end;
    if (score.descriptionMatch && score.descriptionMatch.length) {
      const itemDescription = accessor.getItemDescription(item);
      if (itemDescription) {
        matchEnd += itemDescription.length;
      }
    }
  } else if (score.descriptionMatch && score.descriptionMatch.length) {
    matchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;
  }
  return matchEnd - matchStart;
}
function compareByMatchLength(matchesA, matchesB) {
  if (!matchesA && !matchesB || (!matchesA || !matchesA.length) && (!matchesB || !matchesB.length)) {
    return 0;
  }
  if (!matchesB || !matchesB.length) {
    return -1;
  }
  if (!matchesA || !matchesA.length) {
    return 1;
  }
  const matchStartA = matchesA[0].start;
  const matchEndA = matchesA[matchesA.length - 1].end;
  const matchLengthA = matchEndA - matchStartA;
  const matchStartB = matchesB[0].start;
  const matchEndB = matchesB[matchesB.length - 1].end;
  const matchLengthB = matchEndB - matchStartB;
  return matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;
}
function fallbackCompare(itemA, itemB, query, accessor) {
  const labelA = accessor.getItemLabel(itemA) || "";
  const labelB = accessor.getItemLabel(itemB) || "";
  const descriptionA = accessor.getItemDescription(itemA);
  const descriptionB = accessor.getItemDescription(itemB);
  const labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);
  const labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);
  if (labelDescriptionALength !== labelDescriptionBLength) {
    return labelDescriptionALength - labelDescriptionBLength;
  }
  const pathA = accessor.getItemPath(itemA);
  const pathB = accessor.getItemPath(itemB);
  if (pathA && pathB && pathA.length !== pathB.length) {
    return pathA.length - pathB.length;
  }
  if (labelA !== labelB) {
    return compareAnything(labelA, labelB, query.normalized);
  }
  if (descriptionA && descriptionB && descriptionA !== descriptionB) {
    return compareAnything(descriptionA, descriptionB, query.normalized);
  }
  if (pathA && pathB && pathA !== pathB) {
    return compareAnything(pathA, pathB, query.normalized);
  }
  return 0;
}
function queryExpectsExactMatch(query) {
  return query.startsWith('"') && query.endsWith('"');
}
var MULTIPLE_QUERY_VALUES_SEPARATOR = " ";
function prepareQuery(original) {
  if (typeof original !== "string") {
    original = "";
  }
  const originalLowercase = original.toLowerCase();
  const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);
  const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;
  const expectExactMatch = queryExpectsExactMatch(original);
  let values = void 0;
  const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);
  if (originalSplit.length > 1) {
    for (const originalPiece of originalSplit) {
      const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);
      const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);
      if (normalizedPiece) {
        if (!values) {
          values = [];
        }
        values.push({
          original: originalPiece,
          originalLowercase: originalPiece.toLowerCase(),
          pathNormalized: pathNormalizedPiece,
          normalized: normalizedPiece,
          normalizedLowercase: normalizedLowercasePiece,
          expectContiguousMatch: expectExactMatchPiece
        });
      }
    }
  }
  return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };
}
function normalizeQuery(original) {
  let pathNormalized;
  if (isWindows) {
    pathNormalized = original.replace(/\//g, sep);
  } else {
    pathNormalized = original.replace(/\\/g, sep);
  }
  const normalized = stripWildcards(pathNormalized).replace(/\s|"/g, "");
  return {
    pathNormalized,
    normalized,
    normalizedLowercase: normalized.toLowerCase()
  };
}
function pieceToQuery(arg1) {
  if (Array.isArray(arg1)) {
    return prepareQuery(arg1.map((piece) => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));
  }
  return prepareQuery(arg1.original);
}

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorQuickAccess.js
init_codicons();
init_themables();
var ActiveGroupEditorsByMostRecentlyUsedQuickAccess_1;
var AllEditorsByAppearanceQuickAccess_1;
var AllEditorsByMostRecentlyUsedQuickAccess_1;
var BaseEditorQuickAccessProvider = class BaseEditorQuickAccessProvider2 extends PickerQuickAccessProvider {
  constructor(prefix, editorGroupService, editorService, modelService, languageService) {
    super(prefix, {
      canAcceptInBackground: true,
      noResultsPick: {
        label: localize("noViewResults", "No matching editors"),
        groupId: -1
      }
    });
    this.editorGroupService = editorGroupService;
    this.editorService = editorService;
    this.modelService = modelService;
    this.languageService = languageService;
    this.pickState = new class {
      constructor() {
        this.scorerCache = /* @__PURE__ */ Object.create(null);
        this.isQuickNavigating = void 0;
      }
      reset(isQuickNavigating) {
        if (!isQuickNavigating) {
          this.scorerCache = /* @__PURE__ */ Object.create(null);
        }
        this.isQuickNavigating = isQuickNavigating;
      }
    }();
  }
  provide(picker, token) {
    this.pickState.reset(!!picker.quickNavigate);
    return super.provide(picker, token);
  }
  _getPicks(filter) {
    const query = prepareQuery(filter);
    const filteredEditorEntries = this.doGetEditorPickItems().filter((entry) => {
      if (!query.normalized) {
        return true;
      }
      const itemScore = scoreItemFuzzy(entry, query, true, quickPickItemScorerAccessor, this.pickState.scorerCache);
      if (!itemScore.score) {
        return false;
      }
      entry.highlights = { label: itemScore.labelMatch, description: itemScore.descriptionMatch };
      return true;
    });
    if (query.normalized) {
      const groups = this.editorGroupService.getGroups(2).map((group) => group.id);
      filteredEditorEntries.sort((entryA, entryB) => {
        if (entryA.groupId !== entryB.groupId) {
          return groups.indexOf(entryA.groupId) - groups.indexOf(entryB.groupId);
        }
        return compareItemsByFuzzyScore(entryA, entryB, query, true, quickPickItemScorerAccessor, this.pickState.scorerCache);
      });
    }
    const filteredEditorEntriesWithSeparators = [];
    if (this.editorGroupService.count > 1) {
      let lastGroupId = void 0;
      for (const entry of filteredEditorEntries) {
        if (typeof lastGroupId !== "number" || lastGroupId !== entry.groupId) {
          const group = this.editorGroupService.getGroup(entry.groupId);
          if (group) {
            filteredEditorEntriesWithSeparators.push({ type: "separator", label: group.label });
          }
          lastGroupId = entry.groupId;
        }
        filteredEditorEntriesWithSeparators.push(entry);
      }
    } else {
      filteredEditorEntriesWithSeparators.push(...filteredEditorEntries);
    }
    return filteredEditorEntriesWithSeparators;
  }
  doGetEditorPickItems() {
    const editors = this.doGetEditors();
    const mapGroupIdToGroupAriaLabel = /* @__PURE__ */ new Map();
    for (const { groupId } of editors) {
      if (!mapGroupIdToGroupAriaLabel.has(groupId)) {
        const group = this.editorGroupService.getGroup(groupId);
        if (group) {
          mapGroupIdToGroupAriaLabel.set(groupId, group.ariaLabel);
        }
      }
    }
    return this.doGetEditors().map(({ editor, groupId }) => {
      var _a43;
      const resource = EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY });
      const isDirty = editor.isDirty() && !editor.isSaving();
      const description = editor.getDescription();
      const nameAndDescription = description ? `${editor.getName()} ${description}` : editor.getName();
      return {
        groupId,
        resource,
        label: editor.getName(),
        ariaLabel: (() => {
          if (mapGroupIdToGroupAriaLabel.size > 1) {
            return isDirty ? localize(
              "entryAriaLabelWithGroupDirty",
              "{0}, unsaved changes, {1}",
              nameAndDescription,
              mapGroupIdToGroupAriaLabel.get(groupId)
            ) : localize(
              "entryAriaLabelWithGroup",
              "{0}, {1}",
              nameAndDescription,
              mapGroupIdToGroupAriaLabel.get(groupId)
            );
          }
          return isDirty ? localize("entryAriaLabelDirty", "{0}, unsaved changes", nameAndDescription) : nameAndDescription;
        })(),
        description,
        iconClasses: getIconClasses(this.modelService, this.languageService, resource).concat(editor.getLabelExtraClasses()),
        italic: !((_a43 = this.editorGroupService.getGroup(groupId)) == null ? void 0 : _a43.isPinned(editor)),
        buttons: (() => {
          return [
            {
              iconClass: isDirty ? "dirty-editor " + ThemeIcon.asClassName(Codicon.closeDirty) : ThemeIcon.asClassName(Codicon.close),
              tooltip: localize("closeEditor", "Close Editor"),
              alwaysVisible: isDirty
            }
          ];
        })(),
        trigger: async () => {
          const group = this.editorGroupService.getGroup(groupId);
          if (group) {
            await group.closeEditor(editor, { preserveFocus: true });
            if (!group.contains(editor)) {
              return TriggerAction.REMOVE_ITEM;
            }
          }
          return TriggerAction.NO_ACTION;
        },
        accept: (keyMods, event) => {
          var _a44;
          return (_a44 = this.editorGroupService.getGroup(groupId)) == null ? void 0 : _a44.openEditor(editor, { preserveFocus: event.inBackground });
        }
      };
    });
  }
};
BaseEditorQuickAccessProvider = __decorate([
  __param(1, IEditorGroupsService),
  __param(2, IEditorService),
  __param(3, IModelService),
  __param(4, ILanguageService)
], BaseEditorQuickAccessProvider);
var _a26;
var ActiveGroupEditorsByMostRecentlyUsedQuickAccess = (_a26 = class extends BaseEditorQuickAccessProvider {
  constructor(editorGroupService, editorService, modelService, languageService) {
    super(ActiveGroupEditorsByMostRecentlyUsedQuickAccess_1.PREFIX, editorGroupService, editorService, modelService, languageService);
  }
  doGetEditors() {
    const group = this.editorGroupService.activeGroup;
    return group.getEditors(0).map((editor) => ({ editor, groupId: group.id }));
  }
}, ActiveGroupEditorsByMostRecentlyUsedQuickAccess_1 = _a26, _a26.PREFIX = "edt active ", _a26);
ActiveGroupEditorsByMostRecentlyUsedQuickAccess = ActiveGroupEditorsByMostRecentlyUsedQuickAccess_1 = __decorate([
  __param(0, IEditorGroupsService),
  __param(1, IEditorService),
  __param(2, IModelService),
  __param(3, ILanguageService)
], ActiveGroupEditorsByMostRecentlyUsedQuickAccess);
var _a27;
var AllEditorsByAppearanceQuickAccess = (_a27 = class extends BaseEditorQuickAccessProvider {
  constructor(editorGroupService, editorService, modelService, languageService) {
    super(AllEditorsByAppearanceQuickAccess_1.PREFIX, editorGroupService, editorService, modelService, languageService);
  }
  doGetEditors() {
    const entries = [];
    for (const group of this.editorGroupService.getGroups(2)) {
      for (const editor of group.getEditors(1)) {
        entries.push({ editor, groupId: group.id });
      }
    }
    return entries;
  }
}, AllEditorsByAppearanceQuickAccess_1 = _a27, _a27.PREFIX = "edt ", _a27);
AllEditorsByAppearanceQuickAccess = AllEditorsByAppearanceQuickAccess_1 = __decorate([
  __param(0, IEditorGroupsService),
  __param(1, IEditorService),
  __param(2, IModelService),
  __param(3, ILanguageService)
], AllEditorsByAppearanceQuickAccess);
var _a28;
var AllEditorsByMostRecentlyUsedQuickAccess = (_a28 = class extends BaseEditorQuickAccessProvider {
  constructor(editorGroupService, editorService, modelService, languageService) {
    super(AllEditorsByMostRecentlyUsedQuickAccess_1.PREFIX, editorGroupService, editorService, modelService, languageService);
  }
  doGetEditors() {
    const entries = [];
    for (const editor of this.editorService.getEditors(0)) {
      entries.push(editor);
    }
    return entries;
  }
}, AllEditorsByMostRecentlyUsedQuickAccess_1 = _a28, _a28.PREFIX = "edt mru ", _a28);
AllEditorsByMostRecentlyUsedQuickAccess = AllEditorsByMostRecentlyUsedQuickAccess_1 = __decorate([
  __param(0, IEditorGroupsService),
  __param(1, IEditorService),
  __param(2, IModelService),
  __param(3, ILanguageService)
], AllEditorsByMostRecentlyUsedQuickAccess);

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorCommands.js
init_opener();
init_network();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/sideBySideEditor.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/media/sidebysideeditor.css.js
var css3 = ".side-by-side-editor-container{height:100%;width:100%}";
n(css3, {});

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/sideBySideEditor.js
init_nls();
init_dom();
init_platform2();
init_telemetry();
init_instantiation();
init_themeService();
init_event();
init_types();
init_configuration();
init_lifecycle();
init_resources();
init_uri();
var SideBySideEditor_1;
function isSideBySideEditorViewState(thing) {
  const candidate = thing;
  return typeof (candidate == null ? void 0 : candidate.primary) === "object" && typeof candidate.secondary === "object";
}
var _a29;
var SideBySideEditor2 = (_a29 = class extends AbstractEditorWithViewState {
  get minimumPrimaryWidth() {
    return this.primaryEditorPane ? this.primaryEditorPane.minimumWidth : 0;
  }
  get maximumPrimaryWidth() {
    return this.primaryEditorPane ? this.primaryEditorPane.maximumWidth : Number.POSITIVE_INFINITY;
  }
  get minimumPrimaryHeight() {
    return this.primaryEditorPane ? this.primaryEditorPane.minimumHeight : 0;
  }
  get maximumPrimaryHeight() {
    return this.primaryEditorPane ? this.primaryEditorPane.maximumHeight : Number.POSITIVE_INFINITY;
  }
  get minimumSecondaryWidth() {
    return this.secondaryEditorPane ? this.secondaryEditorPane.minimumWidth : 0;
  }
  get maximumSecondaryWidth() {
    return this.secondaryEditorPane ? this.secondaryEditorPane.maximumWidth : Number.POSITIVE_INFINITY;
  }
  get minimumSecondaryHeight() {
    return this.secondaryEditorPane ? this.secondaryEditorPane.minimumHeight : 0;
  }
  get maximumSecondaryHeight() {
    return this.secondaryEditorPane ? this.secondaryEditorPane.maximumHeight : Number.POSITIVE_INFINITY;
  }
  set minimumWidth(value) {
  }
  set maximumWidth(value) {
  }
  set minimumHeight(value) {
  }
  set maximumHeight(value) {
  }
  get minimumWidth() {
    return this.minimumPrimaryWidth + this.minimumSecondaryWidth;
  }
  get maximumWidth() {
    return this.maximumPrimaryWidth + this.maximumSecondaryWidth;
  }
  get minimumHeight() {
    return this.minimumPrimaryHeight + this.minimumSecondaryHeight;
  }
  get maximumHeight() {
    return this.maximumPrimaryHeight + this.maximumSecondaryHeight;
  }
  constructor(telemetryService, instantiationService, themeService, storageService, configurationService, textResourceConfigurationService, editorService, editorGroupService) {
    super(SideBySideEditor_1.ID, SideBySideEditor_1.VIEW_STATE_PREFERENCE_KEY, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorService, editorGroupService);
    this.configurationService = configurationService;
    this.onDidCreateEditors = this._register(new Emitter());
    this._onDidChangeSizeConstraints = this._register(new Relay());
    this.onDidChangeSizeConstraints = Event.any(this.onDidCreateEditors.event, this._onDidChangeSizeConstraints.event);
    this._onDidChangeSelection = this._register(new Emitter());
    this.onDidChangeSelection = this._onDidChangeSelection.event;
    this.primaryEditorPane = void 0;
    this.secondaryEditorPane = void 0;
    this.splitviewDisposables = this._register(new DisposableStore());
    this.editorDisposables = this._register(new DisposableStore());
    this.orientation = this.configurationService.getValue(SideBySideEditor_1.SIDE_BY_SIDE_LAYOUT_SETTING) === "vertical" ? 0 : 1;
    this.dimension = new Dimension(0, 0);
    this.lastFocusedSide = void 0;
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationUpdated(e)));
  }
  onConfigurationUpdated(event) {
    if (event.affectsConfiguration(SideBySideEditor_1.SIDE_BY_SIDE_LAYOUT_SETTING)) {
      this.orientation = this.configurationService.getValue(SideBySideEditor_1.SIDE_BY_SIDE_LAYOUT_SETTING) === "vertical" ? 0 : 1;
      if (this.splitview) {
        this.recreateSplitview();
      }
    }
  }
  recreateSplitview() {
    const container = assertIsDefined(this.getContainer());
    const ratio = this.getSplitViewRatio();
    if (this.splitview) {
      container.removeChild(this.splitview.el);
      this.splitviewDisposables.clear();
    }
    this.createSplitView(container, ratio);
    this.layout(this.dimension);
  }
  getSplitViewRatio() {
    let ratio = void 0;
    if (this.splitview) {
      const leftViewSize = this.splitview.getViewSize(0);
      const rightViewSize = this.splitview.getViewSize(1);
      if (Math.abs(leftViewSize - rightViewSize) > 1) {
        const totalSize = this.splitview.orientation === 1 ? this.dimension.width : this.dimension.height;
        ratio = leftViewSize / totalSize;
      }
    }
    return ratio;
  }
  createEditor(parent) {
    parent.classList.add("side-by-side-editor");
    this.secondaryEditorContainer = $(".side-by-side-editor-container.editor-instance");
    this.primaryEditorContainer = $(".side-by-side-editor-container.editor-instance");
    this.createSplitView(parent);
  }
  createSplitView(parent, ratio) {
    var _a43, _b, _c;
    this.splitview = this.splitviewDisposables.add(new SplitView(parent, { orientation: this.orientation }));
    this.splitviewDisposables.add(this.splitview.onDidSashReset(() => {
      var _a44;
      return (_a44 = this.splitview) == null ? void 0 : _a44.distributeViewSizes();
    }));
    if (this.orientation === 1) {
      this.splitview.orthogonalEndSash = (_a43 = this._boundarySashes) == null ? void 0 : _a43.bottom;
    } else {
      this.splitview.orthogonalStartSash = (_b = this._boundarySashes) == null ? void 0 : _b.left;
      this.splitview.orthogonalEndSash = (_c = this._boundarySashes) == null ? void 0 : _c.right;
    }
    let leftSizing = Sizing.Distribute;
    let rightSizing = Sizing.Distribute;
    if (ratio) {
      const totalSize = this.splitview.orientation === 1 ? this.dimension.width : this.dimension.height;
      leftSizing = Math.round(totalSize * ratio);
      rightSizing = totalSize - leftSizing;
      this.splitview.layout(this.orientation === 1 ? this.dimension.width : this.dimension.height);
    }
    const secondaryEditorContainer = assertIsDefined(this.secondaryEditorContainer);
    this.splitview.addView({
      element: secondaryEditorContainer,
      layout: (size) => this.layoutPane(this.secondaryEditorPane, size),
      minimumSize: this.orientation === 1 ? DEFAULT_EDITOR_MIN_DIMENSIONS.width : DEFAULT_EDITOR_MIN_DIMENSIONS.height,
      maximumSize: Number.POSITIVE_INFINITY,
      onDidChange: Event.None
    }, leftSizing);
    const primaryEditorContainer = assertIsDefined(this.primaryEditorContainer);
    this.splitview.addView({
      element: primaryEditorContainer,
      layout: (size) => this.layoutPane(this.primaryEditorPane, size),
      minimumSize: this.orientation === 1 ? DEFAULT_EDITOR_MIN_DIMENSIONS.width : DEFAULT_EDITOR_MIN_DIMENSIONS.height,
      maximumSize: Number.POSITIVE_INFINITY,
      onDidChange: Event.None
    }, rightSizing);
    this.updateStyles();
  }
  getTitle() {
    if (this.input) {
      return this.input.getName();
    }
    return localize("sideBySideEditor", "Side by Side Editor");
  }
  async setInput(input, options, context, token) {
    var _a43, _b, _c;
    const oldInput = this.input;
    await super.setInput(input, options, context, token);
    if (!oldInput || !input.matches(oldInput)) {
      if (oldInput) {
        this.disposeEditors();
      }
      this.createEditors(input);
    }
    const { primary, secondary, viewState } = this.loadViewState(input, options, context);
    this.lastFocusedSide = viewState == null ? void 0 : viewState.focus;
    if (typeof (viewState == null ? void 0 : viewState.ratio) === "number" && this.splitview) {
      const totalSize = this.splitview.orientation === 1 ? this.dimension.width : this.dimension.height;
      this.splitview.resizeView(0, Math.round(totalSize * viewState.ratio));
    } else {
      (_a43 = this.splitview) == null ? void 0 : _a43.distributeViewSizes();
    }
    await Promise.all([
      (_b = this.secondaryEditorPane) == null ? void 0 : _b.setInput(input.secondary, secondary, context, token),
      (_c = this.primaryEditorPane) == null ? void 0 : _c.setInput(input.primary, primary, context, token)
    ]);
    if (typeof (options == null ? void 0 : options.target) === "number") {
      this.lastFocusedSide = options.target;
    }
  }
  loadViewState(input, options, context) {
    const viewState = isSideBySideEditorViewState(options == null ? void 0 : options.viewState) ? options == null ? void 0 : options.viewState : this.loadEditorViewState(input, context);
    let primaryOptions = /* @__PURE__ */ Object.create(null);
    let secondaryOptions = void 0;
    if ((options == null ? void 0 : options.target) === SideBySideEditor.SECONDARY) {
      secondaryOptions = { ...options };
    } else {
      primaryOptions = { ...options };
    }
    primaryOptions.viewState = viewState == null ? void 0 : viewState.primary;
    if (viewState == null ? void 0 : viewState.secondary) {
      if (!secondaryOptions) {
        secondaryOptions = { viewState: viewState.secondary };
      } else {
        secondaryOptions.viewState = viewState == null ? void 0 : viewState.secondary;
      }
    }
    return { primary: primaryOptions, secondary: secondaryOptions, viewState };
  }
  createEditors(newInput) {
    this.secondaryEditorPane = this.doCreateEditor(newInput.secondary, assertIsDefined(this.secondaryEditorContainer));
    this.primaryEditorPane = this.doCreateEditor(newInput.primary, assertIsDefined(this.primaryEditorContainer));
    this.layout(this.dimension);
    this._onDidChangeSizeConstraints.input = Event.any(Event.map(this.secondaryEditorPane.onDidChangeSizeConstraints, () => void 0), Event.map(this.primaryEditorPane.onDidChangeSizeConstraints, () => void 0));
    this.onDidCreateEditors.fire(void 0);
    this.editorDisposables.add(this.primaryEditorPane.onDidFocus(() => this.onDidFocusChange(SideBySideEditor.PRIMARY)));
    this.editorDisposables.add(this.secondaryEditorPane.onDidFocus(() => this.onDidFocusChange(SideBySideEditor.SECONDARY)));
  }
  doCreateEditor(editorInput, container) {
    const editorPaneDescriptor = Registry.as(EditorExtensions.EditorPane).getEditorPane(editorInput);
    if (!editorPaneDescriptor) {
      throw new Error("No editor pane descriptor for editor found");
    }
    const editorPane = editorPaneDescriptor.instantiate(this.instantiationService);
    editorPane.create(container);
    editorPane.setVisible(this.isVisible(), this.group);
    if (isEditorPaneWithSelection(editorPane)) {
      this.editorDisposables.add(editorPane.onDidChangeSelection((e) => this._onDidChangeSelection.fire(e)));
    }
    this.editorDisposables.add(editorPane);
    return editorPane;
  }
  onDidFocusChange(side) {
    this.lastFocusedSide = side;
    this._onDidChangeControl.fire();
  }
  getSelection() {
    const lastFocusedEditorPane = this.getLastFocusedEditorPane();
    if (isEditorPaneWithSelection(lastFocusedEditorPane)) {
      const selection = lastFocusedEditorPane.getSelection();
      if (selection) {
        return new SideBySideAwareEditorPaneSelection(
          selection,
          lastFocusedEditorPane === this.primaryEditorPane ? SideBySideEditor.PRIMARY : SideBySideEditor.SECONDARY
        );
      }
    }
    return void 0;
  }
  setOptions(options) {
    var _a43;
    super.setOptions(options);
    if (typeof (options == null ? void 0 : options.target) === "number") {
      this.lastFocusedSide = options.target;
    }
    (_a43 = this.getLastFocusedEditorPane()) == null ? void 0 : _a43.setOptions(options);
  }
  setEditorVisible(visible, group) {
    var _a43, _b;
    (_a43 = this.primaryEditorPane) == null ? void 0 : _a43.setVisible(visible, group);
    (_b = this.secondaryEditorPane) == null ? void 0 : _b.setVisible(visible, group);
    super.setEditorVisible(visible, group);
  }
  clearInput() {
    var _a43, _b;
    super.clearInput();
    (_a43 = this.primaryEditorPane) == null ? void 0 : _a43.clearInput();
    (_b = this.secondaryEditorPane) == null ? void 0 : _b.clearInput();
    this.disposeEditors();
  }
  focus() {
    var _a43;
    (_a43 = this.getLastFocusedEditorPane()) == null ? void 0 : _a43.focus();
  }
  getLastFocusedEditorPane() {
    if (this.lastFocusedSide === SideBySideEditor.SECONDARY) {
      return this.secondaryEditorPane;
    }
    return this.primaryEditorPane;
  }
  layout(dimension) {
    this.dimension = dimension;
    const splitview = assertIsDefined(this.splitview);
    splitview.layout(this.orientation === 1 ? dimension.width : dimension.height);
  }
  setBoundarySashes(sashes) {
    this._boundarySashes = sashes;
    if (this.splitview) {
      this.splitview.orthogonalEndSash = sashes.bottom;
    }
  }
  layoutPane(pane, size) {
    pane == null ? void 0 : pane.layout(this.orientation === 1 ? new Dimension(size, this.dimension.height) : new Dimension(this.dimension.width, size));
  }
  getControl() {
    var _a43;
    return (_a43 = this.getLastFocusedEditorPane()) == null ? void 0 : _a43.getControl();
  }
  getPrimaryEditorPane() {
    return this.primaryEditorPane;
  }
  getSecondaryEditorPane() {
    return this.secondaryEditorPane;
  }
  tracksEditorViewState(input) {
    return input instanceof SideBySideEditorInput;
  }
  computeEditorViewState(resource) {
    var _a43, _b;
    if (!this.input || !isEqual2(resource, this.toEditorViewStateResource(this.input))) {
      return;
    }
    const primarViewState = (_a43 = this.primaryEditorPane) == null ? void 0 : _a43.getViewState();
    const secondaryViewState = (_b = this.secondaryEditorPane) == null ? void 0 : _b.getViewState();
    if (!primarViewState || !secondaryViewState) {
      return;
    }
    return {
      primary: primarViewState,
      secondary: secondaryViewState,
      focus: this.lastFocusedSide,
      ratio: this.getSplitViewRatio()
    };
  }
  toEditorViewStateResource(input) {
    let primary;
    let secondary;
    if (input instanceof SideBySideEditorInput) {
      primary = input.primary.resource;
      secondary = input.secondary.resource;
    }
    if (!secondary || !primary) {
      return void 0;
    }
    return URI.from({ scheme: "sideBySide", path: `${multibyteAwareBtoa(secondary.toString())}${multibyteAwareBtoa(primary.toString())}` });
  }
  updateStyles() {
    super.updateStyles();
    if (this.primaryEditorContainer) {
      if (this.orientation === 1) {
        this.primaryEditorContainer.style.borderLeftWidth = "1px";
        this.primaryEditorContainer.style.borderLeftStyle = "solid";
        this.primaryEditorContainer.style.borderLeftColor = this.getColor(SIDE_BY_SIDE_EDITOR_VERTICAL_BORDER) ?? "";
        this.primaryEditorContainer.style.borderTopWidth = "0";
      } else {
        this.primaryEditorContainer.style.borderTopWidth = "1px";
        this.primaryEditorContainer.style.borderTopStyle = "solid";
        this.primaryEditorContainer.style.borderTopColor = this.getColor(SIDE_BY_SIDE_EDITOR_HORIZONTAL_BORDER) ?? "";
        this.primaryEditorContainer.style.borderLeftWidth = "0";
      }
    }
  }
  dispose() {
    this.disposeEditors();
    super.dispose();
  }
  disposeEditors() {
    this.editorDisposables.clear();
    this.secondaryEditorPane = void 0;
    this.primaryEditorPane = void 0;
    this.lastFocusedSide = void 0;
    if (this.secondaryEditorContainer) {
      clearNode(this.secondaryEditorContainer);
    }
    if (this.primaryEditorContainer) {
      clearNode(this.primaryEditorContainer);
    }
  }
}, SideBySideEditor_1 = _a29, _a29.ID = SIDE_BY_SIDE_EDITOR_ID, _a29.SIDE_BY_SIDE_LAYOUT_SETTING = "workbench.editor.splitInGroupLayout", _a29.VIEW_STATE_PREFERENCE_KEY = "sideBySideEditorViewState", _a29);
SideBySideEditor2 = SideBySideEditor_1 = __decorate([
  __param(0, ITelemetryService),
  __param(1, IInstantiationService),
  __param(2, IThemeService),
  __param(3, IStorageService),
  __param(4, IConfigurationService),
  __param(5, ITextResourceConfigurationService),
  __param(6, IEditorService),
  __param(7, IEditorGroupsService)
], SideBySideEditor2);
var SideBySideAwareEditorPaneSelection = class _SideBySideAwareEditorPaneSelection {
  constructor(selection, side) {
    this.selection = selection;
    this.side = side;
  }
  compare(other) {
    if (!(other instanceof _SideBySideAwareEditorPaneSelection)) {
      return 3;
    }
    if (this.side !== other.side) {
      return 3;
    }
    return this.selection.compare(other.selection);
  }
  restore(options) {
    const sideBySideEditorOptions = {
      ...options,
      target: this.side
    };
    return this.selection.restore(sideBySideEditorOptions);
  }
};

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorCommands.js
init_telemetry();
init_resources();
init_editorBrowser();
var CLOSE_EDITORS_AND_GROUP_COMMAND_ID = "workbench.action.closeEditorsAndGroup";
var CLOSE_EDITOR_COMMAND_ID = "workbench.action.closeActiveEditor";
var COPY_ACTIVE_EDITOR_COMMAND_ID = "copyActiveEditor";
var LAYOUT_EDITOR_GROUPS_COMMAND_ID = "layoutEditorGroups";
var UNPIN_EDITOR_COMMAND_ID = "workbench.action.unpinEditor";
var SPLIT_EDITOR_UP = "workbench.action.splitEditorUp";
var SPLIT_EDITOR_DOWN = "workbench.action.splitEditorDown";
function splitEditor(editorGroupService, direction, context) {
  let sourceGroup;
  if (context && typeof context.groupId === "number") {
    sourceGroup = editorGroupService.getGroup(context.groupId);
  } else {
    sourceGroup = editorGroupService.activeGroup;
  }
  if (!sourceGroup) {
    return;
  }
  const newGroup = editorGroupService.addGroup(sourceGroup, direction);
  let editorToCopy;
  if (context && typeof context.editorIndex === "number") {
    editorToCopy = sourceGroup.getEditorByIndex(context.editorIndex);
  } else {
    editorToCopy = sourceGroup.activeEditor ?? void 0;
  }
  if (editorToCopy && !editorToCopy.hasCapability(8)) {
    sourceGroup.copyEditor(editorToCopy, newGroup, { preserveFocus: context == null ? void 0 : context.preserveFocus });
  }
  newGroup.focus();
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/fileActions.js
init_arrays();
init_errors();
init_dom();
init_async();
init_codicons();
init_themables();
init_strings();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/fileImportExport.js
init_tslib_es6();
init_nls();
init_cancellation();
init_files();
init_progress();
init_async();
init_buffer();
init_resources();
init_uri();
init_platform();
init_dom();
init_log();
init_network();
init_stream();
init_lifecycle();
init_functional();
init_arrays();
init_errors();
init_configuration();
init_instantiation();
var BrowserFileUpload_1;
var FileDownload_1;
var _a30;
var BrowserFileUpload = (_a30 = class {
  constructor(progressService, dialogService, explorerService, editorService, fileService) {
    this.progressService = progressService;
    this.dialogService = dialogService;
    this.explorerService = explorerService;
    this.editorService = editorService;
    this.fileService = fileService;
  }
  upload(target, source) {
    const cts = new CancellationTokenSource();
    const uploadPromise = this.progressService.withProgress({
      location: 10,
      delay: 800,
      cancellable: true,
      title: localize("uploadingFiles", "Uploading")
    }, async (progress) => this.doUpload(target, this.toTransfer(source), progress, cts.token), () => cts.dispose(true));
    this.progressService.withProgress({ location: VIEW_ID, delay: 500 }, () => uploadPromise);
    return uploadPromise;
  }
  toTransfer(source) {
    if (source instanceof DragEvent) {
      return source.dataTransfer;
    }
    const transfer = { items: [] };
    for (const file of source) {
      transfer.items.push({
        webkitGetAsEntry: () => {
          return {
            name: file.name,
            isDirectory: false,
            isFile: true,
            createReader: () => {
              throw new Error("Unsupported for files");
            },
            file: (resolve) => resolve(file)
          };
        }
      });
    }
    return transfer;
  }
  async doUpload(target, source, progress, token) {
    const items = source.items;
    const entries = [];
    for (const item of items) {
      entries.push(item.webkitGetAsEntry());
    }
    const results = [];
    const operation = {
      startTime: Date.now(),
      progressScheduler: new RunOnceWorker((steps) => {
        progress.report(steps[steps.length - 1]);
      }, 1e3),
      filesTotal: entries.length,
      filesUploaded: 0,
      totalBytesUploaded: 0
    };
    const uploadLimiter = new Limiter(BrowserFileUpload_1.MAX_PARALLEL_UPLOADS);
    await Promises.settled(entries.map((entry) => {
      return uploadLimiter.queue(async () => {
        var _a43;
        if (token.isCancellationRequested) {
          return;
        }
        if (target && entry.name && target.getChild(entry.name)) {
          const { confirmed } = await this.dialogService.confirm(getFileOverwriteConfirm(entry.name));
          if (!confirmed) {
            return;
          }
          await this.explorerService.applyBulkEdit([new ResourceFileEdit(
            joinPath(target.resource, entry.name),
            void 0,
            { recursive: true, folder: (_a43 = target.getChild(entry.name)) == null ? void 0 : _a43.isDirectory }
          )], {
            undoLabel: localize("overwrite", "Overwrite {0}", entry.name),
            progressLabel: localize("overwriting", "Overwriting {0}", entry.name)
          });
          if (token.isCancellationRequested) {
            return;
          }
        }
        const result = await this.doUploadEntry(entry, target.resource, target, progress, operation, token);
        if (result) {
          results.push(result);
        }
      });
    }));
    operation.progressScheduler.dispose();
    const firstUploadedFile = results[0];
    if (!token.isCancellationRequested && (firstUploadedFile == null ? void 0 : firstUploadedFile.isFile)) {
      await this.editorService.openEditor({ resource: firstUploadedFile.resource, options: { pinned: true } });
    }
  }
  async doUploadEntry(entry, parentResource, target, progress, operation, token) {
    if (token.isCancellationRequested || !entry.name || !entry.isFile && !entry.isDirectory) {
      return void 0;
    }
    let fileBytesUploaded = 0;
    const reportProgress = (fileSize, bytesUploaded) => {
      fileBytesUploaded += bytesUploaded;
      operation.totalBytesUploaded += bytesUploaded;
      const bytesUploadedPerSecond = operation.totalBytesUploaded / ((Date.now() - operation.startTime) / 1e3);
      let message;
      if (fileSize < ByteSize.MB) {
        if (operation.filesTotal === 1) {
          message = `${entry.name}`;
        } else {
          message = localize(
            "uploadProgressSmallMany",
            "{0} of {1} files ({2}/s)",
            operation.filesUploaded,
            operation.filesTotal,
            ByteSize.formatSize(bytesUploadedPerSecond)
          );
        }
      } else {
        message = localize(
          "uploadProgressLarge",
          "{0} ({1} of {2}, {3}/s)",
          entry.name,
          ByteSize.formatSize(fileBytesUploaded),
          ByteSize.formatSize(fileSize),
          ByteSize.formatSize(bytesUploadedPerSecond)
        );
      }
      operation.progressScheduler.work({ message });
    };
    operation.filesUploaded++;
    reportProgress(0, 0);
    const resource = joinPath(parentResource, entry.name);
    if (entry.isFile) {
      const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
      if (token.isCancellationRequested) {
        return void 0;
      }
      if (typeof file.stream === "function" && file.size > ByteSize.MB) {
        await this.doUploadFileBuffered(resource, file, reportProgress, token);
      } else {
        await this.doUploadFileUnbuffered(resource, file, reportProgress);
      }
      return { isFile: true, resource };
    } else {
      await this.fileService.createFolder(resource);
      if (token.isCancellationRequested) {
        return void 0;
      }
      const dirReader = entry.createReader();
      const childEntries = [];
      let done = false;
      do {
        const childEntriesChunk = await new Promise((resolve, reject) => dirReader.readEntries(resolve, reject));
        if (childEntriesChunk.length > 0) {
          childEntries.push(...childEntriesChunk);
        } else {
          done = true;
        }
      } while (!done && !token.isCancellationRequested);
      operation.filesTotal += childEntries.length;
      const folderTarget = target && target.getChild(entry.name) || void 0;
      const fileChildEntries = [];
      const folderChildEntries = [];
      for (const childEntry of childEntries) {
        if (childEntry.isFile) {
          fileChildEntries.push(childEntry);
        } else if (childEntry.isDirectory) {
          folderChildEntries.push(childEntry);
        }
      }
      const fileUploadQueue = new Limiter(BrowserFileUpload_1.MAX_PARALLEL_UPLOADS);
      await Promises.settled(fileChildEntries.map((fileChildEntry) => {
        return fileUploadQueue.queue(() => this.doUploadEntry(fileChildEntry, resource, folderTarget, progress, operation, token));
      }));
      for (const folderChildEntry of folderChildEntries) {
        await this.doUploadEntry(folderChildEntry, resource, folderTarget, progress, operation, token);
      }
      return { isFile: false, resource };
    }
  }
  async doUploadFileBuffered(resource, file, progressReporter, token) {
    const writeableStream = newWriteableBufferStream({
      highWaterMark: 10
    });
    const writeFilePromise = this.fileService.writeFile(resource, writeableStream);
    try {
      const reader = file.stream().getReader();
      let res = await reader.read();
      while (!res.done) {
        if (token.isCancellationRequested) {
          break;
        }
        const buffer = VSBuffer.wrap(res.value);
        await writeableStream.write(buffer);
        if (token.isCancellationRequested) {
          break;
        }
        progressReporter(file.size, buffer.byteLength);
        res = await reader.read();
      }
      writeableStream.end(void 0);
    } catch (error) {
      writeableStream.error(error);
      writeableStream.end();
    }
    if (token.isCancellationRequested) {
      return void 0;
    }
    await writeFilePromise;
  }
  doUploadFileUnbuffered(resource, file, progressReporter) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = async (event) => {
        var _a43;
        try {
          if (((_a43 = event.target) == null ? void 0 : _a43.result) instanceof ArrayBuffer) {
            const buffer = VSBuffer.wrap(new Uint8Array(event.target.result));
            await this.fileService.writeFile(resource, buffer);
            progressReporter(file.size, buffer.byteLength);
          } else {
            throw new Error("Could not read from dropped file.");
          }
          resolve();
        } catch (error) {
          reject(error);
        }
      };
      reader.readAsArrayBuffer(file);
    });
  }
}, BrowserFileUpload_1 = _a30, _a30.MAX_PARALLEL_UPLOADS = 20, _a30);
BrowserFileUpload = BrowserFileUpload_1 = __decorate([
  __param(0, IProgressService),
  __param(1, IDialogService),
  __param(2, IExplorerService),
  __param(3, IEditorService),
  __param(4, IFileService)
], BrowserFileUpload);
var ExternalFileImport = class ExternalFileImport2 {
  constructor(fileService, hostService, contextService, configurationService, dialogService, workspaceEditingService, explorerService, editorService, progressService, notificationService, instantiationService) {
    this.fileService = fileService;
    this.hostService = hostService;
    this.contextService = contextService;
    this.configurationService = configurationService;
    this.dialogService = dialogService;
    this.workspaceEditingService = workspaceEditingService;
    this.explorerService = explorerService;
    this.editorService = editorService;
    this.progressService = progressService;
    this.notificationService = notificationService;
    this.instantiationService = instantiationService;
  }
  async import(target, source) {
    const cts = new CancellationTokenSource();
    const importPromise = this.progressService.withProgress({
      location: 10,
      delay: 800,
      cancellable: true,
      title: localize("copyingFiles", "Copying...")
    }, async () => await this.doImport(target, source, cts.token), () => cts.dispose(true));
    this.progressService.withProgress({ location: VIEW_ID, delay: 500 }, () => importPromise);
    return importPromise;
  }
  async doImport(target, source, token) {
    const candidateFiles = coalesce((await this.instantiationService.invokeFunction((accessor) => extractEditorsAndFilesDropData(accessor, source))).map((editor) => editor.resource));
    await Promise.all(candidateFiles.map((resource) => this.fileService.activateProvider(resource.scheme)));
    const files = coalesce(candidateFiles.filter((resource) => this.fileService.hasProvider(resource)));
    const resolvedFiles = await this.fileService.resolveAll(files.map((file) => ({ resource: file })));
    if (token.isCancellationRequested) {
      return;
    }
    this.hostService.focus();
    const folders = resolvedFiles.filter((resolvedFile) => {
      var _a43;
      return resolvedFile.success && ((_a43 = resolvedFile.stat) == null ? void 0 : _a43.isDirectory);
    }).map((resolvedFile) => ({ uri: resolvedFile.stat.resource }));
    if (folders.length > 0 && target.isRoot) {
      let ImportChoice;
      (function(ImportChoice2) {
        ImportChoice2[ImportChoice2["Copy"] = 1] = "Copy";
        ImportChoice2[ImportChoice2["Add"] = 2] = "Add";
      })(ImportChoice || (ImportChoice = {}));
      const buttons = [
        {
          label: folders.length > 1 ? localize("copyFolders", "&&Copy Folders") : localize("copyFolder", "&&Copy Folder"),
          run: () => ImportChoice.Copy
        }
      ];
      let message;
      const workspaceFolderSchemas = this.contextService.getWorkspace().folders.map((folder) => folder.uri.scheme);
      if (folders.some((folder) => workspaceFolderSchemas.indexOf(folder.uri.scheme) >= 0)) {
        buttons.unshift({
          label: folders.length > 1 ? localize("addFolders", "&&Add Folders to Workspace") : localize("addFolder", "&&Add Folder to Workspace"),
          run: () => ImportChoice.Add
        });
        message = folders.length > 1 ? localize(
          "dropFolders",
          "Do you want to copy the folders or add the folders to the workspace?"
        ) : localize(
          "dropFolder",
          "Do you want to copy '{0}' or add '{0}' as a folder to the workspace?",
          basename2(folders[0].uri)
        );
      } else {
        message = folders.length > 1 ? localize("copyfolders", "Are you sure to want to copy folders?") : localize(
          "copyfolder",
          "Are you sure to want to copy '{0}'?",
          basename2(folders[0].uri)
        );
      }
      const { result } = await this.dialogService.prompt({
        type: Severity.Info,
        message,
        buttons,
        cancelButton: true
      });
      if (result === ImportChoice.Add) {
        return this.workspaceEditingService.addFolders(folders);
      }
      if (result === ImportChoice.Copy) {
        return this.importResources(target, files, token);
      }
    } else if (target instanceof ExplorerItem) {
      return this.importResources(target, files, token);
    }
  }
  async importResources(target, resources, token) {
    if (resources && resources.length > 0) {
      const targetStat = await this.fileService.resolve(target.resource);
      if (token.isCancellationRequested) {
        return;
      }
      const targetNames = /* @__PURE__ */ new Set();
      const caseSensitive = this.fileService.hasCapability(target.resource, 1024);
      if (targetStat.children) {
        targetStat.children.forEach((child) => {
          targetNames.add(caseSensitive ? child.name : child.name.toLowerCase());
        });
      }
      let inaccessibleFileCount = 0;
      const resourcesFiltered = coalesce(await Promises.settled(resources.map(async (resource) => {
        const fileDoesNotExist = !await this.fileService.exists(resource);
        if (fileDoesNotExist) {
          inaccessibleFileCount++;
          return void 0;
        }
        if (targetNames.has(caseSensitive ? basename2(resource) : basename2(resource).toLowerCase())) {
          const confirmationResult = await this.dialogService.confirm(getFileOverwriteConfirm(basename2(resource)));
          if (!confirmationResult.confirmed) {
            return void 0;
          }
        }
        return resource;
      })));
      if (inaccessibleFileCount > 0) {
        this.notificationService.error(inaccessibleFileCount > 1 ? localize(
          "filesInaccessible",
          "Some or all of the dropped files could not be accessed for import."
        ) : localize("fileInaccessible", "The dropped file could not be accessed for import."));
      }
      const resourceFileEdits = resourcesFiltered.map((resource) => {
        const sourceFileName = basename2(resource);
        const targetFile = joinPath(target.resource, sourceFileName);
        return new ResourceFileEdit(resource, targetFile, { overwrite: true, copy: true });
      });
      const undoLevel = this.configurationService.getValue().explorer.confirmUndo;
      await this.explorerService.applyBulkEdit(resourceFileEdits, {
        undoLabel: resourcesFiltered.length === 1 ? localize(
          { comment: ["substitution will be the name of the file that was imported"], key: "importFile" },
          "Import {0}",
          basename2(resourcesFiltered[0])
        ) : localize(
          { comment: ["substitution will be the number of files that were imported"], key: "importnFile" },
          "Import {0} resources",
          resourcesFiltered.length
        ),
        progressLabel: resourcesFiltered.length === 1 ? localize(
          { comment: ["substitution will be the name of the file that was copied"], key: "copyingFile" },
          "Copying {0}",
          basename2(resourcesFiltered[0])
        ) : localize(
          { comment: ["substitution will be the number of files that were copied"], key: "copyingnFile" },
          "Copying {0} resources",
          resourcesFiltered.length
        ),
        progressLocation: 10,
        confirmBeforeUndo: undoLevel === "verbose" || undoLevel === "default"
      });
      if (resourceFileEdits.length === 1) {
        const item = this.explorerService.findClosest(resourceFileEdits[0].newResource);
        if (item && !item.isDirectory) {
          this.editorService.openEditor({ resource: item.resource, options: { pinned: true } });
        }
      }
    }
  }
};
ExternalFileImport = __decorate([
  __param(0, IFileService),
  __param(1, IHostService),
  __param(2, IWorkspaceContextService),
  __param(3, IConfigurationService),
  __param(4, IDialogService),
  __param(5, IWorkspaceEditingService),
  __param(6, IExplorerService),
  __param(7, IEditorService),
  __param(8, IProgressService),
  __param(9, INotificationService),
  __param(10, IInstantiationService)
], ExternalFileImport);
var _a31;
var FileDownload = (_a31 = class {
  constructor(fileService, explorerService, progressService, logService, fileDialogService, storageService) {
    this.fileService = fileService;
    this.explorerService = explorerService;
    this.progressService = progressService;
    this.logService = logService;
    this.fileDialogService = fileDialogService;
    this.storageService = storageService;
  }
  download(source) {
    const cts = new CancellationTokenSource();
    const downloadPromise = this.progressService.withProgress({
      location: 10,
      delay: 800,
      cancellable: isWeb,
      title: localize("downloadingFiles", "Downloading")
    }, async (progress) => this.doDownload(source, progress, cts), () => cts.dispose(true));
    this.progressService.withProgress({ location: VIEW_ID, delay: 500 }, () => downloadPromise);
    return downloadPromise;
  }
  async doDownload(sources, progress, cts) {
    for (const source of sources) {
      if (cts.token.isCancellationRequested) {
        return;
      }
      if (isWeb) {
        await this.doDownloadBrowser(source.resource, progress, cts);
      } else {
        await this.doDownloadNative(source, progress, cts);
      }
    }
  }
  async doDownloadBrowser(resource, progress, cts) {
    const stat = await this.fileService.resolve(resource, { resolveMetadata: true });
    if (cts.token.isCancellationRequested) {
      return;
    }
    const maxBlobDownloadSize = 32 * ByteSize.MB;
    const preferFileSystemAccessWebApis = stat.isDirectory || stat.size > maxBlobDownloadSize;
    if (preferFileSystemAccessWebApis && WebFileSystemAccess.supported(window)) {
      try {
        const parentFolder = await window.showDirectoryPicker();
        const operation = {
          startTime: Date.now(),
          progressScheduler: new RunOnceWorker((steps) => {
            progress.report(steps[steps.length - 1]);
          }, 1e3),
          filesTotal: stat.isDirectory ? 0 : 1,
          filesDownloaded: 0,
          totalBytesDownloaded: 0,
          fileBytesDownloaded: 0
        };
        if (stat.isDirectory) {
          const targetFolder = await parentFolder.getDirectoryHandle(stat.name, { create: true });
          await this.downloadFolderBrowser(stat, targetFolder, operation, cts.token);
        } else {
          await this.downloadFileBrowser(parentFolder, stat, operation, cts.token);
        }
        operation.progressScheduler.dispose();
      } catch (error) {
        this.logService.warn(error);
        cts.cancel();
      }
    } else if (stat.isFile) {
      let bufferOrUri;
      try {
        bufferOrUri = (await this.fileService.readFile(stat.resource, { limits: { size: maxBlobDownloadSize } }, cts.token)).value.buffer;
      } catch (error) {
        bufferOrUri = FileAccess.uriToBrowserUri(stat.resource);
      }
      if (!cts.token.isCancellationRequested) {
        triggerDownload(bufferOrUri, stat.name);
      }
    }
  }
  async downloadFileBufferedBrowser(resource, target, operation, token) {
    const contents = await this.fileService.readFileStream(resource, void 0, token);
    if (token.isCancellationRequested) {
      target.close();
      return;
    }
    return new Promise((resolve, reject) => {
      const sourceStream = contents.value;
      const disposables = new DisposableStore();
      disposables.add(toDisposable(() => target.close()));
      disposables.add(once(token.onCancellationRequested)(() => {
        disposables.dispose();
        reject(canceled());
      }));
      listenStream(sourceStream, {
        onData: (data) => {
          target.write(data.buffer);
          this.reportProgress(contents.name, contents.size, data.byteLength, operation);
        },
        onError: (error) => {
          disposables.dispose();
          reject(error);
        },
        onEnd: () => {
          disposables.dispose();
          resolve();
        }
      }, token);
    });
  }
  async downloadFileUnbufferedBrowser(resource, target, operation, token) {
    const contents = await this.fileService.readFile(resource, void 0, token);
    if (!token.isCancellationRequested) {
      target.write(contents.value.buffer);
      this.reportProgress(contents.name, contents.size, contents.value.byteLength, operation);
    }
    target.close();
  }
  async downloadFileBrowser(targetFolder, file, operation, token) {
    operation.filesDownloaded++;
    operation.fileBytesDownloaded = 0;
    this.reportProgress(file.name, 0, 0, operation);
    const targetFile = await targetFolder.getFileHandle(file.name, { create: true });
    const targetFileWriter = await targetFile.createWritable();
    if (file.size > ByteSize.MB) {
      return this.downloadFileBufferedBrowser(file.resource, targetFileWriter, operation, token);
    }
    return this.downloadFileUnbufferedBrowser(file.resource, targetFileWriter, operation, token);
  }
  async downloadFolderBrowser(folder, targetFolder, operation, token) {
    if (folder.children) {
      operation.filesTotal += folder.children.map((child) => child.isFile).length;
      for (const child of folder.children) {
        if (token.isCancellationRequested) {
          return;
        }
        if (child.isFile) {
          await this.downloadFileBrowser(targetFolder, child, operation, token);
        } else {
          const childFolder = await targetFolder.getDirectoryHandle(child.name, { create: true });
          const resolvedChildFolder = await this.fileService.resolve(child.resource, { resolveMetadata: true });
          await this.downloadFolderBrowser(resolvedChildFolder, childFolder, operation, token);
        }
      }
    }
  }
  reportProgress(name, fileSize, bytesDownloaded, operation) {
    operation.fileBytesDownloaded += bytesDownloaded;
    operation.totalBytesDownloaded += bytesDownloaded;
    const bytesDownloadedPerSecond = operation.totalBytesDownloaded / ((Date.now() - operation.startTime) / 1e3);
    let message;
    if (fileSize < ByteSize.MB) {
      if (operation.filesTotal === 1) {
        message = name;
      } else {
        message = localize(
          "downloadProgressSmallMany",
          "{0} of {1} files ({2}/s)",
          operation.filesDownloaded,
          operation.filesTotal,
          ByteSize.formatSize(bytesDownloadedPerSecond)
        );
      }
    } else {
      message = localize(
        "downloadProgressLarge",
        "{0} ({1} of {2}, {3}/s)",
        name,
        ByteSize.formatSize(operation.fileBytesDownloaded),
        ByteSize.formatSize(fileSize),
        ByteSize.formatSize(bytesDownloadedPerSecond)
      );
    }
    operation.progressScheduler.work({ message });
  }
  async doDownloadNative(explorerItem, progress, cts) {
    progress.report({ message: explorerItem.name });
    let defaultUri;
    const lastUsedDownloadPath = this.storageService.get(FileDownload_1.LAST_USED_DOWNLOAD_PATH_STORAGE_KEY, -1);
    if (lastUsedDownloadPath) {
      defaultUri = joinPath(URI.file(lastUsedDownloadPath), explorerItem.name);
    } else {
      defaultUri = joinPath(explorerItem.isDirectory ? await this.fileDialogService.defaultFolderPath(Schemas.file) : await this.fileDialogService.defaultFilePath(Schemas.file), explorerItem.name);
    }
    const destination = await this.fileDialogService.showSaveDialog({
      availableFileSystems: [Schemas.file],
      saveLabel: mnemonicButtonLabel(localize("downloadButton", "Download")),
      title: localize("chooseWhereToDownload", "Choose Where to Download"),
      defaultUri
    });
    if (destination) {
      this.storageService.store(FileDownload_1.LAST_USED_DOWNLOAD_PATH_STORAGE_KEY, dirname(destination).fsPath, -1, 1);
      await this.explorerService.applyBulkEdit([new ResourceFileEdit(explorerItem.resource, destination, { overwrite: true, copy: true })], {
        undoLabel: localize("downloadBulkEdit", "Download {0}", explorerItem.name),
        progressLabel: localize("downloadingBulkEdit", "Downloading {0}", explorerItem.name),
        progressLocation: 10
      });
    } else {
      cts.cancel();
    }
  }
}, FileDownload_1 = _a31, _a31.LAST_USED_DOWNLOAD_PATH_STORAGE_KEY = "workbench.explorer.downloadPath", _a31);
FileDownload = FileDownload_1 = __decorate([
  __param(0, IFileService),
  __param(1, IExplorerService),
  __param(2, IProgressService),
  __param(3, ILogService),
  __param(4, IFileDialogService),
  __param(5, IStorageService)
], FileDownload);
function getFileOverwriteConfirm(name) {
  return {
    message: localize(
      "confirmOverwrite",
      "A file or folder with the name '{0}' already exists in the destination folder. Do you want to replace it?",
      name
    ),
    detail: localize("irreversible", "This action is irreversible!"),
    primaryButton: localize(
      { key: "replaceButtonLabel", comment: ["&& denotes a mnemonic"] },
      "&&Replace"
    ),
    type: "warning"
  };
}
function getMultipleFilesOverwriteConfirm(files) {
  if (files.length > 1) {
    return {
      message: localize(
        "confirmManyOverwrites",
        "The following {0} files and/or folders already exist in the destination folder. Do you want to replace them?",
        files.length
      ),
      detail: getFileNamesMessage(files) + "\n" + localize("irreversible", "This action is irreversible!"),
      primaryButton: localize(
        { key: "replaceButtonLabel", comment: ["&& denotes a mnemonic"] },
        "&&Replace"
      ),
      type: "warning"
    };
  }
  return getFileOverwriteConfirm(basename2(files[0]));
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/fileActions.js
init_actions2();
init_keyCodes();
var NEW_FILE_COMMAND_ID = "explorer.newFile";
var NEW_FILE_LABEL = localize("newFile", "New File...");
var NEW_FOLDER_COMMAND_ID = "explorer.newFolder";
var NEW_FOLDER_LABEL = localize("newFolder", "New Folder...");
var TRIGGER_RENAME_LABEL = localize("rename", "Rename...");
var MOVE_FILE_TO_TRASH_LABEL = localize("delete", "Delete");
var COPY_FILE_LABEL = localize("copyFile", "Copy");
var PASTE_FILE_LABEL = localize("pasteFile", "Paste");
var FileCopiedContext = new RawContextKey("fileCopied", false);
var DOWNLOAD_COMMAND_ID = "explorer.download";
var DOWNLOAD_LABEL = localize("download", "Download...");
var UPLOAD_COMMAND_ID = "explorer.upload";
var UPLOAD_LABEL = localize("upload", "Upload...");
function onError(notificationService, error) {
  if (error.message === "string") {
    error = error.message;
  }
  notificationService.error(toErrorMessage(error, false));
}
async function refreshIfSeparator(value, explorerService) {
  if (value && (value.indexOf("/") >= 0 || value.indexOf("\\") >= 0)) {
    await explorerService.refresh();
  }
}
async function findValidPasteFileTarget(explorerService, fileService, dialogService, targetFolder, fileToPaste, incrementalNaming) {
  let name = basenameOrAuthority(fileToPaste.resource);
  let candidate = joinPath(targetFolder.resource, name);
  if (incrementalNaming === "disabled") {
    const canOverwrite = await askForOverwrite(fileService, dialogService, candidate);
    if (!canOverwrite) {
      return;
    }
  }
  while (!fileToPaste.allowOverwrite) {
    if (!explorerService.findClosest(candidate)) {
      break;
    }
    if (incrementalNaming !== "disabled") {
      name = incrementFileName(name, !!fileToPaste.isDirectory, incrementalNaming);
    }
    candidate = joinPath(targetFolder.resource, name);
  }
  return candidate;
}
function incrementFileName(name, isFolder, incrementalNaming) {
  if (incrementalNaming === "simple") {
    let namePrefix = name;
    let extSuffix = "";
    if (!isFolder) {
      extSuffix = extname(name);
      namePrefix = basename(name, extSuffix);
    }
    const suffixRegex = /^(.+ copy)( \d+)?$/;
    if (suffixRegex.test(namePrefix)) {
      return namePrefix.replace(suffixRegex, (match2, g1, g2) => {
        const number = g2 ? parseInt(g2) : 1;
        return number === 0 ? `${g1}` : number < 1073741824 ? `${g1} ${number + 1}` : `${g1}${g2} copy`;
      }) + extSuffix;
    }
    return `${namePrefix} copy${extSuffix}`;
  }
  const separators = "[\\.\\-_]";
  const maxNumber = 1073741824;
  const suffixFileRegex = RegExp("(.*" + separators + ")(\\d+)(\\..*)$");
  if (!isFolder && name.match(suffixFileRegex)) {
    return name.replace(suffixFileRegex, (match2, g1, g2, g3) => {
      const number = parseInt(g2);
      return number < maxNumber ? g1 + String(number + 1).padStart(g2.length, "0") + g3 : `${g1}${g2}.1${g3}`;
    });
  }
  const prefixFileRegex = RegExp("(\\d+)(" + separators + ".*)(\\..*)$");
  if (!isFolder && name.match(prefixFileRegex)) {
    return name.replace(prefixFileRegex, (match2, g1, g2, g3) => {
      const number = parseInt(g1);
      return number < maxNumber ? String(number + 1).padStart(g1.length, "0") + g2 + g3 : `${g1}${g2}.1${g3}`;
    });
  }
  const prefixFileNoNameRegex = RegExp("(\\d+)(\\..*)$");
  if (!isFolder && name.match(prefixFileNoNameRegex)) {
    return name.replace(prefixFileNoNameRegex, (match2, g1, g2) => {
      const number = parseInt(g1);
      return number < maxNumber ? String(number + 1).padStart(g1.length, "0") + g2 : `${g1}.1${g2}`;
    });
  }
  const lastIndexOfDot = name.lastIndexOf(".");
  if (!isFolder && lastIndexOfDot >= 0) {
    return `${name.substr(0, lastIndexOfDot)}.1${name.substr(lastIndexOfDot)}`;
  }
  const noNameNoExtensionRegex = RegExp("(\\d+)$");
  if (!isFolder && lastIndexOfDot === -1 && name.match(noNameNoExtensionRegex)) {
    return name.replace(noNameNoExtensionRegex, (match2, g1) => {
      const number = parseInt(g1);
      return number < maxNumber ? String(number + 1).padStart(g1.length, "0") : `${g1}.1`;
    });
  }
  const noExtensionRegex = RegExp("(.*)(\\d*)$");
  if (!isFolder && lastIndexOfDot === -1 && name.match(noExtensionRegex)) {
    return name.replace(noExtensionRegex, (match2, g1, g2) => {
      let number = parseInt(g2);
      if (isNaN(number)) {
        number = 0;
      }
      return number < maxNumber ? g1 + String(number + 1).padStart(g2.length, "0") : `${g1}${g2}.1`;
    });
  }
  if (isFolder && name.match(/(\d+)$/)) {
    return name.replace(/(\d+)$/, (match2, ...groups) => {
      const number = parseInt(groups[0]);
      return number < maxNumber ? String(number + 1).padStart(groups[0].length, "0") : `${groups[0]}.1`;
    });
  }
  if (isFolder && name.match(/^(\d+)/)) {
    return name.replace(/^(\d+)(.*)$/, (match2, ...groups) => {
      const number = parseInt(groups[0]);
      return number < maxNumber ? String(number + 1).padStart(groups[0].length, "0") + groups[1] : `${groups[0]}${groups[1]}.1`;
    });
  }
  return `${name}.1`;
}
async function askForOverwrite(fileService, dialogService, targetResource) {
  const exists = await fileService.exists(targetResource);
  if (!exists) {
    return true;
  }
  const { confirmed } = await dialogService.confirm({
    type: Severity.Warning,
    message: localize(
      "confirmOverwrite",
      "A file or folder with the name '{0}' already exists in the destination folder. Do you want to replace it?",
      basename(targetResource.path)
    ),
    primaryButton: localize("replaceButtonLabel", "&&Replace")
  });
  return confirmed;
}
var _GlobalCompareResourcesAction = class _GlobalCompareResourcesAction extends Action2 {
  constructor() {
    super({
      id: _GlobalCompareResourcesAction.ID,
      title: { value: _GlobalCompareResourcesAction.LABEL, original: "Compare Active File With..." },
      f1: true,
      category: Categories.File,
      precondition: ActiveEditorContext
    });
  }
  async run(accessor) {
    const editorService = accessor.get(IEditorService);
    const textModelService = accessor.get(ITextModelService);
    const quickInputService = accessor.get(IQuickInputService);
    const activeInput = editorService.activeEditor;
    const activeResource = EditorResourceAccessor.getOriginalUri(activeInput);
    if (activeResource && textModelService.canHandleResource(activeResource)) {
      const picks = await quickInputService.quickAccess.pick("", { itemActivation: ItemActivation.SECOND });
      if ((picks == null ? void 0 : picks.length) === 1) {
        const resource = picks[0].resource;
        if (URI.isUri(resource) && textModelService.canHandleResource(resource)) {
          editorService.openEditor({
            original: { resource: activeResource },
            modified: { resource },
            options: { pinned: true }
          });
        }
      }
    }
  }
};
_GlobalCompareResourcesAction.ID = "workbench.files.action.compareFileWith";
_GlobalCompareResourcesAction.LABEL = localize("globalCompareFile", "Compare Active File With...");
var GlobalCompareResourcesAction = _GlobalCompareResourcesAction;
var _ToggleAutoSaveAction = class _ToggleAutoSaveAction extends Action2 {
  constructor() {
    super({
      id: _ToggleAutoSaveAction.ID,
      title: { value: _ToggleAutoSaveAction.LABEL, original: "Toggle Auto Save" },
      f1: true,
      category: Categories.File
    });
  }
  run(accessor) {
    const filesConfigurationService = accessor.get(IFilesConfigurationService);
    return filesConfigurationService.toggleAutoSave();
  }
};
_ToggleAutoSaveAction.ID = "workbench.action.toggleAutoSave";
_ToggleAutoSaveAction.LABEL = localize("toggleAutoSave", "Toggle Auto Save");
var ToggleAutoSaveAction = _ToggleAutoSaveAction;
var BaseSaveAllAction = class BaseSaveAllAction2 extends Action {
  constructor(id, label, commandService, notificationService, workingCopyService) {
    super(id, label);
    this.commandService = commandService;
    this.notificationService = notificationService;
    this.workingCopyService = workingCopyService;
    this.lastDirtyState = this.workingCopyService.hasDirty;
    this.enabled = this.lastDirtyState;
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.workingCopyService.onDidChangeDirty((workingCopy) => this.updateEnablement(workingCopy)));
  }
  updateEnablement(workingCopy) {
    const hasDirty = workingCopy.isDirty() || this.workingCopyService.hasDirty;
    if (this.lastDirtyState !== hasDirty) {
      this.enabled = hasDirty;
      this.lastDirtyState = this.enabled;
    }
  }
  async run(context) {
    try {
      await this.doRun(context);
    } catch (error) {
      onError(this.notificationService, error);
    }
  }
};
BaseSaveAllAction = __decorate([
  __param(2, ICommandService),
  __param(3, INotificationService),
  __param(4, IWorkingCopyService)
], BaseSaveAllAction);
var _SaveAllInGroupAction = class _SaveAllInGroupAction extends BaseSaveAllAction {
  get class() {
    return "explorer-action " + ThemeIcon.asClassName(Codicon.saveAll);
  }
  doRun(context) {
    return this.commandService.executeCommand(SAVE_ALL_IN_GROUP_COMMAND_ID, {}, context);
  }
};
_SaveAllInGroupAction.ID = "workbench.files.action.saveAllInGroup";
_SaveAllInGroupAction.LABEL = localize("saveAllInGroup", "Save All in Group");
var SaveAllInGroupAction = _SaveAllInGroupAction;
var _a32;
var CloseGroupAction = (_a32 = class extends Action {
  constructor(id, label, commandService) {
    super(id, label, ThemeIcon.asClassName(Codicon.closeAll));
    this.commandService = commandService;
  }
  run(context) {
    return this.commandService.executeCommand(CLOSE_EDITORS_AND_GROUP_COMMAND_ID, {}, context);
  }
}, _a32.ID = "workbench.files.action.closeGroup", _a32.LABEL = localize("closeGroup", "Close Group"), _a32);
CloseGroupAction = __decorate([
  __param(2, ICommandService)
], CloseGroupAction);
var _FocusFilesExplorer = class _FocusFilesExplorer extends Action2 {
  constructor() {
    super({
      id: _FocusFilesExplorer.ID,
      title: { value: _FocusFilesExplorer.LABEL, original: "Focus on Files Explorer" },
      f1: true,
      category: Categories.File
    });
  }
  async run(accessor) {
    const paneCompositeService = accessor.get(IPaneCompositePartService);
    await paneCompositeService.openPaneComposite(VIEWLET_ID, 0, true);
  }
};
_FocusFilesExplorer.ID = "workbench.files.action.focusFilesExplorer";
_FocusFilesExplorer.LABEL = localize("focusFilesExplorer", "Focus on Files Explorer");
var FocusFilesExplorer = _FocusFilesExplorer;
var _ShowActiveFileInExplorer = class _ShowActiveFileInExplorer extends Action2 {
  constructor() {
    super({
      id: _ShowActiveFileInExplorer.ID,
      title: { value: _ShowActiveFileInExplorer.LABEL, original: "Reveal Active File in Explorer View" },
      f1: true,
      category: Categories.File
    });
  }
  async run(accessor) {
    const commandService = accessor.get(ICommandService);
    const editorService = accessor.get(IEditorService);
    const resource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
    if (resource) {
      commandService.executeCommand(REVEAL_IN_EXPLORER_COMMAND_ID, resource);
    }
  }
};
_ShowActiveFileInExplorer.ID = "workbench.files.action.showActiveFileInExplorer";
_ShowActiveFileInExplorer.LABEL = localize("showInExplorer", "Reveal Active File in Explorer View");
var ShowActiveFileInExplorer = _ShowActiveFileInExplorer;
var _ShowOpenedFileInNewWindow = class _ShowOpenedFileInNewWindow extends Action2 {
  constructor() {
    super({
      id: _ShowOpenedFileInNewWindow.ID,
      title: { value: _ShowOpenedFileInNewWindow.LABEL, original: "Open Active File in New Window" },
      f1: true,
      category: Categories.File,
      keybinding: { primary: KeyChord(2048 | 41, 45), weight: 200 },
      precondition: EmptyWorkspaceSupportContext
    });
  }
  async run(accessor) {
    const editorService = accessor.get(IEditorService);
    const hostService = accessor.get(IHostService);
    const dialogService = accessor.get(IDialogService);
    const fileService = accessor.get(IFileService);
    const fileResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
    if (fileResource) {
      if (fileService.hasProvider(fileResource)) {
        hostService.openWindow([{ fileUri: fileResource }], { forceNewWindow: true });
      } else {
        dialogService.error(localize(
          "openFileToShowInNewWindow.unsupportedschema",
          "The active editor must contain an openable resource."
        ));
      }
    }
  }
};
_ShowOpenedFileInNewWindow.ID = "workbench.action.files.showOpenedFileInNewWindow";
_ShowOpenedFileInNewWindow.LABEL = localize("openFileInNewWindow", "Open Active File in New Window");
var ShowOpenedFileInNewWindow = _ShowOpenedFileInNewWindow;
function validateFileName(pathService, item, name, os) {
  name = getWellFormedFileName(name);
  if (!name || name.length === 0 || /^\s+$/.test(name)) {
    return {
      content: localize("emptyFileNameError", "A file or folder name must be provided."),
      severity: Severity.Error
    };
  }
  if (name[0] === "/" || name[0] === "\\") {
    return {
      content: localize(
        "fileNameStartsWithSlashError",
        "A file or folder name cannot start with a slash."
      ),
      severity: Severity.Error
    };
  }
  const names = coalesce(name.split(/[\\/]/));
  const parent = item.parent;
  if (name !== item.name) {
    const child = parent == null ? void 0 : parent.getChild(name);
    if (child && child !== item) {
      return {
        content: localize(
          "fileNameExistsError",
          "A file or folder **{0}** already exists at this location. Please choose a different name.",
          name
        ),
        severity: Severity.Error
      };
    }
  }
  if (names.some((folderName) => !pathService.hasValidBasename(item.resource, os, folderName))) {
    const escapedName = name.replace(/\*/g, "\\*");
    return {
      content: localize(
        "invalidFileNameError",
        "The name **{0}** is not valid as a file or folder name. Please choose a different name.",
        trimLongName(escapedName)
      ),
      severity: Severity.Error
    };
  }
  if (names.some((name2) => /^\s|\s$/.test(name2))) {
    return {
      content: localize(
        "fileNameWhitespaceWarning",
        "Leading or trailing whitespace detected in file or folder name."
      ),
      severity: Severity.Warning
    };
  }
  return null;
}
function trimLongName(name) {
  if ((name == null ? void 0 : name.length) > 255) {
    return `${name.substr(0, 255)}...`;
  }
  return name;
}
function getWellFormedFileName(filename) {
  if (!filename) {
    return filename;
  }
  filename = trim(filename, "	");
  filename = rtrim(filename, "/");
  filename = rtrim(filename, "\\");
  return filename;
}
var _CompareNewUntitledTextFilesAction = class _CompareNewUntitledTextFilesAction extends Action2 {
  constructor() {
    super({
      id: _CompareNewUntitledTextFilesAction.ID,
      title: { value: _CompareNewUntitledTextFilesAction.LABEL, original: "Compare New Untitled Text Files" },
      f1: true,
      category: Categories.File
    });
  }
  async run(accessor) {
    const editorService = accessor.get(IEditorService);
    await editorService.openEditor({
      original: { resource: void 0 },
      modified: { resource: void 0 },
      options: { pinned: true }
    });
  }
};
_CompareNewUntitledTextFilesAction.ID = "workbench.files.action.compareNewUntitledTextFiles";
_CompareNewUntitledTextFilesAction.LABEL = localize("compareNewUntitledTextFiles", "Compare New Untitled Text Files");
var CompareNewUntitledTextFilesAction = _CompareNewUntitledTextFilesAction;
var _CompareWithClipboardAction = class _CompareWithClipboardAction extends Action2 {
  constructor() {
    super({
      id: _CompareWithClipboardAction.ID,
      title: { value: _CompareWithClipboardAction.LABEL, original: "Compare Active File with Clipboard" },
      f1: true,
      category: Categories.File,
      keybinding: { primary: KeyChord(2048 | 41, 33), weight: 200 }
    });
  }
  async run(accessor) {
    const editorService = accessor.get(IEditorService);
    const instantiationService = accessor.get(IInstantiationService);
    const textModelService = accessor.get(ITextModelService);
    const fileService = accessor.get(IFileService);
    const resource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
    const scheme = `clipboardCompare${_CompareWithClipboardAction.SCHEME_COUNTER++}`;
    if (resource && (fileService.hasProvider(resource) || resource.scheme === Schemas.untitled)) {
      if (!this.registrationDisposal) {
        const provider = instantiationService.createInstance(ClipboardContentProvider);
        this.registrationDisposal = textModelService.registerTextModelContentProvider(scheme, provider);
      }
      const name = basename2(resource);
      const editorLabel = localize("clipboardComparisonLabel", "Clipboard  {0}", name);
      await editorService.openEditor({
        original: { resource: resource.with({ scheme }) },
        modified: { resource },
        label: editorLabel,
        options: { pinned: true }
      }).finally(() => {
        dispose(this.registrationDisposal);
        this.registrationDisposal = void 0;
      });
    }
  }
  dispose() {
    dispose(this.registrationDisposal);
    this.registrationDisposal = void 0;
  }
};
_CompareWithClipboardAction.ID = "workbench.files.action.compareWithClipboard";
_CompareWithClipboardAction.LABEL = localize("compareWithClipboard", "Compare Active File with Clipboard");
_CompareWithClipboardAction.SCHEME_COUNTER = 0;
var CompareWithClipboardAction = _CompareWithClipboardAction;
var ClipboardContentProvider = class ClipboardContentProvider2 {
  constructor(clipboardService, languageService, modelService) {
    this.clipboardService = clipboardService;
    this.languageService = languageService;
    this.modelService = modelService;
  }
  async provideTextContent(resource) {
    const text = await this.clipboardService.readText();
    const model = this.modelService.createModel(text, this.languageService.createByFilepathOrFirstLine(resource), resource);
    return model;
  }
};
ClipboardContentProvider = __decorate([
  __param(0, IClipboardService),
  __param(1, ILanguageService),
  __param(2, IModelService)
], ClipboardContentProvider);
function onErrorWithRetry(notificationService, error, retry) {
  notificationService.prompt(Severity.Error, toErrorMessage(error, false), [{
    label: localize("retry", "Retry"),
    run: () => retry()
  }]);
}
async function openExplorerAndCreate(accessor, isFolder) {
  var _a43;
  const explorerService = accessor.get(IExplorerService);
  const fileService = accessor.get(IFileService);
  const configService = accessor.get(IConfigurationService);
  const filesConfigService = accessor.get(IFilesConfigurationService);
  const editorService = accessor.get(IEditorService);
  const viewsService = accessor.get(IViewsService);
  const notificationService = accessor.get(INotificationService);
  const remoteAgentService = accessor.get(IRemoteAgentService);
  const commandService = accessor.get(ICommandService);
  const pathService = accessor.get(IPathService);
  const wasHidden = !viewsService.isViewVisible(VIEW_ID);
  const view = await viewsService.openView(VIEW_ID, true);
  if (wasHidden) {
    await timeout(500);
  }
  if (!view) {
    if (isFolder) {
      throw new Error("Open a folder or workspace first.");
    }
    return commandService.executeCommand(NEW_UNTITLED_FILE_COMMAND_ID);
  }
  const stats = explorerService.getContext(false);
  const stat = stats.length > 0 ? stats[0] : void 0;
  let folder;
  if (stat) {
    folder = stat.isDirectory ? stat : stat.parent || explorerService.roots[0];
  } else {
    folder = explorerService.roots[0];
  }
  if (folder.isReadonly) {
    throw new Error("Parent folder is readonly.");
  }
  const newStat = new NewExplorerItem(fileService, configService, filesConfigService, folder, isFolder);
  folder.addChild(newStat);
  const onSuccess = async (value) => {
    try {
      const resourceToCreate = joinPath(folder.resource, value);
      if (value.endsWith("/")) {
        isFolder = true;
      }
      await explorerService.applyBulkEdit([new ResourceFileEdit(void 0, resourceToCreate, { folder: isFolder })], {
        undoLabel: localize("createBulkEdit", "Create {0}", value),
        progressLabel: localize("creatingBulkEdit", "Creating {0}", value),
        confirmBeforeUndo: true
      });
      await refreshIfSeparator(value, explorerService);
      if (isFolder) {
        await explorerService.select(resourceToCreate, true);
      } else {
        await editorService.openEditor({ resource: resourceToCreate, options: { pinned: true } });
      }
    } catch (error) {
      onErrorWithRetry(notificationService, error, () => onSuccess(value));
    }
  };
  const os = ((_a43 = await remoteAgentService.getEnvironment()) == null ? void 0 : _a43.os) ?? OS;
  await explorerService.setEditable(newStat, {
    validationMessage: (value) => validateFileName(pathService, newStat, value, os),
    onFinish: async (value, success) => {
      folder.removeChild(newStat);
      await explorerService.setEditable(newStat, null);
      if (success) {
        onSuccess(value);
      }
    }
  });
}
CommandsRegistry.registerCommand({
  id: NEW_FILE_COMMAND_ID,
  handler: async (accessor) => {
    await openExplorerAndCreate(accessor, false);
  }
});
CommandsRegistry.registerCommand({
  id: NEW_FOLDER_COMMAND_ID,
  handler: async (accessor) => {
    await openExplorerAndCreate(accessor, true);
  }
});
var downloadFileHandler = async (accessor) => {
  const explorerService = accessor.get(IExplorerService);
  const notificationService = accessor.get(INotificationService);
  const instantiationService = accessor.get(IInstantiationService);
  const context = explorerService.getContext(true);
  const explorerItems = context.length ? context : explorerService.roots;
  const downloadHandler = instantiationService.createInstance(FileDownload);
  try {
    await downloadHandler.download(explorerItems);
  } catch (error) {
    notificationService.error(error);
    throw error;
  }
};
CommandsRegistry.registerCommand({
  id: DOWNLOAD_COMMAND_ID,
  handler: downloadFileHandler
});
var uploadFileHandler = async (accessor) => {
  const explorerService = accessor.get(IExplorerService);
  const notificationService = accessor.get(INotificationService);
  const instantiationService = accessor.get(IInstantiationService);
  const context = explorerService.getContext(true);
  const element = context.length ? context[0] : explorerService.roots[0];
  try {
    const files = await triggerUpload();
    if (files) {
      const browserUpload = instantiationService.createInstance(BrowserFileUpload);
      await browserUpload.upload(element, files);
    }
  } catch (error) {
    notificationService.error(error);
    throw error;
  }
};
CommandsRegistry.registerCommand({
  id: UPLOAD_COMMAND_ID,
  handler: uploadFileHandler
});
var BaseSetActiveEditorReadonlyInSession = class extends Action2 {
  constructor(id, title, newReadonlyState) {
    super({
      id,
      title,
      f1: true,
      category: Categories.File,
      precondition: ActiveEditorCanToggleReadonlyContext
    });
    this.newReadonlyState = newReadonlyState;
  }
  async run(accessor) {
    const editorService = accessor.get(IEditorService);
    const filesConfigurationService = accessor.get(IFilesConfigurationService);
    const fileResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
    if (!fileResource) {
      return;
    }
    await filesConfigurationService.updateReadonly(fileResource, this.newReadonlyState);
  }
};
var _SetActiveEditorReadonlyInSession = class _SetActiveEditorReadonlyInSession extends BaseSetActiveEditorReadonlyInSession {
  constructor() {
    super(_SetActiveEditorReadonlyInSession.ID, { value: _SetActiveEditorReadonlyInSession.LABEL, original: "Set Active Editor Readonly in Session" }, true);
  }
};
_SetActiveEditorReadonlyInSession.ID = "workbench.action.files.setActiveEditorReadonlyInSession";
_SetActiveEditorReadonlyInSession.LABEL = localize(
  "setActiveEditorReadonlyInSession",
  "Set Active Editor Read-only in Session"
);
var SetActiveEditorReadonlyInSession = _SetActiveEditorReadonlyInSession;
var _SetActiveEditorWriteableInSession = class _SetActiveEditorWriteableInSession extends BaseSetActiveEditorReadonlyInSession {
  constructor() {
    super(_SetActiveEditorWriteableInSession.ID, { value: _SetActiveEditorWriteableInSession.LABEL, original: "Set Active Editor Writeable in Session" }, false);
  }
};
_SetActiveEditorWriteableInSession.ID = "workbench.action.files.setActiveEditorWriteableInSession";
_SetActiveEditorWriteableInSession.LABEL = localize(
  "setActiveEditorWriteableInSession",
  "Set Active Editor Writeable in Session"
);
var SetActiveEditorWriteableInSession = _SetActiveEditorWriteableInSession;
var _ToggleActiveEditorReadonlyInSession = class _ToggleActiveEditorReadonlyInSession extends BaseSetActiveEditorReadonlyInSession {
  constructor() {
    super(_ToggleActiveEditorReadonlyInSession.ID, { value: _ToggleActiveEditorReadonlyInSession.LABEL, original: "Toggle Active Editor Readonly in Session" }, "toggle");
  }
};
_ToggleActiveEditorReadonlyInSession.ID = "workbench.action.files.toggleActiveEditorReadonlyInSession";
_ToggleActiveEditorReadonlyInSession.LABEL = localize(
  "toggleActiveEditorReadonlyInSession",
  "Toggle Active Editor Read-only in Session"
);
var ToggleActiveEditorReadonlyInSession = _ToggleActiveEditorReadonlyInSession;
var _ResetActiveEditorReadonlyInSession = class _ResetActiveEditorReadonlyInSession extends BaseSetActiveEditorReadonlyInSession {
  constructor() {
    super(_ResetActiveEditorReadonlyInSession.ID, { value: _ResetActiveEditorReadonlyInSession.LABEL, original: "Reset Active Editor Readonly in Session" }, "reset");
  }
};
_ResetActiveEditorReadonlyInSession.ID = "workbench.action.files.resetActiveEditorReadonlyInSession";
_ResetActiveEditorReadonlyInSession.LABEL = localize(
  "resetActiveEditorReadonlyInSession",
  "Reset Active Editor Read-only in Session"
);
var ResetActiveEditorReadonlyInSession = _ResetActiveEditorReadonlyInSession;

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerView.js
init_dom();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerDecorationsProvider.js
init_tslib_es6();
init_event();
init_nls();
init_colorRegistry();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerViewer.js
init_tslib_es6();
init_dom();
init_progress();
init_files();
init_lifecycle();
init_themeService();
init_configuration();
init_resources();
init_nls();
init_functional();
init_objects();
init_path();

// node_modules/vscode/vscode/src/vs/workbench/browser/dnd.js
init_tslib_es6();
init_dom();
init_arrays();
init_event();
init_lifecycle();
init_mime();
init_network();
init_platform();
init_resources();
init_uri();
init_files();
init_instantiation();
init_opener();
init_platform2();
var ResourcesDropHandler = class ResourcesDropHandler2 {
  constructor(options, fileService, workspacesService, editorService, workspaceEditingService, hostService, contextService, instantiationService) {
    this.options = options;
    this.fileService = fileService;
    this.workspacesService = workspacesService;
    this.editorService = editorService;
    this.workspaceEditingService = workspaceEditingService;
    this.hostService = hostService;
    this.contextService = contextService;
    this.instantiationService = instantiationService;
  }
  async handleDrop(event, resolveTargetGroup, afterDrop, targetIndex) {
    const editors = await this.instantiationService.invokeFunction((accessor) => extractEditorsAndFilesDropData(accessor, event));
    if (!editors.length) {
      return;
    }
    await this.hostService.focus();
    if (this.options.allowWorkspaceOpen) {
      const localFilesAllowedToOpenAsWorkspace = coalesce(editors.filter((editor) => {
        var _a43;
        return editor.allowWorkspaceOpen && ((_a43 = editor.resource) == null ? void 0 : _a43.scheme) === Schemas.file;
      }).map((editor) => editor.resource));
      if (localFilesAllowedToOpenAsWorkspace.length > 0) {
        const isWorkspaceOpening = await this.handleWorkspaceDrop(localFilesAllowedToOpenAsWorkspace);
        if (isWorkspaceOpening) {
          return;
        }
      }
    }
    const externalLocalFiles = coalesce(editors.filter((editor) => {
      var _a43;
      return editor.isExternal && ((_a43 = editor.resource) == null ? void 0 : _a43.scheme) === Schemas.file;
    }).map((editor) => editor.resource));
    if (externalLocalFiles.length) {
      this.workspacesService.addRecentlyOpened(externalLocalFiles.map((resource) => ({ fileUri: resource })));
    }
    const targetGroup = resolveTargetGroup();
    await this.editorService.openEditors(editors.map((editor) => ({
      ...editor,
      resource: editor.resource,
      options: {
        ...editor.options,
        pinned: true,
        index: targetIndex
      }
    })), targetGroup, { validateTrust: true });
    afterDrop(targetGroup);
  }
  async handleWorkspaceDrop(resources) {
    const toOpen = [];
    const folderURIs = [];
    await Promise.all(resources.map(async (resource) => {
      if (hasWorkspaceFileExtension(resource)) {
        toOpen.push({ workspaceUri: resource });
        return;
      }
      try {
        const stat = await this.fileService.stat(resource);
        if (stat.isDirectory) {
          toOpen.push({ folderUri: stat.resource });
          folderURIs.push({ uri: stat.resource });
        }
      } catch (error) {
      }
    }));
    if (toOpen.length === 0) {
      return false;
    }
    this.hostService.focus();
    if (toOpen.length > folderURIs.length || folderURIs.length === 1) {
      await this.hostService.openWindow(toOpen);
    } else if (isTemporaryWorkspace(this.contextService.getWorkspace())) {
      await this.workspaceEditingService.addFolders(folderURIs);
    } else {
      await this.workspaceEditingService.createAndEnterWorkspace(folderURIs);
    }
    return true;
  }
};
ResourcesDropHandler = __decorate([
  __param(1, IFileService),
  __param(2, IWorkspacesService),
  __param(3, IEditorService),
  __param(4, IWorkspaceEditingService),
  __param(5, IHostService),
  __param(6, IWorkspaceContextService),
  __param(7, IInstantiationService)
], ResourcesDropHandler);
function fillEditorsDragData(accessor, resourcesOrEditors, event) {
  var _a43;
  if (resourcesOrEditors.length === 0 || !event.dataTransfer) {
    return;
  }
  const textFileService = accessor.get(ITextFileService);
  const editorService = accessor.get(IEditorService);
  const fileService = accessor.get(IFileService);
  const labelService = accessor.get(ILabelService);
  const resources = coalesce(resourcesOrEditors.map((resourceOrEditor) => {
    if (URI.isUri(resourceOrEditor)) {
      return { resource: resourceOrEditor };
    }
    if (isEditorIdentifier(resourceOrEditor)) {
      if (URI.isUri(resourceOrEditor.editor.resource)) {
        return { resource: resourceOrEditor.editor.resource };
      }
      return void 0;
    }
    return resourceOrEditor;
  }));
  const fileSystemResources = resources.filter(({ resource }) => fileService.hasProvider(resource));
  const lineDelimiter = isWindows ? "\r\n" : "\n";
  event.dataTransfer.setData(DataTransfers.TEXT, fileSystemResources.map(({ resource }) => labelService.getUriLabel(resource, { noPrefix: true })).join(lineDelimiter));
  const firstFile = fileSystemResources.find(({ isDirectory }) => !isDirectory);
  if (firstFile) {
    const firstFileUri = FileAccess.uriToFileUri(firstFile.resource);
    if (firstFileUri.scheme === Schemas.file) {
      event.dataTransfer.setData(DataTransfers.DOWNLOAD_URL, [Mimes.binary, basename2(firstFile.resource), firstFileUri.toString()].join(":"));
    }
  }
  const files = fileSystemResources.filter(({ isDirectory }) => !isDirectory);
  if (files.length) {
    event.dataTransfer.setData(DataTransfers.RESOURCES, JSON.stringify(files.map(({ resource }) => resource.toString())));
  }
  const contributions = Registry.as(Extensions4.DragAndDropContribution).getAll();
  for (const contribution of contributions) {
    contribution.setData(resources, event);
  }
  const draggedEditors = [];
  for (const resourceOrEditor of resourcesOrEditors) {
    let editor = void 0;
    if (isEditorIdentifier(resourceOrEditor)) {
      const untypedEditor = resourceOrEditor.editor.toUntyped({ preserveViewState: resourceOrEditor.groupId });
      if (untypedEditor) {
        editor = { ...untypedEditor, resource: EditorResourceAccessor.getCanonicalUri(untypedEditor) };
      }
    } else if (URI.isUri(resourceOrEditor)) {
      const { selection, uri } = extractSelection(resourceOrEditor);
      editor = { resource: uri, options: selection ? { selection } : void 0 };
    } else if (!resourceOrEditor.isDirectory) {
      editor = { resource: resourceOrEditor.resource };
    }
    if (!editor) {
      continue;
    }
    {
      const resource = editor.resource;
      if (resource) {
        const textFileModel = textFileService.files.get(resource);
        if (textFileModel) {
          if (typeof editor.languageId !== "string") {
            editor.languageId = textFileModel.getLanguageId();
          }
          if (typeof editor.encoding !== "string") {
            editor.encoding = textFileModel.getEncoding();
          }
          if (typeof editor.contents !== "string" && textFileModel.isDirty()) {
            editor.contents = textFileModel.textEditorModel.getValue();
          }
        }
        if (!((_a43 = editor.options) == null ? void 0 : _a43.viewState)) {
          editor.options = {
            ...editor.options,
            viewState: (() => {
              for (const visibleEditorPane of editorService.visibleEditorPanes) {
                if (isEqual2(visibleEditorPane.input.resource, resource)) {
                  const viewState = visibleEditorPane.getViewState();
                  if (viewState) {
                    return viewState;
                  }
                }
              }
              return void 0;
            })()
          };
        }
      }
    }
    draggedEditors.push(editor);
  }
  if (draggedEditors.length) {
    event.dataTransfer.setData(CodeDataTransfers.EDITORS, stringify(draggedEditors));
    const uriListEntries = [];
    for (const editor of draggedEditors) {
      if (editor.resource) {
        uriListEntries.push(editor.resource);
      } else if (isResourceDiffEditorInput(editor)) {
        if (editor.modified.resource) {
          uriListEntries.push(editor.modified.resource);
        }
      } else if (isResourceSideBySideEditorInput(editor)) {
        if (editor.primary.resource) {
          uriListEntries.push(editor.primary.resource);
        }
      } else if (isResourceMergeEditorInput(editor)) {
        uriListEntries.push(editor.result.resource);
      }
    }
    event.dataTransfer.setData(Mimes.uriList, UriList.create(uriListEntries.slice(0, 1)));
    event.dataTransfer.setData(DataTransfers.INTERNAL_URI_LIST, UriList.create(uriListEntries));
  }
}
var CompositeDragAndDropData = class {
  constructor(type, id) {
    this.type = type;
    this.id = id;
  }
  update(dataTransfer) {
  }
  getData() {
    return { type: this.type, id: this.id };
  }
};
var DraggedCompositeIdentifier = class {
  constructor(compositeId) {
    this.compositeId = compositeId;
  }
  get id() {
    return this.compositeId;
  }
};
var DraggedViewIdentifier = class {
  constructor(viewId) {
    this.viewId = viewId;
  }
  get id() {
    return this.viewId;
  }
};
var CompositeDragAndDropObserver = class _CompositeDragAndDropObserver extends Disposable {
  static get INSTANCE() {
    if (!_CompositeDragAndDropObserver.instance) {
      _CompositeDragAndDropObserver.instance = new _CompositeDragAndDropObserver();
      markAsSingleton(_CompositeDragAndDropObserver.instance);
    }
    return _CompositeDragAndDropObserver.instance;
  }
  constructor() {
    super();
    this.transferData = LocalSelectionTransfer.getInstance();
    this.onDragStart = this._register(new Emitter());
    this.onDragEnd = this._register(new Emitter());
    this._register(this.onDragEnd.event((e) => {
      const id = e.dragAndDropData.getData().id;
      const type = e.dragAndDropData.getData().type;
      const data = this.readDragData(type);
      if ((data == null ? void 0 : data.getData().id) === id) {
        this.transferData.clearData(type === "view" ? DraggedViewIdentifier.prototype : DraggedCompositeIdentifier.prototype);
      }
    }));
  }
  readDragData(type) {
    if (this.transferData.hasData(type === "view" ? DraggedViewIdentifier.prototype : DraggedCompositeIdentifier.prototype)) {
      const data = this.transferData.getData(type === "view" ? DraggedViewIdentifier.prototype : DraggedCompositeIdentifier.prototype);
      if (data && data[0]) {
        return new CompositeDragAndDropData(type, data[0].id);
      }
    }
    return void 0;
  }
  writeDragData(id, type) {
    this.transferData.setData([type === "view" ? new DraggedViewIdentifier(id) : new DraggedCompositeIdentifier(id)], type === "view" ? DraggedViewIdentifier.prototype : DraggedCompositeIdentifier.prototype);
  }
  registerTarget(element, callbacks) {
    const disposableStore = new DisposableStore();
    disposableStore.add(new DragAndDropObserver(element, {
      onDragEnd: (e) => {
      },
      onDragEnter: (e) => {
        e.preventDefault();
        if (callbacks.onDragEnter) {
          const data = this.readDragData("composite") || this.readDragData("view");
          if (data) {
            callbacks.onDragEnter({ eventData: e, dragAndDropData: data });
          }
        }
      },
      onDragLeave: (e) => {
        const data = this.readDragData("composite") || this.readDragData("view");
        if (callbacks.onDragLeave && data) {
          callbacks.onDragLeave({ eventData: e, dragAndDropData: data });
        }
      },
      onDrop: (e) => {
        if (callbacks.onDrop) {
          const data = this.readDragData("composite") || this.readDragData("view");
          if (!data) {
            return;
          }
          callbacks.onDrop({ eventData: e, dragAndDropData: data });
          this.onDragEnd.fire({ eventData: e, dragAndDropData: data });
        }
      },
      onDragOver: (e) => {
        e.preventDefault();
        if (callbacks.onDragOver) {
          const data = this.readDragData("composite") || this.readDragData("view");
          if (!data) {
            return;
          }
          callbacks.onDragOver({ eventData: e, dragAndDropData: data });
        }
      }
    }));
    if (callbacks.onDragStart) {
      this.onDragStart.event((e) => {
        callbacks.onDragStart(e);
      }, this, disposableStore);
    }
    if (callbacks.onDragEnd) {
      this.onDragEnd.event((e) => {
        callbacks.onDragEnd(e);
      }, this, disposableStore);
    }
    return this._register(disposableStore);
  }
  registerDraggable(element, draggedItemProvider, callbacks) {
    element.draggable = true;
    const disposableStore = new DisposableStore();
    disposableStore.add(addDisposableListener(element, EventType.DRAG_START, (e) => {
      var _a43;
      const { id, type } = draggedItemProvider();
      this.writeDragData(id, type);
      (_a43 = e.dataTransfer) == null ? void 0 : _a43.setDragImage(element, 0, 0);
      this.onDragStart.fire({ eventData: e, dragAndDropData: this.readDragData(type) });
    }));
    disposableStore.add(new DragAndDropObserver(element, {
      onDragEnd: (e) => {
        const { type } = draggedItemProvider();
        const data = this.readDragData(type);
        if (!data) {
          return;
        }
        this.onDragEnd.fire({ eventData: e, dragAndDropData: data });
      },
      onDragEnter: (e) => {
        if (callbacks.onDragEnter) {
          const data = this.readDragData("composite") || this.readDragData("view");
          if (!data) {
            return;
          }
          if (data) {
            callbacks.onDragEnter({ eventData: e, dragAndDropData: data });
          }
        }
      },
      onDragLeave: (e) => {
        var _a43;
        const data = this.readDragData("composite") || this.readDragData("view");
        if (!data) {
          return;
        }
        (_a43 = callbacks.onDragLeave) == null ? void 0 : _a43.call(callbacks, { eventData: e, dragAndDropData: data });
      },
      onDrop: (e) => {
        if (callbacks.onDrop) {
          const data = this.readDragData("composite") || this.readDragData("view");
          if (!data) {
            return;
          }
          callbacks.onDrop({ eventData: e, dragAndDropData: data });
          this.onDragEnd.fire({ eventData: e, dragAndDropData: data });
        }
      },
      onDragOver: (e) => {
        if (callbacks.onDragOver) {
          const data = this.readDragData("composite") || this.readDragData("view");
          if (!data) {
            return;
          }
          callbacks.onDragOver({ eventData: e, dragAndDropData: data });
        }
      }
    }));
    if (callbacks.onDragStart) {
      this.onDragStart.event((e) => {
        callbacks.onDragStart(e);
      }, this, disposableStore);
    }
    if (callbacks.onDragEnd) {
      this.onDragEnd.event((e) => {
        callbacks.onDragEnd(e);
      }, this, disposableStore);
    }
    return this._register(disposableStore);
  }
};
function toggleDropEffect(dataTransfer, dropEffect, shouldHaveIt) {
  if (!dataTransfer) {
    return;
  }
  dataTransfer.dropEffect = shouldHaveIt ? dropEffect : "none";
}
var ResourceListDnDHandler = class ResourceListDnDHandler2 {
  constructor(toResource2, instantiationService) {
    this.toResource = toResource2;
    this.instantiationService = instantiationService;
  }
  getDragURI(element) {
    const resource = this.toResource(element);
    return resource ? resource.toString() : null;
  }
  getDragLabel(elements) {
    const resources = coalesce(elements.map(this.toResource));
    return resources.length === 1 ? basename2(resources[0]) : resources.length > 1 ? String(resources.length) : void 0;
  }
  onDragStart(data, originalEvent) {
    const resources = [];
    for (const element of data.elements) {
      const resource = this.toResource(element);
      if (resource) {
        resources.push(resource);
      }
    }
    if (resources.length) {
      this.instantiationService.invokeFunction((accessor) => fillEditorsDragData(accessor, resources, originalEvent));
    }
  }
  onDragOver(data, targetElement, targetIndex, originalEvent) {
    return false;
  }
  drop(data, targetElement, targetIndex, originalEvent) {
  }
};
ResourceListDnDHandler = __decorate([
  __param(1, IInstantiationService)
], ResourceListDnDHandler);

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerViewer.js
init_instantiation();
init_network();
init_platform();
init_filters();
init_event();
init_types();
init_errorMessage();

// node_modules/vscode/vscode/src/vs/workbench/services/search/common/ignoreFile.js
var IgnoreFile = class {
  constructor(contents, location, parent) {
    this.location = location;
    this.parent = parent;
    if (location[location.length - 1] === "\\") {
      throw Error("Unexpected path format, do not use trailing backslashes");
    }
    if (location[location.length - 1] !== "/") {
      location += "/";
    }
    this.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);
  }
  updateContents(contents) {
    this.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);
  }
  isPathIncludedInTraversal(path, isDir) {
    if (path[0] !== "/" || path[path.length - 1] === "/") {
      throw Error("Unexpected path format, expectred to begin with slash and end without. got:" + path);
    }
    const ignored = this.isPathIgnored(path, isDir);
    return !ignored;
  }
  isArbitraryPathIgnored(path, isDir) {
    if (path[0] !== "/" || path[path.length - 1] === "/") {
      throw Error("Unexpected path format, expectred to begin with slash and end without. got:" + path);
    }
    const segments = path.split("/").filter((x) => x);
    let ignored = false;
    let walkingPath = "";
    for (let i = 0; i < segments.length; i++) {
      const isLast = i === segments.length - 1;
      const segment = segments[i];
      walkingPath = walkingPath + "/" + segment;
      if (!this.isPathIncludedInTraversal(walkingPath, isLast ? isDir : true)) {
        ignored = true;
        break;
      }
    }
    return ignored;
  }
  gitignoreLinesToExpression(lines, dirPath, trimForExclusions) {
    const includeLines = lines.map((line) => this.gitignoreLineToGlob(line, dirPath));
    const includeExpression = /* @__PURE__ */ Object.create(null);
    for (const line of includeLines) {
      includeExpression[line] = true;
    }
    return parse(includeExpression, { trimForExclusions });
  }
  parseIgnoreFile(ignoreContents, dirPath, parent) {
    const contentLines = ignoreContents.split("\n").map((line) => line.trim()).filter((line) => line && line[0] !== "#");
    const fileLines = contentLines.filter((line) => !line.endsWith("/"));
    const fileIgnoreLines = fileLines.filter((line) => !line.includes("!"));
    const isFileIgnored = this.gitignoreLinesToExpression(fileIgnoreLines, dirPath, true);
    const fileIncludeLines = fileLines.filter((line) => line.includes("!")).map((line) => line.replace(/!/g, ""));
    const isFileIncluded = this.gitignoreLinesToExpression(fileIncludeLines, dirPath, false);
    const dirIgnoreLines = contentLines.filter((line) => !line.includes("!"));
    const isDirIgnored = this.gitignoreLinesToExpression(dirIgnoreLines, dirPath, true);
    const dirIncludeLines = contentLines.filter((line) => line.includes("!")).map((line) => line.replace(/!/g, ""));
    const isDirIncluded = this.gitignoreLinesToExpression(dirIncludeLines, dirPath, false);
    const isPathIgnored = (path, isDir) => {
      if (!path.startsWith(dirPath)) {
        return false;
      }
      if (isDir && isDirIgnored(path) && !isDirIncluded(path)) {
        return true;
      }
      if (isFileIgnored(path) && !isFileIncluded(path)) {
        return true;
      }
      if (parent) {
        return parent.isPathIgnored(path, isDir);
      }
      return false;
    };
    return isPathIgnored;
  }
  gitignoreLineToGlob(line, dirPath) {
    const firstSep = line.indexOf("/");
    if (firstSep === -1 || firstSep === line.length - 1) {
      line = "**/" + line;
    } else {
      if (firstSep === 0) {
        if (dirPath.slice(-1) === "/") {
          line = line.slice(1);
        }
      } else {
        if (dirPath.slice(-1) !== "/") {
          line = "/" + line;
        }
      }
      line = dirPath + line;
    }
    return line;
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerViewer.js
init_map();
init_ternarySearchTree();
init_async();
var FilesRenderer_1;
var FileDragAndDrop_1;
var _ExplorerDelegate = class _ExplorerDelegate {
  getHeight(element) {
    return _ExplorerDelegate.ITEM_HEIGHT;
  }
  getTemplateId(element) {
    return FilesRenderer.ID;
  }
};
_ExplorerDelegate.ITEM_HEIGHT = 22;
var ExplorerDelegate = _ExplorerDelegate;
var explorerRootErrorEmitter = new Emitter();
var ExplorerDataSource = class ExplorerDataSource2 {
  constructor(fileFilter, progressService, configService, notificationService, layoutService, fileService, explorerService, contextService, filesConfigService) {
    this.fileFilter = fileFilter;
    this.progressService = progressService;
    this.configService = configService;
    this.notificationService = notificationService;
    this.layoutService = layoutService;
    this.fileService = fileService;
    this.explorerService = explorerService;
    this.contextService = contextService;
    this.filesConfigService = filesConfigService;
  }
  hasChildren(element) {
    return Array.isArray(element) || element.hasChildren((stat) => this.fileFilter.filter(stat, 1));
  }
  getChildren(element) {
    if (Array.isArray(element)) {
      return element;
    }
    const hasError = element.error;
    const sortOrder = this.explorerService.sortOrderConfiguration.sortOrder;
    const children = element.fetchChildren(sortOrder);
    if (Array.isArray(children)) {
      return children;
    }
    const promise = children.then((children2) => {
      if (element instanceof ExplorerItem && element.isRoot && !element.error && hasError && this.contextService.getWorkbenchState() !== 2) {
        explorerRootErrorEmitter.fire(element.resource);
      }
      return children2;
    }, (e) => {
      if (element instanceof ExplorerItem && element.isRoot) {
        if (this.contextService.getWorkbenchState() === 2) {
          const placeholder = new ExplorerItem(
            element.resource,
            this.fileService,
            this.configService,
            this.filesConfigService,
            void 0,
            void 0,
            false
          );
          placeholder.error = e;
          return [placeholder];
        } else {
          explorerRootErrorEmitter.fire(element.resource);
        }
      } else {
        this.notificationService.error(e);
      }
      return [];
    });
    this.progressService.withProgress({
      location: 1,
      delay: this.layoutService.isRestored() ? 800 : 1500
    }, (_progress) => promise);
    return promise;
  }
};
ExplorerDataSource = __decorate([
  __param(1, IProgressService),
  __param(2, IConfigurationService),
  __param(3, INotificationService),
  __param(4, IWorkbenchLayoutService),
  __param(5, IFileService),
  __param(6, IExplorerService),
  __param(7, IWorkspaceContextService),
  __param(8, IFilesConfigurationService)
], ExplorerDataSource);
var _CompressedNavigationController = class _CompressedNavigationController {
  get index() {
    return this._index;
  }
  get count() {
    return this.items.length;
  }
  get current() {
    return this.items[this._index];
  }
  get currentId() {
    return `${this.id}_${this.index}`;
  }
  get labels() {
    return this._labels;
  }
  constructor(id, items, templateData, depth, collapsed) {
    this.id = id;
    this.items = items;
    this.depth = depth;
    this.collapsed = collapsed;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._index = items.length - 1;
    this.updateLabels(templateData);
    this._updateLabelDisposable = templateData.label.onDidRender(() => this.updateLabels(templateData));
  }
  updateLabels(templateData) {
    this._labels = Array.from(templateData.container.querySelectorAll(".label-name"));
    let parents = "";
    for (let i = 0; i < this.labels.length; i++) {
      const ariaLabel = parents.length ? `${this.items[i].name}, compact, ${parents}` : this.items[i].name;
      this.labels[i].setAttribute("aria-label", ariaLabel);
      this.labels[i].setAttribute("aria-level", `${this.depth + i}`);
      parents = parents.length ? `${this.items[i].name} ${parents}` : this.items[i].name;
    }
    this.updateCollapsed(this.collapsed);
    if (this._index < this.labels.length) {
      this.labels[this._index].classList.add("active");
    }
  }
  previous() {
    if (this._index <= 0) {
      return;
    }
    this.setIndex(this._index - 1);
  }
  next() {
    if (this._index >= this.items.length - 1) {
      return;
    }
    this.setIndex(this._index + 1);
  }
  first() {
    if (this._index === 0) {
      return;
    }
    this.setIndex(0);
  }
  last() {
    if (this._index === this.items.length - 1) {
      return;
    }
    this.setIndex(this.items.length - 1);
  }
  setIndex(index) {
    if (index < 0 || index >= this.items.length) {
      return;
    }
    this.labels[this._index].classList.remove("active");
    this._index = index;
    this.labels[this._index].classList.add("active");
    this._onDidChange.fire();
  }
  updateCollapsed(collapsed) {
    this.collapsed = collapsed;
    for (let i = 0; i < this.labels.length; i++) {
      this.labels[i].setAttribute("aria-expanded", collapsed ? "false" : "true");
    }
  }
  dispose() {
    this._onDidChange.dispose();
    this._updateLabelDisposable.dispose();
  }
};
_CompressedNavigationController.ID = 0;
var CompressedNavigationController = _CompressedNavigationController;
var _a33;
var FilesRenderer = (_a33 = class {
  constructor(container, labels, updateWidth, contextViewService, themeService, configurationService, explorerService, labelService, contextService, contextMenuService, hoverService) {
    this.labels = labels;
    this.updateWidth = updateWidth;
    this.contextViewService = contextViewService;
    this.themeService = themeService;
    this.configurationService = configurationService;
    this.explorerService = explorerService;
    this.labelService = labelService;
    this.contextService = contextService;
    this.contextMenuService = contextMenuService;
    this.hoverService = hoverService;
    this.compressedNavigationControllers = /* @__PURE__ */ new Map();
    this._onDidChangeActiveDescendant = new EventMultiplexer();
    this.onDidChangeActiveDescendant = this._onDidChangeActiveDescendant.event;
    this.hoverDelegate = new class {
      get delay() {
        if (Date.now() - this.lastHoverHideTime < 500) {
          return 0;
        }
        return this.configurationService.getValue("workbench.hover.delay");
      }
      constructor(configurationService2, hoverService2) {
        this.configurationService = configurationService2;
        this.hoverService = hoverService2;
        this.lastHoverHideTime = 0;
        this.hiddenFromClick = false;
        this.placement = "element";
      }
      showHover(options, focus) {
        let element;
        if (options.target instanceof HTMLElement) {
          element = options.target;
        } else {
          element = options.target.targetElements[0];
        }
        const tlRow = element.closest(".monaco-tl-row");
        const listRow = tlRow == null ? void 0 : tlRow.closest(".monaco-list-row");
        const child = element.querySelector("div.monaco-icon-label-container");
        const childOfChild = child == null ? void 0 : child.querySelector("span.monaco-icon-name-container");
        let overflowed = false;
        if (childOfChild && child) {
          const width = child.clientWidth;
          const childWidth = childOfChild.offsetWidth;
          overflowed = width <= childWidth;
        }
        const hasDecoration = options.content.toString().includes("");
        overflowed = overflowed || hasDecoration;
        const indentGuideElement = tlRow == null ? void 0 : tlRow.querySelector(".monaco-tl-indent");
        if (!indentGuideElement) {
          return;
        }
        return overflowed ? this.hoverService.showHover({
          ...options,
          target: indentGuideElement,
          compact: true,
          container: listRow,
          additionalClasses: ["explorer-item-hover"],
          skipFadeInAnimation: true,
          showPointer: false,
          hoverPosition: 1
        }, focus) : void 0;
      }
      onDidHideHover() {
        if (!this.hiddenFromClick) {
          this.lastHoverHideTime = Date.now();
        }
        this.hiddenFromClick = false;
      }
    }(this.configurationService, this.hoverService);
    this.config = this.configurationService.getValue();
    const updateOffsetStyles = () => {
      const indent = this.configurationService.getValue("workbench.tree.indent");
      const offset = Math.max(22 - indent, 0);
      container.style.setProperty(`--vscode-explorer-align-offset-margin-left`, `${offset}px`);
    };
    this.configListener = this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("explorer")) {
        this.config = this.configurationService.getValue();
      }
      if (e.affectsConfiguration("workbench.tree.indent")) {
        updateOffsetStyles();
      }
    });
    updateOffsetStyles();
  }
  getWidgetAriaLabel() {
    return localize("treeAriaLabel", "Files Explorer");
  }
  get templateId() {
    return FilesRenderer_1.ID;
  }
  renderTemplate(container) {
    const templateDisposables = new DisposableStore();
    const experimentalHover = this.configurationService.getValue("explorer.experimental.hover");
    const label = templateDisposables.add(this.labels.create(container, { supportHighlights: true, hoverDelegate: experimentalHover ? this.hoverDelegate : void 0 }));
    templateDisposables.add(label.onDidRender(() => {
      try {
        if (templateData.currentContext) {
          this.updateWidth(templateData.currentContext);
        }
      } catch (e) {
      }
    }));
    const templateData = { templateDisposables, elementDisposables: templateDisposables.add(new DisposableStore()), label, container };
    return templateData;
  }
  renderElement(node, index, templateData) {
    const stat = node.element;
    templateData.currentContext = stat;
    const editableData = this.explorerService.getEditableData(stat);
    templateData.label.element.classList.remove("compressed");
    if (!editableData) {
      templateData.label.element.style.display = "flex";
      this.renderStat(stat, stat.name, void 0, node.filterData, templateData);
    } else {
      templateData.label.element.style.display = "none";
      templateData.elementDisposables.add(this.renderInputBox(templateData.container, stat, editableData));
    }
  }
  renderCompressedElements(node, index, templateData, height) {
    const stat = node.element.elements[node.element.elements.length - 1];
    templateData.currentContext = stat;
    const editable = node.element.elements.filter((e) => this.explorerService.isEditable(e));
    const editableData = editable.length === 0 ? void 0 : this.explorerService.getEditableData(editable[0]);
    if (!editableData) {
      templateData.label.element.classList.add("compressed");
      templateData.label.element.style.display = "flex";
      const id = `compressed-explorer_${CompressedNavigationController.ID++}`;
      const label = node.element.elements.map((e) => e.name);
      this.renderStat(stat, label, id, node.filterData, templateData);
      const compressedNavigationController = new CompressedNavigationController(id, node.element.elements, templateData, node.depth, node.collapsed);
      templateData.elementDisposables.add(compressedNavigationController);
      this.compressedNavigationControllers.set(stat, compressedNavigationController);
      templateData.elementDisposables.add(this._onDidChangeActiveDescendant.add(compressedNavigationController.onDidChange));
      templateData.elementDisposables.add(addDisposableListener(templateData.container, "mousedown", (e) => {
        const result = getIconLabelNameFromHTMLElement(e.target);
        if (result) {
          compressedNavigationController.setIndex(result.index);
        }
      }));
      templateData.elementDisposables.add(toDisposable(() => this.compressedNavigationControllers.delete(stat)));
    } else {
      templateData.label.element.classList.remove("compressed");
      templateData.label.element.style.display = "none";
      templateData.elementDisposables.add(this.renderInputBox(templateData.container, editable[0], editableData));
    }
  }
  renderStat(stat, label, domId, filterData, templateData) {
    var _a43, _b;
    templateData.label.element.style.display = "flex";
    const extraClasses = ["explorer-item"];
    if (this.explorerService.isCut(stat)) {
      extraClasses.push("cut");
    }
    const theme = this.themeService.getFileIconTheme();
    const twistieContainer = (_b = (_a43 = templateData.container.parentElement) == null ? void 0 : _a43.parentElement) == null ? void 0 : _b.querySelector(".monaco-tl-twistie");
    twistieContainer == null ? void 0 : twistieContainer.classList.toggle("force-twistie", stat.hasNests && theme.hidesExplorerArrows);
    const themeIsUnhappyWithNesting = theme.hasFileIcons && (theme.hidesExplorerArrows || !theme.hasFolderIcons);
    const realignNestedChildren = stat.nestedParent && themeIsUnhappyWithNesting;
    const experimentalHover = this.configurationService.getValue("explorer.experimental.hover");
    templateData.label.setResource({ resource: stat.resource, name: label }, {
      title: experimentalHover ? isStringArray(label) ? label[0] : label : void 0,
      fileKind: stat.isRoot ? FileKind.ROOT_FOLDER : stat.isDirectory ? FileKind.FOLDER : FileKind.FILE,
      extraClasses: realignNestedChildren ? [...extraClasses, "align-nest-icon-with-parent-icon"] : extraClasses,
      fileDecorations: this.config.explorer.decorations,
      matches: createMatches(filterData),
      separator: this.labelService.getSeparator(stat.resource.scheme, stat.resource.authority),
      domId
    });
  }
  renderInputBox(container, stat, editableData) {
    const label = this.labels.create(container);
    const extraClasses = ["explorer-item", "explorer-item-edited"];
    const fileKind = stat.isRoot ? FileKind.ROOT_FOLDER : stat.isDirectory ? FileKind.FOLDER : FileKind.FILE;
    const theme = this.themeService.getFileIconTheme();
    const themeIsUnhappyWithNesting = theme.hasFileIcons && (theme.hidesExplorerArrows || !theme.hasFolderIcons);
    const realignNestedChildren = stat.nestedParent && themeIsUnhappyWithNesting;
    const labelOptions = {
      hidePath: true,
      hideLabel: true,
      fileKind,
      extraClasses: realignNestedChildren ? [...extraClasses, "align-nest-icon-with-parent-icon"] : extraClasses
    };
    const parent = stat.name ? dirname(stat.resource) : stat.resource;
    const value = stat.name || "";
    label.setFile(joinPath(parent, value || " "), labelOptions);
    label.element.firstElementChild.style.display = "none";
    const inputBox = new InputBox(label.element, this.contextViewService, {
      validationOptions: {
        validation: (value2) => {
          const message = editableData.validationMessage(value2);
          if (!message || message.severity !== Severity.Error) {
            return null;
          }
          return {
            content: message.content,
            formatContent: true,
            type: 3
          };
        }
      },
      ariaLabel: localize(
        "fileInputAriaLabel",
        "Type file name. Press Enter to confirm or Escape to cancel."
      ),
      inputBoxStyles: defaultInputBoxStyles
    });
    const lastDot = value.lastIndexOf(".");
    let currentSelectionState = "prefix";
    inputBox.value = value;
    inputBox.focus();
    inputBox.select({ start: 0, end: lastDot > 0 && !stat.isDirectory ? lastDot : value.length });
    const done = once((success, finishEditing) => {
      label.element.style.display = "none";
      const value2 = inputBox.value;
      dispose(toDispose);
      label.element.remove();
      if (finishEditing) {
        editableData.onFinish(value2, success);
      }
    });
    const showInputBoxNotification = () => {
      if (inputBox.isInputValid()) {
        const message = editableData.validationMessage(inputBox.value);
        if (message) {
          inputBox.showMessage({
            content: message.content,
            formatContent: true,
            type: message.severity === Severity.Info ? 1 : message.severity === Severity.Warning ? 2 : 3
          });
        } else {
          inputBox.hideMessage();
        }
      }
    };
    showInputBoxNotification();
    const toDispose = [
      inputBox,
      inputBox.onDidChange((value2) => {
        label.setFile(joinPath(parent, value2 || " "), labelOptions);
      }),
      addStandardDisposableListener(inputBox.inputElement, EventType.KEY_DOWN, (e) => {
        if (e.equals(60)) {
          const dotIndex = inputBox.value.lastIndexOf(".");
          if (stat.isDirectory || dotIndex === -1) {
            return;
          }
          if (currentSelectionState === "prefix") {
            currentSelectionState = "all";
            inputBox.select({ start: 0, end: inputBox.value.length });
          } else if (currentSelectionState === "all") {
            currentSelectionState = "suffix";
            inputBox.select({ start: dotIndex + 1, end: inputBox.value.length });
          } else {
            currentSelectionState = "prefix";
            inputBox.select({ start: 0, end: dotIndex });
          }
        } else if (e.equals(3)) {
          if (!inputBox.validate()) {
            done(true, true);
          }
        } else if (e.equals(9)) {
          done(false, true);
        }
      }),
      addStandardDisposableListener(inputBox.inputElement, EventType.KEY_UP, (e) => {
        showInputBoxNotification();
      }),
      addDisposableListener(inputBox.inputElement, EventType.BLUR, async () => {
        while (true) {
          await timeout(0);
          if (!document.hasFocus()) {
            break;
          }
          if (document.activeElement === inputBox.inputElement) {
            return;
          } else if (document.activeElement instanceof HTMLElement && hasParentWithClass(document.activeElement, "context-view")) {
            await Event.toPromise(this.contextMenuService.onDidHideContextMenu);
          } else {
            break;
          }
        }
        done(inputBox.isInputValid(), true);
      }),
      label
    ];
    return toDisposable(() => {
      done(false, false);
    });
  }
  disposeElement(element, index, templateData) {
    templateData.currentContext = void 0;
    templateData.elementDisposables.clear();
  }
  disposeCompressedElements(node, index, templateData) {
    templateData.currentContext = void 0;
    templateData.elementDisposables.clear();
  }
  disposeTemplate(templateData) {
    templateData.templateDisposables.dispose();
  }
  getCompressedNavigationController(stat) {
    return this.compressedNavigationControllers.get(stat);
  }
  getAriaLabel(element) {
    return element.name;
  }
  getAriaLevel(element) {
    let depth = 0;
    let parent = element.parent;
    while (parent) {
      parent = parent.parent;
      depth++;
    }
    if (this.contextService.getWorkbenchState() === 3) {
      depth = depth + 1;
    }
    return depth;
  }
  getActiveDescendantId(stat) {
    const compressedNavigationController = this.compressedNavigationControllers.get(stat);
    return compressedNavigationController == null ? void 0 : compressedNavigationController.currentId;
  }
  dispose() {
    this.configListener.dispose();
  }
}, FilesRenderer_1 = _a33, _a33.ID = "file", _a33);
FilesRenderer = FilesRenderer_1 = __decorate([
  __param(3, IContextViewService),
  __param(4, IThemeService),
  __param(5, IConfigurationService),
  __param(6, IExplorerService),
  __param(7, ILabelService),
  __param(8, IWorkspaceContextService),
  __param(9, IContextMenuService),
  __param(10, IHoverService)
], FilesRenderer);
var FilesFilter = class FilesFilter2 {
  constructor(contextService, configurationService, explorerService, editorService, uriIdentityService, fileService) {
    this.contextService = contextService;
    this.configurationService = configurationService;
    this.explorerService = explorerService;
    this.editorService = editorService;
    this.uriIdentityService = uriIdentityService;
    this.fileService = fileService;
    this.hiddenExpressionPerRoot = /* @__PURE__ */ new Map();
    this.editorsAffectingFilter = /* @__PURE__ */ new Set();
    this._onDidChange = new Emitter();
    this.toDispose = [];
    this.ignoreFileResourcesPerRoot = /* @__PURE__ */ new Map();
    this.ignoreTreesPerRoot = /* @__PURE__ */ new Map();
    this.toDispose.push(this.contextService.onDidChangeWorkspaceFolders(() => this.updateConfiguration()));
    this.toDispose.push(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("files.exclude") || e.affectsConfiguration("explorer.excludeGitIgnore")) {
        this.updateConfiguration();
      }
    }));
    this.toDispose.push(this.fileService.onDidFilesChange((e) => {
      for (const [root, ignoreFileResourceSet] of this.ignoreFileResourcesPerRoot.entries()) {
        ignoreFileResourceSet.forEach(async (ignoreResource) => {
          var _a43;
          if (e.contains(ignoreResource, 0)) {
            await this.processIgnoreFile(root, ignoreResource, true);
          }
          if (e.contains(ignoreResource, 2)) {
            (_a43 = this.ignoreTreesPerRoot.get(root)) == null ? void 0 : _a43.delete(dirname(ignoreResource));
            ignoreFileResourceSet.delete(ignoreResource);
            this._onDidChange.fire();
          }
        });
      }
    }));
    this.toDispose.push(this.editorService.onDidVisibleEditorsChange(() => {
      const editors = this.editorService.visibleEditors;
      let shouldFire = false;
      for (const e of editors) {
        if (!e.resource) {
          continue;
        }
        const stat = this.explorerService.findClosest(e.resource);
        if (stat && stat.isExcluded) {
          shouldFire = true;
          break;
        }
      }
      for (const e of this.editorsAffectingFilter) {
        if (!editors.includes(e)) {
          shouldFire = true;
          break;
        }
      }
      if (shouldFire) {
        this.editorsAffectingFilter.clear();
        this._onDidChange.fire();
      }
    }));
    this.updateConfiguration();
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  updateConfiguration() {
    let shouldFire = false;
    let updatedGitIgnoreSetting = false;
    this.contextService.getWorkspace().folders.forEach((folder) => {
      var _a43;
      const configuration = this.configurationService.getValue({ resource: folder.uri });
      const excludesConfig = ((_a43 = configuration == null ? void 0 : configuration.files) == null ? void 0 : _a43.exclude) || /* @__PURE__ */ Object.create(null);
      const parseIgnoreFile = configuration.explorer.excludeGitIgnore;
      if (parseIgnoreFile && !this.ignoreTreesPerRoot.has(folder.uri.toString())) {
        updatedGitIgnoreSetting = true;
        this.ignoreFileResourcesPerRoot.set(folder.uri.toString(), new ResourceSet());
        this.ignoreTreesPerRoot.set(folder.uri.toString(), TernarySearchTree.forUris((uri) => this.uriIdentityService.extUri.ignorePathCasing(uri)));
      }
      if (!parseIgnoreFile && this.ignoreTreesPerRoot.has(folder.uri.toString())) {
        updatedGitIgnoreSetting = true;
        this.ignoreFileResourcesPerRoot.delete(folder.uri.toString());
        this.ignoreTreesPerRoot.delete(folder.uri.toString());
      }
      if (!shouldFire) {
        const cached = this.hiddenExpressionPerRoot.get(folder.uri.toString());
        shouldFire = !cached || !equals(cached.original, excludesConfig);
      }
      const excludesConfigCopy = deepClone(excludesConfig);
      this.hiddenExpressionPerRoot.set(folder.uri.toString(), { original: excludesConfigCopy, parsed: parse(excludesConfigCopy) });
    });
    if (shouldFire || updatedGitIgnoreSetting) {
      this.editorsAffectingFilter.clear();
      this._onDidChange.fire();
    }
  }
  async processIgnoreFile(root, ignoreFileResource, update) {
    var _a43, _b;
    const dirUri = dirname(ignoreFileResource);
    const ignoreTree = this.ignoreTreesPerRoot.get(root);
    if (!ignoreTree) {
      return;
    }
    if (!update && ignoreTree.has(dirUri)) {
      return;
    }
    const content = await this.fileService.readFile(ignoreFileResource);
    if (update) {
      const ignoreFile = ignoreTree.get(dirUri);
      ignoreFile == null ? void 0 : ignoreFile.updateContents(content.value.toString());
    } else {
      const ignoreParent = ignoreTree.findSubstr(dirUri);
      const ignoreFile = new IgnoreFile(content.value.toString(), dirUri.path, ignoreParent);
      ignoreTree.set(dirUri, ignoreFile);
      if (!((_a43 = this.ignoreFileResourcesPerRoot.get(root)) == null ? void 0 : _a43.has(ignoreFileResource))) {
        (_b = this.ignoreFileResourcesPerRoot.get(root)) == null ? void 0 : _b.add(ignoreFileResource);
      }
    }
    this._onDidChange.fire();
  }
  filter(stat, parentVisibility) {
    if (stat.name === ".gitignore" && this.ignoreTreesPerRoot.has(stat.root.resource.toString())) {
      this.processIgnoreFile(stat.root.resource.toString(), stat.resource, false);
      return true;
    }
    return this.isVisible(stat, parentVisibility);
  }
  isVisible(stat, parentVisibility) {
    var _a43, _b;
    stat.isExcluded = false;
    if (parentVisibility === 0) {
      stat.isExcluded = true;
      return false;
    }
    if (this.explorerService.getEditableData(stat)) {
      return true;
    }
    const cached = this.hiddenExpressionPerRoot.get(stat.root.resource.toString());
    const globMatch = cached == null ? void 0 : cached.parsed(relative(stat.root.resource.path, stat.resource.path), stat.name, (name) => !!(stat.parent && stat.parent.getChild(name)));
    const ignoreFile = globMatch ? void 0 : (_a43 = this.ignoreTreesPerRoot.get(stat.root.resource.toString())) == null ? void 0 : _a43.findSubstr(stat.resource);
    const isIncludedInTraversal = ignoreFile == null ? void 0 : ignoreFile.isPathIncludedInTraversal(stat.resource.path, stat.isDirectory);
    const isIgnoredByIgnoreFile = isIncludedInTraversal === void 0 ? false : !isIncludedInTraversal;
    if (isIgnoredByIgnoreFile || globMatch || ((_b = stat.parent) == null ? void 0 : _b.isExcluded)) {
      stat.isExcluded = true;
      const editors = this.editorService.visibleEditors;
      const editor = editors.find((e) => e.resource && this.uriIdentityService.extUri.isEqualOrParent(e.resource, stat.resource));
      if (editor && stat.root === this.explorerService.findClosestRoot(stat.resource)) {
        this.editorsAffectingFilter.add(editor);
        return true;
      }
      return false;
    }
    return true;
  }
  dispose() {
    dispose(this.toDispose);
  }
};
FilesFilter = __decorate([
  __param(0, IWorkspaceContextService),
  __param(1, IConfigurationService),
  __param(2, IExplorerService),
  __param(3, IEditorService),
  __param(4, IUriIdentityService),
  __param(5, IFileService)
], FilesFilter);
var FileSorter = class FileSorter2 {
  constructor(explorerService, contextService) {
    this.explorerService = explorerService;
    this.contextService = contextService;
  }
  compare(statA, statB) {
    if (statA.isRoot) {
      if (statB.isRoot) {
        const workspaceA = this.contextService.getWorkspaceFolder(statA.resource);
        const workspaceB = this.contextService.getWorkspaceFolder(statB.resource);
        return workspaceA && workspaceB ? workspaceA.index - workspaceB.index : -1;
      }
      return -1;
    }
    if (statB.isRoot) {
      return 1;
    }
    const sortOrder = this.explorerService.sortOrderConfiguration.sortOrder;
    const lexicographicOptions = this.explorerService.sortOrderConfiguration.lexicographicOptions;
    let compareFileNames2;
    let compareFileExtensions2;
    switch (lexicographicOptions) {
      case "upper":
        compareFileNames2 = compareFileNamesUpper;
        compareFileExtensions2 = compareFileExtensionsUpper;
        break;
      case "lower":
        compareFileNames2 = compareFileNamesLower;
        compareFileExtensions2 = compareFileExtensionsLower;
        break;
      case "unicode":
        compareFileNames2 = compareFileNamesUnicode;
        compareFileExtensions2 = compareFileExtensionsUnicode;
        break;
      default:
        compareFileNames2 = compareFileNamesDefault;
        compareFileExtensions2 = compareFileExtensionsDefault;
    }
    switch (sortOrder) {
      case "type":
        if (statA.isDirectory && !statB.isDirectory) {
          return -1;
        }
        if (statB.isDirectory && !statA.isDirectory) {
          return 1;
        }
        if (statA.isDirectory && statB.isDirectory) {
          return compareFileNames2(statA.name, statB.name);
        }
        break;
      case "filesFirst":
        if (statA.isDirectory && !statB.isDirectory) {
          return 1;
        }
        if (statB.isDirectory && !statA.isDirectory) {
          return -1;
        }
        break;
      case "foldersNestsFiles":
        if (statA.isDirectory && !statB.isDirectory) {
          return -1;
        }
        if (statB.isDirectory && !statA.isDirectory) {
          return 1;
        }
        if (statA.hasNests && !statB.hasNests) {
          return -1;
        }
        if (statB.hasNests && !statA.hasNests) {
          return 1;
        }
        break;
      case "mixed":
        break;
      default:
        if (statA.isDirectory && !statB.isDirectory) {
          return -1;
        }
        if (statB.isDirectory && !statA.isDirectory) {
          return 1;
        }
        break;
    }
    switch (sortOrder) {
      case "type":
        return compareFileExtensions2(statA.name, statB.name);
      case "modified":
        if (statA.mtime !== statB.mtime) {
          return statA.mtime && statB.mtime && statA.mtime < statB.mtime ? 1 : -1;
        }
        return compareFileNames2(statA.name, statB.name);
      default:
        return compareFileNames2(statA.name, statB.name);
    }
  }
};
FileSorter = __decorate([
  __param(0, IExplorerService),
  __param(1, IWorkspaceContextService)
], FileSorter);
var _a34;
var FileDragAndDrop = (_a34 = class {
  constructor(isCollapsed, explorerService, editorService, dialogService, contextService, fileService, configurationService, instantiationService, workspaceEditingService, uriIdentityService) {
    this.isCollapsed = isCollapsed;
    this.explorerService = explorerService;
    this.editorService = editorService;
    this.dialogService = dialogService;
    this.contextService = contextService;
    this.fileService = fileService;
    this.configurationService = configurationService;
    this.instantiationService = instantiationService;
    this.workspaceEditingService = workspaceEditingService;
    this.uriIdentityService = uriIdentityService;
    this.compressedDropTargetDisposable = Disposable.None;
    this.dropEnabled = false;
    this.toDispose = [];
    const updateDropEnablement = (e) => {
      if (!e || e.affectsConfiguration("explorer.enableDragAndDrop")) {
        this.dropEnabled = this.configurationService.getValue("explorer.enableDragAndDrop");
      }
    };
    updateDropEnablement(void 0);
    this.toDispose.push(this.configurationService.onDidChangeConfiguration((e) => updateDropEnablement(e)));
  }
  onDragOver(data, target, targetIndex, originalEvent) {
    if (!this.dropEnabled) {
      return false;
    }
    if (target) {
      const compressedTarget = FileDragAndDrop_1.getCompressedStatFromDragEvent(target, originalEvent);
      if (compressedTarget) {
        const iconLabelName = getIconLabelNameFromHTMLElement(originalEvent.target);
        if (iconLabelName && iconLabelName.index < iconLabelName.count - 1) {
          const result = this.handleDragOver(data, compressedTarget, targetIndex, originalEvent);
          if (result) {
            if (iconLabelName.element !== this.compressedDragOverElement) {
              this.compressedDragOverElement = iconLabelName.element;
              this.compressedDropTargetDisposable.dispose();
              this.compressedDropTargetDisposable = toDisposable(() => {
                iconLabelName.element.classList.remove("drop-target");
                this.compressedDragOverElement = void 0;
              });
              iconLabelName.element.classList.add("drop-target");
            }
            return typeof result === "boolean" ? result : { ...result, feedback: [] };
          }
          this.compressedDropTargetDisposable.dispose();
          return false;
        }
      }
    }
    this.compressedDropTargetDisposable.dispose();
    return this.handleDragOver(data, target, targetIndex, originalEvent);
  }
  handleDragOver(data, target, targetIndex, originalEvent) {
    const isCopy = originalEvent && (originalEvent.ctrlKey && !isMacintosh || originalEvent.altKey && isMacintosh);
    const isNative2 = data instanceof NativeDragAndDropData;
    const effect = isNative2 || isCopy ? 0 : 1;
    if (isNative2) {
      if (!containsDragType(originalEvent, DataTransfers.FILES, CodeDataTransfers.FILES, DataTransfers.RESOURCES)) {
        return false;
      }
    } else if (data instanceof ExternalElementsDragAndDropData) {
      return false;
    } else {
      const items = FileDragAndDrop_1.getStatsFromDragAndDropData(data);
      if (!target) {
        if (!isCopy && items.every((i) => !!i.parent && i.parent.isRoot)) {
          return false;
        }
        return { accept: true, bubble: 0, effect, autoExpand: false };
      }
      if (!Array.isArray(items)) {
        return false;
      }
      if (!isCopy && items.every((source) => source.isReadonly)) {
        return false;
      }
      if (items.some((source) => {
        if (source.isRoot && target instanceof ExplorerItem && !target.isRoot) {
          return true;
        }
        if (this.uriIdentityService.extUri.isEqual(source.resource, target.resource)) {
          return true;
        }
        if (source.isRoot && target instanceof ExplorerItem && target.isRoot) {
          return false;
        }
        if (!isCopy && this.uriIdentityService.extUri.isEqual(dirname(source.resource), target.resource)) {
          return true;
        }
        if (this.uriIdentityService.extUri.isEqualOrParent(target.resource, source.resource)) {
          return true;
        }
        return false;
      })) {
        return false;
      }
    }
    if (!target) {
      return { accept: true, bubble: 0, effect };
    } else {
      if (target.isDirectory) {
        if (target.isReadonly) {
          return false;
        }
        return { accept: true, bubble: 0, effect, autoExpand: true };
      }
      if (this.contextService.getWorkspace().folders.every((folder) => folder.uri.toString() !== target.resource.toString())) {
        return { accept: true, bubble: 1, effect };
      }
    }
    return false;
  }
  getDragURI(element) {
    if (this.explorerService.isEditable(element)) {
      return null;
    }
    return element.resource.toString();
  }
  getDragLabel(elements, originalEvent) {
    if (elements.length === 1) {
      const stat = FileDragAndDrop_1.getCompressedStatFromDragEvent(elements[0], originalEvent);
      return stat.name;
    }
    return String(elements.length);
  }
  onDragStart(data, originalEvent) {
    const items = FileDragAndDrop_1.getStatsFromDragAndDropData(data, originalEvent);
    if (items && items.length && originalEvent.dataTransfer) {
      this.instantiationService.invokeFunction((accessor) => fillEditorsDragData(accessor, items, originalEvent));
      const fileResources = items.filter((s) => s.resource.scheme === Schemas.file).map((r) => r.resource.fsPath);
      if (fileResources.length) {
        originalEvent.dataTransfer.setData(CodeDataTransfers.FILES, JSON.stringify(fileResources));
      }
    }
  }
  async drop(data, target, targetIndex, originalEvent) {
    this.compressedDropTargetDisposable.dispose();
    if (target) {
      const compressedTarget = FileDragAndDrop_1.getCompressedStatFromDragEvent(target, originalEvent);
      if (compressedTarget) {
        target = compressedTarget;
      }
    }
    if (!target) {
      target = this.explorerService.roots[this.explorerService.roots.length - 1];
    }
    if (!target.isDirectory && target.parent) {
      target = target.parent;
    }
    if (target.isReadonly) {
      return;
    }
    const resolvedTarget = target;
    if (!resolvedTarget) {
      return;
    }
    try {
      if (data instanceof NativeDragAndDropData) {
        if (!isWeb || isTemporaryWorkspace(this.contextService.getWorkspace()) && WebFileSystemAccess.supported(window)) {
          const fileImport = this.instantiationService.createInstance(ExternalFileImport);
          await fileImport.import(resolvedTarget, originalEvent);
        } else {
          const browserUpload = this.instantiationService.createInstance(BrowserFileUpload);
          await browserUpload.upload(target, originalEvent);
        }
      } else {
        await this.handleExplorerDrop(data, resolvedTarget, originalEvent);
      }
    } catch (error) {
      this.dialogService.error(toErrorMessage(error));
    }
  }
  async handleExplorerDrop(data, target, originalEvent) {
    const elementsData = FileDragAndDrop_1.getStatsFromDragAndDropData(data);
    const distinctItems = new Map(elementsData.map((element) => [element, this.isCollapsed(element)]));
    for (const [item, collapsed] of distinctItems) {
      if (collapsed) {
        const nestedChildren = item.nestedChildren;
        if (nestedChildren) {
          for (const child of nestedChildren) {
            distinctItems.set(child, true);
          }
        }
      }
    }
    const items = distinctParents([...distinctItems.keys()], (s) => s.resource);
    const isCopy = originalEvent.ctrlKey && !isMacintosh || originalEvent.altKey && isMacintosh;
    const confirmDragAndDrop = !isCopy && this.configurationService.getValue(FileDragAndDrop_1.CONFIRM_DND_SETTING_KEY);
    if (confirmDragAndDrop) {
      const message = items.length > 1 && items.every((s) => s.isRoot) ? localize(
        "confirmRootsMove",
        "Are you sure you want to change the order of multiple root folders in your workspace?"
      ) : items.length > 1 ? localize(
        "confirmMultiMove",
        "Are you sure you want to move the following {0} files into '{1}'?",
        items.length,
        target.name
      ) : items[0].isRoot ? localize(
        "confirmRootMove",
        "Are you sure you want to change the order of root folder '{0}' in your workspace?",
        items[0].name
      ) : localize(
        "confirmMove",
        "Are you sure you want to move '{0}' into '{1}'?",
        items[0].name,
        target.name
      );
      const detail = items.length > 1 && !items.every((s) => s.isRoot) ? getFileNamesMessage(items.map((i) => i.resource)) : void 0;
      const confirmation = await this.dialogService.confirm({
        message,
        detail,
        checkbox: {
          label: localize("doNotAskAgain", "Do not ask me again")
        },
        primaryButton: localize({ key: "moveButtonLabel", comment: ["&& denotes a mnemonic"] }, "&&Move")
      });
      if (!confirmation.confirmed) {
        return;
      }
      if (confirmation.checkboxChecked === true) {
        await this.configurationService.updateValue(FileDragAndDrop_1.CONFIRM_DND_SETTING_KEY, false);
      }
    }
    await this.doHandleRootDrop(items.filter((s) => s.isRoot), target);
    const sources = items.filter((s) => !s.isRoot);
    if (isCopy) {
      return this.doHandleExplorerDropOnCopy(sources, target);
    }
    return this.doHandleExplorerDropOnMove(sources, target);
  }
  async doHandleRootDrop(roots, target) {
    if (roots.length === 0) {
      return;
    }
    const folders = this.contextService.getWorkspace().folders;
    let targetIndex;
    const workspaceCreationData = [];
    const rootsToMove = [];
    for (let index = 0; index < folders.length; index++) {
      const data = {
        uri: folders[index].uri,
        name: folders[index].name
      };
      if (target instanceof ExplorerItem && this.uriIdentityService.extUri.isEqual(folders[index].uri, target.resource)) {
        targetIndex = index;
      }
      if (roots.every((r) => r.resource.toString() !== folders[index].uri.toString())) {
        workspaceCreationData.push(data);
      } else {
        rootsToMove.push(data);
      }
    }
    if (targetIndex === void 0) {
      targetIndex = workspaceCreationData.length;
    }
    workspaceCreationData.splice(targetIndex, 0, ...rootsToMove);
    return this.workspaceEditingService.updateFolders(0, workspaceCreationData.length, workspaceCreationData);
  }
  async doHandleExplorerDropOnCopy(sources, target) {
    const explorerConfig = this.configurationService.getValue().explorer;
    const resourceFileEdits = [];
    for (const { resource, isDirectory } of sources) {
      const allowOverwrite = explorerConfig.incrementalNaming === "disabled";
      const newResource = await findValidPasteFileTarget(this.explorerService, this.fileService, this.dialogService, target, { resource, isDirectory, allowOverwrite }, explorerConfig.incrementalNaming);
      if (!newResource) {
        continue;
      }
      const resourceEdit = new ResourceFileEdit(resource, newResource, { copy: true, overwrite: allowOverwrite });
      resourceFileEdits.push(resourceEdit);
    }
    const labelSuffix = getFileOrFolderLabelSuffix(sources);
    await this.explorerService.applyBulkEdit(resourceFileEdits, {
      confirmBeforeUndo: explorerConfig.confirmUndo === "default" || explorerConfig.confirmUndo === "verbose",
      undoLabel: localize("copy", "Copy {0}", labelSuffix),
      progressLabel: localize("copying", "Copying {0}", labelSuffix)
    });
    const editors = resourceFileEdits.filter((edit) => {
      const item = edit.newResource ? this.explorerService.findClosest(edit.newResource) : void 0;
      return item && !item.isDirectory;
    }).map((edit) => ({ resource: edit.newResource, options: { pinned: true } }));
    await this.editorService.openEditors(editors);
  }
  async doHandleExplorerDropOnMove(sources, target) {
    const resourceFileEdits = sources.filter((source) => !source.isReadonly).map((source) => new ResourceFileEdit(source.resource, joinPath(target.resource, source.name)));
    const labelSuffix = getFileOrFolderLabelSuffix(sources);
    const options = {
      confirmBeforeUndo: this.configurationService.getValue().explorer.confirmUndo === "verbose",
      undoLabel: localize("move", "Move {0}", labelSuffix),
      progressLabel: localize("moving", "Moving {0}", labelSuffix)
    };
    try {
      await this.explorerService.applyBulkEdit(resourceFileEdits, options);
    } catch (error) {
      if (error.fileOperationResult === 4) {
        const overwrites = [];
        for (const edit of resourceFileEdits) {
          if (edit.newResource && await this.fileService.exists(edit.newResource)) {
            overwrites.push(edit.newResource);
          }
        }
        const confirm = getMultipleFilesOverwriteConfirm(overwrites);
        const { confirmed } = await this.dialogService.confirm(confirm);
        if (confirmed) {
          await this.explorerService.applyBulkEdit(resourceFileEdits.map((re) => new ResourceFileEdit(re.oldResource, re.newResource, { overwrite: true })), options);
        }
      } else {
        throw error;
      }
    }
  }
  static getStatsFromDragAndDropData(data, dragStartEvent) {
    if (data.context) {
      return data.context;
    }
    if (dragStartEvent && data.elements.length === 1) {
      data.context = [FileDragAndDrop_1.getCompressedStatFromDragEvent(data.elements[0], dragStartEvent)];
      return data.context;
    }
    return data.elements;
  }
  static getCompressedStatFromDragEvent(stat, dragEvent) {
    const target = document.elementFromPoint(dragEvent.clientX, dragEvent.clientY);
    const iconLabelName = getIconLabelNameFromHTMLElement(target);
    if (iconLabelName) {
      const { count, index } = iconLabelName;
      let i = count - 1;
      while (i > index && stat.parent) {
        stat = stat.parent;
        i--;
      }
      return stat;
    }
    return stat;
  }
  onDragEnd() {
    this.compressedDropTargetDisposable.dispose();
  }
}, FileDragAndDrop_1 = _a34, _a34.CONFIRM_DND_SETTING_KEY = "explorer.confirmDragAndDrop", _a34);
FileDragAndDrop = FileDragAndDrop_1 = __decorate([
  __param(1, IExplorerService),
  __param(2, IEditorService),
  __param(3, IDialogService),
  __param(4, IWorkspaceContextService),
  __param(5, IFileService),
  __param(6, IConfigurationService),
  __param(7, IInstantiationService),
  __param(8, IWorkspaceEditingService),
  __param(9, IUriIdentityService)
], FileDragAndDrop);
function getIconLabelNameFromHTMLElement(target) {
  if (!(target instanceof HTMLElement)) {
    return null;
  }
  let element = target;
  while (element && !element.classList.contains("monaco-list-row")) {
    if (element.classList.contains("label-name") && element.hasAttribute("data-icon-label-count")) {
      const count = Number(element.getAttribute("data-icon-label-count"));
      const index = Number(element.getAttribute("data-icon-label-index"));
      if (isNumber(count) && isNumber(index)) {
        return { element, count, index };
      }
    }
    element = element.parentElement;
  }
  return null;
}
function isCompressedFolderName(target) {
  return !!getIconLabelNameFromHTMLElement(target);
}
var ExplorerCompressionDelegate = class {
  isIncompressible(stat) {
    return stat.isRoot || !stat.isDirectory || stat instanceof NewExplorerItem || (!stat.parent || stat.parent.isRoot);
  }
};
function getFileOrFolderLabelSuffix(items) {
  if (items.length === 1) {
    return items[0].name;
  }
  if (items.every((i) => i.isDirectory)) {
    return localize("numberOfFolders", "{0} folders", items.length);
  }
  if (items.every((i) => !i.isDirectory)) {
    return localize("numberOfFiles", "{0} files", items.length);
  }
  return `${items.length} files and folders`;
}

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerDecorationsProvider.js
init_errorMessage();
function provideDecorations(fileStat) {
  if (fileStat.isRoot && fileStat.error) {
    return {
      tooltip: localize(
        "canNotResolve",
        "Unable to resolve workspace folder ({0})",
        toErrorMessage(fileStat.error)
      ),
      letter: "!",
      color: listInvalidItemForeground
    };
  }
  if (fileStat.isSymbolicLink) {
    return {
      tooltip: localize("symbolicLlink", "Symbolic Link"),
      letter: ""
    };
  }
  if (fileStat.isUnknown) {
    return {
      tooltip: localize("unknown", "Unknown File Type"),
      letter: "?"
    };
  }
  if (fileStat.isExcluded) {
    return {
      color: listDeemphasizedForeground
    };
  }
  return void 0;
}
var ExplorerDecorationsProvider = class ExplorerDecorationsProvider2 {
  constructor(explorerService, contextService) {
    this.explorerService = explorerService;
    this.label = localize("label", "Explorer");
    this._onDidChange = new Emitter();
    this.toDispose = new DisposableStore();
    this.toDispose.add(this._onDidChange);
    this.toDispose.add(contextService.onDidChangeWorkspaceFolders((e) => {
      this._onDidChange.fire(e.changed.concat(e.added).map((wf) => wf.uri));
    }));
    this.toDispose.add(explorerRootErrorEmitter.event((resource) => {
      this._onDidChange.fire([resource]);
    }));
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  async provideDecorations(resource) {
    const fileStat = this.explorerService.findClosest(resource);
    if (!fileStat) {
      throw new Error("ExplorerItem not found");
    }
    return provideDecorations(fileStat);
  }
  dispose() {
    this.toDispose.dispose();
  }
};
ExplorerDecorationsProvider = __decorate([
  __param(0, IExplorerService),
  __param(1, IWorkspaceContextService)
], ExplorerDecorationsProvider);

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerView.js
init_configuration();
init_instantiation();
init_progress();
init_contextkey();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/views/viewPane.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/views/media/paneviewlet.css.js
var css4 = ".monaco-pane-view .split-view-view:first-of-type>.pane>.pane-header{border-top:none!important}.monaco-pane-view .split-view-view:first-of-type>.pane{border-left:none!important}.monaco-pane-view .pane>.pane-header{position:relative}.monaco-pane-view .pane.expanded>.pane-header>.actions.show-expanded,.monaco-pane-view .pane>.pane-header>.actions.show-always{display:initial}.monaco-pane-view .pane>.pane-header>.icon{display:none;height:16px;width:16px}.monaco-pane-view .pane.pane.horizontal:not(.expanded)>.pane-header>.icon{display:inline;margin-top:4px}.monaco-pane-view .pane>.pane-header h3.title{-webkit-margin-before:0;-webkit-margin-after:0;font-size:11px;min-width:3ch;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-pane-view .pane>.pane-header .description{display:block;flex-shrink:100000;font-weight:400;margin-left:10px;opacity:.6;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}.monaco-pane-view .pane>.pane-header .description .codicon{font-size:9px;margin-left:2px}.monaco-pane-view .pane.horizontal:not(.expanded)>.pane-header .description,.monaco-pane-view .pane.horizontal:not(.expanded)>.pane-header h3.title,.monaco-pane-view .pane>.pane-header:not(.expanded) .description{display:none}.monaco-pane-view .pane .monaco-progress-container{height:2px;left:0;position:absolute;top:-2px;z-index:5}.monaco-pane-view .pane:not(.merged-header) .monaco-progress-container{top:20px}";
n(css4, {});

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/views/viewPane.js
init_nls();
init_event();
init_colorRegistry();
init_dom();
init_lifecycle();
init_actions();
init_platform2();
init_telemetry();
init_themeService();
init_themables();

// node_modules/vscode/vscode/src/vs/base/browser/ui/splitview/paneview.js
init_browser();
init_dom();
init_keyboardEvent();
init_color();
init_event();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/base/browser/ui/splitview/paneview.css.js
var css5 = ".monaco-pane-view{height:100%;width:100%}.monaco-pane-view .pane{display:flex;flex-direction:column;height:100%;overflow:hidden;width:100%}.monaco-pane-view .pane.horizontal:not(.expanded){flex-direction:row}.monaco-pane-view .pane>.pane-header{align-items:center;box-sizing:border-box;cursor:pointer;display:flex;font-size:11px;font-weight:700;height:22px;overflow:hidden}.monaco-pane-view .pane>.pane-header>.title{text-transform:uppercase}.monaco-pane-view .pane.horizontal:not(.expanded)>.pane-header{flex-direction:column;height:100%;width:22px}.monaco-pane-view .pane>.pane-header>.codicon:first-of-type{margin:0 2px}.monaco-pane-view .pane.horizontal:not(.expanded)>.pane-header>.codicon:first-of-type{margin:2px}.monaco-pane-view .pane>.pane-header>.actions{display:none;margin-left:auto}.monaco-pane-view .pane>.pane-header>.actions .action-item{margin-right:4px}.monaco-pane-view .pane>.pane-header>.actions .action-label{padding:2px}.monaco-pane-view .pane:focus-within>.pane-header.expanded>.actions,.monaco-pane-view .pane:hover>.pane-header.expanded>.actions,.monaco-pane-view .pane>.pane-header.actions-always-visible.expanded>.actions,.monaco-pane-view .pane>.pane-header.focused.expanded>.actions{display:initial}.monaco-pane-view .pane>.pane-header .monaco-action-bar .action-item.select-container{cursor:default}.monaco-pane-view .pane>.pane-header .action-item .monaco-select-box{cursor:pointer;min-height:18px;min-width:110px;padding:2px 23px 2px 8px}.linux .monaco-pane-view .pane>.pane-header .action-item .monaco-select-box,.windows .monaco-pane-view .pane>.pane-header .action-item .monaco-select-box{padding:0 23px 0 8px}.monaco-pane-view:lang(ja) .pane>.pane-header,.monaco-pane-view:lang(ko) .pane>.pane-header,.monaco-pane-view:lang(zh-Hans) .pane>.pane-header,.monaco-pane-view:lang(zh-Hant) .pane>.pane-header{font-weight:400}.monaco-pane-view .pane>.pane-header.hidden{display:none}.monaco-pane-view .pane>.pane-body{flex:1;overflow:hidden}.monaco-pane-view.animated .split-view-view{transition-duration:.15s;transition-timing-function:ease-out}.reduce-motion .monaco-pane-view .split-view-view{transition-duration:0s!important}.monaco-pane-view.animated.vertical .split-view-view{transition-property:height}.monaco-pane-view.animated.horizontal .split-view-view{transition-property:width}#monaco-pane-drop-overlay{box-sizing:border-box;height:100%;left:0;position:absolute;width:100%;z-index:10000}#monaco-pane-drop-overlay>.pane-overlay-indicator{height:100%;min-height:22px;min-width:19px;pointer-events:none;position:absolute;transition:opacity .15s ease-out;width:100%}#monaco-pane-drop-overlay>.pane-overlay-indicator.overlay-move-transition{transition:top 70ms ease-out,left 70ms ease-out,width 70ms ease-out,height 70ms ease-out,opacity .15s ease-out}";
n(css5, {});

// node_modules/vscode/vscode/src/vs/base/browser/ui/splitview/paneview.js
init_nls();
var _Pane = class _Pane extends Disposable {
  get ariaHeaderLabel() {
    return this._ariaHeaderLabel;
  }
  set ariaHeaderLabel(newLabel) {
    this._ariaHeaderLabel = newLabel;
    this.header.setAttribute("aria-label", this.ariaHeaderLabel);
  }
  get draggableElement() {
    return this.header;
  }
  get dropTargetElement() {
    return this.element;
  }
  get dropBackground() {
    return this.styles.dropBackground;
  }
  get minimumBodySize() {
    return this._minimumBodySize;
  }
  set minimumBodySize(size) {
    this._minimumBodySize = size;
    this._onDidChange.fire(void 0);
  }
  get maximumBodySize() {
    return this._maximumBodySize;
  }
  set maximumBodySize(size) {
    this._maximumBodySize = size;
    this._onDidChange.fire(void 0);
  }
  get headerSize() {
    return this.headerVisible ? _Pane.HEADER_SIZE : 0;
  }
  get minimumSize() {
    const headerSize = this.headerSize;
    const expanded = !this.headerVisible || this.isExpanded();
    const minimumBodySize = expanded ? this.minimumBodySize : 0;
    return headerSize + minimumBodySize;
  }
  get maximumSize() {
    const headerSize = this.headerSize;
    const expanded = !this.headerVisible || this.isExpanded();
    const maximumBodySize = expanded ? this.maximumBodySize : 0;
    return headerSize + maximumBodySize;
  }
  constructor(options) {
    super();
    this.expandedSize = void 0;
    this._headerVisible = true;
    this._bodyRendered = false;
    this.styles = {
      dropBackground: void 0,
      headerBackground: void 0,
      headerBorder: void 0,
      headerForeground: void 0,
      leftBorder: void 0
    };
    this.animationTimer = void 0;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._onDidChangeExpansionState = this._register(new Emitter());
    this.onDidChangeExpansionState = this._onDidChangeExpansionState.event;
    this.orthogonalSize = 0;
    this._expanded = typeof options.expanded === "undefined" ? true : !!options.expanded;
    this._orientation = typeof options.orientation === "undefined" ? 0 : options.orientation;
    this._ariaHeaderLabel = localize("viewSection", "{0} Section", options.title);
    this._minimumBodySize = typeof options.minimumBodySize === "number" ? options.minimumBodySize : this._orientation === 1 ? 200 : 120;
    this._maximumBodySize = typeof options.maximumBodySize === "number" ? options.maximumBodySize : Number.POSITIVE_INFINITY;
    this.element = $(".pane");
  }
  isExpanded() {
    return this._expanded;
  }
  setExpanded(expanded) {
    var _a43;
    if (this._expanded === !!expanded) {
      return false;
    }
    (_a43 = this.element) == null ? void 0 : _a43.classList.toggle("expanded", expanded);
    this._expanded = !!expanded;
    this.updateHeader();
    if (expanded) {
      if (!this._bodyRendered) {
        this.renderBody(this.body);
        this._bodyRendered = true;
      }
      if (typeof this.animationTimer === "number") {
        clearTimeout(this.animationTimer);
      }
      append(this.element, this.body);
    } else {
      this.animationTimer = window.setTimeout(() => {
        this.body.remove();
      }, 200);
    }
    this._onDidChangeExpansionState.fire(expanded);
    this._onDidChange.fire(expanded ? this.expandedSize : void 0);
    return true;
  }
  get headerVisible() {
    return this._headerVisible;
  }
  set headerVisible(visible) {
    if (this._headerVisible === !!visible) {
      return;
    }
    this._headerVisible = !!visible;
    this.updateHeader();
    this._onDidChange.fire(void 0);
  }
  get orientation() {
    return this._orientation;
  }
  set orientation(orientation) {
    if (this._orientation === orientation) {
      return;
    }
    this._orientation = orientation;
    if (this.element) {
      this.element.classList.toggle("horizontal", this.orientation === 1);
      this.element.classList.toggle("vertical", this.orientation === 0);
    }
    if (this.header) {
      this.updateHeader();
    }
  }
  render() {
    this.element.classList.toggle("expanded", this.isExpanded());
    this.element.classList.toggle("horizontal", this.orientation === 1);
    this.element.classList.toggle("vertical", this.orientation === 0);
    this.header = $(".pane-header");
    append(this.element, this.header);
    this.header.setAttribute("tabindex", "0");
    this.header.setAttribute("role", "button");
    this.header.setAttribute("aria-label", this.ariaHeaderLabel);
    this.renderHeader(this.header);
    const focusTracker = trackFocus(this.header);
    this._register(focusTracker);
    this._register(focusTracker.onDidFocus(() => this.header.classList.add("focused"), null));
    this._register(focusTracker.onDidBlur(() => this.header.classList.remove("focused"), null));
    this.updateHeader();
    const eventDisposables = this._register(new DisposableStore());
    const onKeyDown = this._register(new DomEmitter(this.header, "keydown"));
    const onHeaderKeyDown = Event.map(onKeyDown.event, (e) => new StandardKeyboardEvent(e), eventDisposables);
    this._register(Event.filter(onHeaderKeyDown, (e) => e.keyCode === 3 || e.keyCode === 10, eventDisposables)(() => this.setExpanded(!this.isExpanded()), null));
    this._register(Event.filter(onHeaderKeyDown, (e) => e.keyCode === 15, eventDisposables)(() => this.setExpanded(false), null));
    this._register(Event.filter(onHeaderKeyDown, (e) => e.keyCode === 17, eventDisposables)(() => this.setExpanded(true), null));
    this._register(Gesture.addTarget(this.header));
    [EventType.CLICK, EventType2.Tap].forEach((eventType) => {
      this._register(addDisposableListener(this.header, eventType, (e) => {
        if (!e.defaultPrevented) {
          this.setExpanded(!this.isExpanded());
        }
      }));
    });
    this.body = append(this.element, $(".pane-body"));
    if (!this._bodyRendered && this.isExpanded()) {
      this.renderBody(this.body);
      this._bodyRendered = true;
    }
    if (!this.isExpanded()) {
      this.body.remove();
    }
  }
  layout(size) {
    const headerSize = this.headerVisible ? _Pane.HEADER_SIZE : 0;
    const width = this._orientation === 0 ? this.orthogonalSize : size;
    const height = this._orientation === 0 ? size - headerSize : this.orthogonalSize - headerSize;
    if (this.isExpanded()) {
      this.body.classList.toggle("wide", width >= 600);
      this.layoutBody(height, width);
      this.expandedSize = size;
    }
  }
  style(styles) {
    this.styles = styles;
    if (!this.header) {
      return;
    }
    this.updateHeader();
  }
  updateHeader() {
    const expanded = !this.headerVisible || this.isExpanded();
    this.header.style.lineHeight = `${this.headerSize}px`;
    this.header.classList.toggle("hidden", !this.headerVisible);
    this.header.classList.toggle("expanded", expanded);
    this.header.setAttribute("aria-expanded", String(expanded));
    this.header.style.color = this.styles.headerForeground ?? "";
    this.header.style.backgroundColor = this.styles.headerBackground ?? "";
    this.header.style.borderTop = this.styles.headerBorder && this.orientation === 0 ? `1px solid ${this.styles.headerBorder}` : "";
    this.element.style.borderLeft = this.styles.leftBorder && this.orientation === 1 ? `1px solid ${this.styles.leftBorder}` : "";
  }
};
_Pane.HEADER_SIZE = 22;
var Pane = _Pane;
var _PaneDraggable = class _PaneDraggable extends Disposable {
  constructor(pane, dnd, context) {
    super();
    this.pane = pane;
    this.dnd = dnd;
    this.context = context;
    this.dragOverCounter = 0;
    this._onDidDrop = this._register(new Emitter());
    this.onDidDrop = this._onDidDrop.event;
    pane.draggableElement.draggable = true;
    this._register(addDisposableListener(pane.draggableElement, "dragstart", (e) => this.onDragStart(e)));
    this._register(addDisposableListener(pane.dropTargetElement, "dragenter", (e) => this.onDragEnter(e)));
    this._register(addDisposableListener(pane.dropTargetElement, "dragleave", (e) => this.onDragLeave(e)));
    this._register(addDisposableListener(pane.dropTargetElement, "dragend", (e) => this.onDragEnd(e)));
    this._register(addDisposableListener(pane.dropTargetElement, "drop", (e) => this.onDrop(e)));
  }
  onDragStart(e) {
    var _a43;
    if (!this.dnd.canDrag(this.pane) || !e.dataTransfer) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    e.dataTransfer.effectAllowed = "move";
    if (isFirefox) {
      (_a43 = e.dataTransfer) == null ? void 0 : _a43.setData(DataTransfers.TEXT, this.pane.draggableElement.textContent || "");
    }
    const dragImage = append(document.body, $(".monaco-drag-image", {}, this.pane.draggableElement.textContent || ""));
    e.dataTransfer.setDragImage(dragImage, -10, -10);
    setTimeout(() => document.body.removeChild(dragImage), 0);
    this.context.draggable = this;
  }
  onDragEnter(e) {
    if (!this.context.draggable || this.context.draggable === this) {
      return;
    }
    if (!this.dnd.canDrop(this.context.draggable.pane, this.pane)) {
      return;
    }
    this.dragOverCounter++;
    this.render();
  }
  onDragLeave(e) {
    if (!this.context.draggable || this.context.draggable === this) {
      return;
    }
    if (!this.dnd.canDrop(this.context.draggable.pane, this.pane)) {
      return;
    }
    this.dragOverCounter--;
    if (this.dragOverCounter === 0) {
      this.render();
    }
  }
  onDragEnd(e) {
    if (!this.context.draggable) {
      return;
    }
    this.dragOverCounter = 0;
    this.render();
    this.context.draggable = null;
  }
  onDrop(e) {
    if (!this.context.draggable) {
      return;
    }
    EventHelper.stop(e);
    this.dragOverCounter = 0;
    this.render();
    if (this.dnd.canDrop(this.context.draggable.pane, this.pane) && this.context.draggable !== this) {
      this._onDidDrop.fire({ from: this.context.draggable.pane, to: this.pane });
    }
    this.context.draggable = null;
  }
  render() {
    let backgroundColor = null;
    if (this.dragOverCounter > 0) {
      backgroundColor = this.pane.dropBackground ?? _PaneDraggable.DefaultDragOverBackgroundColor.toString();
    }
    this.pane.dropTargetElement.style.backgroundColor = backgroundColor || "";
  }
};
_PaneDraggable.DefaultDragOverBackgroundColor = new Color(new RGBA(128, 128, 128, 0.5));
var PaneDraggable = _PaneDraggable;
var PaneView = class extends Disposable {
  constructor(container, options = {}) {
    super();
    this.dndContext = { draggable: null };
    this.paneItems = [];
    this.orthogonalSize = 0;
    this.size = 0;
    this.animationTimer = void 0;
    this._onDidDrop = this._register(new Emitter());
    this.onDidDrop = this._onDidDrop.event;
    this.dnd = options.dnd;
    this.orientation = options.orientation ?? 0;
    this.element = append(container, $(".monaco-pane-view"));
    this.splitview = this._register(new SplitView(this.element, { orientation: this.orientation }));
    this.onDidSashReset = this.splitview.onDidSashReset;
    this.onDidSashChange = this.splitview.onDidSashChange;
    this.onDidScroll = this.splitview.onDidScroll;
    const eventDisposables = this._register(new DisposableStore());
    const onKeyDown = this._register(new DomEmitter(this.element, "keydown"));
    const onHeaderKeyDown = Event.map(
      Event.filter(onKeyDown.event, (e) => e.target instanceof HTMLElement && e.target.classList.contains("pane-header"), eventDisposables),
      (e) => new StandardKeyboardEvent(e),
      eventDisposables
    );
    this._register(Event.filter(onHeaderKeyDown, (e) => e.keyCode === 16, eventDisposables)(() => this.focusPrevious()));
    this._register(Event.filter(onHeaderKeyDown, (e) => e.keyCode === 18, eventDisposables)(() => this.focusNext()));
  }
  addPane(pane, size, index = this.splitview.length) {
    const disposables = new DisposableStore();
    pane.onDidChangeExpansionState(this.setupAnimation, this, disposables);
    const paneItem = { pane, disposable: disposables };
    this.paneItems.splice(index, 0, paneItem);
    pane.orientation = this.orientation;
    pane.orthogonalSize = this.orthogonalSize;
    this.splitview.addView(pane, size, index);
    if (this.dnd) {
      const draggable = new PaneDraggable(pane, this.dnd, this.dndContext);
      disposables.add(draggable);
      disposables.add(draggable.onDidDrop(this._onDidDrop.fire, this._onDidDrop));
    }
  }
  removePane(pane) {
    const index = this.paneItems.findIndex((item) => item.pane === pane);
    if (index === -1) {
      return;
    }
    this.splitview.removeView(index, pane.isExpanded() ? Sizing.Distribute : void 0);
    const paneItem = this.paneItems.splice(index, 1)[0];
    paneItem.disposable.dispose();
  }
  movePane(from, to) {
    const fromIndex = this.paneItems.findIndex((item) => item.pane === from);
    const toIndex = this.paneItems.findIndex((item) => item.pane === to);
    if (fromIndex === -1 || toIndex === -1) {
      return;
    }
    const [paneItem] = this.paneItems.splice(fromIndex, 1);
    this.paneItems.splice(toIndex, 0, paneItem);
    this.splitview.moveView(fromIndex, toIndex);
  }
  resizePane(pane, size) {
    const index = this.paneItems.findIndex((item) => item.pane === pane);
    if (index === -1) {
      return;
    }
    this.splitview.resizeView(index, size);
  }
  getPaneSize(pane) {
    const index = this.paneItems.findIndex((item) => item.pane === pane);
    if (index === -1) {
      return -1;
    }
    return this.splitview.getViewSize(index);
  }
  layout(height, width) {
    this.orthogonalSize = this.orientation === 0 ? width : height;
    this.size = this.orientation === 1 ? width : height;
    for (const paneItem of this.paneItems) {
      paneItem.pane.orthogonalSize = this.orthogonalSize;
    }
    this.splitview.layout(this.size);
  }
  setBoundarySashes(sashes) {
    this.boundarySashes = sashes;
    this.updateSplitviewOrthogonalSashes(sashes);
  }
  updateSplitviewOrthogonalSashes(sashes) {
    if (this.orientation === 0) {
      this.splitview.orthogonalStartSash = sashes == null ? void 0 : sashes.left;
      this.splitview.orthogonalEndSash = sashes == null ? void 0 : sashes.right;
    } else {
      this.splitview.orthogonalEndSash = sashes == null ? void 0 : sashes.bottom;
    }
  }
  flipOrientation(height, width) {
    this.orientation = this.orientation === 0 ? 1 : 0;
    const paneSizes = this.paneItems.map((pane) => this.getPaneSize(pane.pane));
    this.splitview.dispose();
    clearNode(this.element);
    this.splitview = this._register(new SplitView(this.element, { orientation: this.orientation }));
    this.updateSplitviewOrthogonalSashes(this.boundarySashes);
    const newOrthogonalSize = this.orientation === 0 ? width : height;
    const newSize = this.orientation === 1 ? width : height;
    this.paneItems.forEach((pane, index) => {
      pane.pane.orthogonalSize = newOrthogonalSize;
      pane.pane.orientation = this.orientation;
      const viewSize = this.size === 0 ? 0 : newSize * paneSizes[index] / this.size;
      this.splitview.addView(pane.pane, viewSize, index);
    });
    this.size = newSize;
    this.orthogonalSize = newOrthogonalSize;
    this.splitview.layout(this.size);
  }
  setupAnimation() {
    if (typeof this.animationTimer === "number") {
      window.clearTimeout(this.animationTimer);
    }
    this.element.classList.add("animated");
    this.animationTimer = window.setTimeout(() => {
      this.animationTimer = void 0;
      this.element.classList.remove("animated");
    }, 200);
  }
  getPaneHeaderElements() {
    return [...this.element.querySelectorAll(".pane-header")];
  }
  focusPrevious() {
    const headers = this.getPaneHeaderElements();
    const index = headers.indexOf(document.activeElement);
    if (index === -1) {
      return;
    }
    headers[Math.max(index - 1, 0)].focus();
  }
  focusNext() {
    const headers = this.getPaneHeaderElements();
    const index = headers.indexOf(document.activeElement);
    if (index === -1) {
      return;
    }
    headers[Math.min(index + 1, headers.length - 1)].focus();
  }
  dispose() {
    super.dispose();
    this.paneItems.forEach((i) => i.disposable.dispose());
  }
};

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/views/viewPane.js
init_configuration();
init_contextkey();
init_types();
init_instantiation();
init_actions2();
init_opener();

// node_modules/vscode/vscode/src/vs/workbench/services/progress/browser/progressIndicator.js
init_event();
init_lifecycle();
init_progress();
var ProgressIndicatorState;
(function(ProgressIndicatorState2) {
  (function(Type) {
    Type[Type["None"] = 0] = "None";
    Type[Type["Done"] = 1] = "Done";
    Type[Type["Infinite"] = 2] = "Infinite";
    Type[Type["While"] = 3] = "While";
    Type[Type["Work"] = 4] = "Work";
  })(ProgressIndicatorState2.Type || (ProgressIndicatorState2.Type = {}));
  ProgressIndicatorState2.None = { type: 0 };
  ProgressIndicatorState2.Done = { type: 1 };
  ProgressIndicatorState2.Infinite = { type: 2 };
  class While {
    constructor(whilePromise, whileStart, whileDelay) {
      this.whilePromise = whilePromise;
      this.whileStart = whileStart;
      this.whileDelay = whileDelay;
      this.type = 3;
    }
  }
  ProgressIndicatorState2.While = While;
  class Work {
    constructor(total, worked) {
      this.total = total;
      this.worked = worked;
      this.type = 4;
    }
  }
  ProgressIndicatorState2.Work = Work;
})(ProgressIndicatorState || (ProgressIndicatorState = {}));
var ScopedProgressIndicator = class extends Disposable {
  constructor(progressBar, scope) {
    super();
    this.progressBar = progressBar;
    this.scope = scope;
    this.progressState = ProgressIndicatorState.None;
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.scope.onDidChangeActive(() => {
      if (this.scope.isActive) {
        this.onDidScopeActivate();
      } else {
        this.onDidScopeDeactivate();
      }
    }));
  }
  onDidScopeActivate() {
    if (this.progressState.type === ProgressIndicatorState.Done.type) {
      return;
    }
    if (this.progressState.type === 3) {
      let delay;
      if (this.progressState.whileDelay > 0) {
        const remainingDelay = this.progressState.whileDelay - (Date.now() - this.progressState.whileStart);
        if (remainingDelay > 0) {
          delay = remainingDelay;
        }
      }
      this.doShowWhile(delay);
    } else if (this.progressState.type === 2) {
      this.progressBar.infinite().show();
    } else if (this.progressState.type === 4) {
      if (this.progressState.total) {
        this.progressBar.total(this.progressState.total).show();
      }
      if (this.progressState.worked) {
        this.progressBar.worked(this.progressState.worked).show();
      }
    }
  }
  onDidScopeDeactivate() {
    this.progressBar.stop().hide();
  }
  show(infiniteOrTotal, delay) {
    if (typeof infiniteOrTotal === "boolean") {
      this.progressState = ProgressIndicatorState.Infinite;
    } else {
      this.progressState = new ProgressIndicatorState.Work(infiniteOrTotal, void 0);
    }
    if (this.scope.isActive) {
      if (this.progressState.type === 2) {
        this.progressBar.infinite().show(delay);
      } else if (this.progressState.type === 4 && typeof this.progressState.total === "number") {
        this.progressBar.total(this.progressState.total).show(delay);
      }
    }
    return {
      total: (total) => {
        this.progressState = new ProgressIndicatorState.Work(total, this.progressState.type === 4 ? this.progressState.worked : void 0);
        if (this.scope.isActive) {
          this.progressBar.total(total);
        }
      },
      worked: (worked) => {
        if (!this.scope.isActive || this.progressBar.hasTotal()) {
          this.progressState = new ProgressIndicatorState.Work(this.progressState.type === 4 ? this.progressState.total : void 0, this.progressState.type === 4 && typeof this.progressState.worked === "number" ? this.progressState.worked + worked : worked);
          if (this.scope.isActive) {
            this.progressBar.worked(worked);
          }
        } else {
          this.progressState = ProgressIndicatorState.Infinite;
          this.progressBar.infinite().show();
        }
      },
      done: () => {
        this.progressState = ProgressIndicatorState.Done;
        if (this.scope.isActive) {
          this.progressBar.stop().hide();
        }
      }
    };
  }
  async showWhile(promise, delay) {
    if (this.progressState.type === 3) {
      promise = Promise.all([promise, this.progressState.whilePromise]);
    }
    this.progressState = new ProgressIndicatorState.While(promise, delay || 0, Date.now());
    try {
      this.doShowWhile(delay);
      await promise;
    } catch (error) {
    } finally {
      if (this.progressState.type !== 3 || this.progressState.whilePromise === promise) {
        this.progressState = ProgressIndicatorState.None;
        if (this.scope.isActive) {
          this.progressBar.stop().hide();
        }
      }
    }
  }
  doShowWhile(delay) {
    if (this.scope.isActive) {
      this.progressBar.infinite().show(delay);
    }
  }
};
var AbstractProgressScope = class extends Disposable {
  get isActive() {
    return this._isActive;
  }
  constructor(scopeId, _isActive) {
    super();
    this.scopeId = scopeId;
    this._isActive = _isActive;
    this._onDidChangeActive = this._register(new Emitter());
    this.onDidChangeActive = this._onDidChangeActive.event;
  }
  onScopeOpened(scopeId) {
    if (scopeId === this.scopeId) {
      if (!this._isActive) {
        this._isActive = true;
        this._onDidChangeActive.fire();
      }
    }
  }
  onScopeClosed(scopeId) {
    if (scopeId === this.scopeId) {
      if (this._isActive) {
        this._isActive = false;
        this._onDidChangeActive.fire();
      }
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/views/viewPane.js
init_uri();
init_codicons();

// node_modules/vscode/vscode/src/vs/workbench/browser/actions.js
init_tslib_es6();
init_lifecycle();
init_event();
init_actions2();
init_contextkey();
var MenuActions = class extends Disposable {
  get primaryActions() {
    return this._primaryActions;
  }
  get secondaryActions() {
    return this._secondaryActions;
  }
  constructor(menuId, options, menuService, contextKeyService) {
    super();
    this.options = options;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this._primaryActions = [];
    this._secondaryActions = [];
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.disposables = this._register(new DisposableStore());
    this.menu = this._register(menuService.createMenu(menuId, contextKeyService));
    this._register(this.menu.onDidChange(() => this.updateActions()));
    this.updateActions();
  }
  updateActions() {
    this.disposables.clear();
    this._primaryActions = [];
    this._secondaryActions = [];
    createAndFillInActionBarActions(this.menu, this.options, { primary: this._primaryActions, secondary: this._secondaryActions });
    this.disposables.add(this.updateSubmenus([...this._primaryActions, ...this._secondaryActions], {}));
    this._onDidChange.fire();
  }
  updateSubmenus(actions, submenus) {
    const disposables = new DisposableStore();
    for (const action of actions) {
      if (action instanceof SubmenuItemAction && !submenus[action.item.submenu.id]) {
        const menu = submenus[action.item.submenu.id] = disposables.add(this.menuService.createMenu(action.item.submenu, this.contextKeyService));
        disposables.add(menu.onDidChange(() => this.updateActions()));
        disposables.add(this.updateSubmenus(action.actions, submenus));
      }
    }
    return disposables;
  }
};
var CompositeMenuActions = class CompositeMenuActions2 extends Disposable {
  constructor(menuId, contextMenuId, options, contextKeyService, menuService) {
    super();
    this.menuId = menuId;
    this.contextMenuId = contextMenuId;
    this.options = options;
    this.contextKeyService = contextKeyService;
    this.menuService = menuService;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.menuActions = this._register(new MenuActions(menuId, this.options, menuService, contextKeyService));
    this._register(this.menuActions.onDidChange(() => this._onDidChange.fire()));
  }
  getPrimaryActions() {
    return this.menuActions.primaryActions;
  }
  getSecondaryActions() {
    return this.menuActions.secondaryActions;
  }
  getContextMenuActions() {
    const actions = [];
    if (this.contextMenuId) {
      const menu = this.menuService.createMenu(this.contextMenuId, this.contextKeyService);
      createAndFillInActionBarActions(menu, this.options, { primary: [], secondary: actions });
      menu.dispose();
    }
    return actions;
  }
};
CompositeMenuActions = __decorate([
  __param(3, IContextKeyService),
  __param(4, IMenuService)
], CompositeMenuActions);

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/views/viewFilter.js
init_tslib_es6();
init_async();
init_dom();
init_lifecycle();
init_colorRegistry();
init_nls();
init_instantiation();
init_contextkey();
init_codicons();
init_actions2();
init_event();
var viewFilterMenu = new MenuId("menu.view.filter");
var viewFilterSubmenu = new MenuId("submenu.view.filter");
MenuRegistry.appendMenuItem(viewFilterMenu, {
  submenu: viewFilterSubmenu,
  title: localize("more filters", "More Filters..."),
  group: "navigation",
  icon: Codicon.filter
});
var MoreFiltersActionViewItem = class extends SubmenuEntryActionViewItem {
  constructor() {
    super(...arguments);
    this._checked = false;
  }
  set checked(checked) {
    if (this._checked !== checked) {
      this._checked = checked;
      this.updateChecked();
    }
  }
  updateChecked() {
    if (this.element) {
      this.element.classList.toggle("checked", this._checked);
    }
  }
  render(container) {
    super.render(container);
    this.updateChecked();
  }
};
var FilterWidget = class FilterWidget2 extends Widget {
  get onDidFocus() {
    return this.focusTracker.onDidFocus;
  }
  get onDidBlur() {
    return this.focusTracker.onDidBlur;
  }
  constructor(options, instantiationService, contextViewService, contextKeyService, keybindingService) {
    super();
    this.options = options;
    this.instantiationService = instantiationService;
    this.contextViewService = contextViewService;
    this.keybindingService = keybindingService;
    this._onDidChangeFilterText = this._register(new Emitter());
    this.onDidChangeFilterText = this._onDidChangeFilterText.event;
    this.isMoreFiltersChecked = false;
    this.delayedFilterUpdate = new Delayer(400);
    this._register(toDisposable(() => this.delayedFilterUpdate.cancel()));
    if (options.focusContextKey) {
      this.focusContextKey = new RawContextKey(options.focusContextKey, false).bindTo(contextKeyService);
    }
    this.element = $(".viewpane-filter");
    [this.filterInputBox, this.focusTracker] = this.createInput(this.element);
    const controlsContainer = append(this.element, $(".viewpane-filter-controls"));
    this.filterBadge = this.createBadge(controlsContainer);
    this.toolbar = this._register(this.createToolBar(controlsContainer));
    this.adjustInputBox();
  }
  hasFocus() {
    return this.filterInputBox.hasFocus();
  }
  focus() {
    this.filterInputBox.focus();
  }
  blur() {
    this.filterInputBox.blur();
  }
  updateBadge(message) {
    this.filterBadge.classList.toggle("hidden", !message);
    this.filterBadge.textContent = message || "";
    this.adjustInputBox();
  }
  setFilterText(filterText) {
    this.filterInputBox.value = filterText;
  }
  getFilterText() {
    return this.filterInputBox.value;
  }
  getHistory() {
    return this.filterInputBox.getHistory();
  }
  layout(width) {
    var _a43;
    (_a43 = this.element.parentElement) == null ? void 0 : _a43.classList.toggle("grow", width > 700);
    this.element.classList.toggle("small", width < 400);
    this.adjustInputBox();
  }
  checkMoreFilters(checked) {
    this.isMoreFiltersChecked = checked;
    if (this.moreFiltersActionViewItem) {
      this.moreFiltersActionViewItem.checked = checked;
    }
  }
  createInput(container) {
    const inputBox = this._register(this.instantiationService.createInstance(ContextScopedHistoryInputBox, container, this.contextViewService, {
      placeholder: this.options.placeholder,
      ariaLabel: this.options.ariaLabel,
      history: this.options.history || [],
      showHistoryHint: () => showHistoryKeybindingHint(this.keybindingService),
      inputBoxStyles: defaultInputBoxStyles
    }));
    if (this.options.text) {
      inputBox.value = this.options.text;
    }
    this._register(inputBox.onDidChange((filter) => this.delayedFilterUpdate.trigger(() => this.onDidInputChange(inputBox))));
    this._register(addStandardDisposableListener(inputBox.inputElement, EventType.KEY_DOWN, (e) => this.onInputKeyDown(e, inputBox)));
    this._register(addStandardDisposableListener(container, EventType.KEY_DOWN, this.handleKeyboardEvent));
    this._register(addStandardDisposableListener(container, EventType.KEY_UP, this.handleKeyboardEvent));
    this._register(addStandardDisposableListener(inputBox.inputElement, EventType.CLICK, (e) => {
      e.stopPropagation();
      e.preventDefault();
    }));
    const focusTracker = this._register(trackFocus(inputBox.inputElement));
    if (this.focusContextKey) {
      this._register(focusTracker.onDidFocus(() => this.focusContextKey.set(true)));
      this._register(focusTracker.onDidBlur(() => this.focusContextKey.set(false)));
      this._register(toDisposable(() => this.focusContextKey.reset()));
    }
    return [inputBox, focusTracker];
  }
  createBadge(container) {
    const filterBadge = append(container, $(".viewpane-filter-badge.hidden"));
    filterBadge.style.backgroundColor = asCssVariable(badgeBackground);
    filterBadge.style.color = asCssVariable(badgeForeground);
    filterBadge.style.border = `1px solid ${asCssVariable(contrastBorder)}`;
    return filterBadge;
  }
  createToolBar(container) {
    return this.instantiationService.createInstance(MenuWorkbenchToolBar, container, viewFilterMenu, {
      hiddenItemStrategy: -1,
      actionViewItemProvider: (action) => {
        if (action instanceof SubmenuItemAction && action.item.submenu.id === viewFilterSubmenu.id) {
          this.moreFiltersActionViewItem = this.instantiationService.createInstance(MoreFiltersActionViewItem, action, void 0);
          this.moreFiltersActionViewItem.checked = this.isMoreFiltersChecked;
          return this.moreFiltersActionViewItem;
        }
        return void 0;
      }
    });
  }
  onDidInputChange(inputbox) {
    inputbox.addToHistory();
    this._onDidChangeFilterText.fire(inputbox.value);
  }
  adjustInputBox() {
    this.filterInputBox.inputElement.style.paddingRight = this.element.classList.contains("small") || this.filterBadge.classList.contains("hidden") ? "25px" : "150px";
  }
  handleKeyboardEvent(event) {
    if (event.equals(10) || event.equals(15) || event.equals(17)) {
      event.stopPropagation();
    }
  }
  onInputKeyDown(event, filterInputBox) {
    let handled = false;
    if (event.equals(2) && !this.toolbar.isEmpty()) {
      this.toolbar.focus();
      handled = true;
    }
    if (handled) {
      event.stopPropagation();
      event.preventDefault();
    }
  }
};
FilterWidget = __decorate([
  __param(1, IInstantiationService),
  __param(2, IContextViewService),
  __param(3, IContextKeyService),
  __param(4, IKeybindingService)
], FilterWidget);

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/views/viewPane.js
var ViewPane_1;
var ViewPaneShowActions;
(function(ViewPaneShowActions2) {
  ViewPaneShowActions2[ViewPaneShowActions2["Default"] = 0] = "Default";
  ViewPaneShowActions2[ViewPaneShowActions2["WhenExpanded"] = 1] = "WhenExpanded";
  ViewPaneShowActions2[ViewPaneShowActions2["Always"] = 2] = "Always";
})(ViewPaneShowActions || (ViewPaneShowActions = {}));
var VIEWPANE_FILTER_ACTION = new Action("viewpane.action.filter");
var viewPaneContainerExpandedIcon = registerIcon("view-pane-container-expanded", Codicon.chevronDown, localize(
  "viewPaneContainerExpandedIcon",
  "Icon for an expanded view pane container."
));
var viewPaneContainerCollapsedIcon = registerIcon("view-pane-container-collapsed", Codicon.chevronRight, localize(
  "viewPaneContainerCollapsedIcon",
  "Icon for a collapsed view pane container."
));
var viewsRegistry = Registry.as(Extensions5.ViewsRegistry);
var ViewWelcomeController = class ViewWelcomeController2 {
  get contents() {
    const visibleItems = this.items.filter((v) => v.visible);
    if (visibleItems.length === 0 && this.defaultItem) {
      return [this.defaultItem.descriptor];
    }
    return visibleItems.map((v) => v.descriptor);
  }
  constructor(id, contextKeyService) {
    this.id = id;
    this.contextKeyService = contextKeyService;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this.items = [];
    this.disposables = new DisposableStore();
    contextKeyService.onDidChangeContext(this.onDidChangeContext, this, this.disposables);
    Event.filter(viewsRegistry.onDidChangeViewWelcomeContent, (id2) => id2 === this.id)(this.onDidChangeViewWelcomeContent, this, this.disposables);
    this.onDidChangeViewWelcomeContent();
  }
  onDidChangeViewWelcomeContent() {
    const descriptors = viewsRegistry.getViewWelcomeContent(this.id);
    this.items = [];
    for (const descriptor of descriptors) {
      if (descriptor.when === "default") {
        this.defaultItem = { descriptor, visible: true };
      } else {
        const visible = descriptor.when ? this.contextKeyService.contextMatchesRules(descriptor.when) : true;
        this.items.push({ descriptor, visible });
      }
    }
    this._onDidChange.fire();
  }
  onDidChangeContext() {
    let didChange = false;
    for (const item of this.items) {
      if (!item.descriptor.when || item.descriptor.when === "default") {
        continue;
      }
      const visible = this.contextKeyService.contextMatchesRules(item.descriptor.when);
      if (item.visible === visible) {
        continue;
      }
      item.visible = visible;
      didChange = true;
    }
    if (didChange) {
      this._onDidChange.fire();
    }
  }
  dispose() {
    this.disposables.dispose();
  }
};
ViewWelcomeController = __decorate([
  __param(1, IContextKeyService)
], ViewWelcomeController);
var _a35;
var ViewPane = (_a35 = class extends Pane {
  get title() {
    return this._title;
  }
  get titleDescription() {
    return this._titleDescription;
  }
  constructor(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService) {
    super({ ...options, ...{ orientation: viewDescriptorService.getViewLocationById(options.id) === 1 ? 1 : 0 } });
    this.keybindingService = keybindingService;
    this.contextMenuService = contextMenuService;
    this.configurationService = configurationService;
    this.contextKeyService = contextKeyService;
    this.viewDescriptorService = viewDescriptorService;
    this.instantiationService = instantiationService;
    this.openerService = openerService;
    this.themeService = themeService;
    this.telemetryService = telemetryService;
    this._onDidFocus = this._register(new Emitter());
    this.onDidFocus = this._onDidFocus.event;
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    this._onDidChangeBodyVisibility = this._register(new Emitter());
    this.onDidChangeBodyVisibility = this._onDidChangeBodyVisibility.event;
    this._onDidChangeTitleArea = this._register(new Emitter());
    this.onDidChangeTitleArea = this._onDidChangeTitleArea.event;
    this._onDidChangeViewWelcomeState = this._register(new Emitter());
    this.onDidChangeViewWelcomeState = this._onDidChangeViewWelcomeState.event;
    this._isVisible = false;
    this.viewWelcomeDisposable = Disposable.None;
    this.id = options.id;
    this._title = options.title;
    this._titleDescription = options.titleDescription;
    this.showActions = options.showActions ?? ViewPaneShowActions.Default;
    this.scopedContextKeyService = this._register(contextKeyService.createScoped(this.element));
    this.scopedContextKeyService.createKey("view", this.id);
    const viewLocationKey = this.scopedContextKeyService.createKey("viewLocation", ViewContainerLocationToString(viewDescriptorService.getViewLocationById(this.id)));
    this._register(Event.filter(viewDescriptorService.onDidChangeLocation, (e) => e.views.some((view) => view.id === this.id))(() => viewLocationKey.set(ViewContainerLocationToString(viewDescriptorService.getViewLocationById(this.id)))));
    this.menuActions = this._register(this.instantiationService.createChild(new ServiceCollection([IContextKeyService, this.scopedContextKeyService])).createInstance(CompositeMenuActions, options.titleMenuId ?? MenuId.ViewTitle, MenuId.ViewTitleContext, { shouldForwardArgs: !options.donotForwardArgs }));
    this._register(this.menuActions.onDidChange(() => this.updateActions()));
    this.viewWelcomeController = new ViewWelcomeController(this.id, contextKeyService);
  }
  get headerVisible() {
    return super.headerVisible;
  }
  set headerVisible(visible) {
    super.headerVisible = visible;
    this.element.classList.toggle("merged-header", !visible);
  }
  setVisible(visible) {
    if (this._isVisible !== visible) {
      this._isVisible = visible;
      if (this.isExpanded()) {
        this._onDidChangeBodyVisibility.fire(visible);
      }
    }
  }
  isVisible() {
    return this._isVisible;
  }
  isBodyVisible() {
    return this._isVisible && this.isExpanded();
  }
  setExpanded(expanded) {
    const changed = super.setExpanded(expanded);
    if (changed) {
      this._onDidChangeBodyVisibility.fire(expanded);
    }
    if (this.twistiesContainer) {
      this.twistiesContainer.classList.remove(...ThemeIcon.asClassNameArray(this.getTwistyIcon(!expanded)));
      this.twistiesContainer.classList.add(...ThemeIcon.asClassNameArray(this.getTwistyIcon(expanded)));
    }
    return changed;
  }
  render() {
    super.render();
    const focusTracker = trackFocus(this.element);
    this._register(focusTracker);
    this._register(focusTracker.onDidFocus(() => this._onDidFocus.fire()));
    this._register(focusTracker.onDidBlur(() => this._onDidBlur.fire()));
  }
  renderHeader(container) {
    this.headerContainer = container;
    this.twistiesContainer = append(container, $(ThemeIcon.asCSSSelector(this.getTwistyIcon(this.isExpanded()))));
    this.renderHeaderTitle(container, this.title);
    const actions = append(container, $(".actions"));
    actions.classList.toggle("show-always", this.showActions === ViewPaneShowActions.Always);
    actions.classList.toggle("show-expanded", this.showActions === ViewPaneShowActions.WhenExpanded);
    this.toolbar = this.instantiationService.createInstance(WorkbenchToolBar, actions, {
      orientation: 0,
      actionViewItemProvider: (action) => this.getActionViewItem(action),
      ariaLabel: localize("viewToolbarAriaLabel", "{0} actions", this.title),
      getKeyBinding: (action) => this.keybindingService.lookupKeybinding(action.id),
      renderDropdownAsChildElement: true,
      actionRunner: this.getActionRunner(),
      resetMenu: this.menuActions.menuId
    });
    this._register(this.toolbar);
    this.setActions();
    this._register(addDisposableListener(actions, EventType.CLICK, (e) => e.preventDefault()));
    const viewContainerModel = this.viewDescriptorService.getViewContainerByViewId(this.id);
    if (viewContainerModel) {
      this._register(this.viewDescriptorService.getViewContainerModel(viewContainerModel).onDidChangeContainerInfo(({ title }) => this.updateTitle(this.title)));
    } else {
      console.error(`View container model not found for view ${this.id}`);
    }
    const onDidRelevantConfigurationChange = Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration(ViewPane_1.AlwaysShowActionsConfig));
    this._register(onDidRelevantConfigurationChange(this.updateActionsVisibility, this));
    this.updateActionsVisibility();
  }
  getTwistyIcon(expanded) {
    return expanded ? viewPaneContainerExpandedIcon : viewPaneContainerCollapsedIcon;
  }
  style(styles) {
    super.style(styles);
    const icon = this.getIcon();
    if (this.iconContainer) {
      const fgColor = asCssValueWithDefault(styles.headerForeground, asCssVariable(foreground));
      if (URI.isUri(icon)) {
        this.iconContainer.style.backgroundColor = fgColor;
        this.iconContainer.style.color = "";
      } else {
        this.iconContainer.style.color = fgColor;
        this.iconContainer.style.backgroundColor = "";
      }
    }
  }
  getIcon() {
    var _a43;
    return ((_a43 = this.viewDescriptorService.getViewDescriptorById(this.id)) == null ? void 0 : _a43.containerIcon) || defaultViewIcon;
  }
  renderHeaderTitle(container, title) {
    this.iconContainer = append(container, $(".icon", void 0));
    const icon = this.getIcon();
    let cssClass = void 0;
    if (URI.isUri(icon)) {
      cssClass = `view-${this.id.replace(/[\.\:]/g, "-")}`;
      const iconClass = `.pane-header .icon.${cssClass}`;
      createCSSRule(iconClass, `
				mask: ${asCSSUrl(icon)} no-repeat 50% 50%;
				mask-size: 24px;
				-webkit-mask: ${asCSSUrl(icon)} no-repeat 50% 50%;
				-webkit-mask-size: 16px;
			`);
    } else if (ThemeIcon.isThemeIcon(icon)) {
      cssClass = ThemeIcon.asClassName(icon);
    }
    if (cssClass) {
      this.iconContainer.classList.add(...cssClass.split(" "));
    }
    const calculatedTitle = this.calculateTitle(title);
    this.titleContainer = append(container, $("h3.title", { title: calculatedTitle }, calculatedTitle));
    if (this._titleDescription) {
      this.setTitleDescription(this._titleDescription);
    }
    this.iconContainer.title = calculatedTitle;
    this.iconContainer.setAttribute("aria-label", calculatedTitle);
  }
  updateTitle(title) {
    const calculatedTitle = this.calculateTitle(title);
    if (this.titleContainer) {
      this.titleContainer.textContent = calculatedTitle;
      this.titleContainer.setAttribute("title", calculatedTitle);
    }
    if (this.iconContainer) {
      this.iconContainer.title = calculatedTitle;
      this.iconContainer.setAttribute("aria-label", calculatedTitle);
    }
    this._title = title;
    this._onDidChangeTitleArea.fire();
  }
  setTitleDescription(description) {
    if (this.titleDescriptionContainer) {
      this.titleDescriptionContainer.textContent = description ?? "";
      this.titleDescriptionContainer.setAttribute("title", description ?? "");
    } else if (description && this.titleContainer) {
      this.titleDescriptionContainer = after(this.titleContainer, $("span.description", { title: description }, description));
    }
  }
  updateTitleDescription(description) {
    this.setTitleDescription(description);
    this._titleDescription = description;
    this._onDidChangeTitleArea.fire();
  }
  calculateTitle(title) {
    const viewContainer = this.viewDescriptorService.getViewContainerByViewId(this.id);
    const model = this.viewDescriptorService.getViewContainerModel(viewContainer);
    const viewDescriptor = this.viewDescriptorService.getViewDescriptorById(this.id);
    const isDefault = this.viewDescriptorService.getDefaultContainerById(this.id) === viewContainer;
    if (!isDefault && (viewDescriptor == null ? void 0 : viewDescriptor.containerTitle) && model.title !== viewDescriptor.containerTitle) {
      return `${viewDescriptor.containerTitle}: ${title}`;
    }
    return title;
  }
  renderBody(container) {
    this.bodyContainer = container;
    const viewWelcomeContainer = append(container, $(".welcome-view"));
    this.viewWelcomeContainer = $(".welcome-view-content", { tabIndex: 0 });
    this.scrollableElement = this._register(new DomScrollableElement(this.viewWelcomeContainer, {
      alwaysConsumeMouseWheel: true,
      horizontal: 2,
      vertical: 3
    }));
    append(viewWelcomeContainer, this.scrollableElement.getDomNode());
    const onViewWelcomeChange = Event.any(this.viewWelcomeController.onDidChange, this.onDidChangeViewWelcomeState);
    this._register(onViewWelcomeChange(this.updateViewWelcome, this));
    this.updateViewWelcome();
  }
  layoutBody(height, width) {
    this.viewWelcomeContainer.style.height = `${height}px`;
    this.viewWelcomeContainer.style.width = `${width}px`;
    this.viewWelcomeContainer.classList.toggle("wide", width > 640);
    this.scrollableElement.scanDomNode();
  }
  onDidScrollRoot() {
  }
  getProgressIndicator() {
    if (this.progressBar === void 0) {
      this.progressBar = this._register(new ProgressBar(this.element, defaultProgressBarStyles));
      this.progressBar.hide();
    }
    if (this.progressIndicator === void 0) {
      const that = this;
      this.progressIndicator = new ScopedProgressIndicator(
        assertIsDefined(this.progressBar),
        new class extends AbstractProgressScope {
          constructor() {
            super(that.id, that.isBodyVisible());
            this._register(that.onDidChangeBodyVisibility((isVisible) => isVisible ? this.onScopeOpened(that.id) : this.onScopeClosed(that.id)));
          }
        }()
      );
    }
    return this.progressIndicator;
  }
  getProgressLocation() {
    return this.viewDescriptorService.getViewContainerByViewId(this.id).id;
  }
  getBackgroundColor() {
    switch (this.viewDescriptorService.getViewLocationById(this.id)) {
      case 1:
        return PANEL_BACKGROUND;
      case 0:
      case 2:
        return SIDE_BAR_BACKGROUND;
    }
    return SIDE_BAR_BACKGROUND;
  }
  focus() {
    if (this.shouldShowWelcome()) {
      this.viewWelcomeContainer.focus();
    } else if (this.element) {
      this.element.focus();
      this._onDidFocus.fire();
    }
  }
  setActions() {
    if (this.toolbar) {
      const primaryActions = [...this.menuActions.getPrimaryActions()];
      if (this.shouldShowFilterInHeader()) {
        primaryActions.unshift(VIEWPANE_FILTER_ACTION);
      }
      this.toolbar.setActions(prepareActions(primaryActions), prepareActions(this.menuActions.getSecondaryActions()));
      this.toolbar.context = this.getActionsContext();
    }
  }
  updateActionsVisibility() {
    if (!this.headerContainer) {
      return;
    }
    const shouldAlwaysShowActions = this.configurationService.getValue("workbench.view.alwaysShowHeaderActions");
    this.headerContainer.classList.toggle("actions-always-visible", shouldAlwaysShowActions);
  }
  updateActions() {
    this.setActions();
    this._onDidChangeTitleArea.fire();
  }
  getActionViewItem(action, options) {
    if (action.id === VIEWPANE_FILTER_ACTION.id) {
      const that = this;
      return new class extends BaseActionViewItem {
        constructor() {
          super(null, action);
        }
        setFocusable() {
        }
        get trapsArrowNavigation() {
          return true;
        }
        render(container) {
          container.classList.add("viewpane-filter-container");
          append(container, that.getFilterWidget().element);
        }
      }();
    }
    return createActionViewItem(this.instantiationService, action, { ...options, ...{ menuAsChild: action instanceof SubmenuItemAction } });
  }
  getActionsContext() {
    return void 0;
  }
  getActionRunner() {
    return void 0;
  }
  getOptimalWidth() {
    return 0;
  }
  saveState() {
  }
  updateViewWelcome() {
    this.viewWelcomeDisposable.dispose();
    if (!this.shouldShowWelcome()) {
      this.bodyContainer.classList.remove("welcome");
      this.viewWelcomeContainer.innerText = "";
      this.scrollableElement.scanDomNode();
      return;
    }
    const contents = this.viewWelcomeController.contents;
    if (contents.length === 0) {
      this.bodyContainer.classList.remove("welcome");
      this.viewWelcomeContainer.innerText = "";
      this.scrollableElement.scanDomNode();
      return;
    }
    const disposables = new DisposableStore();
    this.bodyContainer.classList.add("welcome");
    this.viewWelcomeContainer.innerText = "";
    for (const { content, precondition } of contents) {
      const lines = content.split("\n");
      for (let line of lines) {
        line = line.trim();
        if (!line) {
          continue;
        }
        const linkedText = parseLinkedText(line);
        if (linkedText.nodes.length === 1 && typeof linkedText.nodes[0] !== "string") {
          const node = linkedText.nodes[0];
          const buttonContainer = append(this.viewWelcomeContainer, $(".button-container"));
          const button = new Button(
            buttonContainer,
            { title: node.title, supportIcons: true, ...defaultButtonStyles }
          );
          button.label = node.label;
          button.onDidClick((_) => {
            this.telemetryService.publicLog2("views.welcomeAction", { viewId: this.id, uri: node.href });
            this.openerService.open(node.href, { allowCommands: true });
          }, null, disposables);
          disposables.add(button);
          if (precondition) {
            const updateEnablement = () => button.enabled = this.contextKeyService.contextMatchesRules(precondition);
            updateEnablement();
            const keys = /* @__PURE__ */ new Set();
            precondition.keys().forEach((key) => keys.add(key));
            const onDidChangeContext = Event.filter(this.contextKeyService.onDidChangeContext, (e) => e.affectsSome(keys));
            onDidChangeContext(updateEnablement, null, disposables);
          }
        } else {
          const p = append(this.viewWelcomeContainer, $("p"));
          for (const node of linkedText.nodes) {
            if (typeof node === "string") {
              append(p, document.createTextNode(node));
            } else {
              const link = disposables.add(this.instantiationService.createInstance(Link, p, node, {}));
              if (precondition && node.href.startsWith("command:")) {
                const updateEnablement = () => link.enabled = this.contextKeyService.contextMatchesRules(precondition);
                updateEnablement();
                const keys = /* @__PURE__ */ new Set();
                precondition.keys().forEach((key) => keys.add(key));
                const onDidChangeContext = Event.filter(this.contextKeyService.onDidChangeContext, (e) => e.affectsSome(keys));
                onDidChangeContext(updateEnablement, null, disposables);
              }
            }
          }
        }
      }
    }
    this.scrollableElement.scanDomNode();
    this.viewWelcomeDisposable = disposables;
  }
  shouldShowWelcome() {
    return false;
  }
  getFilterWidget() {
    return void 0;
  }
  shouldShowFilterInHeader() {
    return false;
  }
}, ViewPane_1 = _a35, _a35.AlwaysShowActionsConfig = "workbench.view.alwaysShowHeaderActions", _a35);
ViewPane = ViewPane_1 = __decorate([
  __param(1, IKeybindingService),
  __param(2, IContextMenuService),
  __param(3, IConfigurationService),
  __param(4, IContextKeyService),
  __param(5, IViewDescriptorService),
  __param(6, IInstantiationService),
  __param(7, IOpenerService),
  __param(8, IThemeService),
  __param(9, ITelemetryService)
], ViewPane);
var FilterViewPane = class FilterViewPane2 extends ViewPane {
  constructor(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService) {
    super(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
    this.filterWidget = this._register(instantiationService.createChild(new ServiceCollection([IContextKeyService, this.scopedContextKeyService])).createInstance(FilterWidget, options.filterOptions));
  }
  getFilterWidget() {
    return this.filterWidget;
  }
  renderBody(container) {
    super.renderBody(container);
    this.filterContainer = append(container, $(".viewpane-filter-container"));
  }
  layoutBody(height, width) {
    var _a43;
    super.layoutBody(height, width);
    this.dimension = new Dimension(width, height);
    const wasFilterShownInHeader = !((_a43 = this.filterContainer) == null ? void 0 : _a43.hasChildNodes());
    const shouldShowFilterInHeader = this.shouldShowFilterInHeader();
    if (wasFilterShownInHeader !== shouldShowFilterInHeader) {
      if (shouldShowFilterInHeader) {
        reset(this.filterContainer);
      }
      this.updateActions();
      if (!shouldShowFilterInHeader) {
        append(this.filterContainer, this.filterWidget.element);
      }
    }
    if (!shouldShowFilterInHeader) {
      height = height - 44;
    }
    this.filterWidget.layout(width);
    this.layoutBodyContent(height, width);
  }
  shouldShowFilterInHeader() {
    return !(this.dimension && this.dimension.width < 600 && this.dimension.height > 100);
  }
};
FilterViewPane = __decorate([
  __param(1, IKeybindingService),
  __param(2, IContextMenuService),
  __param(3, IConfigurationService),
  __param(4, IContextKeyService),
  __param(5, IViewDescriptorService),
  __param(6, IInstantiationService),
  __param(7, IOpenerService),
  __param(8, IThemeService),
  __param(9, ITelemetryService)
], FilterViewPane);
var ViewAction = class extends Action2 {
  constructor(desc) {
    super(desc);
    this.desc = desc;
  }
  run(accessor, ...args) {
    const view = accessor.get(IViewsService).getActiveViewWithId(this.desc.viewId);
    if (view) {
      return this.runInView(accessor, view, ...args);
    }
  }
};

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerView.js
init_themeService();
init_actions2();
init_telemetry();

// node_modules/vscode/vscode/src/vs/workbench/browser/labels.js
init_tslib_es6();
init_uri();
init_resources();
init_language();
init_configuration();
init_model2();
init_network();
init_files();
init_themeService();
init_event();
init_lifecycle();
init_instantiation();
function toResource(props) {
  if (!props || !props.resource) {
    return void 0;
  }
  if (URI.isUri(props.resource)) {
    return props.resource;
  }
  return props.resource.primary;
}
var DEFAULT_LABELS_CONTAINER = {
  onDidChangeVisibility: Event.None
};
var ResourceLabels = class ResourceLabels2 extends Disposable {
  constructor(container, instantiationService, configurationService, modelService, workspaceService, languageService, decorationsService, themeService, labelService, textFileService) {
    super();
    this.instantiationService = instantiationService;
    this.configurationService = configurationService;
    this.modelService = modelService;
    this.workspaceService = workspaceService;
    this.languageService = languageService;
    this.decorationsService = decorationsService;
    this.themeService = themeService;
    this.labelService = labelService;
    this.textFileService = textFileService;
    this._onDidChangeDecorations = this._register(new Emitter());
    this.onDidChangeDecorations = this._onDidChangeDecorations.event;
    this.widgets = [];
    this.labels = [];
    this.registerListeners(container);
  }
  registerListeners(container) {
    this._register(container.onDidChangeVisibility((visible) => {
      this.widgets.forEach((widget) => widget.notifyVisibilityChanged(visible));
    }));
    this._register(this.languageService.onDidChange(() => this.widgets.forEach((widget) => widget.notifyExtensionsRegistered())));
    this._register(this.modelService.onModelLanguageChanged((e) => {
      if (!e.model.uri) {
        return;
      }
      this.widgets.forEach((widget) => widget.notifyModelLanguageChanged(e.model));
    }));
    this._register(this.modelService.onModelAdded((model) => {
      if (!model.uri) {
        return;
      }
      this.widgets.forEach((widget) => widget.notifyModelAdded(model));
    }));
    this._register(this.workspaceService.onDidChangeWorkspaceFolders(() => {
      this.widgets.forEach((widget) => widget.notifyWorkspaceFoldersChange());
    }));
    this._register(this.decorationsService.onDidChangeDecorations((e) => {
      let notifyDidChangeDecorations = false;
      this.widgets.forEach((widget) => {
        if (widget.notifyFileDecorationsChanges(e)) {
          notifyDidChangeDecorations = true;
        }
      });
      if (notifyDidChangeDecorations) {
        this._onDidChangeDecorations.fire();
      }
    }));
    this._register(this.themeService.onDidColorThemeChange(() => this.widgets.forEach((widget) => widget.notifyThemeChange())));
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(FILES_ASSOCIATIONS_CONFIG)) {
        this.widgets.forEach((widget) => widget.notifyFileAssociationsChange());
      }
    }));
    this._register(this.labelService.onDidChangeFormatters((e) => {
      this.widgets.forEach((widget) => widget.notifyFormattersChange(e.scheme));
    }));
    this._register(this.textFileService.untitled.onDidChangeLabel((model) => {
      this.widgets.forEach((widget) => widget.notifyUntitledLabelChange(model.resource));
    }));
  }
  get(index) {
    return this.labels[index];
  }
  create(container, options) {
    const widget = this.instantiationService.createInstance(ResourceLabelWidget, container, options);
    const label = {
      element: widget.element,
      onDidRender: widget.onDidRender,
      setLabel: (label2, description, options2) => widget.setLabel(label2, description, options2),
      setResource: (label2, options2) => widget.setResource(label2, options2),
      setFile: (resource, options2) => widget.setFile(resource, options2),
      clear: () => widget.clear(),
      dispose: () => this.disposeWidget(widget)
    };
    this.labels.push(label);
    this.widgets.push(widget);
    return label;
  }
  disposeWidget(widget) {
    const index = this.widgets.indexOf(widget);
    if (index > -1) {
      this.widgets.splice(index, 1);
      this.labels.splice(index, 1);
    }
    dispose(widget);
  }
  clear() {
    this.widgets = dispose(this.widgets);
    this.labels = [];
  }
  dispose() {
    super.dispose();
    this.clear();
  }
};
ResourceLabels = __decorate([
  __param(1, IInstantiationService),
  __param(2, IConfigurationService),
  __param(3, IModelService),
  __param(4, IWorkspaceContextService),
  __param(5, ILanguageService),
  __param(6, IDecorationsService),
  __param(7, IThemeService),
  __param(8, ILabelService),
  __param(9, ITextFileService)
], ResourceLabels);
var ResourceLabel = class ResourceLabel2 extends ResourceLabels {
  get element() {
    return this.label;
  }
  constructor(container, options, instantiationService, configurationService, modelService, workspaceService, languageService, decorationsService, themeService, labelService, textFileService) {
    super(DEFAULT_LABELS_CONTAINER, instantiationService, configurationService, modelService, workspaceService, languageService, decorationsService, themeService, labelService, textFileService);
    this.label = this._register(this.create(container, options));
  }
};
ResourceLabel = __decorate([
  __param(2, IInstantiationService),
  __param(3, IConfigurationService),
  __param(4, IModelService),
  __param(5, IWorkspaceContextService),
  __param(6, ILanguageService),
  __param(7, IDecorationsService),
  __param(8, IThemeService),
  __param(9, ILabelService),
  __param(10, ITextFileService)
], ResourceLabel);
var Redraw;
(function(Redraw2) {
  Redraw2[Redraw2["Basic"] = 1] = "Basic";
  Redraw2[Redraw2["Full"] = 2] = "Full";
})(Redraw || (Redraw = {}));
var ResourceLabelWidget = class ResourceLabelWidget2 extends IconLabel {
  constructor(container, options, languageService, modelService, decorationsService, labelService, textFileService, contextService) {
    super(container, options);
    this.languageService = languageService;
    this.modelService = modelService;
    this.decorationsService = decorationsService;
    this.labelService = labelService;
    this.textFileService = textFileService;
    this.contextService = contextService;
    this._onDidRender = this._register(new Emitter());
    this.onDidRender = this._onDidRender.event;
    this.label = void 0;
    this.decoration = this._register(new MutableDisposable());
    this.options = void 0;
    this.computedIconClasses = void 0;
    this.computedLanguageId = void 0;
    this.computedPathLabel = void 0;
    this.computedWorkspaceFolderLabel = void 0;
    this.needsRedraw = void 0;
    this.isHidden = false;
  }
  notifyVisibilityChanged(visible) {
    if (visible === this.isHidden) {
      this.isHidden = !visible;
      if (visible && this.needsRedraw) {
        this.render({
          updateIcon: this.needsRedraw === Redraw.Full,
          updateDecoration: this.needsRedraw === Redraw.Full
        });
        this.needsRedraw = void 0;
      }
    }
  }
  notifyModelLanguageChanged(model) {
    this.handleModelEvent(model);
  }
  notifyModelAdded(model) {
    this.handleModelEvent(model);
  }
  handleModelEvent(model) {
    const resource = toResource(this.label);
    if (!resource) {
      return;
    }
    if (isEqual2(model.uri, resource)) {
      if (this.computedLanguageId !== model.getLanguageId()) {
        this.computedLanguageId = model.getLanguageId();
        this.render({ updateIcon: true, updateDecoration: false });
      }
    }
  }
  notifyFileDecorationsChanges(e) {
    if (!this.options) {
      return false;
    }
    const resource = toResource(this.label);
    if (!resource) {
      return false;
    }
    if (this.options.fileDecorations && e.affectsResource(resource)) {
      return this.render({ updateIcon: false, updateDecoration: true });
    }
    return false;
  }
  notifyExtensionsRegistered() {
    this.render({ updateIcon: true, updateDecoration: false });
  }
  notifyThemeChange() {
    this.render({ updateIcon: false, updateDecoration: false });
  }
  notifyFileAssociationsChange() {
    this.render({ updateIcon: true, updateDecoration: false });
  }
  notifyFormattersChange(scheme) {
    var _a43;
    if (((_a43 = toResource(this.label)) == null ? void 0 : _a43.scheme) === scheme) {
      this.render({ updateIcon: false, updateDecoration: false });
    }
  }
  notifyUntitledLabelChange(resource) {
    if (isEqual2(resource, toResource(this.label))) {
      this.render({ updateIcon: false, updateDecoration: false });
    }
  }
  notifyWorkspaceFoldersChange() {
    var _a43;
    if (typeof this.computedWorkspaceFolderLabel === "string") {
      const resource = toResource(this.label);
      if (URI.isUri(resource) && ((_a43 = this.label) == null ? void 0 : _a43.name) === this.computedWorkspaceFolderLabel) {
        this.setFile(resource, this.options);
      }
    }
  }
  setFile(resource, options) {
    const hideLabel = options == null ? void 0 : options.hideLabel;
    let name;
    if (!hideLabel) {
      if ((options == null ? void 0 : options.fileKind) === FileKind.ROOT_FOLDER) {
        const workspaceFolder = this.contextService.getWorkspaceFolder(resource);
        if (workspaceFolder) {
          name = workspaceFolder.name;
          this.computedWorkspaceFolderLabel = name;
        }
      }
      if (!name) {
        name = normalizeDriveLetter(basenameOrAuthority(resource));
      }
    }
    let description;
    if (!(options == null ? void 0 : options.hidePath)) {
      description = this.labelService.getUriLabel(dirname(resource), { relative: true });
    }
    this.setResource({ resource, name, description }, options);
  }
  setResource(label, options = /* @__PURE__ */ Object.create(null)) {
    const resource = toResource(label);
    const isSideBySideEditor = (label == null ? void 0 : label.resource) && !URI.isUri(label.resource);
    if (!options.forceLabel && !isSideBySideEditor && (resource == null ? void 0 : resource.scheme) === Schemas.untitled) {
      const untitledModel = this.textFileService.untitled.get(resource);
      if (untitledModel && !untitledModel.hasAssociatedFilePath) {
        if (typeof label.name === "string") {
          label.name = untitledModel.name;
        }
        if (typeof label.description === "string") {
          const untitledDescription = untitledModel.resource.path;
          if (label.name !== untitledDescription) {
            label.description = untitledDescription;
          } else {
            label.description = void 0;
          }
        }
        const untitledTitle = untitledModel.resource.path;
        if (untitledModel.name !== untitledTitle) {
          options.title = `${untitledModel.name}  ${untitledTitle}`;
        } else {
          options.title = untitledTitle;
        }
      }
    }
    const hasResourceChanged = this.hasResourceChanged(label);
    const hasPathLabelChanged = hasResourceChanged || this.hasPathLabelChanged(label);
    const hasFileKindChanged = this.hasFileKindChanged(options);
    this.label = label;
    this.options = options;
    if (hasResourceChanged) {
      this.computedLanguageId = void 0;
    }
    if (hasPathLabelChanged) {
      this.computedPathLabel = void 0;
    }
    this.render({
      updateIcon: hasResourceChanged || hasFileKindChanged,
      updateDecoration: hasResourceChanged || hasFileKindChanged
    });
  }
  hasFileKindChanged(newOptions) {
    var _a43;
    const newFileKind = newOptions == null ? void 0 : newOptions.fileKind;
    const oldFileKind = (_a43 = this.options) == null ? void 0 : _a43.fileKind;
    return newFileKind !== oldFileKind;
  }
  hasResourceChanged(newLabel) {
    const newResource = toResource(newLabel);
    const oldResource = toResource(this.label);
    if (newResource && oldResource) {
      return newResource.toString() !== oldResource.toString();
    }
    if (!newResource && !oldResource) {
      return false;
    }
    return true;
  }
  hasPathLabelChanged(newLabel) {
    const newResource = toResource(newLabel);
    return !!newResource && this.computedPathLabel !== this.labelService.getUriLabel(newResource);
  }
  clear() {
    this.label = void 0;
    this.options = void 0;
    this.computedLanguageId = void 0;
    this.computedIconClasses = void 0;
    this.computedPathLabel = void 0;
    this.setLabel("");
  }
  render(options) {
    var _a43, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    if (this.isHidden) {
      if (this.needsRedraw !== Redraw.Full) {
        this.needsRedraw = options.updateIcon || options.updateDecoration ? Redraw.Full : Redraw.Basic;
      }
      return false;
    }
    if (options.updateIcon) {
      this.computedIconClasses = void 0;
    }
    if (!this.label) {
      return false;
    }
    const iconLabelOptions = {
      title: "",
      italic: (_a43 = this.options) == null ? void 0 : _a43.italic,
      strikethrough: (_b = this.options) == null ? void 0 : _b.strikethrough,
      matches: (_c = this.options) == null ? void 0 : _c.matches,
      descriptionMatches: (_d = this.options) == null ? void 0 : _d.descriptionMatches,
      extraClasses: [],
      separator: (_e = this.options) == null ? void 0 : _e.separator,
      domId: (_f = this.options) == null ? void 0 : _f.domId,
      disabledCommand: (_g = this.options) == null ? void 0 : _g.disabledCommand,
      labelEscapeNewLines: (_h = this.options) == null ? void 0 : _h.labelEscapeNewLines
    };
    const resource = toResource(this.label);
    const label = this.label.name;
    if (((_i = this.options) == null ? void 0 : _i.title) !== void 0) {
      iconLabelOptions.title = this.options.title;
    }
    if (resource && resource.scheme !== Schemas.data && (!((_j = this.options) == null ? void 0 : _j.title) || typeof this.options.title !== "string" && !this.options.title.markdownNotSupportedFallback)) {
      if (!this.computedPathLabel) {
        this.computedPathLabel = this.labelService.getUriLabel(resource);
      }
      if (!iconLabelOptions.title || typeof iconLabelOptions.title === "string") {
        iconLabelOptions.title = this.computedPathLabel;
      } else if (!iconLabelOptions.title.markdownNotSupportedFallback) {
        iconLabelOptions.title.markdownNotSupportedFallback = this.computedPathLabel;
      }
    }
    if (this.options && !this.options.hideIcon) {
      if (!this.computedIconClasses) {
        this.computedIconClasses = getIconClasses(this.modelService, this.languageService, resource, this.options.fileKind);
      }
      iconLabelOptions.extraClasses = this.computedIconClasses.slice(0);
    }
    if ((_k = this.options) == null ? void 0 : _k.extraClasses) {
      iconLabelOptions.extraClasses.push(...this.options.extraClasses);
    }
    if (((_l = this.options) == null ? void 0 : _l.fileDecorations) && resource) {
      if (options.updateDecoration) {
        this.decoration.value = this.decorationsService.getDecoration(resource, this.options.fileKind !== FileKind.FILE);
      }
      const decoration = this.decoration.value;
      if (decoration) {
        if (decoration.tooltip) {
          if (typeof iconLabelOptions.title === "string") {
            iconLabelOptions.title = `${iconLabelOptions.title}  ${decoration.tooltip}`;
          } else if (typeof ((_m = iconLabelOptions.title) == null ? void 0 : _m.markdown) === "string") {
            const title = `${iconLabelOptions.title.markdown}  ${decoration.tooltip}`;
            iconLabelOptions.title = { markdown: title, markdownNotSupportedFallback: title };
          }
        }
        if (decoration.strikethrough) {
          iconLabelOptions.strikethrough = true;
        }
        if (this.options.fileDecorations.colors) {
          iconLabelOptions.extraClasses.push(decoration.labelClassName);
        }
        if (this.options.fileDecorations.badges) {
          iconLabelOptions.extraClasses.push(decoration.badgeClassName);
          iconLabelOptions.extraClasses.push(decoration.iconClassName);
        }
      }
    }
    this.setLabel(label || "", this.label.description, iconLabelOptions);
    this._onDidRender.fire();
    return true;
  }
  dispose() {
    super.dispose();
    this.label = void 0;
    this.options = void 0;
    this.computedLanguageId = void 0;
    this.computedIconClasses = void 0;
    this.computedPathLabel = void 0;
    this.computedWorkspaceFolderLabel = void 0;
  }
};
ResourceLabelWidget = __decorate([
  __param(2, ILanguageService),
  __param(3, IModelService),
  __param(4, IDecorationsService),
  __param(5, ILabelService),
  __param(6, ITextFileService),
  __param(7, IWorkspaceContextService)
], ResourceLabelWidget);

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/explorerView.js
init_files();
init_event();
init_opener();
init_codicons();
init_commands();
init_map();
var ExplorerView_1;
function hasExpandedRootChild(tree, treeInput) {
  for (const folder of treeInput) {
    if (tree.hasNode(folder) && !tree.isCollapsed(folder)) {
      for (const [, child] of folder.children.entries()) {
        if (tree.hasNode(child) && tree.isCollapsible(child) && !tree.isCollapsed(child)) {
          return true;
        }
      }
    }
  }
  return false;
}
function hasExpandedNode(tree, treeInput) {
  for (const folder of treeInput) {
    if (tree.hasNode(folder) && !tree.isCollapsed(folder)) {
      return true;
    }
  }
  return false;
}
var identityProvider = {
  getId: (stat) => {
    if (stat instanceof NewExplorerItem) {
      return `new:${stat.getId()}`;
    }
    return stat.getId();
  }
};
function getContext(focus, selection, respectMultiSelection, compressedNavigationControllerProvider) {
  let focusedStat;
  focusedStat = focus.length ? focus[0] : void 0;
  if (respectMultiSelection && selection.length > 1) {
    focusedStat = void 0;
  }
  const compressedNavigationController = focusedStat && compressedNavigationControllerProvider.getCompressedNavigationController(focusedStat);
  focusedStat = compressedNavigationController ? compressedNavigationController.current : focusedStat;
  const selectedStats = [];
  for (const stat of selection) {
    const controller = compressedNavigationControllerProvider.getCompressedNavigationController(stat);
    if (controller && focusedStat && controller === compressedNavigationController) {
      if (stat === focusedStat) {
        selectedStats.push(stat);
      }
      continue;
    }
    if (controller) {
      selectedStats.push(...controller.items);
    } else {
      selectedStats.push(stat);
    }
  }
  if (!focusedStat) {
    if (respectMultiSelection) {
      return selectedStats;
    } else {
      return [];
    }
  }
  if (respectMultiSelection && selectedStats.indexOf(focusedStat) >= 0) {
    return selectedStats;
  }
  return [focusedStat];
}
var _a36;
var ExplorerView = (_a36 = class extends ViewPane {
  constructor(options, contextMenuService, viewDescriptorService, instantiationService, contextService, progressService, editorService, editorResolverService, layoutService, keybindingService, contextKeyService, configurationService, decorationService, labelService, themeService, telemetryService, explorerService, storageService, clipboardService, fileService, uriIdentityService, commandService, openerService) {
    super(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
    this.contextService = contextService;
    this.progressService = progressService;
    this.editorService = editorService;
    this.editorResolverService = editorResolverService;
    this.layoutService = layoutService;
    this.decorationService = decorationService;
    this.labelService = labelService;
    this.explorerService = explorerService;
    this.storageService = storageService;
    this.clipboardService = clipboardService;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this.commandService = commandService;
    this.autoReveal = false;
    this.delegate = options.delegate;
    this.resourceContext = instantiationService.createInstance(ResourceContextKey);
    this._register(this.resourceContext);
    this.folderContext = ExplorerFolderContext.bindTo(contextKeyService);
    this.readonlyContext = ExplorerResourceReadonlyContext.bindTo(contextKeyService);
    this.availableEditorIdsContext = ExplorerResourceAvailableEditorIdsContext.bindTo(contextKeyService);
    this.rootContext = ExplorerRootContext.bindTo(contextKeyService);
    this.resourceMoveableToTrash = ExplorerResourceMoveableToTrash.bindTo(contextKeyService);
    this.compressedFocusContext = ExplorerCompressedFocusContext.bindTo(contextKeyService);
    this.compressedFocusFirstContext = ExplorerCompressedFirstFocusContext.bindTo(contextKeyService);
    this.compressedFocusLastContext = ExplorerCompressedLastFocusContext.bindTo(contextKeyService);
    this.viewHasSomeCollapsibleRootItem = ViewHasSomeCollapsibleRootItemContext.bindTo(contextKeyService);
    this.viewVisibleContextKey = FoldersViewVisibleContext.bindTo(contextKeyService);
    this.explorerService.registerView(this);
  }
  get name() {
    return this.labelService.getWorkspaceLabel(this.contextService.getWorkspace());
  }
  get title() {
    return this.name;
  }
  set title(_) {
  }
  setVisible(visible) {
    this.viewVisibleContextKey.set(visible);
    super.setVisible(visible);
  }
  get fileCopiedContextKey() {
    return FileCopiedContext.bindTo(this.contextKeyService);
  }
  get resourceCutContextKey() {
    return ExplorerResourceCut.bindTo(this.contextKeyService);
  }
  renderHeader(container) {
    super.renderHeader(container);
    this.dragHandler = new DelayedDragHandler(container, () => this.setExpanded(true));
    const titleElement = container.querySelector(".title");
    const setHeader = () => {
      const workspace = this.contextService.getWorkspace();
      const title = workspace.folders.map((folder) => folder.name).join();
      titleElement.textContent = this.name;
      titleElement.title = title;
      this.ariaHeaderLabel = localize("explorerSection", "Explorer Section: {0}", this.name);
      titleElement.setAttribute("aria-label", this.ariaHeaderLabel);
    };
    this._register(this.contextService.onDidChangeWorkspaceName(setHeader));
    this._register(this.labelService.onDidChangeFormatters(setHeader));
    setHeader();
  }
  layoutBody(height, width) {
    super.layoutBody(height, width);
    this.tree.layout(height, width);
  }
  renderBody(container) {
    super.renderBody(container);
    this.container = container;
    this.treeContainer = append(container, $(".explorer-folders-view"));
    this.createTree(this.treeContainer);
    this._register(this.labelService.onDidChangeFormatters(() => {
      this._onDidChangeTitleArea.fire();
    }));
    this.onConfigurationUpdated(void 0);
    this._register(this.editorService.onDidActiveEditorChange(() => {
      this.selectActiveFile();
    }));
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationUpdated(e)));
    this._register(this.onDidChangeBodyVisibility(async (visible) => {
      if (visible) {
        await this.setTreeInput();
        this.updateAnyCollapsedContext();
        this.selectActiveFile(true);
      }
    }));
  }
  focus() {
    this.tree.domFocus();
    const focused = this.tree.getFocus();
    if (focused.length === 1 && this.autoReveal) {
      this.tree.reveal(focused[0], 0.5);
    }
  }
  hasFocus() {
    return isAncestor(document.activeElement, this.container);
  }
  getContext(respectMultiSelection) {
    return getContext(this.tree.getFocus(), this.tree.getSelection(), respectMultiSelection, this.renderer);
  }
  isItemVisible(item) {
    if (!this.filter) {
      return false;
    }
    return this.filter.filter(item, 1);
  }
  isItemCollapsed(item) {
    return this.tree.isCollapsed(item);
  }
  async setEditable(stat, isEditing) {
    if (isEditing) {
      this.horizontalScrolling = this.tree.options.horizontalScrolling;
      if (this.horizontalScrolling) {
        this.tree.updateOptions({ horizontalScrolling: false });
      }
      await this.tree.expand(stat.parent);
    } else {
      if (this.horizontalScrolling !== void 0) {
        this.tree.updateOptions({ horizontalScrolling: this.horizontalScrolling });
      }
      this.horizontalScrolling = void 0;
      this.treeContainer.classList.remove("highlight");
    }
    await this.refresh(false, stat.parent, false);
    if (isEditing) {
      this.treeContainer.classList.add("highlight");
      this.tree.reveal(stat);
    } else {
      this.tree.domFocus();
    }
  }
  selectActiveFile(reveal = this.autoReveal) {
    if (this.autoReveal) {
      const activeFile = EditorResourceAccessor.getCanonicalUri(this.editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
      if (activeFile) {
        const focus = this.tree.getFocus();
        const selection = this.tree.getSelection();
        if (focus.length === 1 && this.uriIdentityService.extUri.isEqual(focus[0].resource, activeFile) && selection.length === 1 && this.uriIdentityService.extUri.isEqual(selection[0].resource, activeFile)) {
          return;
        }
        this.explorerService.select(activeFile, reveal);
      }
    }
  }
  createTree(container) {
    this.filter = this.instantiationService.createInstance(FilesFilter);
    this._register(this.filter);
    this._register(this.filter.onDidChange(() => this.refresh(true)));
    const explorerLabels = this.instantiationService.createInstance(ResourceLabels, { onDidChangeVisibility: this.onDidChangeBodyVisibility });
    this._register(explorerLabels);
    const updateWidth = (stat) => this.tree.updateWidth(stat);
    this.renderer = this.instantiationService.createInstance(FilesRenderer, container, explorerLabels, updateWidth);
    this._register(this.renderer);
    this._register(createFileIconThemableTreeContainerScope(container, this.themeService));
    const isCompressionEnabled = () => this.configurationService.getValue("explorer.compactFolders");
    const getFileNestingSettings = (item) => this.configurationService.getValue({ resource: item == null ? void 0 : item.root.resource }).explorer.fileNesting;
    this.tree = this.instantiationService.createInstance(WorkbenchCompressibleAsyncDataTree, "FileExplorer", container, new ExplorerDelegate(), new ExplorerCompressionDelegate(), [this.renderer], this.instantiationService.createInstance(ExplorerDataSource, this.filter), {
      compressionEnabled: isCompressionEnabled(),
      accessibilityProvider: this.renderer,
      identityProvider,
      keyboardNavigationLabelProvider: {
        getKeyboardNavigationLabel: (stat) => {
          if (this.explorerService.isEditable(stat)) {
            return void 0;
          }
          return stat.name;
        },
        getCompressedNodeKeyboardNavigationLabel: (stats) => {
          if (stats.some((stat) => this.explorerService.isEditable(stat))) {
            return void 0;
          }
          return stats.map((stat) => stat.name).join("/");
        }
      },
      multipleSelectionSupport: true,
      filter: this.filter,
      sorter: this.instantiationService.createInstance(FileSorter),
      dnd: this.instantiationService.createInstance(FileDragAndDrop, (item) => this.isItemCollapsed(item)),
      collapseByDefault: (e) => {
        if (e instanceof ExplorerItem) {
          if (e.hasNests && getFileNestingSettings(e).expand) {
            return false;
          }
        }
        return true;
      },
      autoExpandSingleChildren: true,
      expandOnlyOnTwistieClick: (e) => {
        if (e instanceof ExplorerItem) {
          if (e.hasNests) {
            return true;
          } else if (this.configurationService.getValue("workbench.tree.expandMode") === "doubleClick") {
            return true;
          }
        }
        return false;
      },
      paddingBottom: ExplorerDelegate.ITEM_HEIGHT,
      overrideStyles: {
        listBackground: SIDE_BAR_BACKGROUND
      }
    });
    this._register(this.tree);
    this._register(this.themeService.onDidColorThemeChange(() => this.tree.rerender()));
    const onDidChangeCompressionConfiguration = Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration("explorer.compactFolders"));
    this._register(onDidChangeCompressionConfiguration((_) => this.tree.updateOptions({ compressionEnabled: isCompressionEnabled() })));
    FilesExplorerFocusedContext.bindTo(this.tree.contextKeyService);
    ExplorerFocusedContext.bindTo(this.tree.contextKeyService);
    this._register(this.tree.onDidChangeFocus((e) => this.onFocusChanged(e.elements)));
    this.onFocusChanged([]);
    this._register(this.tree.onDidOpen(async (e) => {
      var _a43, _b;
      const element = e.element;
      if (!element) {
        return;
      }
      const shiftDown = e.browserEvent instanceof KeyboardEvent && e.browserEvent.shiftKey;
      if (!shiftDown) {
        if (element.isDirectory || this.explorerService.isEditable(void 0)) {
          return;
        }
        this.telemetryService.publicLog2("workbenchActionExecuted", { id: "workbench.files.openFile", from: "explorer" });
        try {
          (_a43 = this.delegate) == null ? void 0 : _a43.willOpenElement(e.browserEvent);
          await this.editorService.openEditor({ resource: element.resource, options: { preserveFocus: e.editorOptions.preserveFocus, pinned: e.editorOptions.pinned, source: EditorOpenSource.USER } }, e.sideBySide ? SIDE_GROUP : ACTIVE_GROUP);
        } finally {
          (_b = this.delegate) == null ? void 0 : _b.didOpenElement();
        }
      }
    }));
    this._register(this.tree.onContextMenu((e) => this.onContextMenu(e)));
    this._register(this.tree.onDidScroll(async (e) => {
      const editable = this.explorerService.getEditable();
      if (e.scrollTopChanged && editable && this.tree.getRelativeTop(editable.stat) === null) {
        await editable.data.onFinish("", false);
      }
    }));
    this._register(this.tree.onDidChangeCollapseState((e) => {
      var _a43;
      const element = (_a43 = e.node.element) == null ? void 0 : _a43.element;
      if (element) {
        const navigationController = this.renderer.getCompressedNavigationController(element instanceof Array ? element[0] : element);
        navigationController == null ? void 0 : navigationController.updateCollapsed(e.node.collapsed);
      }
      this.updateAnyCollapsedContext();
    }));
    this.updateAnyCollapsedContext();
    this._register(this.tree.onMouseDblClick((e) => {
      const scrollingByPage = this.configurationService.getValue("workbench.list.scrollByPage");
      if (e.element === null && !scrollingByPage) {
        this.commandService.executeCommand(NEW_FILE_COMMAND_ID);
      }
    }));
    this._register(this.storageService.onWillSaveState(() => {
      this.storeTreeViewState();
    }));
  }
  onConfigurationUpdated(event) {
    var _a43;
    if (!event || event.affectsConfiguration("explorer.autoReveal")) {
      const configuration = this.configurationService.getValue();
      this.autoReveal = (_a43 = configuration == null ? void 0 : configuration.explorer) == null ? void 0 : _a43.autoReveal;
    }
    if (event && (event.affectsConfiguration("explorer.decorations.colors") || event.affectsConfiguration("explorer.decorations.badges"))) {
      this.refresh(true);
    }
  }
  storeTreeViewState() {
    this.storageService.store(ExplorerView_1.TREE_VIEW_STATE_STORAGE_KEY, JSON.stringify(this.tree.getViewState()), 1, 1);
  }
  setContextKeys(stat) {
    const folders = this.contextService.getWorkspace().folders;
    const resource = stat ? stat.resource : folders[folders.length - 1].uri;
    stat = stat || this.explorerService.findClosest(resource);
    this.resourceContext.set(resource);
    this.folderContext.set(!!stat && stat.isDirectory);
    this.readonlyContext.set(!!stat && !!stat.isReadonly);
    this.rootContext.set(!!stat && stat.isRoot);
    if (resource) {
      const overrides = resource ? this.editorResolverService.getEditors(resource).map((editor) => editor.id) : [];
      this.availableEditorIdsContext.set(overrides.join(","));
    } else {
      this.availableEditorIdsContext.reset();
    }
  }
  async onContextMenu(e) {
    if (isInputElement(e.browserEvent.target)) {
      return;
    }
    const stat = e.element;
    let anchor = e.anchor;
    if (isHTMLElement(anchor)) {
      if (stat) {
        const controller = this.renderer.getCompressedNavigationController(stat);
        if (controller) {
          if (e.browserEvent instanceof KeyboardEvent || isCompressedFolderName(e.browserEvent.target)) {
            anchor = controller.labels[controller.index];
          } else {
            controller.last();
          }
        }
      }
    }
    this.fileCopiedContextKey.set(await this.clipboardService.hasResources());
    this.setContextKeys(stat);
    const selection = this.tree.getSelection();
    const roots = this.explorerService.roots;
    let arg;
    if (stat instanceof ExplorerItem) {
      const compressedController = this.renderer.getCompressedNavigationController(stat);
      arg = compressedController ? compressedController.current.resource : stat.resource;
    } else {
      arg = roots.length === 1 ? roots[0].resource : {};
    }
    this.contextMenuService.showContextMenu({
      menuId: MenuId.ExplorerContext,
      menuActionOptions: { arg, shouldForwardArgs: true },
      contextKeyService: this.tree.contextKeyService,
      getAnchor: () => anchor,
      onHide: (wasCancelled) => {
        if (wasCancelled) {
          this.tree.domFocus();
        }
      },
      getActionsContext: () => stat && selection && selection.indexOf(stat) >= 0 ? selection.map((fs) => fs.resource) : stat instanceof ExplorerItem ? [stat.resource] : []
    });
  }
  onFocusChanged(elements) {
    const stat = elements && elements.length ? elements[0] : void 0;
    this.setContextKeys(stat);
    if (stat) {
      const enableTrash = this.configurationService.getValue().files.enableTrash;
      const hasCapability = this.fileService.hasCapability(stat.resource, 4096);
      this.resourceMoveableToTrash.set(enableTrash && hasCapability);
    } else {
      this.resourceMoveableToTrash.reset();
    }
    const compressedNavigationController = stat && this.renderer.getCompressedNavigationController(stat);
    if (!compressedNavigationController) {
      this.compressedFocusContext.set(false);
      return;
    }
    this.compressedFocusContext.set(true);
    this.updateCompressedNavigationContextKeys(compressedNavigationController);
  }
  refresh(recursive, item, cancelEditing = true) {
    if (!this.tree || !this.isBodyVisible() || item && !this.tree.hasNode(item)) {
      return Promise.resolve(void 0);
    }
    if (cancelEditing && this.explorerService.isEditable(void 0)) {
      this.tree.domFocus();
    }
    const toRefresh = item || this.tree.getInput();
    return this.tree.updateChildren(toRefresh, recursive, !!item, {
      diffIdentityProvider: identityProvider
    });
  }
  getOptimalWidth() {
    const parentNode = this.tree.getHTMLElement();
    const childNodes = [].slice.call(parentNode.querySelectorAll(".explorer-item .label-name"));
    return getLargestChildWidth(parentNode, childNodes);
  }
  async setTreeInput() {
    if (!this.isBodyVisible()) {
      return Promise.resolve(void 0);
    }
    if (this.setTreeInputPromise) {
      await this.setTreeInputPromise;
    }
    const initialInputSetup = !this.tree.getInput();
    if (initialInputSetup) {
      mark("code/willResolveExplorer");
    }
    const roots = this.explorerService.roots;
    let input = roots[0];
    if (this.contextService.getWorkbenchState() !== 2 || roots[0].error) {
      input = roots;
    }
    let viewState;
    if (this.tree && this.tree.getInput()) {
      viewState = this.tree.getViewState();
    } else {
      const rawViewState = this.storageService.get(ExplorerView_1.TREE_VIEW_STATE_STORAGE_KEY, 1);
      if (rawViewState) {
        viewState = JSON.parse(rawViewState);
      }
    }
    const previousInput = this.tree.getInput();
    const promise = this.setTreeInputPromise = this.tree.setInput(input, viewState).then(async () => {
      if (Array.isArray(input)) {
        if (!viewState || previousInput instanceof ExplorerItem) {
          for (let i = 0; i < Math.min(input.length, 5); i++) {
            try {
              await this.tree.expand(input[i]);
            } catch (e) {
            }
          }
        }
        if (!previousInput && input.length === 1 && this.configurationService.getValue().explorer.expandSingleFolderWorkspaces) {
          await this.tree.expand(input[0]).catch(() => {
          });
        }
        if (Array.isArray(previousInput)) {
          const previousRoots = new ResourceMap();
          previousInput.forEach((previousRoot) => previousRoots.set(previousRoot.resource, true));
          await Promise.all(input.map(async (item) => {
            if (!previousRoots.has(item.resource)) {
              try {
                await this.tree.expand(item);
              } catch (e) {
              }
            }
          }));
        }
      }
      if (initialInputSetup) {
        mark("code/didResolveExplorer");
      }
    });
    this.progressService.withProgress({
      location: 1,
      delay: this.layoutService.isRestored() ? 800 : 1500
    }, (_progress) => promise);
    await promise;
    if (!this.decorationsProvider) {
      this.decorationsProvider = new ExplorerDecorationsProvider(this.explorerService, this.contextService);
      this._register(this.decorationService.registerDecorationsProvider(this.decorationsProvider));
    }
  }
  async selectResource(resource, reveal = this.autoReveal, retry = 0) {
    if (retry === 2) {
      return;
    }
    if (!resource || !this.isBodyVisible()) {
      return;
    }
    let item = this.explorerService.findClosestRoot(resource);
    while (item && item.resource.toString() !== resource.toString()) {
      try {
        await this.tree.expand(item);
      } catch (e) {
        return this.selectResource(resource, reveal, retry + 1);
      }
      for (const child of item.children.values()) {
        if (this.uriIdentityService.extUri.isEqualOrParent(resource, child.resource)) {
          item = child;
          break;
        }
        item = null;
      }
    }
    if (item) {
      if (item === this.tree.getInput()) {
        this.tree.setFocus([]);
        this.tree.setSelection([]);
        return;
      }
      try {
        if (item.nestedParent) {
          await this.tree.expand(item.nestedParent);
        }
        if ((reveal === true || reveal === "force") && this.tree.getRelativeTop(item) === null) {
          this.tree.reveal(item, 0.5);
        }
        this.tree.setFocus([item]);
        this.tree.setSelection([item]);
      } catch (e) {
        return this.selectResource(resource, reveal, retry + 1);
      }
    }
  }
  itemsCopied(stats, cut, previousCut) {
    this.fileCopiedContextKey.set(stats.length > 0);
    this.resourceCutContextKey.set(cut && stats.length > 0);
    previousCut == null ? void 0 : previousCut.forEach((item) => this.tree.rerender(item));
    if (cut) {
      stats.forEach((s) => this.tree.rerender(s));
    }
  }
  expandAll() {
    if (this.explorerService.isEditable(void 0)) {
      this.tree.domFocus();
    }
    this.tree.expandAll();
  }
  collapseAll() {
    if (this.explorerService.isEditable(void 0)) {
      this.tree.domFocus();
    }
    const treeInput = this.tree.getInput();
    if (Array.isArray(treeInput)) {
      if (hasExpandedRootChild(this.tree, treeInput)) {
        treeInput.forEach((folder) => {
          folder.children.forEach((child) => this.tree.hasNode(child) && this.tree.collapse(child, true));
        });
        return;
      }
    }
    this.tree.collapseAll();
  }
  previousCompressedStat() {
    const focused = this.tree.getFocus();
    if (!focused.length) {
      return;
    }
    const compressedNavigationController = this.renderer.getCompressedNavigationController(focused[0]);
    compressedNavigationController.previous();
    this.updateCompressedNavigationContextKeys(compressedNavigationController);
  }
  nextCompressedStat() {
    const focused = this.tree.getFocus();
    if (!focused.length) {
      return;
    }
    const compressedNavigationController = this.renderer.getCompressedNavigationController(focused[0]);
    compressedNavigationController.next();
    this.updateCompressedNavigationContextKeys(compressedNavigationController);
  }
  firstCompressedStat() {
    const focused = this.tree.getFocus();
    if (!focused.length) {
      return;
    }
    const compressedNavigationController = this.renderer.getCompressedNavigationController(focused[0]);
    compressedNavigationController.first();
    this.updateCompressedNavigationContextKeys(compressedNavigationController);
  }
  lastCompressedStat() {
    const focused = this.tree.getFocus();
    if (!focused.length) {
      return;
    }
    const compressedNavigationController = this.renderer.getCompressedNavigationController(focused[0]);
    compressedNavigationController.last();
    this.updateCompressedNavigationContextKeys(compressedNavigationController);
  }
  updateCompressedNavigationContextKeys(controller) {
    this.compressedFocusFirstContext.set(controller.index === 0);
    this.compressedFocusLastContext.set(controller.index === controller.count - 1);
  }
  updateAnyCollapsedContext() {
    const treeInput = this.tree.getInput();
    if (treeInput === void 0) {
      return;
    }
    const treeInputArray = Array.isArray(treeInput) ? treeInput : Array.from(treeInput.children.values());
    this.viewHasSomeCollapsibleRootItem.set(hasExpandedNode(this.tree, treeInputArray));
    this.storeTreeViewState();
  }
  dispose() {
    var _a43;
    (_a43 = this.dragHandler) == null ? void 0 : _a43.dispose();
    super.dispose();
  }
}, ExplorerView_1 = _a36, _a36.TREE_VIEW_STATE_STORAGE_KEY = "workbench.explorer.treeViewState", _a36);
ExplorerView.__decorator = __decorate([
  memoize
], ExplorerView.prototype, "fileCopiedContextKey", null);
ExplorerView.__decorator = __decorate([
  memoize
], ExplorerView.prototype, "resourceCutContextKey", null);
ExplorerView = ExplorerView_1 = __decorate([
  __param(1, IContextMenuService),
  __param(2, IViewDescriptorService),
  __param(3, IInstantiationService),
  __param(4, IWorkspaceContextService),
  __param(5, IProgressService),
  __param(6, IEditorService),
  __param(7, IEditorResolverService),
  __param(8, IWorkbenchLayoutService),
  __param(9, IKeybindingService),
  __param(10, IContextKeyService),
  __param(11, IConfigurationService),
  __param(12, IDecorationsService),
  __param(13, ILabelService),
  __param(14, IThemeService),
  __param(15, ITelemetryService),
  __param(16, IExplorerService),
  __param(17, IStorageService),
  __param(18, IClipboardService),
  __param(19, IFileService),
  __param(20, IUriIdentityService),
  __param(21, ICommandService),
  __param(22, IOpenerService)
], ExplorerView);
function createFileIconThemableTreeContainerScope(container, themeService) {
  container.classList.add("file-icon-themable-tree");
  container.classList.add("show-file-icons");
  const onDidChangeFileIconTheme = (theme) => {
    container.classList.toggle("align-icons-and-twisties", theme.hasFileIcons && !theme.hasFolderIcons);
    container.classList.toggle("hide-arrows", theme.hidesExplorerArrows === true);
  };
  onDidChangeFileIconTheme(themeService.getFileIconTheme());
  return themeService.onDidFileIconThemeChange(onDidChangeFileIconTheme);
}
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "workbench.files.action.createFileFromExplorer",
      title: localize("createNewFile", "New File..."),
      f1: false,
      icon: Codicon.newFile,
      precondition: ExplorerResourceNotReadonlyContext,
      menu: {
        id: MenuId.ViewTitle,
        group: "navigation",
        when: ContextKeyExpr.equals("view", VIEW_ID),
        order: 10
      }
    });
  }
  run(accessor) {
    const commandService = accessor.get(ICommandService);
    commandService.executeCommand(NEW_FILE_COMMAND_ID);
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "workbench.files.action.createFolderFromExplorer",
      title: localize("createNewFolder", "New Folder..."),
      f1: false,
      icon: Codicon.newFolder,
      precondition: ExplorerResourceNotReadonlyContext,
      menu: {
        id: MenuId.ViewTitle,
        group: "navigation",
        when: ContextKeyExpr.equals("view", VIEW_ID),
        order: 20
      }
    });
  }
  run(accessor) {
    const commandService = accessor.get(ICommandService);
    commandService.executeCommand(NEW_FOLDER_COMMAND_ID);
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "workbench.files.action.refreshFilesExplorer",
      title: { value: localize("refreshExplorer", "Refresh Explorer"), original: "Refresh Explorer" },
      f1: true,
      icon: Codicon.refresh,
      menu: {
        id: MenuId.ViewTitle,
        group: "navigation",
        when: ContextKeyExpr.equals("view", VIEW_ID),
        order: 30
      }
    });
  }
  async run(accessor) {
    const paneCompositeService = accessor.get(IPaneCompositePartService);
    const explorerService = accessor.get(IExplorerService);
    await paneCompositeService.openPaneComposite(VIEWLET_ID, 0);
    await explorerService.refresh();
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "workbench.files.action.collapseExplorerFolders",
      title: { value: localize("collapseExplorerFolders", "Collapse Folders in Explorer"), original: "Collapse Folders in Explorer" },
      f1: true,
      icon: Codicon.collapseAll,
      menu: {
        id: MenuId.ViewTitle,
        group: "navigation",
        when: ContextKeyExpr.equals("view", VIEW_ID),
        order: 40
      }
    });
  }
  run(accessor) {
    const viewsService = accessor.get(IViewsService);
    const view = viewsService.getViewWithId(VIEW_ID);
    if (view !== null) {
      const explorerView = view;
      explorerView.collapseAll();
    }
  }
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/emptyView.js
init_tslib_es6();
init_nls();
init_instantiation();
init_themeService();
init_configuration();
init_colorRegistry();
init_contextkey();
init_opener();
init_telemetry();
init_platform();
init_dom();
var EmptyView_1;
var _a37;
var EmptyView = (_a37 = class extends ViewPane {
  constructor(options, themeService, viewDescriptorService, instantiationService, keybindingService, contextMenuService, contextService, configurationService, labelService, contextKeyService, openerService, telemetryService) {
    super(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
    this.contextService = contextService;
    this.labelService = labelService;
    this._disposed = false;
    this._register(this.contextService.onDidChangeWorkbenchState(() => this.refreshTitle()));
    this._register(this.labelService.onDidChangeFormatters(() => this.refreshTitle()));
  }
  shouldShowWelcome() {
    return true;
  }
  renderBody(container) {
    super.renderBody(container);
    this._register(new DragAndDropObserver(container, {
      onDrop: (e) => {
        container.style.backgroundColor = "";
        const dropHandler = this.instantiationService.createInstance(ResourcesDropHandler, { allowWorkspaceOpen: !isWeb || isTemporaryWorkspace(this.contextService.getWorkspace()) });
        dropHandler.handleDrop(e, () => void 0, () => void 0);
      },
      onDragEnter: () => {
        const color = this.themeService.getColorTheme().getColor(listDropBackground);
        container.style.backgroundColor = color ? color.toString() : "";
      },
      onDragEnd: () => {
        container.style.backgroundColor = "";
      },
      onDragLeave: () => {
        container.style.backgroundColor = "";
      },
      onDragOver: (e) => {
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "copy";
        }
      }
    }));
    this.refreshTitle();
  }
  refreshTitle() {
    if (this._disposed) {
      return;
    }
    if (this.contextService.getWorkbenchState() === 3) {
      this.updateTitle(EmptyView_1.NAME);
    } else {
      this.updateTitle(this.title);
    }
  }
  dispose() {
    this._disposed = true;
    super.dispose();
  }
}, EmptyView_1 = _a37, _a37.ID = "workbench.explorer.emptyView", _a37.NAME = localize("noWorkspace", "No Folder Opened"), _a37);
EmptyView = EmptyView_1 = __decorate([
  __param(1, IThemeService),
  __param(2, IViewDescriptorService),
  __param(3, IInstantiationService),
  __param(4, IKeybindingService),
  __param(5, IContextMenuService),
  __param(6, IWorkspaceContextService),
  __param(7, IConfigurationService),
  __param(8, ILabelService),
  __param(9, IContextKeyService),
  __param(10, IOpenerService),
  __param(11, ITelemetryService)
], EmptyView);

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/openEditorsView.js
init_tslib_es6();

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/media/openeditors.css.js
var css6 = '.pane-header .open-editors-dirty-count-container{align-items:center;display:flex;min-width:fit-content}.pane-header .open-editors-dirty-count-container>.dirty-count.monaco-count-badge.hidden,.pane.horizontal:not(.expanded) .pane-header .open-editors-dirty-count-container>.dirty-count.monaco-count-badge{display:none}.pane-header .open-editors-dirty-count-container>.dirty-count.monaco-count-badge{margin-left:6px;min-height:auto;padding:2px 4px}.open-editors .monaco-list .monaco-list-row.dirty>.monaco-action-bar,.open-editors .monaco-list .monaco-list-row.focused>.monaco-action-bar,.open-editors .monaco-list .monaco-list-row.sticky>.monaco-action-bar,.open-editors .monaco-list .monaco-list-row:hover>.monaco-action-bar{visibility:visible}.open-editors .monaco-list .monaco-list-row>.monaco-action-bar .action-label{display:block;padding:2px}.open-editors .monaco-list .monaco-list-row>.monaco-action-bar .codicon{color:inherit}.open-editors .monaco-list .monaco-list-row.dirty:not(:hover)>.monaco-action-bar .codicon-pinned:before{content:"\\ebb2"}.open-editors .monaco-list .monaco-list-row.dirty:not(:hover)>.monaco-action-bar .codicon-close:before{content:"\\ea71"}.open-editors .monaco-list .monaco-list-row>.monaco-action-bar .action-close-all-files,.open-editors .monaco-list .monaco-list-row>.monaco-action-bar .save-all{height:22px;width:23px}.open-editors .monaco-list .monaco-list-row>.editor-group,.open-editors .monaco-list .monaco-list-row>.open-editor{flex:1}.open-editors .monaco-list .monaco-list-row{display:flex;padding-left:22px}.open-editors .monaco-list .monaco-list-row>.monaco-action-bar{align-items:center;display:flex;visibility:hidden}.open-editors .monaco-list .monaco-list-row .editor-group{cursor:default;font-size:11px;font-weight:700;text-transform:uppercase}.composite:lang(ja) .open-editors .monaco-list .monaco-list-row .editor-group,.composite:lang(ko) .open-editors .monaco-list .monaco-list-row .editor-group,.composite:lang(zh-Hans) .open-editors .monaco-list .monaco-list-row .editor-group,.composite:lang(zh-Hant) .open-editors .monaco-list .monaco-list-row .editor-group{font-weight:400}.open-editors .editor-group,.open-editors .open-editor{height:22px;line-height:22px}.open-editors .editor-group,.open-editors .open-editor>a{overflow:hidden;text-overflow:ellipsis}.monaco-workbench.hc-black .open-editors .editor-group,.monaco-workbench.hc-black .open-editors .open-editor,.monaco-workbench.hc-light .open-editors .editor-group,.monaco-workbench.hc-light .open-editors .open-editor{line-height:20px}';
n(css6, {});

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/openEditorsView.js
init_nls();
init_async();
init_actions();
init_dom();
init_instantiation();
init_configuration();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorActions.js
init_tslib_es6();
init_nls();
init_actions();
init_arrays();
init_commands();
init_configuration();
init_codicons();
init_themables();
init_platform();
init_actions2();
init_contextkey();
init_keyCodes();
init_log();
var ExecuteCommandAction = class extends Action2 {
  constructor(desc, commandId, commandArgs) {
    super(desc);
    this.commandId = commandId;
    this.commandArgs = commandArgs;
  }
  run(accessor) {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(this.commandId, this.commandArgs);
  }
};
var AbstractSplitEditorAction = class extends Action2 {
  getDirection(configurationService) {
    return preferredSideBySideGroupDirection(configurationService);
  }
  async run(accessor, context) {
    const editorGroupService = accessor.get(IEditorGroupsService);
    const configurationService = accessor.get(IConfigurationService);
    splitEditor(editorGroupService, this.getDirection(configurationService), context);
  }
};
var _SplitEditorAction = class _SplitEditorAction extends AbstractSplitEditorAction {
  constructor() {
    super({
      id: _SplitEditorAction.ID,
      title: { value: localize("splitEditor", "Split Editor"), original: "Split Editor" },
      f1: true,
      keybinding: {
        weight: 200,
        primary: 2048 | 93
      },
      category: Categories.View
    });
  }
};
_SplitEditorAction.ID = "workbench.action.splitEditor";
var SplitEditorAction = _SplitEditorAction;
var _SplitEditorUpAction = class _SplitEditorUpAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: SPLIT_EDITOR_UP,
      title: { value: localize("splitEditorGroupUp", "Split Editor Up"), original: "Split Editor Up" },
      f1: true,
      keybinding: {
        weight: 200,
        primary: KeyChord(2048 | 41, 2048 | 93)
      },
      category: Categories.View
    }, SPLIT_EDITOR_UP);
  }
};
_SplitEditorUpAction.LABEL = localize("splitEditorGroupUp", "Split Editor Up");
var SplitEditorUpAction = _SplitEditorUpAction;
var _SplitEditorDownAction = class _SplitEditorDownAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: SPLIT_EDITOR_DOWN,
      title: { value: localize("splitEditorGroupDown", "Split Editor Down"), original: "Split Editor Down" },
      f1: true,
      keybinding: {
        weight: 200,
        primary: KeyChord(2048 | 41, 2048 | 93)
      },
      category: Categories.View
    }, SPLIT_EDITOR_DOWN);
  }
};
_SplitEditorDownAction.LABEL = localize("splitEditorGroupDown", "Split Editor Down");
var SplitEditorDownAction = _SplitEditorDownAction;
var _a38;
var CloseEditorAction = (_a38 = class extends Action {
  constructor(id, label, commandService) {
    super(id, label, ThemeIcon.asClassName(Codicon.close));
    this.commandService = commandService;
  }
  run(context) {
    return this.commandService.executeCommand(CLOSE_EDITOR_COMMAND_ID, void 0, context);
  }
}, _a38.ID = "workbench.action.closeActiveEditor", _a38.LABEL = localize("closeEditor", "Close Editor"), _a38);
CloseEditorAction = __decorate([
  __param(2, ICommandService)
], CloseEditorAction);
var _a39;
var UnpinEditorAction = (_a39 = class extends Action {
  constructor(id, label, commandService) {
    super(id, label, ThemeIcon.asClassName(Codicon.pinned));
    this.commandService = commandService;
  }
  run(context) {
    return this.commandService.executeCommand(UNPIN_EDITOR_COMMAND_ID, void 0, context);
  }
}, _a39.ID = "workbench.action.unpinActiveEditor", _a39.LABEL = localize("unpinEditor", "Unpin Editor"), _a39);
UnpinEditorAction = __decorate([
  __param(2, ICommandService)
], UnpinEditorAction);
var _a40;
var CloseOneEditorAction = (_a40 = class extends Action {
  constructor(id, label, editorGroupService) {
    super(id, label, ThemeIcon.asClassName(Codicon.close));
    this.editorGroupService = editorGroupService;
  }
  async run(context) {
    let group;
    let editorIndex;
    if (context) {
      group = this.editorGroupService.getGroup(context.groupId);
      if (group) {
        editorIndex = context.editorIndex;
      }
    }
    if (!group) {
      group = this.editorGroupService.activeGroup;
    }
    if (typeof editorIndex === "number") {
      const editorAtIndex = group.getEditorByIndex(editorIndex);
      if (editorAtIndex) {
        await group.closeEditor(editorAtIndex, { preserveFocus: context == null ? void 0 : context.preserveFocus });
        return;
      }
    }
    if (group.activeEditor) {
      await group.closeEditor(group.activeEditor, { preserveFocus: context == null ? void 0 : context.preserveFocus });
      return;
    }
  }
}, _a40.ID = "workbench.action.closeActiveEditor", _a40.LABEL = localize("closeOneEditor", "Close"), _a40);
CloseOneEditorAction = __decorate([
  __param(2, IEditorGroupsService)
], CloseOneEditorAction);
var AbstractCloseAllAction = class extends Action2 {
  groupsToClose(editorGroupService) {
    const groupsToClose = [];
    const groups = editorGroupService.getGroups(2);
    for (let i = groups.length - 1; i >= 0; i--) {
      groupsToClose.push(groups[i]);
    }
    return groupsToClose;
  }
  async run(accessor) {
    var _a43, _b, _c, _d;
    const editorService = accessor.get(IEditorService);
    const editorGroupService = accessor.get(IEditorGroupsService);
    const filesConfigurationService = accessor.get(IFilesConfigurationService);
    const fileDialogService = accessor.get(IFileDialogService);
    const dirtyEditorsWithDefaultConfirm = /* @__PURE__ */ new Set();
    const dirtyAutoSaveOnFocusChangeEditors = /* @__PURE__ */ new Set();
    const dirtyAutoSaveOnWindowChangeEditors = /* @__PURE__ */ new Set();
    const editorsWithCustomConfirm = /* @__PURE__ */ new Map();
    for (const { editor, groupId } of editorService.getEditors(1, { excludeSticky: this.excludeSticky })) {
      let confirmClose = false;
      if (editor.closeHandler) {
        confirmClose = editor.closeHandler.showConfirm();
      } else {
        confirmClose = editor.isDirty() && !editor.isSaving();
      }
      if (!confirmClose) {
        continue;
      }
      if (typeof ((_a43 = editor.closeHandler) == null ? void 0 : _a43.confirm) === "function") {
        let customEditorsToConfirm = editorsWithCustomConfirm.get(editor.typeId);
        if (!customEditorsToConfirm) {
          customEditorsToConfirm = /* @__PURE__ */ new Set();
          editorsWithCustomConfirm.set(editor.typeId, customEditorsToConfirm);
        }
        customEditorsToConfirm.add({ editor, groupId });
      } else if (filesConfigurationService.getAutoSaveMode() === 3 && !editor.hasCapability(4)) {
        dirtyAutoSaveOnFocusChangeEditors.add({ editor, groupId });
      } else if (isNative && (isWindows || isLinux) && filesConfigurationService.getAutoSaveMode() === 4 && !editor.hasCapability(4)) {
        dirtyAutoSaveOnWindowChangeEditors.add({ editor, groupId });
      } else {
        dirtyEditorsWithDefaultConfirm.add({ editor, groupId });
      }
    }
    if (dirtyEditorsWithDefaultConfirm.size > 0) {
      const editors = Array.from(dirtyEditorsWithDefaultConfirm.values());
      await this.revealEditorsToConfirm(editors, editorGroupService);
      const confirmation = await fileDialogService.showSaveConfirm(editors.map(({ editor }) => {
        if (editor instanceof SideBySideEditorInput) {
          return editor.primary.getName();
        }
        return editor.getName();
      }));
      switch (confirmation) {
        case 2:
          return;
        case 1:
          await editorService.revert(editors, { soft: true });
          break;
        case 0:
          await editorService.save(editors, { reason: 1 });
          break;
      }
    }
    for (const [, editorIdentifiers] of editorsWithCustomConfirm) {
      const editors = Array.from(editorIdentifiers.values());
      await this.revealEditorsToConfirm(editors, editorGroupService);
      const confirmation = await ((_d = (_c = (_b = firstOrDefault(editors)) == null ? void 0 : _b.editor.closeHandler) == null ? void 0 : _c.confirm) == null ? void 0 : _d.call(_c, editors));
      if (typeof confirmation === "number") {
        switch (confirmation) {
          case 2:
            return;
          case 1:
            await editorService.revert(editors, { soft: true });
            break;
          case 0:
            await editorService.save(editors, { reason: 1 });
            break;
        }
      }
    }
    if (dirtyAutoSaveOnFocusChangeEditors.size > 0) {
      const editors = Array.from(dirtyAutoSaveOnFocusChangeEditors.values());
      await editorService.save(editors, { reason: 3 });
    }
    if (dirtyAutoSaveOnWindowChangeEditors.size > 0) {
      const editors = Array.from(dirtyAutoSaveOnWindowChangeEditors.values());
      await editorService.save(editors, { reason: 4 });
    }
    return this.doCloseAll(editorGroupService);
  }
  async revealEditorsToConfirm(editors, editorGroupService) {
    try {
      const handledGroups = /* @__PURE__ */ new Set();
      for (const { editor, groupId } of editors) {
        if (handledGroups.has(groupId)) {
          continue;
        }
        handledGroups.add(groupId);
        const group = editorGroupService.getGroup(groupId);
        await (group == null ? void 0 : group.openEditor(editor));
      }
    } catch (error) {
    }
  }
  async doCloseAll(editorGroupService) {
    await Promise.all(this.groupsToClose(editorGroupService).map((group) => group.closeAllEditors({ excludeSticky: this.excludeSticky })));
  }
};
var _CloseAllEditorsAction = class _CloseAllEditorsAction extends AbstractCloseAllAction {
  constructor() {
    super({
      id: _CloseAllEditorsAction.ID,
      title: _CloseAllEditorsAction.LABEL,
      f1: true,
      keybinding: {
        weight: 200,
        primary: KeyChord(2048 | 41, 2048 | 53)
      },
      icon: Codicon.closeAll,
      category: Categories.View
    });
  }
  get excludeSticky() {
    return true;
  }
};
_CloseAllEditorsAction.ID = "workbench.action.closeAllEditors";
_CloseAllEditorsAction.LABEL = { value: localize("closeAllEditors", "Close All Editors"), original: "Close All Editors" };
var CloseAllEditorsAction = _CloseAllEditorsAction;
var _NavigateForwardAction = class _NavigateForwardAction extends Action2 {
  constructor() {
    super({
      id: _NavigateForwardAction.ID,
      title: { value: localize("navigateForward", "Go Forward"), original: "Go Forward", mnemonicTitle: localize({ key: "miForward", comment: ["&& denotes a mnemonic"] }, "&&Forward") },
      f1: true,
      icon: Codicon.arrowRight,
      precondition: ContextKeyExpr.has("canNavigateForward"),
      keybinding: {
        weight: 200,
        win: { primary: 512 | 17 },
        mac: { primary: 256 | 1024 | 88 },
        linux: { primary: 2048 | 1024 | 88 }
      },
      menu: [
        { id: MenuId.MenubarGoMenu, group: "1_history_nav", order: 2 },
        { id: MenuId.CommandCenter, order: 2 }
      ]
    });
  }
  async run(accessor) {
    const historyService = accessor.get(IHistoryService);
    await historyService.goForward(0);
  }
};
_NavigateForwardAction.ID = "workbench.action.navigateForward";
_NavigateForwardAction.LABEL = localize("navigateForward", "Go Forward");
var NavigateForwardAction = _NavigateForwardAction;
var _NavigateBackwardsAction = class _NavigateBackwardsAction extends Action2 {
  constructor() {
    super({
      id: _NavigateBackwardsAction.ID,
      title: { value: localize("navigateBack", "Go Back"), original: "Go Back", mnemonicTitle: localize({ key: "miBack", comment: ["&& denotes a mnemonic"] }, "&&Back") },
      f1: true,
      precondition: ContextKeyExpr.has("canNavigateBack"),
      icon: Codicon.arrowLeft,
      keybinding: {
        weight: 200,
        win: { primary: 512 | 15 },
        mac: { primary: 256 | 88 },
        linux: { primary: 2048 | 512 | 88 }
      },
      menu: [
        { id: MenuId.MenubarGoMenu, group: "1_history_nav", order: 1 },
        { id: MenuId.CommandCenter, order: 1 }
      ]
    });
  }
  async run(accessor) {
    const historyService = accessor.get(IHistoryService);
    await historyService.goBack(0);
  }
};
_NavigateBackwardsAction.ID = "workbench.action.navigateBack";
_NavigateBackwardsAction.LABEL = localize("navigateBack", "Go Back");
var NavigateBackwardsAction = _NavigateBackwardsAction;
var _ReopenClosedEditorAction = class _ReopenClosedEditorAction extends Action2 {
  constructor() {
    super({
      id: _ReopenClosedEditorAction.ID,
      title: { value: localize("reopenClosedEditor", "Reopen Closed Editor"), original: "Reopen Closed Editor" },
      f1: true,
      keybinding: {
        weight: 200,
        primary: 2048 | 1024 | 50
      },
      category: Categories.View
    });
  }
  async run(accessor) {
    const historyService = accessor.get(IHistoryService);
    await historyService.reopenLastClosedEditor();
  }
};
_ReopenClosedEditorAction.ID = "workbench.action.reopenClosedEditor";
var ReopenClosedEditorAction = _ReopenClosedEditorAction;
var _ClearRecentFilesAction = class _ClearRecentFilesAction extends Action2 {
  constructor() {
    super({
      id: _ClearRecentFilesAction.ID,
      title: { value: localize("clearRecentFiles", "Clear Recently Opened"), original: "Clear Recently Opened" },
      f1: true,
      category: Categories.File
    });
  }
  async run(accessor) {
    const dialogService = accessor.get(IDialogService);
    const workspacesService = accessor.get(IWorkspacesService);
    const historyService = accessor.get(IHistoryService);
    const { confirmed } = await dialogService.confirm({
      type: "warning",
      message: localize(
        "confirmClearRecentsMessage",
        "Do you want to clear all recently opened files and workspaces?"
      ),
      detail: localize("confirmClearDetail", "This action is irreversible!"),
      primaryButton: localize({ key: "clearButtonLabel", comment: ["&& denotes a mnemonic"] }, "&&Clear")
    });
    if (!confirmed) {
      return;
    }
    workspacesService.clearRecentlyOpened();
    historyService.clearRecentlyOpened();
  }
};
_ClearRecentFilesAction.ID = "workbench.action.clearRecentFiles";
var ClearRecentFilesAction = _ClearRecentFilesAction;
var _ShowEditorsInActiveGroupByMostRecentlyUsedAction = class _ShowEditorsInActiveGroupByMostRecentlyUsedAction extends Action2 {
  constructor() {
    super({
      id: _ShowEditorsInActiveGroupByMostRecentlyUsedAction.ID,
      title: { value: localize(
        "showEditorsInActiveGroup",
        "Show Editors in Active Group By Most Recently Used"
      ), original: "Show Editors in Active Group By Most Recently Used" },
      f1: true,
      category: Categories.View
    });
  }
  async run(accessor) {
    const quickInputService = accessor.get(IQuickInputService);
    quickInputService.quickAccess.show(ActiveGroupEditorsByMostRecentlyUsedQuickAccess.PREFIX);
  }
};
_ShowEditorsInActiveGroupByMostRecentlyUsedAction.ID = "workbench.action.showEditorsInActiveGroup";
var ShowEditorsInActiveGroupByMostRecentlyUsedAction = _ShowEditorsInActiveGroupByMostRecentlyUsedAction;
var _ShowAllEditorsByAppearanceAction = class _ShowAllEditorsByAppearanceAction extends Action2 {
  constructor() {
    super({
      id: _ShowAllEditorsByAppearanceAction.ID,
      title: { value: localize("showAllEditors", "Show All Editors By Appearance"), original: "Show All Editors By Appearance" },
      f1: true,
      keybinding: {
        weight: 200,
        primary: KeyChord(2048 | 41, 2048 | 46),
        mac: {
          primary: 2048 | 512 | 2
        }
      },
      category: Categories.File
    });
  }
  async run(accessor) {
    const quickInputService = accessor.get(IQuickInputService);
    quickInputService.quickAccess.show(AllEditorsByAppearanceQuickAccess.PREFIX);
  }
};
_ShowAllEditorsByAppearanceAction.ID = "workbench.action.showAllEditors";
var ShowAllEditorsByAppearanceAction = _ShowAllEditorsByAppearanceAction;
var _ShowAllEditorsByMostRecentlyUsedAction = class _ShowAllEditorsByMostRecentlyUsedAction extends Action2 {
  constructor() {
    super({
      id: _ShowAllEditorsByMostRecentlyUsedAction.ID,
      title: { value: localize(
        "showAllEditorsByMostRecentlyUsed",
        "Show All Editors By Most Recently Used"
      ), original: "Show All Editors By Most Recently Used" },
      f1: true,
      category: Categories.View
    });
  }
  async run(accessor) {
    const quickInputService = accessor.get(IQuickInputService);
    quickInputService.quickAccess.show(AllEditorsByMostRecentlyUsedQuickAccess.PREFIX);
  }
};
_ShowAllEditorsByMostRecentlyUsedAction.ID = "workbench.action.showAllEditorsByMostRecentlyUsed";
var ShowAllEditorsByMostRecentlyUsedAction = _ShowAllEditorsByMostRecentlyUsedAction;
var _QuickAccessPreviousEditorFromHistoryAction = class _QuickAccessPreviousEditorFromHistoryAction extends Action2 {
  constructor() {
    super({
      id: _QuickAccessPreviousEditorFromHistoryAction.ID,
      title: { value: localize("navigateEditorHistoryByInput", "Quick Open Previous Editor from History"), original: "Quick Open Previous Editor from History" },
      f1: true
    });
  }
  async run(accessor) {
    const keybindingService = accessor.get(IKeybindingService);
    const quickInputService = accessor.get(IQuickInputService);
    const editorGroupService = accessor.get(IEditorGroupsService);
    const keybindings = keybindingService.lookupKeybindings(_QuickAccessPreviousEditorFromHistoryAction.ID);
    let itemActivation = void 0;
    if (editorGroupService.activeGroup.count === 0) {
      itemActivation = ItemActivation.FIRST;
    }
    quickInputService.quickAccess.show("", { quickNavigateConfiguration: { keybindings }, itemActivation });
  }
};
_QuickAccessPreviousEditorFromHistoryAction.ID = "workbench.action.openPreviousEditorFromHistory";
var QuickAccessPreviousEditorFromHistoryAction = _QuickAccessPreviousEditorFromHistoryAction;
var _SplitEditorToLeftGroupAction = class _SplitEditorToLeftGroupAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: "workbench.action.splitEditorToLeftGroup",
      title: { value: localize("splitEditorToLeftGroup", "Split Editor into Left Group"), original: "Split Editor into Left Group" },
      f1: true,
      category: Categories.View
    }, COPY_ACTIVE_EDITOR_COMMAND_ID, { to: "left", by: "group" });
  }
};
_SplitEditorToLeftGroupAction.ID = "workbench.action.splitEditorToLeftGroup";
_SplitEditorToLeftGroupAction.LABEL = localize("splitEditorToLeftGroup", "Split Editor into Left Group");
var SplitEditorToLeftGroupAction = _SplitEditorToLeftGroupAction;
var _EditorLayoutSingleAction = class _EditorLayoutSingleAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: _EditorLayoutSingleAction.ID,
      title: { value: localize("editorLayoutSingle", "Single Column Editor Layout"), original: "Single Column Editor Layout" },
      f1: true,
      category: Categories.View
    }, LAYOUT_EDITOR_GROUPS_COMMAND_ID, { groups: [{}] });
  }
};
_EditorLayoutSingleAction.ID = "workbench.action.editorLayoutSingle";
var EditorLayoutSingleAction = _EditorLayoutSingleAction;
var _EditorLayoutTwoColumnsAction = class _EditorLayoutTwoColumnsAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: _EditorLayoutTwoColumnsAction.ID,
      title: { value: localize("editorLayoutTwoColumns", "Two Columns Editor Layout"), original: "Two Columns Editor Layout" },
      f1: true,
      category: Categories.View
    }, LAYOUT_EDITOR_GROUPS_COMMAND_ID, { groups: [{}, {}], orientation: 0 });
  }
};
_EditorLayoutTwoColumnsAction.ID = "workbench.action.editorLayoutTwoColumns";
var EditorLayoutTwoColumnsAction = _EditorLayoutTwoColumnsAction;
var _EditorLayoutThreeColumnsAction = class _EditorLayoutThreeColumnsAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: _EditorLayoutThreeColumnsAction.ID,
      title: { value: localize("editorLayoutThreeColumns", "Three Columns Editor Layout"), original: "Three Columns Editor Layout" },
      f1: true,
      category: Categories.View
    }, LAYOUT_EDITOR_GROUPS_COMMAND_ID, { groups: [{}, {}, {}], orientation: 0 });
  }
};
_EditorLayoutThreeColumnsAction.ID = "workbench.action.editorLayoutThreeColumns";
var EditorLayoutThreeColumnsAction = _EditorLayoutThreeColumnsAction;
var _EditorLayoutTwoRowsAction = class _EditorLayoutTwoRowsAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: _EditorLayoutTwoRowsAction.ID,
      title: { value: localize("editorLayoutTwoRows", "Two Rows Editor Layout"), original: "Two Rows Editor Layout" },
      f1: true,
      category: Categories.View
    }, LAYOUT_EDITOR_GROUPS_COMMAND_ID, { groups: [{}, {}], orientation: 1 });
  }
};
_EditorLayoutTwoRowsAction.ID = "workbench.action.editorLayoutTwoRows";
var EditorLayoutTwoRowsAction = _EditorLayoutTwoRowsAction;
var _EditorLayoutThreeRowsAction = class _EditorLayoutThreeRowsAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: _EditorLayoutThreeRowsAction.ID,
      title: { value: localize("editorLayoutThreeRows", "Three Rows Editor Layout"), original: "Three Rows Editor Layout" },
      f1: true,
      category: Categories.View
    }, LAYOUT_EDITOR_GROUPS_COMMAND_ID, { groups: [{}, {}, {}], orientation: 1 });
  }
};
_EditorLayoutThreeRowsAction.ID = "workbench.action.editorLayoutThreeRows";
var EditorLayoutThreeRowsAction = _EditorLayoutThreeRowsAction;
var _EditorLayoutTwoByTwoGridAction = class _EditorLayoutTwoByTwoGridAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: _EditorLayoutTwoByTwoGridAction.ID,
      title: { value: localize("editorLayoutTwoByTwoGrid", "Grid Editor Layout (2x2)"), original: "Grid Editor Layout (2x2)" },
      f1: true,
      category: Categories.View
    }, LAYOUT_EDITOR_GROUPS_COMMAND_ID, { groups: [{ groups: [{}, {}] }, { groups: [{}, {}] }] });
  }
};
_EditorLayoutTwoByTwoGridAction.ID = "workbench.action.editorLayoutTwoByTwoGrid";
var EditorLayoutTwoByTwoGridAction = _EditorLayoutTwoByTwoGridAction;
var _EditorLayoutTwoColumnsBottomAction = class _EditorLayoutTwoColumnsBottomAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: _EditorLayoutTwoColumnsBottomAction.ID,
      title: { value: localize("editorLayoutTwoColumnsBottom", "Two Columns Bottom Editor Layout"), original: "Two Columns Bottom Editor Layout" },
      f1: true,
      category: Categories.View
    }, LAYOUT_EDITOR_GROUPS_COMMAND_ID, { groups: [{}, { groups: [{}, {}] }], orientation: 1 });
  }
};
_EditorLayoutTwoColumnsBottomAction.ID = "workbench.action.editorLayoutTwoColumnsBottom";
var EditorLayoutTwoColumnsBottomAction = _EditorLayoutTwoColumnsBottomAction;
var _EditorLayoutTwoRowsRightAction = class _EditorLayoutTwoRowsRightAction extends ExecuteCommandAction {
  constructor() {
    super({
      id: _EditorLayoutTwoRowsRightAction.ID,
      title: { value: localize("editorLayoutTwoRowsRight", "Two Rows Right Editor Layout"), original: "Two Rows Right Editor Layout" },
      f1: true,
      category: Categories.View
    }, LAYOUT_EDITOR_GROUPS_COMMAND_ID, { groups: [{}, { groups: [{}, {}] }], orientation: 0 });
  }
};
_EditorLayoutTwoRowsRightAction.ID = "workbench.action.editorLayoutTwoRowsRight";
var EditorLayoutTwoRowsRightAction = _EditorLayoutTwoRowsRightAction;

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/views/openEditorsView.js
init_contextkey();
init_themeService();
init_colorRegistry();
init_telemetry();
init_lifecycle();
init_actions2();
init_opener();
init_network();
init_resources();
var OpenEditorsView_1;
var $2 = $;
var _a41;
var OpenEditorsView = (_a41 = class extends ViewPane {
  constructor(options, instantiationService, viewDescriptorService, contextMenuService, editorGroupService, configurationService, keybindingService, contextKeyService, themeService, telemetryService, workingCopyService, filesConfigurationService, openerService) {
    super(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
    this.editorGroupService = editorGroupService;
    this.workingCopyService = workingCopyService;
    this.filesConfigurationService = filesConfigurationService;
    this.needsRefresh = false;
    this.elements = [];
    this.structuralRefreshDelay = 0;
    this.sortOrder = configurationService.getValue("explorer.openEditors.sortOrder");
    this.registerUpdateEvents();
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationChange(e)));
    this._register(this.workingCopyService.onDidChangeDirty((workingCopy) => this.updateDirtyIndicator(workingCopy)));
  }
  registerUpdateEvents() {
    const updateWholeList = () => {
      var _a43;
      if (!this.isBodyVisible() || !this.list) {
        this.needsRefresh = true;
        return;
      }
      (_a43 = this.listRefreshScheduler) == null ? void 0 : _a43.schedule(this.structuralRefreshDelay);
    };
    const groupDisposables = /* @__PURE__ */ new Map();
    const addGroupListener = (group) => {
      const groupModelChangeListener = group.onDidModelChange((e) => {
        var _a43;
        if ((_a43 = this.listRefreshScheduler) == null ? void 0 : _a43.isScheduled()) {
          return;
        }
        if (!this.isBodyVisible() || !this.list) {
          this.needsRefresh = true;
          return;
        }
        const index = this.getIndex(group, e.editor);
        switch (e.kind) {
          case 6:
          case 0:
            this.focusActiveEditor();
            break;
          case 1:
            if (index >= 0) {
              this.list.splice(index, 1, [group]);
            }
            break;
          case 11:
          case 10:
          case 8:
          case 9:
          case 7:
            this.list.splice(index, 1, [new OpenEditor(e.editor, group)]);
            this.focusActiveEditor();
            break;
          case 3:
          case 5:
          case 4:
            updateWholeList();
            break;
        }
      });
      groupDisposables.set(group.id, groupModelChangeListener);
      this._register(groupDisposables.get(group.id));
    };
    this.editorGroupService.groups.forEach((g) => addGroupListener(g));
    this._register(this.editorGroupService.onDidAddGroup((group) => {
      addGroupListener(group);
      updateWholeList();
    }));
    this._register(this.editorGroupService.onDidMoveGroup(() => updateWholeList()));
    this._register(this.editorGroupService.onDidRemoveGroup((group) => {
      dispose(groupDisposables.get(group.id));
      updateWholeList();
    }));
  }
  renderHeaderTitle(container) {
    super.renderHeaderTitle(container, this.title);
    const count = append(container, $2(".open-editors-dirty-count-container"));
    this.dirtyCountElement = append(count, $2(".dirty-count.monaco-count-badge.long"));
    this.dirtyCountElement.style.backgroundColor = asCssVariable(badgeBackground);
    this.dirtyCountElement.style.color = asCssVariable(badgeForeground);
    this.dirtyCountElement.style.border = `1px solid ${asCssVariable(contrastBorder)}`;
    this.updateDirtyIndicator();
  }
  renderBody(container) {
    super.renderBody(container);
    container.classList.add("open-editors");
    container.classList.add("show-file-icons");
    const delegate = new OpenEditorsDelegate();
    if (this.list) {
      this.list.dispose();
    }
    if (this.listLabels) {
      this.listLabels.clear();
    }
    this.listLabels = this.instantiationService.createInstance(ResourceLabels, { onDidChangeVisibility: this.onDidChangeBodyVisibility });
    this.list = this.instantiationService.createInstance(WorkbenchList, "OpenEditors", container, delegate, [
      new EditorGroupRenderer(this.keybindingService, this.instantiationService),
      new OpenEditorRenderer(
        this.listLabels,
        this.instantiationService,
        this.keybindingService,
        this.configurationService
      )
    ], {
      identityProvider: { getId: (element) => element instanceof OpenEditor ? element.getId() : element.id.toString() },
      dnd: new OpenEditorsDragAndDrop(this.instantiationService, this.editorGroupService),
      overrideStyles: {
        listBackground: this.getBackgroundColor()
      },
      accessibilityProvider: new OpenEditorsAccessibilityProvider()
    });
    this._register(this.list);
    this._register(this.listLabels);
    let labelChangeListeners = [];
    this.listRefreshScheduler = this._register(new RunOnceScheduler(() => {
      if (!this.list) {
        return;
      }
      labelChangeListeners = dispose(labelChangeListeners);
      const previousLength = this.list.length;
      const elements = this.getElements();
      this.list.splice(0, this.list.length, elements);
      this.focusActiveEditor();
      if (previousLength !== this.list.length) {
        this.updateSize();
      }
      this.needsRefresh = false;
      if (this.sortOrder === "alphabetical" || this.sortOrder === "fullPath") {
        elements.forEach((e) => {
          if (e instanceof OpenEditor) {
            labelChangeListeners.push(e.editor.onDidChangeLabel(() => {
              var _a43;
              return (_a43 = this.listRefreshScheduler) == null ? void 0 : _a43.schedule();
            }));
          }
        });
      }
    }, this.structuralRefreshDelay));
    this.updateSize();
    OpenEditorsFocusedContext.bindTo(this.list.contextKeyService);
    ExplorerFocusedContext.bindTo(this.list.contextKeyService);
    this.resourceContext = this.instantiationService.createInstance(ResourceContextKey);
    this._register(this.resourceContext);
    this.groupFocusedContext = OpenEditorsGroupContext.bindTo(this.contextKeyService);
    this.dirtyEditorFocusedContext = OpenEditorsDirtyEditorContext.bindTo(this.contextKeyService);
    this.readonlyEditorFocusedContext = OpenEditorsReadonlyEditorContext.bindTo(this.contextKeyService);
    this._register(this.list.onContextMenu((e) => this.onListContextMenu(e)));
    this.list.onDidChangeFocus((e) => {
      this.resourceContext.reset();
      this.groupFocusedContext.reset();
      this.dirtyEditorFocusedContext.reset();
      this.readonlyEditorFocusedContext.reset();
      const element = e.elements.length ? e.elements[0] : void 0;
      if (element instanceof OpenEditor) {
        const resource = element.getResource();
        this.dirtyEditorFocusedContext.set(element.editor.isDirty() && !element.editor.isSaving());
        this.readonlyEditorFocusedContext.set(!!element.editor.isReadonly());
        this.resourceContext.set(resource ?? null);
      } else if (!!element) {
        this.groupFocusedContext.set(true);
      }
    });
    this._register(this.list.onMouseMiddleClick((e) => {
      if (e && e.element instanceof OpenEditor) {
        if (preventEditorClose(e.element.group, e.element.editor, EditorCloseMethod.MOUSE, this.editorGroupService.partOptions)) {
          return;
        }
        e.element.group.closeEditor(e.element.editor, { preserveFocus: true });
      }
    }));
    this._register(this.list.onDidOpen((e) => {
      if (!e.element) {
        return;
      } else if (e.element instanceof OpenEditor) {
        if (e.browserEvent instanceof MouseEvent && e.browserEvent.button === 1) {
          return;
        }
        this.openEditor(e.element, { preserveFocus: e.editorOptions.preserveFocus, pinned: e.editorOptions.pinned, sideBySide: e.sideBySide });
      } else {
        this.editorGroupService.activateGroup(e.element);
      }
    }));
    this.listRefreshScheduler.schedule(0);
    this._register(this.onDidChangeBodyVisibility((visible) => {
      var _a43;
      if (visible && this.needsRefresh) {
        (_a43 = this.listRefreshScheduler) == null ? void 0 : _a43.schedule(0);
      }
    }));
    const containerModel = this.viewDescriptorService.getViewContainerModel(this.viewDescriptorService.getViewContainerByViewId(this.id));
    this._register(containerModel.onDidChangeAllViewDescriptors(() => {
      this.updateSize();
    }));
  }
  focus() {
    super.focus();
    this.list.domFocus();
  }
  getList() {
    return this.list;
  }
  layoutBody(height, width) {
    var _a43;
    super.layoutBody(height, width);
    (_a43 = this.list) == null ? void 0 : _a43.layout(height, width);
  }
  get showGroups() {
    return this.editorGroupService.groups.length > 1;
  }
  getElements() {
    this.elements = [];
    this.editorGroupService.getGroups(2).forEach((g) => {
      if (this.showGroups) {
        this.elements.push(g);
      }
      let editors = g.editors.map((ei) => new OpenEditor(ei, g));
      if (this.sortOrder === "alphabetical") {
        editors = editors.sort((first2, second) => compareFileNamesDefault(first2.editor.getName(), second.editor.getName()));
      } else if (this.sortOrder === "fullPath") {
        editors = editors.sort((first2, second) => {
          const firstResource = first2.editor.resource;
          const secondResource = second.editor.resource;
          if (firstResource === void 0 && secondResource === void 0) {
            return compareFileNamesDefault(first2.editor.getName(), second.editor.getName());
          } else if (firstResource === void 0) {
            return -1;
          } else if (secondResource === void 0) {
            return 1;
          } else {
            const firstScheme = firstResource.scheme;
            const secondScheme = secondResource.scheme;
            if (firstScheme !== Schemas.file && secondScheme !== Schemas.file) {
              return extUriIgnorePathCase.compare(firstResource, secondResource);
            } else if (firstScheme !== Schemas.file) {
              return -1;
            } else if (secondScheme !== Schemas.file) {
              return 1;
            } else {
              return extUriIgnorePathCase.compare(firstResource, secondResource);
            }
          }
        });
      }
      this.elements.push(...editors);
    });
    return this.elements;
  }
  getIndex(group, editor) {
    if (!editor) {
      return this.elements.findIndex((e) => !(e instanceof OpenEditor) && e.id === group.id);
    }
    return this.elements.findIndex((e) => e instanceof OpenEditor && e.editor === editor && e.group.id === group.id);
  }
  openEditor(element, options) {
    if (element) {
      this.telemetryService.publicLog2("workbenchActionExecuted", { id: "workbench.files.openFile", from: "openEditors" });
      const preserveActivateGroup = options.sideBySide && options.preserveFocus;
      if (!preserveActivateGroup) {
        this.editorGroupService.activateGroup(element.group);
      }
      const targetGroup = options.sideBySide ? this.editorGroupService.sideGroup : this.editorGroupService.activeGroup;
      targetGroup.openEditor(element.editor, options);
    }
  }
  onListContextMenu(e) {
    if (!e.element) {
      return;
    }
    const element = e.element;
    this.contextMenuService.showContextMenu({
      menuId: MenuId.OpenEditorsContext,
      menuActionOptions: { shouldForwardArgs: true, arg: element instanceof OpenEditor ? EditorResourceAccessor.getOriginalUri(element.editor) : {} },
      contextKeyService: this.list.contextKeyService,
      getAnchor: () => e.anchor,
      getActionsContext: () => element instanceof OpenEditor ? { groupId: element.groupId, editorIndex: element.group.getIndexOfEditor(element.editor) } : { groupId: element.id }
    });
  }
  focusActiveEditor() {
    if (this.list.length && this.editorGroupService.activeGroup) {
      const index = this.getIndex(this.editorGroupService.activeGroup, this.editorGroupService.activeGroup.activeEditor);
      if (index >= 0) {
        try {
          this.list.setFocus([index]);
          this.list.setSelection([index]);
          this.list.reveal(index);
        } catch (e) {
        }
        return;
      }
    }
    this.list.setFocus([]);
    this.list.setSelection([]);
  }
  onConfigurationChange(event) {
    var _a43;
    if (event.affectsConfiguration("explorer.openEditors")) {
      this.updateSize();
    }
    if (event.affectsConfiguration("explorer.decorations") || event.affectsConfiguration("explorer.openEditors.sortOrder")) {
      this.sortOrder = this.configurationService.getValue("explorer.openEditors.sortOrder");
      (_a43 = this.listRefreshScheduler) == null ? void 0 : _a43.schedule();
    }
  }
  updateSize() {
    this.minimumBodySize = this.orientation === 0 ? this.getMinExpandedBodySize() : 170;
    this.maximumBodySize = this.orientation === 0 ? this.getMaxExpandedBodySize() : Number.POSITIVE_INFINITY;
  }
  updateDirtyIndicator(workingCopy) {
    if (workingCopy) {
      const gotDirty = workingCopy.isDirty();
      if (gotDirty && !(workingCopy.capabilities & 2) && this.filesConfigurationService.getAutoSaveMode() === 1) {
        return;
      }
    }
    const dirty = this.workingCopyService.dirtyCount;
    if (dirty === 0) {
      this.dirtyCountElement.classList.add("hidden");
    } else {
      this.dirtyCountElement.textContent = localize("dirtyCounter", "{0} unsaved", dirty);
      this.dirtyCountElement.classList.remove("hidden");
    }
  }
  get elementCount() {
    return this.editorGroupService.groups.map((g) => g.count).reduce((first2, second) => first2 + second, this.showGroups ? this.editorGroupService.groups.length : 0);
  }
  getMaxExpandedBodySize() {
    let minVisibleOpenEditors = this.configurationService.getValue("explorer.openEditors.minVisible");
    if (typeof minVisibleOpenEditors !== "number") {
      minVisibleOpenEditors = OpenEditorsView_1.DEFAULT_MIN_VISIBLE_OPEN_EDITORS;
    }
    const containerModel = this.viewDescriptorService.getViewContainerModel(this.viewDescriptorService.getViewContainerByViewId(this.id));
    if (containerModel.visibleViewDescriptors.length <= 1) {
      return Number.POSITIVE_INFINITY;
    }
    return Math.max(this.elementCount, minVisibleOpenEditors) * OpenEditorsDelegate.ITEM_HEIGHT;
  }
  getMinExpandedBodySize() {
    let visibleOpenEditors = this.configurationService.getValue("explorer.openEditors.visible");
    if (typeof visibleOpenEditors !== "number") {
      visibleOpenEditors = OpenEditorsView_1.DEFAULT_VISIBLE_OPEN_EDITORS;
    }
    return this.computeMinExpandedBodySize(visibleOpenEditors);
  }
  computeMinExpandedBodySize(visibleOpenEditors = OpenEditorsView_1.DEFAULT_VISIBLE_OPEN_EDITORS) {
    const itemsToShow = Math.min(Math.max(visibleOpenEditors, 1), this.elementCount);
    return itemsToShow * OpenEditorsDelegate.ITEM_HEIGHT;
  }
  setStructuralRefreshDelay(delay) {
    this.structuralRefreshDelay = delay;
  }
  getOptimalWidth() {
    const parentNode = this.list.getHTMLElement();
    const childNodes = [].slice.call(parentNode.querySelectorAll(".open-editor > a"));
    return getLargestChildWidth(parentNode, childNodes);
  }
}, OpenEditorsView_1 = _a41, _a41.DEFAULT_VISIBLE_OPEN_EDITORS = 9, _a41.DEFAULT_MIN_VISIBLE_OPEN_EDITORS = 0, _a41.ID = "workbench.explorer.openEditorsView", _a41.NAME = localize({ key: "openEditors", comment: ["Open is an adjective"] }, "Open Editors"), _a41);
OpenEditorsView = OpenEditorsView_1 = __decorate([
  __param(1, IInstantiationService),
  __param(2, IViewDescriptorService),
  __param(3, IContextMenuService),
  __param(4, IEditorGroupsService),
  __param(5, IConfigurationService),
  __param(6, IKeybindingService),
  __param(7, IContextKeyService),
  __param(8, IThemeService),
  __param(9, ITelemetryService),
  __param(10, IWorkingCopyService),
  __param(11, IFilesConfigurationService),
  __param(12, IOpenerService)
], OpenEditorsView);
var OpenEditorActionRunner = class extends ActionRunner {
  async run(action) {
    if (!this.editor) {
      return;
    }
    return super.run(action, { groupId: this.editor.groupId, editorIndex: this.editor.group.getIndexOfEditor(this.editor.editor) });
  }
};
var _OpenEditorsDelegate = class _OpenEditorsDelegate {
  getHeight(_element) {
    return _OpenEditorsDelegate.ITEM_HEIGHT;
  }
  getTemplateId(element) {
    if (element instanceof OpenEditor) {
      return OpenEditorRenderer.ID;
    }
    return EditorGroupRenderer.ID;
  }
};
_OpenEditorsDelegate.ITEM_HEIGHT = 22;
var OpenEditorsDelegate = _OpenEditorsDelegate;
var _EditorGroupRenderer = class _EditorGroupRenderer {
  constructor(keybindingService, instantiationService) {
    this.keybindingService = keybindingService;
    this.instantiationService = instantiationService;
  }
  get templateId() {
    return _EditorGroupRenderer.ID;
  }
  renderTemplate(container) {
    const editorGroupTemplate = /* @__PURE__ */ Object.create(null);
    editorGroupTemplate.root = append(container, $2(".editor-group"));
    editorGroupTemplate.name = append(editorGroupTemplate.root, $2("span.name"));
    editorGroupTemplate.actionBar = new ActionBar(container);
    const saveAllInGroupAction = this.instantiationService.createInstance(SaveAllInGroupAction, SaveAllInGroupAction.ID, SaveAllInGroupAction.LABEL);
    const saveAllInGroupKey = this.keybindingService.lookupKeybinding(saveAllInGroupAction.id);
    editorGroupTemplate.actionBar.push(saveAllInGroupAction, { icon: true, label: false, keybinding: saveAllInGroupKey ? saveAllInGroupKey.getLabel() : void 0 });
    const closeGroupAction = this.instantiationService.createInstance(CloseGroupAction, CloseGroupAction.ID, CloseGroupAction.LABEL);
    const closeGroupActionKey = this.keybindingService.lookupKeybinding(closeGroupAction.id);
    editorGroupTemplate.actionBar.push(closeGroupAction, { icon: true, label: false, keybinding: closeGroupActionKey ? closeGroupActionKey.getLabel() : void 0 });
    return editorGroupTemplate;
  }
  renderElement(editorGroup, _index, templateData) {
    templateData.editorGroup = editorGroup;
    templateData.name.textContent = editorGroup.label;
    templateData.actionBar.context = { groupId: editorGroup.id };
  }
  disposeTemplate(templateData) {
    templateData.actionBar.dispose();
  }
};
_EditorGroupRenderer.ID = "editorgroup";
var EditorGroupRenderer = _EditorGroupRenderer;
var _OpenEditorRenderer = class _OpenEditorRenderer {
  constructor(labels, instantiationService, keybindingService, configurationService) {
    this.labels = labels;
    this.instantiationService = instantiationService;
    this.keybindingService = keybindingService;
    this.configurationService = configurationService;
    this.closeEditorAction = this.instantiationService.createInstance(CloseEditorAction, CloseEditorAction.ID, CloseEditorAction.LABEL);
    this.unpinEditorAction = this.instantiationService.createInstance(UnpinEditorAction, UnpinEditorAction.ID, UnpinEditorAction.LABEL);
  }
  get templateId() {
    return _OpenEditorRenderer.ID;
  }
  renderTemplate(container) {
    const editorTemplate = /* @__PURE__ */ Object.create(null);
    editorTemplate.container = container;
    editorTemplate.actionRunner = new OpenEditorActionRunner();
    editorTemplate.actionBar = new ActionBar(container, { actionRunner: editorTemplate.actionRunner });
    editorTemplate.root = this.labels.create(container);
    return editorTemplate;
  }
  renderElement(openedEditor, _index, templateData) {
    var _a43;
    const editor = openedEditor.editor;
    templateData.actionRunner.editor = openedEditor;
    templateData.container.classList.toggle("dirty", editor.isDirty() && !editor.isSaving());
    templateData.container.classList.toggle("sticky", openedEditor.isSticky());
    templateData.root.setResource({
      resource: EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.BOTH }),
      name: editor.getName(),
      description: editor.getDescription(1)
    }, {
      italic: openedEditor.isPreview(),
      extraClasses: ["open-editor"].concat(openedEditor.editor.getLabelExtraClasses()),
      fileDecorations: this.configurationService.getValue().explorer.decorations,
      title: editor.getTitle(2)
    });
    const editorAction = openedEditor.isSticky() ? this.unpinEditorAction : this.closeEditorAction;
    if (!templateData.actionBar.hasAction(editorAction)) {
      if (!templateData.actionBar.isEmpty()) {
        templateData.actionBar.clear();
      }
      templateData.actionBar.push(editorAction, { icon: true, label: false, keybinding: (_a43 = this.keybindingService.lookupKeybinding(editorAction.id)) == null ? void 0 : _a43.getLabel() });
    }
  }
  disposeTemplate(templateData) {
    templateData.actionBar.dispose();
    templateData.root.dispose();
    templateData.actionRunner.dispose();
  }
};
_OpenEditorRenderer.ID = "openeditor";
var OpenEditorRenderer = _OpenEditorRenderer;
var OpenEditorsDragAndDrop = class {
  constructor(instantiationService, editorGroupService) {
    this.instantiationService = instantiationService;
    this.editorGroupService = editorGroupService;
  }
  get dropHandler() {
    return this.instantiationService.createInstance(ResourcesDropHandler, { allowWorkspaceOpen: false });
  }
  getDragURI(element) {
    if (element instanceof OpenEditor) {
      const resource = element.getResource();
      if (resource) {
        return resource.toString();
      }
    }
    return null;
  }
  getDragLabel(elements) {
    if (elements.length > 1) {
      return String(elements.length);
    }
    const element = elements[0];
    return element instanceof OpenEditor ? element.editor.getName() : element.label;
  }
  onDragStart(data, originalEvent) {
    const items = data.elements;
    const editors = [];
    if (items) {
      for (const item of items) {
        if (item instanceof OpenEditor) {
          editors.push(item);
        }
      }
    }
    if (editors.length) {
      this.instantiationService.invokeFunction(fillEditorsDragData, editors, originalEvent);
    }
  }
  onDragOver(data, _targetElement, _targetIndex, originalEvent) {
    if (data instanceof NativeDragAndDropData) {
      return containsDragType(originalEvent, DataTransfers.FILES, CodeDataTransfers.FILES);
    }
    return true;
  }
  drop(data, targetElement, _targetIndex, originalEvent) {
    const group = targetElement instanceof OpenEditor ? targetElement.group : targetElement || this.editorGroupService.groups[this.editorGroupService.count - 1];
    const index = targetElement instanceof OpenEditor ? targetElement.group.getIndexOfEditor(targetElement.editor) : 0;
    if (data instanceof ElementsDragAndDropData) {
      const elementsData = data.elements;
      elementsData.forEach((oe, offset) => {
        oe.group.moveEditor(oe.editor, group, { index: index + offset, preserveFocus: true });
      });
      this.editorGroupService.activateGroup(group);
    } else {
      this.dropHandler.handleDrop(originalEvent, () => group, () => group.focus(), index);
    }
  }
};
OpenEditorsDragAndDrop.__decorator = __decorate([
  memoize
], OpenEditorsDragAndDrop.prototype, "dropHandler", null);
var OpenEditorsAccessibilityProvider = class {
  getWidgetAriaLabel() {
    return localize("openEditors", "Open Editors");
  }
  getAriaLabel(element) {
    if (element instanceof OpenEditor) {
      return `${element.editor.getName()}, ${element.editor.getDescription()}`;
    }
    return element.ariaLabel;
  }
};
var toggleEditorGroupLayoutId = "workbench.action.toggleEditorGroupLayout";
MenuRegistry.appendMenuItem(MenuId.MenubarLayoutMenu, {
  group: "4_flip",
  command: {
    id: toggleEditorGroupLayoutId,
    title: {
      original: "Flip Layout",
      value: localize("miToggleEditorLayoutWithoutMnemonic", "Flip Layout"),
      mnemonicTitle: localize(
        { key: "miToggleEditorLayout", comment: ["&& denotes a mnemonic"] },
        "Flip &&Layout"
      )
    }
  },
  order: 1
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/explorerViewlet.js
init_instantiation();
init_telemetry();
init_contextkey();
init_themeService();
init_lifecycle();

// node_modules/vscode/vscode/src/vs/workbench/browser/parts/views/viewPaneContainer.js
init_tslib_es6();
init_dom();
init_mouseEvent();
init_async();
init_event();
init_keyCodes();
init_lifecycle();
init_types();
init_nls();
init_actions2();
init_configuration();
init_contextkey();
init_instantiation();
init_telemetry();
init_colorRegistry();
init_themeService();
var ViewsSubMenu = new MenuId("Views");
MenuRegistry.appendMenuItem(MenuId.ViewContainerTitle, {
  submenu: ViewsSubMenu,
  title: localize("views", "Views"),
  order: 1,
  when: ContextKeyExpr.equals(
    "viewContainerLocation",
    ViewContainerLocationToString(0)
  )
});
var _ViewPaneDropOverlay = class _ViewPaneDropOverlay extends Themable {
  get currentDropOperation() {
    return this._currentDropOperation;
  }
  constructor(paneElement, orientation, bounds, location, themeService) {
    super(themeService);
    this.paneElement = paneElement;
    this.orientation = orientation;
    this.bounds = bounds;
    this.location = location;
    this.cleanupOverlayScheduler = this._register(new RunOnceScheduler(() => this.dispose(), 300));
    this.create();
  }
  get disposed() {
    return !!this._disposed;
  }
  create() {
    this.container = document.createElement("div");
    this.container.id = _ViewPaneDropOverlay.OVERLAY_ID;
    this.container.style.top = "0px";
    this.paneElement.appendChild(this.container);
    this.paneElement.classList.add("dragged-over");
    this._register(toDisposable(() => {
      this.paneElement.removeChild(this.container);
      this.paneElement.classList.remove("dragged-over");
    }));
    this.overlay = document.createElement("div");
    this.overlay.classList.add("pane-overlay-indicator");
    this.container.appendChild(this.overlay);
    this.registerListeners();
    this.updateStyles();
  }
  updateStyles() {
    this.overlay.style.backgroundColor = this.getColor(this.location === 1 ? PANEL_SECTION_DRAG_AND_DROP_BACKGROUND : SIDE_BAR_DRAG_AND_DROP_BACKGROUND) || "";
    const activeContrastBorderColor = this.getColor(activeContrastBorder);
    this.overlay.style.outlineColor = activeContrastBorderColor || "";
    this.overlay.style.outlineOffset = activeContrastBorderColor ? "-2px" : "";
    this.overlay.style.outlineStyle = activeContrastBorderColor ? "dashed" : "";
    this.overlay.style.outlineWidth = activeContrastBorderColor ? "2px" : "";
    this.overlay.style.borderColor = activeContrastBorderColor || "";
    this.overlay.style.borderStyle = "solid";
    this.overlay.style.borderWidth = "0px";
  }
  registerListeners() {
    this._register(new DragAndDropObserver(this.container, {
      onDragEnter: (e) => void 0,
      onDragOver: (e) => {
        this.positionOverlay(e.offsetX, e.offsetY);
        if (this.cleanupOverlayScheduler.isScheduled()) {
          this.cleanupOverlayScheduler.cancel();
        }
      },
      onDragLeave: (e) => this.dispose(),
      onDragEnd: (e) => this.dispose(),
      onDrop: (e) => {
        this.dispose();
      }
    }));
    this._register(addDisposableListener(this.container, EventType.MOUSE_OVER, () => {
      if (!this.cleanupOverlayScheduler.isScheduled()) {
        this.cleanupOverlayScheduler.schedule();
      }
    }));
  }
  positionOverlay(mousePosX, mousePosY) {
    const paneWidth = this.paneElement.clientWidth;
    const paneHeight = this.paneElement.clientHeight;
    const splitWidthThreshold = paneWidth / 2;
    const splitHeightThreshold = paneHeight / 2;
    let dropDirection;
    if (this.orientation === 0) {
      if (mousePosY < splitHeightThreshold) {
        dropDirection = 0;
      } else if (mousePosY >= splitHeightThreshold) {
        dropDirection = 1;
      }
    } else if (this.orientation === 1) {
      if (mousePosX < splitWidthThreshold) {
        dropDirection = 2;
      } else if (mousePosX >= splitWidthThreshold) {
        dropDirection = 3;
      }
    }
    switch (dropDirection) {
      case 0:
        this.doPositionOverlay({ top: "0", left: "0", width: "100%", height: "50%" });
        break;
      case 1:
        this.doPositionOverlay({ bottom: "0", left: "0", width: "100%", height: "50%" });
        break;
      case 2:
        this.doPositionOverlay({ top: "0", left: "0", width: "50%", height: "100%" });
        break;
      case 3:
        this.doPositionOverlay({ top: "0", right: "0", width: "50%", height: "100%" });
        break;
      default: {
        let top = "0";
        let left = "0";
        let width = "100%";
        let height = "100%";
        if (this.bounds) {
          const boundingRect = this.container.getBoundingClientRect();
          top = `${this.bounds.top - boundingRect.top}px`;
          left = `${this.bounds.left - boundingRect.left}px`;
          height = `${this.bounds.bottom - this.bounds.top}px`;
          width = `${this.bounds.right - this.bounds.left}px`;
        }
        this.doPositionOverlay({ top, left, width, height });
      }
    }
    if (this.orientation === 0 && paneHeight <= 25 || this.orientation === 1 && paneWidth <= 25) {
      this.doUpdateOverlayBorder(dropDirection);
    } else {
      this.doUpdateOverlayBorder(void 0);
    }
    this.overlay.style.opacity = "1";
    setTimeout(() => this.overlay.classList.add("overlay-move-transition"), 0);
    this._currentDropOperation = dropDirection;
  }
  doUpdateOverlayBorder(direction) {
    this.overlay.style.borderTopWidth = direction === 0 ? "2px" : "0px";
    this.overlay.style.borderLeftWidth = direction === 2 ? "2px" : "0px";
    this.overlay.style.borderBottomWidth = direction === 1 ? "2px" : "0px";
    this.overlay.style.borderRightWidth = direction === 3 ? "2px" : "0px";
  }
  doPositionOverlay(options) {
    this.container.style.height = "100%";
    this.overlay.style.top = options.top || "";
    this.overlay.style.left = options.left || "";
    this.overlay.style.bottom = options.bottom || "";
    this.overlay.style.right = options.right || "";
    this.overlay.style.width = options.width;
    this.overlay.style.height = options.height;
  }
  contains(element) {
    return element === this.container || element === this.overlay;
  }
  dispose() {
    super.dispose();
    this._disposed = true;
  }
};
_ViewPaneDropOverlay.OVERLAY_ID = "monaco-pane-drop-overlay";
var ViewPaneDropOverlay = _ViewPaneDropOverlay;
var ViewContainerMenuActions = class ViewContainerMenuActions2 extends CompositeMenuActions {
  constructor(element, viewContainer, viewDescriptorService, contextKeyService, menuService) {
    const scopedContextKeyService = contextKeyService.createScoped(element);
    scopedContextKeyService.createKey("viewContainer", viewContainer.id);
    const viewContainerLocationKey = scopedContextKeyService.createKey("viewContainerLocation", ViewContainerLocationToString(viewDescriptorService.getViewContainerLocation(viewContainer)));
    super(MenuId.ViewContainerTitle, MenuId.ViewContainerTitleContext, { shouldForwardArgs: true }, scopedContextKeyService, menuService);
    this._register(scopedContextKeyService);
    this._register(Event.filter(viewDescriptorService.onDidChangeContainerLocation, (e) => e.viewContainer === viewContainer)(() => viewContainerLocationKey.set(ViewContainerLocationToString(viewDescriptorService.getViewContainerLocation(viewContainer)))));
  }
};
ViewContainerMenuActions = __decorate([
  __param(2, IViewDescriptorService),
  __param(3, IContextKeyService),
  __param(4, IMenuService)
], ViewContainerMenuActions);
var ViewPaneContainer = class ViewPaneContainer2 extends Component {
  get onDidSashChange() {
    return assertIsDefined(this.paneview).onDidSashChange;
  }
  get panes() {
    return this.paneItems.map((i) => i.pane);
  }
  get views() {
    return this.panes;
  }
  get length() {
    return this.paneItems.length;
  }
  get menuActions() {
    return this._menuActions;
  }
  constructor(id, options, instantiationService, configurationService, layoutService, contextMenuService, telemetryService, extensionService, themeService, storageService, contextService, viewDescriptorService) {
    super(id, themeService, storageService);
    this.options = options;
    this.instantiationService = instantiationService;
    this.configurationService = configurationService;
    this.layoutService = layoutService;
    this.contextMenuService = contextMenuService;
    this.telemetryService = telemetryService;
    this.extensionService = extensionService;
    this.storageService = storageService;
    this.contextService = contextService;
    this.viewDescriptorService = viewDescriptorService;
    this.paneItems = [];
    this.visible = false;
    this.areExtensionsReady = false;
    this.didLayout = false;
    this.viewDisposables = [];
    this._onTitleAreaUpdate = this._register(new Emitter());
    this.onTitleAreaUpdate = this._onTitleAreaUpdate.event;
    this._onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    this._onDidAddViews = this._register(new Emitter());
    this.onDidAddViews = this._onDidAddViews.event;
    this._onDidRemoveViews = this._register(new Emitter());
    this.onDidRemoveViews = this._onDidRemoveViews.event;
    this._onDidChangeViewVisibility = this._register(new Emitter());
    this.onDidChangeViewVisibility = this._onDidChangeViewVisibility.event;
    this._onDidFocusView = this._register(new Emitter());
    this.onDidFocusView = this._onDidFocusView.event;
    this._onDidBlurView = this._register(new Emitter());
    this.onDidBlurView = this._onDidBlurView.event;
    const container = this.viewDescriptorService.getViewContainerById(id);
    if (!container) {
      throw new Error("Could not find container");
    }
    this.viewContainer = container;
    this.visibleViewsStorageId = `${id}.numberOfVisibleViews`;
    this.visibleViewsCountFromCache = this.storageService.getNumber(this.visibleViewsStorageId, 1, void 0);
    this._register(toDisposable(() => this.viewDisposables = dispose(this.viewDisposables)));
    this.viewContainerModel = this.viewDescriptorService.getViewContainerModel(container);
  }
  create(parent) {
    const options = this.options;
    options.orientation = this.orientation;
    this.paneview = this._register(new PaneView(parent, this.options));
    if (this._boundarySashes) {
      this.paneview.setBoundarySashes(this._boundarySashes);
    }
    this._register(this.paneview.onDidDrop(({ from, to }) => this.movePane(from, to)));
    this._register(this.paneview.onDidScroll((_) => this.onDidScrollPane()));
    this._register(this.paneview.onDidSashReset((index) => this.onDidSashReset(index)));
    this._register(addDisposableListener(parent, EventType.CONTEXT_MENU, (e) => this.showContextMenu(new StandardMouseEvent(e))));
    this._register(Gesture.addTarget(parent));
    this._register(addDisposableListener(parent, EventType2.Contextmenu, (e) => this.showContextMenu(new StandardMouseEvent(e))));
    this._menuActions = this._register(this.instantiationService.createInstance(ViewContainerMenuActions, this.paneview.element, this.viewContainer));
    this._register(this._menuActions.onDidChange(() => this.updateTitleArea()));
    let overlay;
    const getOverlayBounds = () => {
      const fullSize = parent.getBoundingClientRect();
      const lastPane = this.panes[this.panes.length - 1].element.getBoundingClientRect();
      const top = this.orientation === 0 ? lastPane.bottom : fullSize.top;
      const left = this.orientation === 1 ? lastPane.right : fullSize.left;
      return {
        top,
        bottom: fullSize.bottom,
        left,
        right: fullSize.right
      };
    };
    const inBounds = (bounds2, pos) => {
      return pos.x >= bounds2.left && pos.x <= bounds2.right && pos.y >= bounds2.top && pos.y <= bounds2.bottom;
    };
    let bounds;
    this._register(CompositeDragAndDropObserver.INSTANCE.registerTarget(parent, {
      onDragEnter: (e) => {
        bounds = getOverlayBounds();
        if (overlay && overlay.disposed) {
          overlay = void 0;
        }
        if (!overlay && inBounds(bounds, e.eventData)) {
          const dropData = e.dragAndDropData.getData();
          if (dropData.type === "view") {
            const oldViewContainer = this.viewDescriptorService.getViewContainerByViewId(dropData.id);
            const viewDescriptor = this.viewDescriptorService.getViewDescriptorById(dropData.id);
            if (oldViewContainer !== this.viewContainer && (!viewDescriptor || !viewDescriptor.canMoveView || this.viewContainer.rejectAddedViews)) {
              return;
            }
            overlay = new ViewPaneDropOverlay(
              parent,
              void 0,
              bounds,
              this.viewDescriptorService.getViewContainerLocation(this.viewContainer),
              this.themeService
            );
          }
          if (dropData.type === "composite" && dropData.id !== this.viewContainer.id) {
            const container = this.viewDescriptorService.getViewContainerById(dropData.id);
            const viewsToMove = this.viewDescriptorService.getViewContainerModel(container).allViewDescriptors;
            if (!viewsToMove.some((v) => !v.canMoveView) && viewsToMove.length > 0) {
              overlay = new ViewPaneDropOverlay(
                parent,
                void 0,
                bounds,
                this.viewDescriptorService.getViewContainerLocation(this.viewContainer),
                this.themeService
              );
            }
          }
        }
      },
      onDragOver: (e) => {
        if (overlay && overlay.disposed) {
          overlay = void 0;
        }
        if (overlay && !inBounds(bounds, e.eventData)) {
          overlay.dispose();
          overlay = void 0;
        }
        if (inBounds(bounds, e.eventData)) {
          toggleDropEffect(e.eventData.dataTransfer, "move", overlay !== void 0);
        }
      },
      onDragLeave: (e) => {
        overlay == null ? void 0 : overlay.dispose();
        overlay = void 0;
      },
      onDrop: (e) => {
        if (overlay) {
          const dropData = e.dragAndDropData.getData();
          const viewsToMove = [];
          if (dropData.type === "composite" && dropData.id !== this.viewContainer.id) {
            const container = this.viewDescriptorService.getViewContainerById(dropData.id);
            const allViews = this.viewDescriptorService.getViewContainerModel(container).allViewDescriptors;
            if (!allViews.some((v) => !v.canMoveView)) {
              viewsToMove.push(...allViews);
            }
          } else if (dropData.type === "view") {
            const oldViewContainer = this.viewDescriptorService.getViewContainerByViewId(dropData.id);
            const viewDescriptor = this.viewDescriptorService.getViewDescriptorById(dropData.id);
            if (oldViewContainer !== this.viewContainer && viewDescriptor && viewDescriptor.canMoveView) {
              this.viewDescriptorService.moveViewsToContainer([viewDescriptor], this.viewContainer);
            }
          }
          const paneCount = this.panes.length;
          if (viewsToMove.length > 0) {
            this.viewDescriptorService.moveViewsToContainer(viewsToMove, this.viewContainer);
          }
          if (paneCount > 0) {
            for (const view of viewsToMove) {
              const paneToMove = this.panes.find((p) => p.id === view.id);
              if (paneToMove) {
                this.movePane(paneToMove, this.panes[this.panes.length - 1]);
              }
            }
          }
        }
        overlay == null ? void 0 : overlay.dispose();
        overlay = void 0;
      }
    }));
    this._register(this.onDidSashChange(() => this.saveViewSizes()));
    this._register(this.viewContainerModel.onDidAddVisibleViewDescriptors((added) => this.onDidAddViewDescriptors(added)));
    this._register(this.viewContainerModel.onDidRemoveVisibleViewDescriptors((removed) => this.onDidRemoveViewDescriptors(removed)));
    const addedViews = this.viewContainerModel.visibleViewDescriptors.map((viewDescriptor, index) => {
      const size = this.viewContainerModel.getSize(viewDescriptor.id);
      const collapsed = this.viewContainerModel.isCollapsed(viewDescriptor.id);
      return { viewDescriptor, index, size, collapsed };
    });
    if (addedViews.length) {
      this.onDidAddViewDescriptors(addedViews);
    }
    this.extensionService.whenInstalledExtensionsRegistered().then(() => {
      this.areExtensionsReady = true;
      if (this.panes.length) {
        this.updateTitleArea();
        this.updateViewHeaders();
      }
    });
    this._register(this.viewContainerModel.onDidChangeActiveViewDescriptors(() => this._onTitleAreaUpdate.fire()));
  }
  getTitle() {
    const containerTitle = this.viewContainerModel.title;
    if (this.isViewMergedWithContainer()) {
      const paneItemTitle = this.paneItems[0].pane.title;
      if (containerTitle === paneItemTitle) {
        return this.paneItems[0].pane.title;
      }
      return paneItemTitle ? `${containerTitle}: ${paneItemTitle}` : containerTitle;
    }
    return containerTitle;
  }
  showContextMenu(event) {
    for (const paneItem of this.paneItems) {
      if (isAncestor(event.target, paneItem.pane.element)) {
        return;
      }
    }
    event.stopPropagation();
    event.preventDefault();
    this.contextMenuService.showContextMenu({
      getAnchor: () => event,
      getActions: () => {
        var _a43;
        return ((_a43 = this.menuActions) == null ? void 0 : _a43.getContextMenuActions()) ?? [];
      }
    });
  }
  getActionsContext() {
    return void 0;
  }
  getActionViewItem(action) {
    if (this.isViewMergedWithContainer()) {
      return this.paneItems[0].pane.getActionViewItem(action);
    }
    return createActionViewItem(this.instantiationService, action);
  }
  focus() {
    if (this.lastFocusedPane) {
      this.lastFocusedPane.focus();
    } else if (this.paneItems.length > 0) {
      for (const { pane } of this.paneItems) {
        if (pane.isExpanded()) {
          pane.focus();
          return;
        }
      }
    }
  }
  get orientation() {
    switch (this.viewDescriptorService.getViewContainerLocation(this.viewContainer)) {
      case 0:
      case 2:
        return 0;
      case 1:
        return this.layoutService.getPanelPosition() === 2 ? 1 : 0;
    }
    return 0;
  }
  layout(dimension) {
    if (this.paneview) {
      if (this.paneview.orientation !== this.orientation) {
        this.paneview.flipOrientation(dimension.height, dimension.width);
      }
      this.paneview.layout(dimension.height, dimension.width);
    }
    this.dimension = dimension;
    if (this.didLayout) {
      this.saveViewSizes();
    } else {
      this.didLayout = true;
      this.restoreViewSizes();
    }
  }
  setBoundarySashes(sashes) {
    var _a43;
    this._boundarySashes = sashes;
    (_a43 = this.paneview) == null ? void 0 : _a43.setBoundarySashes(sashes);
  }
  getOptimalWidth() {
    const additionalMargin = 16;
    const optimalWidth = Math.max(...this.panes.map((view) => view.getOptimalWidth() || 0));
    return optimalWidth + additionalMargin;
  }
  addPanes(panes) {
    const wasMerged = this.isViewMergedWithContainer();
    for (const { pane, size, index } of panes) {
      this.addPane(pane, size, index);
    }
    this.updateViewHeaders();
    if (this.isViewMergedWithContainer() !== wasMerged) {
      this.updateTitleArea();
    }
    this._onDidAddViews.fire(panes.map(({ pane }) => pane));
  }
  setVisible(visible) {
    if (this.visible !== !!visible) {
      this.visible = visible;
      this._onDidChangeVisibility.fire(visible);
    }
    this.panes.filter((view) => view.isVisible() !== visible).forEach((view) => view.setVisible(visible));
  }
  isVisible() {
    return this.visible;
  }
  updateTitleArea() {
    this._onTitleAreaUpdate.fire();
  }
  createView(viewDescriptor, options) {
    return this.instantiationService.createInstance(viewDescriptor.ctorDescriptor.ctor, ...viewDescriptor.ctorDescriptor.staticArguments || [], options);
  }
  getView(id) {
    return this.panes.filter((view) => view.id === id)[0];
  }
  saveViewSizes() {
    if (this.didLayout) {
      this.viewContainerModel.setSizes(this.panes.map((view) => ({ id: view.id, size: this.getPaneSize(view) })));
    }
  }
  restoreViewSizes() {
    if (this.didLayout) {
      let initialSizes;
      for (let i = 0; i < this.viewContainerModel.visibleViewDescriptors.length; i++) {
        const pane = this.panes[i];
        const viewDescriptor = this.viewContainerModel.visibleViewDescriptors[i];
        const size = this.viewContainerModel.getSize(viewDescriptor.id);
        if (typeof size === "number") {
          this.resizePane(pane, size);
        } else {
          initialSizes = initialSizes ? initialSizes : this.computeInitialSizes();
          this.resizePane(pane, initialSizes.get(pane.id) || 200);
        }
      }
    }
  }
  computeInitialSizes() {
    const sizes = /* @__PURE__ */ new Map();
    if (this.dimension) {
      const totalWeight = this.viewContainerModel.visibleViewDescriptors.reduce((totalWeight2, { weight }) => totalWeight2 + (weight || 20), 0);
      for (const viewDescriptor of this.viewContainerModel.visibleViewDescriptors) {
        if (this.orientation === 0) {
          sizes.set(viewDescriptor.id, this.dimension.height * (viewDescriptor.weight || 20) / totalWeight);
        } else {
          sizes.set(viewDescriptor.id, this.dimension.width * (viewDescriptor.weight || 20) / totalWeight);
        }
      }
    }
    return sizes;
  }
  saveState() {
    this.panes.forEach((view) => view.saveState());
    this.storageService.store(this.visibleViewsStorageId, this.length, 1, 1);
  }
  onContextMenu(event, viewPane) {
    event.stopPropagation();
    event.preventDefault();
    const actions = viewPane.menuActions.getContextMenuActions();
    this.contextMenuService.showContextMenu({
      getAnchor: () => event,
      getActions: () => actions
    });
  }
  openView(id, focus) {
    let view = this.getView(id);
    if (!view) {
      this.toggleViewVisibility(id);
    }
    view = this.getView(id);
    if (view) {
      view.setExpanded(true);
      if (focus) {
        view.focus();
      }
    }
    return view;
  }
  onDidAddViewDescriptors(added) {
    const panesToAdd = [];
    for (const { viewDescriptor, collapsed, index, size } of added) {
      const pane = this.createView(viewDescriptor, {
        id: viewDescriptor.id,
        title: viewDescriptor.name,
        fromExtensionId: viewDescriptor.extensionId,
        expanded: !collapsed
      });
      pane.render();
      const contextMenuDisposable = addDisposableListener(pane.draggableElement, "contextmenu", (e) => {
        e.stopPropagation();
        e.preventDefault();
        this.onContextMenu(new StandardMouseEvent(e), pane);
      });
      const collapseDisposable = Event.latch(Event.map(pane.onDidChange, () => !pane.isExpanded()))((collapsed2) => {
        this.viewContainerModel.setCollapsed(viewDescriptor.id, collapsed2);
      });
      this.viewDisposables.splice(index, 0, combinedDisposable(contextMenuDisposable, collapseDisposable));
      panesToAdd.push({ pane, size: size || pane.minimumSize, index });
    }
    this.addPanes(panesToAdd);
    this.restoreViewSizes();
    const panes = [];
    for (const { pane } of panesToAdd) {
      pane.setVisible(this.isVisible());
      panes.push(pane);
    }
    return panes;
  }
  onDidRemoveViewDescriptors(removed) {
    removed = removed.sort((a, b) => b.index - a.index);
    const panesToRemove = [];
    for (const { index } of removed) {
      const [disposable] = this.viewDisposables.splice(index, 1);
      disposable.dispose();
      panesToRemove.push(this.panes[index]);
    }
    this.removePanes(panesToRemove);
    for (const pane of panesToRemove) {
      pane.setVisible(false);
    }
  }
  toggleViewVisibility(viewId) {
    if (this.viewContainerModel.activeViewDescriptors.some((viewDescriptor) => viewDescriptor.id === viewId)) {
      const visible = !this.viewContainerModel.isVisible(viewId);
      this.viewContainerModel.setVisible(viewId, visible);
    }
  }
  addPane(pane, size, index = this.paneItems.length - 1) {
    const onDidFocus = pane.onDidFocus(() => {
      this._onDidFocusView.fire(pane);
      this.lastFocusedPane = pane;
    });
    const onDidBlur = pane.onDidBlur(() => this._onDidBlurView.fire(pane));
    const onDidChangeTitleArea = pane.onDidChangeTitleArea(() => {
      if (this.isViewMergedWithContainer()) {
        this.updateTitleArea();
      }
    });
    const onDidChangeVisibility = pane.onDidChangeBodyVisibility(() => this._onDidChangeViewVisibility.fire(pane));
    const onDidChange = pane.onDidChange(() => {
      if (pane === this.lastFocusedPane && !pane.isExpanded()) {
        this.lastFocusedPane = void 0;
      }
    });
    const isPanel = this.viewDescriptorService.getViewContainerLocation(this.viewContainer) === 1;
    pane.style({
      headerForeground: asCssVariable(isPanel ? PANEL_SECTION_HEADER_FOREGROUND : SIDE_BAR_SECTION_HEADER_FOREGROUND),
      headerBackground: asCssVariable(isPanel ? PANEL_SECTION_HEADER_BACKGROUND : SIDE_BAR_SECTION_HEADER_BACKGROUND),
      headerBorder: asCssVariable(isPanel ? PANEL_SECTION_HEADER_BORDER : SIDE_BAR_SECTION_HEADER_BORDER),
      dropBackground: asCssVariable(isPanel ? PANEL_SECTION_DRAG_AND_DROP_BACKGROUND : SIDE_BAR_DRAG_AND_DROP_BACKGROUND),
      leftBorder: isPanel ? asCssVariable(PANEL_SECTION_BORDER) : void 0
    });
    const disposable = combinedDisposable(pane, onDidFocus, onDidBlur, onDidChangeTitleArea, onDidChange, onDidChangeVisibility);
    const paneItem = { pane, disposable };
    this.paneItems.splice(index, 0, paneItem);
    assertIsDefined(this.paneview).addPane(pane, size, index);
    let overlay;
    this._register(CompositeDragAndDropObserver.INSTANCE.registerDraggable(pane.draggableElement, () => {
      return { type: "view", id: pane.id };
    }, {}));
    this._register(CompositeDragAndDropObserver.INSTANCE.registerTarget(pane.dropTargetElement, {
      onDragEnter: (e) => {
        if (!overlay) {
          const dropData = e.dragAndDropData.getData();
          if (dropData.type === "view" && dropData.id !== pane.id) {
            const oldViewContainer = this.viewDescriptorService.getViewContainerByViewId(dropData.id);
            const viewDescriptor = this.viewDescriptorService.getViewDescriptorById(dropData.id);
            if (oldViewContainer !== this.viewContainer && (!viewDescriptor || !viewDescriptor.canMoveView || this.viewContainer.rejectAddedViews)) {
              return;
            }
            overlay = new ViewPaneDropOverlay(
              pane.dropTargetElement,
              this.orientation ?? 0,
              void 0,
              this.viewDescriptorService.getViewContainerLocation(this.viewContainer),
              this.themeService
            );
          }
          if (dropData.type === "composite" && dropData.id !== this.viewContainer.id && !this.viewContainer.rejectAddedViews) {
            const container = this.viewDescriptorService.getViewContainerById(dropData.id);
            const viewsToMove = this.viewDescriptorService.getViewContainerModel(container).allViewDescriptors;
            if (!viewsToMove.some((v) => !v.canMoveView) && viewsToMove.length > 0) {
              overlay = new ViewPaneDropOverlay(
                pane.dropTargetElement,
                this.orientation ?? 0,
                void 0,
                this.viewDescriptorService.getViewContainerLocation(this.viewContainer),
                this.themeService
              );
            }
          }
        }
      },
      onDragOver: (e) => {
        toggleDropEffect(e.eventData.dataTransfer, "move", overlay !== void 0);
      },
      onDragLeave: (e) => {
        overlay == null ? void 0 : overlay.dispose();
        overlay = void 0;
      },
      onDrop: (e) => {
        if (overlay) {
          const dropData = e.dragAndDropData.getData();
          const viewsToMove = [];
          let anchorView;
          if (dropData.type === "composite" && dropData.id !== this.viewContainer.id && !this.viewContainer.rejectAddedViews) {
            const container = this.viewDescriptorService.getViewContainerById(dropData.id);
            const allViews = this.viewDescriptorService.getViewContainerModel(container).allViewDescriptors;
            if (allViews.length > 0 && !allViews.some((v) => !v.canMoveView)) {
              viewsToMove.push(...allViews);
              anchorView = allViews[0];
            }
          } else if (dropData.type === "view") {
            const oldViewContainer = this.viewDescriptorService.getViewContainerByViewId(dropData.id);
            const viewDescriptor = this.viewDescriptorService.getViewDescriptorById(dropData.id);
            if (oldViewContainer !== this.viewContainer && viewDescriptor && viewDescriptor.canMoveView && !this.viewContainer.rejectAddedViews) {
              viewsToMove.push(viewDescriptor);
            }
            if (viewDescriptor) {
              anchorView = viewDescriptor;
            }
          }
          if (viewsToMove) {
            this.viewDescriptorService.moveViewsToContainer(viewsToMove, this.viewContainer);
          }
          if (anchorView) {
            if (overlay.currentDropOperation === 1 || overlay.currentDropOperation === 3) {
              const fromIndex = this.panes.findIndex((p) => p.id === anchorView.id);
              let toIndex = this.panes.findIndex((p) => p.id === pane.id);
              if (fromIndex >= 0 && toIndex >= 0) {
                if (fromIndex > toIndex) {
                  toIndex++;
                }
                if (toIndex < this.panes.length && toIndex !== fromIndex) {
                  this.movePane(this.panes[fromIndex], this.panes[toIndex]);
                }
              }
            }
            if (overlay.currentDropOperation === 0 || overlay.currentDropOperation === 2) {
              const fromIndex = this.panes.findIndex((p) => p.id === anchorView.id);
              let toIndex = this.panes.findIndex((p) => p.id === pane.id);
              if (fromIndex >= 0 && toIndex >= 0) {
                if (fromIndex < toIndex) {
                  toIndex--;
                }
                if (toIndex >= 0 && toIndex !== fromIndex) {
                  this.movePane(this.panes[fromIndex], this.panes[toIndex]);
                }
              }
            }
            if (viewsToMove.length > 1) {
              viewsToMove.slice(1).forEach((view) => {
                let toIndex = this.panes.findIndex((p) => p.id === anchorView.id);
                const fromIndex = this.panes.findIndex((p) => p.id === view.id);
                if (fromIndex >= 0 && toIndex >= 0) {
                  if (fromIndex > toIndex) {
                    toIndex++;
                  }
                  if (toIndex < this.panes.length && toIndex !== fromIndex) {
                    this.movePane(this.panes[fromIndex], this.panes[toIndex]);
                    anchorView = view;
                  }
                }
              });
            }
          }
        }
        overlay == null ? void 0 : overlay.dispose();
        overlay = void 0;
      }
    }));
  }
  removePanes(panes) {
    const wasMerged = this.isViewMergedWithContainer();
    panes.forEach((pane) => this.removePane(pane));
    this.updateViewHeaders();
    if (wasMerged !== this.isViewMergedWithContainer()) {
      this.updateTitleArea();
    }
    this._onDidRemoveViews.fire(panes);
  }
  removePane(pane) {
    const index = this.paneItems.findIndex((i) => i.pane === pane);
    if (index === -1) {
      return;
    }
    if (this.lastFocusedPane === pane) {
      this.lastFocusedPane = void 0;
    }
    assertIsDefined(this.paneview).removePane(pane);
    const [paneItem] = this.paneItems.splice(index, 1);
    paneItem.disposable.dispose();
  }
  movePane(from, to) {
    const fromIndex = this.paneItems.findIndex((item) => item.pane === from);
    const toIndex = this.paneItems.findIndex((item) => item.pane === to);
    const fromViewDescriptor = this.viewContainerModel.visibleViewDescriptors[fromIndex];
    const toViewDescriptor = this.viewContainerModel.visibleViewDescriptors[toIndex];
    if (fromIndex < 0 || fromIndex >= this.paneItems.length) {
      return;
    }
    if (toIndex < 0 || toIndex >= this.paneItems.length) {
      return;
    }
    const [paneItem] = this.paneItems.splice(fromIndex, 1);
    this.paneItems.splice(toIndex, 0, paneItem);
    assertIsDefined(this.paneview).movePane(from, to);
    this.viewContainerModel.move(fromViewDescriptor.id, toViewDescriptor.id);
    this.updateTitleArea();
  }
  resizePane(pane, size) {
    assertIsDefined(this.paneview).resizePane(pane, size);
  }
  getPaneSize(pane) {
    return assertIsDefined(this.paneview).getPaneSize(pane);
  }
  updateViewHeaders() {
    if (this.isViewMergedWithContainer()) {
      if (this.paneItems[0].pane.isExpanded()) {
        this.lastMergedCollapsedPane = void 0;
      } else {
        this.lastMergedCollapsedPane = this.paneItems[0].pane;
        this.paneItems[0].pane.setExpanded(true);
      }
      this.paneItems[0].pane.headerVisible = false;
    } else {
      this.paneItems.forEach((i) => {
        i.pane.headerVisible = true;
        if (i.pane === this.lastMergedCollapsedPane) {
          i.pane.setExpanded(false);
        }
      });
      this.lastMergedCollapsedPane = void 0;
    }
  }
  isViewMergedWithContainer() {
    if (!(this.options.mergeViewWithContainerWhenSingleView && this.paneItems.length === 1)) {
      return false;
    }
    if (!this.areExtensionsReady) {
      if (this.visibleViewsCountFromCache === void 0) {
        return this.paneItems[0].pane.isExpanded();
      }
      return this.visibleViewsCountFromCache === 1;
    }
    return true;
  }
  onDidScrollPane() {
    for (const pane of this.panes) {
      pane.onDidScrollRoot();
    }
  }
  onDidSashReset(index) {
    var _a43, _b, _c, _d;
    let firstPane = void 0;
    let secondPane = void 0;
    for (let i = index; i >= 0; i--) {
      if (((_a43 = this.paneItems[i].pane) == null ? void 0 : _a43.isVisible()) && ((_b = this.paneItems[i]) == null ? void 0 : _b.pane.isExpanded())) {
        firstPane = this.paneItems[i].pane;
        break;
      }
    }
    for (let i = index + 1; i < this.paneItems.length; i++) {
      if (((_c = this.paneItems[i].pane) == null ? void 0 : _c.isVisible()) && ((_d = this.paneItems[i]) == null ? void 0 : _d.pane.isExpanded())) {
        secondPane = this.paneItems[i].pane;
        break;
      }
    }
    if (firstPane && secondPane) {
      const firstPaneSize = this.getPaneSize(firstPane);
      const secondPaneSize = this.getPaneSize(secondPane);
      const newFirstPaneSize = Math.ceil((firstPaneSize + secondPaneSize) / 2);
      const newSecondPaneSize = Math.floor((firstPaneSize + secondPaneSize) / 2);
      if (firstPaneSize > secondPaneSize) {
        this.resizePane(firstPane, newFirstPaneSize);
        this.resizePane(secondPane, newSecondPaneSize);
      } else {
        this.resizePane(secondPane, newSecondPaneSize);
        this.resizePane(firstPane, newFirstPaneSize);
      }
    }
  }
  dispose() {
    super.dispose();
    this.paneItems.forEach((i) => i.disposable.dispose());
    if (this.paneview) {
      this.paneview.dispose();
    }
  }
};
ViewPaneContainer = __decorate([
  __param(2, IInstantiationService),
  __param(3, IConfigurationService),
  __param(4, IWorkbenchLayoutService),
  __param(5, IContextMenuService),
  __param(6, ITelemetryService),
  __param(7, IExtensionService),
  __param(8, IThemeService),
  __param(9, IStorageService),
  __param(10, IWorkspaceContextService),
  __param(11, IViewDescriptorService)
], ViewPaneContainer);
var MoveViewPosition = class extends Action2 {
  constructor(desc, offset) {
    super(desc);
    this.offset = offset;
  }
  async run(accessor) {
    const viewDescriptorService = accessor.get(IViewDescriptorService);
    const contextKeyService = accessor.get(IContextKeyService);
    const viewId = FocusedViewContext.getValue(contextKeyService);
    if (viewId === void 0) {
      return;
    }
    const viewContainer = viewDescriptorService.getViewContainerByViewId(viewId);
    const model = viewDescriptorService.getViewContainerModel(viewContainer);
    const viewDescriptor = model.visibleViewDescriptors.find((vd) => vd.id === viewId);
    const currentIndex = model.visibleViewDescriptors.indexOf(viewDescriptor);
    if (currentIndex + this.offset < 0 || currentIndex + this.offset >= model.visibleViewDescriptors.length) {
      return;
    }
    const newPosition = model.visibleViewDescriptors[currentIndex + this.offset];
    model.move(viewDescriptor.id, newPosition.id);
  }
};
registerAction2(class MoveViewUp extends MoveViewPosition {
  constructor() {
    super({
      id: "views.moveViewUp",
      title: localize("viewMoveUp", "Move View Up"),
      keybinding: {
        primary: KeyChord(2048 + 41, 16),
        weight: 200 + 1,
        when: FocusedViewContext.notEqualsTo("")
      }
    }, -1);
  }
});
registerAction2(class MoveViewLeft extends MoveViewPosition {
  constructor() {
    super({
      id: "views.moveViewLeft",
      title: localize("viewMoveLeft", "Move View Left"),
      keybinding: {
        primary: KeyChord(2048 + 41, 15),
        weight: 200 + 1,
        when: FocusedViewContext.notEqualsTo("")
      }
    }, -1);
  }
});
registerAction2(class MoveViewDown extends MoveViewPosition {
  constructor() {
    super({
      id: "views.moveViewDown",
      title: localize("viewMoveDown", "Move View Down"),
      keybinding: {
        primary: KeyChord(2048 + 41, 18),
        weight: 200 + 1,
        when: FocusedViewContext.notEqualsTo("")
      }
    }, 1);
  }
});
registerAction2(class MoveViewRight extends MoveViewPosition {
  constructor() {
    super({
      id: "views.moveViewRight",
      title: localize("viewMoveRight", "Move View Right"),
      keybinding: {
        primary: KeyChord(2048 + 41, 17),
        weight: 200 + 1,
        when: FocusedViewContext.notEqualsTo("")
      }
    }, 1);
  }
});
registerAction2(class MoveViews extends Action2 {
  constructor() {
    super({
      id: "vscode.moveViews",
      title: localize("viewsMove", "Move Views")
    });
  }
  async run(accessor, options) {
    if (!Array.isArray(options == null ? void 0 : options.viewIds) || typeof (options == null ? void 0 : options.destinationId) !== "string") {
      return Promise.reject("Invalid arguments");
    }
    const viewDescriptorService = accessor.get(IViewDescriptorService);
    const destination = viewDescriptorService.getViewContainerById(options.destinationId);
    if (!destination) {
      return;
    }
    for (const viewId of options.viewIds) {
      const viewDescriptor = viewDescriptorService.getViewDescriptorById(viewId);
      if (viewDescriptor == null ? void 0 : viewDescriptor.canMoveView) {
        viewDescriptorService.moveViewsToContainer([viewDescriptor], destination, ViewVisibilityState.Default);
      }
    }
    await accessor.get(IViewsService).openViewContainer(destination.id, true);
  }
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/explorerViewlet.js
init_keyCodes();
init_platform2();
init_progress();
init_descriptors();

// node_modules/vscode/vscode/src/vs/workbench/browser/actions/workspaceActions.js
init_nls();
init_commands();

// node_modules/vscode/vscode/src/vs/workbench/browser/actions/workspaceCommands.js
init_nls();
var ADD_ROOT_FOLDER_COMMAND_ID = "addRootFolder";
var ADD_ROOT_FOLDER_LABEL = { value: localize("addFolderToWorkspace", "Add Folder to Workspace..."), original: "Add Folder to Workspace..." };
var SET_ROOT_FOLDER_COMMAND_ID = "setRootFolder";
var PICK_WORKSPACE_FOLDER_COMMAND_ID = "_workbench.pickWorkspaceFolder";

// node_modules/vscode/vscode/src/vs/workbench/browser/actions/workspaceActions.js
init_actions2();
init_keyCodes();
init_contextkey();
var workspacesCategory = { value: localize("workspaces", "Workspaces"), original: "Workspaces" };
var _OpenFileAction = class _OpenFileAction extends Action2 {
  constructor() {
    super({
      id: _OpenFileAction.ID,
      title: { value: localize("openFile", "Open File..."), original: "Open File..." },
      category: Categories.File,
      f1: true,
      precondition: IsMacNativeContext.toNegated(),
      keybinding: {
        weight: 200,
        primary: 2048 | 45
      }
    });
  }
  async run(accessor, data) {
    const fileDialogService = accessor.get(IFileDialogService);
    return fileDialogService.pickFileAndOpen({ forceNewWindow: false, telemetryExtraData: data });
  }
};
_OpenFileAction.ID = "workbench.action.files.openFile";
var OpenFileAction = _OpenFileAction;
var _OpenFolderAction = class _OpenFolderAction extends Action2 {
  constructor() {
    super({
      id: _OpenFolderAction.ID,
      title: { value: localize("openFolder", "Open Folder..."), original: "Open Folder..." },
      category: Categories.File,
      f1: true,
      precondition: OpenFolderWorkspaceSupportContext,
      keybinding: {
        weight: 200,
        primary: void 0,
        linux: {
          primary: KeyChord(2048 | 41, 2048 | 45)
        },
        win: {
          primary: KeyChord(2048 | 41, 2048 | 45)
        }
      }
    });
  }
  async run(accessor, data) {
    const fileDialogService = accessor.get(IFileDialogService);
    return fileDialogService.pickFolderAndOpen({ forceNewWindow: false, telemetryExtraData: data });
  }
};
_OpenFolderAction.ID = "workbench.action.files.openFolder";
var OpenFolderAction = _OpenFolderAction;
var _OpenFolderViaWorkspaceAction = class _OpenFolderViaWorkspaceAction extends Action2 {
  constructor() {
    super({
      id: _OpenFolderViaWorkspaceAction.ID,
      title: { value: localize("openFolder", "Open Folder..."), original: "Open Folder..." },
      category: Categories.File,
      f1: true,
      precondition: ContextKeyExpr.and(OpenFolderWorkspaceSupportContext.toNegated(), WorkbenchStateContext.isEqualTo("workspace")),
      keybinding: {
        weight: 200,
        primary: 2048 | 45
      }
    });
  }
  run(accessor) {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(SET_ROOT_FOLDER_COMMAND_ID);
  }
};
_OpenFolderViaWorkspaceAction.ID = "workbench.action.files.openFolderViaWorkspace";
var OpenFolderViaWorkspaceAction = _OpenFolderViaWorkspaceAction;
var _OpenFileFolderAction = class _OpenFileFolderAction extends Action2 {
  constructor() {
    super({
      id: _OpenFileFolderAction.ID,
      title: _OpenFileFolderAction.LABEL,
      category: Categories.File,
      f1: true,
      precondition: ContextKeyExpr.and(IsMacNativeContext, OpenFolderWorkspaceSupportContext),
      keybinding: {
        weight: 200,
        primary: 2048 | 45
      }
    });
  }
  async run(accessor, data) {
    const fileDialogService = accessor.get(IFileDialogService);
    return fileDialogService.pickFileFolderAndOpen({ forceNewWindow: false, telemetryExtraData: data });
  }
};
_OpenFileFolderAction.ID = "workbench.action.files.openFileFolder";
_OpenFileFolderAction.LABEL = { value: localize("openFileFolder", "Open..."), original: "Open..." };
var OpenFileFolderAction = _OpenFileFolderAction;
var _OpenWorkspaceAction = class _OpenWorkspaceAction extends Action2 {
  constructor() {
    super({
      id: _OpenWorkspaceAction.ID,
      title: { value: localize("openWorkspaceAction", "Open Workspace from File..."), original: "Open Workspace from File..." },
      category: Categories.File,
      f1: true,
      precondition: EnterMultiRootWorkspaceSupportContext
    });
  }
  async run(accessor, data) {
    const fileDialogService = accessor.get(IFileDialogService);
    return fileDialogService.pickWorkspaceAndOpen({ telemetryExtraData: data });
  }
};
_OpenWorkspaceAction.ID = "workbench.action.openWorkspace";
var OpenWorkspaceAction = _OpenWorkspaceAction;
var _CloseWorkspaceAction = class _CloseWorkspaceAction extends Action2 {
  constructor() {
    super({
      id: _CloseWorkspaceAction.ID,
      title: { value: localize("closeWorkspace", "Close Workspace"), original: "Close Workspace" },
      category: workspacesCategory,
      f1: true,
      precondition: ContextKeyExpr.and(WorkbenchStateContext.notEqualsTo("empty"), EmptyWorkspaceSupportContext),
      keybinding: {
        weight: 200,
        primary: KeyChord(2048 | 41, 36)
      }
    });
  }
  async run(accessor) {
    const hostService = accessor.get(IHostService);
    const environmentService = accessor.get(IWorkbenchEnvironmentService);
    return hostService.openWindow({ forceReuseWindow: true, remoteAuthority: environmentService.remoteAuthority });
  }
};
_CloseWorkspaceAction.ID = "workbench.action.closeFolder";
var CloseWorkspaceAction = _CloseWorkspaceAction;
var _OpenWorkspaceConfigFileAction = class _OpenWorkspaceConfigFileAction extends Action2 {
  constructor() {
    super({
      id: _OpenWorkspaceConfigFileAction.ID,
      title: { value: localize("openWorkspaceConfigFile", "Open Workspace Configuration File"), original: "Open Workspace Configuration File" },
      category: workspacesCategory,
      f1: true,
      precondition: WorkbenchStateContext.isEqualTo("workspace")
    });
  }
  async run(accessor) {
    const contextService = accessor.get(IWorkspaceContextService);
    const editorService = accessor.get(IEditorService);
    const configuration = contextService.getWorkspace().configuration;
    if (configuration) {
      await editorService.openEditor({ resource: configuration, options: { pinned: true } });
    }
  }
};
_OpenWorkspaceConfigFileAction.ID = "workbench.action.openWorkspaceConfigFile";
var OpenWorkspaceConfigFileAction = _OpenWorkspaceConfigFileAction;
var _AddRootFolderAction = class _AddRootFolderAction extends Action2 {
  constructor() {
    super({
      id: _AddRootFolderAction.ID,
      title: ADD_ROOT_FOLDER_LABEL,
      category: workspacesCategory,
      f1: true,
      precondition: ContextKeyExpr.or(EnterMultiRootWorkspaceSupportContext, WorkbenchStateContext.isEqualTo("workspace"))
    });
  }
  run(accessor) {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(ADD_ROOT_FOLDER_COMMAND_ID);
  }
};
_AddRootFolderAction.ID = "workbench.action.addRootFolder";
var AddRootFolderAction = _AddRootFolderAction;
var _RemoveRootFolderAction = class _RemoveRootFolderAction extends Action2 {
  constructor() {
    super({
      id: _RemoveRootFolderAction.ID,
      title: { value: localize("globalRemoveFolderFromWorkspace", "Remove Folder from Workspace..."), original: "Remove Folder from Workspace..." },
      category: workspacesCategory,
      f1: true,
      precondition: ContextKeyExpr.and(WorkspaceFolderCountContext.notEqualsTo("0"), ContextKeyExpr.or(EnterMultiRootWorkspaceSupportContext, WorkbenchStateContext.isEqualTo("workspace")))
    });
  }
  async run(accessor) {
    const commandService = accessor.get(ICommandService);
    const workspaceEditingService = accessor.get(IWorkspaceEditingService);
    const folder = await commandService.executeCommand(PICK_WORKSPACE_FOLDER_COMMAND_ID);
    if (folder) {
      await workspaceEditingService.removeFolders([folder.uri]);
    }
  }
};
_RemoveRootFolderAction.ID = "workbench.action.removeRootFolder";
var RemoveRootFolderAction = _RemoveRootFolderAction;
var _SaveWorkspaceAsAction = class _SaveWorkspaceAsAction extends Action2 {
  constructor() {
    super({
      id: _SaveWorkspaceAsAction.ID,
      title: { value: localize("saveWorkspaceAsAction", "Save Workspace As..."), original: "Save Workspace As..." },
      category: workspacesCategory,
      f1: true,
      precondition: EnterMultiRootWorkspaceSupportContext
    });
  }
  async run(accessor) {
    const workspaceEditingService = accessor.get(IWorkspaceEditingService);
    const contextService = accessor.get(IWorkspaceContextService);
    const configPathUri = await workspaceEditingService.pickNewWorkspacePath();
    if (configPathUri && hasWorkspaceFileExtension(configPathUri)) {
      switch (contextService.getWorkbenchState()) {
        case 1:
        case 2: {
          const folders = contextService.getWorkspace().folders.map((folder) => ({ uri: folder.uri }));
          return workspaceEditingService.createAndEnterWorkspace(folders, configPathUri);
        }
        case 3:
          return workspaceEditingService.saveAndEnterWorkspace(configPathUri);
      }
    }
  }
};
_SaveWorkspaceAsAction.ID = "workbench.action.saveWorkspaceAs";
var SaveWorkspaceAsAction = _SaveWorkspaceAsAction;
var _DuplicateWorkspaceInNewWindowAction = class _DuplicateWorkspaceInNewWindowAction extends Action2 {
  constructor() {
    super({
      id: _DuplicateWorkspaceInNewWindowAction.ID,
      title: { value: localize("duplicateWorkspaceInNewWindow", "Duplicate As Workspace in New Window"), original: "Duplicate As Workspace in New Window" },
      category: workspacesCategory,
      f1: true,
      precondition: EnterMultiRootWorkspaceSupportContext
    });
  }
  async run(accessor) {
    const workspaceContextService = accessor.get(IWorkspaceContextService);
    const workspaceEditingService = accessor.get(IWorkspaceEditingService);
    const hostService = accessor.get(IHostService);
    const workspacesService = accessor.get(IWorkspacesService);
    const environmentService = accessor.get(IWorkbenchEnvironmentService);
    const folders = workspaceContextService.getWorkspace().folders;
    const remoteAuthority = environmentService.remoteAuthority;
    const newWorkspace = await workspacesService.createUntitledWorkspace(folders, remoteAuthority);
    await workspaceEditingService.copyWorkspaceSettings(newWorkspace);
    return hostService.openWindow([{ workspaceUri: newWorkspace.configPath }], { forceNewWindow: true, remoteAuthority });
  }
};
_DuplicateWorkspaceInNewWindowAction.ID = "workbench.action.duplicateWorkspaceInNewWindow";
var DuplicateWorkspaceInNewWindowAction = _DuplicateWorkspaceInNewWindowAction;

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/explorerViewlet.js
init_platform();
init_codicons();
var explorerViewIcon = registerIcon("explorer-view-icon", Codicon.files, localize("explorerViewIcon", "View icon of the explorer view."));
var openEditorsViewIcon = registerIcon("open-editors-view-icon", Codicon.book, localize("openEditorsIcon", "View icon of the open editors view."));
var ExplorerViewletViewsContribution = class ExplorerViewletViewsContribution2 extends Disposable {
  constructor(workspaceContextService, progressService) {
    super();
    this.workspaceContextService = workspaceContextService;
    progressService.withProgress({ location: 1 }, () => workspaceContextService.getCompleteWorkspace()).finally(() => {
      this.registerViews();
      this._register(workspaceContextService.onDidChangeWorkbenchState(() => this.registerViews()));
      this._register(workspaceContextService.onDidChangeWorkspaceFolders(() => this.registerViews()));
    });
  }
  registerViews() {
    mark("code/willRegisterExplorerViews");
    const viewDescriptors = viewsRegistry2.getViews(VIEW_CONTAINER);
    const viewDescriptorsToRegister = [];
    const viewDescriptorsToDeregister = [];
    this.createOpenEditorsViewDescriptor();
    const explorerViewDescriptor = this.createExplorerViewDescriptor();
    const registeredExplorerViewDescriptor = viewDescriptors.find((v) => v.id === explorerViewDescriptor.id);
    const emptyViewDescriptor = this.createEmptyViewDescriptor();
    const registeredEmptyViewDescriptor = viewDescriptors.find((v) => v.id === emptyViewDescriptor.id);
    if (this.workspaceContextService.getWorkbenchState() === 1 || this.workspaceContextService.getWorkspace().folders.length === 0) {
      if (registeredExplorerViewDescriptor) {
        viewDescriptorsToDeregister.push(registeredExplorerViewDescriptor);
      }
      if (!registeredEmptyViewDescriptor) {
        viewDescriptorsToRegister.push(emptyViewDescriptor);
      }
    } else {
      if (registeredEmptyViewDescriptor) {
        viewDescriptorsToDeregister.push(registeredEmptyViewDescriptor);
      }
      if (!registeredExplorerViewDescriptor) {
        viewDescriptorsToRegister.push(explorerViewDescriptor);
      }
    }
    if (viewDescriptorsToRegister.length) {
      viewsRegistry2.registerViews(viewDescriptorsToRegister, VIEW_CONTAINER);
    }
    if (viewDescriptorsToDeregister.length) {
      viewsRegistry2.deregisterViews(viewDescriptorsToDeregister, VIEW_CONTAINER);
    }
    mark("code/didRegisterExplorerViews");
  }
  createOpenEditorsViewDescriptor() {
    return {
      id: OpenEditorsView.ID,
      name: OpenEditorsView.NAME,
      ctorDescriptor: new SyncDescriptor(OpenEditorsView),
      containerIcon: openEditorsViewIcon,
      order: 0,
      canToggleVisibility: true,
      canMoveView: true,
      collapsed: false,
      hideByDefault: true,
      focusCommand: {
        id: "workbench.files.action.focusOpenEditorsView",
        keybindings: { primary: KeyChord(2048 | 41, 35) }
      }
    };
  }
  createEmptyViewDescriptor() {
    return {
      id: EmptyView.ID,
      name: EmptyView.NAME,
      containerIcon: explorerViewIcon,
      ctorDescriptor: new SyncDescriptor(EmptyView),
      order: 1,
      canToggleVisibility: true,
      focusCommand: {
        id: "workbench.explorer.fileView.focus"
      }
    };
  }
  createExplorerViewDescriptor() {
    return {
      id: VIEW_ID,
      name: localize("folders", "Folders"),
      containerIcon: explorerViewIcon,
      ctorDescriptor: new SyncDescriptor(ExplorerView),
      order: 1,
      canMoveView: true,
      canToggleVisibility: false,
      focusCommand: {
        id: "workbench.explorer.fileView.focus"
      }
    };
  }
};
ExplorerViewletViewsContribution = __decorate([
  __param(0, IWorkspaceContextService),
  __param(1, IProgressService)
], ExplorerViewletViewsContribution);
var ExplorerViewPaneContainer = class ExplorerViewPaneContainer2 extends ViewPaneContainer {
  constructor(layoutService, telemetryService, contextService, storageService, configurationService, instantiationService, contextKeyService, themeService, contextMenuService, extensionService, viewDescriptorService) {
    super(VIEWLET_ID, { mergeViewWithContainerWhenSingleView: true }, instantiationService, configurationService, layoutService, contextMenuService, telemetryService, extensionService, themeService, storageService, contextService, viewDescriptorService);
    this.viewletVisibleContextKey = ExplorerViewletVisibleContext.bindTo(contextKeyService);
    this._register(this.contextService.onDidChangeWorkspaceName((e) => this.updateTitleArea()));
  }
  create(parent) {
    super.create(parent);
    parent.classList.add("explorer-viewlet");
  }
  createView(viewDescriptor, options) {
    if (viewDescriptor.id === VIEW_ID) {
      return this.instantiationService.createInstance(ExplorerView, {
        ...options,
        delegate: {
          willOpenElement: (e) => {
            var _a43, _b;
            if (!(e instanceof MouseEvent)) {
              return;
            }
            const openEditorsView = this.getOpenEditorsView();
            if (openEditorsView) {
              let delay = 0;
              const config = this.configurationService.getValue();
              if (!!((_b = (_a43 = config.workbench) == null ? void 0 : _a43.editor) == null ? void 0 : _b.enablePreview)) {
                delay = 250;
              }
              openEditorsView.setStructuralRefreshDelay(delay);
            }
          },
          didOpenElement: (e) => {
            if (!(e instanceof MouseEvent)) {
              return;
            }
            const openEditorsView = this.getOpenEditorsView();
            openEditorsView == null ? void 0 : openEditorsView.setStructuralRefreshDelay(0);
          }
        }
      });
    }
    return super.createView(viewDescriptor, options);
  }
  getExplorerView() {
    return this.getView(VIEW_ID);
  }
  getOpenEditorsView() {
    return this.getView(OpenEditorsView.ID);
  }
  setVisible(visible) {
    this.viewletVisibleContextKey.set(visible);
    super.setVisible(visible);
  }
  focus() {
    const explorerView = this.getView(VIEW_ID);
    if (explorerView && this.panes.every((p) => !p.isExpanded())) {
      explorerView.setExpanded(true);
    }
    if (explorerView == null ? void 0 : explorerView.isExpanded()) {
      explorerView.focus();
    } else {
      super.focus();
    }
  }
};
ExplorerViewPaneContainer = __decorate([
  __param(0, IWorkbenchLayoutService),
  __param(1, ITelemetryService),
  __param(2, IWorkspaceContextService),
  __param(3, IStorageService),
  __param(4, IConfigurationService),
  __param(5, IInstantiationService),
  __param(6, IContextKeyService),
  __param(7, IThemeService),
  __param(8, IContextMenuService),
  __param(9, IExtensionService),
  __param(10, IViewDescriptorService)
], ExplorerViewPaneContainer);
var viewContainerRegistry = Registry.as(Extensions5.ViewContainersRegistry);
var VIEW_CONTAINER = viewContainerRegistry.registerViewContainer({
  id: VIEWLET_ID,
  title: localize("explore", "Explorer"),
  ctorDescriptor: new SyncDescriptor(ExplorerViewPaneContainer),
  storageId: "workbench.explorer.views.state",
  icon: explorerViewIcon,
  alwaysUseContainerInfo: true,
  hideIfEmpty: true,
  order: 0,
  openCommandActionDescriptor: {
    id: VIEWLET_ID,
    title: { value: localize("explore", "Explorer"), original: "Explorer" },
    mnemonicTitle: localize(
      { key: "miViewExplorer", comment: ["&& denotes a mnemonic"] },
      "&&Explorer"
    ),
    keybindings: { primary: 2048 | 1024 | 35 },
    order: 0
  }
}, 0, { isDefault: true });
var openFolder = localize("openFolder", "Open Folder");
var openFolderButton = `[${openFolder}](command:${isMacintosh && !isWeb ? OpenFileFolderAction.ID : OpenFolderAction.ID})`;
var viewsRegistry2 = Registry.as(Extensions5.ViewsRegistry);
var _a42;
viewsRegistry2.registerViewWelcomeContent(EmptyView.ID, {
  content: localize(
    { key: "noFolderHelp", comment: ['Please do not translate the word "commmand", it is part of our internal syntax which must not change'] },
    "You have not yet opened a folder.\n{0}",
    openFolderButton
  ),
  when: ContextKeyExpr.and(
    (_a42 = ContextKeyExpr.has("editorIsOpen")) == null ? void 0 : _a42.negate(),
    ContextKeyExpr.or(ContextKeyExpr.and(WorkbenchStateContext.notEqualsTo("workspace"), RemoteNameContext.isEqualTo("")), ContextKeyExpr.and(WorkbenchStateContext.notEqualsTo("workspace"), IsWebContext))
  ),
  group: ViewContentGroups.Open,
  order: 1
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/files.contribution.js
var configurationRegistry2 = Registry.as(Extensions2.Configuration);
var hotExitConfiguration = isNative ? {
  "type": "string",
  "scope": 1,
  "enum": [HotExitConfiguration.OFF, HotExitConfiguration.ON_EXIT, HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE],
  "default": HotExitConfiguration.ON_EXIT,
  "markdownEnumDescriptions": [
    localize(
      "hotExit.off",
      "Disable hot exit. A prompt will show when attempting to close a window with editors that have unsaved changes."
    ),
    localize(
      "hotExit.onExit",
      "Hot exit will be triggered when the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu). All windows without folders opened will be restored upon next launch. A list of previously opened windows with unsaved files can be accessed via `File > Open Recent > More...`"
    ),
    localize(
      "hotExit.onExitAndWindowClose",
      "Hot exit will be triggered when the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu), and also for any window with a folder opened regardless of whether it's the last window. All windows without folders opened will be restored upon next launch. A list of previously opened windows with unsaved files can be accessed via `File > Open Recent > More...`"
    )
  ],
  "description": localize(
    "hotExit",
    "Controls whether unsaved files are remembered between sessions, allowing the save prompt when exiting the editor to be skipped.",
    HotExitConfiguration.ON_EXIT,
    HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE
  )
} : {
  "type": "string",
  "scope": 1,
  "enum": [HotExitConfiguration.OFF, HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE],
  "default": HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE,
  "markdownEnumDescriptions": [
    localize(
      "hotExit.off",
      "Disable hot exit. A prompt will show when attempting to close a window with editors that have unsaved changes."
    ),
    localize(
      "hotExit.onExitAndWindowCloseBrowser",
      "Hot exit will be triggered when the browser quits or the window or tab is closed."
    )
  ],
  "description": localize(
    "hotExit",
    "Controls whether unsaved files are remembered between sessions, allowing the save prompt when exiting the editor to be skipped.",
    HotExitConfiguration.ON_EXIT,
    HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE
  )
};
configurationRegistry2.registerConfiguration({
  "id": "files",
  "order": 9,
  "title": localize("filesConfigurationTitle", "Files"),
  "type": "object",
  "properties": {
    [FILES_EXCLUDE_CONFIG]: {
      "type": "object",
      "markdownDescription": localize(
        "exclude",
        "Configure [glob patterns](https://aka.ms/vscode-glob-patterns) for excluding files and folders. For example, the File Explorer decides which files and folders to show or hide based on this setting. Refer to the `#search.exclude#` setting to define search-specific excludes. Refer to the `#explorer.excludeGitIgnore#` setting for ignoring files based on your `.gitignore`."
      ),
      "default": {
        ...{ "**/.git": true, "**/.svn": true, "**/.hg": true, "**/CVS": true, "**/.DS_Store": true, "**/Thumbs.db": true },
        ...isWeb ? { "**/*.crswap": true } : void 0
      },
      "scope": 4,
      "additionalProperties": {
        "anyOf": [
          {
            "type": "boolean",
            "enum": [true, false],
            "enumDescriptions": [localize("trueDescription", "Enable the pattern."), localize("falseDescription", "Disable the pattern.")],
            "description": localize(
              "files.exclude.boolean",
              "The glob pattern to match file paths against. Set to true or false to enable or disable the pattern."
            )
          },
          {
            "type": "object",
            "properties": {
              "when": {
                "type": "string",
                "pattern": "\\w*\\$\\(basename\\)\\w*",
                "default": "$(basename).ext",
                "markdownDescription": localize(
                  { key: "files.exclude.when", comment: ["\\$(basename) should not be translated"] },
                  "Additional check on the siblings of a matching file. Use \\$(basename) as variable for the matching file name."
                )
              }
            }
          }
        ]
      }
    },
    [FILES_ASSOCIATIONS_CONFIG]: {
      "type": "object",
      "markdownDescription": localize(
        "associations",
        'Configure [glob patterns](https://aka.ms/vscode-glob-patterns) of file associations to languages (for example `"*.extension": "html"`). Patterns will match on the absolute path of a file if they contain a path separator and will match on the name of the file otherwise. These have precedence over the default associations of the languages installed.'
      ),
      "additionalProperties": {
        "type": "string"
      }
    },
    "files.encoding": {
      "type": "string",
      "enum": Object.keys(SUPPORTED_ENCODINGS),
      "default": "utf8",
      "description": localize(
        "encoding",
        "The default character set encoding to use when reading and writing files. This setting can also be configured per language."
      ),
      "scope": 5,
      "enumDescriptions": Object.keys(SUPPORTED_ENCODINGS).map((key) => SUPPORTED_ENCODINGS[key].labelLong),
      "enumItemLabels": Object.keys(SUPPORTED_ENCODINGS).map((key) => SUPPORTED_ENCODINGS[key].labelLong)
    },
    "files.autoGuessEncoding": {
      "type": "boolean",
      "default": false,
      "markdownDescription": localize(
        "autoGuessEncoding",
        "When enabled, the editor will attempt to guess the character set encoding when opening files. This setting can also be configured per language. Note, this setting is not respected by text search. Only {0} is respected.",
        "`#files.encoding#`"
      ),
      "scope": 5
    },
    "files.eol": {
      "type": "string",
      "enum": [
        "\n",
        "\r\n",
        "auto"
      ],
      "enumDescriptions": [
        localize("eol.LF", "LF"),
        localize("eol.CRLF", "CRLF"),
        localize("eol.auto", "Uses operating system specific end of line character.")
      ],
      "default": "auto",
      "description": localize("eol", "The default end of line character."),
      "scope": 5
    },
    "files.enableTrash": {
      "type": "boolean",
      "default": true,
      "description": localize(
        "useTrash",
        "Moves files/folders to the OS trash (recycle bin on Windows) when deleting. Disabling this will delete files/folders permanently."
      )
    },
    "files.trimTrailingWhitespace": {
      "type": "boolean",
      "default": false,
      "description": localize(
        "trimTrailingWhitespace",
        "When enabled, will trim trailing whitespace when saving a file."
      ),
      "scope": 5
    },
    "files.insertFinalNewline": {
      "type": "boolean",
      "default": false,
      "description": localize(
        "insertFinalNewline",
        "When enabled, insert a final new line at the end of the file when saving it."
      ),
      "scope": 5
    },
    "files.trimFinalNewlines": {
      "type": "boolean",
      "default": false,
      "description": localize(
        "trimFinalNewlines",
        "When enabled, will trim all new lines after the final new line at the end of the file when saving it."
      ),
      scope: 5
    },
    "files.autoSave": {
      "type": "string",
      "enum": [AutoSaveConfiguration.OFF, AutoSaveConfiguration.AFTER_DELAY, AutoSaveConfiguration.ON_FOCUS_CHANGE, AutoSaveConfiguration.ON_WINDOW_CHANGE],
      "markdownEnumDescriptions": [
        localize(
          { comment: ["This is the description for a setting. Values surrounded by single quotes are not to be translated."], key: "files.autoSave.off" },
          "An editor with changes is never automatically saved."
        ),
        localize(
          { comment: ["This is the description for a setting. Values surrounded by single quotes are not to be translated."], key: "files.autoSave.afterDelay" },
          "An editor with changes is automatically saved after the configured `#files.autoSaveDelay#`."
        ),
        localize(
          { comment: ["This is the description for a setting. Values surrounded by single quotes are not to be translated."], key: "files.autoSave.onFocusChange" },
          "An editor with changes is automatically saved when the editor loses focus."
        ),
        localize(
          { comment: ["This is the description for a setting. Values surrounded by single quotes are not to be translated."], key: "files.autoSave.onWindowChange" },
          "An editor with changes is automatically saved when the window loses focus."
        )
      ],
      "default": isWeb ? AutoSaveConfiguration.AFTER_DELAY : AutoSaveConfiguration.OFF,
      "markdownDescription": localize(
        { comment: ["This is the description for a setting. Values surrounded by single quotes are not to be translated."], key: "autoSave" },
        "Controls [auto save](https://code.visualstudio.com/docs/editor/codebasics#_save-auto-save) of editors that have unsaved changes.",
        AutoSaveConfiguration.OFF,
        AutoSaveConfiguration.AFTER_DELAY,
        AutoSaveConfiguration.ON_FOCUS_CHANGE,
        AutoSaveConfiguration.ON_WINDOW_CHANGE,
        AutoSaveConfiguration.AFTER_DELAY
      )
    },
    "files.autoSaveDelay": {
      "type": "number",
      "default": 1e3,
      "minimum": 0,
      "markdownDescription": localize(
        { comment: ["This is the description for a setting. Values surrounded by single quotes are not to be translated."], key: "autoSaveDelay" },
        "Controls the delay in milliseconds after which an editor with unsaved changes is saved automatically. Only applies when `#files.autoSave#` is set to `{0}`.",
        AutoSaveConfiguration.AFTER_DELAY
      )
    },
    "files.watcherExclude": {
      "type": "object",
      "patternProperties": {
        ".*": { "type": "boolean" }
      },
      "default": { "**/.git/objects/**": true, "**/.git/subtree-cache/**": true, "**/node_modules/*/**": true, "**/.hg/store/**": true },
      "markdownDescription": localize(
        "watcherExclude",
        "Configure paths or [glob patterns](https://aka.ms/vscode-glob-patterns) to exclude from file watching. Paths can either be relative to the watched folder or absolute. Glob patterns are matched relative from the watched folder. When you experience the file watcher process consuming a lot of CPU, make sure to exclude large folders that are of less interest (such as build output folders)."
      ),
      "scope": 4
    },
    "files.watcherInclude": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "default": [],
      "description": localize(
        "watcherInclude",
        "Configure extra paths to watch for changes inside the workspace. By default, all workspace folders will be watched recursively, except for folders that are symbolic links. You can explicitly add absolute or relative paths to support watching folders that are symbolic links. Relative paths will be resolved to an absolute path using the currently opened workspace."
      ),
      "scope": 4
    },
    "files.hotExit": hotExitConfiguration,
    "files.defaultLanguage": {
      "type": "string",
      "markdownDescription": localize(
        "defaultLanguage",
        "The default language identifier that is assigned to new files. If configured to `${activeEditorLanguage}`, will use the language identifier of the currently active text editor if any."
      )
    },
    [FILES_READONLY_INCLUDE_CONFIG]: {
      "type": "object",
      "patternProperties": {
        ".*": { "type": "boolean" }
      },
      "default": {},
      "markdownDescription": localize(
        "filesReadonlyInclude",
        "Configure paths or [glob patterns](https://aka.ms/vscode-glob-patterns) to mark as read-only. Glob patterns are always evaluated relative to the path of the workspace folder unless they are absolute paths. You can exclude matching paths via the `#files.readonlyExclude#` setting. Files from readonly file system providers will always be read-only independent of this setting."
      ),
      "scope": 4
    },
    [FILES_READONLY_EXCLUDE_CONFIG]: {
      "type": "object",
      "patternProperties": {
        ".*": { "type": "boolean" }
      },
      "default": {},
      "markdownDescription": localize(
        "filesReadonlyExclude",
        "Configure paths or [glob patterns](https://aka.ms/vscode-glob-patterns) to exclude from being marked as read-only if they match as a result of the `#files.readonlyInclude#` setting. Glob patterns are always evaluated relative to the path of the workspace folder unless they are absolute paths. Files from readonly file system providers will always be read-only independent of this setting."
      ),
      "scope": 4
    },
    [FILES_READONLY_FROM_PERMISSIONS_CONFIG]: {
      "type": "boolean",
      "markdownDescription": localize(
        "filesReadonlyFromPermissions",
        "Marks files as read-only when their file permissions indicate as such. This can be overridden via `#files.readonlyInclude#` and `#files.readonlyExclude#` settings."
      ),
      "default": false
    },
    "files.restoreUndoStack": {
      "type": "boolean",
      "description": localize(
        "files.restoreUndoStack",
        "Restore the undo stack when a file is reopened."
      ),
      "default": true
    },
    "files.saveConflictResolution": {
      "type": "string",
      "enum": [
        "askUser",
        "overwriteFileOnDisk"
      ],
      "enumDescriptions": [
        localize(
          "askUser",
          "Will refuse to save and ask for resolving the save conflict manually."
        ),
        localize(
          "overwriteFileOnDisk",
          "Will resolve the save conflict by overwriting the file on disk with the changes in the editor."
        )
      ],
      "description": localize(
        "files.saveConflictResolution",
        "A save conflict can occur when a file is saved to disk that was changed by another program in the meantime. To prevent data loss, the user is asked to compare the changes in the editor with the version on disk. This setting should only be changed if you frequently encounter save conflict errors and may result in data loss if used without caution."
      ),
      "default": "askUser",
      "scope": 5
    },
    "files.dialog.defaultPath": {
      "type": "string",
      "pattern": "^((\\/|\\\\\\\\|[a-zA-Z]:\\\\).*)?$",
      "patternErrorMessage": localize(
        "defaultPathErrorMessage",
        "Default path for file dialogs must be an absolute path (e.g. C:\\\\myFolder or /myFolder)."
      ),
      "description": localize(
        "fileDialogDefaultPath",
        "Default path for file dialogs, overriding user's home path. Only used in the absence of a context-specific path, such as most recently opened file or folder."
      ),
      "scope": 2
    },
    "files.simpleDialog.enable": {
      "type": "boolean",
      "description": localize(
        "files.simpleDialog.enable",
        "Enables the simple file dialog for opening and saving files and folders. The simple file dialog replaces the system file dialog when enabled."
      ),
      "default": false
    },
    "files.participants.timeout": {
      type: "number",
      default: 6e4,
      markdownDescription: localize(
        "files.participants.timeout",
        "Timeout in milliseconds after which file participants for create, rename, and delete are cancelled. Use `0` to disable participants."
      )
    }
  }
});
configurationRegistry2.registerConfiguration({
  ...editorConfigurationBaseNode,
  properties: {
    "editor.formatOnSave": {
      "type": "boolean",
      "description": localize(
        "formatOnSave",
        "Format a file on save. A formatter must be available, the file must not be saved after delay, and the editor must not be shutting down."
      ),
      "scope": 5
    },
    "editor.formatOnSaveMode": {
      "type": "string",
      "default": "file",
      "enum": [
        "file",
        "modifications",
        "modificationsIfAvailable"
      ],
      "enumDescriptions": [
        localize(
          { key: "everything", comment: ["This is the description of an option"] },
          "Format the whole file."
        ),
        localize(
          { key: "modification", comment: ["This is the description of an option"] },
          "Format modifications (requires source control)."
        ),
        localize(
          { key: "modificationIfAvailable", comment: ["This is the description of an option"] },
          "Will attempt to format modifications only (requires source control). If source control can't be used, then the whole file will be formatted."
        )
      ],
      "markdownDescription": localize(
        "formatOnSaveMode",
        "Controls if format on save formats the whole file or only modifications. Only applies when `#editor.formatOnSave#` is enabled."
      ),
      "scope": 5
    }
  }
});
configurationRegistry2.registerConfiguration({
  "id": "explorer",
  "order": 10,
  "title": localize("explorerConfigurationTitle", "File Explorer"),
  "type": "object",
  "properties": {
    "explorer.openEditors.visible": {
      "type": "number",
      "description": localize(
        { key: "openEditorsVisible", comment: ["Open is an adjective"] },
        "The initial maximum number of editors shown in the Open Editors pane. Exceeding this limit will show a scroll bar and allow resizing the pane to display more items."
      ),
      "default": 9,
      "minimum": 1
    },
    "explorer.openEditors.minVisible": {
      "type": "number",
      "description": localize(
        { key: "openEditorsVisibleMin", comment: ["Open is an adjective"] },
        "The minimum number of editor slots pre-allocated in the Open Editors pane. If set to 0 the Open Editors pane will dynamically resize based on the number of editors."
      ),
      "default": 0,
      "minimum": 0
    },
    "explorer.openEditors.sortOrder": {
      "type": "string",
      "enum": ["editorOrder", "alphabetical", "fullPath"],
      "description": localize(
        { key: "openEditorsSortOrder", comment: ["Open is an adjective"] },
        "Controls the sorting order of editors in the Open Editors pane."
      ),
      "enumDescriptions": [
        localize(
          "sortOrder.editorOrder",
          "Editors are ordered in the same order editor tabs are shown."
        ),
        localize(
          "sortOrder.alphabetical",
          "Editors are ordered alphabetically by tab name inside each editor group."
        ),
        localize(
          "sortOrder.fullPath",
          "Editors are ordered alphabetically by full path inside each editor group."
        )
      ],
      "default": "editorOrder"
    },
    "explorer.autoReveal": {
      "type": ["boolean", "string"],
      "enum": [true, false, "focusNoScroll"],
      "default": true,
      "enumDescriptions": [
        localize("autoReveal.on", "Files will be revealed and selected."),
        localize("autoReveal.off", "Files will not be revealed and selected."),
        localize(
          "autoReveal.focusNoScroll",
          "Files will not be scrolled into view, but will still be focused."
        )
      ],
      "description": localize(
        "autoReveal",
        "Controls whether the Explorer should automatically reveal and select files when opening them."
      )
    },
    "explorer.autoRevealExclude": {
      "type": "object",
      "markdownDescription": localize(
        "autoRevealExclude",
        "Configure paths or [glob patterns](https://aka.ms/vscode-glob-patterns) for excluding files and folders from being revealed and selected in the Explorer when they are opened. Glob patterns are always evaluated relative to the path of the workspace folder unless they are absolute paths."
      ),
      "default": { "**/node_modules": true, "**/bower_components": true },
      "additionalProperties": {
        "anyOf": [
          {
            "type": "boolean",
            "description": localize(
              "explorer.autoRevealExclude.boolean",
              "The glob pattern to match file paths against. Set to true or false to enable or disable the pattern."
            )
          },
          {
            type: "object",
            properties: {
              when: {
                type: "string",
                pattern: "\\w*\\$\\(basename\\)\\w*",
                default: "$(basename).ext",
                description: localize(
                  "explorer.autoRevealExclude.when",
                  "Additional check on the siblings of a matching file. Use $(basename) as variable for the matching file name."
                )
              }
            }
          }
        ]
      }
    },
    "explorer.enableDragAndDrop": {
      "type": "boolean",
      "description": localize(
        "enableDragAndDrop",
        "Controls whether the Explorer should allow to move files and folders via drag and drop. This setting only effects drag and drop from inside the Explorer."
      ),
      "default": true
    },
    "explorer.confirmDragAndDrop": {
      "type": "boolean",
      "description": localize(
        "confirmDragAndDrop",
        "Controls whether the Explorer should ask for confirmation to move files and folders via drag and drop."
      ),
      "default": true
    },
    "explorer.confirmDelete": {
      "type": "boolean",
      "description": localize(
        "confirmDelete",
        "Controls whether the Explorer should ask for confirmation when deleting a file via the trash."
      ),
      "default": true
    },
    "explorer.enableUndo": {
      "type": "boolean",
      "description": localize(
        "enableUndo",
        "Controls whether the Explorer should support undoing file and folder operations."
      ),
      "default": true
    },
    "explorer.confirmUndo": {
      "type": "string",
      "enum": ["verbose", "default", "light"],
      "description": localize(
        "confirmUndo",
        "Controls whether the Explorer should ask for confirmation when undoing."
      ),
      "default": "default",
      "enumDescriptions": [
        localize("enableUndo.verbose", "Explorer will prompt before all undo operations."),
        localize(
          "enableUndo.default",
          "Explorer will prompt before destructive undo operations."
        ),
        localize(
          "enableUndo.light",
          "Explorer will not prompt before undo operations when focused."
        )
      ]
    },
    "explorer.expandSingleFolderWorkspaces": {
      "type": "boolean",
      "description": localize(
        "expandSingleFolderWorkspaces",
        "Controls whether the Explorer should expand multi-root workspaces containing only one folder during initialization"
      ),
      "default": true
    },
    "explorer.sortOrder": {
      "type": "string",
      "enum": ["default", "mixed", "filesFirst", "type", "modified", "foldersNestsFiles"],
      "default": "default",
      "enumDescriptions": [
        localize(
          "sortOrder.default",
          "Files and folders are sorted by their names. Folders are displayed before files."
        ),
        localize(
          "sortOrder.mixed",
          "Files and folders are sorted by their names. Files are interwoven with folders."
        ),
        localize(
          "sortOrder.filesFirst",
          "Files and folders are sorted by their names. Files are displayed before folders."
        ),
        localize(
          "sortOrder.type",
          "Files and folders are grouped by extension type then sorted by their names. Folders are displayed before files."
        ),
        localize(
          "sortOrder.modified",
          "Files and folders are sorted by last modified date in descending order. Folders are displayed before files."
        ),
        localize(
          "sortOrder.foldersNestsFiles",
          "Files and folders are sorted by their names. Folders are displayed before files. Files with nested children are displayed before other files."
        )
      ],
      "markdownDescription": localize(
        "sortOrder",
        "Controls the property-based sorting of files and folders in the Explorer. When `#explorer.fileNesting.enabled#` is enabled, also controls sorting of nested files."
      )
    },
    "explorer.sortOrderLexicographicOptions": {
      "type": "string",
      "enum": ["default", "upper", "lower", "unicode"],
      "default": "default",
      "enumDescriptions": [
        localize(
          "sortOrderLexicographicOptions.default",
          "Uppercase and lowercase names are mixed together."
        ),
        localize(
          "sortOrderLexicographicOptions.upper",
          "Uppercase names are grouped together before lowercase names."
        ),
        localize(
          "sortOrderLexicographicOptions.lower",
          "Lowercase names are grouped together before uppercase names."
        ),
        localize(
          "sortOrderLexicographicOptions.unicode",
          "Names are sorted in Unicode order."
        )
      ],
      "description": localize(
        "sortOrderLexicographicOptions",
        "Controls the lexicographic sorting of file and folder names in the Explorer."
      )
    },
    "explorer.decorations.colors": {
      type: "boolean",
      description: localize(
        "explorer.decorations.colors",
        "Controls whether file decorations should use colors."
      ),
      default: true
    },
    "explorer.decorations.badges": {
      type: "boolean",
      description: localize(
        "explorer.decorations.badges",
        "Controls whether file decorations should use badges."
      ),
      default: true
    },
    "explorer.incrementalNaming": {
      "type": "string",
      enum: ["simple", "smart", "disabled"],
      enumDescriptions: [
        localize(
          "simple",
          'Appends the word "copy" at the end of the duplicated name potentially followed by a number.'
        ),
        localize(
          "smart",
          "Adds a number at the end of the duplicated name. If some number is already part of the name, tries to increase that number."
        ),
        localize(
          "disabled",
          "Disables incremental naming. If two files with the same name exist you will be prompted to overwrite the existing file."
        )
      ],
      description: localize(
        "explorer.incrementalNaming",
        "Controls what naming strategy to use when a giving a new name to a duplicated Explorer item on paste."
      ),
      default: "simple"
    },
    "explorer.compactFolders": {
      "type": "boolean",
      "description": localize(
        "compressSingleChildFolders",
        "Controls whether the Explorer should render folders in a compact form. In such a form, single child folders will be compressed in a combined tree element. Useful for Java package structures, for example."
      ),
      "default": true
    },
    "explorer.copyRelativePathSeparator": {
      "type": "string",
      "enum": [
        "/",
        "\\",
        "auto"
      ],
      "enumDescriptions": [
        localize(
          "copyRelativePathSeparator.slash",
          "Use slash as path separation character."
        ),
        localize(
          "copyRelativePathSeparator.backslash",
          "Use backslash as path separation character."
        ),
        localize(
          "copyRelativePathSeparator.auto",
          "Uses operating system specific path separation character."
        )
      ],
      "description": localize(
        "copyRelativePathSeparator",
        "The path separation character used when copying relative file paths."
      ),
      "default": "auto"
    },
    "explorer.excludeGitIgnore": {
      type: "boolean",
      markdownDescription: localize(
        "excludeGitignore",
        "Controls whether entries in .gitignore should be parsed and excluded from the Explorer. Similar to {0}.",
        "`#files.exclude#`"
      ),
      default: false,
      scope: 4
    },
    "explorer.fileNesting.enabled": {
      "type": "boolean",
      scope: 4,
      "markdownDescription": localize(
        "fileNestingEnabled",
        "Controls whether file nesting is enabled in the Explorer. File nesting allows for related files in a directory to be visually grouped together under a single parent file."
      ),
      "default": false
    },
    "explorer.fileNesting.expand": {
      "type": "boolean",
      "markdownDescription": localize(
        "fileNestingExpand",
        "Controls whether file nests are automatically expanded. {0} must be set for this to take effect.",
        "`#explorer.fileNesting.enabled#`"
      ),
      "default": true
    },
    "explorer.fileNesting.patterns": {
      "type": "object",
      scope: 4,
      "markdownDescription": localize(
        "fileNestingPatterns",
        "Controls nesting of files in the Explorer. {0} must be set for this to take effect. Each __Item__ represents a parent pattern and may contain a single `*` character that matches any string. Each __Value__ represents a comma separated list of the child patterns that should be shown nested under a given parent. Child patterns may contain several special tokens:\n- `${capture}`: Matches the resolved value of the `*` from the parent pattern\n- `${basename}`: Matches the parent file's basename, the `file` in `file.ts`\n- `${extname}`: Matches the parent file's extension, the `ts` in `file.ts`\n- `${dirname}`: Matches the parent file's directory name, the `src` in `src/file.ts`\n- `*`:  Matches any string, may only be used once per child pattern",
        "`#explorer.fileNesting.enabled#`"
      ),
      patternProperties: {
        "^[^*]*\\*?[^*]*$": {
          markdownDescription: localize(
            "fileNesting.description",
            "Each key pattern may contain a single `*` character which will match any string."
          ),
          type: "string",
          pattern: "^([^,*]*\\*?[^,*]*)(, ?[^,*]*\\*?[^,*]*)*$"
        }
      },
      additionalProperties: false,
      "default": {
        "*.ts": "${capture}.js",
        "*.js": "${capture}.js.map, ${capture}.min.js, ${capture}.d.ts",
        "*.jsx": "${capture}.js",
        "*.tsx": "${capture}.ts",
        "tsconfig.json": "tsconfig.*.json",
        "package.json": "package-lock.json, yarn.lock, pnpm-lock.yaml"
      }
    }
  }
});

// node_modules/vscode/service-override/files.js
init_network();
var RegisteredFile = class {
  constructor(uri, readonly) {
    this.uri = uri;
    this.readonly = readonly;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onDidDelete = new Emitter();
    this.onDidDelete = this._onDidDelete.event;
    this._onDidRename = new Emitter();
    this.onDidRename = this._onDidRename.event;
    this.ctime = Date.now();
    this.mtime = Date.now();
    this.type = FileType2.File;
  }
  async stats() {
    return {
      ctime: this.ctime,
      mtime: this.mtime,
      size: await this.getSize(),
      type: FileType2.File,
      permissions: this.readonly ? FilePermission2.Readonly : void 0
    };
  }
  async getSize() {
    return (await this.read()).length;
  }
  async delete() {
    this._onDidDelete.fire();
  }
  async rename(to) {
    const previousUri = this.uri;
    this.uri = to;
    this._onDidRename.fire({ from: previousUri, to });
  }
};
var RegisteredReadOnlyFile = class extends RegisteredFile {
  constructor(uri, read) {
    super(uri, true);
    this.read = read;
  }
  write() {
    throw createFileSystemProviderError("Not allowed", FileSystemProviderErrorCode.FileWriteLocked);
  }
  async delete() {
    throw createFileSystemProviderError("Not allowed", FileSystemProviderErrorCode.FileWriteLocked);
  }
  async rename() {
    throw createFileSystemProviderError("Not allowed", FileSystemProviderErrorCode.FileWriteLocked);
  }
};
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var RegisteredFileSystemProvider = class extends Disposable {
  constructor(readonly) {
    super();
    this.onDidChangeCapabilities = Event.None;
    this._onDidChangeFile = new Emitter();
    this.onDidChangeFile = this._onDidChangeFile.event;
    this.files = /* @__PURE__ */ new Map();
    this.capabilities = 2 | 1024;
    if (readonly) {
      this.capabilities |= 2048;
    }
  }
  registerFile(file) {
    this.files.set(file.uri.toString(), file);
    this._onDidChangeFile.fire([{
      resource: file.uri,
      type: 1
    }]);
    const disposableStore = new DisposableStore();
    disposableStore.add(toDisposable(() => {
      if (this.files.get(file.uri.toString()) === file) {
        this.files.delete(file.uri.toString());
        this._onDidChangeFile.fire([{
          resource: file.uri,
          type: 2
        }]);
      }
    }));
    disposableStore.add(file.onDidDelete(() => {
      disposableStore.dispose();
    }));
    disposableStore.add(file.onDidChange(() => {
      this._onDidChangeFile.fire([{
        resource: file.uri,
        type: 0
      }]);
    }));
    disposableStore.add(file.onDidRename(({ from, to }) => {
      if (this.files.get(from.toString()) === file) {
        this.files.delete(from.toString());
        this._onDidChangeFile.fire([{
          resource: from,
          type: 2
        }]);
        this.files.set(to.toString(), file);
        this._onDidChangeFile.fire([{
          resource: to,
          type: 1
        }]);
      }
    }));
    return disposableStore;
  }
  async stat(resource) {
    const resourceUri = resource.toString();
    const file = this.files.get(resourceUri);
    if (file != null) {
      return file.stats();
    }
    const handledUris = Array.from(this.files.keys());
    for (const handledUri of handledUris) {
      if (handledUri.startsWith(resourceUri + "/")) {
        return {
          ctime: Date.now(),
          mtime: Date.now(),
          size: 0,
          type: FileType2.Directory
        };
      }
    }
    throw createFileSystemProviderError("file not found", FileSystemProviderErrorCode.FileNotFound);
  }
  async readdir(resource) {
    const includedPaths = Array.from(this.files.keys()).map((uri) => relative(resource.path, URI.parse(uri).path)).filter((path) => !path.startsWith(".."));
    const files = includedPaths.filter((path) => !path.includes("/"));
    const directories = includedPaths.filter((path) => path.includes("/")).map((path) => path.slice(0, path.indexOf("/")));
    return [
      ...files.map((path) => [
        path,
        FileType2.File
      ]),
      ...directories.map((path) => [
        path,
        FileType2.Directory
      ])
    ];
  }
  async readFile(resource) {
    const file = this.files.get(resource.toString());
    if (file != null) {
      const data = await file.read();
      if (data instanceof Uint8Array) {
        return data;
      } else {
        return encoder.encode(data);
      }
    }
    throw FileSystemProviderError.create("file not found", FileSystemProviderErrorCode.FileNotFound);
  }
  watch() {
    return Disposable.None;
  }
  async writeFile(resource, content) {
    const file = this.files.get(resource.toString());
    if ((file == null ? void 0 : file.write) != null) {
      await file.write(decoder.decode(content));
      return;
    }
    throw createFileSystemProviderError("Not allowed", FileSystemProviderErrorCode.NoPermissions);
  }
  async delete(resource) {
    const file = this.files.get(resource.toString());
    if (file != null) {
      await file.delete();
      return;
    }
    throw createFileSystemProviderError("File not found", FileSystemProviderErrorCode.FileNotFound);
  }
  async rename(from, to) {
    const file = this.files.get(from.toString());
    if (file != null) {
      await file.rename(to);
      return;
    }
    throw createFileSystemProviderError("File not found", FileSystemProviderErrorCode.FileNotFound);
  }
  async mkdir() {
    throw createFileSystemProviderError("Not allowed", FileSystemProviderErrorCode.NoPermissions);
  }
};
function isFullfiled(result) {
  return result.status === "fulfilled";
}
var OverlayFileSystemProvider = class {
  constructor() {
    this.providers = [];
    this.onDidChangeCapabilities = Event.None;
    this._onDidChangeFile = new Emitter();
    this.onDidChangeFile = this._onDidChangeFile.event;
    this._onDidChangeOverlays = new Emitter();
    this.onDidChangeOverlays = this._onDidChangeOverlays.event;
    this.capabilities = 2 | 1024;
  }
  register(priority, provider) {
    const item = { priority, provider };
    this.providers.push(item);
    this.providers.sort((a, b) => b.priority - a.priority);
    const disposableStore = new DisposableStore();
    disposableStore.add(provider.onDidChangeFile((e) => {
      this._onDidChangeFile.fire(e);
    }));
    disposableStore.add({
      dispose: () => {
        const index = this.providers.indexOf(item);
        if (index >= 0) {
          this.providers.splice(index, 1);
          this._onDidChangeOverlays.fire();
        }
      }
    });
    this._onDidChangeOverlays.fire();
    return disposableStore;
  }
  get delegates() {
    return this.providers.map(({ provider }) => provider);
  }
  async readFromDelegates(caller) {
    let firstError;
    for (const delegate of this.delegates) {
      try {
        return await caller(delegate);
      } catch (err) {
        firstError ?? (firstError = err);
        if (err instanceof FileSystemProviderError && [
          FileSystemProviderErrorCode.NoPermissions,
          FileSystemProviderErrorCode.FileNotFound,
          FileSystemProviderErrorCode.Unavailable
        ].includes(err.code)) {
          continue;
        }
        throw err;
      }
    }
    throw firstError;
  }
  async writeToDelegates(resource, caller) {
    for (const provider of this.delegates) {
      if ((provider.capabilities & 2048) > 0) {
        continue;
      }
      try {
        return await caller(provider);
      } catch (err) {
        if (err instanceof FileSystemProviderError && [
          FileSystemProviderErrorCode.NoPermissions,
          FileSystemProviderErrorCode.FileNotFound,
          FileSystemProviderErrorCode.Unavailable
        ].includes(err.code)) {
          continue;
        }
        throw err;
      }
    }
    throw createFileSystemProviderError("Not allowed", FileSystemProviderErrorCode.NoPermissions);
  }
  async stat(resource) {
    return this.readFromDelegates(async (delegate) => {
      const result = await delegate.stat(resource);
      const readOnly = (delegate.capabilities & 2048) > 0;
      return {
        ...result,
        permissions: result.permissions ?? (readOnly ? FilePermission2.Readonly : void 0)
      };
    });
  }
  async readFile(resource) {
    return this.readFromDelegates((delegate) => delegate.readFile(resource));
  }
  async readdir(resource) {
    const results = await Promise.allSettled(this.delegates.map((delegate) => delegate.readdir(resource)));
    if (!results.some(isFullfiled)) {
      throw results[0].reason;
    }
    return Object.entries(Object.fromEntries(results.filter(isFullfiled).map((result) => result.value).flat()));
  }
  watch(resource, opts) {
    const store = new DisposableStore();
    for (const delegate of this.delegates) {
      store.add(delegate.watch(resource, opts));
    }
    return store;
  }
  async writeFile(resource, content, opts) {
    await this.writeToDelegates(resource, async (delegate) => {
      try {
        const stats = await delegate.stat(resource);
        if (((stats.permissions ?? 0) & FilePermission2.Readonly) > 0) {
          throw createFileSystemProviderError("Not allowed", FileSystemProviderErrorCode.NoPermissions);
        }
      } catch (err) {
      }
      return delegate.writeFile(resource, content, opts);
    });
  }
  async mkdir(resource) {
    await this.writeToDelegates(resource, (delegate) => delegate.mkdir(resource));
  }
  async delete(resource, opts) {
    await this.writeToDelegates(resource, (delegate) => delegate.delete(resource, opts));
  }
  async rename(from, to, opts) {
    await this.writeToDelegates(from, (delegate) => delegate.rename(from, to, opts));
  }
};
var MkdirpOnWriteInMemoryFileSystemProvider = class extends InMemoryFileSystemProvider {
  async writeFile(resource, content, opts) {
    await StandaloneServices.get(IFileService)["mkdirp"](this, extUri.dirname(resource));
    return super.writeFile(resource, content, opts);
  }
};
var fileSystemProvider = new OverlayFileSystemProvider();
fileSystemProvider.register(0, new MkdirpOnWriteInMemoryFileSystemProvider());
var extensionFileSystemProvider = new RegisteredFileSystemProvider(true);
var MemoryFileService = class MemoryFileService2 extends FileService2 {
  constructor(logService) {
    super(logService);
    const userMemoryFileSystem = new InMemoryFileSystemProvider();
    this.registerProvider("user", userMemoryFileSystem);
    this.registerProvider("extension", extensionFileSystemProvider);
    this.registerProvider("cache", new InMemoryFileSystemProvider());
    this.registerProvider("logs", new InMemoryFileSystemProvider());
    this.registerProvider(Schemas.vscodeUserData, new InMemoryFileSystemProvider());
    this.registerProvider(Schemas.tmp, new InMemoryFileSystemProvider());
    let fileSystemProviderDisposable = this.registerProvider("file", fileSystemProvider);
    fileSystemProvider.onDidChangeOverlays(() => {
      fileSystemProviderDisposable.dispose();
      fileSystemProviderDisposable = this.registerProvider("file", fileSystemProvider);
    });
  }
};
MemoryFileService = __decorate([
  __param(0, ILogService)
], MemoryFileService);
function getServiceOverride() {
  return {
    [IFileService.toString()]: new SyncDescriptor(MemoryFileService, [], true)
  };
}
function registerExtensionFile(extensionLocation, filePath, getContent) {
  return extensionFileSystemProvider.registerFile(new RegisteredReadOnlyFile(joinPath(extensionLocation, filePath), getContent));
}

export {
  IWorkbenchEnvironmentService,
  IRemoteExtensionsScannerService,
  IWorkbenchExtensionManagementService,
  IWorkbenchExtensionEnablementService,
  getVirtualWorkspaceScheme,
  Memento,
  IExtensionManifestPropertiesService,
  ExtensionManifestPropertiesService,
  IPathService,
  ISearchService,
  resultIsMatch,
  getExcludes,
  pathIncludedInQuery,
  resolvePatternsForProvider,
  QueryGlobTester,
  hasSiblingPromiseFn,
  hasSiblingFn,
  IDialogService,
  IFileDialogService,
  IBrowserWorkbenchEnvironmentService,
  BrowserWorkbenchEnvironmentService,
  IUserDataInitializationService,
  IExtensionHostDebugService,
  IRemoteSocketFactoryService,
  ISignService,
  ITunnelService,
  TunnelProtocol,
  TunnelPrivacyId,
  ProvidedOnAutoForward,
  LOCALHOST_ADDRESSES,
  isLocalhost,
  ALL_INTERFACES_ADDRESSES,
  isAllInterfaces,
  DisposableTunnel,
  OUTPUT_MIME,
  OUTPUT_MODE_ID,
  LOG_MIME,
  LOG_SCHEME,
  LOG_MODE_ID,
  OUTPUT_VIEW_ID,
  CONTEXT_IN_OUTPUT,
  CONTEXT_ACTIVE_LOG_OUTPUT,
  CONTEXT_OUTPUT_SCROLL_LOCK,
  IOutputService,
  OutputChannelUpdateMode,
  Extensions6 as Extensions,
  ACTIVE_OUTPUT_CHANNEL_CONTEXT,
  fromNow,
  toLocalISOString,
  Extensions5 as Extensions2,
  IViewsService,
  IViewDescriptorService,
  ResolvableTreeItem,
  NoTreeViewError,
  IConfigurationResolverService,
  VariableKind,
  VariableError,
  IPaneCompositePartService,
  IWorkingCopyService,
  IWorkingCopyFileService,
  ILanguageStatusService,
  IHostService,
  IKeyboardLayoutService,
  getKeyboardLayoutId,
  IHostColorSchemeService,
  IPreferencesService,
  FallbackKeyboardMapper,
  IActivityService,
  NumberBadge,
  ITaskService,
  IRequestService,
  IWorkspaceEditingService,
  ITimerService,
  IExtensionsWorkbenchService,
  IFilesConfigurationService,
  EditorModel,
  BaseTextEditorModel,
  NO_TYPE_ID,
  IUntitledTextEditorService,
  IDecorationsService,
  TextFileEditorModel,
  IJSONEditingService,
  setProperty,
  IWorkspacesService,
  isRecentWorkspace,
  isRecentFolder,
  isRecentFile,
  isStoredWorkspaceFolder,
  getStoredWorkspaceFolder,
  toWorkspaceFolders,
  rewriteWorkspaceFileForNewLocation,
  restoreRecentlyOpened,
  toStoreData,
  EditorInput,
  SideBySideEditorInput,
  DiffEditorInput,
  TextResourceEditorModel,
  AbstractTextResourceEditorInput,
  TextResourceEditorInput,
  UntitledTextEditorInput,
  IEditorResolverService,
  LogContentProvider,
  IHoverService,
  IExtensionStorageService,
  ILanguagePackService,
  IOutlineService,
  IStatusbarService,
  ITerminalService,
  ITerminalEditorService,
  ITerminalGroupService,
  ITerminalInstanceService,
  terminalEditorId,
  ITerminalProfileResolverService,
  ITerminalProfileService,
  TerminalLocation,
  TerminalExitReason,
  ITerminalLinkProviderService,
  IEnvironmentVariableService,
  ITerminalQuickFixService,
  TerminalQuickFixType,
  INotebookService,
  SimpleNotebookProviderInfo,
  INotebookEditorService,
  INotebookEditorModelResolverService,
  IUserActivityService,
  ICanonicalUriService,
  TAB_ACTIVE_BORDER,
  EDITOR_DRAG_AND_DROP_BACKGROUND,
  PANEL_BORDER,
  SIDE_BAR_BACKGROUND,
  IExtensionStatusBarItemService,
  IWorkbenchAssignmentService,
  IChatService,
  ICustomEditorService,
  IWebviewService,
  ExtensionKeyedWebviewOriginStore,
  WebviewInput,
  IWorkbenchLayoutService,
  positionToString,
  IWebviewWorkbenchService,
  LazilyResolvedWebviewEditorInput,
  IWebviewViewService,
  defaultExternalUriOpenerId,
  updateContributedOpeners,
  IExternalUriOpenerService,
  IURLService,
  ICredentialsService,
  ISCMService,
  ISCMViewService,
  IDownloadService,
  IExtensionUrlHandler,
  ICommentService,
  INotebookCellStatusBarService,
  INotebookKernelService,
  INotebookRendererMessagingService,
  IInteractiveDocumentService,
  IInlineChatService,
  IChatWidgetService,
  IRemoteExplorerService,
  PORT_AUTO_FORWARD_SETTING,
  PORT_AUTO_SOURCE_SETTING,
  PORT_AUTO_SOURCE_SETTING_OUTPUT,
  IAuthenticationService,
  ITimelineService,
  ITestService,
  ISecretStorageService,
  IShareService,
  IWorkbenchIssueService,
  NotebookExecutionType,
  INotebookExecutionStateService,
  IChatContributionService,
  ITestProfileService,
  IEncryptionService,
  ITestResultService,
  IChatProviderService,
  IChatSlashCommandService,
  IChatVariablesService,
  IAiRelatedInformationService,
  RelatedInformationType,
  IAiEmbeddingVectorService,
  EditorPaneDescriptor,
  getWorkspaceIdentifier,
  unsupported,
  memoizedConstructor,
  applyTextEditorOptions,
  AbstractTextEditor,
  FakeAbstractTextEditor,
  viewFilterSubmenu,
  ViewPane,
  FilterViewPane,
  ViewAction,
  ViewPaneContainer,
  columnToEditorGroup,
  editorGroupToColumn,
  ResourceLabels,
  TriggerAction,
  PickerQuickAccessProvider,
  scoreFuzzy2,
  prepareQuery,
  pieceToQuery,
  getServiceOverride,
  registerExtensionFile
};
//# sourceMappingURL=chunk-AR3QIQFF.js.map
