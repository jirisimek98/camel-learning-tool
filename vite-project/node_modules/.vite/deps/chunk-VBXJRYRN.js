import {
  ExtensionsRegistry
} from "./chunk-UI7MTZPM.js";
import {
  Color,
  Extensions5 as Extensions,
  Registry,
  init_color,
  init_colorRegistry,
  init_platform
} from "./chunk-Z3Z4BZM7.js";
import {
  init_nls,
  localize
} from "./chunk-N5MAMNNV.js";

// node_modules/vscode/vscode/src/vs/workbench/services/themes/common/colorExtensionPoint.js
init_nls();
init_colorRegistry();
init_color();
init_platform();
var colorRegistry = Registry.as(Extensions.ColorContribution);
var colorReferenceSchema = colorRegistry.getColorReferenceSchema();
var colorIdPattern = "^\\w+[.\\w+]*$";
var configurationExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "colors",
  jsonSchema: {
    description: localize("contributes.color", "Contributes extension defined themable colors"),
    type: "array",
    items: {
      type: "object",
      properties: {
        id: {
          type: "string",
          description: localize("contributes.color.id", "The identifier of the themable color"),
          pattern: colorIdPattern,
          patternErrorMessage: localize(
            "contributes.color.id.format",
            "Identifiers must only contain letters, digits and dots and can not start with a dot"
          )
        },
        description: {
          type: "string",
          description: localize("contributes.color.description", "The description of the themable color")
        },
        defaults: {
          type: "object",
          properties: {
            light: {
              description: localize(
                "contributes.defaults.light",
                "The default color for light themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default."
              ),
              type: "string",
              anyOf: [
                colorReferenceSchema,
                { type: "string", format: "color-hex" }
              ]
            },
            dark: {
              description: localize(
                "contributes.defaults.dark",
                "The default color for dark themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default."
              ),
              type: "string",
              anyOf: [
                colorReferenceSchema,
                { type: "string", format: "color-hex" }
              ]
            },
            highContrast: {
              description: localize(
                "contributes.defaults.highContrast",
                "The default color for high contrast dark themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default. If not provided, the `dark` color is used as default for high contrast dark themes."
              ),
              type: "string",
              anyOf: [
                colorReferenceSchema,
                { type: "string", format: "color-hex" }
              ]
            },
            highContrastLight: {
              description: localize(
                "contributes.defaults.highContrastLight",
                "The default color for high contrast light themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default. If not provided, the `light` color is used as default for high contrast light themes."
              ),
              type: "string",
              anyOf: [
                colorReferenceSchema,
                { type: "string", format: "color-hex" }
              ]
            }
          },
          required: ["light", "dark"]
        }
      }
    }
  }
});
var ColorExtensionPoint = class {
  constructor() {
    configurationExtPoint.setHandler((extensions, delta) => {
      for (const extension of delta.added) {
        const extensionValue = extension.value;
        const collector = extension.collector;
        if (!extensionValue || !Array.isArray(extensionValue)) {
          collector.error(localize("invalid.colorConfiguration", "'configuration.colors' must be a array"));
          return;
        }
        const parseColorValue = (s, name) => {
          if (s.length > 0) {
            if (s[0] === "#") {
              return Color.Format.CSS.parseHex(s);
            } else {
              return s;
            }
          }
          collector.error(localize(
            "invalid.default.colorType",
            "{0} must be either a color value in hex (#RRGGBB[AA] or #RGB[A]) or the identifier of a themable color which provides the default.",
            name
          ));
          return Color.red;
        };
        for (const colorContribution of extensionValue) {
          if (typeof colorContribution.id !== "string" || colorContribution.id.length === 0) {
            collector.error(localize(
              "invalid.id",
              "'configuration.colors.id' must be defined and can not be empty"
            ));
            return;
          }
          if (!colorContribution.id.match(colorIdPattern)) {
            collector.error(localize(
              "invalid.id.format",
              "'configuration.colors.id' must only contain letters, digits and dots and can not start with a dot"
            ));
            return;
          }
          if (typeof colorContribution.description !== "string" || colorContribution.id.length === 0) {
            collector.error(localize(
              "invalid.description",
              "'configuration.colors.description' must be defined and can not be empty"
            ));
            return;
          }
          const defaults = colorContribution.defaults;
          if (!defaults || typeof defaults !== "object" || typeof defaults.light !== "string" || typeof defaults.dark !== "string") {
            collector.error(localize(
              "invalid.defaults",
              "'configuration.colors.defaults' must be defined and must contain 'light' and 'dark'"
            ));
            return;
          }
          if (defaults.highContrast && typeof defaults.highContrast !== "string") {
            collector.error(localize(
              "invalid.defaults.highContrast",
              "If defined, 'configuration.colors.defaults.highContrast' must be a string."
            ));
            return;
          }
          if (defaults.highContrastLight && typeof defaults.highContrastLight !== "string") {
            collector.error(localize(
              "invalid.defaults.highContrastLight",
              "If defined, 'configuration.colors.defaults.highContrastLight' must be a string."
            ));
            return;
          }
          colorRegistry.registerColor(colorContribution.id, {
            light: parseColorValue(defaults.light, "configuration.colors.defaults.light"),
            dark: parseColorValue(defaults.dark, "configuration.colors.defaults.dark"),
            hcDark: parseColorValue(defaults.highContrast ?? defaults.dark, "configuration.colors.defaults.highContrast"),
            hcLight: parseColorValue(defaults.highContrastLight ?? defaults.light, "configuration.colors.defaults.highContrastLight")
          }, colorContribution.description);
        }
      }
      for (const extension of delta.removed) {
        const extensionValue = extension.value;
        for (const colorContribution of extensionValue) {
          colorRegistry.deregisterColor(colorContribution.id);
        }
      }
    });
  }
};

export {
  ColorExtensionPoint
};
//# sourceMappingURL=chunk-VBXJRYRN.js.map
