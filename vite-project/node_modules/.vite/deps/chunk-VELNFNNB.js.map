{
  "version": 3,
  "sources": ["../../monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js", "../../monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { binarySearch, coalesceInPlace, equals } from '../../../../base/common/arrays.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LRUCache } from '../../../../base/common/map.js';\nimport { commonPrefixLength } from '../../../../base/common/strings.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nexport class TreeElement {\n    remove() {\n        var _a;\n        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.delete(this.id);\n    }\n    static findId(candidate, container) {\n        // complex id-computation which contains the origin/extension,\n        // the parent path, and some dedupe logic when names collide\n        let candidateId;\n        if (typeof candidate === 'string') {\n            candidateId = `${container.id}/${candidate}`;\n        }\n        else {\n            candidateId = `${container.id}/${candidate.name}`;\n            if (container.children.get(candidateId) !== undefined) {\n                candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;\n            }\n        }\n        let id = candidateId;\n        for (let i = 0; container.children.get(id) !== undefined; i++) {\n            id = `${candidateId}_${i}`;\n        }\n        return id;\n    }\n    static getElementById(id, element) {\n        if (!id) {\n            return undefined;\n        }\n        const len = commonPrefixLength(id, element.id);\n        if (len === id.length) {\n            return element;\n        }\n        if (len < element.id.length) {\n            return undefined;\n        }\n        for (const [, child] of element.children) {\n            const candidate = TreeElement.getElementById(id, child);\n            if (candidate) {\n                return candidate;\n            }\n        }\n        return undefined;\n    }\n    static size(element) {\n        let res = 1;\n        for (const [, child] of element.children) {\n            res += TreeElement.size(child);\n        }\n        return res;\n    }\n    static empty(element) {\n        return element.children.size === 0;\n    }\n}\nexport class OutlineElement extends TreeElement {\n    constructor(id, parent, symbol) {\n        super();\n        this.id = id;\n        this.parent = parent;\n        this.symbol = symbol;\n        this.children = new Map();\n    }\n}\nexport class OutlineGroup extends TreeElement {\n    constructor(id, parent, label, order) {\n        super();\n        this.id = id;\n        this.parent = parent;\n        this.label = label;\n        this.order = order;\n        this.children = new Map();\n    }\n    getItemEnclosingPosition(position) {\n        return position ? this._getItemEnclosingPosition(position, this.children) : undefined;\n    }\n    _getItemEnclosingPosition(position, children) {\n        for (const [, item] of children) {\n            if (!item.symbol.range || !Range.containsPosition(item.symbol.range, position)) {\n                continue;\n            }\n            return this._getItemEnclosingPosition(position, item.children) || item;\n        }\n        return undefined;\n    }\n    updateMarker(marker) {\n        for (const [, child] of this.children) {\n            this._updateMarker(marker, child);\n        }\n    }\n    _updateMarker(markers, item) {\n        item.marker = undefined;\n        // find the proper start index to check for item/marker overlap.\n        const idx = binarySearch(markers, item.symbol.range, Range.compareRangesUsingStarts);\n        let start;\n        if (idx < 0) {\n            start = ~idx;\n            if (start > 0 && Range.areIntersecting(markers[start - 1], item.symbol.range)) {\n                start -= 1;\n            }\n        }\n        else {\n            start = idx;\n        }\n        const myMarkers = [];\n        let myTopSev;\n        for (; start < markers.length && Range.areIntersecting(item.symbol.range, markers[start]); start++) {\n            // remove markers intersecting with this outline element\n            // and store them in a 'private' array.\n            const marker = markers[start];\n            myMarkers.push(marker);\n            markers[start] = undefined;\n            if (!myTopSev || marker.severity > myTopSev) {\n                myTopSev = marker.severity;\n            }\n        }\n        // Recurse into children and let them match markers that have matched\n        // this outline element. This might remove markers from this element and\n        // therefore we remember that we have had markers. That allows us to render\n        // the dot, saying 'this element has children with markers'\n        for (const [, child] of item.children) {\n            this._updateMarker(myMarkers, child);\n        }\n        if (myTopSev) {\n            item.marker = {\n                count: myMarkers.length,\n                topSev: myTopSev\n            };\n        }\n        coalesceInPlace(markers);\n    }\n}\nexport class OutlineModel extends TreeElement {\n    static create(registry, textModel, token) {\n        const cts = new CancellationTokenSource(token);\n        const result = new OutlineModel(textModel.uri);\n        const provider = registry.ordered(textModel);\n        const promises = provider.map((provider, index) => {\n            var _a;\n            const id = TreeElement.findId(`provider_${index}`, result);\n            const group = new OutlineGroup(id, result, (_a = provider.displayName) !== null && _a !== void 0 ? _a : 'Unknown Outline Provider', index);\n            return Promise.resolve(provider.provideDocumentSymbols(textModel, cts.token)).then(result => {\n                for (const info of result || []) {\n                    OutlineModel._makeOutlineElement(info, group);\n                }\n                return group;\n            }, err => {\n                onUnexpectedExternalError(err);\n                return group;\n            }).then(group => {\n                if (!TreeElement.empty(group)) {\n                    result._groups.set(id, group);\n                }\n                else {\n                    group.remove();\n                }\n            });\n        });\n        const listener = registry.onDidChange(() => {\n            const newProvider = registry.ordered(textModel);\n            if (!equals(newProvider, provider)) {\n                cts.cancel();\n            }\n        });\n        return Promise.all(promises).then(() => {\n            if (cts.token.isCancellationRequested && !token.isCancellationRequested) {\n                return OutlineModel.create(registry, textModel, token);\n            }\n            else {\n                return result._compact();\n            }\n        }).finally(() => {\n            listener.dispose();\n        });\n    }\n    static _makeOutlineElement(info, container) {\n        const id = TreeElement.findId(info, container);\n        const res = new OutlineElement(id, container, info);\n        if (info.children) {\n            for (const childInfo of info.children) {\n                OutlineModel._makeOutlineElement(childInfo, res);\n            }\n        }\n        container.children.set(res.id, res);\n    }\n    static get(element) {\n        while (element) {\n            if (element instanceof OutlineModel) {\n                return element;\n            }\n            element = element.parent;\n        }\n        return undefined;\n    }\n    constructor(uri) {\n        super();\n        this.uri = uri;\n        this.id = 'root';\n        this.parent = undefined;\n        this._groups = new Map();\n        this.children = new Map();\n        this.id = 'root';\n        this.parent = undefined;\n    }\n    _compact() {\n        let count = 0;\n        for (const [key, group] of this._groups) {\n            if (group.children.size === 0) { // empty\n                this._groups.delete(key);\n            }\n            else {\n                count += 1;\n            }\n        }\n        if (count !== 1) {\n            //\n            this.children = this._groups;\n        }\n        else {\n            // adopt all elements of the first group\n            const group = Iterable.first(this._groups.values());\n            for (const [, child] of group.children) {\n                child.parent = this;\n                this.children.set(child.id, child);\n            }\n        }\n        return this;\n    }\n    merge(other) {\n        if (this.uri.toString() !== other.uri.toString()) {\n            return false;\n        }\n        if (this._groups.size !== other._groups.size) {\n            return false;\n        }\n        this._groups = other._groups;\n        this.children = other.children;\n        return true;\n    }\n    getItemEnclosingPosition(position, context) {\n        let preferredGroup;\n        if (context) {\n            let candidate = context.parent;\n            while (candidate && !preferredGroup) {\n                if (candidate instanceof OutlineGroup) {\n                    preferredGroup = candidate;\n                }\n                candidate = candidate.parent;\n            }\n        }\n        let result = undefined;\n        for (const [, group] of this._groups) {\n            result = group.getItemEnclosingPosition(position);\n            if (result && (!preferredGroup || preferredGroup === group)) {\n                break;\n            }\n        }\n        return result;\n    }\n    getItemById(id) {\n        return TreeElement.getElementById(id, this);\n    }\n    updateMarker(marker) {\n        // sort markers by start range so that we can use\n        // outline element starts for quicker look up\n        marker.sort(Range.compareRangesUsingStarts);\n        for (const [, group] of this._groups) {\n            group.updateMarker(marker.slice(0));\n        }\n    }\n    getTopLevelSymbols() {\n        const roots = [];\n        for (const child of this.children.values()) {\n            if (child instanceof OutlineElement) {\n                roots.push(child.symbol);\n            }\n            else {\n                roots.push(...Iterable.map(child.children.values(), child => child.symbol));\n            }\n        }\n        return roots.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));\n    }\n    asListOfDocumentSymbols() {\n        const roots = this.getTopLevelSymbols();\n        const bucket = [];\n        OutlineModel._flattenDocumentSymbols(bucket, roots, '');\n        return bucket.sort((a, b) => Position.compare(Range.getStartPosition(a.range), Range.getStartPosition(b.range)) || Position.compare(Range.getEndPosition(b.range), Range.getEndPosition(a.range)));\n    }\n    static _flattenDocumentSymbols(bucket, entries, overrideContainerLabel) {\n        for (const entry of entries) {\n            bucket.push({\n                kind: entry.kind,\n                tags: entry.tags,\n                name: entry.name,\n                detail: entry.detail,\n                containerName: entry.containerName || overrideContainerLabel,\n                range: entry.range,\n                selectionRange: entry.selectionRange,\n                children: undefined, // we flatten it...\n            });\n            // Recurse over children\n            if (entry.children) {\n                OutlineModel._flattenDocumentSymbols(bucket, entry.children, entry.name);\n            }\n        }\n    }\n}\nexport const IOutlineModelService = createDecorator('IOutlineModelService');\nlet OutlineModelService = class OutlineModelService {\n    constructor(_languageFeaturesService, debounces, modelService) {\n        this._languageFeaturesService = _languageFeaturesService;\n        this._disposables = new DisposableStore();\n        this._cache = new LRUCache(10, 0.7);\n        this._debounceInformation = debounces.for(_languageFeaturesService.documentSymbolProvider, 'DocumentSymbols', { min: 350 });\n        // don't cache outline models longer than their text model\n        this._disposables.add(modelService.onModelRemoved(textModel => {\n            this._cache.delete(textModel.id);\n        }));\n    }\n    dispose() {\n        this._disposables.dispose();\n    }\n    getOrCreate(textModel, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const registry = this._languageFeaturesService.documentSymbolProvider;\n            const provider = registry.ordered(textModel);\n            let data = this._cache.get(textModel.id);\n            if (!data || data.versionId !== textModel.getVersionId() || !equals(data.provider, provider)) {\n                const source = new CancellationTokenSource();\n                data = {\n                    versionId: textModel.getVersionId(),\n                    provider,\n                    promiseCnt: 0,\n                    source,\n                    promise: OutlineModel.create(registry, textModel, source.token),\n                    model: undefined,\n                };\n                this._cache.set(textModel.id, data);\n                const now = Date.now();\n                data.promise.then(outlineModel => {\n                    data.model = outlineModel;\n                    this._debounceInformation.update(textModel, Date.now() - now);\n                }).catch(_err => {\n                    this._cache.delete(textModel.id);\n                });\n            }\n            if (data.model) {\n                // resolved -> return data\n                return data.model;\n            }\n            // increase usage counter\n            data.promiseCnt += 1;\n            const listener = token.onCancellationRequested(() => {\n                // last -> cancel provider request, remove cached promise\n                if (--data.promiseCnt === 0) {\n                    data.source.cancel();\n                    this._cache.delete(textModel.id);\n                }\n            });\n            try {\n                return yield data.promise;\n            }\n            finally {\n                listener.dispose();\n            }\n        });\n    }\n    getDebounceValue(textModel) {\n        return this._debounceInformation.get(textModel);\n    }\n};\nOutlineModelService = __decorate([\n    __param(0, ILanguageFeaturesService),\n    __param(1, ILanguageFeatureDebounceService),\n    __param(2, IModelService)\n], OutlineModelService);\nexport { OutlineModelService };\nregisterSingleton(IOutlineModelService, OutlineModelService, 1 /* InstantiationType.Delayed */);\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        // flip bytes 0<->3 and 1<->2\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nfunction fromLittleEndianBuffer(buff) {\n    const uint8Arr = buff.buffer;\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    if (uint8Arr.byteOffset % 4 === 0) {\n        return new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);\n    }\n    else {\n        // unaligned memory access doesn't work on all platforms\n        const data = new Uint8Array(uint8Arr.byteLength);\n        data.set(uint8Arr);\n        return new Uint32Array(data.buffer, data.byteOffset, data.length / 4);\n    }\n}\nexport function encodeSemanticTokensDto(semanticTokens) {\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 /* EncodedSemanticTokensType.Full */;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 /* EncodedSemanticTokensType.Delta */;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += (+1 // id\n        + 1 // type\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1 // data length\n            + semanticTokens.data.length);\n    }\n    else {\n        result += (+1 // delta count\n        );\n        result += (+1 // start\n            + 1 // deleteCount\n            + 1 // data length\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\nexport function decodeSemanticTokensDto(_buff) {\n    const src = fromLittleEndianBuffer(_buff);\n    let offset = 0;\n    const id = src[offset++];\n    const type = src[offset++];\n    if (type === 1 /* EncodedSemanticTokensType.Full */) {\n        const length = src[offset++];\n        const data = src.subarray(offset, offset + length);\n        offset += length;\n        return {\n            id: id,\n            type: 'full',\n            data: data\n        };\n    }\n    const deltaCount = src[offset++];\n    const deltas = [];\n    for (let i = 0; i < deltaCount; i++) {\n        const start = src[offset++];\n        const deleteCount = src[offset++];\n        const length = src[offset++];\n        let data;\n        if (length > 0) {\n            data = src.subarray(offset, offset + length);\n            offset += length;\n        }\n        deltas[i] = { start, deleteCount, data };\n    }\n    return {\n        id: id,\n        type: 'delta',\n        deltas: deltas\n    };\n}\n"],
  "mappings": "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",
  "names": ["provider", "result", "group", "child", "OutlineModelService"]
}
