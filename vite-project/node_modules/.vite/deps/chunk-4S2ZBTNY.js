import {
  DataTransfers,
  DeferredPromise,
  EditorWorkerClient,
  IDialogService,
  Registry,
  extractSelection,
  init_async,
  init_extensions,
  init_opener,
  init_platform as init_platform2,
  parse,
  registerSingleton
} from "./chunk-Z3Z4BZM7.js";
import {
  ByteSize,
  Disposable,
  Event,
  FileSystemProviderError,
  FileSystemProviderErrorCode,
  FileType,
  IFileService,
  IInstantiationService,
  Iterable,
  ResourceMap,
  Schemas,
  URI,
  VSBuffer,
  basename,
  coalesce,
  containsUppercaseCharacter,
  createDecorator,
  createFileSystemProviderError,
  distinct,
  extUri,
  extUriIgnorePathCase,
  extname,
  generateUuid,
  getAllMethodNames,
  init_arrays,
  init_buffer,
  init_event,
  init_files,
  init_instantiation,
  init_iterator,
  init_lifecycle,
  init_map,
  init_network,
  init_nls,
  init_objects,
  init_path,
  init_platform,
  init_resources,
  init_stream,
  init_strings,
  init_uri,
  init_uuid,
  isLinux,
  isWeb,
  localize,
  newWriteableStream,
  normalize
} from "./chunk-N5MAMNNV.js";

// node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDnd.js
var TreeViewsDnDService = class {
  constructor() {
    this._dragOperations = /* @__PURE__ */ new Map();
  }
  removeDragOperationTransfer(uuid) {
    if (uuid && this._dragOperations.has(uuid)) {
      const operation = this._dragOperations.get(uuid);
      this._dragOperations.delete(uuid);
      return operation;
    }
    return void 0;
  }
  addDragOperationTransfer(uuid, transferPromise) {
    this._dragOperations.set(uuid, transferPromise);
  }
};
var DraggedTreeItemsIdentifier = class {
  constructor(identifier) {
    this.identifier = identifier;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js
init_extensions();
init_instantiation();
var ITreeViewsDnDService = createDecorator("treeViewsDndService");
registerSingleton(
  ITreeViewsDnDService,
  TreeViewsDnDService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/platform/files/browser/htmlFileSystemProvider.js
init_nls();
init_uri();
init_buffer();
init_event();
init_lifecycle();
init_network();
init_path();
init_platform();
init_resources();
init_stream();
init_files();

// node_modules/monaco-editor/esm/vs/platform/files/browser/webFileSystemAccess.js
var WebFileSystemAccess;
(function(WebFileSystemAccess2) {
  function supported(obj) {
    if (typeof (obj === null || obj === void 0 ? void 0 : obj.showDirectoryPicker) === "function") {
      return true;
    }
    return false;
  }
  WebFileSystemAccess2.supported = supported;
  function isFileSystemHandle(handle) {
    const candidate = handle;
    if (!candidate) {
      return false;
    }
    return typeof candidate.kind === "string" && typeof candidate.queryPermission === "function" && typeof candidate.requestPermission === "function";
  }
  WebFileSystemAccess2.isFileSystemHandle = isFileSystemHandle;
  function isFileSystemFileHandle(handle) {
    return handle.kind === "file";
  }
  WebFileSystemAccess2.isFileSystemFileHandle = isFileSystemFileHandle;
  function isFileSystemDirectoryHandle(handle) {
    return handle.kind === "directory";
  }
  WebFileSystemAccess2.isFileSystemDirectoryHandle = isFileSystemDirectoryHandle;
})(WebFileSystemAccess || (WebFileSystemAccess = {}));

// node_modules/monaco-editor/esm/vs/platform/files/browser/htmlFileSystemProvider.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var HTMLFileSystemProvider = class {
  get capabilities() {
    if (!this._capabilities) {
      this._capabilities = 2 | 16;
      if (isLinux) {
        this._capabilities |= 1024;
      }
    }
    return this._capabilities;
  }
  //#endregion
  constructor(indexedDB, store, logService) {
    this.indexedDB = indexedDB;
    this.store = store;
    this.logService = logService;
    this.onDidChangeCapabilities = Event.None;
    this.onDidChangeFile = Event.None;
    this.extUri = isLinux ? extUri : extUriIgnorePathCase;
    this._files = /* @__PURE__ */ new Map();
    this._directories = /* @__PURE__ */ new Map();
  }
  //#region File Metadata Resolving
  stat(resource) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const handle = yield this.getHandle(resource);
        if (!handle) {
          throw this.createFileSystemProviderError(resource, "No such file or directory, stat", FileSystemProviderErrorCode.FileNotFound);
        }
        if (WebFileSystemAccess.isFileSystemFileHandle(handle)) {
          const file = yield handle.getFile();
          return {
            type: FileType.File,
            mtime: file.lastModified,
            ctime: 0,
            size: file.size
          };
        }
        return {
          type: FileType.Directory,
          mtime: 0,
          ctime: 0,
          size: 0
        };
      } catch (error) {
        throw this.toFileSystemProviderError(error);
      }
    });
  }
  readdir(resource) {
    var _a, e_1, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const handle = yield this.getDirectoryHandle(resource);
        if (!handle) {
          throw this.createFileSystemProviderError(resource, "No such file or directory, readdir", FileSystemProviderErrorCode.FileNotFound);
        }
        const result = [];
        try {
          for (var _d = true, handle_1 = __asyncValues(handle), handle_1_1; handle_1_1 = yield handle_1.next(), _a = handle_1_1.done, !_a; _d = true) {
            _c = handle_1_1.value;
            _d = false;
            const [name, child] = _c;
            result.push([name, WebFileSystemAccess.isFileSystemFileHandle(child) ? FileType.File : FileType.Directory]);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = handle_1.return))
              yield _b.call(handle_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result;
      } catch (error) {
        throw this.toFileSystemProviderError(error);
      }
    });
  }
  //#endregion
  //#region File Reading/Writing
  readFileStream(resource, opts, token) {
    const stream = newWriteableStream((data) => VSBuffer.concat(data.map((data2) => VSBuffer.wrap(data2))).buffer, {
      // Set a highWaterMark to prevent the stream
      // for file upload to produce large buffers
      // in-memory
      highWaterMark: 10
    });
    (() => __awaiter(this, void 0, void 0, function* () {
      try {
        const handle = yield this.getFileHandle(resource);
        if (!handle) {
          throw this.createFileSystemProviderError(resource, "No such file or directory, readFile", FileSystemProviderErrorCode.FileNotFound);
        }
        const file = yield handle.getFile();
        if (typeof opts.length === "number" || typeof opts.position === "number") {
          let buffer = new Uint8Array(yield file.arrayBuffer());
          if (typeof (opts === null || opts === void 0 ? void 0 : opts.position) === "number") {
            buffer = buffer.slice(opts.position);
          }
          if (typeof (opts === null || opts === void 0 ? void 0 : opts.length) === "number") {
            buffer = buffer.slice(0, opts.length);
          }
          stream.end(buffer);
        } else {
          const reader = file.stream().getReader();
          let res = yield reader.read();
          while (!res.done) {
            if (token.isCancellationRequested) {
              break;
            }
            yield stream.write(res.value);
            if (token.isCancellationRequested) {
              break;
            }
            res = yield reader.read();
          }
          stream.end(void 0);
        }
      } catch (error) {
        stream.error(this.toFileSystemProviderError(error));
        stream.end();
      }
    }))();
    return stream;
  }
  readFile(resource) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const handle = yield this.getFileHandle(resource);
        if (!handle) {
          throw this.createFileSystemProviderError(resource, "No such file or directory, readFile", FileSystemProviderErrorCode.FileNotFound);
        }
        const file = yield handle.getFile();
        return new Uint8Array(yield file.arrayBuffer());
      } catch (error) {
        throw this.toFileSystemProviderError(error);
      }
    });
  }
  writeFile(resource, content, opts) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let handle = yield this.getFileHandle(resource);
        if (!opts.create || !opts.overwrite) {
          if (handle) {
            if (!opts.overwrite) {
              throw this.createFileSystemProviderError(resource, "File already exists, writeFile", FileSystemProviderErrorCode.FileExists);
            }
          } else {
            if (!opts.create) {
              throw this.createFileSystemProviderError(resource, "No such file, writeFile", FileSystemProviderErrorCode.FileNotFound);
            }
          }
        }
        if (!handle) {
          const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
          if (!parent) {
            throw this.createFileSystemProviderError(resource, "No such parent directory, writeFile", FileSystemProviderErrorCode.FileNotFound);
          }
          handle = yield parent.getFileHandle(this.extUri.basename(resource), { create: true });
          if (!handle) {
            throw this.createFileSystemProviderError(resource, "Unable to create file , writeFile", FileSystemProviderErrorCode.Unknown);
          }
        }
        const writable = yield handle.createWritable();
        yield writable.write(content);
        yield writable.close();
      } catch (error) {
        throw this.toFileSystemProviderError(error);
      }
    });
  }
  //#endregion
  //#region Move/Copy/Delete/Create Folder
  mkdir(resource) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
        if (!parent) {
          throw this.createFileSystemProviderError(resource, "No such parent directory, mkdir", FileSystemProviderErrorCode.FileNotFound);
        }
        yield parent.getDirectoryHandle(this.extUri.basename(resource), { create: true });
      } catch (error) {
        throw this.toFileSystemProviderError(error);
      }
    });
  }
  delete(resource, opts) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
        if (!parent) {
          throw this.createFileSystemProviderError(resource, "No such parent directory, delete", FileSystemProviderErrorCode.FileNotFound);
        }
        return parent.removeEntry(this.extUri.basename(resource), { recursive: opts.recursive });
      } catch (error) {
        throw this.toFileSystemProviderError(error);
      }
    });
  }
  rename(from, to, opts) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (this.extUri.isEqual(from, to)) {
          return;
        }
        const fileHandle = yield this.getFileHandle(from);
        if (fileHandle) {
          const file = yield fileHandle.getFile();
          const contents = new Uint8Array(yield file.arrayBuffer());
          yield this.writeFile(to, contents, { create: true, overwrite: opts.overwrite, unlock: false, atomic: false });
          yield this.delete(from, { recursive: false, useTrash: false, atomic: false });
        } else {
          throw this.createFileSystemProviderError(from, localize("fileSystemRenameError", "Rename is only supported for files."), FileSystemProviderErrorCode.Unavailable);
        }
      } catch (error) {
        throw this.toFileSystemProviderError(error);
      }
    });
  }
  //#endregion
  //#region File Watching (unsupported)
  watch(resource, opts) {
    return Disposable.None;
  }
  registerFileHandle(handle) {
    return this.registerHandle(handle, this._files);
  }
  registerDirectoryHandle(handle) {
    return this.registerHandle(handle, this._directories);
  }
  get directories() {
    return this._directories.values();
  }
  registerHandle(handle, map) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
      let handleId = `/${handle.name}`;
      if (map.has(handleId) && !(yield (_a = map.get(handleId)) === null || _a === void 0 ? void 0 : _a.isSameEntry(handle))) {
        const fileExt = extname(handle.name);
        const fileName = basename(handle.name, fileExt);
        let handleIdCounter = 1;
        do {
          handleId = `/${fileName}-${handleIdCounter++}${fileExt}`;
        } while (map.has(handleId) && !(yield (_b = map.get(handleId)) === null || _b === void 0 ? void 0 : _b.isSameEntry(handle)));
      }
      map.set(handleId, handle);
      try {
        yield (_c = this.indexedDB) === null || _c === void 0 ? void 0 : _c.runInTransaction(this.store, "readwrite", (objectStore) => objectStore.put(handle, handleId));
      } catch (error) {
        this.logService.error(error);
      }
      return URI.from({ scheme: Schemas.file, path: handleId });
    });
  }
  getHandle(resource) {
    return __awaiter(this, void 0, void 0, function* () {
      let handle = yield this.doGetHandle(resource);
      if (!handle) {
        const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
        if (parent) {
          const name = extUri.basename(resource);
          try {
            handle = yield parent.getFileHandle(name);
          } catch (error) {
            try {
              handle = yield parent.getDirectoryHandle(name);
            } catch (error2) {
            }
          }
        }
      }
      return handle;
    });
  }
  getFileHandle(resource) {
    return __awaiter(this, void 0, void 0, function* () {
      const handle = yield this.doGetHandle(resource);
      if (handle instanceof FileSystemFileHandle) {
        return handle;
      }
      const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
      try {
        return yield parent === null || parent === void 0 ? void 0 : parent.getFileHandle(extUri.basename(resource));
      } catch (error) {
        return void 0;
      }
    });
  }
  getDirectoryHandle(resource) {
    return __awaiter(this, void 0, void 0, function* () {
      const handle = yield this.doGetHandle(resource);
      if (handle instanceof FileSystemDirectoryHandle) {
        return handle;
      }
      const parentUri = this.extUri.dirname(resource);
      if (this.extUri.isEqual(parentUri, resource)) {
        return void 0;
      }
      const parent = yield this.getDirectoryHandle(parentUri);
      try {
        return yield parent === null || parent === void 0 ? void 0 : parent.getDirectoryHandle(extUri.basename(resource));
      } catch (error) {
        return void 0;
      }
    });
  }
  doGetHandle(resource) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.extUri.dirname(resource).path !== "/") {
        return void 0;
      }
      const handleId = resource.path.replace(/\/$/, "");
      const inMemoryHandle = (_a = this._files.get(handleId)) !== null && _a !== void 0 ? _a : this._directories.get(handleId);
      if (inMemoryHandle) {
        return inMemoryHandle;
      }
      const persistedHandle = yield (_b = this.indexedDB) === null || _b === void 0 ? void 0 : _b.runInTransaction(this.store, "readonly", (store) => store.get(handleId));
      if (WebFileSystemAccess.isFileSystemHandle(persistedHandle)) {
        let hasPermissions = (yield persistedHandle.queryPermission()) === "granted";
        try {
          if (!hasPermissions) {
            hasPermissions = (yield persistedHandle.requestPermission()) === "granted";
          }
        } catch (error) {
          this.logService.error(error);
        }
        if (hasPermissions) {
          if (WebFileSystemAccess.isFileSystemFileHandle(persistedHandle)) {
            this._files.set(handleId, persistedHandle);
          } else if (WebFileSystemAccess.isFileSystemDirectoryHandle(persistedHandle)) {
            this._directories.set(handleId, persistedHandle);
          }
          return persistedHandle;
        }
      }
      throw this.createFileSystemProviderError(resource, "No file system handle registered", FileSystemProviderErrorCode.Unavailable);
    });
  }
  //#endregion
  toFileSystemProviderError(error) {
    if (error instanceof FileSystemProviderError) {
      return error;
    }
    let code = FileSystemProviderErrorCode.Unknown;
    if (error.name === "NotAllowedError") {
      error = new Error(localize("fileSystemNotAllowedError", "Insufficient permissions. Please retry and allow the operation."));
      code = FileSystemProviderErrorCode.Unavailable;
    }
    return createFileSystemProviderError(error, code);
  }
  createFileSystemProviderError(resource, msg, code) {
    return createFileSystemProviderError(new Error(`${msg} (${normalize(resource.path)})`), code);
  }
};

// node_modules/monaco-editor/esm/vs/base/common/dataTransfer.js
init_arrays();
init_iterator();
init_uuid();
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function createStringDataTransferItem(stringOrPromise) {
  return {
    asString: () => __awaiter2(this, void 0, void 0, function* () {
      return stringOrPromise;
    }),
    asFile: () => void 0,
    value: typeof stringOrPromise === "string" ? stringOrPromise : void 0
  };
}
function createFileDataTransferItem(fileName, uri, data) {
  const file = { id: generateUuid(), name: fileName, uri, data };
  return {
    asString: () => __awaiter2(this, void 0, void 0, function* () {
      return "";
    }),
    asFile: () => file,
    value: void 0
  };
}
var VSDataTransfer = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  get size() {
    let size = 0;
    for (const _ of this._entries) {
      size++;
    }
    return size;
  }
  has(mimeType) {
    return this._entries.has(this.toKey(mimeType));
  }
  matches(pattern) {
    const mimes = [...this._entries.keys()];
    if (Iterable.some(this, ([_, item]) => item.asFile())) {
      mimes.push("files");
    }
    return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);
  }
  get(mimeType) {
    var _a;
    return (_a = this._entries.get(this.toKey(mimeType))) === null || _a === void 0 ? void 0 : _a[0];
  }
  /**
   * Add a new entry to this data transfer.
   *
   * This does not replace existing entries for `mimeType`.
   */
  append(mimeType, value) {
    const existing = this._entries.get(mimeType);
    if (existing) {
      existing.push(value);
    } else {
      this._entries.set(this.toKey(mimeType), [value]);
    }
  }
  /**
   * Set the entry for a given mime type.
   *
   * This replaces all existing entries for `mimeType`.
   */
  replace(mimeType, value) {
    this._entries.set(this.toKey(mimeType), [value]);
  }
  /**
   * Remove all entries for `mimeType`.
   */
  delete(mimeType) {
    this._entries.delete(this.toKey(mimeType));
  }
  /**
   * Iterate over all `[mime, item]` pairs in this data transfer.
   *
   * There may be multiple entries for each mime type.
   */
  *[Symbol.iterator]() {
    for (const [mine, items] of this._entries) {
      for (const item of items) {
        yield [mine, item];
      }
    }
  }
  toKey(mimeType) {
    return normalizeMimeType(mimeType);
  }
};
function normalizeMimeType(mimeType) {
  return mimeType.toLowerCase();
}
function matchesMimeType(pattern, mimeTypes) {
  return matchesMimeType_normalized(normalizeMimeType(pattern), mimeTypes.map(normalizeMimeType));
}
function matchesMimeType_normalized(normalizedPattern, normalizedMimeTypes) {
  if (normalizedPattern === "*/*") {
    return normalizedMimeTypes.length > 0;
  }
  if (normalizedMimeTypes.includes(normalizedPattern)) {
    return true;
  }
  const wildcard = normalizedPattern.match(/^([a-z]+)\/([a-z]+|\*)$/i);
  if (!wildcard) {
    return false;
  }
  const [_, type, subtype] = wildcard;
  if (subtype === "*") {
    return normalizedMimeTypes.some((mime) => mime.startsWith(type + "/"));
  }
  return false;
}
var UriList = Object.freeze({
  // http://amundsen.com/hypermedia/urilist/
  create: (entries) => {
    return distinct(entries.map((x) => x.toString())).join("\r\n");
  },
  split: (str) => {
    return str.split("\r\n");
  },
  parse: (str) => {
    return UriList.split(str).filter((value) => !value.startsWith("#"));
  }
});

// node_modules/monaco-editor/esm/vs/editor/browser/services/webWorker.js
init_objects();
function createWebWorker(modelService, languageConfigurationService, opts) {
  return new MonacoWebWorkerImpl(modelService, languageConfigurationService, opts);
}
var MonacoWebWorkerImpl = class extends EditorWorkerClient {
  constructor(modelService, languageConfigurationService, opts) {
    super(modelService, opts.keepIdleModels || false, opts.label, languageConfigurationService);
    this._foreignModuleId = opts.moduleId;
    this._foreignModuleCreateData = opts.createData || null;
    this._foreignModuleHost = opts.host || null;
    this._foreignProxy = null;
  }
  // foreign host request
  fhr(method, args) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== "function") {
      return Promise.reject(new Error("Missing method " + method + " or missing main thread foreign host."));
    }
    try {
      return Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  _getForeignProxy() {
    if (!this._foreignProxy) {
      this._foreignProxy = this._getProxy().then((proxy) => {
        const foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];
        return proxy.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {
          this._foreignModuleCreateData = null;
          const proxyMethodRequest = (method, args) => {
            return proxy.fmr(method, args);
          };
          const createProxyMethod = (method, proxyMethodRequest2) => {
            return function() {
              const args = Array.prototype.slice.call(arguments, 0);
              return proxyMethodRequest2(method, args);
            };
          };
          const foreignProxy = {};
          for (const foreignMethod of foreignMethods) {
            foreignProxy[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);
          }
          return foreignProxy;
        });
      });
    }
    return this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(resources) {
    return this._withSyncedResources(resources).then((_) => this.getProxy());
  }
};

// node_modules/monaco-editor/esm/vs/base/common/search.js
init_strings();
function buildReplaceStringWithCasePreserved(matches, pattern) {
  if (matches && matches[0] !== "") {
    const containsHyphens = validateSpecificSpecialCharacter(matches, pattern, "-");
    const containsUnderscores = validateSpecificSpecialCharacter(matches, pattern, "_");
    if (containsHyphens && !containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "-");
    } else if (!containsHyphens && containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "_");
    }
    if (matches[0].toUpperCase() === matches[0]) {
      return pattern.toUpperCase();
    } else if (matches[0].toLowerCase() === matches[0]) {
      return pattern.toLowerCase();
    } else if (containsUppercaseCharacter(matches[0][0]) && pattern.length > 0) {
      return pattern[0].toUpperCase() + pattern.substr(1);
    } else if (matches[0][0].toUpperCase() !== matches[0][0] && pattern.length > 0) {
      return pattern[0].toLowerCase() + pattern.substr(1);
    } else {
      return pattern;
    }
  } else {
    return pattern;
  }
}
function validateSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const doesContainSpecialCharacter = matches[0].indexOf(specialCharacter) !== -1 && pattern.indexOf(specialCharacter) !== -1;
  return doesContainSpecialCharacter && matches[0].split(specialCharacter).length === pattern.split(specialCharacter).length;
}
function buildReplaceStringForSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const splitPatternAtSpecialCharacter = pattern.split(specialCharacter);
  const splitMatchAtSpecialCharacter = matches[0].split(specialCharacter);
  let replaceString = "";
  splitPatternAtSpecialCharacter.forEach((splitValue, index) => {
    replaceString += buildReplaceStringWithCasePreserved([splitMatchAtSpecialCharacter[index]], splitValue) + specialCharacter;
  });
  return replaceString.slice(0, -1);
}

// node_modules/monaco-editor/esm/vs/platform/history/browser/historyWidgetKeybindingHint.js
function showHistoryKeybindingHint(keybindingService) {
  var _a, _b;
  return ((_a = keybindingService.lookupKeybinding("history.showPrevious")) === null || _a === void 0 ? void 0 : _a.getElectronAccelerator()) === "Up" && ((_b = keybindingService.lookupKeybinding("history.showNext")) === null || _b === void 0 ? void 0 : _b.getElectronAccelerator()) === "Down";
}

// node_modules/monaco-editor/esm/vs/platform/dnd/browser/dnd.js
init_arrays();
init_async();
init_buffer();
init_map();
init_network();
init_platform();
init_uri();
init_nls();
init_files();
init_instantiation();
init_opener();
init_platform2();
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeDataTransfers = {
  EDITORS: "CodeEditors",
  FILES: "CodeFiles"
};
function extractEditorsDropData(e) {
  var _a;
  const editors = [];
  if (e.dataTransfer && e.dataTransfer.types.length > 0) {
    const rawEditorsData = e.dataTransfer.getData(CodeDataTransfers.EDITORS);
    if (rawEditorsData) {
      try {
        editors.push(...parse(rawEditorsData));
      } catch (error) {
      }
    } else {
      try {
        const rawResourcesData = e.dataTransfer.getData(DataTransfers.RESOURCES);
        editors.push(...createDraggedEditorInputFromRawResourcesData(rawResourcesData));
      } catch (error) {
      }
    }
    if ((_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.files) {
      for (let i = 0; i < e.dataTransfer.files.length; i++) {
        const file = e.dataTransfer.files[i];
        if (file && file.path) {
          try {
            editors.push({ resource: URI.file(file.path), isExternal: true, allowWorkspaceOpen: true });
          } catch (error) {
          }
        }
      }
    }
    const rawCodeFiles = e.dataTransfer.getData(CodeDataTransfers.FILES);
    if (rawCodeFiles) {
      try {
        const codeFiles = JSON.parse(rawCodeFiles);
        for (const codeFile of codeFiles) {
          editors.push({ resource: URI.file(codeFile), isExternal: true, allowWorkspaceOpen: true });
        }
      } catch (error) {
      }
    }
    const contributions = Registry.as(Extensions.DragAndDropContribution).getAll();
    for (const contribution of contributions) {
      const data = e.dataTransfer.getData(contribution.dataFormatKey);
      if (data) {
        try {
          editors.push(...contribution.getEditorInputs(data));
        } catch (error) {
        }
      }
    }
  }
  const coalescedEditors = [];
  const seen = new ResourceMap();
  for (const editor of editors) {
    if (!editor.resource) {
      coalescedEditors.push(editor);
    } else if (!seen.has(editor.resource)) {
      coalescedEditors.push(editor);
      seen.set(editor.resource, true);
    }
  }
  return coalescedEditors;
}
function extractEditorsAndFilesDropData(accessor, e) {
  var _a;
  return __awaiter3(this, void 0, void 0, function* () {
    const editors = extractEditorsDropData(e);
    if (e.dataTransfer && isWeb && containsDragType(e, DataTransfers.FILES)) {
      const files = e.dataTransfer.items;
      if (files) {
        const instantiationService = accessor.get(IInstantiationService);
        const filesData = yield instantiationService.invokeFunction((accessor2) => extractFilesDropData(accessor2, e));
        for (const fileData of filesData) {
          editors.push({ resource: fileData.resource, contents: (_a = fileData.contents) === null || _a === void 0 ? void 0 : _a.toString(), isExternal: true, allowWorkspaceOpen: fileData.isDirectory });
        }
      }
    }
    return editors;
  });
}
function createDraggedEditorInputFromRawResourcesData(rawResourcesData) {
  const editors = [];
  if (rawResourcesData) {
    const resourcesRaw = JSON.parse(rawResourcesData);
    for (const resourceRaw of resourcesRaw) {
      if (resourceRaw.indexOf(":") > 0) {
        const { selection, uri } = extractSelection(URI.parse(resourceRaw));
        editors.push({ resource: uri, options: { selection } });
      }
    }
  }
  return editors;
}
function extractFilesDropData(accessor, event) {
  var _a, _b;
  return __awaiter3(this, void 0, void 0, function* () {
    if (WebFileSystemAccess.supported(window)) {
      const items = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.items;
      if (items) {
        return extractFileTransferData(accessor, items);
      }
    }
    const files = (_b = event.dataTransfer) === null || _b === void 0 ? void 0 : _b.files;
    if (!files) {
      return [];
    }
    return extractFileListData(accessor, files);
  });
}
function extractFileTransferData(accessor, items) {
  return __awaiter3(this, void 0, void 0, function* () {
    const fileSystemProvider = accessor.get(IFileService).getProvider(Schemas.file);
    if (!(fileSystemProvider instanceof HTMLFileSystemProvider)) {
      return [];
    }
    const results = [];
    for (let i = 0; i < items.length; i++) {
      const file = items[i];
      if (file) {
        const result = new DeferredPromise();
        results.push(result);
        (() => __awaiter3(this, void 0, void 0, function* () {
          try {
            const handle = yield file.getAsFileSystemHandle();
            if (!handle) {
              result.complete(void 0);
              return;
            }
            if (WebFileSystemAccess.isFileSystemFileHandle(handle)) {
              result.complete({
                resource: yield fileSystemProvider.registerFileHandle(handle),
                isDirectory: false
              });
            } else if (WebFileSystemAccess.isFileSystemDirectoryHandle(handle)) {
              result.complete({
                resource: yield fileSystemProvider.registerDirectoryHandle(handle),
                isDirectory: true
              });
            } else {
              result.complete(void 0);
            }
          } catch (error) {
            result.complete(void 0);
          }
        }))();
      }
    }
    return coalesce(yield Promise.all(results.map((result) => result.p)));
  });
}
function extractFileListData(accessor, files) {
  return __awaiter3(this, void 0, void 0, function* () {
    const dialogService = accessor.get(IDialogService);
    const results = [];
    for (let i = 0; i < files.length; i++) {
      const file = files.item(i);
      if (file) {
        if (file.size > 100 * ByteSize.MB) {
          dialogService.warn(localize("fileTooLarge", "File is too large to open as untitled editor. Please upload it first into the file explorer and then try again."));
          continue;
        }
        const result = new DeferredPromise();
        results.push(result);
        const reader = new FileReader();
        reader.onerror = () => result.complete(void 0);
        reader.onabort = () => result.complete(void 0);
        reader.onload = (event) => __awaiter3(this, void 0, void 0, function* () {
          var _a, _b;
          const name = file.name;
          const loadResult = (_b = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result) !== null && _b !== void 0 ? _b : void 0;
          if (typeof name !== "string" || typeof loadResult === "undefined") {
            result.complete(void 0);
            return;
          }
          result.complete({
            resource: URI.from({ scheme: Schemas.untitled, path: name }),
            contents: typeof loadResult === "string" ? VSBuffer.fromString(loadResult) : VSBuffer.wrap(new Uint8Array(loadResult))
          });
        });
        reader.readAsArrayBuffer(file);
      }
    }
    return coalesce(yield Promise.all(results.map((result) => result.p)));
  });
}
function containsDragType(event, ...dragTypesToFind) {
  if (!event.dataTransfer) {
    return false;
  }
  const dragTypes = event.dataTransfer.types;
  const lowercaseDragTypes = [];
  for (let i = 0; i < dragTypes.length; i++) {
    lowercaseDragTypes.push(dragTypes[i].toLowerCase());
  }
  for (const dragType of dragTypesToFind) {
    if (lowercaseDragTypes.indexOf(dragType.toLowerCase()) >= 0) {
      return true;
    }
  }
  return false;
}
var DragAndDropContributionRegistry = class {
  constructor() {
    this._contributions = /* @__PURE__ */ new Map();
  }
  register(contribution) {
    if (this._contributions.has(contribution.dataFormatKey)) {
      throw new Error(`A drag and drop contributiont with key '${contribution.dataFormatKey}' was already registered.`);
    }
    this._contributions.set(contribution.dataFormatKey, contribution);
  }
  getAll() {
    return this._contributions.values();
  }
};
var Extensions = {
  DragAndDropContribution: "workbench.contributions.dragAndDrop"
};
Registry.add(Extensions.DragAndDropContribution, new DragAndDropContributionRegistry());
var LocalSelectionTransfer = class _LocalSelectionTransfer {
  constructor() {
  }
  static getInstance() {
    return _LocalSelectionTransfer.INSTANCE;
  }
  hasData(proto) {
    return proto && proto === this.proto;
  }
  clearData(proto) {
    if (this.hasData(proto)) {
      this.proto = void 0;
      this.data = void 0;
    }
  }
  getData(proto) {
    if (this.hasData(proto)) {
      return this.data;
    }
    return void 0;
  }
  setData(data, proto) {
    if (proto) {
      this.data = data;
      this.proto = proto;
    }
  }
};
LocalSelectionTransfer.INSTANCE = new LocalSelectionTransfer();

export {
  createStringDataTransferItem,
  createFileDataTransferItem,
  VSDataTransfer,
  matchesMimeType,
  UriList,
  TreeViewsDnDService,
  DraggedTreeItemsIdentifier,
  createWebWorker,
  ITreeViewsDnDService,
  buildReplaceStringWithCasePreserved,
  showHistoryKeybindingHint,
  WebFileSystemAccess,
  CodeDataTransfers,
  extractEditorsAndFilesDropData,
  containsDragType,
  Extensions,
  LocalSelectionTransfer
};
//# sourceMappingURL=chunk-4S2ZBTNY.js.map
