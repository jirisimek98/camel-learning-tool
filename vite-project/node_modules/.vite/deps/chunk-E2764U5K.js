import {
  ErrorNoTelemetry,
  RawContextKey,
  Schemas,
  VSBuffer,
  createDecorator,
  decodeBase64,
  encodeBase64,
  init_buffer,
  init_contextkey,
  init_errors,
  init_instantiation,
  init_network,
  init_nls,
  localize
} from "./chunk-N5MAMNNV.js";
import {
  __esm
} from "./chunk-PGWBAY6J.js";

// node_modules/vscode/vscode/src/vs/workbench/contrib/debug/common/debug.js
var REPL_VIEW_ID, CONTEXT_DEBUG_TYPE, CONTEXT_DEBUG_CONFIGURATION_TYPE, CONTEXT_DEBUG_STATE, CONTEXT_DEBUG_UX_KEY, CONTEXT_DEBUG_UX, CONTEXT_HAS_DEBUGGED, CONTEXT_IN_DEBUG_MODE, CONTEXT_IN_DEBUG_REPL, CONTEXT_BREAKPOINT_WIDGET_VISIBLE, CONTEXT_IN_BREAKPOINT_WIDGET, CONTEXT_BREAKPOINTS_FOCUSED, CONTEXT_WATCH_EXPRESSIONS_FOCUSED, CONTEXT_WATCH_EXPRESSIONS_EXIST, CONTEXT_VARIABLES_FOCUSED, CONTEXT_EXPRESSION_SELECTED, CONTEXT_BREAKPOINT_INPUT_FOCUSED, CONTEXT_CALLSTACK_ITEM_TYPE, CONTEXT_CALLSTACK_SESSION_IS_ATTACH, CONTEXT_CALLSTACK_ITEM_STOPPED, CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD, CONTEXT_WATCH_ITEM_TYPE, CONTEXT_CAN_VIEW_MEMORY, CONTEXT_BREAKPOINT_ITEM_TYPE, CONTEXT_BREAKPOINT_SUPPORTS_CONDITION, CONTEXT_LOADED_SCRIPTS_SUPPORTED, CONTEXT_LOADED_SCRIPTS_ITEM_TYPE, CONTEXT_FOCUSED_SESSION_IS_ATTACH, CONTEXT_STEP_BACK_SUPPORTED, CONTEXT_RESTART_FRAME_SUPPORTED, CONTEXT_STACK_FRAME_SUPPORTS_RESTART, CONTEXT_JUMP_TO_CURSOR_SUPPORTED, CONTEXT_STEP_INTO_TARGETS_SUPPORTED, CONTEXT_BREAKPOINTS_EXIST, CONTEXT_DEBUGGERS_AVAILABLE, CONTEXT_DEBUG_EXTENSION_AVAILABLE, CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT, CONTEXT_SET_VARIABLE_SUPPORTED, CONTEXT_SET_EXPRESSION_SUPPORTED, CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED, CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED, CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED, CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED, CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED, CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT, CONTEXT_VARIABLE_IS_READONLY, CONTEXT_EXCEPTION_WIDGET_VISIBLE, CONTEXT_MULTI_SESSION_REPL, CONTEXT_MULTI_SESSION_DEBUG, CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED, CONTEXT_DISASSEMBLY_VIEW_FOCUS, CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST, CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE, INTERNAL_CONSOLE_OPTIONS_SCHEMA, DebugConfigurationProviderTriggerKind, DebuggerString, IDebugService;
var init_debug = __esm({
  "node_modules/vscode/vscode/src/vs/workbench/contrib/debug/common/debug.js"() {
    init_nls();
    init_contextkey();
    init_instantiation();
    REPL_VIEW_ID = "workbench.panel.repl.view";
    CONTEXT_DEBUG_TYPE = new RawContextKey("debugType", void 0, { type: "string", description: localize(
      "debugType",
      "Debug type of the active debug session. For example 'python'."
    ) });
    CONTEXT_DEBUG_CONFIGURATION_TYPE = new RawContextKey(
      "debugConfigurationType",
      void 0,
      { type: "string", description: localize(
        "debugConfigurationType",
        "Debug type of the selected launch configuration. For example 'python'."
      ) }
    );
    CONTEXT_DEBUG_STATE = new RawContextKey("debugState", "inactive", { type: "string", description: localize(
      "debugState",
      "State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'."
    ) });
    CONTEXT_DEBUG_UX_KEY = "debugUx";
    CONTEXT_DEBUG_UX = new RawContextKey(
      CONTEXT_DEBUG_UX_KEY,
      "default",
      { type: "string", description: localize(
        "debugUX",
        "Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet."
      ) }
    );
    CONTEXT_HAS_DEBUGGED = new RawContextKey("hasDebugged", false, { type: "boolean", description: localize(
      "hasDebugged",
      "True when a debug session has been started at least once, false otherwise."
    ) });
    CONTEXT_IN_DEBUG_MODE = new RawContextKey("inDebugMode", false, { type: "boolean", description: localize("inDebugMode", "True when debugging, false otherwise.") });
    CONTEXT_IN_DEBUG_REPL = new RawContextKey("inDebugRepl", false, { type: "boolean", description: localize("inDebugRepl", "True when focus is in the debug console, false otherwise.") });
    CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new RawContextKey(
      "breakpointWidgetVisible",
      false,
      { type: "boolean", description: localize(
        "breakpointWidgetVisibile",
        "True when breakpoint editor zone widget is visible, false otherwise."
      ) }
    );
    CONTEXT_IN_BREAKPOINT_WIDGET = new RawContextKey(
      "inBreakpointWidget",
      false,
      { type: "boolean", description: localize(
        "inBreakpointWidget",
        "True when focus is in the breakpoint editor zone widget, false otherwise."
      ) }
    );
    CONTEXT_BREAKPOINTS_FOCUSED = new RawContextKey("breakpointsFocused", true, { type: "boolean", description: localize(
      "breakpointsFocused",
      "True when the BREAKPOINTS view is focused, false otherwise."
    ) });
    CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new RawContextKey(
      "watchExpressionsFocused",
      true,
      { type: "boolean", description: localize(
        "watchExpressionsFocused",
        "True when the WATCH view is focused, false otherwsie."
      ) }
    );
    CONTEXT_WATCH_EXPRESSIONS_EXIST = new RawContextKey(
      "watchExpressionsExist",
      false,
      { type: "boolean", description: localize(
        "watchExpressionsExist",
        "True when at least one watch expression exists, false otherwise."
      ) }
    );
    CONTEXT_VARIABLES_FOCUSED = new RawContextKey("variablesFocused", true, { type: "boolean", description: localize(
      "variablesFocused",
      "True when the VARIABLES views is focused, false otherwsie"
    ) });
    CONTEXT_EXPRESSION_SELECTED = new RawContextKey(
      "expressionSelected",
      false,
      { type: "boolean", description: localize(
        "expressionSelected",
        "True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise."
      ) }
    );
    CONTEXT_BREAKPOINT_INPUT_FOCUSED = new RawContextKey(
      "breakpointInputFocused",
      false,
      { type: "boolean", description: localize(
        "breakpointInputFocused",
        "True when the input box has focus in the BREAKPOINTS view."
      ) }
    );
    CONTEXT_CALLSTACK_ITEM_TYPE = new RawContextKey(
      "callStackItemType",
      void 0,
      { type: "string", description: localize(
        "callStackItemType",
        "Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'"
      ) }
    );
    CONTEXT_CALLSTACK_SESSION_IS_ATTACH = new RawContextKey(
      "callStackSessionIsAttach",
      false,
      { type: "boolean", description: localize(
        "callStackSessionIsAttach",
        "True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view."
      ) }
    );
    CONTEXT_CALLSTACK_ITEM_STOPPED = new RawContextKey(
      "callStackItemStopped",
      false,
      { type: "boolean", description: localize(
        "callStackItemStopped",
        "True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view."
      ) }
    );
    CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD = new RawContextKey(
      "callStackSessionHasOneThread",
      false,
      { type: "boolean", description: localize(
        "callStackSessionHasOneThread",
        "True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view."
      ) }
    );
    CONTEXT_WATCH_ITEM_TYPE = new RawContextKey("watchItemType", void 0, { type: "string", description: localize(
      "watchItemType",
      "Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'"
    ) });
    CONTEXT_CAN_VIEW_MEMORY = new RawContextKey("canViewMemory", void 0, { type: "boolean", description: localize(
      "canViewMemory",
      "Indicates whether the item in the view has an associated memory refrence."
    ) });
    CONTEXT_BREAKPOINT_ITEM_TYPE = new RawContextKey(
      "breakpointItemType",
      void 0,
      { type: "string", description: localize(
        "breakpointItemType",
        "Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'"
      ) }
    );
    CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = new RawContextKey(
      "breakpointSupportsCondition",
      false,
      { type: "boolean", description: localize(
        "breakpointSupportsCondition",
        "True when the focused breakpoint supports conditions."
      ) }
    );
    CONTEXT_LOADED_SCRIPTS_SUPPORTED = new RawContextKey(
      "loadedScriptsSupported",
      false,
      { type: "boolean", description: localize(
        "loadedScriptsSupported",
        "True when the focused sessions supports the LOADED SCRIPTS view"
      ) }
    );
    CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new RawContextKey(
      "loadedScriptsItemType",
      void 0,
      { type: "string", description: localize(
        "loadedScriptsItemType",
        "Represents the item type of the focused element in the LOADED SCRIPTS view."
      ) }
    );
    CONTEXT_FOCUSED_SESSION_IS_ATTACH = new RawContextKey(
      "focusedSessionIsAttach",
      false,
      { type: "boolean", description: localize("focusedSessionIsAttach", "True when the focused session is 'attach'.") }
    );
    CONTEXT_STEP_BACK_SUPPORTED = new RawContextKey("stepBackSupported", false, { type: "boolean", description: localize(
      "stepBackSupported",
      "True when the focused session supports 'stepBack' requests."
    ) });
    CONTEXT_RESTART_FRAME_SUPPORTED = new RawContextKey(
      "restartFrameSupported",
      false,
      { type: "boolean", description: localize(
        "restartFrameSupported",
        "True when the focused session supports 'restartFrame' requests."
      ) }
    );
    CONTEXT_STACK_FRAME_SUPPORTS_RESTART = new RawContextKey(
      "stackFrameSupportsRestart",
      false,
      { type: "boolean", description: localize(
        "stackFrameSupportsRestart",
        "True when the focused stack frame suppots 'restartFrame'."
      ) }
    );
    CONTEXT_JUMP_TO_CURSOR_SUPPORTED = new RawContextKey(
      "jumpToCursorSupported",
      false,
      { type: "boolean", description: localize(
        "jumpToCursorSupported",
        "True when the focused session supports 'jumpToCursor' request."
      ) }
    );
    CONTEXT_STEP_INTO_TARGETS_SUPPORTED = new RawContextKey(
      "stepIntoTargetsSupported",
      false,
      { type: "boolean", description: localize(
        "stepIntoTargetsSupported",
        "True when the focused session supports 'stepIntoTargets' request."
      ) }
    );
    CONTEXT_BREAKPOINTS_EXIST = new RawContextKey("breakpointsExist", false, { type: "boolean", description: localize("breakpointsExist", "True when at least one breakpoint exists.") });
    CONTEXT_DEBUGGERS_AVAILABLE = new RawContextKey(
      "debuggersAvailable",
      false,
      { type: "boolean", description: localize(
        "debuggersAvailable",
        "True when there is at least one debug extensions active."
      ) }
    );
    CONTEXT_DEBUG_EXTENSION_AVAILABLE = new RawContextKey(
      "debugExtensionAvailable",
      true,
      { type: "boolean", description: localize(
        "debugExtensionsAvailable",
        "True when there is at least one debug extension installed and enabled."
      ) }
    );
    CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT = new RawContextKey(
      "debugProtocolVariableMenuContext",
      void 0,
      { type: "string", description: localize(
        "debugProtocolVariableMenuContext",
        "Represents the context the debug adapter sets on the focused variable in the VARIABLES view."
      ) }
    );
    CONTEXT_SET_VARIABLE_SUPPORTED = new RawContextKey(
      "debugSetVariableSupported",
      false,
      { type: "boolean", description: localize(
        "debugSetVariableSupported",
        "True when the focused session supports 'setVariable' request."
      ) }
    );
    CONTEXT_SET_EXPRESSION_SUPPORTED = new RawContextKey(
      "debugSetExpressionSupported",
      false,
      { type: "boolean", description: localize(
        "debugSetExpressionSupported",
        "True when the focused session supports 'setExpression' request."
      ) }
    );
    CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED = new RawContextKey(
      "breakWhenValueChangesSupported",
      false,
      { type: "boolean", description: localize(
        "breakWhenValueChangesSupported",
        "True when the focused session supports to break when value changes."
      ) }
    );
    CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED = new RawContextKey(
      "breakWhenValueIsAccessedSupported",
      false,
      { type: "boolean", description: localize(
        "breakWhenValueIsAccessedSupported",
        "True when the focused breakpoint supports to break when value is accessed."
      ) }
    );
    CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED = new RawContextKey(
      "breakWhenValueIsReadSupported",
      false,
      { type: "boolean", description: localize(
        "breakWhenValueIsReadSupported",
        "True when the focused breakpoint supports to break when value is read."
      ) }
    );
    CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = new RawContextKey(
      "terminateDebuggeeSupported",
      false,
      { type: "boolean", description: localize(
        "terminateDebuggeeSupported",
        "True when the focused session supports the terminate debuggee capability."
      ) }
    );
    CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED = new RawContextKey(
      "suspendDebuggeeSupported",
      false,
      { type: "boolean", description: localize(
        "suspendDebuggeeSupported",
        "True when the focused session supports the suspend debuggee capability."
      ) }
    );
    CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT = new RawContextKey(
      "variableEvaluateNamePresent",
      false,
      { type: "boolean", description: localize(
        "variableEvaluateNamePresent",
        "True when the focused variable has an 'evalauteName' field set."
      ) }
    );
    CONTEXT_VARIABLE_IS_READONLY = new RawContextKey(
      "variableIsReadonly",
      false,
      { type: "boolean", description: localize("variableIsReadonly", "True when the focused variable is read-only.") }
    );
    CONTEXT_EXCEPTION_WIDGET_VISIBLE = new RawContextKey(
      "exceptionWidgetVisible",
      false,
      { type: "boolean", description: localize("exceptionWidgetVisible", "True when the exception widget is visible.") }
    );
    CONTEXT_MULTI_SESSION_REPL = new RawContextKey("multiSessionRepl", false, { type: "boolean", description: localize("multiSessionRepl", "True when there is more than 1 debug console.") });
    CONTEXT_MULTI_SESSION_DEBUG = new RawContextKey("multiSessionDebug", false, { type: "boolean", description: localize(
      "multiSessionDebug",
      "True when there is more than 1 active debug session."
    ) });
    CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED = new RawContextKey(
      "disassembleRequestSupported",
      false,
      { type: "boolean", description: localize(
        "disassembleRequestSupported",
        "True when the focused sessions supports disassemble request."
      ) }
    );
    CONTEXT_DISASSEMBLY_VIEW_FOCUS = new RawContextKey(
      "disassemblyViewFocus",
      false,
      { type: "boolean", description: localize("disassemblyViewFocus", "True when the Disassembly View is focused.") }
    );
    CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST = new RawContextKey(
      "languageSupportsDisassembleRequest",
      false,
      { type: "boolean", description: localize(
        "languageSupportsDisassembleRequest",
        "True when the language in the current editor supports disassemble request."
      ) }
    );
    CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE = new RawContextKey(
      "focusedStackFrameHasInstructionReference",
      false,
      { type: "boolean", description: localize(
        "focusedStackFrameHasInstructionReference",
        "True when the focused stack frame has instruction pointer reference."
      ) }
    );
    INTERNAL_CONSOLE_OPTIONS_SCHEMA = {
      enum: ["neverOpen", "openOnSessionStart", "openOnFirstSessionStart"],
      default: "openOnFirstSessionStart",
      description: localize(
        "internalConsoleOptions",
        "Controls when the internal Debug Console should open."
      )
    };
    (function(DebugConfigurationProviderTriggerKind2) {
      DebugConfigurationProviderTriggerKind2[DebugConfigurationProviderTriggerKind2["Initial"] = 1] = "Initial";
      DebugConfigurationProviderTriggerKind2[DebugConfigurationProviderTriggerKind2["Dynamic"] = 2] = "Dynamic";
    })(
      DebugConfigurationProviderTriggerKind || (DebugConfigurationProviderTriggerKind = {})
    );
    (function(DebuggerString2) {
      DebuggerString2["UnverifiedBreakpoints"] = "unverifiedBreakpoints";
    })(DebuggerString || (DebuggerString = {}));
    IDebugService = createDecorator("debugService");
  }
});

// node_modules/vscode/vscode/src/vs/platform/workspace/common/editSessions.js
var IEditSessionIdentityService, EditSessionIdentityMatch;
var init_editSessions = __esm({
  "node_modules/vscode/vscode/src/vs/platform/workspace/common/editSessions.js"() {
    init_instantiation();
    IEditSessionIdentityService = createDecorator("editSessionIdentityService");
    (function(EditSessionIdentityMatch2) {
      EditSessionIdentityMatch2[EditSessionIdentityMatch2["Complete"] = 100] = "Complete";
      EditSessionIdentityMatch2[EditSessionIdentityMatch2["Partial"] = 50] = "Partial";
      EditSessionIdentityMatch2[EditSessionIdentityMatch2["None"] = 0] = "None";
    })(EditSessionIdentityMatch || (EditSessionIdentityMatch = {}));
  }
});

// node_modules/vscode/vscode/src/vs/platform/remote/common/remoteAuthorityResolver.js
function getRemoteAuthorityPrefix(remoteAuthority) {
  const plusIndex = remoteAuthority.indexOf("+");
  if (plusIndex === -1) {
    return remoteAuthority;
  }
  return remoteAuthority.substring(0, plusIndex);
}
var IRemoteAuthorityResolverService, ManagedRemoteConnection, WebSocketRemoteConnection, RemoteAuthorityResolverErrorCode, RemoteAuthorityResolverError;
var init_remoteAuthorityResolver = __esm({
  "node_modules/vscode/vscode/src/vs/platform/remote/common/remoteAuthorityResolver.js"() {
    init_errors();
    init_instantiation();
    IRemoteAuthorityResolverService = createDecorator("remoteAuthorityResolverService");
    ManagedRemoteConnection = class {
      constructor(id) {
        this.id = id;
        this.type = 1;
      }
      toString() {
        return `Managed(${this.id})`;
      }
    };
    WebSocketRemoteConnection = class {
      constructor(host, port) {
        this.host = host;
        this.port = port;
        this.type = 0;
      }
      toString() {
        return `WebSocket(${this.host}:${this.port})`;
      }
    };
    (function(RemoteAuthorityResolverErrorCode2) {
      RemoteAuthorityResolverErrorCode2["Unknown"] = "Unknown";
      RemoteAuthorityResolverErrorCode2["NotAvailable"] = "NotAvailable";
      RemoteAuthorityResolverErrorCode2["TemporarilyNotAvailable"] = "TemporarilyNotAvailable";
      RemoteAuthorityResolverErrorCode2["NoResolverFound"] = "NoResolverFound";
      RemoteAuthorityResolverErrorCode2["InvalidAuthority"] = "InvalidAuthority";
    })(
      RemoteAuthorityResolverErrorCode || (RemoteAuthorityResolverErrorCode = {})
    );
    RemoteAuthorityResolverError = class _RemoteAuthorityResolverError extends ErrorNoTelemetry {
      static isNotAvailable(err) {
        return err instanceof _RemoteAuthorityResolverError && err._code === RemoteAuthorityResolverErrorCode.NotAvailable;
      }
      static isTemporarilyNotAvailable(err) {
        return err instanceof _RemoteAuthorityResolverError && err._code === RemoteAuthorityResolverErrorCode.TemporarilyNotAvailable;
      }
      static isNoResolverFound(err) {
        return err instanceof _RemoteAuthorityResolverError && err._code === RemoteAuthorityResolverErrorCode.NoResolverFound;
      }
      static isInvalidAuthority(err) {
        return err instanceof _RemoteAuthorityResolverError && err._code === RemoteAuthorityResolverErrorCode.InvalidAuthority;
      }
      static isHandled(err) {
        return err instanceof _RemoteAuthorityResolverError && err.isHandled;
      }
      constructor(message, code = RemoteAuthorityResolverErrorCode.Unknown, detail) {
        super(message);
        this._message = message;
        this._code = code;
        this._detail = detail;
        this.isHandled = code === RemoteAuthorityResolverErrorCode.NotAvailable && detail === true;
        Object.setPrototypeOf(this, _RemoteAuthorityResolverError.prototype);
      }
    };
  }
});

// node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookCommon.js
function isTextStreamMime(mimeType) {
  return ["application/vnd.code.notebook.stdout", "application/vnd.code.notebook.stderr"].includes(mimeType);
}
function compressOutputItemStreams(outputs) {
  const buffers = [];
  let startAppending = false;
  for (const output of outputs) {
    if (buffers.length === 0 || startAppending) {
      buffers.push(output);
      startAppending = true;
    }
  }
  let didCompression = compressStreamBuffer(buffers);
  const concatenated = VSBuffer.concat(buffers.map((buffer) => VSBuffer.wrap(buffer)));
  const data = formatStreamText(concatenated);
  didCompression = didCompression || data.byteLength !== concatenated.byteLength;
  return { data, didCompression };
}
function compressStreamBuffer(streams) {
  let didCompress = false;
  streams.forEach((stream, index) => {
    if (index === 0 || stream.length < MOVE_CURSOR_1_LINE_COMMAND.length) {
      return;
    }
    const previousStream = streams[index - 1];
    const command = stream.subarray(0, MOVE_CURSOR_1_LINE_COMMAND.length);
    if (command[0] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[0] && command[1] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[1] && command[2] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[2]) {
      const lastIndexOfLineFeed = previousStream.lastIndexOf(LINE_FEED);
      if (lastIndexOfLineFeed === -1) {
        return;
      }
      didCompress = true;
      streams[index - 1] = previousStream.subarray(0, lastIndexOfLineFeed);
      streams[index] = stream.subarray(MOVE_CURSOR_1_LINE_COMMAND.length);
    }
  });
  return didCompress;
}
function fixBackspace(txt) {
  let tmp = txt;
  do {
    txt = tmp;
    tmp = txt.replace(/[^\n]\x08/gm, "");
  } while (tmp.length < txt.length);
  return txt;
}
function fixCarriageReturn(txt) {
  txt = txt.replace(/\r+\n/gm, "\n");
  while (txt.search(/\r[^$]/g) > -1) {
    const base = txt.match(/^(.*)\r+/m)[1];
    let insert = txt.match(/\r+(.*)$/m)[1];
    insert = insert + base.slice(insert.length, base.length);
    txt = txt.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, insert);
  }
  return txt;
}
function formatStreamText(buffer) {
  if (!buffer.buffer.includes(BACKSPACE_CHARACTER) && !buffer.buffer.includes(CARRIAGE_RETURN_CHARACTER)) {
    return buffer;
  }
  return VSBuffer.fromString(fixCarriageReturn(fixBackspace(textDecoder.decode(buffer.buffer))));
}
var NOTEBOOK_EDITOR_ID, CellKind, NotebookCellExecutionState, NotebookCellsChangeType, SelectionStateType, CellUri, NotebookSetting, _NotebookWorkingCopyTypeIdentifier, NotebookWorkingCopyTypeIdentifier, textDecoder, MOVE_CURSOR_1_LINE_COMMAND, MOVE_CURSOR_1_LINE_COMMAND_BYTES, LINE_FEED, BACKSPACE_CHARACTER, CARRIAGE_RETURN_CHARACTER;
var init_notebookCommon = __esm({
  "node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookCommon.js"() {
    init_buffer();
    init_network();
    NOTEBOOK_EDITOR_ID = "workbench.editor.notebook";
    (function(CellKind2) {
      CellKind2[CellKind2["Markup"] = 1] = "Markup";
      CellKind2[CellKind2["Code"] = 2] = "Code";
    })(CellKind || (CellKind = {}));
    (function(NotebookCellExecutionState2) {
      NotebookCellExecutionState2[NotebookCellExecutionState2["Unconfirmed"] = 1] = "Unconfirmed";
      NotebookCellExecutionState2[NotebookCellExecutionState2["Pending"] = 2] = "Pending";
      NotebookCellExecutionState2[NotebookCellExecutionState2["Executing"] = 3] = "Executing";
    })(NotebookCellExecutionState || (NotebookCellExecutionState = {}));
    (function(NotebookCellsChangeType2) {
      NotebookCellsChangeType2[NotebookCellsChangeType2["ModelChange"] = 1] = "ModelChange";
      NotebookCellsChangeType2[NotebookCellsChangeType2["Move"] = 2] = "Move";
      NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellLanguage"] = 5] = "ChangeCellLanguage";
      NotebookCellsChangeType2[NotebookCellsChangeType2["Initialize"] = 6] = "Initialize";
      NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellMetadata"] = 7] = "ChangeCellMetadata";
      NotebookCellsChangeType2[NotebookCellsChangeType2["Output"] = 8] = "Output";
      NotebookCellsChangeType2[NotebookCellsChangeType2["OutputItem"] = 9] = "OutputItem";
      NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellContent"] = 10] = "ChangeCellContent";
      NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeDocumentMetadata"] = 11] = "ChangeDocumentMetadata";
      NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellInternalMetadata"] = 12] = "ChangeCellInternalMetadata";
      NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellMime"] = 13] = "ChangeCellMime";
      NotebookCellsChangeType2[NotebookCellsChangeType2["Unknown"] = 100] = "Unknown";
    })(NotebookCellsChangeType || (NotebookCellsChangeType = {}));
    (function(SelectionStateType2) {
      SelectionStateType2[SelectionStateType2["Handle"] = 0] = "Handle";
      SelectionStateType2[SelectionStateType2["Index"] = 1] = "Index";
    })(SelectionStateType || (SelectionStateType = {}));
    (function(CellUri2) {
      CellUri2.scheme = Schemas.vscodeNotebookCell;
      const _lengths = ["W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f"];
      const _padRegexp = new RegExp(`^[${_lengths.join("")}]+`);
      const _radix = 7;
      function generate(notebook, handle) {
        const s = handle.toString(_radix);
        const p = s.length < _lengths.length ? _lengths[s.length - 1] : "z";
        const fragment = `${p}${s}s${encodeBase64(VSBuffer.fromString(notebook.scheme), true, true)}`;
        return notebook.with({ scheme: CellUri2.scheme, fragment });
      }
      CellUri2.generate = generate;
      function parse(cell) {
        if (cell.scheme !== CellUri2.scheme) {
          return void 0;
        }
        const idx = cell.fragment.indexOf("s");
        if (idx < 0) {
          return void 0;
        }
        const handle = parseInt(cell.fragment.substring(0, idx).replace(_padRegexp, ""), _radix);
        const _scheme = decodeBase64(cell.fragment.substring(idx + 1)).toString();
        if (isNaN(handle)) {
          return void 0;
        }
        return {
          handle,
          notebook: cell.with({ scheme: _scheme, fragment: null })
        };
      }
      CellUri2.parse = parse;
      function generateCellOutputUri(notebook, outputId) {
        return notebook.with({
          scheme: Schemas.vscodeNotebookCellOutput,
          fragment: `op${outputId ?? ""},${notebook.scheme !== Schemas.file ? notebook.scheme : ""}`
        });
      }
      CellUri2.generateCellOutputUri = generateCellOutputUri;
      function parseCellOutputUri(uri) {
        if (uri.scheme !== Schemas.vscodeNotebookCellOutput) {
          return;
        }
        const match = /^op([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?\,(.*)$/i.exec(uri.fragment);
        if (!match) {
          return void 0;
        }
        const outputId = match[1] && match[1] !== "" ? match[1] : void 0;
        const scheme = match[2];
        return {
          outputId,
          notebook: uri.with({
            scheme: scheme || Schemas.file,
            fragment: null
          })
        };
      }
      CellUri2.parseCellOutputUri = parseCellOutputUri;
      function generateCellPropertyUri(notebook, handle, scheme) {
        return CellUri2.generate(notebook, handle).with({ scheme });
      }
      CellUri2.generateCellPropertyUri = generateCellPropertyUri;
      function parseCellPropertyUri(uri, propertyScheme) {
        if (uri.scheme !== propertyScheme) {
          return void 0;
        }
        return CellUri2.parse(uri.with({ scheme: CellUri2.scheme }));
      }
      CellUri2.parseCellPropertyUri = parseCellPropertyUri;
    })(CellUri || (CellUri = {}));
    NotebookSetting = {
      displayOrder: "notebook.displayOrder",
      cellToolbarLocation: "notebook.cellToolbarLocation",
      cellToolbarVisibility: "notebook.cellToolbarVisibility",
      showCellStatusBar: "notebook.showCellStatusBar",
      textDiffEditorPreview: "notebook.diff.enablePreview",
      diffOverviewRuler: "notebook.diff.overviewRuler",
      experimentalInsertToolbarAlignment: "notebook.experimental.insertToolbarAlignment",
      compactView: "notebook.compactView",
      focusIndicator: "notebook.cellFocusIndicator",
      insertToolbarLocation: "notebook.insertToolbarLocation",
      globalToolbar: "notebook.globalToolbar",
      stickyScroll: "notebook.stickyScroll.enabled",
      undoRedoPerCell: "notebook.undoRedoPerCell",
      consolidatedOutputButton: "notebook.consolidatedOutputButton",
      showFoldingControls: "notebook.showFoldingControls",
      dragAndDropEnabled: "notebook.dragAndDropEnabled",
      cellEditorOptionsCustomizations: "notebook.editorOptionsCustomizations",
      consolidatedRunButton: "notebook.consolidatedRunButton",
      openGettingStarted: "notebook.experimental.openGettingStarted",
      globalToolbarShowLabel: "notebook.globalToolbarShowLabel",
      markupFontSize: "notebook.markup.fontSize",
      interactiveWindowCollapseCodeCells: "interactiveWindow.collapseCellInputCode",
      outputScrollingDeprecated: "notebook.experimental.outputScrolling",
      outputScrolling: "notebook.output.scrolling",
      textOutputLineLimit: "notebook.output.textLineLimit",
      formatOnSave: "notebook.formatOnSave.enabled",
      formatOnCellExecution: "notebook.formatOnCellExecution",
      codeActionsOnSave: "notebook.codeActionsOnSave",
      outputWordWrap: "notebook.output.wordWrap",
      outputLineHeightDeprecated: "notebook.outputLineHeight",
      outputLineHeight: "notebook.output.lineHeight",
      outputFontSizeDeprecated: "notebook.outputFontSize",
      outputFontSize: "notebook.output.fontSize",
      outputFontFamilyDeprecated: "notebook.outputFontFamily",
      outputFontFamily: "notebook.output.fontFamily",
      findScope: "notebook.find.scope",
      logging: "notebook.logging",
      confirmDeleteRunningCell: "notebook.confirmDeleteRunningCell",
      remoteSaving: "notebook.experimental.remoteSave"
    };
    _NotebookWorkingCopyTypeIdentifier = class _NotebookWorkingCopyTypeIdentifier {
      static create(viewType) {
        return `${_NotebookWorkingCopyTypeIdentifier._prefix}${viewType}`;
      }
      static parse(candidate) {
        if (candidate.startsWith(_NotebookWorkingCopyTypeIdentifier._prefix)) {
          return candidate.substring(_NotebookWorkingCopyTypeIdentifier._prefix.length);
        }
        return void 0;
      }
    };
    _NotebookWorkingCopyTypeIdentifier._prefix = "notebook/";
    NotebookWorkingCopyTypeIdentifier = _NotebookWorkingCopyTypeIdentifier;
    textDecoder = new TextDecoder();
    MOVE_CURSOR_1_LINE_COMMAND = `${String.fromCharCode(27)}[A`;
    MOVE_CURSOR_1_LINE_COMMAND_BYTES = MOVE_CURSOR_1_LINE_COMMAND.split("").map((c) => c.charCodeAt(0));
    LINE_FEED = 10;
    BACKSPACE_CHARACTER = "\b".charCodeAt(0);
    CARRIAGE_RETURN_CHARACTER = "\r".charCodeAt(0);
  }
});

export {
  IRemoteAuthorityResolverService,
  ManagedRemoteConnection,
  WebSocketRemoteConnection,
  RemoteAuthorityResolverErrorCode,
  RemoteAuthorityResolverError,
  getRemoteAuthorityPrefix,
  init_remoteAuthorityResolver,
  NOTEBOOK_EDITOR_ID,
  CellKind,
  NotebookCellExecutionState,
  NotebookCellsChangeType,
  SelectionStateType,
  CellUri,
  NotebookSetting,
  isTextStreamMime,
  compressOutputItemStreams,
  init_notebookCommon,
  REPL_VIEW_ID,
  DebugConfigurationProviderTriggerKind,
  IDebugService,
  init_debug,
  IEditSessionIdentityService,
  EditSessionIdentityMatch,
  init_editSessions
};
//# sourceMappingURL=chunk-E2764U5K.js.map
